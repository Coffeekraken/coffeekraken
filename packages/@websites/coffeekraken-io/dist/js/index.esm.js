var __defProp = Object.defineProperty;
var __defNormalProp = (obj2, key, value) => key in obj2 ? __defProp(obj2, key, { enumerable: true, configurable: true, writable: true, value }) : obj2[key] = value;
var __publicField = (obj2, key, value) => {
  __defNormalProp(obj2, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _a2;
function __unique(array) {
  const a3 = array.concat();
  for (let i2 = 0; i2 < a3.length; ++i2) {
    for (let j = i2 + 1; j < a3.length; ++j) {
      if (a3[i2] === a3[j])
        a3.splice(j--, 1);
    }
  }
  return a3;
}
function __pickRandom(array, count = 1) {
  array = __unique(array);
  const items = [];
  if (count > 1) {
    if (count >= array.length) {
      return array;
    }
    for (let i2 = 0; i2 < count; i2++) {
      let item = __pickRandom(array, 1);
      while (items.includes(item)) {
        item = __pickRandom(array, 1);
      }
      items.push(item);
    }
    return items;
  } else if (count === 1) {
    return array[Math.round(Math.random() * (array.length - 1))];
  }
  return array;
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n) {
  var f = n.default;
  if (typeof f == "function") {
    var a3 = function() {
      return f.apply(this, arguments);
    };
    a3.prototype = f.prototype;
  } else
    a3 = {};
  Object.defineProperty(a3, "__esModule", { value: true });
  Object.keys(n).forEach(function(k2) {
    var d4 = Object.getOwnPropertyDescriptor(n, k2);
    Object.defineProperty(a3, k2, d4.get ? d4 : {
      enumerable: true,
      get: function() {
        return n[k2];
      }
    });
  });
  return a3;
}
var md5$1 = { exports: {} };
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var core$1 = { exports: {} };
const __viteBrowserExternal = new Proxy({}, {
  get(_, key) {
    throw new Error(`Module "" has been externalized for browser compatibility. Cannot access ".${key}" in client code.`);
  }
});
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$5 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore)
    return core$1.exports;
  hasRequiredCore = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory();
      }
    })(commonjsGlobal, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined$12) {
        var crypto2;
        if (typeof window !== "undefined" && window.crypto) {
          crypto2 = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto2 = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto2 = globalThis.crypto;
        }
        if (!crypto2 && typeof window !== "undefined" && window.msCrypto) {
          crypto2 = window.msCrypto;
        }
        if (!crypto2 && typeof commonjsGlobal !== "undefined" && commonjsGlobal.crypto) {
          crypto2 = commonjsGlobal.crypto;
        }
        if (!crypto2 && typeof commonjsRequire === "function") {
          try {
            crypto2 = require$$0$5;
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto2) {
            if (typeof crypto2.getRandomValues === "function") {
              try {
                return crypto2.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto2.randomBytes === "function") {
              try {
                return crypto2.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create2 = Object.create || function() {
          function F() {
          }
          return function(obj2) {
            var subtype;
            F.prototype = obj2;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C2 = {};
        var C_lib = C2.lib = {};
        var Base = C_lib.Base = function() {
          return {
            extend: function(overrides) {
              var subtype = create2(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            init: function() {
            },
            mixIn: function(properties2) {
              for (var propertyName in properties2) {
                if (properties2.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties2[propertyName];
                }
              }
              if (properties2.hasOwnProperty("toString")) {
                this.toString = properties2.toString;
              }
            },
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined$12) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i2 = 0; i2 < thatSigBytes; i2++) {
                var thatByte = thatWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
                thisWords[thisSigBytes + i2 >>> 2] |= thatByte << 24 - (thisSigBytes + i2) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          clone: function() {
            var clone2 = Base.clone.call(this);
            clone2.words = this.words.slice(0);
            return clone2;
          },
          random: function(nBytes) {
            var words = [];
            for (var i2 = 0; i2 < nBytes; i2 += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C2.enc = {};
        var Hex = C_enc.Hex = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i2 = 0; i2 < sigBytes; i2++) {
              var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i2 = 0; i2 < hexStrLength; i2 += 2) {
              words[i2 >>> 3] |= parseInt(hexStr.substr(i2, 2), 16) << 24 - i2 % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2++) {
              var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i2 = 0; i2 < latin1StrLength; i2++) {
              words[i2 >>> 2] |= (latin1Str.charCodeAt(i2) & 255) << 24 - i2 % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          _append: function(data2) {
            if (typeof data2 == "string") {
              data2 = Utf8.parse(data2);
            }
            this._data.concat(data2);
            this._nDataBytes += data2.sigBytes;
          },
          _process: function(doFlush) {
            var processedWords;
            var data2 = this._data;
            var dataWords = data2.words;
            var dataSigBytes = data2.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset2 = 0; offset2 < nWordsReady; offset2 += blockSize) {
                this._doProcessBlock(dataWords, offset2);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data2.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          clone: function() {
            var clone2 = Base.clone.call(this);
            clone2._data = this._data.clone();
            return clone2;
          },
          _minBufferSize: 0
        });
        C_lib.Hasher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash2 = this._doFinalize();
            return hash2;
          },
          blockSize: 512 / 32,
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C2.algo = {};
        return C2;
      }(Math);
      return CryptoJS;
    });
  })(core$1);
  return core$1.exports;
}
(function(module, exports) {
  (function(root, factory) {
    {
      module.exports = factory(requireCore());
    }
  })(commonjsGlobal, function(CryptoJS) {
    (function(Math2) {
      var C2 = CryptoJS;
      var C_lib = C2.lib;
      var WordArray = C_lib.WordArray;
      var Hasher = C_lib.Hasher;
      var C_algo = C2.algo;
      var T2 = [];
      (function() {
        for (var i2 = 0; i2 < 64; i2++) {
          T2[i2] = Math2.abs(Math2.sin(i2 + 1)) * 4294967296 | 0;
        }
      })();
      var MD5 = C_algo.MD5 = Hasher.extend({
        _doReset: function() {
          this._hash = new WordArray.init([
            1732584193,
            4023233417,
            2562383102,
            271733878
          ]);
        },
        _doProcessBlock: function(M2, offset2) {
          for (var i2 = 0; i2 < 16; i2++) {
            var offset_i = offset2 + i2;
            var M_offset_i = M2[offset_i];
            M2[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
          }
          var H3 = this._hash.words;
          var M_offset_0 = M2[offset2 + 0];
          var M_offset_1 = M2[offset2 + 1];
          var M_offset_2 = M2[offset2 + 2];
          var M_offset_3 = M2[offset2 + 3];
          var M_offset_4 = M2[offset2 + 4];
          var M_offset_5 = M2[offset2 + 5];
          var M_offset_6 = M2[offset2 + 6];
          var M_offset_7 = M2[offset2 + 7];
          var M_offset_8 = M2[offset2 + 8];
          var M_offset_9 = M2[offset2 + 9];
          var M_offset_10 = M2[offset2 + 10];
          var M_offset_11 = M2[offset2 + 11];
          var M_offset_12 = M2[offset2 + 12];
          var M_offset_13 = M2[offset2 + 13];
          var M_offset_14 = M2[offset2 + 14];
          var M_offset_15 = M2[offset2 + 15];
          var a3 = H3[0];
          var b2 = H3[1];
          var c = H3[2];
          var d4 = H3[3];
          a3 = FF(a3, b2, c, d4, M_offset_0, 7, T2[0]);
          d4 = FF(d4, a3, b2, c, M_offset_1, 12, T2[1]);
          c = FF(c, d4, a3, b2, M_offset_2, 17, T2[2]);
          b2 = FF(b2, c, d4, a3, M_offset_3, 22, T2[3]);
          a3 = FF(a3, b2, c, d4, M_offset_4, 7, T2[4]);
          d4 = FF(d4, a3, b2, c, M_offset_5, 12, T2[5]);
          c = FF(c, d4, a3, b2, M_offset_6, 17, T2[6]);
          b2 = FF(b2, c, d4, a3, M_offset_7, 22, T2[7]);
          a3 = FF(a3, b2, c, d4, M_offset_8, 7, T2[8]);
          d4 = FF(d4, a3, b2, c, M_offset_9, 12, T2[9]);
          c = FF(c, d4, a3, b2, M_offset_10, 17, T2[10]);
          b2 = FF(b2, c, d4, a3, M_offset_11, 22, T2[11]);
          a3 = FF(a3, b2, c, d4, M_offset_12, 7, T2[12]);
          d4 = FF(d4, a3, b2, c, M_offset_13, 12, T2[13]);
          c = FF(c, d4, a3, b2, M_offset_14, 17, T2[14]);
          b2 = FF(b2, c, d4, a3, M_offset_15, 22, T2[15]);
          a3 = GG(a3, b2, c, d4, M_offset_1, 5, T2[16]);
          d4 = GG(d4, a3, b2, c, M_offset_6, 9, T2[17]);
          c = GG(c, d4, a3, b2, M_offset_11, 14, T2[18]);
          b2 = GG(b2, c, d4, a3, M_offset_0, 20, T2[19]);
          a3 = GG(a3, b2, c, d4, M_offset_5, 5, T2[20]);
          d4 = GG(d4, a3, b2, c, M_offset_10, 9, T2[21]);
          c = GG(c, d4, a3, b2, M_offset_15, 14, T2[22]);
          b2 = GG(b2, c, d4, a3, M_offset_4, 20, T2[23]);
          a3 = GG(a3, b2, c, d4, M_offset_9, 5, T2[24]);
          d4 = GG(d4, a3, b2, c, M_offset_14, 9, T2[25]);
          c = GG(c, d4, a3, b2, M_offset_3, 14, T2[26]);
          b2 = GG(b2, c, d4, a3, M_offset_8, 20, T2[27]);
          a3 = GG(a3, b2, c, d4, M_offset_13, 5, T2[28]);
          d4 = GG(d4, a3, b2, c, M_offset_2, 9, T2[29]);
          c = GG(c, d4, a3, b2, M_offset_7, 14, T2[30]);
          b2 = GG(b2, c, d4, a3, M_offset_12, 20, T2[31]);
          a3 = HH2(a3, b2, c, d4, M_offset_5, 4, T2[32]);
          d4 = HH2(d4, a3, b2, c, M_offset_8, 11, T2[33]);
          c = HH2(c, d4, a3, b2, M_offset_11, 16, T2[34]);
          b2 = HH2(b2, c, d4, a3, M_offset_14, 23, T2[35]);
          a3 = HH2(a3, b2, c, d4, M_offset_1, 4, T2[36]);
          d4 = HH2(d4, a3, b2, c, M_offset_4, 11, T2[37]);
          c = HH2(c, d4, a3, b2, M_offset_7, 16, T2[38]);
          b2 = HH2(b2, c, d4, a3, M_offset_10, 23, T2[39]);
          a3 = HH2(a3, b2, c, d4, M_offset_13, 4, T2[40]);
          d4 = HH2(d4, a3, b2, c, M_offset_0, 11, T2[41]);
          c = HH2(c, d4, a3, b2, M_offset_3, 16, T2[42]);
          b2 = HH2(b2, c, d4, a3, M_offset_6, 23, T2[43]);
          a3 = HH2(a3, b2, c, d4, M_offset_9, 4, T2[44]);
          d4 = HH2(d4, a3, b2, c, M_offset_12, 11, T2[45]);
          c = HH2(c, d4, a3, b2, M_offset_15, 16, T2[46]);
          b2 = HH2(b2, c, d4, a3, M_offset_2, 23, T2[47]);
          a3 = II(a3, b2, c, d4, M_offset_0, 6, T2[48]);
          d4 = II(d4, a3, b2, c, M_offset_7, 10, T2[49]);
          c = II(c, d4, a3, b2, M_offset_14, 15, T2[50]);
          b2 = II(b2, c, d4, a3, M_offset_5, 21, T2[51]);
          a3 = II(a3, b2, c, d4, M_offset_12, 6, T2[52]);
          d4 = II(d4, a3, b2, c, M_offset_3, 10, T2[53]);
          c = II(c, d4, a3, b2, M_offset_10, 15, T2[54]);
          b2 = II(b2, c, d4, a3, M_offset_1, 21, T2[55]);
          a3 = II(a3, b2, c, d4, M_offset_8, 6, T2[56]);
          d4 = II(d4, a3, b2, c, M_offset_15, 10, T2[57]);
          c = II(c, d4, a3, b2, M_offset_6, 15, T2[58]);
          b2 = II(b2, c, d4, a3, M_offset_13, 21, T2[59]);
          a3 = II(a3, b2, c, d4, M_offset_4, 6, T2[60]);
          d4 = II(d4, a3, b2, c, M_offset_11, 10, T2[61]);
          c = II(c, d4, a3, b2, M_offset_2, 15, T2[62]);
          b2 = II(b2, c, d4, a3, M_offset_9, 21, T2[63]);
          H3[0] = H3[0] + a3 | 0;
          H3[1] = H3[1] + b2 | 0;
          H3[2] = H3[2] + c | 0;
          H3[3] = H3[3] + d4 | 0;
        },
        _doFinalize: function() {
          var data2 = this._data;
          var dataWords = data2.words;
          var nBitsTotal = this._nDataBytes * 8;
          var nBitsLeft = data2.sigBytes * 8;
          dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
          var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
          var nBitsTotalL = nBitsTotal;
          dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
          dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
          data2.sigBytes = (dataWords.length + 1) * 4;
          this._process();
          var hash2 = this._hash;
          var H3 = hash2.words;
          for (var i2 = 0; i2 < 4; i2++) {
            var H_i = H3[i2];
            H3[i2] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
          }
          return hash2;
        },
        clone: function() {
          var clone2 = Hasher.clone.call(this);
          clone2._hash = this._hash.clone();
          return clone2;
        }
      });
      function FF(a3, b2, c, d4, x2, s2, t) {
        var n = a3 + (b2 & c | ~b2 & d4) + x2 + t;
        return (n << s2 | n >>> 32 - s2) + b2;
      }
      function GG(a3, b2, c, d4, x2, s2, t) {
        var n = a3 + (b2 & d4 | c & ~d4) + x2 + t;
        return (n << s2 | n >>> 32 - s2) + b2;
      }
      function HH2(a3, b2, c, d4, x2, s2, t) {
        var n = a3 + (b2 ^ c ^ d4) + x2 + t;
        return (n << s2 | n >>> 32 - s2) + b2;
      }
      function II(a3, b2, c, d4, x2, s2, t) {
        var n = a3 + (c ^ (b2 | ~d4)) + x2 + t;
        return (n << s2 | n >>> 32 - s2) + b2;
      }
      C2.MD5 = Hasher._createHelper(MD5);
      C2.HmacMD5 = Hasher._createHmacHelper(MD5);
    })(Math);
    return CryptoJS.MD5;
  });
})(md5$1);
const md5 = md5$1.exports;
function __parseString(value) {
  if (typeof value !== "string")
    return value;
  value = value.split("\u2800").join("").trim();
  try {
    return Function(`
            "use strict";
            return (${value});
        `)();
  } catch (e) {
    return value;
  }
}
var ansiStyles$1 = { exports: {} };
var colorName;
var hasRequiredColorName;
function requireColorName() {
  if (hasRequiredColorName)
    return colorName;
  hasRequiredColorName = 1;
  colorName = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };
  return colorName;
}
var conversions;
var hasRequiredConversions;
function requireConversions() {
  if (hasRequiredConversions)
    return conversions;
  hasRequiredConversions = 1;
  const cssKeywords = requireColorName();
  const reverseKeywords = {};
  for (const key of Object.keys(cssKeywords)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
  const convert2 = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  conversions = convert2;
  for (const model of Object.keys(convert2)) {
    if (!("channels" in convert2[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert2[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert2[model].labels.length !== convert2[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    const { channels, labels } = convert2[model];
    delete convert2[model].channels;
    delete convert2[model].labels;
    Object.defineProperty(convert2[model], "channels", { value: channels });
    Object.defineProperty(convert2[model], "labels", { value: labels });
  }
  convert2.rgb.hsl = function(rgb) {
    const r = rgb[0] / 255;
    const g2 = rgb[1] / 255;
    const b2 = rgb[2] / 255;
    const min2 = Math.min(r, g2, b2);
    const max2 = Math.max(r, g2, b2);
    const delta = max2 - min2;
    let h2;
    let s2;
    if (max2 === min2) {
      h2 = 0;
    } else if (r === max2) {
      h2 = (g2 - b2) / delta;
    } else if (g2 === max2) {
      h2 = 2 + (b2 - r) / delta;
    } else if (b2 === max2) {
      h2 = 4 + (r - g2) / delta;
    }
    h2 = Math.min(h2 * 60, 360);
    if (h2 < 0) {
      h2 += 360;
    }
    const l = (min2 + max2) / 2;
    if (max2 === min2) {
      s2 = 0;
    } else if (l <= 0.5) {
      s2 = delta / (max2 + min2);
    } else {
      s2 = delta / (2 - max2 - min2);
    }
    return [h2, s2 * 100, l * 100];
  };
  convert2.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h2;
    let s2;
    const r = rgb[0] / 255;
    const g2 = rgb[1] / 255;
    const b2 = rgb[2] / 255;
    const v = Math.max(r, g2, b2);
    const diff = v - Math.min(r, g2, b2);
    const diffc = function(c) {
      return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h2 = 0;
      s2 = 0;
    } else {
      s2 = diff / v;
      rdif = diffc(r);
      gdif = diffc(g2);
      bdif = diffc(b2);
      if (r === v) {
        h2 = bdif - gdif;
      } else if (g2 === v) {
        h2 = 1 / 3 + rdif - bdif;
      } else if (b2 === v) {
        h2 = 2 / 3 + gdif - rdif;
      }
      if (h2 < 0) {
        h2 += 1;
      } else if (h2 > 1) {
        h2 -= 1;
      }
    }
    return [
      h2 * 360,
      s2 * 100,
      v * 100
    ];
  };
  convert2.rgb.hwb = function(rgb) {
    const r = rgb[0];
    const g2 = rgb[1];
    let b2 = rgb[2];
    const h2 = convert2.rgb.hsl(rgb)[0];
    const w2 = 1 / 255 * Math.min(r, Math.min(g2, b2));
    b2 = 1 - 1 / 255 * Math.max(r, Math.max(g2, b2));
    return [h2, w2 * 100, b2 * 100];
  };
  convert2.rgb.cmyk = function(rgb) {
    const r = rgb[0] / 255;
    const g2 = rgb[1] / 255;
    const b2 = rgb[2] / 255;
    const k2 = Math.min(1 - r, 1 - g2, 1 - b2);
    const c = (1 - r - k2) / (1 - k2) || 0;
    const m2 = (1 - g2 - k2) / (1 - k2) || 0;
    const y = (1 - b2 - k2) / (1 - k2) || 0;
    return [c * 100, m2 * 100, y * 100, k2 * 100];
  };
  function comparativeDistance(x2, y) {
    return (x2[0] - y[0]) ** 2 + (x2[1] - y[1]) ** 2 + (x2[2] - y[2]) ** 2;
  }
  convert2.rgb.keyword = function(rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys(cssKeywords)) {
      const value = cssKeywords[keyword];
      const distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
    return currentClosestKeyword;
  };
  convert2.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert2.rgb.xyz = function(rgb) {
    let r = rgb[0] / 255;
    let g2 = rgb[1] / 255;
    let b2 = rgb[2] / 255;
    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
    g2 = g2 > 0.04045 ? ((g2 + 0.055) / 1.055) ** 2.4 : g2 / 12.92;
    b2 = b2 > 0.04045 ? ((b2 + 0.055) / 1.055) ** 2.4 : b2 / 12.92;
    const x2 = r * 0.4124 + g2 * 0.3576 + b2 * 0.1805;
    const y = r * 0.2126 + g2 * 0.7152 + b2 * 0.0722;
    const z = r * 0.0193 + g2 * 0.1192 + b2 * 0.9505;
    return [x2 * 100, y * 100, z * 100];
  };
  convert2.rgb.lab = function(rgb) {
    const xyz = convert2.rgb.xyz(rgb);
    let x2 = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x2 /= 95.047;
    y /= 100;
    z /= 108.883;
    x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
    y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a3 = 500 * (x2 - y);
    const b2 = 200 * (y - z);
    return [l, a3, b2];
  };
  convert2.hsl.rgb = function(hsl) {
    const h2 = hsl[0] / 360;
    const s2 = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val;
    if (s2 === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s2);
    } else {
      t2 = l + s2 - l * s2;
    }
    const t1 = 2 * l - t2;
    const rgb = [0, 0, 0];
    for (let i2 = 0; i2 < 3; i2++) {
      t3 = h2 + 1 / 3 * -(i2 - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i2] = val * 255;
    }
    return rgb;
  };
  convert2.hsl.hsv = function(hsl) {
    const h2 = hsl[0];
    let s2 = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s2;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s2 *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s2) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s2 / (l + s2);
    return [h2, sv * 100, v * 100];
  };
  convert2.hsv.rgb = function(hsv) {
    const h2 = hsv[0] / 60;
    const s2 = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h2) % 6;
    const f = h2 - Math.floor(h2);
    const p = 255 * v * (1 - s2);
    const q = 255 * v * (1 - s2 * f);
    const t = 255 * v * (1 - s2 * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert2.hsv.hsl = function(hsv) {
    const h2 = hsv[0];
    const s2 = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl2;
    let l;
    l = (2 - s2) * v;
    const lmin = (2 - s2) * vmin;
    sl2 = s2 * vmin;
    sl2 /= lmin <= 1 ? lmin : 2 - lmin;
    sl2 = sl2 || 0;
    l /= 2;
    return [h2, sl2 * 100, l * 100];
  };
  convert2.hwb.rgb = function(hwb) {
    const h2 = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl2 = hwb[2] / 100;
    const ratio = wh + bl2;
    let f;
    if (ratio > 1) {
      wh /= ratio;
      bl2 /= ratio;
    }
    const i2 = Math.floor(6 * h2);
    const v = 1 - bl2;
    f = 6 * h2 - i2;
    if ((i2 & 1) !== 0) {
      f = 1 - f;
    }
    const n = wh + f * (v - wh);
    let r;
    let g2;
    let b2;
    switch (i2) {
      default:
      case 6:
      case 0:
        r = v;
        g2 = n;
        b2 = wh;
        break;
      case 1:
        r = n;
        g2 = v;
        b2 = wh;
        break;
      case 2:
        r = wh;
        g2 = v;
        b2 = n;
        break;
      case 3:
        r = wh;
        g2 = n;
        b2 = v;
        break;
      case 4:
        r = n;
        g2 = wh;
        b2 = v;
        break;
      case 5:
        r = v;
        g2 = wh;
        b2 = n;
        break;
    }
    return [r * 255, g2 * 255, b2 * 255];
  };
  convert2.cmyk.rgb = function(cmyk) {
    const c = cmyk[0] / 100;
    const m2 = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k2 = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k2) + k2);
    const g2 = 1 - Math.min(1, m2 * (1 - k2) + k2);
    const b2 = 1 - Math.min(1, y * (1 - k2) + k2);
    return [r * 255, g2 * 255, b2 * 255];
  };
  convert2.xyz.rgb = function(xyz) {
    const x2 = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g2;
    let b2;
    r = x2 * 3.2406 + y * -1.5372 + z * -0.4986;
    g2 = x2 * -0.9689 + y * 1.8758 + z * 0.0415;
    b2 = x2 * 0.0557 + y * -0.204 + z * 1.057;
    r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
    g2 = g2 > 31308e-7 ? 1.055 * g2 ** (1 / 2.4) - 0.055 : g2 * 12.92;
    b2 = b2 > 31308e-7 ? 1.055 * b2 ** (1 / 2.4) - 0.055 : b2 * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g2 = Math.min(Math.max(0, g2), 1);
    b2 = Math.min(Math.max(0, b2), 1);
    return [r * 255, g2 * 255, b2 * 255];
  };
  convert2.xyz.lab = function(xyz) {
    let x2 = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x2 /= 95.047;
    y /= 100;
    z /= 108.883;
    x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
    y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a3 = 500 * (x2 - y);
    const b2 = 200 * (y - z);
    return [l, a3, b2];
  };
  convert2.lab.xyz = function(lab) {
    const l = lab[0];
    const a3 = lab[1];
    const b2 = lab[2];
    let x2;
    let y;
    let z;
    y = (l + 16) / 116;
    x2 = a3 / 500 + y;
    z = y - b2 / 200;
    const y2 = y ** 3;
    const x22 = x2 ** 3;
    const z2 = z ** 3;
    y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
    x2 = x22 > 8856e-6 ? x22 : (x2 - 16 / 116) / 7.787;
    z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
    x2 *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x2, y, z];
  };
  convert2.lab.lch = function(lab) {
    const l = lab[0];
    const a3 = lab[1];
    const b2 = lab[2];
    let h2;
    const hr2 = Math.atan2(b2, a3);
    h2 = hr2 * 360 / 2 / Math.PI;
    if (h2 < 0) {
      h2 += 360;
    }
    const c = Math.sqrt(a3 * a3 + b2 * b2);
    return [l, c, h2];
  };
  convert2.lch.lab = function(lch) {
    const l = lch[0];
    const c = lch[1];
    const h2 = lch[2];
    const hr2 = h2 / 360 * 2 * Math.PI;
    const a3 = c * Math.cos(hr2);
    const b2 = c * Math.sin(hr2);
    return [l, a3, b2];
  };
  convert2.rgb.ansi16 = function(args, saturation = null) {
    const [r, g2, b2] = args;
    let value = saturation === null ? convert2.rgb.hsv(args)[2] : saturation;
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    let ansi = 30 + (Math.round(b2 / 255) << 2 | Math.round(g2 / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert2.hsv.ansi16 = function(args) {
    return convert2.rgb.ansi16(convert2.hsv.rgb(args), args[2]);
  };
  convert2.rgb.ansi256 = function(args) {
    const r = args[0];
    const g2 = args[1];
    const b2 = args[2];
    if (r === g2 && g2 === b2) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g2 / 255 * 5) + Math.round(b2 / 255 * 5);
    return ansi;
  };
  convert2.ansi16.rgb = function(args) {
    let color2 = args % 10;
    if (color2 === 0 || color2 === 7) {
      if (args > 50) {
        color2 += 3.5;
      }
      color2 = color2 / 10.5 * 255;
      return [color2, color2, color2];
    }
    const mult = (~~(args > 50) + 1) * 0.5;
    const r = (color2 & 1) * mult * 255;
    const g2 = (color2 >> 1 & 1) * mult * 255;
    const b2 = (color2 >> 2 & 1) * mult * 255;
    return [r, g2, b2];
  };
  convert2.ansi256.rgb = function(args) {
    if (args >= 232) {
      const c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    let rem;
    const r = Math.floor(args / 36) / 5 * 255;
    const g2 = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b2 = rem % 6 / 5 * 255;
    return [r, g2, b2];
  };
  convert2.rgb.hex = function(args) {
    const integer2 = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    const string2 = integer2.toString(16).toUpperCase();
    return "000000".substring(string2.length) + string2;
  };
  convert2.hex.rgb = function(args) {
    const match5 = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match5) {
      return [0, 0, 0];
    }
    let colorString = match5[0];
    if (match5[0].length === 3) {
      colorString = colorString.split("").map((char) => {
        return char + char;
      }).join("");
    }
    const integer2 = parseInt(colorString, 16);
    const r = integer2 >> 16 & 255;
    const g2 = integer2 >> 8 & 255;
    const b2 = integer2 & 255;
    return [r, g2, b2];
  };
  convert2.rgb.hcg = function(rgb) {
    const r = rgb[0] / 255;
    const g2 = rgb[1] / 255;
    const b2 = rgb[2] / 255;
    const max2 = Math.max(Math.max(r, g2), b2);
    const min2 = Math.min(Math.min(r, g2), b2);
    const chroma = max2 - min2;
    let grayscale;
    let hue;
    if (chroma < 1) {
      grayscale = min2 / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max2 === r) {
      hue = (g2 - b2) / chroma % 6;
    } else if (max2 === g2) {
      hue = 2 + (b2 - r) / chroma;
    } else {
      hue = 4 + (r - g2) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert2.hsl.hcg = function(hsl) {
    const s2 = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2 * s2 * l : 2 * s2 * (1 - l);
    let f = 0;
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert2.hsv.hcg = function(hsv) {
    const s2 = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s2 * v;
    let f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert2.hcg.rgb = function(hcg) {
    const h2 = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g2 = hcg[2] / 100;
    if (c === 0) {
      return [g2 * 255, g2 * 255, g2 * 255];
    }
    const pure = [0, 0, 0];
    const hi = h2 % 1 * 6;
    const v = hi % 1;
    const w2 = 1 - v;
    let mg2 = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w2;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w2;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w2;
    }
    mg2 = (1 - c) * g2;
    return [
      (c * pure[0] + mg2) * 255,
      (c * pure[1] + mg2) * 255,
      (c * pure[2] + mg2) * 255
    ];
  };
  convert2.hcg.hsv = function(hcg) {
    const c = hcg[1] / 100;
    const g2 = hcg[2] / 100;
    const v = c + g2 * (1 - c);
    let f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert2.hcg.hsl = function(hcg) {
    const c = hcg[1] / 100;
    const g2 = hcg[2] / 100;
    const l = g2 * (1 - c) + 0.5 * c;
    let s2 = 0;
    if (l > 0 && l < 0.5) {
      s2 = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s2 = c / (2 * (1 - l));
    }
    return [hcg[0], s2 * 100, l * 100];
  };
  convert2.hcg.hwb = function(hcg) {
    const c = hcg[1] / 100;
    const g2 = hcg[2] / 100;
    const v = c + g2 * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert2.hwb.hcg = function(hwb) {
    const w2 = hwb[1] / 100;
    const b2 = hwb[2] / 100;
    const v = 1 - b2;
    const c = v - w2;
    let g2 = 0;
    if (c < 1) {
      g2 = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g2 * 100];
  };
  convert2.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert2.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert2.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert2.gray.hsl = function(args) {
    return [0, 0, args[0]];
  };
  convert2.gray.hsv = convert2.gray.hsl;
  convert2.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert2.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert2.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert2.gray.hex = function(gray) {
    const val = Math.round(gray[0] / 100 * 255) & 255;
    const integer2 = (val << 16) + (val << 8) + val;
    const string2 = integer2.toString(16).toUpperCase();
    return "000000".substring(string2.length) + string2;
  };
  convert2.rgb.gray = function(rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
  return conversions;
}
var route;
var hasRequiredRoute;
function requireRoute() {
  if (hasRequiredRoute)
    return route;
  hasRequiredRoute = 1;
  const conversions2 = requireConversions();
  function buildGraph() {
    const graph = {};
    const models = Object.keys(conversions2);
    for (let len = models.length, i2 = 0; i2 < len; i2++) {
      graph[models[i2]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  }
  function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      const current = queue.pop();
      const adjacents = Object.keys(conversions2[current]);
      for (let len = adjacents.length, i2 = 0; i2 < len; i2++) {
        const adjacent = adjacents[i2];
        const node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link(from2, to2) {
    return function(args) {
      return to2(from2(args));
    };
  }
  function wrapConversion(toModel, graph) {
    const path2 = [graph[toModel].parent, toModel];
    let fn2 = conversions2[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path2.unshift(graph[cur].parent);
      fn2 = link(conversions2[graph[cur].parent][cur], fn2);
      cur = graph[cur].parent;
    }
    fn2.conversion = path2;
    return fn2;
  }
  route = function(fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);
    for (let len = models.length, i2 = 0; i2 < len; i2++) {
      const toModel = models[i2];
      const node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
  return route;
}
var colorConvert;
var hasRequiredColorConvert;
function requireColorConvert() {
  if (hasRequiredColorConvert)
    return colorConvert;
  hasRequiredColorConvert = 1;
  const conversions2 = requireConversions();
  const route2 = requireRoute();
  const convert2 = {};
  const models = Object.keys(conversions2);
  function wrapRaw(fn2) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      return fn2(args);
    };
    if ("conversion" in fn2) {
      wrappedFn.conversion = fn2.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn2) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      const result2 = fn2(args);
      if (typeof result2 === "object") {
        for (let len = result2.length, i2 = 0; i2 < len; i2++) {
          result2[i2] = Math.round(result2[i2]);
        }
      }
      return result2;
    };
    if ("conversion" in fn2) {
      wrappedFn.conversion = fn2.conversion;
    }
    return wrappedFn;
  }
  models.forEach((fromModel) => {
    convert2[fromModel] = {};
    Object.defineProperty(convert2[fromModel], "channels", { value: conversions2[fromModel].channels });
    Object.defineProperty(convert2[fromModel], "labels", { value: conversions2[fromModel].labels });
    const routes = route2(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach((toModel) => {
      const fn2 = routes[toModel];
      convert2[fromModel][toModel] = wrapRounded(fn2);
      convert2[fromModel][toModel].raw = wrapRaw(fn2);
    });
  });
  colorConvert = convert2;
  return colorConvert;
}
(function(module) {
  const wrapAnsi16 = (fn2, offset2) => (...args) => {
    const code3 = fn2(...args);
    return `\x1B[${code3 + offset2}m`;
  };
  const wrapAnsi256 = (fn2, offset2) => (...args) => {
    const code3 = fn2(...args);
    return `\x1B[${38 + offset2};5;${code3}m`;
  };
  const wrapAnsi16m = (fn2, offset2) => (...args) => {
    const rgb = fn2(...args);
    return `\x1B[${38 + offset2};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };
  const ansi2ansi = (n) => n;
  const rgb2rgb = (r, g2, b2) => [r, g2, b2];
  const setLazyProperty = (object, property, get2) => {
    Object.defineProperty(object, property, {
      get: () => {
        const value = get2();
        Object.defineProperty(object, property, {
          value,
          enumerable: true,
          configurable: true
        });
        return value;
      },
      enumerable: true,
      configurable: true
    });
  };
  let colorConvert2;
  const makeDynamicStyles = (wrap2, targetSpace, identity2, isBackground) => {
    if (colorConvert2 === void 0) {
      colorConvert2 = requireColorConvert();
    }
    const offset2 = isBackground ? 10 : 0;
    const styles2 = {};
    for (const [sourceSpace, suite] of Object.entries(colorConvert2)) {
      const name2 = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
      if (sourceSpace === targetSpace) {
        styles2[name2] = wrap2(identity2, offset2);
      } else if (typeof suite === "object") {
        styles2[name2] = wrap2(suite[targetSpace], offset2);
      }
    }
    return styles2;
  };
  function assembleStyles() {
    const codes = /* @__PURE__ */ new Map();
    const styles2 = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles2.color.gray = styles2.color.blackBright;
    styles2.bgColor.bgGray = styles2.bgColor.bgBlackBright;
    styles2.color.grey = styles2.color.blackBright;
    styles2.bgColor.bgGrey = styles2.bgColor.bgBlackBright;
    for (const [groupName, group] of Object.entries(styles2)) {
      for (const [styleName, style] of Object.entries(group)) {
        styles2[styleName] = {
          open: `\x1B[${style[0]}m`,
          close: `\x1B[${style[1]}m`
        };
        group[styleName] = styles2[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles2, groupName, {
        value: group,
        enumerable: false
      });
    }
    Object.defineProperty(styles2, "codes", {
      value: codes,
      enumerable: false
    });
    styles2.color.close = "\x1B[39m";
    styles2.bgColor.close = "\x1B[49m";
    setLazyProperty(styles2.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
    setLazyProperty(styles2.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
    setLazyProperty(styles2.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
    setLazyProperty(styles2.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
    setLazyProperty(styles2.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
    setLazyProperty(styles2.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
    return styles2;
  }
  Object.defineProperty(module, "exports", {
    enumerable: true,
    get: assembleStyles
  });
})(ansiStyles$1);
var browser = {
  stdout: false,
  stderr: false
};
const stringReplaceAll$1 = (string2, substring, replacer) => {
  let index = string2.indexOf(substring);
  if (index === -1) {
    return string2;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string2.substr(endIndex, index - endIndex) + substring + replacer;
    endIndex = index + substringLength;
    index = string2.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string2.substr(endIndex);
  return returnValue;
};
const stringEncaseCRLFWithFirstIndex$1 = (string2, prefix, postfix, index) => {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string2[index - 1] === "\r";
    returnValue += string2.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
    endIndex = index + 1;
    index = string2.indexOf("\n", endIndex);
  } while (index !== -1);
  returnValue += string2.substr(endIndex);
  return returnValue;
};
var util$2 = {
  stringReplaceAll: stringReplaceAll$1,
  stringEncaseCRLFWithFirstIndex: stringEncaseCRLFWithFirstIndex$1
};
var templates;
var hasRequiredTemplates;
function requireTemplates() {
  if (hasRequiredTemplates)
    return templates;
  hasRequiredTemplates = 1;
  const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
  const ESCAPES = /* @__PURE__ */ new Map([
    ["n", "\n"],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", "\x1B"],
    ["a", "\x07"]
  ]);
  function unescape2(c) {
    const u = c[0] === "u";
    const bracket = c[1] === "{";
    if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
      return String.fromCharCode(parseInt(c.slice(1), 16));
    }
    if (u && bracket) {
      return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
    }
    return ESCAPES.get(c) || c;
  }
  function parseArguments(name2, arguments_) {
    const results = [];
    const chunks = arguments_.trim().split(/\s*,\s*/g);
    let matches;
    for (const chunk of chunks) {
      const number2 = Number(chunk);
      if (!Number.isNaN(number2)) {
        results.push(number2);
      } else if (matches = chunk.match(STRING_REGEX)) {
        results.push(matches[2].replace(ESCAPE_REGEX, (m2, escape2, character) => escape2 ? unescape2(escape2) : character));
      } else {
        throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name2}')`);
      }
    }
    return results;
  }
  function parseStyle(style) {
    STYLE_REGEX.lastIndex = 0;
    const results = [];
    let matches;
    while ((matches = STYLE_REGEX.exec(style)) !== null) {
      const name2 = matches[1];
      if (matches[2]) {
        const args = parseArguments(name2, matches[2]);
        results.push([name2].concat(args));
      } else {
        results.push([name2]);
      }
    }
    return results;
  }
  function buildStyle(chalk2, styles2) {
    const enabled = {};
    for (const layer of styles2) {
      for (const style of layer.styles) {
        enabled[style[0]] = layer.inverse ? null : style.slice(1);
      }
    }
    let current = chalk2;
    for (const [styleName, styles3] of Object.entries(enabled)) {
      if (!Array.isArray(styles3)) {
        continue;
      }
      if (!(styleName in current)) {
        throw new Error(`Unknown Chalk style: ${styleName}`);
      }
      current = styles3.length > 0 ? current[styleName](...styles3) : current[styleName];
    }
    return current;
  }
  templates = (chalk2, temporary) => {
    const styles2 = [];
    const chunks = [];
    let chunk = [];
    temporary.replace(TEMPLATE_REGEX, (m2, escapeCharacter, inverse, style, close, character) => {
      if (escapeCharacter) {
        chunk.push(unescape2(escapeCharacter));
      } else if (style) {
        const string2 = chunk.join("");
        chunk = [];
        chunks.push(styles2.length === 0 ? string2 : buildStyle(chalk2, styles2)(string2));
        styles2.push({ inverse, styles: parseStyle(style) });
      } else if (close) {
        if (styles2.length === 0) {
          throw new Error("Found extraneous } in Chalk template literal");
        }
        chunks.push(buildStyle(chalk2, styles2)(chunk.join("")));
        chunk = [];
        styles2.pop();
      } else {
        chunk.push(character);
      }
    });
    chunks.push(chunk.join(""));
    if (styles2.length > 0) {
      const errMessage = `Chalk template literal is missing ${styles2.length} closing bracket${styles2.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(errMessage);
    }
    return chunks.join("");
  };
  return templates;
}
const ansiStyles = ansiStyles$1.exports;
const { stdout: stdoutColor, stderr: stderrColor } = browser;
const {
  stringReplaceAll,
  stringEncaseCRLFWithFirstIndex
} = util$2;
const { isArray: isArray$6 } = Array;
const levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
const styles = /* @__PURE__ */ Object.create(null);
const applyOptions = (object, options = {}) => {
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === void 0 ? colorLevel : options.level;
};
class ChalkClass {
  constructor(options) {
    return chalkFactory(options);
  }
}
const chalkFactory = (options) => {
  const chalk2 = {};
  applyOptions(chalk2, options);
  chalk2.template = (...arguments_) => chalkTag(chalk2.template, ...arguments_);
  Object.setPrototypeOf(chalk2, Chalk.prototype);
  Object.setPrototypeOf(chalk2.template, chalk2);
  chalk2.template.constructor = () => {
    throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
  };
  chalk2.template.Instance = ChalkClass;
  return chalk2.template;
};
function Chalk(options) {
  return chalkFactory(options);
}
for (const [styleName, style] of Object.entries(ansiStyles)) {
  styles[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    }
  };
}
styles.visible = {
  get() {
    const builder = createBuilder(this, this._styler, true);
    Object.defineProperty(this, "visible", { value: builder });
    return builder;
  }
};
const usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
for (const model of usedModels) {
  styles[model] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
        return createBuilder(this, styler, this._isEmpty);
      };
    }
  };
}
for (const model of usedModels) {
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles[bgModel] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
        return createBuilder(this, styler, this._isEmpty);
      };
    }
  };
}
const proto = Object.defineProperties(() => {
}, {
  ...styles,
  level: {
    enumerable: true,
    get() {
      return this._generator.level;
    },
    set(level) {
      this._generator.level = level;
    }
  }
});
const createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === void 0) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
};
const createBuilder = (self2, _styler, _isEmpty) => {
  const builder = (...arguments_) => {
    if (isArray$6(arguments_[0]) && isArray$6(arguments_[0].raw)) {
      return applyStyle(builder, chalkTag(builder, ...arguments_));
    }
    return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  };
  Object.setPrototypeOf(builder, proto);
  builder._generator = self2;
  builder._styler = _styler;
  builder._isEmpty = _isEmpty;
  return builder;
};
const applyStyle = (self2, string2) => {
  if (self2.level <= 0 || !string2) {
    return self2._isEmpty ? "" : string2;
  }
  let styler = self2._styler;
  if (styler === void 0) {
    return string2;
  }
  const { openAll, closeAll } = styler;
  if (string2.indexOf("\x1B") !== -1) {
    while (styler !== void 0) {
      string2 = stringReplaceAll(string2, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string2.indexOf("\n");
  if (lfIndex !== -1) {
    string2 = stringEncaseCRLFWithFirstIndex(string2, closeAll, openAll, lfIndex);
  }
  return openAll + string2 + closeAll;
};
let template;
const chalkTag = (chalk2, ...strings) => {
  const [firstString] = strings;
  if (!isArray$6(firstString) || !isArray$6(firstString.raw)) {
    return strings.join(" ");
  }
  const arguments_ = strings.slice(1);
  const parts = [firstString.raw[0]];
  for (let i2 = 1; i2 < firstString.length; i2++) {
    parts.push(
      String(arguments_[i2 - 1]).replace(/[{}\\]/g, "\\$&"),
      String(firstString.raw[i2])
    );
  }
  if (template === void 0) {
    template = requireTemplates();
  }
  return template(chalk2, parts.join(""));
};
Object.defineProperties(Chalk.prototype, styles);
const chalk = Chalk();
chalk.supportsColor = stdoutColor;
chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
chalk.stderr.supportsColor = stderrColor;
var source$1 = chalk;
function __mapToObject(map2) {
  const obj2 = {};
  for (const [k2, v] of map2)
    obj2[k2] = v;
  return obj2;
}
function __isArray(value) {
  return Array.isArray(value);
}
function __isBoolean(value) {
  return typeof value === "boolean";
}
function __isFunction(value) {
  return value && {}.toString.call(value) === "[object Function]";
}
function __isJson(value) {
  try {
    const res = JSON.parse(value);
    if (Object.keys(res).length)
      return true;
    return false;
  } catch (e) {
    return false;
  }
  return true;
}
function __isMap(value) {
  return value instanceof Map;
}
function __isObject(value) {
  return value && typeof value === "object" && value.constructor === Object;
}
function __isClassInstance(object) {
  if (!object)
    return false;
  if (typeof object !== "object")
    return false;
  if (object.constructor && object.constructor.name === "Object")
    return false;
  if (Object.prototype.toString.call(object) === "[object Object]")
    return false;
  if (object.constructor === Object)
    return false;
  return true;
}
function __isPlainObject(object) {
  if (!object)
    return false;
  if (typeof object !== "object")
    return false;
  if (object.constructor && object.constructor.name !== "Object")
    return false;
  if (Object.prototype.toString.call(object) !== "[object Object]")
    return false;
  if (object !== Object(object))
    return false;
  return true;
}
function __deepMerge(...args) {
  function merge2(firstObj, secondObj) {
    const newObj = {};
    if (!firstObj && secondObj)
      return secondObj;
    if (!secondObj && firstObj)
      return firstObj;
    if (!firstObj && !secondObj)
      return {};
    const firstProps = Object.getOwnPropertyNames(firstObj);
    firstProps.forEach((key) => {
      const desc = Object.getOwnPropertyDescriptor(firstObj, key);
      if (desc.set || desc.get) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = firstObj[key];
      }
    });
    const secondProps = Object.getOwnPropertyNames(secondObj);
    secondProps.forEach((key) => {
      const secondObjDesc = Object.getOwnPropertyDescriptor(secondObj, key);
      if (secondObjDesc.set || secondObjDesc.get) {
        Object.defineProperty(newObj, key, secondObjDesc);
      } else if (__isPlainObject(newObj[key]) && __isPlainObject(secondObj[key])) {
        newObj[key] = merge2(newObj[key], secondObj[key]);
      } else {
        newObj[key] = secondObj[key];
      }
    });
    return newObj;
  }
  let currentObj = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMergeObj = args[i2];
    currentObj = merge2(currentObj, toMergeObj);
  }
  return currentObj;
}
function __deepMap(objectOrArray, processor, settings = {}, _path = []) {
  settings = __deepMerge({
    classInstances: false,
    array: true,
    privateProps: false,
    cloneFirst: false
  }, settings);
  const isArray2 = Array.isArray(objectOrArray);
  let newObject = isArray2 ? [] : settings.cloneFirst ? Object.assign({}, objectOrArray) : objectOrArray;
  Object.keys(objectOrArray).forEach((prop) => {
    if (!settings.privateProps && prop.match(/^_/))
      return;
    if (__isPlainObject(objectOrArray[prop]) || __isClassInstance(objectOrArray[prop]) && settings.classInstances || Array.isArray(objectOrArray[prop]) && settings.array) {
      const res2 = __deepMap(objectOrArray[prop], processor, settings, [
        ..._path,
        prop
      ]);
      if (isArray2) {
        newObject.push(res2);
      } else {
        if (prop === "..." && __isPlainObject(res2)) {
          newObject = Object.assign(Object.assign({}, newObject), res2);
        } else {
          newObject[prop] = res2;
        }
      }
      return;
    }
    const res = processor({
      object: objectOrArray,
      prop,
      value: objectOrArray[prop],
      path: [..._path, prop].join(".")
    });
    if (res === -1) {
      delete objectOrArray[prop];
      return;
    }
    if (isArray2) {
      newObject.push(res);
    } else {
      if (prop === "..." && __isPlainObject(res)) {
        newObject = Object.assign(Object.assign({}, newObject), res);
      } else {
        newObject[prop] = res;
      }
    }
  });
  return newObject;
}
var decycle_1;
const isArray$5 = (e) => Array.isArray(e), isObject$5 = (e) => "Object" === Object.prototype.toString.call(e).slice(8, -1), validate$1 = (e) => {
  if (void 0 === e)
    throw new Error("This method requires one parameter");
  if (!isArray$5(e) && !isObject$5(e))
    throw new TypeError("This method only accepts arrays and objects");
}, findRef = (e, r) => Object.keys(r).find((a3) => r[a3] === e), decycle = (e) => {
  validate$1(e);
  let r = {};
  const a3 = (e2, c = "$") => {
    const s2 = findRef(e2, r);
    return s2 ? { $ref: s2 } : isArray$5(e2) || isObject$5(e2) ? (r[c] = e2, isArray$5(e2) ? e2.map((e3, r2) => a3(e3, `${c}[${r2}]`)) : Object.keys(e2).reduce((r2, s3) => (r2[s3] = a3(e2[s3], `${c}.${s3}`), r2), {})) : e2;
  };
  return a3(e);
};
decycle_1 = decycle;
function fn$3(value, settings = {}) {
  settings = __deepMerge({
    beautify: true,
    highlight: true,
    verbose: true,
    theme: {
      number: source$1.yellow,
      default: source$1.white,
      keyword: source$1.blue,
      regexp: source$1.red,
      string: source$1.whiteBright,
      class: source$1.yellow,
      function: source$1.yellow,
      comment: source$1.gray,
      variable: source$1.red,
      attr: source$1.green
    }
  }, settings);
  if (typeof value === "string")
    return value;
  if (value === null)
    return null;
  if (value === void 0)
    return void 0;
  if (value instanceof Error) {
    const errorStr = value.toString();
    const stackStr = value.stack;
    const messageStr = value.message;
    if (settings.verbose) {
      return [
        `<red>${value.constructor.name || "Error"}</red>`,
        "",
        messageStr,
        "",
        stackStr
      ].join("\n");
    }
    return errorStr;
  }
  if (__isMap(value)) {
    value = __mapToObject(value);
  }
  if (__isObject(value) || __isArray(value) || __isJson(value)) {
    try {
      value = decycle_1(value);
    } catch (e) {
    }
    value = __deepMap(value, ({ value: value2 }) => {
      if (value2 instanceof Map)
        return __mapToObject(value2);
      return value2;
    });
    let prettyString = JSON.stringify(value, null, settings.beautify ? 4 : 0);
    prettyString = prettyString.replace(/"([^"]+)":/g, "$1:").replace(/\uFFFF/g, '\\"');
    if (settings.highlight)
      ;
    return prettyString;
  }
  if (__isBoolean(value)) {
    if (value)
      return "true";
    else
      return "false";
  }
  if (__isFunction(value)) {
    return "" + value;
  }
  let returnString = "";
  try {
    value = decycle_1(value);
    returnString = JSON.stringify(value, null, settings.beautify ? 4 : 0);
  } catch (e) {
    try {
      returnString = value.toString();
    } catch (e2) {
      returnString = value;
    }
  }
  return returnString;
}
const __encryptedMessages = {};
const __md5 = {
  encrypt: function(message) {
    if (typeof message !== "string")
      message = fn$3(message);
    const string2 = md5(message).toString();
    __encryptedMessages[string2] = message;
    return string2;
  },
  decrypt: function(message) {
    if (!__encryptedMessages[message]) {
      console.warn(`The message "${message}" cannot be decrypted...`);
      return;
    }
    const string2 = __encryptedMessages[message];
    delete __encryptedMessages[message];
    return __parseString(string2);
  }
};
function availableColors(settings) {
  settings = Object.assign({ excludeBasics: false }, settings !== null && settings !== void 0 ? settings : {});
  const _colors = [
    "yellow",
    "cyan",
    "green",
    "magenta",
    "blue",
    "red",
    "grey",
    "gray"
  ];
  let colors = _colors;
  if (settings.excludeBasics) {
    colors = _colors.filter((c) => {
      return c !== "white" && c !== "black" && c !== "grey" && c !== "gray";
    });
  }
  return colors;
}
const _colorUsedByScope = {};
const _colorsStack = {};
function getColorFor(ref, settings) {
  settings = __deepMerge({
    scope: "default",
    excludeBasics: true
  }, settings !== null && settings !== void 0 ? settings : {});
  const availableColors$1 = availableColors(settings);
  const scopeId = __md5.encrypt(settings.scope);
  const refId = __md5.encrypt(ref);
  if (_colorsStack[`${scopeId}.${refId}`])
    return _colorsStack[`${scopeId}.${refId}`];
  if (!_colorUsedByScope[scopeId])
    _colorUsedByScope[scopeId] = [];
  if (_colorUsedByScope[scopeId].length >= availableColors$1.length) {
    const color2 = __pickRandom(availableColors$1);
    _colorsStack[`${scopeId}.${refId}`] = color2;
    return color2;
  } else {
    for (let i2 = 0; i2 < availableColors$1.length; i2++) {
      if (_colorUsedByScope[scopeId].indexOf(availableColors$1[i2]) === -1) {
        _colorUsedByScope[scopeId].push(availableColors$1[i2]);
        _colorsStack[`${scopeId}.${refId}`] = availableColors$1[i2];
        return availableColors$1[i2];
      }
    }
  }
}
function __unquote(string2, quotesToRemove = ['"', "'", "\u201D", "`"]) {
  string2 = string2.trim();
  quotesToRemove.forEach((quote) => {
    if (string2.substr(0, 1) === quote && string2.substr(-1) === quote) {
      string2 = string2.substr(1);
      string2 = string2.substr(0, string2.length - 1);
      return;
    }
  });
  return string2;
}
globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(uuid) {
  return typeof uuid === "string" && REGEX.test(uuid);
}
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).substr(1));
}
function stringify(arr) {
  var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
  if (!validate(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
function v4(options, buf, offset2) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset2 = offset2 || 0;
    for (var i2 = 0; i2 < 16; ++i2) {
      buf[offset2 + i2] = rnds[i2];
    }
    return buf;
  }
  return stringify(rnds);
}
function __uniqid() {
  return v4();
}
function __proxyArray(array) {
  if (array.__$proxied)
    return array;
  const watchStack = {};
  Object.defineProperty(array, "__$proxied", {
    value: true,
    enumerable: false,
    writable: false
  });
  function _proxyMethod(name2, ...args) {
    const handlersStack = [];
    Object.keys(watchStack).forEach((watchId) => {
      const watch = watchStack[watchId];
      if (watch.methods.indexOf(name2) === -1)
        return;
      handlersStack.push({
        handlerFn: watch.handlerFn,
        watchObj: {
          oldValue: [...array],
          action: `${name2}`,
          fullAction: `Array.${name2}`,
          args
        }
      });
    });
    const returnValue = Array.prototype[name2].call(array, ...args);
    handlersStack.forEach((handlerObj) => {
      handlerObj.watchObj = Object.assign(Object.assign({}, handlerObj.watchObj), { value: array, returnedValue: returnValue });
      handlerObj.handlerFn(handlerObj.watchObj);
    });
    return returnValue;
  }
  Object.getOwnPropertyNames(Array.prototype).forEach((methodName) => {
    const unProxyMethods = ["length", "constructor"];
    if (unProxyMethods.indexOf(methodName) !== -1)
      return;
    Object.defineProperty(array, methodName, {
      writable: false,
      configurable: false,
      enumerable: false,
      value: (...args) => {
        return _proxyMethod(methodName, ...args);
      }
    });
  });
  Object.defineProperty(array, "watch", {
    writable: false,
    configurable: false,
    enumerable: false,
    value: (methods, handlerFn) => {
      const watchId = __uniqid();
      watchStack[watchId] = {
        methods,
        handlerFn
      };
      return watchId;
    }
  });
  Object.defineProperty(array, "unwatch", {
    writable: false,
    configurable: false,
    enumerable: false,
    value: (watchId) => {
      delete watchStack[watchId];
    }
  });
  return array;
}
function get(obj2, path2, settings = {}) {
  settings = Object.assign({}, settings);
  if (Array.isArray(path2)) {
    return __get(obj2, path2, settings);
  }
  if (obj2[path2] !== void 0)
    return obj2[path2];
  if (!path2 || path2 === "" || path2 === ".")
    return obj2;
  path2 = path2.replace(/\[(\w+)\]/g, ".$1");
  path2 = path2.replace(/\\\./g, "_dot_");
  path2 = path2.replace(/^\./, "");
  let potentialPaths = [path2.replace(/\?/gm, "")];
  const parts = path2.split(".");
  for (let i2 = parts.length - 1; i2 >= 0; i2--) {
    const part = parts[i2];
    if (part.match(/\?$/)) {
      const before = parts.slice(0, i2);
      const after = parts.slice(i2 + 1);
      potentialPaths.push([...before, ...after].join("."));
      potentialPaths.push([...before, ...after.filter((a3) => !a3.match(/\?$/))].join("."));
    }
  }
  potentialPaths = __unique(potentialPaths.map((s2) => s2.replace(/\?/gm, "")));
  for (let i2 = 0; i2 < potentialPaths.length; i2++) {
    const path3 = potentialPaths[i2];
    const result2 = __get(obj2, path3, settings);
    if (result2 !== void 0)
      return result2;
  }
}
function __get(obj2, path2, settings = {}) {
  settings = Object.assign({}, settings);
  let o = obj2, a3;
  if (typeof path2 === "string") {
    if (obj2[path2] !== void 0)
      return obj2[path2];
    if (!path2 || path2 === "" || path2 === ".")
      return obj2;
    path2 = path2.split(/(?!\B"[^"]*)\.(?![^"]*"\B)/gm);
  }
  a3 = [...path2].map((p) => {
    if (typeof p === "string")
      return __unquote(p);
    return p;
  });
  while (a3.length) {
    let n = a3.shift();
    if (typeof n === "string") {
      n = n.replace(/\?$/, "");
    }
    if (typeof o !== "object" || !(o && n in o)) {
      return;
    }
    o = o[n];
  }
  return o;
}
function __set(obj2, path2, value, settings = {}) {
  settings = Object.assign({}, settings);
  let o = obj2, a3;
  if (typeof path2 === "string") {
    if (!path2 || path2 === "" || path2 === ".") {
      obj2 = value;
      return;
    }
    path2 = path2.replace(/\[(\w+)\]/g, ".[$1]");
    a3 = __unquote(path2).split(/(?!\B"[^"]*)\.(?![^"]*"\B)/gm).map((p) => __unquote(p));
  } else if (Array.isArray(path2)) {
    a3 = [...path2];
  }
  while (a3.length - 1) {
    const n = a3.shift();
    if (!(n in o)) {
      if (typeof a3[0] === "string") {
        if (a3[0].match(/^\[[0-9]+\]$/))
          o[n] = [];
        else
          o[n] = {};
      } else {
        o[n] = {};
      }
    }
    if (!o[n]) {
      o[n] = {};
    }
    o = o[n];
  }
  if (typeof a3[0] === "string" && a3[0].match(/^\[[0-9]+\]$/)) {
    if (!Array.isArray(o))
      o = [];
    o.push(value);
  } else {
    o[a3[0]] = value;
  }
  return get(obj2, path2);
}
function __toJson(object) {
  const newObj = {};
  __deepMap(object, ({ value, path: path2 }) => {
    __set(newObj, path2, value);
    return value;
  }, {
    privateProps: false,
    classInstances: true
  });
  return newObj;
}
class SClass {
  constructor(settings = {}) {
    this.settings = {};
    setSettings(this, settings);
    this.metas = getMetas(this);
    Object.defineProperty(this, "metas", {
      enumerable: true,
      value: getMetas(this)
    });
  }
  static extends(Cls) {
    class SClass2 extends Cls {
      constructor(settings, ...args) {
        super(...args);
        this.settings = {};
        setSettings(this, settings);
        this.metas = getMetas(this);
        Object.defineProperty(this, "metas", {
          enumerable: true,
          value: getMetas(this)
        });
      }
      expose(instance, settings) {
        return expose(this, instance, settings);
      }
      toPlainObject() {
        return toPlainObject(this);
      }
    }
    return SClass2;
  }
  expose(instance, settings) {
    return expose(this, instance, settings);
  }
  toPlainObject() {
    return toPlainObject(this);
  }
}
function getMetas(ctx) {
  var _a3, _b2, _c2, _d2, _e2, _f2, _g, _h;
  let name2 = `<yellow>${((_a3 = ctx.settings.metas) === null || _a3 === void 0 ? void 0 : _a3.name) || ""}</yellow>`;
  if ((_b2 = ctx.settings.metas) === null || _b2 === void 0 ? void 0 : _b2.id) {
    name2 += ` <cyan>${ctx.settings.metas.id}</cyan>`;
  }
  const metasObj = {
    id: (_d2 = (_c2 = ctx.settings.metas) === null || _c2 === void 0 ? void 0 : _c2.id) !== null && _d2 !== void 0 ? _d2 : ctx.constructor.name,
    name: (_f2 = (_e2 = ctx.settings.metas) === null || _e2 === void 0 ? void 0 : _e2.name) !== null && _f2 !== void 0 ? _f2 : ctx.constructor.name,
    formattedName: name2,
    color: (_h = (_g = ctx.settings.metas) === null || _g === void 0 ? void 0 : _g.color) !== null && _h !== void 0 ? _h : "yellow"
  };
  return metasObj;
}
function expose(ctx, instance, settings) {
  var _a3;
  settings = __deepMerge({
    as: void 0,
    props: []
  }, settings);
  if (settings.as && typeof settings.as === "string") {
    ctx[settings.as] = instance;
  }
  (_a3 = settings === null || settings === void 0 ? void 0 : settings.props) === null || _a3 === void 0 ? void 0 : _a3.forEach((prop) => {
    if (instance[prop].bind && typeof instance[prop].bind === "function") {
      ctx[prop] = instance[prop].bind(instance);
    } else {
      ctx[prop] = instance[prop];
    }
  });
}
function toPlainObject(ctx) {
  return __toJson(ctx);
}
function setSettings(ctx, settings = {}) {
  var _a3;
  ctx.settings = settings;
  if (!ctx.settings.metas)
    ctx.settings.metas = {};
  if (!((_a3 = ctx.settings.metas) === null || _a3 === void 0 ? void 0 : _a3.id))
    ctx.settings.metas.id = ctx.constructor.name;
  if (!ctx.constructor.name.match(/^SConfig/)) {
    if (!ctx.settings.metas.color)
      ctx.settings.metas.color = getColorFor(ctx.constructor.name, {
        scope: "class"
      });
  } else if (!ctx.settings.metas.color)
    ctx.settings.metas.color = "yellow";
}
const ruleObj$3 = {
  name: "Max",
  id: "max",
  settings: {},
  accept: "Number",
  message: (resultObj) => {
    return `This value has to be maximum "<yellow>${resultObj.max}</yellow>". Received "<red>${resultObj.received}</red>"`;
  },
  processParams: (params) => {
    return { value: params };
  },
  apply: (value, params, ruleSettings, settings) => {
    if (value > params.value) {
      return new Error(`<red>[minRule]</red> Sorry but the passed value "<yellow>${value}</yellow>" must be lower or equal at <cyan>${params.value}</cyan>`);
    }
    return value;
  }
};
const ruleObj$2 = {
  name: "Min",
  id: "min",
  settings: {},
  accept: "Number",
  message: (resultObj) => {
    return `This value has to be minimum "<yellow>${resultObj.min}</yellow>". Received "<red>${resultObj.received}</red>"`;
  },
  processParams: (params) => {
    return { value: params };
  },
  apply: (value, params, ruleSettings, settings) => {
    if (value < params.value) {
      return new Error(`<red>[minRule]</red> Sorry but the passed value "<yellow>${value}</yellow>" must be greater or equal at <cyan>${params.value}</cyan>`);
    }
    return value;
  }
};
const ruleObj$1 = {
  priority: 1,
  name: "Required",
  id: "required",
  settings: {
    when: [void 0, null]
  },
  message: "This value is required",
  processParams: (params) => {
    return { value: params };
  },
  apply: (value, params, ruleSettings, settings) => {
    if (params.value === true) {
      if (ruleSettings.when.indexOf(value) !== -1) {
        return new Error("This property is <yellow>required</yellow>");
      }
    }
    return value;
  }
};
var src$1 = {};
var config = {};
const name$1 = "clone-class";
const version$1 = "0.6.20";
const description = "Clone an ES6 Class as Another Class Name for Isolating Class Static Properties.";
const main = "src/index.js";
const typings = "src/index.d.ts";
const scripts = {
  clean: "shx rm -fr dist/*",
  dist: "npm run clean && tsc && shx cp {README.md,package.json} dist/",
  pack: "npm pack dist/",
  example: "ts-node examples/example.ts",
  lint: "npm run lint:ts",
  "lint:ts": "tslint --project tsconfig.json && tsc --noEmit",
  test: "npm run test:unit",
  "test:unit": 'blue-tape -r ts-node/register "src/**/*.spec.ts" "tests/**/*.spec.ts"',
  "test:pack": "bash -x scripts/npm-pack-testing.sh"
};
const repository = {
  type: "git",
  url: "git+https://github.com/huan/clone-class.git"
};
const keywords = [
  "clone",
  "class",
  "es6",
  "static"
];
const author = "Huan LI <zixia@zixia.net>";
const license = "Apache-2.0";
const bugs = {
  url: "https://github.com/huan/clone-class/issues"
};
const homepage = "https://github.com/huan/clone-class#readme";
const devDependencies = {
  "@types/blue-tape": "^0.1.31",
  "@types/node": "^10.0.3",
  "@types/semver": "^5.5.0",
  "blue-tape": "^1.0.0",
  "git-scripts": "^0.2.1",
  semver: "^5.5.0",
  shx: "^0.3.0",
  "ts-node": "^7.0.0",
  tslint: "^5.9.1",
  typescript: "^3.0.3"
};
const git = {
  scripts: {
    "pre-push": "./scripts/pre-push.sh"
  }
};
const publishConfig = {
  access: "public",
  tag: "latest"
};
const require$$0$4 = {
  name: name$1,
  version: version$1,
  description,
  main,
  typings,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  git,
  publishConfig
};
Object.defineProperty(config, "__esModule", { value: true });
config.VERSION = require$$0$4.version;
var instanceToClass$1 = {};
Object.defineProperty(instanceToClass$1, "__esModule", { value: true });
function instanceToClass(instance, baseClass) {
  return instance.constructor;
}
instanceToClass$1.instanceToClass = instanceToClass;
instanceToClass$1.default = instanceToClass;
var cloneClass$1 = {};
Object.defineProperty(cloneClass$1, "__esModule", { value: true });
function cloneClass(OriginalClass) {
  for (const staticProperty in OriginalClass) {
    if (/^[A-Z]/.test(staticProperty)) {
      continue;
    }
    if (typeof OriginalClass[staticProperty] === "object") {
      throw new Error("static property initialized to an object with defination is not supported with cloneClass.");
    }
  }
  class AnotherOriginalClass extends OriginalClass {
    constructor(...args) {
      super(...args);
    }
  }
  Reflect.defineProperty(AnotherOriginalClass, "name", {
    value: OriginalClass.name
  });
  return AnotherOriginalClass;
}
cloneClass$1.cloneClass = cloneClass;
cloneClass$1.default = cloneClass;
Object.defineProperty(src$1, "__esModule", { value: true });
var config_1 = config;
src$1.VERSION = config_1.VERSION;
var instance_to_class_1 = instanceToClass$1;
src$1.instanceToClass = instance_to_class_1.instanceToClass;
const clone_class_1 = cloneClass$1;
src$1.cloneClass = clone_class_1.cloneClass;
src$1.default = clone_class_1.cloneClass;
var isClass$2 = { exports: {} };
(function(module, exports) {
  (function(root) {
    const toString2 = Function.prototype.toString;
    function fnBody(fn2) {
      return toString2.call(fn2).replace(/^[^{]*{\s*/, "").replace(/\s*}[^}]*$/, "");
    }
    function isClass2(fn2) {
      if (typeof fn2 !== "function") {
        return false;
      }
      if (/^class[\s{]/.test(toString2.call(fn2))) {
        return true;
      }
      const body = fnBody(fn2);
      return /classCallCheck\(/.test(body) || /TypeError\("Cannot call a class as a function"\)/.test(body);
    }
    {
      if (module.exports) {
        exports = module.exports = isClass2;
      }
      exports.isClass = isClass2;
    }
  })();
})(isClass$2, isClass$2.exports);
const __isClass = isClass$2.exports;
function isClass$1(cls) {
  if (!Array.isArray(cls))
    cls = [cls];
  for (let i2 = 0; i2 < cls.length; i2++) {
    if (!__isClass(cls[i2]))
      return false;
  }
  return true;
}
const fn$2 = function(cls, settings = {}) {
  const stack = {};
  if (!isClass$1(cls)) {
    cls = cls.constructor;
  }
  if (settings.includeBaseClass === true) {
    stack[cls.name] = cls;
  }
  let baseClass = cls;
  while (baseClass) {
    const newBaseClass = Object.getPrototypeOf(baseClass);
    if (newBaseClass && newBaseClass !== Object && newBaseClass.name) {
      stack[newBaseClass.name] = newBaseClass;
      baseClass = newBaseClass;
    } else {
      break;
    }
  }
  return stack;
};
function __getMethods(toCheck) {
  let props = [];
  let obj2 = toCheck;
  do {
    const _props = Object.getOwnPropertyNames(obj2);
    if (_props.indexOf("__defineGetter__") !== -1)
      continue;
    props = props.concat(_props);
  } while (obj2 = Object.getPrototypeOf(obj2));
  return props.sort().filter(function(e, i2, arr) {
    if (e != arr[i2 + 1] && typeof toCheck[e] == "function")
      return true;
  });
}
var es5 = { exports: {} };
var aggregation = function(base) {
  var mixins = Array.prototype.slice.call(arguments, 1);
  var aggregate = function() {
    var args = Array.prototype.slice.call(arguments, 0);
    base.apply(this, args);
    mixins.forEach(function(mixin) {
      if (typeof mixin.prototype.initializer === "function")
        mixin.prototype.initializer.apply(this, args);
    }.bind(this));
  };
  aggregate.prototype = Object.create(base.prototype);
  aggregate.prototype.constructor = aggregate;
  var copyProps = function(target, source2) {
    Object.getOwnPropertyNames(source2).forEach(function(prop) {
      if (prop.match(/^(?:initializer|constructor|prototype|arguments|caller|name|bind|call|apply|toString|length)$/))
        return;
      Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source2, prop));
    });
  };
  mixins.forEach(function(mixin) {
    copyProps(aggregate.prototype, mixin.prototype);
    copyProps(aggregate, mixin);
  });
  return aggregate;
};
var aggregationEs5 = aggregation;
(function(module) {
  module.exports = aggregationEs5;
})(es5);
function __replaceTags(text, tags) {
  if (!text)
    text = "";
  text = fn$3(text);
  let oneLineText = text.replace(/\r\n/g, "|rn|");
  oneLineText = oneLineText.replace(/\n/g, "|n|");
  oneLineText = oneLineText.replace(/\r/g, "|r|");
  Object.keys(tags).forEach((tagName) => {
    const reg = new RegExp(`<s*${tagName}[^>]*>((.*?))<\\s*/\\s*${tagName}>`, "g");
    const tagsArray = oneLineText.match(reg);
    const singleReg = new RegExp(`\\s?<${tagName}\\s?/>\\s?`, "g");
    const singleTagsArray = oneLineText.match(singleReg);
    if (tagsArray) {
      for (let i2 = 0; i2 < tagsArray.length; i2++) {
        const t = tagsArray[i2];
        const tagArgs = t.match(`<\\s*${tagName}[^>]*>((.*?))<\\s*/\\s*${tagName}>`);
        if (!tagArgs)
          continue;
        const tagToReplace = tagArgs[0];
        const tagContent = tagArgs[1];
        oneLineText = oneLineText.replace(tagToReplace, tags[tagName](tagName, tagContent));
      }
    }
    if (singleTagsArray) {
      for (let i2 = 0; i2 < singleTagsArray.length; i2++) {
        const t = singleTagsArray[i2];
        const tagArgs = t.match(`\\s?<${tagName}\\s?/>\\s?`);
        if (!tagArgs)
          continue;
        const tagToReplace = tagArgs[0];
        const tagContent = "";
        oneLineText = oneLineText.replace(tagToReplace, tags[tagName](tagName, tagContent));
      }
    }
  });
  oneLineText = oneLineText.replace(/\|rn\|/g, "\r\n");
  oneLineText = oneLineText.replace(/\|n\|/g, "\n");
  oneLineText = oneLineText.replace(/\|r\|/g, "\r");
  return oneLineText;
}
source$1.level = 3;
const tagsMap = {
  black: (tag2, content) => source$1.black(content),
  red: (tag2, content) => source$1.red(content),
  green: (tag2, content) => source$1.green(content),
  yellow: (tag2, content) => source$1.yellow(content),
  blue: (tag2, content) => source$1.blue(content),
  magenta: (tag2, content) => source$1.magenta(content),
  cyan: (tag2, content) => source$1.cyan(content),
  white: (tag2, content) => source$1.white(content),
  grey: (tag2, content) => source$1.grey(content),
  bgBlack: (tag2, content) => source$1.bgBlack(content),
  bgRed: (tag2, content) => source$1.bgRed(content),
  bgGreen: (tag2, content) => source$1.bgGreen(content),
  bgYellow: (tag2, content) => source$1.bgYellow(content),
  bgBlue: (tag2, content) => source$1.bgBlue(content),
  bgMagenta: (tag2, content) => source$1.bgMagenta(content),
  bgCyan: (tag2, content) => source$1.bgCyan(content),
  bgWhite: (tag2, content) => source$1.bgWhite(content),
  bold: (tag2, content) => source$1.bold(content),
  dim: (tag2, content) => source$1.dim(content),
  italic: (tag2, content) => source$1.italic(content),
  underline: (tag2, content) => source$1.underline(content),
  strike: (tag2, content) => source$1.strike(content),
  h1: (tag2, content) => {
    return source$1.underline(source$1.bold(content)) + "\n\n";
  },
  h2: (tag2, content) => {
    return source$1.bold(content) + "\n";
  },
  date: (tag2, content) => new Date().getDate().toString().padStart("0", 2) + "-" + (new Date().getMonth() + 1).toString().padStart("0", 2) + "-" + new Date().getFullYear().toString().padStart("0", 2),
  time: (tag2, content) => new Date().getHours().toString().padStart("0", 2) + ":" + new Date().getMinutes().toString().padStart("0", 2) + ":" + new Date().getMinutes().toString().padStart("0", 2),
  day: (tag2, content) => new Date().getDate().toString().padStart("0", 2),
  days: (tag2, content) => new Date().getDate().toString().padStart("0", 2),
  month: (tag2, content) => new Date().getMonth().toString().padStart("0", 2),
  months: (tag2, content) => new Date().getMonth().toString().padStart("0", 2),
  year: (tag2, content) => new Date().getFullYear().toString().padStart("0", 2),
  years: (tag2, content) => new Date().getFullYear().toString().padStart("0", 2),
  hour: (tag2, content) => new Date().getHours().toString().padStart("0", 2),
  hours: (tag2, content) => new Date().getHours().toString().padStart("0", 2),
  minute: (tag2, content) => new Date().getMinutes().toString().padStart("0", 2),
  minutes: (tag2, content) => new Date().getMinutes().toString().padStart("0", 2),
  second: (tag2, content) => new Date().getSeconds().toString().padStart("0", 2),
  seconds: (tag2, content) => new Date().getSeconds().toString().padStart("0", 2),
  br: (tag2, content) => "\n"
};
function __parseHtml(message) {
  let isArray2 = false;
  if (Array.isArray(message)) {
    isArray2 = true;
  } else {
    message = [message];
  }
  message = message.map((m2) => {
    return __replaceTags(m2, tagsMap);
  });
  if (isArray2)
    return message;
  return message[0];
}
function __isInteger(data2) {
  return typeof data2 === "number" && !isNaN(data2) && function(x2) {
    return (x2 | 0) === x2;
  }(parseFloat(data2));
}
function __upperFirst(string2) {
  return string2.charAt(0).toUpperCase() + string2.slice(1);
}
function __typeof(value, settings = {}) {
  settings = __deepMerge({
    of: false,
    customClass: true
  }, settings);
  let type;
  if (Array.isArray(value))
    type = "Array";
  else if (value instanceof Map)
    type = "Map";
  else if (value === null)
    type = "Null";
  else if (value === void 0)
    type = "Undefined";
  else if (typeof value === "string")
    type = "String";
  else if (__isInteger(value))
    type = "Integer";
  else if (typeof value === "number")
    type = "Number";
  else if (typeof value === "boolean")
    type = "Boolean";
  else if (value instanceof RegExp)
    type = "RegExp";
  else if (settings.customClass === true && isClass$1(value) && value.name !== void 0) {
    type = __upperFirst(value.name);
  } else if (settings.customClass === true && value.constructor !== void 0 && value.constructor.name !== void 0) {
    type = __upperFirst(value.constructor.name);
  } else if (settings.customClass === false && isClass$1(value)) {
    type = "Class";
  } else if (typeof value === "function")
    type = "Function";
  else if (typeof value === "object")
    type = "Object";
  else
    type = "Unknown";
  const avoidTypes = [
    "Null",
    "Undefined",
    "String",
    "Integer",
    "Number",
    "Boolean",
    "Unknown"
  ];
  if (settings.of === true && !avoidTypes.includes(type)) {
    const loopOn = Array.isArray(value) ? [...value.keys()] : Object.keys(value);
    const receivedTypes = [];
    loopOn.forEach((valueIndex) => {
      const valueToCheck = value[valueIndex];
      const childType = __typeOf(valueToCheck, {
        of: false,
        customClass: settings.customClass
      });
      if (!receivedTypes.includes(childType)) {
        receivedTypes.push(childType);
      }
    });
    type += `<${receivedTypes.join("|")}>`;
  }
  return type;
}
const fn$1 = function(stack, callback, settings = {}) {
  settings = Object.assign({ newStack: false }, settings);
  const stackType = __typeof(stack).toLowerCase();
  let loopOnKeys;
  if (stackType === "object")
    loopOnKeys = Object.keys(stack);
  else if (stackType === "array")
    loopOnKeys = Array.from(Array(stack.length).keys());
  else if (stackType === "number" || stackType === "integer")
    loopOnKeys = Array.from(Array(Math.round(stack)).keys());
  else if (stackType === "string")
    loopOnKeys = Array.from(stack);
  else if (stackType === "set")
    loopOnKeys = Array.from(stack);
  else
    loopOnKeys = Array.from(stack.keys());
  if (stackType === "string" || stackType === "number" || stackType === "integer" || stackType === "set")
    settings.newStack = true;
  let newStack = [];
  if (stackType === "object")
    newStack = {};
  else if (stackType === "map")
    newStack = /* @__PURE__ */ new Map();
  else if (stackType === "set")
    newStack = /* @__PURE__ */ new Set();
  let value;
  let newValue;
  const _get = (s2, k2) => {
    switch (__typeof(s2).toLowerCase()) {
      case "array":
      case "object":
        return s2[k2];
      case "string":
        return k2;
      case "number":
      case "integer":
        return k2;
      case "map":
        return s2.get(k2);
      case "set":
        return k2;
    }
  };
  const _set = (s2, k2, v) => {
    switch (__typeof(s2).toLowerCase()) {
      case "array":
        if (settings.newStack === true)
          s2.push(v);
        else
          s2[k2] = v;
        break;
      case "object":
        s2[k2] = v;
        break;
      case "number":
      case "integer":
      case "string":
        s2.push(v);
        break;
      case "map":
        s2.set(k2, v);
        break;
      case "set":
        s2.add(v);
        break;
    }
  };
  for (let i2 = 0; i2 < loopOnKeys.length; i2++) {
    const key = loopOnKeys[i2];
    value = _get(stack, key);
    newValue = callback({ key, prop: key, value, i: i2, idx: i2 });
    if (newValue === -1)
      break;
    _set(settings.newStack ? newStack : stack, key, newValue);
  }
  if (stackType === "string") {
    return newStack.join("");
  }
  return settings.newStack ? newStack : stack;
};
function __camelize(text) {
  if (!text)
    text = "";
  let res = "";
  const reg = /(?:^|[_-\s])(\w)/g;
  res = text.replace(reg, function(_, c) {
    return c ? c.toUpperCase() : "";
  });
  res = res.substr(0, 1).toLowerCase() + res.slice(1);
  return res.trim();
}
function __camelCase(text) {
  return __camelize(text);
}
function __camelCaseProps(object, settings) {
  const finalSettings = Object.assign({ deep: true }, settings !== null && settings !== void 0 ? settings : {});
  for (let [key, value] of Object.entries(object)) {
    const newKey = __camelCase(key);
    if (__isPlainObject(value) && finalSettings.deep) {
      object[newKey] = __camelCaseProps(object[key], finalSettings);
    } else {
      object[newKey] = value;
    }
    if (newKey !== key) {
      delete object[key];
    }
  }
  return object;
}
var lodash_clone = { exports: {} };
(function(module, exports) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reFlags = /\w*$/;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  function addMapEntry(map2, pair) {
    map2.set(pair[0], pair[1]);
    return map2;
  }
  function addSetEntry(set, value) {
    set.add(value);
    return set;
  }
  function arrayEach(array, iteratee) {
    var index = -1, length = array ? array.length : 0;
    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset2 = array.length;
    while (++index < length) {
      array[offset2 + index] = values[index];
    }
    return array;
  }
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array ? array.length : 0;
    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }
  function baseTimes(n, iteratee) {
    var index = -1, result2 = Array(n);
    while (++index < n) {
      result2[index] = iteratee(index);
    }
    return result2;
  }
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  function isHostObject(value) {
    var result2 = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result2 = !!(value + "");
      } catch (e) {
      }
    }
    return result2;
  }
  function mapToArray(map2) {
    var index = -1, result2 = Array(map2.size);
    map2.forEach(function(value, key) {
      result2[++index] = [key, value];
    });
    return result2;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  function setToArray(set) {
    var index = -1, result2 = Array(set.size);
    set.forEach(function(value) {
      result2[++index] = value;
    });
    return result2;
  }
  var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString = funcProto.toString;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var Buffer2 = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
  var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
  var DataView2 = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
  var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet(key) {
    var data2 = this.__data__;
    if (nativeCreate) {
      var result2 = data2[key];
      return result2 === HASH_UNDEFINED ? void 0 : result2;
    }
    return hasOwnProperty2.call(data2, key) ? data2[key] : void 0;
  }
  function hashHas(key) {
    var data2 = this.__data__;
    return nativeCreate ? data2[key] !== void 0 : hasOwnProperty2.call(data2, key);
  }
  function hashSet(key, value) {
    var data2 = this.__data__;
    data2[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key) {
    var data2 = this.__data__, index = assocIndexOf(data2, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data2.length - 1;
    if (index == lastIndex) {
      data2.pop();
    } else {
      splice.call(data2, index, 1);
    }
    return true;
  }
  function listCacheGet(key) {
    var data2 = this.__data__, index = assocIndexOf(data2, key);
    return index < 0 ? void 0 : data2[index][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data2 = this.__data__, index = assocIndexOf(data2, key);
    if (index < 0) {
      data2.push([key, value]);
    } else {
      data2[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash()
    };
  }
  function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function Stack(entries) {
    this.__data__ = new ListCache(entries);
  }
  function stackClear() {
    this.__data__ = new ListCache();
  }
  function stackDelete(key) {
    return this.__data__["delete"](key);
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var cache2 = this.__data__;
    if (cache2 instanceof ListCache) {
      var pairs = cache2.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        return this;
      }
      cache2 = this.__data__ = new MapCache(pairs);
    }
    cache2.set(key, value);
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var result2 = isArray2(value) || isArguments5(value) ? baseTimes(value.length, String) : [];
    var length = result2.length, skipIndexes = !!length;
    for (var key in value) {
      if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
        result2.push(key);
      }
    }
    return result2;
  }
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
      object[key] = value;
    }
  }
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseAssign(object, source2) {
    return object && copyObject(source2, keys3(source2), object);
  }
  function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
    var result2;
    if (customizer) {
      result2 = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result2 !== void 0) {
      return result2;
    }
    if (!isObject3(value)) {
      return value;
    }
    var isArr = isArray2(value);
    if (isArr) {
      result2 = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result2);
      }
    } else {
      var tag2 = getTag(value), isFunc = tag2 == funcTag || tag2 == genTag;
      if (isBuffer2(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag2 == objectTag || tag2 == argsTag || isFunc && !object) {
        if (isHostObject(value)) {
          return object ? value : {};
        }
        result2 = initCloneObject(isFunc ? {} : value);
        if (!isDeep) {
          return copySymbols(value, baseAssign(result2, value));
        }
      } else {
        if (!cloneableTags[tag2]) {
          return object ? value : {};
        }
        result2 = initCloneByTag(value, tag2, baseClone, isDeep);
      }
    }
    stack || (stack = new Stack());
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result2);
    if (!isArr) {
      var props = isFull ? getAllKeys(value) : keys3(value);
    }
    arrayEach(props || value, function(subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value[key2];
      }
      assignValue(result2, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
    });
    return result2;
  }
  function baseCreate(proto2) {
    return isObject3(proto2) ? objectCreate(proto2) : {};
  }
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result2 = keysFunc(object);
    return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
  }
  function baseGetTag(value) {
    return objectToString.call(value);
  }
  function baseIsNative(value) {
    if (!isObject3(value) || isMasked(value)) {
      return false;
    }
    var pattern2 = isFunction2(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern2.test(toSource(value));
  }
  function baseKeys(object) {
    if (!isPrototype2(object)) {
      return nativeKeys(object);
    }
    var result2 = [];
    for (var key in Object(object)) {
      if (hasOwnProperty2.call(object, key) && key != "constructor") {
        result2.push(key);
      }
    }
    return result2;
  }
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var result2 = new buffer.constructor(buffer.length);
    buffer.copy(result2);
    return result2;
  }
  function cloneArrayBuffer(arrayBuffer) {
    var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
    return result2;
  }
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }
  function cloneMap(map2, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(mapToArray(map2), true) : mapToArray(map2);
    return arrayReduce(array, addMapEntry, new map2.constructor());
  }
  function cloneRegExp(regexp) {
    var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result2.lastIndex = regexp.lastIndex;
    return result2;
  }
  function cloneSet(set, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
    return arrayReduce(array, addSetEntry, new set.constructor());
  }
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  function copyArray(source2, array) {
    var index = -1, length = source2.length;
    array || (array = Array(length));
    while (++index < length) {
      array[index] = source2[index];
    }
    return array;
  }
  function copyObject(source2, props, object, customizer) {
    object || (object = {});
    var index = -1, length = props.length;
    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source2[key], key, object, source2) : void 0;
      assignValue(object, key, newValue === void 0 ? source2[key] : newValue);
    }
    return object;
  }
  function copySymbols(source2, object) {
    return copyObject(source2, getSymbols(source2), object);
  }
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys3, getSymbols);
  }
  function getMapData(map2, key) {
    var data2 = map2.__data__;
    return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
  var getTag = baseGetTag;
  if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
    getTag = function(value) {
      var result2 = objectToString.call(value), Ctor = result2 == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result2;
    };
  }
  function initCloneArray(array) {
    var length = array.length, result2 = array.constructor(length);
    if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
      result2.index = array.index;
      result2.input = array.input;
    }
    return result2;
  }
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype2(object) ? baseCreate(getPrototype(object)) : {};
  }
  function initCloneByTag(object, tag2, cloneFunc, isDeep) {
    var Ctor = object.constructor;
    switch (tag2) {
      case arrayBufferTag:
        return cloneArrayBuffer(object);
      case boolTag:
      case dateTag:
        return new Ctor(+object);
      case dataViewTag:
        return cloneDataView(object, isDeep);
      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object, isDeep);
      case mapTag:
        return cloneMap(object, isDeep, cloneFunc);
      case numberTag:
      case stringTag:
        return new Ctor(object);
      case regexpTag:
        return cloneRegExp(object);
      case setTag:
        return cloneSet(object, isDeep, cloneFunc);
      case symbolTag:
        return cloneSymbol(object);
    }
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function isPrototype2(value) {
    var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto2;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  function clone2(value) {
    return baseClone(value, false, true);
  }
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArguments5(value) {
    return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray2 = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  var isBuffer2 = nativeIsBuffer || stubFalse;
  function isFunction2(value) {
    var tag2 = isObject3(value) ? objectToString.call(value) : "";
    return tag2 == funcTag || tag2 == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject3(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function keys3(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  function stubArray() {
    return [];
  }
  function stubFalse() {
    return false;
  }
  module.exports = clone2;
})(lodash_clone, lodash_clone.exports);
const __clone = lodash_clone.exports;
var lodash_clonedeep = { exports: {} };
(function(module, exports) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reFlags = /\w*$/;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  function addMapEntry(map2, pair) {
    map2.set(pair[0], pair[1]);
    return map2;
  }
  function addSetEntry(set, value) {
    set.add(value);
    return set;
  }
  function arrayEach(array, iteratee) {
    var index = -1, length = array ? array.length : 0;
    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset2 = array.length;
    while (++index < length) {
      array[offset2 + index] = values[index];
    }
    return array;
  }
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array ? array.length : 0;
    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }
  function baseTimes(n, iteratee) {
    var index = -1, result2 = Array(n);
    while (++index < n) {
      result2[index] = iteratee(index);
    }
    return result2;
  }
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  function isHostObject(value) {
    var result2 = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result2 = !!(value + "");
      } catch (e) {
      }
    }
    return result2;
  }
  function mapToArray(map2) {
    var index = -1, result2 = Array(map2.size);
    map2.forEach(function(value, key) {
      result2[++index] = [key, value];
    });
    return result2;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  function setToArray(set) {
    var index = -1, result2 = Array(set.size);
    set.forEach(function(value) {
      result2[++index] = value;
    });
    return result2;
  }
  var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString = funcProto.toString;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var Buffer2 = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
  var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
  var DataView2 = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
  var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet(key) {
    var data2 = this.__data__;
    if (nativeCreate) {
      var result2 = data2[key];
      return result2 === HASH_UNDEFINED ? void 0 : result2;
    }
    return hasOwnProperty2.call(data2, key) ? data2[key] : void 0;
  }
  function hashHas(key) {
    var data2 = this.__data__;
    return nativeCreate ? data2[key] !== void 0 : hasOwnProperty2.call(data2, key);
  }
  function hashSet(key, value) {
    var data2 = this.__data__;
    data2[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key) {
    var data2 = this.__data__, index = assocIndexOf(data2, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data2.length - 1;
    if (index == lastIndex) {
      data2.pop();
    } else {
      splice.call(data2, index, 1);
    }
    return true;
  }
  function listCacheGet(key) {
    var data2 = this.__data__, index = assocIndexOf(data2, key);
    return index < 0 ? void 0 : data2[index][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data2 = this.__data__, index = assocIndexOf(data2, key);
    if (index < 0) {
      data2.push([key, value]);
    } else {
      data2[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash()
    };
  }
  function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function Stack(entries) {
    this.__data__ = new ListCache(entries);
  }
  function stackClear() {
    this.__data__ = new ListCache();
  }
  function stackDelete(key) {
    return this.__data__["delete"](key);
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var cache2 = this.__data__;
    if (cache2 instanceof ListCache) {
      var pairs = cache2.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        return this;
      }
      cache2 = this.__data__ = new MapCache(pairs);
    }
    cache2.set(key, value);
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var result2 = isArray2(value) || isArguments5(value) ? baseTimes(value.length, String) : [];
    var length = result2.length, skipIndexes = !!length;
    for (var key in value) {
      if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
        result2.push(key);
      }
    }
    return result2;
  }
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
      object[key] = value;
    }
  }
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseAssign(object, source2) {
    return object && copyObject(source2, keys3(source2), object);
  }
  function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
    var result2;
    if (customizer) {
      result2 = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result2 !== void 0) {
      return result2;
    }
    if (!isObject3(value)) {
      return value;
    }
    var isArr = isArray2(value);
    if (isArr) {
      result2 = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result2);
      }
    } else {
      var tag2 = getTag(value), isFunc = tag2 == funcTag || tag2 == genTag;
      if (isBuffer2(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag2 == objectTag || tag2 == argsTag || isFunc && !object) {
        if (isHostObject(value)) {
          return object ? value : {};
        }
        result2 = initCloneObject(isFunc ? {} : value);
        if (!isDeep) {
          return copySymbols(value, baseAssign(result2, value));
        }
      } else {
        if (!cloneableTags[tag2]) {
          return object ? value : {};
        }
        result2 = initCloneByTag(value, tag2, baseClone, isDeep);
      }
    }
    stack || (stack = new Stack());
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result2);
    if (!isArr) {
      var props = isFull ? getAllKeys(value) : keys3(value);
    }
    arrayEach(props || value, function(subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value[key2];
      }
      assignValue(result2, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
    });
    return result2;
  }
  function baseCreate(proto2) {
    return isObject3(proto2) ? objectCreate(proto2) : {};
  }
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result2 = keysFunc(object);
    return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
  }
  function baseGetTag(value) {
    return objectToString.call(value);
  }
  function baseIsNative(value) {
    if (!isObject3(value) || isMasked(value)) {
      return false;
    }
    var pattern2 = isFunction2(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern2.test(toSource(value));
  }
  function baseKeys(object) {
    if (!isPrototype2(object)) {
      return nativeKeys(object);
    }
    var result2 = [];
    for (var key in Object(object)) {
      if (hasOwnProperty2.call(object, key) && key != "constructor") {
        result2.push(key);
      }
    }
    return result2;
  }
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var result2 = new buffer.constructor(buffer.length);
    buffer.copy(result2);
    return result2;
  }
  function cloneArrayBuffer(arrayBuffer) {
    var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
    return result2;
  }
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }
  function cloneMap(map2, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(mapToArray(map2), true) : mapToArray(map2);
    return arrayReduce(array, addMapEntry, new map2.constructor());
  }
  function cloneRegExp(regexp) {
    var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result2.lastIndex = regexp.lastIndex;
    return result2;
  }
  function cloneSet(set, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
    return arrayReduce(array, addSetEntry, new set.constructor());
  }
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  function copyArray(source2, array) {
    var index = -1, length = source2.length;
    array || (array = Array(length));
    while (++index < length) {
      array[index] = source2[index];
    }
    return array;
  }
  function copyObject(source2, props, object, customizer) {
    object || (object = {});
    var index = -1, length = props.length;
    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source2[key], key, object, source2) : void 0;
      assignValue(object, key, newValue === void 0 ? source2[key] : newValue);
    }
    return object;
  }
  function copySymbols(source2, object) {
    return copyObject(source2, getSymbols(source2), object);
  }
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys3, getSymbols);
  }
  function getMapData(map2, key) {
    var data2 = map2.__data__;
    return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
  var getTag = baseGetTag;
  if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
    getTag = function(value) {
      var result2 = objectToString.call(value), Ctor = result2 == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result2;
    };
  }
  function initCloneArray(array) {
    var length = array.length, result2 = array.constructor(length);
    if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
      result2.index = array.index;
      result2.input = array.input;
    }
    return result2;
  }
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype2(object) ? baseCreate(getPrototype(object)) : {};
  }
  function initCloneByTag(object, tag2, cloneFunc, isDeep) {
    var Ctor = object.constructor;
    switch (tag2) {
      case arrayBufferTag:
        return cloneArrayBuffer(object);
      case boolTag:
      case dateTag:
        return new Ctor(+object);
      case dataViewTag:
        return cloneDataView(object, isDeep);
      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object, isDeep);
      case mapTag:
        return cloneMap(object, isDeep, cloneFunc);
      case numberTag:
      case stringTag:
        return new Ctor(object);
      case regexpTag:
        return cloneRegExp(object);
      case setTag:
        return cloneSet(object, isDeep, cloneFunc);
      case symbolTag:
        return cloneSymbol(object);
    }
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function isPrototype2(value) {
    var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto2;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  function cloneDeep(value) {
    return baseClone(value, true, true);
  }
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArguments5(value) {
    return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray2 = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  var isBuffer2 = nativeIsBuffer || stubFalse;
  function isFunction2(value) {
    var tag2 = isObject3(value) ? objectToString.call(value) : "";
    return tag2 == funcTag || tag2 == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject3(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function keys3(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  function stubArray() {
    return [];
  }
  function stubFalse() {
    return false;
  }
  module.exports = cloneDeep;
})(lodash_clonedeep, lodash_clonedeep.exports);
const __deepClone = lodash_clonedeep.exports;
function clone(object, settings = {}) {
  settings = Object.assign({ deep: false }, settings);
  if (settings.deep) {
    return __deepClone(object);
  }
  return __clone(object);
}
function __deepAssign(referenceObj, ...objects) {
  const settings = {
    array: false,
    object: true,
    cloneChilds: true
  };
  function merge2(refObj, mixWithObj) {
    for (const key of Object.keys(mixWithObj)) {
      if (settings.array === true && Array.isArray(refObj[key]) && Array.isArray(mixWithObj[key])) {
        const newArray = __unique([...refObj[key], ...mixWithObj[key]]);
        refObj[key] = newArray;
        continue;
      }
      if (settings.object === true && __isPlainObject(refObj[key]) && __isPlainObject(mixWithObj[key])) {
        refObj[key] = merge2(refObj[key], mixWithObj[key]);
        continue;
      }
      if (__isPlainObject(mixWithObj[key]) && settings.cloneChilds) {
        refObj[key] = clone(mixWithObj[key], {
          deep: true
        });
      } else {
        refObj[key] = mixWithObj[key];
      }
    }
    return refObj;
  }
  const potentialSettingsObj = objects[objects.length - 1] || {};
  if (potentialSettingsObj.array && typeof potentialSettingsObj.array === "boolean" || potentialSettingsObj.object && typeof potentialSettingsObj.object === "boolean") {
    if (potentialSettingsObj.array !== void 0)
      settings.array = potentialSettingsObj.array;
    if (potentialSettingsObj.object !== void 0)
      settings.object = potentialSettingsObj.object;
    objects.pop();
  }
  for (let i2 = 0; i2 < objects.length; i2++) {
    const toMergeObj = objects[i2] || {};
    merge2(referenceObj, toMergeObj);
  }
  return referenceObj;
}
function __isDomElement(element) {
  return typeof HTMLElement === "object" ? element instanceof HTMLElement : element && typeof element === "object" && element !== null && element.nodeType === 1 && typeof element.nodeName === "string";
}
const _loopTimeout = /* @__PURE__ */ new WeakMap();
function __deepProxy(object, handlerFn, settings = {}) {
  let isRevoked = false;
  settings = __deepMerge({
    deep: true,
    handleSet: true,
    handleGet: false,
    handleDelete: true,
    domElements: false
  }, settings);
  function makeHandler(path2) {
    return {
      set(target, key, value) {
        if (!_loopTimeout.has(target)) {
          _loopTimeout.set(target, {});
        }
        const dotpath = [...path2, key].join(".");
        const timeouts = _loopTimeout.get(target);
        if (timeouts[dotpath]) {
          return true;
        }
        timeouts[dotpath] = true;
        setTimeout(() => {
          delete timeouts[dotpath];
        });
        if (isRevoked || !settings.handleSet)
          return true;
        if (value === target[key])
          return true;
        if (settings.deep && typeof value === "object") {
          value = proxify(value, [...path2, key]);
        }
        const oldValue = target[key];
        target[key] = value;
        handlerFn({
          object,
          target,
          key,
          path: [...path2, key].join("."),
          action: "set",
          fullAction: `Object.set`,
          oldValue,
          value
        });
        return true;
      },
      get(target, key, receiver) {
        if (Reflect.has(target, key)) {
          if (!settings.handleGet)
            return target[key];
          const value = handlerFn({
            object,
            target,
            key,
            path: [...path2, key].join("."),
            action: "get",
            fullAction: "Object.get"
          });
          if (key === "revoke")
            return receiver.revoke;
          if (value === void 0)
            return target[key];
          return value;
        }
        return void 0;
      },
      deleteProperty(target, key) {
        if (isRevoked || !settings.handleDelete)
          return true;
        if (Reflect.has(target, key)) {
          const oldValue = target[key];
          const deleted = Reflect.deleteProperty(target, key);
          if (deleted) {
            handlerFn({
              object,
              target,
              key,
              path: [...path2, key].join("."),
              action: "delete",
              fullAction: "Object.delete",
              oldValue
            });
          }
          return deleted;
        }
        return false;
      }
    };
  }
  function proxify(obj2, path2) {
    if (obj2 === null)
      return obj2;
    if (!settings.domElements && __isDomElement(obj2)) {
      return obj2;
    }
    if (settings.deep) {
      for (const key of Object.keys(obj2)) {
        if (Array.isArray(obj2[key])) {
          obj2[key] = __proxyArray(obj2[key]);
          obj2[key].watch(Object.getOwnPropertyNames(Array.prototype), (watchObj) => {
            handlerFn(Object.assign({ path: [...path2, key].join(".") }, watchObj));
          });
        } else if (typeof obj2[key] === "object") {
          obj2[key] = proxify(obj2[key], [...path2, key]);
        }
      }
    }
    const p = Proxy.revocable(obj2, makeHandler(path2));
    const revokePropertyObj = {
      writable: true,
      configurable: false,
      enumerable: false,
      value: () => {
        let __copy = clone(p.proxy, { deep: true });
        isRevoked = true;
        __copy = __deepMap(__copy, ({ value, prop }) => {
          if (prop === "revoke" && typeof value === "function") {
            return -1;
          }
          return value;
        });
        setTimeout(() => {
          __deepMap(p.proxy, ({ value, prop }) => {
            if (prop === "revoke" && typeof value === "function") {
              value();
            }
          }, {});
          p.revoke();
        });
        return __copy;
      }
    };
    if (Array.isArray(p.proxy)) {
      p.proxy.revoke = revokePropertyObj.value;
    } else {
      Object.defineProperties(p.proxy, {
        revoke: revokePropertyObj
      });
    }
    return p.proxy;
  }
  return proxify(object, []);
}
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var slice$1 = Array.prototype.slice;
var toStr$a = Object.prototype.toString;
var funcType = "[object Function]";
var implementation$b = function bind2(that) {
  var target = this;
  if (typeof target !== "function" || toStr$a.call(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slice$1.call(arguments, 1);
  var bound2;
  var binder = function() {
    if (this instanceof bound2) {
      var result2 = target.apply(
        this,
        args.concat(slice$1.call(arguments))
      );
      if (Object(result2) === result2) {
        return result2;
      }
      return this;
    } else {
      return target.apply(
        that,
        args.concat(slice$1.call(arguments))
      );
    }
  };
  var boundLength = Math.max(0, target.length - args.length);
  var boundArgs = [];
  for (var i2 = 0; i2 < boundLength; i2++) {
    boundArgs.push("$" + i2);
  }
  bound2 = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target.prototype;
    bound2.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound2;
};
var implementation$a = implementation$b;
var functionBind = Function.prototype.bind || implementation$a;
var bind$4 = functionBind;
var src = bind$4.call(Function.call, Object.prototype.hasOwnProperty);
var toString$3 = {}.toString;
var isarray = Array.isArray || function(arr) {
  return toString$3.call(arr) == "[object Array]";
};
var fnToStr$2 = Function.prototype.toString;
var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
  try {
    badArrayLike = Object.defineProperty({}, "length", {
      get: function() {
        throw isCallableMarker;
      }
    });
    isCallableMarker = {};
    reflectApply(function() {
      throw 42;
    }, null, badArrayLike);
  } catch (_) {
    if (_ !== isCallableMarker) {
      reflectApply = null;
    }
  }
} else {
  reflectApply = null;
}
var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
  try {
    var fnStr = fnToStr$2.call(value);
    return constructorRegex.test(fnStr);
  } catch (e) {
    return false;
  }
};
var tryFunctionObject = function tryFunctionToStr(value) {
  try {
    if (isES6ClassFn(value)) {
      return false;
    }
    fnToStr$2.call(value);
    return true;
  } catch (e) {
    return false;
  }
};
var toStr$9 = Object.prototype.toString;
var fnClass = "[object Function]";
var genClass = "[object GeneratorFunction]";
var hasToStringTag$a = typeof Symbol === "function" && !!Symbol.toStringTag;
var documentDotAll = typeof document === "object" && typeof document.all === "undefined" && document.all !== void 0 ? document.all : {};
var isCallable$1 = reflectApply ? function isCallable2(value) {
  if (value === documentDotAll) {
    return true;
  }
  if (!value) {
    return false;
  }
  if (typeof value !== "function" && typeof value !== "object") {
    return false;
  }
  if (typeof value === "function" && !value.prototype) {
    return true;
  }
  try {
    reflectApply(value, null, badArrayLike);
  } catch (e) {
    if (e !== isCallableMarker) {
      return false;
    }
  }
  return !isES6ClassFn(value);
} : function isCallable3(value) {
  if (value === documentDotAll) {
    return true;
  }
  if (!value) {
    return false;
  }
  if (typeof value !== "function" && typeof value !== "object") {
    return false;
  }
  if (typeof value === "function" && !value.prototype) {
    return true;
  }
  if (hasToStringTag$a) {
    return tryFunctionObject(value);
  }
  if (isES6ClassFn(value)) {
    return false;
  }
  var strClass2 = toStr$9.call(value);
  return strClass2 === fnClass || strClass2 === genClass;
};
var shams$1 = function hasSymbols2() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj2 = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj2[sym] = symVal;
  for (sym in obj2) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj2).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj2).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj2);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj2, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor2 = Object.getOwnPropertyDescriptor(obj2, sym);
    if (descriptor2.value !== symVal || descriptor2.enumerable !== true) {
      return false;
    }
  }
  return true;
};
var origSymbol = typeof Symbol !== "undefined" && Symbol;
var hasSymbolSham = shams$1;
var hasSymbols$4 = function hasNativeSymbols() {
  if (typeof origSymbol !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return hasSymbolSham();
};
var undefined$1;
var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError$3 = TypeError;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e) {
  }
};
var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
  try {
    $gOPD({}, "");
  } catch (e) {
    $gOPD = null;
  }
}
var throwTypeError = function() {
  throw new $TypeError$3();
};
var ThrowTypeError = $gOPD ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols$3 = hasSymbols$4();
var getProto$4 = Object.getPrototypeOf || function(x2) {
  return x2.__proto__;
};
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" ? undefined$1 : getProto$4(Uint8Array);
var INTRINSICS = {
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols$3 ? getProto$4([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols$3 ? getProto$4(getProto$4([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols$3 ? undefined$1 : getProto$4((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols$3 ? undefined$1 : getProto$4((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols$3 ? getProto$4(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols$3 ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$3,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
};
var doEval = function doEval2(name2) {
  var value;
  if (name2 === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name2 === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name2 === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name2 === "%AsyncGenerator%") {
    var fn2 = doEval2("%AsyncGeneratorFunction%");
    if (fn2) {
      value = fn2.prototype;
    }
  } else if (name2 === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen) {
      value = getProto$4(gen.prototype);
    }
  }
  INTRINSICS[name2] = value;
  return value;
};
var LEGACY_ALIASES = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind$3 = functionBind;
var hasOwn$1 = src;
var $concat = bind$3.call(Function.call, Array.prototype.concat);
var $spliceApply = bind$3.call(Function.apply, Array.prototype.splice);
var $replace = bind$3.call(Function.call, String.prototype.replace);
var $strSlice = bind$3.call(Function.call, String.prototype.slice);
var $exec$1 = bind$3.call(Function.call, RegExp.prototype.exec);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string2) {
  var first = $strSlice(string2, 0, 1);
  var last = $strSlice(string2, -1);
  if (first === "%" && last !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
  } else if (last === "%" && first !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
  }
  var result2 = [];
  $replace(string2, rePropName, function(match5, number2, quote, subString) {
    result2[result2.length] = quote ? $replace(subString, reEscapeChar, "$1") : number2 || match5;
  });
  return result2;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
  var intrinsicName = name2;
  var alias;
  if (hasOwn$1(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn$1(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError$3("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
};
var getIntrinsic = function GetIntrinsic2(name2, allowMissing) {
  if (typeof name2 !== "string" || name2.length === 0) {
    throw new $TypeError$3("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError$3('"allowMissing" argument must be a boolean');
  }
  if ($exec$1(/^%?[^%]*%?$/g, name2) === null) {
    throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  }
  var parts = stringToPath(name2);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }
  for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
    var part = parts[i2];
    var first = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);
    if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
      throw new $SyntaxError("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn$1(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError$3("base intrinsic for " + name2 + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD && i2 + 1 >= parts.length) {
        var desc = $gOPD(value, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn$1(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
var callBind$3 = { exports: {} };
(function(module) {
  var bind4 = functionBind;
  var GetIntrinsic3 = getIntrinsic;
  var $apply = GetIntrinsic3("%Function.prototype.apply%");
  var $call = GetIntrinsic3("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic3("%Reflect.apply%", true) || bind4.call($call, $apply);
  var $gOPD2 = GetIntrinsic3("%Object.getOwnPropertyDescriptor%", true);
  var $defineProperty2 = GetIntrinsic3("%Object.defineProperty%", true);
  var $max = GetIntrinsic3("%Math.max%");
  if ($defineProperty2) {
    try {
      $defineProperty2({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty2 = null;
    }
  }
  module.exports = function callBind2(originalFunction) {
    var func = $reflectApply(bind4, $call, arguments);
    if ($gOPD2 && $defineProperty2) {
      var desc = $gOPD2(func, "length");
      if (desc.configurable) {
        $defineProperty2(
          func,
          "length",
          { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
        );
      }
    }
    return func;
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind4, $apply, arguments);
  };
  if ($defineProperty2) {
    $defineProperty2(module.exports, "apply", { value: applyBind });
  } else {
    module.exports.apply = applyBind;
  }
})(callBind$3);
var GetIntrinsic$7 = getIntrinsic;
var callBind$2 = callBind$3.exports;
var $indexOf = callBind$2(GetIntrinsic$7("String.prototype.indexOf"));
var callBound$9 = function callBoundIntrinsic(name2, allowMissing) {
  var intrinsic = GetIntrinsic$7(name2, !!allowMissing);
  if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
    return callBind$2(intrinsic);
  }
  return intrinsic;
};
var hasSymbols$2 = shams$1;
var shams = function hasToStringTagShams() {
  return hasSymbols$2() && !!Symbol.toStringTag;
};
var callBound$8 = callBound$9;
var $boolToStr = callBound$8("Boolean.prototype.toString");
var $toString$3 = callBound$8("Object.prototype.toString");
var tryBooleanObject = function booleanBrandCheck(value) {
  try {
    $boolToStr(value);
    return true;
  } catch (e) {
    return false;
  }
};
var boolClass = "[object Boolean]";
var hasToStringTag$9 = shams();
var isBooleanObject = function isBoolean2(value) {
  if (typeof value === "boolean") {
    return true;
  }
  if (value === null || typeof value !== "object") {
    return false;
  }
  return hasToStringTag$9 && Symbol.toStringTag in value ? tryBooleanObject(value) : $toString$3(value) === boolClass;
};
var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateGetDayCall(value) {
  try {
    getDay.call(value);
    return true;
  } catch (e) {
    return false;
  }
};
var toStr$8 = Object.prototype.toString;
var dateClass = "[object Date]";
var hasToStringTag$8 = shams();
var isDateObject = function isDateObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  return hasToStringTag$8 ? tryDateObject(value) : toStr$8.call(value) === dateClass;
};
var toStr$7 = Object.prototype.toString;
var fnToStr$1 = Function.prototype.toString;
var isFnRegex$1 = /^\s*(?:function)?\*/;
var hasToStringTag$7 = shams();
var getProto$3 = Object.getPrototypeOf;
var getGeneratorFunc = function() {
  if (!hasToStringTag$7) {
    return false;
  }
  try {
    return Function("return function*() {}")();
  } catch (e) {
  }
};
var GeneratorFunction;
var isGeneratorFunction$1 = function isGeneratorFunction2(fn2) {
  if (typeof fn2 !== "function") {
    return false;
  }
  if (isFnRegex$1.test(fnToStr$1.call(fn2))) {
    return true;
  }
  if (!hasToStringTag$7) {
    var str2 = toStr$7.call(fn2);
    return str2 === "[object GeneratorFunction]";
  }
  if (!getProto$3) {
    return false;
  }
  if (typeof GeneratorFunction === "undefined") {
    var generatorFunc = getGeneratorFunc();
    GeneratorFunction = generatorFunc ? getProto$3(generatorFunc) : false;
  }
  return getProto$3(fn2) === GeneratorFunction;
};
var numToStr = Number.prototype.toString;
var tryNumberObject = function tryNumberObject2(value) {
  try {
    numToStr.call(value);
    return true;
  } catch (e) {
    return false;
  }
};
var toStr$6 = Object.prototype.toString;
var numClass = "[object Number]";
var hasToStringTag$6 = shams();
var isNumberObject = function isNumberObject2(value) {
  if (typeof value === "number") {
    return true;
  }
  if (typeof value !== "object") {
    return false;
  }
  return hasToStringTag$6 ? tryNumberObject(value) : toStr$6.call(value) === numClass;
};
var callBound$7 = callBound$9;
var hasToStringTag$5 = shams();
var has$2;
var $exec;
var isRegexMarker;
var badStringifier;
if (hasToStringTag$5) {
  has$2 = callBound$7("Object.prototype.hasOwnProperty");
  $exec = callBound$7("RegExp.prototype.exec");
  isRegexMarker = {};
  var throwRegexMarker = function() {
    throw isRegexMarker;
  };
  badStringifier = {
    toString: throwRegexMarker,
    valueOf: throwRegexMarker
  };
  if (typeof Symbol.toPrimitive === "symbol") {
    badStringifier[Symbol.toPrimitive] = throwRegexMarker;
  }
}
var $toString$2 = callBound$7("Object.prototype.toString");
var gOPD$1 = Object.getOwnPropertyDescriptor;
var regexClass = "[object RegExp]";
var isRegex$1 = hasToStringTag$5 ? function isRegex2(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  var descriptor2 = gOPD$1(value, "lastIndex");
  var hasLastIndexDataProperty = descriptor2 && has$2(descriptor2, "value");
  if (!hasLastIndexDataProperty) {
    return false;
  }
  try {
    $exec(value, badStringifier);
  } catch (e) {
    return e === isRegexMarker;
  }
} : function isRegex3(value) {
  if (!value || typeof value !== "object" && typeof value !== "function") {
    return false;
  }
  return $toString$2(value) === regexClass;
};
var strValue = String.prototype.valueOf;
var tryStringObject = function tryStringObject2(value) {
  try {
    strValue.call(value);
    return true;
  } catch (e) {
    return false;
  }
};
var toStr$5 = Object.prototype.toString;
var strClass = "[object String]";
var hasToStringTag$4 = shams();
var isString$4 = function isString2(value) {
  if (typeof value === "string") {
    return true;
  }
  if (typeof value !== "object") {
    return false;
  }
  return hasToStringTag$4 ? tryStringObject(value) : toStr$5.call(value) === strClass;
};
var isSymbol$2 = { exports: {} };
var toStr$4 = Object.prototype.toString;
var hasSymbols$1 = hasSymbols$4();
if (hasSymbols$1) {
  var symToStr = Symbol.prototype.toString;
  var symStringRegex = /^Symbol\(.*\)$/;
  var isSymbolObject = function isRealSymbolObject(value) {
    if (typeof value.valueOf() !== "symbol") {
      return false;
    }
    return symStringRegex.test(symToStr.call(value));
  };
  isSymbol$2.exports = function isSymbol2(value) {
    if (typeof value === "symbol") {
      return true;
    }
    if (toStr$4.call(value) !== "[object Symbol]") {
      return false;
    }
    try {
      return isSymbolObject(value);
    } catch (e) {
      return false;
    }
  };
} else {
  isSymbol$2.exports = function isSymbol2(value) {
    return false;
  };
}
var isBigint = { exports: {} };
var $BigInt = typeof BigInt !== "undefined" && BigInt;
var hasBigints = function hasNativeBigInts() {
  return typeof $BigInt === "function" && typeof BigInt === "function" && typeof $BigInt(42) === "bigint" && typeof BigInt(42) === "bigint";
};
var hasBigInts = hasBigints();
if (hasBigInts) {
  var bigIntValueOf = BigInt.prototype.valueOf;
  var tryBigInt = function tryBigIntObject(value) {
    try {
      bigIntValueOf.call(value);
      return true;
    } catch (e) {
    }
    return false;
  };
  isBigint.exports = function isBigInt2(value) {
    if (value === null || typeof value === "undefined" || typeof value === "boolean" || typeof value === "string" || typeof value === "number" || typeof value === "symbol" || typeof value === "function") {
      return false;
    }
    if (typeof value === "bigint") {
      return true;
    }
    return tryBigInt(value);
  };
} else {
  isBigint.exports = function isBigInt2(value) {
    return false;
  };
}
var hasToStringTag$3 = shams();
var callBound$6 = callBound$9;
var $toString$1 = callBound$6("Object.prototype.toString");
var isStandardArguments = function isArguments2(value) {
  if (hasToStringTag$3 && value && typeof value === "object" && Symbol.toStringTag in value) {
    return false;
  }
  return $toString$1(value) === "[object Arguments]";
};
var isLegacyArguments = function isArguments3(value) {
  if (isStandardArguments(value)) {
    return true;
  }
  return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString$1(value) !== "[object Array]" && $toString$1(value.callee) === "[object Function]";
};
(function() {
  return isStandardArguments(arguments);
})();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var $Map$2 = typeof Map === "function" && Map.prototype ? Map : null;
var $Set$2 = typeof Set === "function" && Set.prototype ? Set : null;
var exported$2;
if (!$Map$2) {
  exported$2 = function isMap3(x2) {
    return false;
  };
}
var $mapHas$3 = $Map$2 ? Map.prototype.has : null;
var $setHas$3 = $Set$2 ? Set.prototype.has : null;
if (!exported$2 && !$mapHas$3) {
  exported$2 = function isMap3(x2) {
    return false;
  };
}
var isMap$1 = exported$2 || function isMap2(x2) {
  if (!x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    $mapHas$3.call(x2);
    if ($setHas$3) {
      try {
        $setHas$3.call(x2);
      } catch (e) {
        return true;
      }
    }
    return x2 instanceof $Map$2;
  } catch (e) {
  }
  return false;
};
var $Map$1 = typeof Map === "function" && Map.prototype ? Map : null;
var $Set$1 = typeof Set === "function" && Set.prototype ? Set : null;
var exported$1;
if (!$Set$1) {
  exported$1 = function isSet3(x2) {
    return false;
  };
}
var $mapHas$2 = $Map$1 ? Map.prototype.has : null;
var $setHas$2 = $Set$1 ? Set.prototype.has : null;
if (!exported$1 && !$setHas$2) {
  exported$1 = function isSet3(x2) {
    return false;
  };
}
var isSet$1 = exported$1 || function isSet2(x2) {
  if (!x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    $setHas$2.call(x2);
    if ($mapHas$2) {
      try {
        $mapHas$2.call(x2);
      } catch (e) {
        return true;
      }
    }
    return x2 instanceof $Set$1;
  } catch (e) {
  }
  return false;
};
if (hasSymbols$4() || shams$1())
  ;
else {
  var GetIntrinsic$6 = getIntrinsic;
  var $Map = GetIntrinsic$6("%Map%", true);
  var $Set = GetIntrinsic$6("%Set%", true);
  var callBound$5 = callBound$9;
  callBound$5("Array.prototype.push");
  callBound$5("String.prototype.charCodeAt");
  callBound$5("String.prototype.slice");
  if (!$Map && !$Set)
    ;
  else {
    callBound$5("Map.prototype.forEach", true);
    callBound$5("Set.prototype.forEach", true);
    if (typeof process === "undefined" || !process.versions || !process.versions.node) {
      callBound$5("Map.prototype.iterator", true);
      callBound$5("Set.prototype.iterator", true);
    }
    callBound$5("Map.prototype.@@iterator", true) || callBound$5("Map.prototype._es6-shim iterator_", true);
    callBound$5("Set.prototype.@@iterator", true) || callBound$5("Set.prototype._es6-shim iterator_", true);
  }
}
var $WeakMap = typeof WeakMap === "function" && WeakMap.prototype ? WeakMap : null;
var $WeakSet$1 = typeof WeakSet === "function" && WeakSet.prototype ? WeakSet : null;
var exported;
if (!$WeakMap) {
  exported = function isWeakMap3(x2) {
    return false;
  };
}
var $mapHas$1 = $WeakMap ? $WeakMap.prototype.has : null;
var $setHas$1 = $WeakSet$1 ? $WeakSet$1.prototype.has : null;
if (!exported && !$mapHas$1) {
  exported = function isWeakMap3(x2) {
    return false;
  };
}
var isWeakmap = exported || function isWeakMap2(x2) {
  if (!x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    $mapHas$1.call(x2, $mapHas$1);
    if ($setHas$1) {
      try {
        $setHas$1.call(x2, $setHas$1);
      } catch (e) {
        return true;
      }
    }
    return x2 instanceof $WeakMap;
  } catch (e) {
  }
  return false;
};
var isWeakset = { exports: {} };
var GetIntrinsic$5 = getIntrinsic;
var callBound$4 = callBound$9;
var $WeakSet = GetIntrinsic$5("%WeakSet%", true);
var $setHas = callBound$4("WeakSet.prototype.has", true);
if ($setHas) {
  var $mapHas = callBound$4("WeakMap.prototype.has", true);
  isWeakset.exports = function isWeakSet2(x2) {
    if (!x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      $setHas(x2, $setHas);
      if ($mapHas) {
        try {
          $mapHas(x2, $mapHas);
        } catch (e) {
          return true;
        }
      }
      return x2 instanceof $WeakSet;
    } catch (e) {
    }
    return false;
  };
} else {
  isWeakset.exports = function isWeakSet2(x2) {
    return false;
  };
}
var isMap = isMap$1;
var isSet = isSet$1;
var isWeakMap = isWeakmap;
var isWeakSet = isWeakset.exports;
var whichCollection$1 = function whichCollection2(value) {
  if (value && typeof value === "object") {
    if (isMap(value)) {
      return "Map";
    }
    if (isSet(value)) {
      return "Set";
    }
    if (isWeakMap(value)) {
      return "WeakMap";
    }
    if (isWeakSet(value)) {
      return "WeakSet";
    }
  }
  return false;
};
var isString$3 = isString$4;
var isNumber$1 = isNumberObject;
var isBoolean = isBooleanObject;
var isSymbol$1 = isSymbol$2.exports;
var isBigInt = isBigint.exports;
var whichBoxedPrimitive$1 = function whichBoxedPrimitive2(value) {
  if (value == null || typeof value !== "object" && typeof value !== "function") {
    return null;
  }
  if (isString$3(value)) {
    return "String";
  }
  if (isNumber$1(value)) {
    return "Number";
  }
  if (isBoolean(value)) {
    return "Boolean";
  }
  if (isSymbol$1(value)) {
    return "Symbol";
  }
  if (isBigInt(value)) {
    return "BigInt";
  }
};
var RequireObjectCoercible$2 = { exports: {} };
var GetIntrinsic$4 = getIntrinsic;
var $TypeError$2 = GetIntrinsic$4("%TypeError%");
var CheckObjectCoercible = function CheckObjectCoercible2(value, optMessage) {
  if (value == null) {
    throw new $TypeError$2(optMessage || "Cannot call method on " + value);
  }
  return value;
};
(function(module) {
  module.exports = CheckObjectCoercible;
})(RequireObjectCoercible$2);
var GetIntrinsic$3 = getIntrinsic;
var $Object$1 = GetIntrinsic$3("%Object%");
var RequireObjectCoercible$1 = RequireObjectCoercible$2.exports;
var ToObject$1 = function ToObject2(value) {
  RequireObjectCoercible$1(value);
  return $Object$1(value);
};
var toStr$3 = Object.prototype.toString;
var isArguments$2 = function isArguments4(value) {
  var str2 = toStr$3.call(value);
  var isArgs2 = str2 === "[object Arguments]";
  if (!isArgs2) {
    isArgs2 = str2 !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr$3.call(value.callee) === "[object Function]";
  }
  return isArgs2;
};
var implementation$9;
var hasRequiredImplementation$1;
function requireImplementation$1() {
  if (hasRequiredImplementation$1)
    return implementation$9;
  hasRequiredImplementation$1 = 1;
  var keysShim2;
  if (!Object.keys) {
    var has2 = Object.prototype.hasOwnProperty;
    var toStr2 = Object.prototype.toString;
    var isArgs2 = isArguments$2;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
    var hasProtoEnumBug = isEnumerable.call(function() {
    }, "prototype");
    var dontEnums = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ];
    var equalsConstructorPrototype = function(o) {
      var ctor = o.constructor;
      return ctor && ctor.prototype === o;
    };
    var excludedKeys = {
      $applicationCache: true,
      $console: true,
      $external: true,
      $frame: true,
      $frameElement: true,
      $frames: true,
      $innerHeight: true,
      $innerWidth: true,
      $onmozfullscreenchange: true,
      $onmozfullscreenerror: true,
      $outerHeight: true,
      $outerWidth: true,
      $pageXOffset: true,
      $pageYOffset: true,
      $parent: true,
      $scrollLeft: true,
      $scrollTop: true,
      $scrollX: true,
      $scrollY: true,
      $self: true,
      $webkitIndexedDB: true,
      $webkitStorageInfo: true,
      $window: true
    };
    var hasAutomationEqualityBug = function() {
      if (typeof window === "undefined") {
        return false;
      }
      for (var k2 in window) {
        try {
          if (!excludedKeys["$" + k2] && has2.call(window, k2) && window[k2] !== null && typeof window[k2] === "object") {
            try {
              equalsConstructorPrototype(window[k2]);
            } catch (e) {
              return true;
            }
          }
        } catch (e) {
          return true;
        }
      }
      return false;
    }();
    var equalsConstructorPrototypeIfNotBuggy = function(o) {
      if (typeof window === "undefined" || !hasAutomationEqualityBug) {
        return equalsConstructorPrototype(o);
      }
      try {
        return equalsConstructorPrototype(o);
      } catch (e) {
        return false;
      }
    };
    keysShim2 = function keys3(object) {
      var isObject3 = object !== null && typeof object === "object";
      var isFunction2 = toStr2.call(object) === "[object Function]";
      var isArguments5 = isArgs2(object);
      var isString3 = isObject3 && toStr2.call(object) === "[object String]";
      var theKeys = [];
      if (!isObject3 && !isFunction2 && !isArguments5) {
        throw new TypeError("Object.keys called on a non-object");
      }
      var skipProto = hasProtoEnumBug && isFunction2;
      if (isString3 && object.length > 0 && !has2.call(object, 0)) {
        for (var i2 = 0; i2 < object.length; ++i2) {
          theKeys.push(String(i2));
        }
      }
      if (isArguments5 && object.length > 0) {
        for (var j = 0; j < object.length; ++j) {
          theKeys.push(String(j));
        }
      } else {
        for (var name2 in object) {
          if (!(skipProto && name2 === "prototype") && has2.call(object, name2)) {
            theKeys.push(String(name2));
          }
        }
      }
      if (hasDontEnumBug) {
        var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
        for (var k2 = 0; k2 < dontEnums.length; ++k2) {
          if (!(skipConstructor && dontEnums[k2] === "constructor") && has2.call(object, dontEnums[k2])) {
            theKeys.push(dontEnums[k2]);
          }
        }
      }
      return theKeys;
    };
  }
  implementation$9 = keysShim2;
  return implementation$9;
}
var slice = Array.prototype.slice;
var isArgs = isArguments$2;
var origKeys = Object.keys;
var keysShim = origKeys ? function keys2(o) {
  return origKeys(o);
} : requireImplementation$1();
var originalKeys = Object.keys;
keysShim.shim = function shimObjectKeys() {
  if (Object.keys) {
    var keysWorksWithArguments = function() {
      var args = Object.keys(arguments);
      return args && args.length === arguments.length;
    }(1, 2);
    if (!keysWorksWithArguments) {
      Object.keys = function keys3(object) {
        if (isArgs(object)) {
          return originalKeys(slice.call(object));
        }
        return originalKeys(object);
      };
    }
  } else {
    Object.keys = keysShim;
  }
  return Object.keys || keysShim;
};
var objectKeys = keysShim;
var GetIntrinsic$2 = getIntrinsic;
var $defineProperty = GetIntrinsic$2("%Object.defineProperty%", true);
var hasPropertyDescriptors$1 = function hasPropertyDescriptors2() {
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
      return true;
    } catch (e) {
      return false;
    }
  }
  return false;
};
hasPropertyDescriptors$1.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
  if (!hasPropertyDescriptors$1()) {
    return null;
  }
  try {
    return $defineProperty([], "length", { value: 1 }).length !== 1;
  } catch (e) {
    return true;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors$1;
var keys$1 = objectKeys;
var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
var toStr$2 = Object.prototype.toString;
var concat$1 = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;
var isFunction$3 = function(fn2) {
  return typeof fn2 === "function" && toStr$2.call(fn2) === "[object Function]";
};
var hasPropertyDescriptors = hasPropertyDescriptors_1();
var supportsDescriptors$1 = origDefineProperty && hasPropertyDescriptors;
var defineProperty$2 = function(object, name2, value, predicate) {
  if (name2 in object && (!isFunction$3(predicate) || !predicate())) {
    return;
  }
  if (supportsDescriptors$1) {
    origDefineProperty(object, name2, {
      configurable: true,
      enumerable: false,
      value,
      writable: true
    });
  } else {
    object[name2] = value;
  }
};
var defineProperties = function(object, map2) {
  var predicates = arguments.length > 2 ? arguments[2] : {};
  var props = keys$1(map2);
  if (hasSymbols) {
    props = concat$1.call(props, Object.getOwnPropertySymbols(map2));
  }
  for (var i2 = 0; i2 < props.length; i2 += 1) {
    defineProperty$2(object, props[i2], map2[props[i2]], predicates[props[i2]]);
  }
};
defineProperties.supportsDescriptors = !!supportsDescriptors$1;
var defineProperties_1 = defineProperties;
var IsCallable$2 = { exports: {} };
(function(module) {
  module.exports = isCallable$1;
})(IsCallable$2);
var Type$3 = function Type2(x2) {
  if (x2 === null) {
    return "Null";
  }
  if (typeof x2 === "undefined") {
    return "Undefined";
  }
  if (typeof x2 === "function" || typeof x2 === "object") {
    return "Object";
  }
  if (typeof x2 === "number") {
    return "Number";
  }
  if (typeof x2 === "boolean") {
    return "Boolean";
  }
  if (typeof x2 === "string") {
    return "String";
  }
};
var ES5Type = Type$3;
var Type$2 = function Type3(x2) {
  if (typeof x2 === "symbol") {
    return "Symbol";
  }
  if (typeof x2 === "bigint") {
    return "BigInt";
  }
  return ES5Type(x2);
};
var isCallable = isCallable$1;
var toStr$1 = Object.prototype.toString;
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var forEachArray = function forEachArray2(array, iterator, receiver) {
  for (var i2 = 0, len = array.length; i2 < len; i2++) {
    if (hasOwnProperty$1.call(array, i2)) {
      if (receiver == null) {
        iterator(array[i2], i2, array);
      } else {
        iterator.call(receiver, array[i2], i2, array);
      }
    }
  }
};
var forEachString = function forEachString2(string2, iterator, receiver) {
  for (var i2 = 0, len = string2.length; i2 < len; i2++) {
    if (receiver == null) {
      iterator(string2.charAt(i2), i2, string2);
    } else {
      iterator.call(receiver, string2.charAt(i2), i2, string2);
    }
  }
};
var forEachObject = function forEachObject2(object, iterator, receiver) {
  for (var k2 in object) {
    if (hasOwnProperty$1.call(object, k2)) {
      if (receiver == null) {
        iterator(object[k2], k2, object);
      } else {
        iterator.call(receiver, object[k2], k2, object);
      }
    }
  }
};
var forEach$3 = function forEach2(list, iterator, thisArg) {
  if (!isCallable(iterator)) {
    throw new TypeError("iterator must be a function");
  }
  var receiver;
  if (arguments.length >= 3) {
    receiver = thisArg;
  }
  if (toStr$1.call(list) === "[object Array]") {
    forEachArray(list, iterator, receiver);
  } else if (typeof list === "string") {
    forEachString(list, iterator, receiver);
  } else {
    forEachObject(list, iterator, receiver);
  }
};
var forEach_1 = forEach$3;
var possibleNames = [
  "BigInt64Array",
  "BigUint64Array",
  "Float32Array",
  "Float64Array",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "Uint16Array",
  "Uint32Array",
  "Uint8Array",
  "Uint8ClampedArray"
];
var g$1 = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
var availableTypedArrays$1 = function availableTypedArrays2() {
  var out = [];
  for (var i2 = 0; i2 < possibleNames.length; i2++) {
    if (typeof g$1[possibleNames[i2]] === "function") {
      out[out.length] = possibleNames[i2];
    }
  }
  return out;
};
var getOwnPropertyDescriptor;
var hasRequiredGetOwnPropertyDescriptor;
function requireGetOwnPropertyDescriptor() {
  if (hasRequiredGetOwnPropertyDescriptor)
    return getOwnPropertyDescriptor;
  hasRequiredGetOwnPropertyDescriptor = 1;
  var GetIntrinsic3 = getIntrinsic;
  var $gOPD2 = GetIntrinsic3("%Object.getOwnPropertyDescriptor%", true);
  if ($gOPD2) {
    try {
      $gOPD2([], "length");
    } catch (e) {
      $gOPD2 = null;
    }
  }
  getOwnPropertyDescriptor = $gOPD2;
  return getOwnPropertyDescriptor;
}
var isTypedArray$2;
var hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray)
    return isTypedArray$2;
  hasRequiredIsTypedArray = 1;
  var forEach4 = forEach_1;
  var availableTypedArrays3 = availableTypedArrays$1;
  var callBound2 = callBound$9;
  var $toString2 = callBound2("Object.prototype.toString");
  var hasToStringTag2 = shams();
  var g2 = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
  var typedArrays2 = availableTypedArrays3();
  var $indexOf2 = callBound2("Array.prototype.indexOf", true) || function indexOf(array, value) {
    for (var i2 = 0; i2 < array.length; i2 += 1) {
      if (array[i2] === value) {
        return i2;
      }
    }
    return -1;
  };
  var $slice2 = callBound2("String.prototype.slice");
  var toStrTags2 = {};
  var gOPD2 = requireGetOwnPropertyDescriptor();
  var getPrototypeOf7 = Object.getPrototypeOf;
  if (hasToStringTag2 && gOPD2 && getPrototypeOf7) {
    forEach4(typedArrays2, function(typedArray) {
      var arr = new g2[typedArray]();
      if (Symbol.toStringTag in arr) {
        var proto2 = getPrototypeOf7(arr);
        var descriptor2 = gOPD2(proto2, Symbol.toStringTag);
        if (!descriptor2) {
          var superProto = getPrototypeOf7(proto2);
          descriptor2 = gOPD2(superProto, Symbol.toStringTag);
        }
        toStrTags2[typedArray] = descriptor2.get;
      }
    });
  }
  var tryTypedArrays2 = function tryAllTypedArrays2(value) {
    var anyTrue = false;
    forEach4(toStrTags2, function(getter, typedArray) {
      if (!anyTrue) {
        try {
          anyTrue = getter.call(value) === typedArray;
        } catch (e) {
        }
      }
    });
    return anyTrue;
  };
  isTypedArray$2 = function isTypedArray2(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    if (!hasToStringTag2 || !(Symbol.toStringTag in value)) {
      var tag2 = $slice2($toString2(value), 8, -1);
      return $indexOf2(typedArrays2, tag2) > -1;
    }
    if (!gOPD2) {
      return false;
    }
    return tryTypedArrays2(value);
  };
  return isTypedArray$2;
}
var forEach$2 = forEach_1;
var availableTypedArrays = availableTypedArrays$1;
var callBound$3 = callBound$9;
var $toString = callBound$3("Object.prototype.toString");
var hasToStringTag$2 = shams();
var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
var typedArrays = availableTypedArrays();
var $slice = callBound$3("String.prototype.slice");
var toStrTags = {};
var gOPD = requireGetOwnPropertyDescriptor();
var getPrototypeOf = Object.getPrototypeOf;
if (hasToStringTag$2 && gOPD && getPrototypeOf) {
  forEach$2(typedArrays, function(typedArray) {
    if (typeof g[typedArray] === "function") {
      var arr = new g[typedArray]();
      if (Symbol.toStringTag in arr) {
        var proto2 = getPrototypeOf(arr);
        var descriptor2 = gOPD(proto2, Symbol.toStringTag);
        if (!descriptor2) {
          var superProto = getPrototypeOf(proto2);
          descriptor2 = gOPD(superProto, Symbol.toStringTag);
        }
        toStrTags[typedArray] = descriptor2.get;
      }
    }
  });
}
var tryTypedArrays = function tryAllTypedArrays(value) {
  var foundName = false;
  forEach$2(toStrTags, function(getter, typedArray) {
    if (!foundName) {
      try {
        var name2 = getter.call(value);
        if (name2 === typedArray) {
          foundName = name2;
        }
      } catch (e) {
      }
    }
  });
  return foundName;
};
var isTypedArray$1 = requireIsTypedArray();
var whichTypedArray$1 = function whichTypedArray2(value) {
  if (!isTypedArray$1(value)) {
    return false;
  }
  if (!hasToStringTag$2 || !(Symbol.toStringTag in value)) {
    return $slice($toString(value), 8, -1);
  }
  return tryTypedArrays(value);
};
var callBound$2 = callBound$9;
var $deref = callBound$2("WeakRef.prototype.deref", true);
var isWeakref = typeof WeakRef === "undefined" ? function isWeakRef2(value) {
  return false;
} : function isWeakRef3(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  try {
    $deref(value);
    return true;
  } catch (e) {
    return false;
  }
};
var callBound$1 = callBound$9;
var $register = callBound$1("FinalizationRegistry.prototype.register", true);
var isFinalizationregistry = $register ? function isFinalizationRegistry2(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  try {
    $register(value, {});
    return true;
  } catch (e) {
    return false;
  }
} : function isFinalizationRegistry3(value) {
  return false;
};
var functionsHaveNames_1;
var hasRequiredFunctionsHaveNames;
function requireFunctionsHaveNames() {
  if (hasRequiredFunctionsHaveNames)
    return functionsHaveNames_1;
  hasRequiredFunctionsHaveNames = 1;
  var functionsHaveNames2 = function functionsHaveNames3() {
    return typeof function f() {
    }.name === "string";
  };
  var gOPD2 = Object.getOwnPropertyDescriptor;
  if (gOPD2) {
    try {
      gOPD2([], "length");
    } catch (e) {
      gOPD2 = null;
    }
  }
  functionsHaveNames2.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
    if (!functionsHaveNames2() || !gOPD2) {
      return false;
    }
    var desc = gOPD2(function() {
    }, "name");
    return !!desc && !!desc.configurable;
  };
  var $bind = Function.prototype.bind;
  functionsHaveNames2.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
    return functionsHaveNames2() && typeof $bind === "function" && function f() {
    }.bind().name !== "";
  };
  functionsHaveNames_1 = functionsHaveNames2;
  return functionsHaveNames_1;
}
var IsCallable$1 = IsCallable$2.exports;
var functionsHaveNames$1 = requireFunctionsHaveNames()();
var callBound = callBound$9;
var $functionToString = callBound("Function.prototype.toString");
var $stringMatch = callBound("String.prototype.match");
var classRegex = /^class /;
var isClass = function isClassConstructor(fn2) {
  if (IsCallable$1(fn2)) {
    return false;
  }
  if (typeof fn2 !== "function") {
    return false;
  }
  try {
    var match5 = $stringMatch($functionToString(fn2), classRegex);
    return !!match5;
  } catch (e) {
  }
  return false;
};
var regex = /\s*function\s+([^(\s]*)\s*/;
var functionProto = Function.prototype;
var implementation$8 = function getName() {
  if (!isClass(this) && !IsCallable$1(this)) {
    throw new TypeError("Function.prototype.name sham getter called on non-function");
  }
  if (functionsHaveNames$1) {
    return this.name;
  }
  if (this === functionProto) {
    return "";
  }
  var str2 = $functionToString(this);
  var match5 = $stringMatch(str2, regex);
  var name2 = match5 && match5[1];
  return name2;
};
var implementation$7 = implementation$8;
var polyfill$3 = function getPolyfill2() {
  return implementation$7;
};
var supportsDescriptors = defineProperties_1.supportsDescriptors;
var functionsHaveNames = requireFunctionsHaveNames()();
var getPolyfill$3 = polyfill$3;
var defineProperty$1 = Object.defineProperty;
var TypeErr = TypeError;
var shim$8 = function shimName() {
  var polyfill2 = getPolyfill$3();
  if (functionsHaveNames) {
    return polyfill2;
  }
  if (!supportsDescriptors) {
    throw new TypeErr("Shimming Function.prototype.name support requires ES5 property descriptor support.");
  }
  var functionProto2 = Function.prototype;
  defineProperty$1(functionProto2, "name", {
    configurable: true,
    enumerable: false,
    get: function() {
      var name2 = polyfill2.call(this);
      if (this !== functionProto2) {
        defineProperty$1(this, "name", {
          configurable: true,
          enumerable: false,
          value: name2,
          writable: false
        });
      }
      return name2;
    }
  });
  return polyfill2;
};
var define$y = defineProperties_1;
var callBind$1 = callBind$3.exports;
var implementation$6 = implementation$8;
var getPolyfill$2 = polyfill$3;
var shim$7 = shim$8;
var bound$1 = callBind$1(implementation$6);
define$y(bound$1, {
  getPolyfill: getPolyfill$2,
  implementation: implementation$6,
  shim: shim$7
});
var function_prototype_name = bound$1;
var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*async(?:\s+function(?:\s+|\()|\s*\()/;
var hasToStringTag$1 = shams();
var getProto$2 = Object.getPrototypeOf;
var getAsyncFunc = function() {
  if (!hasToStringTag$1) {
    return false;
  }
  try {
    return Function("return async function () {}")();
  } catch (e) {
  }
};
var AsyncFunction;
var isAsyncFunction$1 = function isAsyncFunction2(fn2) {
  if (typeof fn2 !== "function") {
    return false;
  }
  if (isFnRegex.test(fnToStr.call(fn2))) {
    return true;
  }
  if (!hasToStringTag$1) {
    var str2 = toStr.call(fn2);
    return str2 === "[object AsyncFunction]";
  }
  if (!getProto$2) {
    return false;
  }
  if (typeof AsyncFunction === "undefined") {
    var asyncFunc = getAsyncFunc();
    AsyncFunction = asyncFunc ? getProto$2(asyncFunc) : false;
  }
  return getProto$2(fn2) === AsyncFunction;
};
var whichBoxedPrimitive = whichBoxedPrimitive$1;
var whichCollection = whichCollection$1;
var whichTypedArray = whichTypedArray$1;
var isArray$4 = isarray;
var isDate$3 = isDateObject;
var isRegex = isRegex$1;
var isWeakRef = isWeakref;
var isFinalizationRegistry = isFinalizationregistry;
var name = function_prototype_name;
var isGeneratorFunction = isGeneratorFunction$1;
var isAsyncFunction = isAsyncFunction$1;
var hasToStringTag = shams();
var toStringTag = hasToStringTag && Symbol.toStringTag;
var $Object = Object;
var promiseThen = typeof Promise === "function" && Promise.prototype.then;
var isPromise = function isPromise2(value) {
  if (!value || typeof value !== "object" || !promiseThen) {
    return false;
  }
  try {
    promiseThen.call(value, null, function() {
    });
    return true;
  } catch (e) {
  }
  return false;
};
var isKnownBuiltin = function isKnownBuiltin2(builtinName) {
  return builtinName && builtinName !== "BigInt" && builtinName !== "Boolean" && builtinName !== "Null" && builtinName !== "Number" && builtinName !== "String" && builtinName !== "Symbol" && builtinName !== "Undefined" && builtinName !== "Math" && builtinName !== "JSON" && builtinName !== "Reflect" && builtinName !== "Atomics" && builtinName !== "Map" && builtinName !== "Set" && builtinName !== "WeakMap" && builtinName !== "WeakSet" && builtinName !== "BigInt64Array" && builtinName !== "BigUint64Array" && builtinName !== "Float32Array" && builtinName !== "Float64Array" && builtinName !== "Int16Array" && builtinName !== "Int32Array" && builtinName !== "Int8Array" && builtinName !== "Uint16Array" && builtinName !== "Uint32Array" && builtinName !== "Uint8Array" && builtinName !== "Uint8ClampedArray" && builtinName !== "Array" && builtinName !== "Date" && builtinName !== "FinalizationRegistry" && builtinName !== "Promise" && builtinName !== "RegExp" && builtinName !== "WeakRef" && builtinName !== "Function" && builtinName !== "GeneratorFunction" && builtinName !== "AsyncFunction";
};
var whichBuiltinType$1 = function whichBuiltinType2(value) {
  if (value == null) {
    return value;
  }
  var which = whichBoxedPrimitive($Object(value)) || whichCollection(value) || whichTypedArray(value);
  if (which) {
    return which;
  }
  if (isArray$4(value)) {
    return "Array";
  }
  if (isDate$3(value)) {
    return "Date";
  }
  if (isRegex(value)) {
    return "RegExp";
  }
  if (isWeakRef(value)) {
    return "WeakRef";
  }
  if (isFinalizationRegistry(value)) {
    return "FinalizationRegistry";
  }
  if (typeof value === "function") {
    if (isGeneratorFunction(value)) {
      return "GeneratorFunction";
    }
    if (isAsyncFunction(value)) {
      return "AsyncFunction";
    }
    return "Function";
  }
  if (isPromise(value)) {
    return "Promise";
  }
  if (toStringTag && toStringTag in value) {
    var tag2 = value[toStringTag];
    if (isKnownBuiltin(tag2)) {
      return tag2;
    }
  }
  if (typeof value.constructor === "function") {
    var constructorName = name(value.constructor);
    if (isKnownBuiltin(constructorName)) {
      return constructorName;
    }
  }
  return "Object";
};
var GetIntrinsic$1 = getIntrinsic;
var IsCallable = IsCallable$2.exports;
var Type$1 = Type$2;
var whichBuiltinType = whichBuiltinType$1;
var $gPO = GetIntrinsic$1("%Object.getPrototypeOf%", true);
var $ObjectPrototype = GetIntrinsic$1("%Object.prototype%");
var $TypeError$1 = GetIntrinsic$1("%TypeError%");
var hasProto$2 = [].__proto__ === Array.prototype;
var implementation$5 = function getPrototypeOf2(O2) {
  if (Type$1(O2) !== "Object") {
    throw new $TypeError$1("Reflect.getPrototypeOf called on non-object");
  }
  if ($gPO) {
    return $gPO(O2);
  }
  if (hasProto$2) {
    var proto2 = O2.__proto__;
    if (proto2 || proto2 === null) {
      return proto2;
    }
  }
  var type = whichBuiltinType(O2);
  if (type) {
    var intrinsic = GetIntrinsic$1("%" + type + "%.prototype", true);
    if (intrinsic) {
      return intrinsic;
    }
  }
  if (IsCallable(O2.constructor)) {
    return O2.constructor.prototype;
  }
  if (O2 instanceof Object) {
    return $ObjectPrototype;
  }
  return null;
};
var Type = Type$2;
var GetIntrinsic = getIntrinsic;
var $TypeError = GetIntrinsic("%TypeError%");
var implementation$4 = implementation$5;
var hasProto$1 = [].__proto__ === Array.prototype;
var getProto$1 = function getPrototypeOf3(value) {
  if (Type(value) !== "Object") {
    throw new $TypeError("Reflect.getPrototypeOf called on non-object");
  }
  return value.__proto__;
};
var polyfill$2 = function getPolyfill3() {
  if (typeof Reflect === "object" && Reflect && Reflect.getPrototypeOf) {
    return Reflect.getPrototypeOf;
  }
  if (hasProto$1) {
    return getProto$1;
  }
  return implementation$4;
};
var define$x = defineProperties_1;
var getPolyfill$1 = polyfill$2;
var shim$6 = function shimGetPrototypeOf() {
  define$x(
    commonjsGlobal,
    { Reflect: {} },
    { Reflect: function() {
      return typeof Reflect !== "object" || !Reflect;
    } }
  );
  var polyfill2 = getPolyfill$1();
  define$x(
    Reflect,
    { getPrototypeOf: polyfill2 },
    { getPrototypeOf: function() {
      return Reflect.getPrototypeOf !== polyfill2;
    } }
  );
  return polyfill2;
};
var callBind = callBind$3.exports;
var define$w = defineProperties_1;
var implementation$3 = implementation$5;
var getPolyfill = polyfill$2;
var shim$5 = shim$6;
var bound = callBind(getPolyfill(), typeof Reflect === "object" ? Reflect : Object);
define$w(bound, {
  getPolyfill,
  implementation: implementation$3,
  shim: shim$5
});
var reflect_getprototypeof = bound;
var ToObject = ToObject$1;
var ReflectGetPrototypeOf = reflect_getprototypeof;
var implementation$2 = function getPrototypeOf4(O2) {
  return ReflectGetPrototypeOf(ToObject(O2));
};
var RequireObjectCoercible = RequireObjectCoercible$2.exports;
var implementation$1 = implementation$2;
var hasProto = [].__proto__ === Array.prototype;
var getProto = function getPrototypeOf5(value) {
  RequireObjectCoercible(value);
  return value.__proto__;
};
var $getPrototypeOf = Object.getPrototypeOf;
var getPrototypeOfPrimitivesToo = function getPrototypeOf6(value) {
  RequireObjectCoercible(value);
  return $getPrototypeOf(Object(value));
};
var polyfill$1 = function getPolyfill4() {
  if ($getPrototypeOf) {
    try {
      $getPrototypeOf(true);
    } catch (e) {
      return getPrototypeOfPrimitivesToo;
    }
    return $getPrototypeOf;
  }
  if (hasProto) {
    return getProto;
  }
  return implementation$1;
};
polyfill$1();
shams$1();
hasBigints();
requireFunctionsHaveNames()();
function __filter(object, filter2) {
  const result2 = {};
  Object.keys(object).forEach((propertyName) => {
    if (filter2(propertyName, object[propertyName])) {
      result2[propertyName] = object[propertyName];
    }
  });
  return result2;
}
function __flatten(object, settings = {}) {
  const toReturn = {};
  if (!Array.isArray(object) && !__isPlainObject(object))
    return object;
  settings = Object.assign({ separator: ".", array: false, quoteSeparatedProperties: true, quoteCharacter: '"', excludeProps: [], keepLastIntact: false }, settings);
  for (const key in object) {
    if (object[key] === void 0)
      continue;
    if (object[key] === null) {
      toReturn[key] = null;
      continue;
    }
    if (settings.excludeProps.indexOf(key) !== -1) {
      toReturn[key] = object[key];
      continue;
    }
    if (Array.isArray(object[key]) && settings.array || (!Array.isArray(object[key]) && typeof object[key]) == "object") {
      const isArray2 = Array.isArray(object[key]);
      const flatObject = __flatten(object[key], Object.assign(Object.assign({}, settings), { keepLastIntact: false }));
      for (const x2 in flatObject) {
        if (flatObject[x2] === void 0)
          continue;
        if (isArray2) {
          toReturn[`${key}[${x2}]`] = flatObject[x2];
        } else {
          const part = key;
          if (settings.quoteSeparatedProperties && part.includes(settings.separator)) {
            toReturn[`${settings.quoteCharacter}${key}${settings.quoteCharacter}` + settings.separator + x2] = flatObject[x2];
          } else {
            toReturn[key + settings.separator + x2] = flatObject[x2];
          }
        }
      }
      continue;
    }
    toReturn[key] = object[key];
  }
  return toReturn;
}
const __viteBrowserExternal_path = new Proxy({}, {
  get(_, key) {
    throw new Error(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code.`);
  }
});
const __viteBrowserExternal_path$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal_path
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$3 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal_path$1);
var concatMap$1 = function(xs2, fn2) {
  var res = [];
  for (var i2 = 0; i2 < xs2.length; i2++) {
    var x2 = fn2(xs2[i2], i2);
    if (isArray$3(x2))
      res.push.apply(res, x2);
    else
      res.push(x2);
  }
  return res;
};
var isArray$3 = Array.isArray || function(xs2) {
  return Object.prototype.toString.call(xs2) === "[object Array]";
};
var balancedMatch = balanced$1;
function balanced$1(a3, b2, str2) {
  if (a3 instanceof RegExp)
    a3 = maybeMatch(a3, str2);
  if (b2 instanceof RegExp)
    b2 = maybeMatch(b2, str2);
  var r = range(a3, b2, str2);
  return r && {
    start: r[0],
    end: r[1],
    pre: str2.slice(0, r[0]),
    body: str2.slice(r[0] + a3.length, r[1]),
    post: str2.slice(r[1] + b2.length)
  };
}
function maybeMatch(reg, str2) {
  var m2 = str2.match(reg);
  return m2 ? m2[0] : null;
}
balanced$1.range = range;
function range(a3, b2, str2) {
  var begs, beg, left, right, result2;
  var ai2 = str2.indexOf(a3);
  var bi2 = str2.indexOf(b2, ai2 + 1);
  var i2 = ai2;
  if (ai2 >= 0 && bi2 > 0) {
    if (a3 === b2) {
      return [ai2, bi2];
    }
    begs = [];
    left = str2.length;
    while (i2 >= 0 && !result2) {
      if (i2 == ai2) {
        begs.push(i2);
        ai2 = str2.indexOf(a3, i2 + 1);
      } else if (begs.length == 1) {
        result2 = [begs.pop(), bi2];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi2;
        }
        bi2 = str2.indexOf(b2, i2 + 1);
      }
      i2 = ai2 < bi2 && ai2 >= 0 ? ai2 : bi2;
    }
    if (begs.length) {
      result2 = [left, right];
    }
  }
  return result2;
}
var concatMap = concatMap$1;
var balanced = balancedMatch;
var braceExpansion = expandTop;
var escSlash = "\0SLASH" + Math.random() + "\0";
var escOpen = "\0OPEN" + Math.random() + "\0";
var escClose = "\0CLOSE" + Math.random() + "\0";
var escComma = "\0COMMA" + Math.random() + "\0";
var escPeriod = "\0PERIOD" + Math.random() + "\0";
function numeric(str2) {
  return parseInt(str2, 10) == str2 ? parseInt(str2, 10) : str2.charCodeAt(0);
}
function escapeBraces(str2) {
  return str2.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
}
function unescapeBraces(str2) {
  return str2.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
}
function parseCommaParts(str2) {
  if (!str2)
    return [""];
  var parts = [];
  var m2 = balanced("{", "}", str2);
  if (!m2)
    return str2.split(",");
  var pre = m2.pre;
  var body = m2.body;
  var post = m2.post;
  var p = pre.split(",");
  p[p.length - 1] += "{" + body + "}";
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length - 1] += postParts.shift();
    p.push.apply(p, postParts);
  }
  parts.push.apply(parts, p);
  return parts;
}
function expandTop(str2) {
  if (!str2)
    return [];
  if (str2.substr(0, 2) === "{}") {
    str2 = "\\{\\}" + str2.substr(2);
  }
  return expand$1(escapeBraces(str2), true).map(unescapeBraces);
}
function embrace(str2) {
  return "{" + str2 + "}";
}
function isPadded(el2) {
  return /^-?0\d/.test(el2);
}
function lte(i2, y) {
  return i2 <= y;
}
function gte(i2, y) {
  return i2 >= y;
}
function expand$1(str2, isTop) {
  var expansions = [];
  var m2 = balanced("{", "}", str2);
  if (!m2 || /\$$/.test(m2.pre))
    return [str2];
  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m2.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m2.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m2.body.indexOf(",") >= 0;
  if (!isSequence && !isOptions) {
    if (m2.post.match(/,.*\}/)) {
      str2 = m2.pre + "{" + m2.body + escClose + m2.post;
      return expand$1(str2);
    }
    return [str2];
  }
  var n;
  if (isSequence) {
    n = m2.body.split(/\.\./);
  } else {
    n = parseCommaParts(m2.body);
    if (n.length === 1) {
      n = expand$1(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m2.post.length ? expand$1(m2.post, false) : [""];
        return post.map(function(p) {
          return m2.pre + n[0] + p;
        });
      }
    }
  }
  var pre = m2.pre;
  var post = m2.post.length ? expand$1(m2.post, false) : [""];
  var N;
  if (isSequence) {
    var x2 = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length);
    var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
    var test2 = lte;
    var reverse = y < x2;
    if (reverse) {
      incr *= -1;
      test2 = gte;
    }
    var pad2 = n.some(isPadded);
    N = [];
    for (var i2 = x2; test2(i2, y); i2 += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i2);
        if (c === "\\")
          c = "";
      } else {
        c = String(i2);
        if (pad2) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join("0");
            if (i2 < 0)
              c = "-" + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el2) {
      return expand$1(el2, false);
    });
  }
  for (var j = 0; j < N.length; j++) {
    for (var k2 = 0; k2 < post.length; k2++) {
      var expansion = pre + N[j] + post[k2];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }
  return expansions;
}
minimatch.Minimatch = Minimatch;
var path = function() {
  try {
    return require$$0$3;
  } catch (e) {
  }
}() || {
  sep: "/"
};
minimatch.sep = path.sep;
var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
var expand = braceExpansion;
var plTypes = {
  "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
  "?": { open: "(?:", close: ")?" },
  "+": { open: "(?:", close: ")+" },
  "*": { open: "(?:", close: ")*" },
  "@": { open: "(?:", close: ")" }
};
var qmark = "[^/]";
var star = qmark + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var reSpecials = charSet("().*{}+?[]^$\\!");
function charSet(s2) {
  return s2.split("").reduce(function(set, c) {
    set[c] = true;
    return set;
  }, {});
}
var slashSplit = /\/+/;
minimatch.filter = filter$1;
function filter$1(pattern2, options) {
  options = options || {};
  return function(p, i2, list) {
    return minimatch(p, pattern2, options);
  };
}
function ext(a3, b2) {
  b2 = b2 || {};
  var t = {};
  Object.keys(a3).forEach(function(k2) {
    t[k2] = a3[k2];
  });
  Object.keys(b2).forEach(function(k2) {
    t[k2] = b2[k2];
  });
  return t;
}
minimatch.defaults = function(def) {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch;
  }
  var orig = minimatch;
  var m2 = function minimatch2(p, pattern2, options) {
    return orig(p, pattern2, ext(def, options));
  };
  m2.Minimatch = function Minimatch2(pattern2, options) {
    return new orig.Minimatch(pattern2, ext(def, options));
  };
  m2.Minimatch.defaults = function defaults2(options) {
    return orig.defaults(ext(def, options)).Minimatch;
  };
  m2.filter = function filter2(pattern2, options) {
    return orig.filter(pattern2, ext(def, options));
  };
  m2.defaults = function defaults2(options) {
    return orig.defaults(ext(def, options));
  };
  m2.makeRe = function makeRe2(pattern2, options) {
    return orig.makeRe(pattern2, ext(def, options));
  };
  m2.braceExpand = function braceExpand2(pattern2, options) {
    return orig.braceExpand(pattern2, ext(def, options));
  };
  m2.match = function(list, pattern2, options) {
    return orig.match(list, pattern2, ext(def, options));
  };
  return m2;
};
Minimatch.defaults = function(def) {
  return minimatch.defaults(def).Minimatch;
};
function minimatch(p, pattern2, options) {
  assertValidPattern(pattern2);
  if (!options)
    options = {};
  if (!options.nocomment && pattern2.charAt(0) === "#") {
    return false;
  }
  return new Minimatch(pattern2, options).match(p);
}
function Minimatch(pattern2, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern2, options);
  }
  assertValidPattern(pattern2);
  if (!options)
    options = {};
  pattern2 = pattern2.trim();
  if (!options.allowWindowsEscape && path.sep !== "/") {
    pattern2 = pattern2.split(path.sep).join("/");
  }
  this.options = options;
  this.set = [];
  this.pattern = pattern2;
  this.regexp = null;
  this.negate = false;
  this.comment = false;
  this.empty = false;
  this.partial = !!options.partial;
  this.make();
}
Minimatch.prototype.debug = function() {
};
Minimatch.prototype.make = make;
function make() {
  var pattern2 = this.pattern;
  var options = this.options;
  if (!options.nocomment && pattern2.charAt(0) === "#") {
    this.comment = true;
    return;
  }
  if (!pattern2) {
    this.empty = true;
    return;
  }
  this.parseNegate();
  var set = this.globSet = this.braceExpand();
  if (options.debug)
    this.debug = function debug() {
      console.error.apply(console, arguments);
    };
  this.debug(this.pattern, set);
  set = this.globParts = set.map(function(s2) {
    return s2.split(slashSplit);
  });
  this.debug(this.pattern, set);
  set = set.map(function(s2, si2, set2) {
    return s2.map(this.parse, this);
  }, this);
  this.debug(this.pattern, set);
  set = set.filter(function(s2) {
    return s2.indexOf(false) === -1;
  });
  this.debug(this.pattern, set);
  this.set = set;
}
Minimatch.prototype.parseNegate = parseNegate;
function parseNegate() {
  var pattern2 = this.pattern;
  var negate = false;
  var options = this.options;
  var negateOffset = 0;
  if (options.nonegate)
    return;
  for (var i2 = 0, l = pattern2.length; i2 < l && pattern2.charAt(i2) === "!"; i2++) {
    negate = !negate;
    negateOffset++;
  }
  if (negateOffset)
    this.pattern = pattern2.substr(negateOffset);
  this.negate = negate;
}
minimatch.braceExpand = function(pattern2, options) {
  return braceExpand(pattern2, options);
};
Minimatch.prototype.braceExpand = braceExpand;
function braceExpand(pattern2, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options;
    } else {
      options = {};
    }
  }
  pattern2 = typeof pattern2 === "undefined" ? this.pattern : pattern2;
  assertValidPattern(pattern2);
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern2)) {
    return [pattern2];
  }
  return expand(pattern2);
}
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = function(pattern2) {
  if (typeof pattern2 !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern2.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};
Minimatch.prototype.parse = parse$2;
var SUBPARSE = {};
function parse$2(pattern2, isSub) {
  assertValidPattern(pattern2);
  var options = this.options;
  if (pattern2 === "**") {
    if (!options.noglobstar)
      return GLOBSTAR;
    else
      pattern2 = "*";
  }
  if (pattern2 === "")
    return "";
  var re2 = "";
  var hasMagic = !!options.nocase;
  var escaping = false;
  var patternListStack = [];
  var negativeLists = [];
  var stateChar;
  var inClass = false;
  var reClassStart = -1;
  var classStart = -1;
  var patternStart = pattern2.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
  var self2 = this;
  function clearStateChar() {
    if (stateChar) {
      switch (stateChar) {
        case "*":
          re2 += star;
          hasMagic = true;
          break;
        case "?":
          re2 += qmark;
          hasMagic = true;
          break;
        default:
          re2 += "\\" + stateChar;
          break;
      }
      self2.debug("clearStateChar %j %j", stateChar, re2);
      stateChar = false;
    }
  }
  for (var i2 = 0, len = pattern2.length, c; i2 < len && (c = pattern2.charAt(i2)); i2++) {
    this.debug("%s	%s %s %j", pattern2, i2, re2, c);
    if (escaping && reSpecials[c]) {
      re2 += "\\" + c;
      escaping = false;
      continue;
    }
    switch (c) {
      case "/": {
        return false;
      }
      case "\\":
        clearStateChar();
        escaping = true;
        continue;
      case "?":
      case "*":
      case "+":
      case "@":
      case "!":
        this.debug("%s	%s %s %j <-- stateChar", pattern2, i2, re2, c);
        if (inClass) {
          this.debug("  in class");
          if (c === "!" && i2 === classStart + 1)
            c = "^";
          re2 += c;
          continue;
        }
        self2.debug("call clearStateChar %j", stateChar);
        clearStateChar();
        stateChar = c;
        if (options.noext)
          clearStateChar();
        continue;
      case "(":
        if (inClass) {
          re2 += "(";
          continue;
        }
        if (!stateChar) {
          re2 += "\\(";
          continue;
        }
        patternListStack.push({
          type: stateChar,
          start: i2 - 1,
          reStart: re2.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        });
        re2 += stateChar === "!" ? "(?:(?!(?:" : "(?:";
        this.debug("plType %j %j", stateChar, re2);
        stateChar = false;
        continue;
      case ")":
        if (inClass || !patternListStack.length) {
          re2 += "\\)";
          continue;
        }
        clearStateChar();
        hasMagic = true;
        var pl2 = patternListStack.pop();
        re2 += pl2.close;
        if (pl2.type === "!") {
          negativeLists.push(pl2);
        }
        pl2.reEnd = re2.length;
        continue;
      case "|":
        if (inClass || !patternListStack.length || escaping) {
          re2 += "\\|";
          escaping = false;
          continue;
        }
        clearStateChar();
        re2 += "|";
        continue;
      case "[":
        clearStateChar();
        if (inClass) {
          re2 += "\\" + c;
          continue;
        }
        inClass = true;
        classStart = i2;
        reClassStart = re2.length;
        re2 += c;
        continue;
      case "]":
        if (i2 === classStart + 1 || !inClass) {
          re2 += "\\" + c;
          escaping = false;
          continue;
        }
        var cs2 = pattern2.substring(classStart + 1, i2);
        try {
          RegExp("[" + cs2 + "]");
        } catch (er2) {
          var sp = this.parse(cs2, SUBPARSE);
          re2 = re2.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
          hasMagic = hasMagic || sp[1];
          inClass = false;
          continue;
        }
        hasMagic = true;
        inClass = false;
        re2 += c;
        continue;
      default:
        clearStateChar();
        if (escaping) {
          escaping = false;
        } else if (reSpecials[c] && !(c === "^" && inClass)) {
          re2 += "\\";
        }
        re2 += c;
    }
  }
  if (inClass) {
    cs2 = pattern2.substr(classStart + 1);
    sp = this.parse(cs2, SUBPARSE);
    re2 = re2.substr(0, reClassStart) + "\\[" + sp[0];
    hasMagic = hasMagic || sp[1];
  }
  for (pl2 = patternListStack.pop(); pl2; pl2 = patternListStack.pop()) {
    var tail = re2.slice(pl2.reStart + pl2.open.length);
    this.debug("setting tail", re2, pl2);
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
      if (!$2) {
        $2 = "\\";
      }
      return $1 + $1 + $2 + "|";
    });
    this.debug("tail=%j\n   %s", tail, tail, pl2, re2);
    var t = pl2.type === "*" ? star : pl2.type === "?" ? qmark : "\\" + pl2.type;
    hasMagic = true;
    re2 = re2.slice(0, pl2.reStart) + t + "\\(" + tail;
  }
  clearStateChar();
  if (escaping) {
    re2 += "\\\\";
  }
  var addPatternStart = false;
  switch (re2.charAt(0)) {
    case "[":
    case ".":
    case "(":
      addPatternStart = true;
  }
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl2 = negativeLists[n];
    var nlBefore = re2.slice(0, nl2.reStart);
    var nlFirst = re2.slice(nl2.reStart, nl2.reEnd - 8);
    var nlLast = re2.slice(nl2.reEnd - 8, nl2.reEnd);
    var nlAfter = re2.slice(nl2.reEnd);
    nlLast += nlAfter;
    var openParensBefore = nlBefore.split("(").length - 1;
    var cleanAfter = nlAfter;
    for (i2 = 0; i2 < openParensBefore; i2++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
    }
    nlAfter = cleanAfter;
    var dollar = "";
    if (nlAfter === "" && isSub !== SUBPARSE) {
      dollar = "$";
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
    re2 = newRe;
  }
  if (re2 !== "" && hasMagic) {
    re2 = "(?=.)" + re2;
  }
  if (addPatternStart) {
    re2 = patternStart + re2;
  }
  if (isSub === SUBPARSE) {
    return [re2, hasMagic];
  }
  if (!hasMagic) {
    return globUnescape(pattern2);
  }
  var flags = options.nocase ? "i" : "";
  try {
    var regExp = new RegExp("^" + re2 + "$", flags);
  } catch (er2) {
    return new RegExp("$.");
  }
  regExp._glob = pattern2;
  regExp._src = re2;
  return regExp;
}
minimatch.makeRe = function(pattern2, options) {
  return new Minimatch(pattern2, options || {}).makeRe();
};
Minimatch.prototype.makeRe = makeRe$1;
function makeRe$1() {
  if (this.regexp || this.regexp === false)
    return this.regexp;
  var set = this.set;
  if (!set.length) {
    this.regexp = false;
    return this.regexp;
  }
  var options = this.options;
  var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
  var flags = options.nocase ? "i" : "";
  var re2 = set.map(function(pattern2) {
    return pattern2.map(function(p) {
      return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
    }).join("\\/");
  }).join("|");
  re2 = "^(?:" + re2 + ")$";
  if (this.negate)
    re2 = "^(?!" + re2 + ").*$";
  try {
    this.regexp = new RegExp(re2, flags);
  } catch (ex) {
    this.regexp = false;
  }
  return this.regexp;
}
minimatch.match = function(list, pattern2, options) {
  options = options || {};
  var mm3 = new Minimatch(pattern2, options);
  list = list.filter(function(f) {
    return mm3.match(f);
  });
  if (mm3.options.nonull && !list.length) {
    list.push(pattern2);
  }
  return list;
};
Minimatch.prototype.match = function match(f, partial) {
  if (typeof partial === "undefined")
    partial = this.partial;
  this.debug("match", f, this.pattern);
  if (this.comment)
    return false;
  if (this.empty)
    return f === "";
  if (f === "/" && partial)
    return true;
  var options = this.options;
  if (path.sep !== "/") {
    f = f.split(path.sep).join("/");
  }
  f = f.split(slashSplit);
  this.debug(this.pattern, "split", f);
  var set = this.set;
  this.debug(this.pattern, "set", set);
  var filename;
  var i2;
  for (i2 = f.length - 1; i2 >= 0; i2--) {
    filename = f[i2];
    if (filename)
      break;
  }
  for (i2 = 0; i2 < set.length; i2++) {
    var pattern2 = set[i2];
    var file = f;
    if (options.matchBase && pattern2.length === 1) {
      file = [filename];
    }
    var hit = this.matchOne(file, pattern2, partial);
    if (hit) {
      if (options.flipNegate)
        return true;
      return !this.negate;
    }
  }
  if (options.flipNegate)
    return false;
  return this.negate;
};
Minimatch.prototype.matchOne = function(file, pattern2, partial) {
  var options = this.options;
  this.debug(
    "matchOne",
    { "this": this, file, pattern: pattern2 }
  );
  this.debug("matchOne", file.length, pattern2.length);
  for (var fi2 = 0, pi = 0, fl2 = file.length, pl2 = pattern2.length; fi2 < fl2 && pi < pl2; fi2++, pi++) {
    this.debug("matchOne loop");
    var p = pattern2[pi];
    var f = file[fi2];
    this.debug(pattern2, p, f);
    if (p === false)
      return false;
    if (p === GLOBSTAR) {
      this.debug("GLOBSTAR", [pattern2, p, f]);
      var fr2 = fi2;
      var pr2 = pi + 1;
      if (pr2 === pl2) {
        this.debug("** at the end");
        for (; fi2 < fl2; fi2++) {
          if (file[fi2] === "." || file[fi2] === ".." || !options.dot && file[fi2].charAt(0) === ".")
            return false;
        }
        return true;
      }
      while (fr2 < fl2) {
        var swallowee = file[fr2];
        this.debug("\nglobstar while", file, fr2, pattern2, pr2, swallowee);
        if (this.matchOne(file.slice(fr2), pattern2.slice(pr2), partial)) {
          this.debug("globstar found match!", fr2, fl2, swallowee);
          return true;
        } else {
          if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
            this.debug("dot detected!", file, fr2, pattern2, pr2);
            break;
          }
          this.debug("globstar swallow a segment, and continue");
          fr2++;
        }
      }
      if (partial) {
        this.debug("\n>>> no match, partial?", file, fr2, pattern2, pr2);
        if (fr2 === fl2)
          return true;
      }
      return false;
    }
    var hit;
    if (typeof p === "string") {
      hit = f === p;
      this.debug("string match", p, f, hit);
    } else {
      hit = f.match(p);
      this.debug("pattern match", p, f, hit);
    }
    if (!hit)
      return false;
  }
  if (fi2 === fl2 && pi === pl2) {
    return true;
  } else if (fi2 === fl2) {
    return partial;
  } else if (pi === pl2) {
    return fi2 === fl2 - 1 && file[fi2] === "";
  }
  throw new Error("wtf?");
};
function globUnescape(s2) {
  return s2.replace(/\\(.)/g, "$1");
}
function regExpEscape(s2) {
  return s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}
var object_hash = { exports: {} };
(function(module, exports) {
  !function(e) {
    module.exports = e();
  }(function() {
    return function o(i2, u, a3) {
      function s2(n, e2) {
        if (!u[n]) {
          if (!i2[n]) {
            var t = "function" == typeof commonjsRequire && commonjsRequire;
            if (!e2 && t)
              return t(n, true);
            if (f)
              return f(n, true);
            throw new Error("Cannot find module '" + n + "'");
          }
          var r = u[n] = { exports: {} };
          i2[n][0].call(r.exports, function(e3) {
            var t2 = i2[n][1][e3];
            return s2(t2 || e3);
          }, r, r.exports, o, i2, u, a3);
        }
        return u[n].exports;
      }
      for (var f = "function" == typeof commonjsRequire && commonjsRequire, e = 0; e < a3.length; e++)
        s2(a3[e]);
      return s2;
    }({ 1: [function(w2, b2, m2) {
      (function(e, t, f, n, r, o, i2, u, a3) {
        var s2 = w2("crypto");
        function c(e2, t2) {
          return function(e3, t3) {
            var n2;
            n2 = "passthrough" !== t3.algorithm ? s2.createHash(t3.algorithm) : new y();
            void 0 === n2.write && (n2.write = n2.update, n2.end = n2.update);
            g2(t3, n2).dispatch(e3), n2.update || n2.end("");
            if (n2.digest)
              return n2.digest("buffer" === t3.encoding ? void 0 : t3.encoding);
            var r2 = n2.read();
            return "buffer" !== t3.encoding ? r2.toString(t3.encoding) : r2;
          }(e2, t2 = h2(e2, t2));
        }
        (m2 = b2.exports = c).sha1 = function(e2) {
          return c(e2);
        }, m2.keys = function(e2) {
          return c(e2, { excludeValues: true, algorithm: "sha1", encoding: "hex" });
        }, m2.MD5 = function(e2) {
          return c(e2, { algorithm: "md5", encoding: "hex" });
        }, m2.keysMD5 = function(e2) {
          return c(e2, { algorithm: "md5", encoding: "hex", excludeValues: true });
        };
        var l = s2.getHashes ? s2.getHashes().slice() : ["sha1", "md5"];
        l.push("passthrough");
        var d4 = ["buffer", "hex", "binary", "base64"];
        function h2(e2, t2) {
          t2 = t2 || {};
          var n2 = {};
          if (n2.algorithm = t2.algorithm || "sha1", n2.encoding = t2.encoding || "hex", n2.excludeValues = !!t2.excludeValues, n2.algorithm = n2.algorithm.toLowerCase(), n2.encoding = n2.encoding.toLowerCase(), n2.ignoreUnknown = true === t2.ignoreUnknown, n2.respectType = false !== t2.respectType, n2.respectFunctionNames = false !== t2.respectFunctionNames, n2.respectFunctionProperties = false !== t2.respectFunctionProperties, n2.unorderedArrays = true === t2.unorderedArrays, n2.unorderedSets = false !== t2.unorderedSets, n2.unorderedObjects = false !== t2.unorderedObjects, n2.replacer = t2.replacer || void 0, n2.excludeKeys = t2.excludeKeys || void 0, void 0 === e2)
            throw new Error("Object argument required.");
          for (var r2 = 0; r2 < l.length; ++r2)
            l[r2].toLowerCase() === n2.algorithm.toLowerCase() && (n2.algorithm = l[r2]);
          if (-1 === l.indexOf(n2.algorithm))
            throw new Error('Algorithm "' + n2.algorithm + '"  not supported. supported values: ' + l.join(", "));
          if (-1 === d4.indexOf(n2.encoding) && "passthrough" !== n2.algorithm)
            throw new Error('Encoding "' + n2.encoding + '"  not supported. supported values: ' + d4.join(", "));
          return n2;
        }
        function p(e2) {
          if ("function" == typeof e2) {
            return null != /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(e2));
          }
        }
        function g2(u2, t2, a4) {
          a4 = a4 || [];
          function s3(e2) {
            return t2.update ? t2.update(e2, "utf8") : t2.write(e2, "utf8");
          }
          return { dispatch: function(e2) {
            return u2.replacer && (e2 = u2.replacer(e2)), this["_" + (null === e2 ? "null" : typeof e2)](e2);
          }, _object: function(t3) {
            var e2 = Object.prototype.toString.call(t3), n2 = /\[object (.*)\]/i.exec(e2);
            n2 = (n2 = n2 ? n2[1] : "unknown:[" + e2 + "]").toLowerCase();
            var r2;
            if (0 <= (r2 = a4.indexOf(t3)))
              return this.dispatch("[CIRCULAR:" + r2 + "]");
            if (a4.push(t3), void 0 !== f && f.isBuffer && f.isBuffer(t3))
              return s3("buffer:"), s3(t3);
            if ("object" === n2 || "function" === n2 || "asyncfunction" === n2) {
              var o2 = Object.keys(t3);
              u2.unorderedObjects && (o2 = o2.sort()), false === u2.respectType || p(t3) || o2.splice(0, 0, "prototype", "__proto__", "constructor"), u2.excludeKeys && (o2 = o2.filter(function(e3) {
                return !u2.excludeKeys(e3);
              })), s3("object:" + o2.length + ":");
              var i3 = this;
              return o2.forEach(function(e3) {
                i3.dispatch(e3), s3(":"), u2.excludeValues || i3.dispatch(t3[e3]), s3(",");
              });
            }
            if (!this["_" + n2]) {
              if (u2.ignoreUnknown)
                return s3("[" + n2 + "]");
              throw new Error('Unknown object type "' + n2 + '"');
            }
            this["_" + n2](t3);
          }, _array: function(e2, t3) {
            t3 = void 0 !== t3 ? t3 : false !== u2.unorderedArrays;
            var n2 = this;
            if (s3("array:" + e2.length + ":"), !t3 || e2.length <= 1)
              return e2.forEach(function(e3) {
                return n2.dispatch(e3);
              });
            var r2 = [], o2 = e2.map(function(e3) {
              var t4 = new y(), n3 = a4.slice();
              return g2(u2, t4, n3).dispatch(e3), r2 = r2.concat(n3.slice(a4.length)), t4.read().toString();
            });
            return a4 = a4.concat(r2), o2.sort(), this._array(o2, false);
          }, _date: function(e2) {
            return s3("date:" + e2.toJSON());
          }, _symbol: function(e2) {
            return s3("symbol:" + e2.toString());
          }, _error: function(e2) {
            return s3("error:" + e2.toString());
          }, _boolean: function(e2) {
            return s3("bool:" + e2.toString());
          }, _string: function(e2) {
            s3("string:" + e2.length + ":"), s3(e2.toString());
          }, _function: function(e2) {
            s3("fn:"), p(e2) ? this.dispatch("[native]") : this.dispatch(e2.toString()), false !== u2.respectFunctionNames && this.dispatch("function-name:" + String(e2.name)), u2.respectFunctionProperties && this._object(e2);
          }, _number: function(e2) {
            return s3("number:" + e2.toString());
          }, _xml: function(e2) {
            return s3("xml:" + e2.toString());
          }, _null: function() {
            return s3("Null");
          }, _undefined: function() {
            return s3("Undefined");
          }, _regexp: function(e2) {
            return s3("regex:" + e2.toString());
          }, _uint8array: function(e2) {
            return s3("uint8array:"), this.dispatch(Array.prototype.slice.call(e2));
          }, _uint8clampedarray: function(e2) {
            return s3("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(e2));
          }, _int8array: function(e2) {
            return s3("uint8array:"), this.dispatch(Array.prototype.slice.call(e2));
          }, _uint16array: function(e2) {
            return s3("uint16array:"), this.dispatch(Array.prototype.slice.call(e2));
          }, _int16array: function(e2) {
            return s3("uint16array:"), this.dispatch(Array.prototype.slice.call(e2));
          }, _uint32array: function(e2) {
            return s3("uint32array:"), this.dispatch(Array.prototype.slice.call(e2));
          }, _int32array: function(e2) {
            return s3("uint32array:"), this.dispatch(Array.prototype.slice.call(e2));
          }, _float32array: function(e2) {
            return s3("float32array:"), this.dispatch(Array.prototype.slice.call(e2));
          }, _float64array: function(e2) {
            return s3("float64array:"), this.dispatch(Array.prototype.slice.call(e2));
          }, _arraybuffer: function(e2) {
            return s3("arraybuffer:"), this.dispatch(new Uint8Array(e2));
          }, _url: function(e2) {
            return s3("url:" + e2.toString());
          }, _map: function(e2) {
            s3("map:");
            var t3 = Array.from(e2);
            return this._array(t3, false !== u2.unorderedSets);
          }, _set: function(e2) {
            s3("set:");
            var t3 = Array.from(e2);
            return this._array(t3, false !== u2.unorderedSets);
          }, _file: function(e2) {
            return s3("file:"), this.dispatch([e2.name, e2.size, e2.type, e2.lastModfied]);
          }, _blob: function() {
            if (u2.ignoreUnknown)
              return s3("[blob]");
            throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n');
          }, _domwindow: function() {
            return s3("domwindow");
          }, _bigint: function(e2) {
            return s3("bigint:" + e2.toString());
          }, _process: function() {
            return s3("process");
          }, _timer: function() {
            return s3("timer");
          }, _pipe: function() {
            return s3("pipe");
          }, _tcp: function() {
            return s3("tcp");
          }, _udp: function() {
            return s3("udp");
          }, _tty: function() {
            return s3("tty");
          }, _statwatcher: function() {
            return s3("statwatcher");
          }, _securecontext: function() {
            return s3("securecontext");
          }, _connection: function() {
            return s3("connection");
          }, _zlib: function() {
            return s3("zlib");
          }, _context: function() {
            return s3("context");
          }, _nodescript: function() {
            return s3("nodescript");
          }, _httpparser: function() {
            return s3("httpparser");
          }, _dataview: function() {
            return s3("dataview");
          }, _signal: function() {
            return s3("signal");
          }, _fsevent: function() {
            return s3("fsevent");
          }, _tlswrap: function() {
            return s3("tlswrap");
          } };
        }
        function y() {
          return { buf: "", write: function(e2) {
            this.buf += e2;
          }, end: function(e2) {
            this.buf += e2;
          }, read: function() {
            return this.buf;
          } };
        }
        m2.writeToStream = function(e2, t2, n2) {
          return void 0 === n2 && (n2 = t2, t2 = {}), g2(t2 = h2(e2, t2), n2).dispatch(e2);
        };
      }).call(this, w2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_7eac155c.js", "/");
    }, { buffer: 3, crypto: 5, lYpoI2: 10 }], 2: [function(e, t, f) {
      (function(e2, t2, n, r, o, i2, u, a3, s2) {
        !function(e3) {
          var f2 = "undefined" != typeof Uint8Array ? Uint8Array : Array, n2 = "+".charCodeAt(0), r2 = "/".charCodeAt(0), o2 = "0".charCodeAt(0), i3 = "a".charCodeAt(0), u2 = "A".charCodeAt(0), a4 = "-".charCodeAt(0), s3 = "_".charCodeAt(0);
          function c(e4) {
            var t3 = e4.charCodeAt(0);
            return t3 === n2 || t3 === a4 ? 62 : t3 === r2 || t3 === s3 ? 63 : t3 < o2 ? -1 : t3 < o2 + 10 ? t3 - o2 + 26 + 26 : t3 < u2 + 26 ? t3 - u2 : t3 < i3 + 26 ? t3 - i3 + 26 : void 0;
          }
          e3.toByteArray = function(e4) {
            var t3, n3;
            if (0 < e4.length % 4)
              throw new Error("Invalid string. Length must be a multiple of 4");
            var r3 = e4.length, o3 = "=" === e4.charAt(r3 - 2) ? 2 : "=" === e4.charAt(r3 - 1) ? 1 : 0, i4 = new f2(3 * e4.length / 4 - o3), u3 = 0 < o3 ? e4.length - 4 : e4.length, a5 = 0;
            function s4(e5) {
              i4[a5++] = e5;
            }
            for (t3 = 0; t3 < u3; t3 += 4, 0)
              s4((16711680 & (n3 = c(e4.charAt(t3)) << 18 | c(e4.charAt(t3 + 1)) << 12 | c(e4.charAt(t3 + 2)) << 6 | c(e4.charAt(t3 + 3)))) >> 16), s4((65280 & n3) >> 8), s4(255 & n3);
            return 2 == o3 ? s4(255 & (n3 = c(e4.charAt(t3)) << 2 | c(e4.charAt(t3 + 1)) >> 4)) : 1 == o3 && (s4((n3 = c(e4.charAt(t3)) << 10 | c(e4.charAt(t3 + 1)) << 4 | c(e4.charAt(t3 + 2)) >> 2) >> 8 & 255), s4(255 & n3)), i4;
          }, e3.fromByteArray = function(e4) {
            var t3, n3, r3, o3, i4 = e4.length % 3, u3 = "";
            function a5(e5) {
              return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e5);
            }
            for (t3 = 0, r3 = e4.length - i4; t3 < r3; t3 += 3)
              n3 = (e4[t3] << 16) + (e4[t3 + 1] << 8) + e4[t3 + 2], u3 += a5((o3 = n3) >> 18 & 63) + a5(o3 >> 12 & 63) + a5(o3 >> 6 & 63) + a5(63 & o3);
            switch (i4) {
              case 1:
                u3 += a5((n3 = e4[e4.length - 1]) >> 2), u3 += a5(n3 << 4 & 63), u3 += "==";
                break;
              case 2:
                u3 += a5((n3 = (e4[e4.length - 2] << 8) + e4[e4.length - 1]) >> 10), u3 += a5(n3 >> 4 & 63), u3 += a5(n3 << 2 & 63), u3 += "=";
            }
            return u3;
          };
        }(void 0 === f ? this.base64js = {} : f);
      }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
    }, { buffer: 3, lYpoI2: 10 }], 3: [function(O2, e, H3) {
      (function(e2, t, g2, n, r, o, i2, u, a3) {
        var s2 = O2("base64-js"), f = O2("ieee754");
        function g2(e3, t2, n2) {
          if (!(this instanceof g2))
            return new g2(e3, t2, n2);
          var r2, o2, i3, u2, a4, s3 = typeof e3;
          if ("base64" === t2 && "string" == s3)
            for (e3 = (r2 = e3).trim ? r2.trim() : r2.replace(/^\s+|\s+$/g, ""); e3.length % 4 != 0; )
              e3 += "=";
          if ("number" == s3)
            o2 = x2(e3);
          else if ("string" == s3)
            o2 = g2.byteLength(e3, t2);
          else {
            if ("object" != s3)
              throw new Error("First argument needs to be a number, array or string.");
            o2 = x2(e3.length);
          }
          if (g2._useTypedArrays ? i3 = g2._augment(new Uint8Array(o2)) : ((i3 = this).length = o2, i3._isBuffer = true), g2._useTypedArrays && "number" == typeof e3.byteLength)
            i3._set(e3);
          else if (S2(a4 = e3) || g2.isBuffer(a4) || a4 && "object" == typeof a4 && "number" == typeof a4.length)
            for (u2 = 0; u2 < o2; u2++)
              g2.isBuffer(e3) ? i3[u2] = e3.readUInt8(u2) : i3[u2] = e3[u2];
          else if ("string" == s3)
            i3.write(e3, 0, t2);
          else if ("number" == s3 && !g2._useTypedArrays && !n2)
            for (u2 = 0; u2 < o2; u2++)
              i3[u2] = 0;
          return i3;
        }
        function y(e3, t2, n2, r2) {
          return g2._charsWritten = T2(function(e4) {
            for (var t3 = [], n3 = 0; n3 < e4.length; n3++)
              t3.push(255 & e4.charCodeAt(n3));
            return t3;
          }(t2), e3, n2, r2);
        }
        function w2(e3, t2, n2, r2) {
          return g2._charsWritten = T2(function(e4) {
            for (var t3, n3, r3, o2 = [], i3 = 0; i3 < e4.length; i3++)
              t3 = e4.charCodeAt(i3), n3 = t3 >> 8, r3 = t3 % 256, o2.push(r3), o2.push(n3);
            return o2;
          }(t2), e3, n2, r2);
        }
        function c(e3, t2, n2) {
          var r2 = "";
          n2 = Math.min(e3.length, n2);
          for (var o2 = t2; o2 < n2; o2++)
            r2 += String.fromCharCode(e3[o2]);
          return r2;
        }
        function l(e3, t2, n2, r2) {
          r2 || (D2("boolean" == typeof n2, "missing or invalid endian"), D2(null != t2, "missing offset"), D2(t2 + 1 < e3.length, "Trying to read beyond buffer length"));
          var o2, i3 = e3.length;
          if (!(i3 <= t2))
            return n2 ? (o2 = e3[t2], t2 + 1 < i3 && (o2 |= e3[t2 + 1] << 8)) : (o2 = e3[t2] << 8, t2 + 1 < i3 && (o2 |= e3[t2 + 1])), o2;
        }
        function d4(e3, t2, n2, r2) {
          r2 || (D2("boolean" == typeof n2, "missing or invalid endian"), D2(null != t2, "missing offset"), D2(t2 + 3 < e3.length, "Trying to read beyond buffer length"));
          var o2, i3 = e3.length;
          if (!(i3 <= t2))
            return n2 ? (t2 + 2 < i3 && (o2 = e3[t2 + 2] << 16), t2 + 1 < i3 && (o2 |= e3[t2 + 1] << 8), o2 |= e3[t2], t2 + 3 < i3 && (o2 += e3[t2 + 3] << 24 >>> 0)) : (t2 + 1 < i3 && (o2 = e3[t2 + 1] << 16), t2 + 2 < i3 && (o2 |= e3[t2 + 2] << 8), t2 + 3 < i3 && (o2 |= e3[t2 + 3]), o2 += e3[t2] << 24 >>> 0), o2;
        }
        function h2(e3, t2, n2, r2) {
          if (r2 || (D2("boolean" == typeof n2, "missing or invalid endian"), D2(null != t2, "missing offset"), D2(t2 + 1 < e3.length, "Trying to read beyond buffer length")), !(e3.length <= t2)) {
            var o2 = l(e3, t2, n2, true);
            return 32768 & o2 ? -1 * (65535 - o2 + 1) : o2;
          }
        }
        function p(e3, t2, n2, r2) {
          if (r2 || (D2("boolean" == typeof n2, "missing or invalid endian"), D2(null != t2, "missing offset"), D2(t2 + 3 < e3.length, "Trying to read beyond buffer length")), !(e3.length <= t2)) {
            var o2 = d4(e3, t2, n2, true);
            return 2147483648 & o2 ? -1 * (4294967295 - o2 + 1) : o2;
          }
        }
        function b2(e3, t2, n2, r2) {
          return r2 || (D2("boolean" == typeof n2, "missing or invalid endian"), D2(t2 + 3 < e3.length, "Trying to read beyond buffer length")), f.read(e3, t2, n2, 23, 4);
        }
        function m2(e3, t2, n2, r2) {
          return r2 || (D2("boolean" == typeof n2, "missing or invalid endian"), D2(t2 + 7 < e3.length, "Trying to read beyond buffer length")), f.read(e3, t2, n2, 52, 8);
        }
        function v(e3, t2, n2, r2, o2) {
          o2 || (D2(null != t2, "missing value"), D2("boolean" == typeof r2, "missing or invalid endian"), D2(null != n2, "missing offset"), D2(n2 + 1 < e3.length, "trying to write beyond buffer length"), N(t2, 65535));
          var i3 = e3.length;
          if (!(i3 <= n2))
            for (var u2 = 0, a4 = Math.min(i3 - n2, 2); u2 < a4; u2++)
              e3[n2 + u2] = (t2 & 255 << 8 * (r2 ? u2 : 1 - u2)) >>> 8 * (r2 ? u2 : 1 - u2);
        }
        function _(e3, t2, n2, r2, o2) {
          o2 || (D2(null != t2, "missing value"), D2("boolean" == typeof r2, "missing or invalid endian"), D2(null != n2, "missing offset"), D2(n2 + 3 < e3.length, "trying to write beyond buffer length"), N(t2, 4294967295));
          var i3 = e3.length;
          if (!(i3 <= n2))
            for (var u2 = 0, a4 = Math.min(i3 - n2, 4); u2 < a4; u2++)
              e3[n2 + u2] = t2 >>> 8 * (r2 ? u2 : 3 - u2) & 255;
        }
        function E(e3, t2, n2, r2, o2) {
          o2 || (D2(null != t2, "missing value"), D2("boolean" == typeof r2, "missing or invalid endian"), D2(null != n2, "missing offset"), D2(n2 + 1 < e3.length, "Trying to write beyond buffer length"), Y3(t2, 32767, -32768)), e3.length <= n2 || v(e3, 0 <= t2 ? t2 : 65535 + t2 + 1, n2, r2, o2);
        }
        function I2(e3, t2, n2, r2, o2) {
          o2 || (D2(null != t2, "missing value"), D2("boolean" == typeof r2, "missing or invalid endian"), D2(null != n2, "missing offset"), D2(n2 + 3 < e3.length, "Trying to write beyond buffer length"), Y3(t2, 2147483647, -2147483648)), e3.length <= n2 || _(e3, 0 <= t2 ? t2 : 4294967295 + t2 + 1, n2, r2, o2);
        }
        function A2(e3, t2, n2, r2, o2) {
          o2 || (D2(null != t2, "missing value"), D2("boolean" == typeof r2, "missing or invalid endian"), D2(null != n2, "missing offset"), D2(n2 + 3 < e3.length, "Trying to write beyond buffer length"), F(t2, 34028234663852886e22, -34028234663852886e22)), e3.length <= n2 || f.write(e3, t2, n2, r2, 23, 4);
        }
        function B(e3, t2, n2, r2, o2) {
          o2 || (D2(null != t2, "missing value"), D2("boolean" == typeof r2, "missing or invalid endian"), D2(null != n2, "missing offset"), D2(n2 + 7 < e3.length, "Trying to write beyond buffer length"), F(t2, 17976931348623157e292, -17976931348623157e292)), e3.length <= n2 || f.write(e3, t2, n2, r2, 52, 8);
        }
        H3.Buffer = g2, H3.SlowBuffer = g2, H3.INSPECT_MAX_BYTES = 50, g2.poolSize = 8192, g2._useTypedArrays = function() {
          try {
            var e3 = new ArrayBuffer(0), t2 = new Uint8Array(e3);
            return t2.foo = function() {
              return 42;
            }, 42 === t2.foo() && "function" == typeof t2.subarray;
          } catch (e4) {
            return false;
          }
        }(), g2.isEncoding = function(e3) {
          switch (String(e3).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "raw":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false;
          }
        }, g2.isBuffer = function(e3) {
          return !(null == e3 || !e3._isBuffer);
        }, g2.byteLength = function(e3, t2) {
          var n2;
          switch (e3 += "", t2 || "utf8") {
            case "hex":
              n2 = e3.length / 2;
              break;
            case "utf8":
            case "utf-8":
              n2 = C2(e3).length;
              break;
            case "ascii":
            case "binary":
            case "raw":
              n2 = e3.length;
              break;
            case "base64":
              n2 = k2(e3).length;
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              n2 = 2 * e3.length;
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return n2;
        }, g2.concat = function(e3, t2) {
          if (D2(S2(e3), "Usage: Buffer.concat(list, [totalLength])\nlist should be an Array."), 0 === e3.length)
            return new g2(0);
          if (1 === e3.length)
            return e3[0];
          if ("number" != typeof t2)
            for (o2 = t2 = 0; o2 < e3.length; o2++)
              t2 += e3[o2].length;
          for (var n2 = new g2(t2), r2 = 0, o2 = 0; o2 < e3.length; o2++) {
            var i3 = e3[o2];
            i3.copy(n2, r2), r2 += i3.length;
          }
          return n2;
        }, g2.prototype.write = function(e3, t2, n2, r2) {
          var o2;
          isFinite(t2) ? isFinite(n2) || (r2 = n2, n2 = void 0) : (o2 = r2, r2 = t2, t2 = n2, n2 = o2), t2 = Number(t2) || 0;
          var i3, u2, a4, s3, f2, c2, l2, d5, h3, p2 = this.length - t2;
          switch ((!n2 || p2 < (n2 = Number(n2))) && (n2 = p2), r2 = String(r2 || "utf8").toLowerCase()) {
            case "hex":
              i3 = function(e4, t3, n3, r3) {
                n3 = Number(n3) || 0;
                var o3 = e4.length - n3;
                (!r3 || o3 < (r3 = Number(r3))) && (r3 = o3);
                var i4 = t3.length;
                D2(i4 % 2 == 0, "Invalid hex string"), i4 / 2 < r3 && (r3 = i4 / 2);
                for (var u3 = 0; u3 < r3; u3++) {
                  var a5 = parseInt(t3.substr(2 * u3, 2), 16);
                  D2(!isNaN(a5), "Invalid hex string"), e4[n3 + u3] = a5;
                }
                return g2._charsWritten = 2 * u3, u3;
              }(this, e3, t2, n2);
              break;
            case "utf8":
            case "utf-8":
              c2 = this, l2 = e3, d5 = t2, h3 = n2, i3 = g2._charsWritten = T2(C2(l2), c2, d5, h3);
              break;
            case "ascii":
            case "binary":
              i3 = y(this, e3, t2, n2);
              break;
            case "base64":
              u2 = this, a4 = e3, s3 = t2, f2 = n2, i3 = g2._charsWritten = T2(k2(a4), u2, s3, f2);
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              i3 = w2(this, e3, t2, n2);
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return i3;
        }, g2.prototype.toString = function(e3, t2, n2) {
          var r2, o2, i3, u2, a4 = this;
          if (e3 = String(e3 || "utf8").toLowerCase(), t2 = Number(t2) || 0, (n2 = void 0 !== n2 ? Number(n2) : n2 = a4.length) === t2)
            return "";
          switch (e3) {
            case "hex":
              r2 = function(e4, t3, n3) {
                var r3 = e4.length;
                (!t3 || t3 < 0) && (t3 = 0);
                (!n3 || n3 < 0 || r3 < n3) && (n3 = r3);
                for (var o3 = "", i4 = t3; i4 < n3; i4++)
                  o3 += j(e4[i4]);
                return o3;
              }(a4, t2, n2);
              break;
            case "utf8":
            case "utf-8":
              r2 = function(e4, t3, n3) {
                var r3 = "", o3 = "";
                n3 = Math.min(e4.length, n3);
                for (var i4 = t3; i4 < n3; i4++)
                  e4[i4] <= 127 ? (r3 += M2(o3) + String.fromCharCode(e4[i4]), o3 = "") : o3 += "%" + e4[i4].toString(16);
                return r3 + M2(o3);
              }(a4, t2, n2);
              break;
            case "ascii":
            case "binary":
              r2 = c(a4, t2, n2);
              break;
            case "base64":
              o2 = a4, u2 = n2, r2 = 0 === (i3 = t2) && u2 === o2.length ? s2.fromByteArray(o2) : s2.fromByteArray(o2.slice(i3, u2));
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              r2 = function(e4, t3, n3) {
                for (var r3 = e4.slice(t3, n3), o3 = "", i4 = 0; i4 < r3.length; i4 += 2)
                  o3 += String.fromCharCode(r3[i4] + 256 * r3[i4 + 1]);
                return o3;
              }(a4, t2, n2);
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return r2;
        }, g2.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        }, g2.prototype.copy = function(e3, t2, n2, r2) {
          if (n2 = n2 || 0, r2 || 0 === r2 || (r2 = this.length), t2 = t2 || 0, r2 !== n2 && 0 !== e3.length && 0 !== this.length) {
            D2(n2 <= r2, "sourceEnd < sourceStart"), D2(0 <= t2 && t2 < e3.length, "targetStart out of bounds"), D2(0 <= n2 && n2 < this.length, "sourceStart out of bounds"), D2(0 <= r2 && r2 <= this.length, "sourceEnd out of bounds"), r2 > this.length && (r2 = this.length), e3.length - t2 < r2 - n2 && (r2 = e3.length - t2 + n2);
            var o2 = r2 - n2;
            if (o2 < 100 || !g2._useTypedArrays)
              for (var i3 = 0; i3 < o2; i3++)
                e3[i3 + t2] = this[i3 + n2];
            else
              e3._set(this.subarray(n2, n2 + o2), t2);
          }
        }, g2.prototype.slice = function(e3, t2) {
          var n2 = this.length;
          if (e3 = U(e3, n2, 0), t2 = U(t2, n2, n2), g2._useTypedArrays)
            return g2._augment(this.subarray(e3, t2));
          for (var r2 = t2 - e3, o2 = new g2(r2, void 0, true), i3 = 0; i3 < r2; i3++)
            o2[i3] = this[i3 + e3];
          return o2;
        }, g2.prototype.get = function(e3) {
          return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(e3);
        }, g2.prototype.set = function(e3, t2) {
          return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(e3, t2);
        }, g2.prototype.readUInt8 = function(e3, t2) {
          if (t2 || (D2(null != e3, "missing offset"), D2(e3 < this.length, "Trying to read beyond buffer length")), !(e3 >= this.length))
            return this[e3];
        }, g2.prototype.readUInt16LE = function(e3, t2) {
          return l(this, e3, true, t2);
        }, g2.prototype.readUInt16BE = function(e3, t2) {
          return l(this, e3, false, t2);
        }, g2.prototype.readUInt32LE = function(e3, t2) {
          return d4(this, e3, true, t2);
        }, g2.prototype.readUInt32BE = function(e3, t2) {
          return d4(this, e3, false, t2);
        }, g2.prototype.readInt8 = function(e3, t2) {
          if (t2 || (D2(null != e3, "missing offset"), D2(e3 < this.length, "Trying to read beyond buffer length")), !(e3 >= this.length))
            return 128 & this[e3] ? -1 * (255 - this[e3] + 1) : this[e3];
        }, g2.prototype.readInt16LE = function(e3, t2) {
          return h2(this, e3, true, t2);
        }, g2.prototype.readInt16BE = function(e3, t2) {
          return h2(this, e3, false, t2);
        }, g2.prototype.readInt32LE = function(e3, t2) {
          return p(this, e3, true, t2);
        }, g2.prototype.readInt32BE = function(e3, t2) {
          return p(this, e3, false, t2);
        }, g2.prototype.readFloatLE = function(e3, t2) {
          return b2(this, e3, true, t2);
        }, g2.prototype.readFloatBE = function(e3, t2) {
          return b2(this, e3, false, t2);
        }, g2.prototype.readDoubleLE = function(e3, t2) {
          return m2(this, e3, true, t2);
        }, g2.prototype.readDoubleBE = function(e3, t2) {
          return m2(this, e3, false, t2);
        }, g2.prototype.writeUInt8 = function(e3, t2, n2) {
          n2 || (D2(null != e3, "missing value"), D2(null != t2, "missing offset"), D2(t2 < this.length, "trying to write beyond buffer length"), N(e3, 255)), t2 >= this.length || (this[t2] = e3);
        }, g2.prototype.writeUInt16LE = function(e3, t2, n2) {
          v(this, e3, t2, true, n2);
        }, g2.prototype.writeUInt16BE = function(e3, t2, n2) {
          v(this, e3, t2, false, n2);
        }, g2.prototype.writeUInt32LE = function(e3, t2, n2) {
          _(this, e3, t2, true, n2);
        }, g2.prototype.writeUInt32BE = function(e3, t2, n2) {
          _(this, e3, t2, false, n2);
        }, g2.prototype.writeInt8 = function(e3, t2, n2) {
          n2 || (D2(null != e3, "missing value"), D2(null != t2, "missing offset"), D2(t2 < this.length, "Trying to write beyond buffer length"), Y3(e3, 127, -128)), t2 >= this.length || (0 <= e3 ? this.writeUInt8(e3, t2, n2) : this.writeUInt8(255 + e3 + 1, t2, n2));
        }, g2.prototype.writeInt16LE = function(e3, t2, n2) {
          E(this, e3, t2, true, n2);
        }, g2.prototype.writeInt16BE = function(e3, t2, n2) {
          E(this, e3, t2, false, n2);
        }, g2.prototype.writeInt32LE = function(e3, t2, n2) {
          I2(this, e3, t2, true, n2);
        }, g2.prototype.writeInt32BE = function(e3, t2, n2) {
          I2(this, e3, t2, false, n2);
        }, g2.prototype.writeFloatLE = function(e3, t2, n2) {
          A2(this, e3, t2, true, n2);
        }, g2.prototype.writeFloatBE = function(e3, t2, n2) {
          A2(this, e3, t2, false, n2);
        }, g2.prototype.writeDoubleLE = function(e3, t2, n2) {
          B(this, e3, t2, true, n2);
        }, g2.prototype.writeDoubleBE = function(e3, t2, n2) {
          B(this, e3, t2, false, n2);
        }, g2.prototype.fill = function(e3, t2, n2) {
          if (e3 = e3 || 0, t2 = t2 || 0, n2 = n2 || this.length, "string" == typeof e3 && (e3 = e3.charCodeAt(0)), D2("number" == typeof e3 && !isNaN(e3), "value is not a number"), D2(t2 <= n2, "end < start"), n2 !== t2 && 0 !== this.length) {
            D2(0 <= t2 && t2 < this.length, "start out of bounds"), D2(0 <= n2 && n2 <= this.length, "end out of bounds");
            for (var r2 = t2; r2 < n2; r2++)
              this[r2] = e3;
          }
        }, g2.prototype.inspect = function() {
          for (var e3 = [], t2 = this.length, n2 = 0; n2 < t2; n2++)
            if (e3[n2] = j(this[n2]), n2 === H3.INSPECT_MAX_BYTES) {
              e3[n2 + 1] = "...";
              break;
            }
          return "<Buffer " + e3.join(" ") + ">";
        }, g2.prototype.toArrayBuffer = function() {
          if ("undefined" == typeof Uint8Array)
            throw new Error("Buffer.toArrayBuffer not supported in this browser");
          if (g2._useTypedArrays)
            return new g2(this).buffer;
          for (var e3 = new Uint8Array(this.length), t2 = 0, n2 = e3.length; t2 < n2; t2 += 1)
            e3[t2] = this[t2];
          return e3.buffer;
        };
        var L = g2.prototype;
        function U(e3, t2, n2) {
          return "number" != typeof e3 ? n2 : t2 <= (e3 = ~~e3) ? t2 : 0 <= e3 || 0 <= (e3 += t2) ? e3 : 0;
        }
        function x2(e3) {
          return (e3 = ~~Math.ceil(+e3)) < 0 ? 0 : e3;
        }
        function S2(e3) {
          return (Array.isArray || function(e4) {
            return "[object Array]" === Object.prototype.toString.call(e4);
          })(e3);
        }
        function j(e3) {
          return e3 < 16 ? "0" + e3.toString(16) : e3.toString(16);
        }
        function C2(e3) {
          for (var t2 = [], n2 = 0; n2 < e3.length; n2++) {
            var r2 = e3.charCodeAt(n2);
            if (r2 <= 127)
              t2.push(e3.charCodeAt(n2));
            else {
              var o2 = n2;
              55296 <= r2 && r2 <= 57343 && n2++;
              for (var i3 = encodeURIComponent(e3.slice(o2, n2 + 1)).substr(1).split("%"), u2 = 0; u2 < i3.length; u2++)
                t2.push(parseInt(i3[u2], 16));
            }
          }
          return t2;
        }
        function k2(e3) {
          return s2.toByteArray(e3);
        }
        function T2(e3, t2, n2, r2) {
          for (var o2 = 0; o2 < r2 && !(o2 + n2 >= t2.length || o2 >= e3.length); o2++)
            t2[o2 + n2] = e3[o2];
          return o2;
        }
        function M2(e3) {
          try {
            return decodeURIComponent(e3);
          } catch (e4) {
            return String.fromCharCode(65533);
          }
        }
        function N(e3, t2) {
          D2("number" == typeof e3, "cannot write a non-number as a number"), D2(0 <= e3, "specified a negative value for writing an unsigned value"), D2(e3 <= t2, "value is larger than maximum value for type"), D2(Math.floor(e3) === e3, "value has a fractional component");
        }
        function Y3(e3, t2, n2) {
          D2("number" == typeof e3, "cannot write a non-number as a number"), D2(e3 <= t2, "value larger than maximum allowed value"), D2(n2 <= e3, "value smaller than minimum allowed value"), D2(Math.floor(e3) === e3, "value has a fractional component");
        }
        function F(e3, t2, n2) {
          D2("number" == typeof e3, "cannot write a non-number as a number"), D2(e3 <= t2, "value larger than maximum allowed value"), D2(n2 <= e3, "value smaller than minimum allowed value");
        }
        function D2(e3, t2) {
          if (!e3)
            throw new Error(t2 || "Failed assertion");
        }
        g2._augment = function(e3) {
          return e3._isBuffer = true, e3._get = e3.get, e3._set = e3.set, e3.get = L.get, e3.set = L.set, e3.write = L.write, e3.toString = L.toString, e3.toLocaleString = L.toString, e3.toJSON = L.toJSON, e3.copy = L.copy, e3.slice = L.slice, e3.readUInt8 = L.readUInt8, e3.readUInt16LE = L.readUInt16LE, e3.readUInt16BE = L.readUInt16BE, e3.readUInt32LE = L.readUInt32LE, e3.readUInt32BE = L.readUInt32BE, e3.readInt8 = L.readInt8, e3.readInt16LE = L.readInt16LE, e3.readInt16BE = L.readInt16BE, e3.readInt32LE = L.readInt32LE, e3.readInt32BE = L.readInt32BE, e3.readFloatLE = L.readFloatLE, e3.readFloatBE = L.readFloatBE, e3.readDoubleLE = L.readDoubleLE, e3.readDoubleBE = L.readDoubleBE, e3.writeUInt8 = L.writeUInt8, e3.writeUInt16LE = L.writeUInt16LE, e3.writeUInt16BE = L.writeUInt16BE, e3.writeUInt32LE = L.writeUInt32LE, e3.writeUInt32BE = L.writeUInt32BE, e3.writeInt8 = L.writeInt8, e3.writeInt16LE = L.writeInt16LE, e3.writeInt16BE = L.writeInt16BE, e3.writeInt32LE = L.writeInt32LE, e3.writeInt32BE = L.writeInt32BE, e3.writeFloatLE = L.writeFloatLE, e3.writeFloatBE = L.writeFloatBE, e3.writeDoubleLE = L.writeDoubleLE, e3.writeDoubleBE = L.writeDoubleBE, e3.fill = L.fill, e3.inspect = L.inspect, e3.toArrayBuffer = L.toArrayBuffer, e3;
        };
      }).call(this, O2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, O2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
    }, { "base64-js": 2, buffer: 3, ieee754: 11, lYpoI2: 10 }], 4: [function(l, d4, e) {
      (function(e2, t, u, n, r, o, i2, a3, s2) {
        var u = l("buffer").Buffer, f = 4, c = new u(f);
        c.fill(0);
        d4.exports = { hash: function(e3, t2, n2, r2) {
          return u.isBuffer(e3) || (e3 = new u(e3)), function(e4, t3, n3) {
            for (var r3 = new u(t3), o2 = n3 ? r3.writeInt32BE : r3.writeInt32LE, i3 = 0; i3 < e4.length; i3++)
              o2.call(r3, e4[i3], 4 * i3, true);
            return r3;
          }(t2(function(e4, t3) {
            var n3;
            e4.length % f != 0 && (n3 = e4.length + (f - e4.length % f), e4 = u.concat([e4, c], n3));
            for (var r3 = [], o2 = t3 ? e4.readInt32BE : e4.readInt32LE, i3 = 0; i3 < e4.length; i3 += f)
              r3.push(o2.call(e4, i3));
            return r3;
          }(e3, r2), 8 * e3.length), n2, r2);
        } };
      }).call(this, l("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, l("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { buffer: 3, lYpoI2: 10 }], 5: [function(w2, e, b2) {
      (function(e2, t, a3, n, r, o, i2, u, s2) {
        var a3 = w2("buffer").Buffer, f = w2("./sha"), c = w2("./sha256"), l = w2("./rng"), d4 = { sha1: f, sha256: c, md5: w2("./md5") }, h2 = 64, p = new a3(h2);
        function g2(e3, r2) {
          var o2 = d4[e3 = e3 || "sha1"], i3 = [];
          return o2 || y("algorithm:", e3, "is not yet supported"), { update: function(e4) {
            return a3.isBuffer(e4) || (e4 = new a3(e4)), i3.push(e4), e4.length, this;
          }, digest: function(e4) {
            var t2 = a3.concat(i3), n2 = r2 ? function(e5, t3, n3) {
              a3.isBuffer(t3) || (t3 = new a3(t3)), a3.isBuffer(n3) || (n3 = new a3(n3)), t3.length > h2 ? t3 = e5(t3) : t3.length < h2 && (t3 = a3.concat([t3, p], h2));
              for (var r3 = new a3(h2), o3 = new a3(h2), i4 = 0; i4 < h2; i4++)
                r3[i4] = 54 ^ t3[i4], o3[i4] = 92 ^ t3[i4];
              var u2 = e5(a3.concat([r3, n3]));
              return e5(a3.concat([o3, u2]));
            }(o2, r2, t2) : o2(t2);
            return i3 = null, e4 ? n2.toString(e4) : n2;
          } };
        }
        function y() {
          var e3 = [].slice.call(arguments).join(" ");
          throw new Error([e3, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join("\n"));
        }
        p.fill(0), b2.createHash = function(e3) {
          return g2(e3);
        }, b2.createHmac = g2, b2.randomBytes = function(e3, t2) {
          if (!t2 || !t2.call)
            return new a3(l(e3));
          try {
            t2.call(this, void 0, new a3(l(e3)));
          } catch (e4) {
            t2(e4);
          }
        }, function(e3, t2) {
          for (var n2 in e3)
            t2(e3[n2], n2);
        }(["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], function(e3) {
          b2[e3] = function() {
            y("sorry,", e3, "is not implemented yet");
          };
        });
      }).call(this, w2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./md5": 6, "./rng": 7, "./sha": 8, "./sha256": 9, buffer: 3, lYpoI2: 10 }], 6: [function(w2, b2, e) {
      (function(e2, t, n, r, o, i2, u, a3, s2) {
        var f = w2("./helpers");
        function c(e3, t2) {
          e3[t2 >> 5] |= 128 << t2 % 32, e3[14 + (t2 + 64 >>> 9 << 4)] = t2;
          for (var n2 = 1732584193, r2 = -271733879, o2 = -1732584194, i3 = 271733878, u2 = 0; u2 < e3.length; u2 += 16) {
            var a4 = n2, s3 = r2, f2 = o2, c2 = i3, n2 = d4(n2, r2, o2, i3, e3[u2 + 0], 7, -680876936), i3 = d4(i3, n2, r2, o2, e3[u2 + 1], 12, -389564586), o2 = d4(o2, i3, n2, r2, e3[u2 + 2], 17, 606105819), r2 = d4(r2, o2, i3, n2, e3[u2 + 3], 22, -1044525330);
            n2 = d4(n2, r2, o2, i3, e3[u2 + 4], 7, -176418897), i3 = d4(i3, n2, r2, o2, e3[u2 + 5], 12, 1200080426), o2 = d4(o2, i3, n2, r2, e3[u2 + 6], 17, -1473231341), r2 = d4(r2, o2, i3, n2, e3[u2 + 7], 22, -45705983), n2 = d4(n2, r2, o2, i3, e3[u2 + 8], 7, 1770035416), i3 = d4(i3, n2, r2, o2, e3[u2 + 9], 12, -1958414417), o2 = d4(o2, i3, n2, r2, e3[u2 + 10], 17, -42063), r2 = d4(r2, o2, i3, n2, e3[u2 + 11], 22, -1990404162), n2 = d4(n2, r2, o2, i3, e3[u2 + 12], 7, 1804603682), i3 = d4(i3, n2, r2, o2, e3[u2 + 13], 12, -40341101), o2 = d4(o2, i3, n2, r2, e3[u2 + 14], 17, -1502002290), n2 = h2(n2, r2 = d4(r2, o2, i3, n2, e3[u2 + 15], 22, 1236535329), o2, i3, e3[u2 + 1], 5, -165796510), i3 = h2(i3, n2, r2, o2, e3[u2 + 6], 9, -1069501632), o2 = h2(o2, i3, n2, r2, e3[u2 + 11], 14, 643717713), r2 = h2(r2, o2, i3, n2, e3[u2 + 0], 20, -373897302), n2 = h2(n2, r2, o2, i3, e3[u2 + 5], 5, -701558691), i3 = h2(i3, n2, r2, o2, e3[u2 + 10], 9, 38016083), o2 = h2(o2, i3, n2, r2, e3[u2 + 15], 14, -660478335), r2 = h2(r2, o2, i3, n2, e3[u2 + 4], 20, -405537848), n2 = h2(n2, r2, o2, i3, e3[u2 + 9], 5, 568446438), i3 = h2(i3, n2, r2, o2, e3[u2 + 14], 9, -1019803690), o2 = h2(o2, i3, n2, r2, e3[u2 + 3], 14, -187363961), r2 = h2(r2, o2, i3, n2, e3[u2 + 8], 20, 1163531501), n2 = h2(n2, r2, o2, i3, e3[u2 + 13], 5, -1444681467), i3 = h2(i3, n2, r2, o2, e3[u2 + 2], 9, -51403784), o2 = h2(o2, i3, n2, r2, e3[u2 + 7], 14, 1735328473), n2 = p(n2, r2 = h2(r2, o2, i3, n2, e3[u2 + 12], 20, -1926607734), o2, i3, e3[u2 + 5], 4, -378558), i3 = p(i3, n2, r2, o2, e3[u2 + 8], 11, -2022574463), o2 = p(o2, i3, n2, r2, e3[u2 + 11], 16, 1839030562), r2 = p(r2, o2, i3, n2, e3[u2 + 14], 23, -35309556), n2 = p(n2, r2, o2, i3, e3[u2 + 1], 4, -1530992060), i3 = p(i3, n2, r2, o2, e3[u2 + 4], 11, 1272893353), o2 = p(o2, i3, n2, r2, e3[u2 + 7], 16, -155497632), r2 = p(r2, o2, i3, n2, e3[u2 + 10], 23, -1094730640), n2 = p(n2, r2, o2, i3, e3[u2 + 13], 4, 681279174), i3 = p(i3, n2, r2, o2, e3[u2 + 0], 11, -358537222), o2 = p(o2, i3, n2, r2, e3[u2 + 3], 16, -722521979), r2 = p(r2, o2, i3, n2, e3[u2 + 6], 23, 76029189), n2 = p(n2, r2, o2, i3, e3[u2 + 9], 4, -640364487), i3 = p(i3, n2, r2, o2, e3[u2 + 12], 11, -421815835), o2 = p(o2, i3, n2, r2, e3[u2 + 15], 16, 530742520), n2 = g2(n2, r2 = p(r2, o2, i3, n2, e3[u2 + 2], 23, -995338651), o2, i3, e3[u2 + 0], 6, -198630844), i3 = g2(i3, n2, r2, o2, e3[u2 + 7], 10, 1126891415), o2 = g2(o2, i3, n2, r2, e3[u2 + 14], 15, -1416354905), r2 = g2(r2, o2, i3, n2, e3[u2 + 5], 21, -57434055), n2 = g2(n2, r2, o2, i3, e3[u2 + 12], 6, 1700485571), i3 = g2(i3, n2, r2, o2, e3[u2 + 3], 10, -1894986606), o2 = g2(o2, i3, n2, r2, e3[u2 + 10], 15, -1051523), r2 = g2(r2, o2, i3, n2, e3[u2 + 1], 21, -2054922799), n2 = g2(n2, r2, o2, i3, e3[u2 + 8], 6, 1873313359), i3 = g2(i3, n2, r2, o2, e3[u2 + 15], 10, -30611744), o2 = g2(o2, i3, n2, r2, e3[u2 + 6], 15, -1560198380), r2 = g2(r2, o2, i3, n2, e3[u2 + 13], 21, 1309151649), n2 = g2(n2, r2, o2, i3, e3[u2 + 4], 6, -145523070), i3 = g2(i3, n2, r2, o2, e3[u2 + 11], 10, -1120210379), o2 = g2(o2, i3, n2, r2, e3[u2 + 2], 15, 718787259), r2 = g2(r2, o2, i3, n2, e3[u2 + 9], 21, -343485551), n2 = y(n2, a4), r2 = y(r2, s3), o2 = y(o2, f2), i3 = y(i3, c2);
          }
          return Array(n2, r2, o2, i3);
        }
        function l(e3, t2, n2, r2, o2, i3) {
          return y((u2 = y(y(t2, e3), y(r2, i3))) << (a4 = o2) | u2 >>> 32 - a4, n2);
          var u2, a4;
        }
        function d4(e3, t2, n2, r2, o2, i3, u2) {
          return l(t2 & n2 | ~t2 & r2, e3, t2, o2, i3, u2);
        }
        function h2(e3, t2, n2, r2, o2, i3, u2) {
          return l(t2 & r2 | n2 & ~r2, e3, t2, o2, i3, u2);
        }
        function p(e3, t2, n2, r2, o2, i3, u2) {
          return l(t2 ^ n2 ^ r2, e3, t2, o2, i3, u2);
        }
        function g2(e3, t2, n2, r2, o2, i3, u2) {
          return l(n2 ^ (t2 | ~r2), e3, t2, o2, i3, u2);
        }
        function y(e3, t2) {
          var n2 = (65535 & e3) + (65535 & t2);
          return (e3 >> 16) + (t2 >> 16) + (n2 >> 16) << 16 | 65535 & n2;
        }
        b2.exports = function(e3) {
          return f.hash(e3, c, 16);
        };
      }).call(this, w2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 10 }], 7: [function(e, l, t) {
      (function(e2, t2, n, r, o, i2, u, a3, s2) {
        var c;
        c = function(e3) {
          for (var t3, n2 = new Array(e3), r2 = 0; r2 < e3; r2++)
            0 == (3 & r2) && (t3 = 4294967296 * Math.random()), n2[r2] = t3 >>> ((3 & r2) << 3) & 255;
          return n2;
        }, l.exports = c;
      }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { buffer: 3, lYpoI2: 10 }], 8: [function(l, d4, e) {
      (function(e2, t, n, r, o, i2, u, a3, s2) {
        var f = l("./helpers");
        function c(e3, t2) {
          e3[t2 >> 5] |= 128 << 24 - t2 % 32, e3[15 + (t2 + 64 >> 9 << 4)] = t2;
          for (var n2, r2, o2, i3, u2, a4 = Array(80), s3 = 1732584193, f2 = -271733879, c2 = -1732584194, l2 = 271733878, d5 = -1009589776, h2 = 0; h2 < e3.length; h2 += 16) {
            for (var p = s3, g2 = f2, y = c2, w2 = l2, b2 = d5, m2 = 0; m2 < 80; m2++) {
              a4[m2] = m2 < 16 ? e3[h2 + m2] : E(a4[m2 - 3] ^ a4[m2 - 8] ^ a4[m2 - 14] ^ a4[m2 - 16], 1);
              var v = _(_(E(s3, 5), (o2 = f2, i3 = c2, u2 = l2, (r2 = m2) < 20 ? o2 & i3 | ~o2 & u2 : !(r2 < 40) && r2 < 60 ? o2 & i3 | o2 & u2 | i3 & u2 : o2 ^ i3 ^ u2)), _(_(d5, a4[m2]), (n2 = m2) < 20 ? 1518500249 : n2 < 40 ? 1859775393 : n2 < 60 ? -1894007588 : -899497514)), d5 = l2, l2 = c2, c2 = E(f2, 30), f2 = s3, s3 = v;
            }
            s3 = _(s3, p), f2 = _(f2, g2), c2 = _(c2, y), l2 = _(l2, w2), d5 = _(d5, b2);
          }
          return Array(s3, f2, c2, l2, d5);
        }
        function _(e3, t2) {
          var n2 = (65535 & e3) + (65535 & t2);
          return (e3 >> 16) + (t2 >> 16) + (n2 >> 16) << 16 | 65535 & n2;
        }
        function E(e3, t2) {
          return e3 << t2 | e3 >>> 32 - t2;
        }
        d4.exports = function(e3) {
          return f.hash(e3, c, 20, true);
        };
      }).call(this, l("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, l("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 10 }], 9: [function(l, d4, e) {
      (function(e2, t, n, r, o, i2, u, a3, s2) {
        function B(e3, t2) {
          var n2 = (65535 & e3) + (65535 & t2);
          return (e3 >> 16) + (t2 >> 16) + (n2 >> 16) << 16 | 65535 & n2;
        }
        function L(e3, t2) {
          return e3 >>> t2 | e3 << 32 - t2;
        }
        function f(e3, t2) {
          var n2, r2, o2, i3, u2, a4, s3, f2, c2, l2, d5 = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), h2 = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), p = new Array(64);
          e3[t2 >> 5] |= 128 << 24 - t2 % 32, e3[15 + (t2 + 64 >> 9 << 4)] = t2;
          for (var g2, y, w2, b2, m2, v, _, E, I2 = 0; I2 < e3.length; I2 += 16) {
            n2 = h2[0], r2 = h2[1], o2 = h2[2], i3 = h2[3], u2 = h2[4], a4 = h2[5], s3 = h2[6], f2 = h2[7];
            for (var A2 = 0; A2 < 64; A2++)
              p[A2] = A2 < 16 ? e3[A2 + I2] : B(B(B((E = p[A2 - 2], L(E, 17) ^ L(E, 19) ^ E >>> 10), p[A2 - 7]), (_ = p[A2 - 15], L(_, 7) ^ L(_, 18) ^ _ >>> 3)), p[A2 - 16]), c2 = B(B(B(B(f2, L(v = u2, 6) ^ L(v, 11) ^ L(v, 25)), (m2 = u2) & a4 ^ ~m2 & s3), d5[A2]), p[A2]), l2 = B(L(b2 = n2, 2) ^ L(b2, 13) ^ L(b2, 22), (g2 = n2) & (y = r2) ^ g2 & (w2 = o2) ^ y & w2), f2 = s3, s3 = a4, a4 = u2, u2 = B(i3, c2), i3 = o2, o2 = r2, r2 = n2, n2 = B(c2, l2);
            h2[0] = B(n2, h2[0]), h2[1] = B(r2, h2[1]), h2[2] = B(o2, h2[2]), h2[3] = B(i3, h2[3]), h2[4] = B(u2, h2[4]), h2[5] = B(a4, h2[5]), h2[6] = B(s3, h2[6]), h2[7] = B(f2, h2[7]);
          }
          return h2;
        }
        var c = l("./helpers");
        d4.exports = function(e3) {
          return c.hash(e3, f, 32, true);
        };
      }).call(this, l("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, l("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 10 }], 10: [function(e, c, t) {
      (function(e2, t2, n, r, o, i2, u, a3, s2) {
        function f() {
        }
        (e2 = c.exports = {}).nextTick = function() {
          var e3 = "undefined" != typeof window && window.setImmediate, t3 = "undefined" != typeof window && window.postMessage && window.addEventListener;
          if (e3)
            return function(e4) {
              return window.setImmediate(e4);
            };
          if (t3) {
            var n2 = [];
            return window.addEventListener("message", function(e4) {
              var t4 = e4.source;
              t4 !== window && null !== t4 || "process-tick" !== e4.data || (e4.stopPropagation(), 0 < n2.length && n2.shift()());
            }, true), function(e4) {
              n2.push(e4), window.postMessage("process-tick", "*");
            };
          }
          return function(e4) {
            setTimeout(e4, 0);
          };
        }(), e2.title = "browser", e2.browser = true, e2.env = {}, e2.argv = [], e2.on = f, e2.addListener = f, e2.once = f, e2.off = f, e2.removeListener = f, e2.removeAllListeners = f, e2.emit = f, e2.binding = function(e3) {
          throw new Error("process.binding is not supported");
        }, e2.cwd = function() {
          return "/";
        }, e2.chdir = function(e3) {
          throw new Error("process.chdir is not supported");
        };
      }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
    }, { buffer: 3, lYpoI2: 10 }], 11: [function(e, t, f) {
      (function(e2, t2, n, r, o, i2, u, a3, s2) {
        f.read = function(e3, t3, n2, r2, o2) {
          var i3, u2, a4 = 8 * o2 - r2 - 1, s3 = (1 << a4) - 1, f2 = s3 >> 1, c = -7, l = n2 ? o2 - 1 : 0, d4 = n2 ? -1 : 1, h2 = e3[t3 + l];
          for (l += d4, i3 = h2 & (1 << -c) - 1, h2 >>= -c, c += a4; 0 < c; i3 = 256 * i3 + e3[t3 + l], l += d4, c -= 8)
            ;
          for (u2 = i3 & (1 << -c) - 1, i3 >>= -c, c += r2; 0 < c; u2 = 256 * u2 + e3[t3 + l], l += d4, c -= 8)
            ;
          if (0 === i3)
            i3 = 1 - f2;
          else {
            if (i3 === s3)
              return u2 ? NaN : 1 / 0 * (h2 ? -1 : 1);
            u2 += Math.pow(2, r2), i3 -= f2;
          }
          return (h2 ? -1 : 1) * u2 * Math.pow(2, i3 - r2);
        }, f.write = function(e3, t3, n2, r2, o2, i3) {
          var u2, a4, s3, f2 = 8 * i3 - o2 - 1, c = (1 << f2) - 1, l = c >> 1, d4 = 23 === o2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, h2 = r2 ? 0 : i3 - 1, p = r2 ? 1 : -1, g2 = t3 < 0 || 0 === t3 && 1 / t3 < 0 ? 1 : 0;
          for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (a4 = isNaN(t3) ? 1 : 0, u2 = c) : (u2 = Math.floor(Math.log(t3) / Math.LN2), t3 * (s3 = Math.pow(2, -u2)) < 1 && (u2--, s3 *= 2), 2 <= (t3 += 1 <= u2 + l ? d4 / s3 : d4 * Math.pow(2, 1 - l)) * s3 && (u2++, s3 /= 2), c <= u2 + l ? (a4 = 0, u2 = c) : 1 <= u2 + l ? (a4 = (t3 * s3 - 1) * Math.pow(2, o2), u2 += l) : (a4 = t3 * Math.pow(2, l - 1) * Math.pow(2, o2), u2 = 0)); 8 <= o2; e3[n2 + h2] = 255 & a4, h2 += p, a4 /= 256, o2 -= 8)
            ;
          for (u2 = u2 << o2 | a4, f2 += o2; 0 < f2; e3[n2 + h2] = 255 & u2, h2 += p, u2 /= 256, f2 -= 8)
            ;
          e3[n2 + h2 - p] |= 128 * g2;
        };
      }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/ieee754/index.js", "/node_modules/ieee754");
    }, { buffer: 3, lYpoI2: 10 }] }, {}, [1])(1);
  });
})(object_hash);
const __objectHash = object_hash.exports;
function __sort(object, sort) {
  const keys3 = Object.keys(object);
  const sortedKeys = keys3.sort((a3, b2) => {
    return sort({ key: a3, value: object[a3] }, { key: b2, value: object[b2] });
  });
  const resultObj = {};
  sortedKeys.forEach((k2) => {
    resultObj[k2] = object[k2];
  });
  return resultObj;
}
class SLog {
  constructor(logObj) {
    var _a3;
    if (!(logObj === null || logObj === void 0 ? void 0 : logObj.value) && !logObj._logObj) {
      throw new Error(`<red>[${this.constructor.name}]</red> Sorry but you cannot instanciate a new SLog without a "<yellow>value</yellow>" property...`);
    }
    this._logObj = __deepMerge(
      {
        type: SLog.TYPE_LOG,
        timestamp: Date.now(),
        decorators: true,
        time: false
      },
      this.constructor._defaultLogObj,
      (_a3 = logObj._logObj) !== null && _a3 !== void 0 ? _a3 : logObj
    );
  }
  static filter(types2) {
    this._filteredTypes = types2;
  }
  static clearFilters() {
    this._filteredTypes = [];
  }
  static setDefaultLogObj(logObj) {
    this._defaultLogObj = logObj;
  }
  static isTypeEnabled(types2) {
    if (!Array.isArray(types2))
      types2 = [types2];
    for (const type of types2) {
      if (!this._filteredTypes.includes(type))
        return false;
    }
    return true;
  }
  get value() {
    return this._logObj.value;
  }
  set value(value) {
    this._logObj.value = value;
  }
  get type() {
    return this._logObj.type;
  }
  get active() {
    if (!this._logObj.type)
      return true;
    if (!this.constructor._filteredTypes.includes(this._logObj.type))
      return false;
    return true;
  }
  get decorators() {
    return this._logObj.decorators;
  }
  set decorators(value) {
    this._logObj.decorators = value;
  }
  get time() {
    return this._logObj.time;
  }
  get timestamp() {
    return this._logObj.timestamp;
  }
  get clear() {
    return this._logObj.clear;
  }
  get margin() {
    var _a3;
    return (_a3 = this._logObj.margin) !== null && _a3 !== void 0 ? _a3 : {
      top: 0,
      bottom: 0
    };
  }
  get temp() {
    return this._logObj.temp;
  }
  get as() {
    return this._logObj.as;
  }
}
SLog.TYPE_LOG = "log";
SLog.TYPE_INFO = "info";
SLog.TYPE_WARN = "warn";
SLog.TYPE_ERROR = "error";
SLog.TYPE_VERBOSE = "verbose";
SLog.TYPE_VERBOSER = "verboser";
SLog.TYPE_DECORATOR = "decorator";
SLog.TYPE_SUMMARY = "summary";
SLog.TYPE_CHILD_PROCESS = "child_process";
SLog.TYPES = [
  SLog.TYPE_LOG,
  SLog.TYPE_INFO,
  SLog.TYPE_WARN,
  SLog.TYPE_ERROR,
  SLog.TYPE_VERBOSE,
  SLog.TYPE_VERBOSER,
  SLog.TYPE_SUMMARY,
  SLog.TYPE_DECORATOR,
  SLog.TYPE_CHILD_PROCESS
];
SLog.PRESET_SILENT = [];
SLog.PRESET_DEFAULT = [
  SLog.TYPE_LOG,
  SLog.TYPE_INFO,
  SLog.TYPE_WARN,
  SLog.TYPE_ERROR,
  SLog.TYPE_SUMMARY,
  SLog.TYPE_DECORATOR,
  SLog.TYPE_CHILD_PROCESS
];
SLog.PRESET_WARN = [
  SLog.TYPE_WARN,
  SLog.TYPE_ERROR,
  SLog.TYPE_CHILD_PROCESS
];
SLog.PRESET_ERROR = [
  SLog.TYPE_ERROR,
  SLog.TYPE_CHILD_PROCESS
];
SLog.PRESET_VERBOSE = [
  SLog.TYPE_LOG,
  SLog.TYPE_INFO,
  SLog.TYPE_WARN,
  SLog.TYPE_ERROR,
  SLog.TYPE_VERBOSE,
  SLog.TYPE_DECORATOR,
  SLog.TYPE_SUMMARY,
  SLog.TYPE_CHILD_PROCESS
];
SLog.PRESET_VERBOSER = [
  SLog.TYPE_LOG,
  SLog.TYPE_INFO,
  SLog.TYPE_WARN,
  SLog.TYPE_ERROR,
  SLog.TYPE_VERBOSE,
  SLog.TYPE_VERBOSER,
  SLog.TYPE_DECORATOR,
  SLog.TYPE_SUMMARY,
  SLog.TYPE_CHILD_PROCESS
];
SLog.PRESETS = [
  "silent",
  "default",
  "warn",
  "error",
  "verbose",
  "verboser"
];
SLog._filteredTypes = [];
SLog._defaultLogObj = {};
var mobileDetect = { exports: {} };
(function(module) {
  /*!mobile-detect v1.4.5 2021-03-13*/
  /*!@license Copyright 2013, Heinrich Goebl, License: MIT, see https://github.com/hgoebl/mobile-detect.js*/
  (function(define2, undefined$12) {
    define2(function() {
      var impl = {};
      impl.mobileDetectRules = {
        "phones": {
          "iPhone": "\\biPhone\\b|\\biPod\\b",
          "BlackBerry": "BlackBerry|\\bBB10\\b|rim[0-9]+|\\b(BBA100|BBB100|BBD100|BBE100|BBF100|STH100)\\b-[0-9]+",
          "Pixel": "; \\bPixel\\b",
          "HTC": "HTC|HTC.*(Sensation|Evo|Vision|Explorer|6800|8100|8900|A7272|S510e|C110e|Legend|Desire|T8282)|APX515CKT|Qtek9090|APA9292KT|HD_mini|Sensation.*Z710e|PG86100|Z715e|Desire.*(A8181|HD)|ADR6200|ADR6400L|ADR6425|001HT|Inspire 4G|Android.*\\bEVO\\b|T-Mobile G1|Z520m|Android [0-9.]+; Pixel",
          "Nexus": "Nexus One|Nexus S|Galaxy.*Nexus|Android.*Nexus.*Mobile|Nexus 4|Nexus 5|Nexus 5X|Nexus 6",
          "Dell": "Dell[;]? (Streak|Aero|Venue|Venue Pro|Flash|Smoke|Mini 3iX)|XCD28|XCD35|\\b001DL\\b|\\b101DL\\b|\\bGS01\\b",
          "Motorola": "Motorola|DROIDX|DROID BIONIC|\\bDroid\\b.*Build|Android.*Xoom|HRI39|MOT-|A1260|A1680|A555|A853|A855|A953|A955|A956|Motorola.*ELECTRIFY|Motorola.*i1|i867|i940|MB200|MB300|MB501|MB502|MB508|MB511|MB520|MB525|MB526|MB611|MB612|MB632|MB810|MB855|MB860|MB861|MB865|MB870|ME501|ME502|ME511|ME525|ME600|ME632|ME722|ME811|ME860|ME863|ME865|MT620|MT710|MT716|MT720|MT810|MT870|MT917|Motorola.*TITANIUM|WX435|WX445|XT300|XT301|XT311|XT316|XT317|XT319|XT320|XT390|XT502|XT530|XT531|XT532|XT535|XT603|XT610|XT611|XT615|XT681|XT701|XT702|XT711|XT720|XT800|XT806|XT860|XT862|XT875|XT882|XT883|XT894|XT901|XT907|XT909|XT910|XT912|XT928|XT926|XT915|XT919|XT925|XT1021|\\bMoto E\\b|XT1068|XT1092|XT1052",
          "Samsung": "\\bSamsung\\b|SM-G950F|SM-G955F|SM-G9250|GT-19300|SGH-I337|BGT-S5230|GT-B2100|GT-B2700|GT-B2710|GT-B3210|GT-B3310|GT-B3410|GT-B3730|GT-B3740|GT-B5510|GT-B5512|GT-B5722|GT-B6520|GT-B7300|GT-B7320|GT-B7330|GT-B7350|GT-B7510|GT-B7722|GT-B7800|GT-C3010|GT-C3011|GT-C3060|GT-C3200|GT-C3212|GT-C3212I|GT-C3262|GT-C3222|GT-C3300|GT-C3300K|GT-C3303|GT-C3303K|GT-C3310|GT-C3322|GT-C3330|GT-C3350|GT-C3500|GT-C3510|GT-C3530|GT-C3630|GT-C3780|GT-C5010|GT-C5212|GT-C6620|GT-C6625|GT-C6712|GT-E1050|GT-E1070|GT-E1075|GT-E1080|GT-E1081|GT-E1085|GT-E1087|GT-E1100|GT-E1107|GT-E1110|GT-E1120|GT-E1125|GT-E1130|GT-E1160|GT-E1170|GT-E1175|GT-E1180|GT-E1182|GT-E1200|GT-E1210|GT-E1225|GT-E1230|GT-E1390|GT-E2100|GT-E2120|GT-E2121|GT-E2152|GT-E2220|GT-E2222|GT-E2230|GT-E2232|GT-E2250|GT-E2370|GT-E2550|GT-E2652|GT-E3210|GT-E3213|GT-I5500|GT-I5503|GT-I5700|GT-I5800|GT-I5801|GT-I6410|GT-I6420|GT-I7110|GT-I7410|GT-I7500|GT-I8000|GT-I8150|GT-I8160|GT-I8190|GT-I8320|GT-I8330|GT-I8350|GT-I8530|GT-I8700|GT-I8703|GT-I8910|GT-I9000|GT-I9001|GT-I9003|GT-I9010|GT-I9020|GT-I9023|GT-I9070|GT-I9082|GT-I9100|GT-I9103|GT-I9220|GT-I9250|GT-I9300|GT-I9305|GT-I9500|GT-I9505|GT-M3510|GT-M5650|GT-M7500|GT-M7600|GT-M7603|GT-M8800|GT-M8910|GT-N7000|GT-S3110|GT-S3310|GT-S3350|GT-S3353|GT-S3370|GT-S3650|GT-S3653|GT-S3770|GT-S3850|GT-S5210|GT-S5220|GT-S5229|GT-S5230|GT-S5233|GT-S5250|GT-S5253|GT-S5260|GT-S5263|GT-S5270|GT-S5300|GT-S5330|GT-S5350|GT-S5360|GT-S5363|GT-S5369|GT-S5380|GT-S5380D|GT-S5560|GT-S5570|GT-S5600|GT-S5603|GT-S5610|GT-S5620|GT-S5660|GT-S5670|GT-S5690|GT-S5750|GT-S5780|GT-S5830|GT-S5839|GT-S6102|GT-S6500|GT-S7070|GT-S7200|GT-S7220|GT-S7230|GT-S7233|GT-S7250|GT-S7500|GT-S7530|GT-S7550|GT-S7562|GT-S7710|GT-S8000|GT-S8003|GT-S8500|GT-S8530|GT-S8600|SCH-A310|SCH-A530|SCH-A570|SCH-A610|SCH-A630|SCH-A650|SCH-A790|SCH-A795|SCH-A850|SCH-A870|SCH-A890|SCH-A930|SCH-A950|SCH-A970|SCH-A990|SCH-I100|SCH-I110|SCH-I400|SCH-I405|SCH-I500|SCH-I510|SCH-I515|SCH-I600|SCH-I730|SCH-I760|SCH-I770|SCH-I830|SCH-I910|SCH-I920|SCH-I959|SCH-LC11|SCH-N150|SCH-N300|SCH-R100|SCH-R300|SCH-R351|SCH-R400|SCH-R410|SCH-T300|SCH-U310|SCH-U320|SCH-U350|SCH-U360|SCH-U365|SCH-U370|SCH-U380|SCH-U410|SCH-U430|SCH-U450|SCH-U460|SCH-U470|SCH-U490|SCH-U540|SCH-U550|SCH-U620|SCH-U640|SCH-U650|SCH-U660|SCH-U700|SCH-U740|SCH-U750|SCH-U810|SCH-U820|SCH-U900|SCH-U940|SCH-U960|SCS-26UC|SGH-A107|SGH-A117|SGH-A127|SGH-A137|SGH-A157|SGH-A167|SGH-A177|SGH-A187|SGH-A197|SGH-A227|SGH-A237|SGH-A257|SGH-A437|SGH-A517|SGH-A597|SGH-A637|SGH-A657|SGH-A667|SGH-A687|SGH-A697|SGH-A707|SGH-A717|SGH-A727|SGH-A737|SGH-A747|SGH-A767|SGH-A777|SGH-A797|SGH-A817|SGH-A827|SGH-A837|SGH-A847|SGH-A867|SGH-A877|SGH-A887|SGH-A897|SGH-A927|SGH-B100|SGH-B130|SGH-B200|SGH-B220|SGH-C100|SGH-C110|SGH-C120|SGH-C130|SGH-C140|SGH-C160|SGH-C170|SGH-C180|SGH-C200|SGH-C207|SGH-C210|SGH-C225|SGH-C230|SGH-C417|SGH-C450|SGH-D307|SGH-D347|SGH-D357|SGH-D407|SGH-D415|SGH-D780|SGH-D807|SGH-D980|SGH-E105|SGH-E200|SGH-E315|SGH-E316|SGH-E317|SGH-E335|SGH-E590|SGH-E635|SGH-E715|SGH-E890|SGH-F300|SGH-F480|SGH-I200|SGH-I300|SGH-I320|SGH-I550|SGH-I577|SGH-I600|SGH-I607|SGH-I617|SGH-I627|SGH-I637|SGH-I677|SGH-I700|SGH-I717|SGH-I727|SGH-i747M|SGH-I777|SGH-I780|SGH-I827|SGH-I847|SGH-I857|SGH-I896|SGH-I897|SGH-I900|SGH-I907|SGH-I917|SGH-I927|SGH-I937|SGH-I997|SGH-J150|SGH-J200|SGH-L170|SGH-L700|SGH-M110|SGH-M150|SGH-M200|SGH-N105|SGH-N500|SGH-N600|SGH-N620|SGH-N625|SGH-N700|SGH-N710|SGH-P107|SGH-P207|SGH-P300|SGH-P310|SGH-P520|SGH-P735|SGH-P777|SGH-Q105|SGH-R210|SGH-R220|SGH-R225|SGH-S105|SGH-S307|SGH-T109|SGH-T119|SGH-T139|SGH-T209|SGH-T219|SGH-T229|SGH-T239|SGH-T249|SGH-T259|SGH-T309|SGH-T319|SGH-T329|SGH-T339|SGH-T349|SGH-T359|SGH-T369|SGH-T379|SGH-T409|SGH-T429|SGH-T439|SGH-T459|SGH-T469|SGH-T479|SGH-T499|SGH-T509|SGH-T519|SGH-T539|SGH-T559|SGH-T589|SGH-T609|SGH-T619|SGH-T629|SGH-T639|SGH-T659|SGH-T669|SGH-T679|SGH-T709|SGH-T719|SGH-T729|SGH-T739|SGH-T746|SGH-T749|SGH-T759|SGH-T769|SGH-T809|SGH-T819|SGH-T839|SGH-T919|SGH-T929|SGH-T939|SGH-T959|SGH-T989|SGH-U100|SGH-U200|SGH-U800|SGH-V205|SGH-V206|SGH-X100|SGH-X105|SGH-X120|SGH-X140|SGH-X426|SGH-X427|SGH-X475|SGH-X495|SGH-X497|SGH-X507|SGH-X600|SGH-X610|SGH-X620|SGH-X630|SGH-X700|SGH-X820|SGH-X890|SGH-Z130|SGH-Z150|SGH-Z170|SGH-ZX10|SGH-ZX20|SHW-M110|SPH-A120|SPH-A400|SPH-A420|SPH-A460|SPH-A500|SPH-A560|SPH-A600|SPH-A620|SPH-A660|SPH-A700|SPH-A740|SPH-A760|SPH-A790|SPH-A800|SPH-A820|SPH-A840|SPH-A880|SPH-A900|SPH-A940|SPH-A960|SPH-D600|SPH-D700|SPH-D710|SPH-D720|SPH-I300|SPH-I325|SPH-I330|SPH-I350|SPH-I500|SPH-I600|SPH-I700|SPH-L700|SPH-M100|SPH-M220|SPH-M240|SPH-M300|SPH-M305|SPH-M320|SPH-M330|SPH-M350|SPH-M360|SPH-M370|SPH-M380|SPH-M510|SPH-M540|SPH-M550|SPH-M560|SPH-M570|SPH-M580|SPH-M610|SPH-M620|SPH-M630|SPH-M800|SPH-M810|SPH-M850|SPH-M900|SPH-M910|SPH-M920|SPH-M930|SPH-N100|SPH-N200|SPH-N240|SPH-N300|SPH-N400|SPH-Z400|SWC-E100|SCH-i909|GT-N7100|GT-N7105|SCH-I535|SM-N900A|SGH-I317|SGH-T999L|GT-S5360B|GT-I8262|GT-S6802|GT-S6312|GT-S6310|GT-S5312|GT-S5310|GT-I9105|GT-I8510|GT-S6790N|SM-G7105|SM-N9005|GT-S5301|GT-I9295|GT-I9195|SM-C101|GT-S7392|GT-S7560|GT-B7610|GT-I5510|GT-S7582|GT-S7530E|GT-I8750|SM-G9006V|SM-G9008V|SM-G9009D|SM-G900A|SM-G900D|SM-G900F|SM-G900H|SM-G900I|SM-G900J|SM-G900K|SM-G900L|SM-G900M|SM-G900P|SM-G900R4|SM-G900S|SM-G900T|SM-G900V|SM-G900W8|SHV-E160K|SCH-P709|SCH-P729|SM-T2558|GT-I9205|SM-G9350|SM-J120F|SM-G920F|SM-G920V|SM-G930F|SM-N910C|SM-A310F|GT-I9190|SM-J500FN|SM-G903F|SM-J330F|SM-G610F|SM-G981B|SM-G892A|SM-A530F",
          "LG": "\\bLG\\b;|LG[- ]?(C800|C900|E400|E610|E900|E-900|F160|F180K|F180L|F180S|730|855|L160|LS740|LS840|LS970|LU6200|MS690|MS695|MS770|MS840|MS870|MS910|P500|P700|P705|VM696|AS680|AS695|AX840|C729|E970|GS505|272|C395|E739BK|E960|L55C|L75C|LS696|LS860|P769BK|P350|P500|P509|P870|UN272|US730|VS840|VS950|LN272|LN510|LS670|LS855|LW690|MN270|MN510|P509|P769|P930|UN200|UN270|UN510|UN610|US670|US740|US760|UX265|UX840|VN271|VN530|VS660|VS700|VS740|VS750|VS910|VS920|VS930|VX9200|VX11000|AX840A|LW770|P506|P925|P999|E612|D955|D802|MS323|M257)|LM-G710",
          "Sony": "SonyST|SonyLT|SonyEricsson|SonyEricssonLT15iv|LT18i|E10i|LT28h|LT26w|SonyEricssonMT27i|C5303|C6902|C6903|C6906|C6943|D2533|SOV34|601SO|F8332",
          "Asus": "Asus.*Galaxy|PadFone.*Mobile",
          "Xiaomi": "^(?!.*\\bx11\\b).*xiaomi.*$|POCOPHONE F1|MI 8|Redmi Note 9S|Redmi Note 5A Prime|N2G47H|M2001J2G|M2001J2I|M1805E10A|M2004J11G|M1902F1G|M2002J9G|M2004J19G|M2003J6A1G",
          "NokiaLumia": "Lumia [0-9]{3,4}",
          "Micromax": "Micromax.*\\b(A210|A92|A88|A72|A111|A110Q|A115|A116|A110|A90S|A26|A51|A35|A54|A25|A27|A89|A68|A65|A57|A90)\\b",
          "Palm": "PalmSource|Palm",
          "Vertu": "Vertu|Vertu.*Ltd|Vertu.*Ascent|Vertu.*Ayxta|Vertu.*Constellation(F|Quest)?|Vertu.*Monika|Vertu.*Signature",
          "Pantech": "PANTECH|IM-A850S|IM-A840S|IM-A830L|IM-A830K|IM-A830S|IM-A820L|IM-A810K|IM-A810S|IM-A800S|IM-T100K|IM-A725L|IM-A780L|IM-A775C|IM-A770K|IM-A760S|IM-A750K|IM-A740S|IM-A730S|IM-A720L|IM-A710K|IM-A690L|IM-A690S|IM-A650S|IM-A630K|IM-A600S|VEGA PTL21|PT003|P8010|ADR910L|P6030|P6020|P9070|P4100|P9060|P5000|CDM8992|TXT8045|ADR8995|IS11PT|P2030|P6010|P8000|PT002|IS06|CDM8999|P9050|PT001|TXT8040|P2020|P9020|P2000|P7040|P7000|C790",
          "Fly": "IQ230|IQ444|IQ450|IQ440|IQ442|IQ441|IQ245|IQ256|IQ236|IQ255|IQ235|IQ245|IQ275|IQ240|IQ285|IQ280|IQ270|IQ260|IQ250",
          "Wiko": "KITE 4G|HIGHWAY|GETAWAY|STAIRWAY|DARKSIDE|DARKFULL|DARKNIGHT|DARKMOON|SLIDE|WAX 4G|RAINBOW|BLOOM|SUNSET|GOA(?!nna)|LENNY|BARRY|IGGY|OZZY|CINK FIVE|CINK PEAX|CINK PEAX 2|CINK SLIM|CINK SLIM 2|CINK +|CINK KING|CINK PEAX|CINK SLIM|SUBLIM",
          "iMobile": "i-mobile (IQ|i-STYLE|idea|ZAA|Hitz)",
          "SimValley": "\\b(SP-80|XT-930|SX-340|XT-930|SX-310|SP-360|SP60|SPT-800|SP-120|SPT-800|SP-140|SPX-5|SPX-8|SP-100|SPX-8|SPX-12)\\b",
          "Wolfgang": "AT-B24D|AT-AS50HD|AT-AS40W|AT-AS55HD|AT-AS45q2|AT-B26D|AT-AS50Q",
          "Alcatel": "Alcatel",
          "Nintendo": "Nintendo (3DS|Switch)",
          "Amoi": "Amoi",
          "INQ": "INQ",
          "OnePlus": "ONEPLUS",
          "GenericPhone": "Tapatalk|PDA;|SAGEM|\\bmmp\\b|pocket|\\bpsp\\b|symbian|Smartphone|smartfon|treo|up.browser|up.link|vodafone|\\bwap\\b|nokia|Series40|Series60|S60|SonyEricsson|N900|MAUI.*WAP.*Browser"
        },
        "tablets": {
          "iPad": "iPad|iPad.*Mobile",
          "NexusTablet": "Android.*Nexus[\\s]+(7|9|10)",
          "GoogleTablet": "Android.*Pixel C",
          "SamsungTablet": "SAMSUNG.*Tablet|Galaxy.*Tab|SC-01C|GT-P1000|GT-P1003|GT-P1010|GT-P3105|GT-P6210|GT-P6800|GT-P6810|GT-P7100|GT-P7300|GT-P7310|GT-P7500|GT-P7510|SCH-I800|SCH-I815|SCH-I905|SGH-I957|SGH-I987|SGH-T849|SGH-T859|SGH-T869|SPH-P100|GT-P3100|GT-P3108|GT-P3110|GT-P5100|GT-P5110|GT-P6200|GT-P7320|GT-P7511|GT-N8000|GT-P8510|SGH-I497|SPH-P500|SGH-T779|SCH-I705|SCH-I915|GT-N8013|GT-P3113|GT-P5113|GT-P8110|GT-N8010|GT-N8005|GT-N8020|GT-P1013|GT-P6201|GT-P7501|GT-N5100|GT-N5105|GT-N5110|SHV-E140K|SHV-E140L|SHV-E140S|SHV-E150S|SHV-E230K|SHV-E230L|SHV-E230S|SHW-M180K|SHW-M180L|SHW-M180S|SHW-M180W|SHW-M300W|SHW-M305W|SHW-M380K|SHW-M380S|SHW-M380W|SHW-M430W|SHW-M480K|SHW-M480S|SHW-M480W|SHW-M485W|SHW-M486W|SHW-M500W|GT-I9228|SCH-P739|SCH-I925|GT-I9200|GT-P5200|GT-P5210|GT-P5210X|SM-T311|SM-T310|SM-T310X|SM-T210|SM-T210R|SM-T211|SM-P600|SM-P601|SM-P605|SM-P900|SM-P901|SM-T217|SM-T217A|SM-T217S|SM-P6000|SM-T3100|SGH-I467|XE500|SM-T110|GT-P5220|GT-I9200X|GT-N5110X|GT-N5120|SM-P905|SM-T111|SM-T2105|SM-T315|SM-T320|SM-T320X|SM-T321|SM-T520|SM-T525|SM-T530NU|SM-T230NU|SM-T330NU|SM-T900|XE500T1C|SM-P605V|SM-P905V|SM-T337V|SM-T537V|SM-T707V|SM-T807V|SM-P600X|SM-P900X|SM-T210X|SM-T230|SM-T230X|SM-T325|GT-P7503|SM-T531|SM-T330|SM-T530|SM-T705|SM-T705C|SM-T535|SM-T331|SM-T800|SM-T700|SM-T537|SM-T807|SM-P907A|SM-T337A|SM-T537A|SM-T707A|SM-T807A|SM-T237|SM-T807P|SM-P607T|SM-T217T|SM-T337T|SM-T807T|SM-T116NQ|SM-T116BU|SM-P550|SM-T350|SM-T550|SM-T9000|SM-P9000|SM-T705Y|SM-T805|GT-P3113|SM-T710|SM-T810|SM-T815|SM-T360|SM-T533|SM-T113|SM-T335|SM-T715|SM-T560|SM-T670|SM-T677|SM-T377|SM-T567|SM-T357T|SM-T555|SM-T561|SM-T713|SM-T719|SM-T813|SM-T819|SM-T580|SM-T355Y?|SM-T280|SM-T817A|SM-T820|SM-W700|SM-P580|SM-T587|SM-P350|SM-P555M|SM-P355M|SM-T113NU|SM-T815Y|SM-T585|SM-T285|SM-T825|SM-W708|SM-T835|SM-T830|SM-T837V|SM-T720|SM-T510|SM-T387V|SM-P610|SM-T290|SM-T515|SM-T590|SM-T595|SM-T725|SM-T817P|SM-P585N0|SM-T395|SM-T295|SM-T865|SM-P610N|SM-P615|SM-T970|SM-T380|SM-T5950|SM-T905|SM-T231|SM-T500|SM-T860",
          "Kindle": "Kindle|Silk.*Accelerated|Android.*\\b(KFOT|KFTT|KFJWI|KFJWA|KFOTE|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|WFJWAE|KFSAWA|KFSAWI|KFASWI|KFARWI|KFFOWI|KFGIWI|KFMEWI)\\b|Android.*Silk/[0-9.]+ like Chrome/[0-9.]+ (?!Mobile)",
          "SurfaceTablet": "Windows NT [0-9.]+; ARM;.*(Tablet|ARMBJS)",
          "HPTablet": "HP Slate (7|8|10)|HP ElitePad 900|hp-tablet|EliteBook.*Touch|HP 8|Slate 21|HP SlateBook 10",
          "AsusTablet": "^.*PadFone((?!Mobile).)*$|Transformer|TF101|TF101G|TF300T|TF300TG|TF300TL|TF700T|TF700KL|TF701T|TF810C|ME171|ME301T|ME302C|ME371MG|ME370T|ME372MG|ME172V|ME173X|ME400C|Slider SL101|\\bK00F\\b|\\bK00C\\b|\\bK00E\\b|\\bK00L\\b|TX201LA|ME176C|ME102A|\\bM80TA\\b|ME372CL|ME560CG|ME372CG|ME302KL| K010 | K011 | K017 | K01E |ME572C|ME103K|ME170C|ME171C|\\bME70C\\b|ME581C|ME581CL|ME8510C|ME181C|P01Y|PO1MA|P01Z|\\bP027\\b|\\bP024\\b|\\bP00C\\b",
          "BlackBerryTablet": "PlayBook|RIM Tablet",
          "HTCtablet": "HTC_Flyer_P512|HTC Flyer|HTC Jetstream|HTC-P715a|HTC EVO View 4G|PG41200|PG09410",
          "MotorolaTablet": "xoom|sholest|MZ615|MZ605|MZ505|MZ601|MZ602|MZ603|MZ604|MZ606|MZ607|MZ608|MZ609|MZ615|MZ616|MZ617",
          "NookTablet": "Android.*Nook|NookColor|nook browser|BNRV200|BNRV200A|BNTV250|BNTV250A|BNTV400|BNTV600|LogicPD Zoom2",
          "AcerTablet": "Android.*; \\b(A100|A101|A110|A200|A210|A211|A500|A501|A510|A511|A700|A701|W500|W500P|W501|W501P|W510|W511|W700|G100|G100W|B1-A71|B1-710|B1-711|A1-810|A1-811|A1-830)\\b|W3-810|\\bA3-A10\\b|\\bA3-A11\\b|\\bA3-A20\\b|\\bA3-A30|A3-A40",
          "ToshibaTablet": "Android.*(AT100|AT105|AT200|AT205|AT270|AT275|AT300|AT305|AT1S5|AT500|AT570|AT700|AT830)|TOSHIBA.*FOLIO",
          "LGTablet": "\\bL-06C|LG-V909|LG-V900|LG-V700|LG-V510|LG-V500|LG-V410|LG-V400|LG-VK810\\b",
          "FujitsuTablet": "Android.*\\b(F-01D|F-02F|F-05E|F-10D|M532|Q572)\\b",
          "PrestigioTablet": "PMP3170B|PMP3270B|PMP3470B|PMP7170B|PMP3370B|PMP3570C|PMP5870C|PMP3670B|PMP5570C|PMP5770D|PMP3970B|PMP3870C|PMP5580C|PMP5880D|PMP5780D|PMP5588C|PMP7280C|PMP7280C3G|PMP7280|PMP7880D|PMP5597D|PMP5597|PMP7100D|PER3464|PER3274|PER3574|PER3884|PER5274|PER5474|PMP5097CPRO|PMP5097|PMP7380D|PMP5297C|PMP5297C_QUAD|PMP812E|PMP812E3G|PMP812F|PMP810E|PMP880TD|PMT3017|PMT3037|PMT3047|PMT3057|PMT7008|PMT5887|PMT5001|PMT5002",
          "LenovoTablet": "Lenovo TAB|Idea(Tab|Pad)( A1|A10| K1|)|ThinkPad([ ]+)?Tablet|YT3-850M|YT3-X90L|YT3-X90F|YT3-X90X|Lenovo.*(S2109|S2110|S5000|S6000|K3011|A3000|A3500|A1000|A2107|A2109|A1107|A5500|A7600|B6000|B8000|B8080)(-|)(FL|F|HV|H|)|TB-X103F|TB-X304X|TB-X304F|TB-X304L|TB-X505F|TB-X505L|TB-X505X|TB-X605F|TB-X605L|TB-8703F|TB-8703X|TB-8703N|TB-8704N|TB-8704F|TB-8704X|TB-8704V|TB-7304F|TB-7304I|TB-7304X|Tab2A7-10F|Tab2A7-20F|TB2-X30L|YT3-X50L|YT3-X50F|YT3-X50M|YT-X705F|YT-X703F|YT-X703L|YT-X705L|YT-X705X|TB2-X30F|TB2-X30L|TB2-X30M|A2107A-F|A2107A-H|TB3-730F|TB3-730M|TB3-730X|TB-7504F|TB-7504X|TB-X704F|TB-X104F|TB3-X70F|TB-X705F|TB-8504F|TB3-X70L|TB3-710F|TB-X704L",
          "DellTablet": "Venue 11|Venue 8|Venue 7|Dell Streak 10|Dell Streak 7",
          "YarvikTablet": "Android.*\\b(TAB210|TAB211|TAB224|TAB250|TAB260|TAB264|TAB310|TAB360|TAB364|TAB410|TAB411|TAB420|TAB424|TAB450|TAB460|TAB461|TAB464|TAB465|TAB467|TAB468|TAB07-100|TAB07-101|TAB07-150|TAB07-151|TAB07-152|TAB07-200|TAB07-201-3G|TAB07-210|TAB07-211|TAB07-212|TAB07-214|TAB07-220|TAB07-400|TAB07-485|TAB08-150|TAB08-200|TAB08-201-3G|TAB08-201-30|TAB09-100|TAB09-211|TAB09-410|TAB10-150|TAB10-201|TAB10-211|TAB10-400|TAB10-410|TAB13-201|TAB274EUK|TAB275EUK|TAB374EUK|TAB462EUK|TAB474EUK|TAB9-200)\\b",
          "MedionTablet": "Android.*\\bOYO\\b|LIFE.*(P9212|P9514|P9516|S9512)|LIFETAB",
          "ArnovaTablet": "97G4|AN10G2|AN7bG3|AN7fG3|AN8G3|AN8cG3|AN7G3|AN9G3|AN7dG3|AN7dG3ST|AN7dG3ChildPad|AN10bG3|AN10bG3DT|AN9G2",
          "IntensoTablet": "INM8002KP|INM1010FP|INM805ND|Intenso Tab|TAB1004",
          "IRUTablet": "M702pro",
          "MegafonTablet": "MegaFon V9|\\bZTE V9\\b|Android.*\\bMT7A\\b",
          "EbodaTablet": "E-Boda (Supreme|Impresspeed|Izzycomm|Essential)",
          "AllViewTablet": "Allview.*(Viva|Alldro|City|Speed|All TV|Frenzy|Quasar|Shine|TX1|AX1|AX2)",
          "ArchosTablet": "\\b(101G9|80G9|A101IT)\\b|Qilive 97R|Archos5|\\bARCHOS (70|79|80|90|97|101|FAMILYPAD|)(b|c|)(G10| Cobalt| TITANIUM(HD|)| Xenon| Neon|XSK| 2| XS 2| PLATINUM| CARBON|GAMEPAD)\\b",
          "AinolTablet": "NOVO7|NOVO8|NOVO10|Novo7Aurora|Novo7Basic|NOVO7PALADIN|novo9-Spark",
          "NokiaLumiaTablet": "Lumia 2520",
          "SonyTablet": "Sony.*Tablet|Xperia Tablet|Sony Tablet S|SO-03E|SGPT12|SGPT13|SGPT114|SGPT121|SGPT122|SGPT123|SGPT111|SGPT112|SGPT113|SGPT131|SGPT132|SGPT133|SGPT211|SGPT212|SGPT213|SGP311|SGP312|SGP321|EBRD1101|EBRD1102|EBRD1201|SGP351|SGP341|SGP511|SGP512|SGP521|SGP541|SGP551|SGP621|SGP641|SGP612|SOT31|SGP771|SGP611|SGP612|SGP712",
          "PhilipsTablet": "\\b(PI2010|PI3000|PI3100|PI3105|PI3110|PI3205|PI3210|PI3900|PI4010|PI7000|PI7100)\\b",
          "CubeTablet": "Android.*(K8GT|U9GT|U10GT|U16GT|U17GT|U18GT|U19GT|U20GT|U23GT|U30GT)|CUBE U8GT",
          "CobyTablet": "MID1042|MID1045|MID1125|MID1126|MID7012|MID7014|MID7015|MID7034|MID7035|MID7036|MID7042|MID7048|MID7127|MID8042|MID8048|MID8127|MID9042|MID9740|MID9742|MID7022|MID7010",
          "MIDTablet": "M9701|M9000|M9100|M806|M1052|M806|T703|MID701|MID713|MID710|MID727|MID760|MID830|MID728|MID933|MID125|MID810|MID732|MID120|MID930|MID800|MID731|MID900|MID100|MID820|MID735|MID980|MID130|MID833|MID737|MID960|MID135|MID860|MID736|MID140|MID930|MID835|MID733|MID4X10",
          "MSITablet": "MSI \\b(Primo 73K|Primo 73L|Primo 81L|Primo 77|Primo 93|Primo 75|Primo 76|Primo 73|Primo 81|Primo 91|Primo 90|Enjoy 71|Enjoy 7|Enjoy 10)\\b",
          "SMiTTablet": "Android.*(\\bMID\\b|MID-560|MTV-T1200|MTV-PND531|MTV-P1101|MTV-PND530)",
          "RockChipTablet": "Android.*(RK2818|RK2808A|RK2918|RK3066)|RK2738|RK2808A",
          "FlyTablet": "IQ310|Fly Vision",
          "bqTablet": "Android.*(bq)?.*\\b(Elcano|Curie|Edison|Maxwell|Kepler|Pascal|Tesla|Hypatia|Platon|Newton|Livingstone|Cervantes|Avant|Aquaris ([E|M]10|M8))\\b|Maxwell.*Lite|Maxwell.*Plus",
          "HuaweiTablet": "MediaPad|MediaPad 7 Youth|IDEOS S7|S7-201c|S7-202u|S7-101|S7-103|S7-104|S7-105|S7-106|S7-201|S7-Slim|M2-A01L|BAH-L09|BAH-W09|AGS-L09|CMR-AL19",
          "NecTablet": "\\bN-06D|\\bN-08D",
          "PantechTablet": "Pantech.*P4100",
          "BronchoTablet": "Broncho.*(N701|N708|N802|a710)",
          "VersusTablet": "TOUCHPAD.*[78910]|\\bTOUCHTAB\\b",
          "ZyncTablet": "z1000|Z99 2G|z930|z990|z909|Z919|z900",
          "PositivoTablet": "TB07STA|TB10STA|TB07FTA|TB10FTA",
          "NabiTablet": "Android.*\\bNabi",
          "KoboTablet": "Kobo Touch|\\bK080\\b|\\bVox\\b Build|\\bArc\\b Build",
          "DanewTablet": "DSlide.*\\b(700|701R|702|703R|704|802|970|971|972|973|974|1010|1012)\\b",
          "TexetTablet": "NaviPad|TB-772A|TM-7045|TM-7055|TM-9750|TM-7016|TM-7024|TM-7026|TM-7041|TM-7043|TM-7047|TM-8041|TM-9741|TM-9747|TM-9748|TM-9751|TM-7022|TM-7021|TM-7020|TM-7011|TM-7010|TM-7023|TM-7025|TM-7037W|TM-7038W|TM-7027W|TM-9720|TM-9725|TM-9737W|TM-1020|TM-9738W|TM-9740|TM-9743W|TB-807A|TB-771A|TB-727A|TB-725A|TB-719A|TB-823A|TB-805A|TB-723A|TB-715A|TB-707A|TB-705A|TB-709A|TB-711A|TB-890HD|TB-880HD|TB-790HD|TB-780HD|TB-770HD|TB-721HD|TB-710HD|TB-434HD|TB-860HD|TB-840HD|TB-760HD|TB-750HD|TB-740HD|TB-730HD|TB-722HD|TB-720HD|TB-700HD|TB-500HD|TB-470HD|TB-431HD|TB-430HD|TB-506|TB-504|TB-446|TB-436|TB-416|TB-146SE|TB-126SE",
          "PlaystationTablet": "Playstation.*(Portable|Vita)",
          "TrekstorTablet": "ST10416-1|VT10416-1|ST70408-1|ST702xx-1|ST702xx-2|ST80208|ST97216|ST70104-2|VT10416-2|ST10216-2A|SurfTab",
          "PyleAudioTablet": "\\b(PTBL10CEU|PTBL10C|PTBL72BC|PTBL72BCEU|PTBL7CEU|PTBL7C|PTBL92BC|PTBL92BCEU|PTBL9CEU|PTBL9CUK|PTBL9C)\\b",
          "AdvanTablet": "Android.* \\b(E3A|T3X|T5C|T5B|T3E|T3C|T3B|T1J|T1F|T2A|T1H|T1i|E1C|T1-E|T5-A|T4|E1-B|T2Ci|T1-B|T1-D|O1-A|E1-A|T1-A|T3A|T4i)\\b ",
          "DanyTechTablet": "Genius Tab G3|Genius Tab S2|Genius Tab Q3|Genius Tab G4|Genius Tab Q4|Genius Tab G-II|Genius TAB GII|Genius TAB GIII|Genius Tab S1",
          "GalapadTablet": "Android [0-9.]+; [a-z-]+; \\bG1\\b",
          "MicromaxTablet": "Funbook|Micromax.*\\b(P250|P560|P360|P362|P600|P300|P350|P500|P275)\\b",
          "KarbonnTablet": "Android.*\\b(A39|A37|A34|ST8|ST10|ST7|Smart Tab3|Smart Tab2)\\b",
          "AllFineTablet": "Fine7 Genius|Fine7 Shine|Fine7 Air|Fine8 Style|Fine9 More|Fine10 Joy|Fine11 Wide",
          "PROSCANTablet": "\\b(PEM63|PLT1023G|PLT1041|PLT1044|PLT1044G|PLT1091|PLT4311|PLT4311PL|PLT4315|PLT7030|PLT7033|PLT7033D|PLT7035|PLT7035D|PLT7044K|PLT7045K|PLT7045KB|PLT7071KG|PLT7072|PLT7223G|PLT7225G|PLT7777G|PLT7810K|PLT7849G|PLT7851G|PLT7852G|PLT8015|PLT8031|PLT8034|PLT8036|PLT8080K|PLT8082|PLT8088|PLT8223G|PLT8234G|PLT8235G|PLT8816K|PLT9011|PLT9045K|PLT9233G|PLT9735|PLT9760G|PLT9770G)\\b",
          "YONESTablet": "BQ1078|BC1003|BC1077|RK9702|BC9730|BC9001|IT9001|BC7008|BC7010|BC708|BC728|BC7012|BC7030|BC7027|BC7026",
          "ChangJiaTablet": "TPC7102|TPC7103|TPC7105|TPC7106|TPC7107|TPC7201|TPC7203|TPC7205|TPC7210|TPC7708|TPC7709|TPC7712|TPC7110|TPC8101|TPC8103|TPC8105|TPC8106|TPC8203|TPC8205|TPC8503|TPC9106|TPC9701|TPC97101|TPC97103|TPC97105|TPC97106|TPC97111|TPC97113|TPC97203|TPC97603|TPC97809|TPC97205|TPC10101|TPC10103|TPC10106|TPC10111|TPC10203|TPC10205|TPC10503",
          "GUTablet": "TX-A1301|TX-M9002|Q702|kf026",
          "PointOfViewTablet": "TAB-P506|TAB-navi-7-3G-M|TAB-P517|TAB-P-527|TAB-P701|TAB-P703|TAB-P721|TAB-P731N|TAB-P741|TAB-P825|TAB-P905|TAB-P925|TAB-PR945|TAB-PL1015|TAB-P1025|TAB-PI1045|TAB-P1325|TAB-PROTAB[0-9]+|TAB-PROTAB25|TAB-PROTAB26|TAB-PROTAB27|TAB-PROTAB26XL|TAB-PROTAB2-IPS9|TAB-PROTAB30-IPS9|TAB-PROTAB25XXL|TAB-PROTAB26-IPS10|TAB-PROTAB30-IPS10",
          "OvermaxTablet": "OV-(SteelCore|NewBase|Basecore|Baseone|Exellen|Quattor|EduTab|Solution|ACTION|BasicTab|TeddyTab|MagicTab|Stream|TB-08|TB-09)|Qualcore 1027",
          "HCLTablet": "HCL.*Tablet|Connect-3G-2.0|Connect-2G-2.0|ME Tablet U1|ME Tablet U2|ME Tablet G1|ME Tablet X1|ME Tablet Y2|ME Tablet Sync",
          "DPSTablet": "DPS Dream 9|DPS Dual 7",
          "VistureTablet": "V97 HD|i75 3G|Visture V4( HD)?|Visture V5( HD)?|Visture V10",
          "CrestaTablet": "CTP(-)?810|CTP(-)?818|CTP(-)?828|CTP(-)?838|CTP(-)?888|CTP(-)?978|CTP(-)?980|CTP(-)?987|CTP(-)?988|CTP(-)?989",
          "MediatekTablet": "\\bMT8125|MT8389|MT8135|MT8377\\b",
          "ConcordeTablet": "Concorde([ ]+)?Tab|ConCorde ReadMan",
          "GoCleverTablet": "GOCLEVER TAB|A7GOCLEVER|M1042|M7841|M742|R1042BK|R1041|TAB A975|TAB A7842|TAB A741|TAB A741L|TAB M723G|TAB M721|TAB A1021|TAB I921|TAB R721|TAB I720|TAB T76|TAB R70|TAB R76.2|TAB R106|TAB R83.2|TAB M813G|TAB I721|GCTA722|TAB I70|TAB I71|TAB S73|TAB R73|TAB R74|TAB R93|TAB R75|TAB R76.1|TAB A73|TAB A93|TAB A93.2|TAB T72|TAB R83|TAB R974|TAB R973|TAB A101|TAB A103|TAB A104|TAB A104.2|R105BK|M713G|A972BK|TAB A971|TAB R974.2|TAB R104|TAB R83.3|TAB A1042",
          "ModecomTablet": "FreeTAB 9000|FreeTAB 7.4|FreeTAB 7004|FreeTAB 7800|FreeTAB 2096|FreeTAB 7.5|FreeTAB 1014|FreeTAB 1001 |FreeTAB 8001|FreeTAB 9706|FreeTAB 9702|FreeTAB 7003|FreeTAB 7002|FreeTAB 1002|FreeTAB 7801|FreeTAB 1331|FreeTAB 1004|FreeTAB 8002|FreeTAB 8014|FreeTAB 9704|FreeTAB 1003",
          "VoninoTablet": "\\b(Argus[ _]?S|Diamond[ _]?79HD|Emerald[ _]?78E|Luna[ _]?70C|Onyx[ _]?S|Onyx[ _]?Z|Orin[ _]?HD|Orin[ _]?S|Otis[ _]?S|SpeedStar[ _]?S|Magnet[ _]?M9|Primus[ _]?94[ _]?3G|Primus[ _]?94HD|Primus[ _]?QS|Android.*\\bQ8\\b|Sirius[ _]?EVO[ _]?QS|Sirius[ _]?QS|Spirit[ _]?S)\\b",
          "ECSTablet": "V07OT2|TM105A|S10OT1|TR10CS1",
          "StorexTablet": "eZee[_']?(Tab|Go)[0-9]+|TabLC7|Looney Tunes Tab",
          "VodafoneTablet": "SmartTab([ ]+)?[0-9]+|SmartTabII10|SmartTabII7|VF-1497|VFD 1400",
          "EssentielBTablet": "Smart[ ']?TAB[ ]+?[0-9]+|Family[ ']?TAB2",
          "RossMoorTablet": "RM-790|RM-997|RMD-878G|RMD-974R|RMT-705A|RMT-701|RME-601|RMT-501|RMT-711",
          "iMobileTablet": "i-mobile i-note",
          "TolinoTablet": "tolino tab [0-9.]+|tolino shine",
          "AudioSonicTablet": "\\bC-22Q|T7-QC|T-17B|T-17P\\b",
          "AMPETablet": "Android.* A78 ",
          "SkkTablet": "Android.* (SKYPAD|PHOENIX|CYCLOPS)",
          "TecnoTablet": "TECNO P9|TECNO DP8D",
          "JXDTablet": "Android.* \\b(F3000|A3300|JXD5000|JXD3000|JXD2000|JXD300B|JXD300|S5800|S7800|S602b|S5110b|S7300|S5300|S602|S603|S5100|S5110|S601|S7100a|P3000F|P3000s|P101|P200s|P1000m|P200m|P9100|P1000s|S6600b|S908|P1000|P300|S18|S6600|S9100)\\b",
          "iJoyTablet": "Tablet (Spirit 7|Essentia|Galatea|Fusion|Onix 7|Landa|Titan|Scooby|Deox|Stella|Themis|Argon|Unique 7|Sygnus|Hexen|Finity 7|Cream|Cream X2|Jade|Neon 7|Neron 7|Kandy|Scape|Saphyr 7|Rebel|Biox|Rebel|Rebel 8GB|Myst|Draco 7|Myst|Tab7-004|Myst|Tadeo Jones|Tablet Boing|Arrow|Draco Dual Cam|Aurix|Mint|Amity|Revolution|Finity 9|Neon 9|T9w|Amity 4GB Dual Cam|Stone 4GB|Stone 8GB|Andromeda|Silken|X2|Andromeda II|Halley|Flame|Saphyr 9,7|Touch 8|Planet|Triton|Unique 10|Hexen 10|Memphis 4GB|Memphis 8GB|Onix 10)",
          "FX2Tablet": "FX2 PAD7|FX2 PAD10",
          "XoroTablet": "KidsPAD 701|PAD[ ]?712|PAD[ ]?714|PAD[ ]?716|PAD[ ]?717|PAD[ ]?718|PAD[ ]?720|PAD[ ]?721|PAD[ ]?722|PAD[ ]?790|PAD[ ]?792|PAD[ ]?900|PAD[ ]?9715D|PAD[ ]?9716DR|PAD[ ]?9718DR|PAD[ ]?9719QR|PAD[ ]?9720QR|TelePAD1030|Telepad1032|TelePAD730|TelePAD731|TelePAD732|TelePAD735Q|TelePAD830|TelePAD9730|TelePAD795|MegaPAD 1331|MegaPAD 1851|MegaPAD 2151",
          "ViewsonicTablet": "ViewPad 10pi|ViewPad 10e|ViewPad 10s|ViewPad E72|ViewPad7|ViewPad E100|ViewPad 7e|ViewSonic VB733|VB100a",
          "VerizonTablet": "QTAQZ3|QTAIR7|QTAQTZ3|QTASUN1|QTASUN2|QTAXIA1",
          "OdysTablet": "LOOX|XENO10|ODYS[ -](Space|EVO|Xpress|NOON)|\\bXELIO\\b|Xelio10Pro|XELIO7PHONETAB|XELIO10EXTREME|XELIOPT2|NEO_QUAD10",
          "CaptivaTablet": "CAPTIVA PAD",
          "IconbitTablet": "NetTAB|NT-3702|NT-3702S|NT-3702S|NT-3603P|NT-3603P|NT-0704S|NT-0704S|NT-3805C|NT-3805C|NT-0806C|NT-0806C|NT-0909T|NT-0909T|NT-0907S|NT-0907S|NT-0902S|NT-0902S",
          "TeclastTablet": "T98 4G|\\bP80\\b|\\bX90HD\\b|X98 Air|X98 Air 3G|\\bX89\\b|P80 3G|\\bX80h\\b|P98 Air|\\bX89HD\\b|P98 3G|\\bP90HD\\b|P89 3G|X98 3G|\\bP70h\\b|P79HD 3G|G18d 3G|\\bP79HD\\b|\\bP89s\\b|\\bA88\\b|\\bP10HD\\b|\\bP19HD\\b|G18 3G|\\bP78HD\\b|\\bA78\\b|\\bP75\\b|G17s 3G|G17h 3G|\\bP85t\\b|\\bP90\\b|\\bP11\\b|\\bP98t\\b|\\bP98HD\\b|\\bG18d\\b|\\bP85s\\b|\\bP11HD\\b|\\bP88s\\b|\\bA80HD\\b|\\bA80se\\b|\\bA10h\\b|\\bP89\\b|\\bP78s\\b|\\bG18\\b|\\bP85\\b|\\bA70h\\b|\\bA70\\b|\\bG17\\b|\\bP18\\b|\\bA80s\\b|\\bA11s\\b|\\bP88HD\\b|\\bA80h\\b|\\bP76s\\b|\\bP76h\\b|\\bP98\\b|\\bA10HD\\b|\\bP78\\b|\\bP88\\b|\\bA11\\b|\\bA10t\\b|\\bP76a\\b|\\bP76t\\b|\\bP76e\\b|\\bP85HD\\b|\\bP85a\\b|\\bP86\\b|\\bP75HD\\b|\\bP76v\\b|\\bA12\\b|\\bP75a\\b|\\bA15\\b|\\bP76Ti\\b|\\bP81HD\\b|\\bA10\\b|\\bT760VE\\b|\\bT720HD\\b|\\bP76\\b|\\bP73\\b|\\bP71\\b|\\bP72\\b|\\bT720SE\\b|\\bC520Ti\\b|\\bT760\\b|\\bT720VE\\b|T720-3GE|T720-WiFi",
          "OndaTablet": "\\b(V975i|Vi30|VX530|V701|Vi60|V701s|Vi50|V801s|V719|Vx610w|VX610W|V819i|Vi10|VX580W|Vi10|V711s|V813|V811|V820w|V820|Vi20|V711|VI30W|V712|V891w|V972|V819w|V820w|Vi60|V820w|V711|V813s|V801|V819|V975s|V801|V819|V819|V818|V811|V712|V975m|V101w|V961w|V812|V818|V971|V971s|V919|V989|V116w|V102w|V973|Vi40)\\b[\\s]+|V10 \\b4G\\b",
          "JaytechTablet": "TPC-PA762",
          "BlaupunktTablet": "Endeavour 800NG|Endeavour 1010",
          "DigmaTablet": "\\b(iDx10|iDx9|iDx8|iDx7|iDxD7|iDxD8|iDsQ8|iDsQ7|iDsQ8|iDsD10|iDnD7|3TS804H|iDsQ11|iDj7|iDs10)\\b",
          "EvolioTablet": "ARIA_Mini_wifi|Aria[ _]Mini|Evolio X10|Evolio X7|Evolio X8|\\bEvotab\\b|\\bNeura\\b",
          "LavaTablet": "QPAD E704|\\bIvoryS\\b|E-TAB IVORY|\\bE-TAB\\b",
          "AocTablet": "MW0811|MW0812|MW0922|MTK8382|MW1031|MW0831|MW0821|MW0931|MW0712",
          "MpmanTablet": "MP11 OCTA|MP10 OCTA|MPQC1114|MPQC1004|MPQC994|MPQC974|MPQC973|MPQC804|MPQC784|MPQC780|\\bMPG7\\b|MPDCG75|MPDCG71|MPDC1006|MP101DC|MPDC9000|MPDC905|MPDC706HD|MPDC706|MPDC705|MPDC110|MPDC100|MPDC99|MPDC97|MPDC88|MPDC8|MPDC77|MP709|MID701|MID711|MID170|MPDC703|MPQC1010",
          "CelkonTablet": "CT695|CT888|CT[\\s]?910|CT7 Tab|CT9 Tab|CT3 Tab|CT2 Tab|CT1 Tab|C820|C720|\\bCT-1\\b",
          "WolderTablet": "miTab \\b(DIAMOND|SPACE|BROOKLYN|NEO|FLY|MANHATTAN|FUNK|EVOLUTION|SKY|GOCAR|IRON|GENIUS|POP|MINT|EPSILON|BROADWAY|JUMP|HOP|LEGEND|NEW AGE|LINE|ADVANCE|FEEL|FOLLOW|LIKE|LINK|LIVE|THINK|FREEDOM|CHICAGO|CLEVELAND|BALTIMORE-GH|IOWA|BOSTON|SEATTLE|PHOENIX|DALLAS|IN 101|MasterChef)\\b",
          "MediacomTablet": "M-MPI10C3G|M-SP10EG|M-SP10EGP|M-SP10HXAH|M-SP7HXAH|M-SP10HXBH|M-SP8HXAH|M-SP8MXA",
          "MiTablet": "\\bMI PAD\\b|\\bHM NOTE 1W\\b",
          "NibiruTablet": "Nibiru M1|Nibiru Jupiter One",
          "NexoTablet": "NEXO NOVA|NEXO 10|NEXO AVIO|NEXO FREE|NEXO GO|NEXO EVO|NEXO 3G|NEXO SMART|NEXO KIDDO|NEXO MOBI",
          "LeaderTablet": "TBLT10Q|TBLT10I|TBL-10WDKB|TBL-10WDKBO2013|TBL-W230V2|TBL-W450|TBL-W500|SV572|TBLT7I|TBA-AC7-8G|TBLT79|TBL-8W16|TBL-10W32|TBL-10WKB|TBL-W100",
          "UbislateTablet": "UbiSlate[\\s]?7C",
          "PocketBookTablet": "Pocketbook",
          "KocasoTablet": "\\b(TB-1207)\\b",
          "HisenseTablet": "\\b(F5281|E2371)\\b",
          "Hudl": "Hudl HT7S3|Hudl 2",
          "TelstraTablet": "T-Hub2",
          "GenericTablet": "Android.*\\b97D\\b|Tablet(?!.*PC)|BNTV250A|MID-WCDMA|LogicPD Zoom2|\\bA7EB\\b|CatNova8|A1_07|CT704|CT1002|\\bM721\\b|rk30sdk|\\bEVOTAB\\b|M758A|ET904|ALUMIUM10|Smartfren Tab|Endeavour 1010|Tablet-PC-4|Tagi Tab|\\bM6pro\\b|CT1020W|arc 10HD|\\bTP750\\b|\\bQTAQZ3\\b|WVT101|TM1088|KT107"
        },
        "oss": {
          "AndroidOS": "Android",
          "BlackBerryOS": "blackberry|\\bBB10\\b|rim tablet os",
          "PalmOS": "PalmOS|avantgo|blazer|elaine|hiptop|palm|plucker|xiino",
          "SymbianOS": "Symbian|SymbOS|Series60|Series40|SYB-[0-9]+|\\bS60\\b",
          "WindowsMobileOS": "Windows CE.*(PPC|Smartphone|Mobile|[0-9]{3}x[0-9]{3})|Windows Mobile|Windows Phone [0-9.]+|WCE;",
          "WindowsPhoneOS": "Windows Phone 10.0|Windows Phone 8.1|Windows Phone 8.0|Windows Phone OS|XBLWP7|ZuneWP7|Windows NT 6.[23]; ARM;",
          "iOS": "\\biPhone.*Mobile|\\biPod|\\biPad|AppleCoreMedia",
          "iPadOS": "CPU OS 13",
          "SailfishOS": "Sailfish",
          "MeeGoOS": "MeeGo",
          "MaemoOS": "Maemo",
          "JavaOS": "J2ME/|\\bMIDP\\b|\\bCLDC\\b",
          "webOS": "webOS|hpwOS",
          "badaOS": "\\bBada\\b",
          "BREWOS": "BREW"
        },
        "uas": {
          "Chrome": "\\bCrMo\\b|CriOS|Android.*Chrome/[.0-9]* (Mobile)?",
          "Dolfin": "\\bDolfin\\b",
          "Opera": "Opera.*Mini|Opera.*Mobi|Android.*Opera|Mobile.*OPR/[0-9.]+$|Coast/[0-9.]+",
          "Skyfire": "Skyfire",
          "Edge": "\\bEdgiOS\\b|Mobile Safari/[.0-9]* Edge",
          "IE": "IEMobile|MSIEMobile",
          "Firefox": "fennec|firefox.*maemo|(Mobile|Tablet).*Firefox|Firefox.*Mobile|FxiOS",
          "Bolt": "bolt",
          "TeaShark": "teashark",
          "Blazer": "Blazer",
          "Safari": "Version((?!\\bEdgiOS\\b).)*Mobile.*Safari|Safari.*Mobile|MobileSafari",
          "WeChat": "\\bMicroMessenger\\b",
          "UCBrowser": "UC.*Browser|UCWEB",
          "baiduboxapp": "baiduboxapp",
          "baidubrowser": "baidubrowser",
          "DiigoBrowser": "DiigoBrowser",
          "Mercury": "\\bMercury\\b",
          "ObigoBrowser": "Obigo",
          "NetFront": "NF-Browser",
          "GenericBrowser": "NokiaBrowser|OviBrowser|OneBrowser|TwonkyBeamBrowser|SEMC.*Browser|FlyFlow|Minimo|NetFront|Novarra-Vision|MQQBrowser|MicroMessenger",
          "PaleMoon": "Android.*PaleMoon|Mobile.*PaleMoon"
        },
        "props": {
          "Mobile": "Mobile/[VER]",
          "Build": "Build/[VER]",
          "Version": "Version/[VER]",
          "VendorID": "VendorID/[VER]",
          "iPad": "iPad.*CPU[a-z ]+[VER]",
          "iPhone": "iPhone.*CPU[a-z ]+[VER]",
          "iPod": "iPod.*CPU[a-z ]+[VER]",
          "Kindle": "Kindle/[VER]",
          "Chrome": [
            "Chrome/[VER]",
            "CriOS/[VER]",
            "CrMo/[VER]"
          ],
          "Coast": [
            "Coast/[VER]"
          ],
          "Dolfin": "Dolfin/[VER]",
          "Firefox": [
            "Firefox/[VER]",
            "FxiOS/[VER]"
          ],
          "Fennec": "Fennec/[VER]",
          "Edge": "Edge/[VER]",
          "IE": [
            "IEMobile/[VER];",
            "IEMobile [VER]",
            "MSIE [VER];",
            "Trident/[0-9.]+;.*rv:[VER]"
          ],
          "NetFront": "NetFront/[VER]",
          "NokiaBrowser": "NokiaBrowser/[VER]",
          "Opera": [
            " OPR/[VER]",
            "Opera Mini/[VER]",
            "Version/[VER]"
          ],
          "Opera Mini": "Opera Mini/[VER]",
          "Opera Mobi": "Version/[VER]",
          "UCBrowser": [
            "UCWEB[VER]",
            "UC.*Browser/[VER]"
          ],
          "MQQBrowser": "MQQBrowser/[VER]",
          "MicroMessenger": "MicroMessenger/[VER]",
          "baiduboxapp": "baiduboxapp/[VER]",
          "baidubrowser": "baidubrowser/[VER]",
          "SamsungBrowser": "SamsungBrowser/[VER]",
          "Iron": "Iron/[VER]",
          "Safari": [
            "Version/[VER]",
            "Safari/[VER]"
          ],
          "Skyfire": "Skyfire/[VER]",
          "Tizen": "Tizen/[VER]",
          "Webkit": "webkit[ /][VER]",
          "PaleMoon": "PaleMoon/[VER]",
          "SailfishBrowser": "SailfishBrowser/[VER]",
          "Gecko": "Gecko/[VER]",
          "Trident": "Trident/[VER]",
          "Presto": "Presto/[VER]",
          "Goanna": "Goanna/[VER]",
          "iOS": " \\bi?OS\\b [VER][ ;]{1}",
          "Android": "Android [VER]",
          "Sailfish": "Sailfish [VER]",
          "BlackBerry": [
            "BlackBerry[\\w]+/[VER]",
            "BlackBerry.*Version/[VER]",
            "Version/[VER]"
          ],
          "BREW": "BREW [VER]",
          "Java": "Java/[VER]",
          "Windows Phone OS": [
            "Windows Phone OS [VER]",
            "Windows Phone [VER]"
          ],
          "Windows Phone": "Windows Phone [VER]",
          "Windows CE": "Windows CE/[VER]",
          "Windows NT": "Windows NT [VER]",
          "Symbian": [
            "SymbianOS/[VER]",
            "Symbian/[VER]"
          ],
          "webOS": [
            "webOS/[VER]",
            "hpwOS/[VER];"
          ]
        },
        "utils": {
          "Bot": "Googlebot|facebookexternalhit|Google-AMPHTML|s~amp-validator|AdsBot-Google|Google Keyword Suggestion|Facebot|YandexBot|YandexMobileBot|bingbot|ia_archiver|AhrefsBot|Ezooms|GSLFbot|WBSearchBot|Twitterbot|TweetmemeBot|Twikle|PaperLiBot|Wotbox|UnwindFetchor|Exabot|MJ12bot|YandexImages|TurnitinBot|Pingdom|contentkingapp|AspiegelBot",
          "MobileBot": "Googlebot-Mobile|AdsBot-Google-Mobile|YahooSeeker/M1A1-R2D2",
          "DesktopMode": "WPDesktop",
          "TV": "SonyDTV|HbbTV",
          "WebKit": "(webkit)[ /]([\\w.]+)",
          "Console": "\\b(Nintendo|Nintendo WiiU|Nintendo 3DS|Nintendo Switch|PLAYSTATION|Xbox)\\b",
          "Watch": "SM-V700"
        }
      };
      impl.detectMobileBrowsers = {
        fullPattern: /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i,
        shortPattern: /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i,
        tabletPattern: /android|ipad|playbook|silk/i
      };
      var hasOwnProp = Object.prototype.hasOwnProperty, isArray2;
      impl.FALLBACK_PHONE = "UnknownPhone";
      impl.FALLBACK_TABLET = "UnknownTablet";
      impl.FALLBACK_MOBILE = "UnknownMobile";
      isArray2 = "isArray" in Array ? Array.isArray : function(value) {
        return Object.prototype.toString.call(value) === "[object Array]";
      };
      function equalIC(a3, b2) {
        return a3 != null && b2 != null && a3.toLowerCase() === b2.toLowerCase();
      }
      function containsIC(array, value) {
        var valueLC, i2, len = array.length;
        if (!len || !value) {
          return false;
        }
        valueLC = value.toLowerCase();
        for (i2 = 0; i2 < len; ++i2) {
          if (valueLC === array[i2].toLowerCase()) {
            return true;
          }
        }
        return false;
      }
      function convertPropsToRegExp(object) {
        for (var key in object) {
          if (hasOwnProp.call(object, key)) {
            object[key] = new RegExp(object[key], "i");
          }
        }
      }
      function prepareUserAgent(userAgent) {
        return (userAgent || "").substr(0, 500);
      }
      (function init() {
        var key, values, value, i2, len, verPos, mobileDetectRules = impl.mobileDetectRules;
        for (key in mobileDetectRules.props) {
          if (hasOwnProp.call(mobileDetectRules.props, key)) {
            values = mobileDetectRules.props[key];
            if (!isArray2(values)) {
              values = [values];
            }
            len = values.length;
            for (i2 = 0; i2 < len; ++i2) {
              value = values[i2];
              verPos = value.indexOf("[VER]");
              if (verPos >= 0) {
                value = value.substring(0, verPos) + "([\\w._\\+]+)" + value.substring(verPos + 5);
              }
              values[i2] = new RegExp(value, "i");
            }
            mobileDetectRules.props[key] = values;
          }
        }
        convertPropsToRegExp(mobileDetectRules.oss);
        convertPropsToRegExp(mobileDetectRules.phones);
        convertPropsToRegExp(mobileDetectRules.tablets);
        convertPropsToRegExp(mobileDetectRules.uas);
        convertPropsToRegExp(mobileDetectRules.utils);
        mobileDetectRules.oss0 = {
          WindowsPhoneOS: mobileDetectRules.oss.WindowsPhoneOS,
          WindowsMobileOS: mobileDetectRules.oss.WindowsMobileOS
        };
      })();
      impl.findMatch = function(rules, userAgent) {
        for (var key in rules) {
          if (hasOwnProp.call(rules, key)) {
            if (rules[key].test(userAgent)) {
              return key;
            }
          }
        }
        return null;
      };
      impl.findMatches = function(rules, userAgent) {
        var result2 = [];
        for (var key in rules) {
          if (hasOwnProp.call(rules, key)) {
            if (rules[key].test(userAgent)) {
              result2.push(key);
            }
          }
        }
        return result2;
      };
      impl.getVersionStr = function(propertyName, userAgent) {
        var props = impl.mobileDetectRules.props, patterns, i2, len, match5;
        if (hasOwnProp.call(props, propertyName)) {
          patterns = props[propertyName];
          len = patterns.length;
          for (i2 = 0; i2 < len; ++i2) {
            match5 = patterns[i2].exec(userAgent);
            if (match5 !== null) {
              return match5[1];
            }
          }
        }
        return null;
      };
      impl.getVersion = function(propertyName, userAgent) {
        var version2 = impl.getVersionStr(propertyName, userAgent);
        return version2 ? impl.prepareVersionNo(version2) : NaN;
      };
      impl.prepareVersionNo = function(version2) {
        var numbers;
        numbers = version2.split(/[a-z._ \/\-]/i);
        if (numbers.length === 1) {
          version2 = numbers[0];
        }
        if (numbers.length > 1) {
          version2 = numbers[0] + ".";
          numbers.shift();
          version2 += numbers.join("");
        }
        return Number(version2);
      };
      impl.isMobileFallback = function(userAgent) {
        return impl.detectMobileBrowsers.fullPattern.test(userAgent) || impl.detectMobileBrowsers.shortPattern.test(userAgent.substr(0, 4));
      };
      impl.isTabletFallback = function(userAgent) {
        return impl.detectMobileBrowsers.tabletPattern.test(userAgent);
      };
      impl.prepareDetectionCache = function(cache2, userAgent, maxPhoneWidth) {
        if (cache2.mobile !== undefined$12) {
          return;
        }
        var phone, tablet, phoneSized;
        tablet = impl.findMatch(impl.mobileDetectRules.tablets, userAgent);
        if (tablet) {
          cache2.mobile = cache2.tablet = tablet;
          cache2.phone = null;
          return;
        }
        phone = impl.findMatch(impl.mobileDetectRules.phones, userAgent);
        if (phone) {
          cache2.mobile = cache2.phone = phone;
          cache2.tablet = null;
          return;
        }
        if (impl.isMobileFallback(userAgent)) {
          phoneSized = MobileDetect2.isPhoneSized(maxPhoneWidth);
          if (phoneSized === undefined$12) {
            cache2.mobile = impl.FALLBACK_MOBILE;
            cache2.tablet = cache2.phone = null;
          } else if (phoneSized) {
            cache2.mobile = cache2.phone = impl.FALLBACK_PHONE;
            cache2.tablet = null;
          } else {
            cache2.mobile = cache2.tablet = impl.FALLBACK_TABLET;
            cache2.phone = null;
          }
        } else if (impl.isTabletFallback(userAgent)) {
          cache2.mobile = cache2.tablet = impl.FALLBACK_TABLET;
          cache2.phone = null;
        } else {
          cache2.mobile = cache2.tablet = cache2.phone = null;
        }
      };
      impl.mobileGrade = function(t) {
        var $isMobile = t.mobile() !== null;
        if (t.os("iOS") && t.version("iPad") >= 4.3 || t.os("iOS") && t.version("iPhone") >= 3.1 || t.os("iOS") && t.version("iPod") >= 3.1 || t.version("Android") > 2.1 && t.is("Webkit") || t.version("Windows Phone OS") >= 7 || t.is("BlackBerry") && t.version("BlackBerry") >= 6 || t.match("Playbook.*Tablet") || t.version("webOS") >= 1.4 && t.match("Palm|Pre|Pixi") || t.match("hp.*TouchPad") || t.is("Firefox") && t.version("Firefox") >= 12 || t.is("Chrome") && t.is("AndroidOS") && t.version("Android") >= 4 || t.is("Skyfire") && t.version("Skyfire") >= 4.1 && t.is("AndroidOS") && t.version("Android") >= 2.3 || t.is("Opera") && t.version("Opera Mobi") > 11 && t.is("AndroidOS") || t.is("MeeGoOS") || t.is("Tizen") || t.is("Dolfin") && t.version("Bada") >= 2 || (t.is("UC Browser") || t.is("Dolfin")) && t.version("Android") >= 2.3 || (t.match("Kindle Fire") || t.is("Kindle") && t.version("Kindle") >= 3) || t.is("AndroidOS") && t.is("NookTablet") || t.version("Chrome") >= 11 && !$isMobile || t.version("Safari") >= 5 && !$isMobile || t.version("Firefox") >= 4 && !$isMobile || t.version("MSIE") >= 7 && !$isMobile || t.version("Opera") >= 10 && !$isMobile) {
          return "A";
        }
        if (t.os("iOS") && t.version("iPad") < 4.3 || t.os("iOS") && t.version("iPhone") < 3.1 || t.os("iOS") && t.version("iPod") < 3.1 || t.is("Blackberry") && t.version("BlackBerry") >= 5 && t.version("BlackBerry") < 6 || t.version("Opera Mini") >= 5 && t.version("Opera Mini") <= 6.5 && (t.version("Android") >= 2.3 || t.is("iOS")) || t.match("NokiaN8|NokiaC7|N97.*Series60|Symbian/3") || t.version("Opera Mobi") >= 11 && t.is("SymbianOS")) {
          return "B";
        }
        if (t.version("BlackBerry") < 5 || t.match("MSIEMobile|Windows CE.*Mobile") || t.version("Windows Mobile") <= 5.2) {
          return "C";
        }
        return "C";
      };
      impl.detectOS = function(ua2) {
        return impl.findMatch(impl.mobileDetectRules.oss0, ua2) || impl.findMatch(impl.mobileDetectRules.oss, ua2);
      };
      impl.getDeviceSmallerSide = function() {
        return window.screen.width < window.screen.height ? window.screen.width : window.screen.height;
      };
      function MobileDetect2(userAgent, maxPhoneWidth) {
        this.ua = prepareUserAgent(userAgent);
        this._cache = {};
        this.maxPhoneWidth = maxPhoneWidth || 600;
      }
      MobileDetect2.prototype = {
        constructor: MobileDetect2,
        mobile: function() {
          impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
          return this._cache.mobile;
        },
        phone: function() {
          impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
          return this._cache.phone;
        },
        tablet: function() {
          impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
          return this._cache.tablet;
        },
        userAgent: function() {
          if (this._cache.userAgent === undefined$12) {
            this._cache.userAgent = impl.findMatch(impl.mobileDetectRules.uas, this.ua);
          }
          return this._cache.userAgent;
        },
        userAgents: function() {
          if (this._cache.userAgents === undefined$12) {
            this._cache.userAgents = impl.findMatches(impl.mobileDetectRules.uas, this.ua);
          }
          return this._cache.userAgents;
        },
        os: function() {
          if (this._cache.os === undefined$12) {
            this._cache.os = impl.detectOS(this.ua);
          }
          return this._cache.os;
        },
        version: function(key) {
          return impl.getVersion(key, this.ua);
        },
        versionStr: function(key) {
          return impl.getVersionStr(key, this.ua);
        },
        is: function(key) {
          return containsIC(this.userAgents(), key) || equalIC(key, this.os()) || equalIC(key, this.phone()) || equalIC(key, this.tablet()) || containsIC(impl.findMatches(impl.mobileDetectRules.utils, this.ua), key);
        },
        match: function(pattern2) {
          if (!(pattern2 instanceof RegExp)) {
            pattern2 = new RegExp(pattern2, "i");
          }
          return pattern2.test(this.ua);
        },
        isPhoneSized: function(maxPhoneWidth) {
          return MobileDetect2.isPhoneSized(maxPhoneWidth || this.maxPhoneWidth);
        },
        mobileGrade: function() {
          if (this._cache.grade === undefined$12) {
            this._cache.grade = impl.mobileGrade(this);
          }
          return this._cache.grade;
        }
      };
      if (typeof window !== "undefined" && window.screen) {
        MobileDetect2.isPhoneSized = function(maxPhoneWidth) {
          return maxPhoneWidth < 0 ? undefined$12 : impl.getDeviceSmallerSide() <= maxPhoneWidth;
        };
      } else {
        MobileDetect2.isPhoneSized = function() {
        };
      }
      MobileDetect2._impl = impl;
      MobileDetect2.version = "1.4.5 2021-03-13";
      return MobileDetect2;
    });
  })(function(undefined$12) {
    if (module.exports) {
      return function(factory) {
        module.exports = factory();
      };
    } else if (typeof undefined$12 === "function" && undefined$12.amd) {
      return undefined$12;
    } else if (typeof window !== "undefined") {
      return function(factory) {
        window.MobileDetect = factory();
      };
    } else {
      throw new Error("unknown environment");
    }
  }());
})(mobileDetect);
const MobileDetect = mobileDetect.exports;
function __isMobile(ua2 = navigator.userAgent) {
  const md2 = new MobileDetect(ua2);
  return md2.mobile() !== null;
}
function __isChildProcess() {
  return process.send !== void 0 || process.env.IS_CHILD_PROCESS !== void 0;
}
function __isColor(value) {
  try {
    const ele = document.createElement("div");
    ele.style.color = value;
    return ele.style.color.split(/\s+/).join("").toLowerCase() !== "";
  } catch (e) {
  }
  if (typeof value !== "string")
    return false;
  return value.match(/^#[a-zA-Z0-9]{3,6}$/) || value.match(/^rgba\([0-9]{1,3}(\s+)?,(\s+)?[0-9]{1,3}(\s+)?,(\s+)?[0-9]{1,3}(\s+)?,(\s+)?[0-9]{1,3}\)$/) || value.match(/^rgb\([0-9]{1,3}(\s+)?,(\s+)?[0-9]{1,3}(\s+)?,(\s+)?[0-9]{1,3}\)$/) || value.match(/^hsl\([0-9]{1,3}%?(\s+)?,(\s+)?[0-9]{1,3}%?(\s+)?,(\s+)?[0-9]{1,3}%?(\s+)?\)$/) || value.match(/^hsv\([0-9]{1,3}%?(\s+)?,(\s+)?[0-9]{1,3}%?(\s+)?,(\s+)?[0-9]{1,3}%?(\s+)?\)$/);
}
function __isCreditCard(value) {
  const re2 = /^(?:(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11}))$/;
  return re2.test(value);
}
function __isEmail(value) {
  const re2 = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  return re2.test(value.toLowerCase());
}
/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var isExtglob$1 = function isExtglob2(str2) {
  if (typeof str2 !== "string" || str2 === "") {
    return false;
  }
  var match5;
  while (match5 = /(\\).|([@?!+*]\(.*\))/g.exec(str2)) {
    if (match5[2])
      return true;
    str2 = str2.slice(match5.index + match5[0].length);
  }
  return false;
};
/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var isExtglob = isExtglob$1;
var chars = { "{": "}", "(": ")", "[": "]" };
var strictCheck = function(str2) {
  if (str2[0] === "!") {
    return true;
  }
  var index = 0;
  var pipeIndex = -2;
  var closeSquareIndex = -2;
  var closeCurlyIndex = -2;
  var closeParenIndex = -2;
  var backSlashIndex = -2;
  while (index < str2.length) {
    if (str2[index] === "*") {
      return true;
    }
    if (str2[index + 1] === "?" && /[\].+)]/.test(str2[index])) {
      return true;
    }
    if (closeSquareIndex !== -1 && str2[index] === "[" && str2[index + 1] !== "]") {
      if (closeSquareIndex < index) {
        closeSquareIndex = str2.indexOf("]", index);
      }
      if (closeSquareIndex > index) {
        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
          return true;
        }
        backSlashIndex = str2.indexOf("\\", index);
        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
          return true;
        }
      }
    }
    if (closeCurlyIndex !== -1 && str2[index] === "{" && str2[index + 1] !== "}") {
      closeCurlyIndex = str2.indexOf("}", index);
      if (closeCurlyIndex > index) {
        backSlashIndex = str2.indexOf("\\", index);
        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
          return true;
        }
      }
    }
    if (closeParenIndex !== -1 && str2[index] === "(" && str2[index + 1] === "?" && /[:!=]/.test(str2[index + 2]) && str2[index + 3] !== ")") {
      closeParenIndex = str2.indexOf(")", index);
      if (closeParenIndex > index) {
        backSlashIndex = str2.indexOf("\\", index);
        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
          return true;
        }
      }
    }
    if (pipeIndex !== -1 && str2[index] === "(" && str2[index + 1] !== "|") {
      if (pipeIndex < index) {
        pipeIndex = str2.indexOf("|", index);
      }
      if (pipeIndex !== -1 && str2[pipeIndex + 1] !== ")") {
        closeParenIndex = str2.indexOf(")", pipeIndex);
        if (closeParenIndex > pipeIndex) {
          backSlashIndex = str2.indexOf("\\", pipeIndex);
          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
            return true;
          }
        }
      }
    }
    if (str2[index] === "\\") {
      var open = str2[index + 1];
      index += 2;
      var close = chars[open];
      if (close) {
        var n = str2.indexOf(close, index);
        if (n !== -1) {
          index = n + 1;
        }
      }
      if (str2[index] === "!") {
        return true;
      }
    } else {
      index++;
    }
  }
  return false;
};
var relaxedCheck = function(str2) {
  if (str2[0] === "!") {
    return true;
  }
  var index = 0;
  while (index < str2.length) {
    if (/[*?{}()[\]]/.test(str2[index])) {
      return true;
    }
    if (str2[index] === "\\") {
      var open = str2[index + 1];
      index += 2;
      var close = chars[open];
      if (close) {
        var n = str2.indexOf(close, index);
        if (n !== -1) {
          index = n + 1;
        }
      }
      if (str2[index] === "!") {
        return true;
      }
    } else {
      index++;
    }
  }
  return false;
};
var isGlob = function isGlob2(str2, options) {
  if (typeof str2 !== "string" || str2 === "") {
    return false;
  }
  if (isExtglob(str2)) {
    return true;
  }
  var check = strictCheck;
  if (options && options.strict === false) {
    check = relaxedCheck;
  }
  return check(str2);
};
function __isGlob(string2) {
  return isGlob(string2);
}
function __isIsoDate(value) {
  return value.match(/^([0-9]{4})-(1[0-2]|0[1-9])$/) || value.match(/^([0-9]{4})-?(1[0-2]|0[1-9])-?(3[01]|0[1-9]|[12][0-9])$/) || value.match(/^([0-9]{4})(-?)(1[0-2]|0[1-9])\2(3[01]|0[1-9]|[12][0-9])$/) || value.match(/^([0-9]{4})-?(36[0-6]|3[0-5][0-9]|[12][0-9]{2}|0[1-9][0-9]|00[1-9])$/);
}
function __isIsoDateTime(value) {
  return value.match(/^([0-9]{4})-?(1[0-2]|0[1-9])-?(3[01]|0[1-9]|[12][0-9])↵\s(2[0-3]|[01][0-9]):?([0-5][0-9]):?([0-5][0-9])$/) || value.match(/^(?:([0-9]{4})-?(1[0-2]|0[1-9])-?(3[01]|0[1-9]|[12][0-9])\s(2[0-3]|[01][0-9]):?([0-5][0-9]):?([0-5][0-9])|([0-9]{4})(1[0-2]|0[1-9])(3[01]|0[1-9]|[12][0-9])\s(2[0-3]|[01][0-9])([0-5][0-9])([0-5][0-9]))$/);
}
function __isIsoTime(value) {
  return value.match(/^(2[0-3]|[01][0-9]):?([0-5][0-9])$/) || value.match(/^(2[0-3]|[01][0-9]):?([0-5][0-9]):?([0-5][0-9])$/) || value.match(/^(Z|[+-](?:2[0-3]|[01][0-9])(?::?(?:[0-5][0-9]))?)$/) || value.match(/^(2[0-3]|[01][0-9]):?([0-5][0-9]):?([0-5][0-9])(Z|[+-](?:2[0-3]|[01][0-9])(?::?(?:[0-5][0-9]))?)$/);
}
function __isNode() {
  return typeof process !== "undefined" && process.release && process.release.name === "node";
}
function __isOfType(value, typeString, settings = {}) {
  settings = Object.assign({ verbose: false }, settings);
  const typeInstance = new SType(typeString, settings);
  const res = typeInstance.is(value);
  return res;
}
function __isString(value) {
  return typeof value === "string" || value instanceof String;
}
var globToRegexp = function(glob, opts) {
  if (typeof glob !== "string") {
    throw new TypeError("Expected a string");
  }
  var str2 = String(glob);
  var reStr = "";
  var extended = opts ? !!opts.extended : false;
  var globstar = opts ? !!opts.globstar : false;
  var inGroup = false;
  var flags = opts && typeof opts.flags === "string" ? opts.flags : "";
  var c;
  for (var i2 = 0, len = str2.length; i2 < len; i2++) {
    c = str2[i2];
    switch (c) {
      case "/":
      case "$":
      case "^":
      case "+":
      case ".":
      case "(":
      case ")":
      case "=":
      case "!":
      case "|":
        reStr += "\\" + c;
        break;
      case "?":
        if (extended) {
          reStr += ".";
          break;
        }
      case "[":
      case "]":
        if (extended) {
          reStr += c;
          break;
        }
      case "{":
        if (extended) {
          inGroup = true;
          reStr += "(";
          break;
        }
      case "}":
        if (extended) {
          inGroup = false;
          reStr += ")";
          break;
        }
      case ",":
        if (inGroup) {
          reStr += "|";
          break;
        }
        reStr += "\\" + c;
        break;
      case "*":
        var prevChar = str2[i2 - 1];
        var starCount = 1;
        while (str2[i2 + 1] === "*") {
          starCount++;
          i2++;
        }
        var nextChar = str2[i2 + 1];
        if (!globstar) {
          reStr += ".*";
        } else {
          var isGlobstar = starCount > 1 && (prevChar === "/" || prevChar === void 0) && (nextChar === "/" || nextChar === void 0);
          if (isGlobstar) {
            reStr += "((?:[^/]*(?:/|$))*)";
            i2++;
          } else {
            reStr += "([^/]*)";
          }
        }
        break;
      default:
        reStr += c;
    }
  }
  if (!flags || !~flags.indexOf("g")) {
    reStr = "^" + reStr + "$";
  }
  return new RegExp(reStr, flags);
};
var __awaiter$v = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SEventEmitter$1 extends SClass {
  constructor(settings) {
    super(__deepMerge({
      asyncStart: false,
      bufferTimeout: 1e3,
      defaults: {},
      castByEvent: {
        log: SLog
      },
      bind: void 0
    }, settings !== null && settings !== void 0 ? settings : {}));
    this._asyncStarted = false;
    this._buffer = [];
    this._eventsStacks = {};
    this._onStackById = {};
  }
  static get global() {
    if (!SEventEmitter$1._globalInstance) {
      SEventEmitter$1._globalInstance = new SEventEmitter$1({
        metas: {
          id: "sugarEventSPromise"
        }
      });
    }
    return SEventEmitter$1._globalInstance;
  }
  static pipe(sourceSEventEmitter, destSEventEmitter, settings) {
    const set = Object.assign({ events: "*", overrideEmitter: false, processor: void 0, exclude: ["finally", "resolve", "reject", "cancel", "catch"], filter: void 0 }, settings !== null && settings !== void 0 ? settings : {});
    if (!sourceSEventEmitter || !sourceSEventEmitter.on || typeof sourceSEventEmitter.on !== "function") {
      return sourceSEventEmitter;
    }
    sourceSEventEmitter.on(set.events || "*", (value, metas) => __awaiter$v(this, void 0, void 0, function* () {
      var _a3, _b2, _c2, _d2, _e2, _f2, _g;
      if (!metas || !value) {
        return;
      }
      metas.id = (_c2 = (_a3 = metas.id) !== null && _a3 !== void 0 ? _a3 : (_b2 = metas.emitter.metas) === null || _b2 === void 0 ? void 0 : _b2.id) !== null && _c2 !== void 0 ? _c2 : __uniqid();
      metas.color = (_f2 = (_d2 = metas.color) !== null && _d2 !== void 0 ? _d2 : (_e2 = metas.emitter.metas) === null || _e2 === void 0 ? void 0 : _e2.color) !== null && _f2 !== void 0 ? _f2 : getColorFor(metas.id);
      if (set.exclude && set.exclude.indexOf(metas.event) !== -1)
        return;
      if (set.filter && !set.filter(value, metas))
        return;
      if (set.processor) {
        const res = set.processor(value, metas);
        if (Array.isArray(res) && res.length === 2) {
          value = res[0];
          metas = res[1];
        } else if (typeof res === "object" && res.value !== void 0 && res.metas !== void 0) {
          value = res.value;
          metas = res.metas;
        } else {
          value = res;
        }
      }
      if (metas && metas.event) {
        metas.event;
        if (!metas.emitter) {
          metas.emitter = this;
        }
        const emitMetas = Object.assign(Object.assign({}, metas), { level: ((_g = metas === null || metas === void 0 ? void 0 : metas.level) !== null && _g !== void 0 ? _g : 0) + 1 });
        if (destSEventEmitter instanceof SEventEmitter$1) {
          if (!set.overrideEmitter && destSEventEmitter.settings.bind) {
            emitMetas.emitter = destSEventEmitter.settings.bind;
          } else if (set.overrideEmitter === true) {
            emitMetas.emitter = destSEventEmitter;
          }
        }
        if (__isNode() && destSEventEmitter === process && __isChildProcess()) {
          if (value.value && value.value instanceof Error) {
            value.value = fn$3(value.value);
          }
          if (!this._ipcInstance._pipedEventsUids) {
            this._ipcInstance._pipedEventsUids = [];
          }
          if (this._ipcInstance && !this._ipcInstance._pipedEventsUids.includes(emitMetas.uid)) {
            this._ipcInstance._pipedEventsUids.push(emitMetas.uid);
            this._ipcInstance.of[`ipc-${process.ppid}`].emit("message", {
              value,
              metas: emitMetas
            });
          }
        } else {
          destSEventEmitter.emit(metas.event, value, emitMetas);
        }
      }
    }));
  }
  bind(obj2) {
    this.settings.bind = obj2;
    return this;
  }
  pipe(input, settings) {
    SEventEmitter$1.pipe(input, this, settings);
    return input;
  }
  pipeErrors(input, settings) {
    SEventEmitter$1.pipe(input, this, Object.assign(Object.assign({}, settings), { events: "error" }));
    return input;
  }
  pipeFrom(input, settings) {
    return this.pipe(input, settings);
  }
  pipeTo(dest, settings) {
    SEventEmitter$1.pipe(this, dest, settings);
    return this;
  }
  start() {
    if (!this.settings.asyncStart)
      return;
    this._asyncStarted = true;
    this._processBuffer();
  }
  _createMetas(event, metas = {}) {
    var _a3, _b2, _c2;
    return __deepMerge({
      event,
      name: event,
      emitter: (_b2 = (_a3 = this.settings.bind) !== null && _a3 !== void 0 ? _a3 : metas === null || metas === void 0 ? void 0 : metas.emitter) !== null && _b2 !== void 0 ? _b2 : this,
      originalEmitter: (_c2 = metas === null || metas === void 0 ? void 0 : metas.originalEmitter) !== null && _c2 !== void 0 ? _c2 : this,
      time: Date.now(),
      level: 0
    }, metas !== null && metas !== void 0 ? metas : {});
  }
  emit(event, value, metas) {
    return new Promise((resolve, reject) => __awaiter$v(this, void 0, void 0, function* () {
      let metasObj = this._createMetas(event, metas);
      const isFirstLevel = !metasObj.level;
      if (__isPlainObject(value)) {
        Object.keys(this.settings.defaults).forEach((key) => {
          var _a3;
          const parts = key.split(",").map((l) => l.trim());
          if (parts.indexOf(event) === -1 && parts.indexOf("*") === -1)
            return;
          value = __deepMerge(value, (_a3 = this.settings.defaults) === null || _a3 === void 0 ? void 0 : _a3[key]);
        });
      }
      const CastClass = this.settings.castByEvent[event];
      if (CastClass && isClass$1(CastClass) && !(value instanceof CastClass) && !value._sEventEmitterPreprocessed) {
        value = new CastClass(value);
      }
      if (event === "ask") {
        if (isFirstLevel) {
          metasObj.askId = __uniqid();
        }
      }
      if (!this._asyncStarted && this.settings.asyncStart) {
        this._buffer.push({
          event,
          value,
          metas: metasObj,
          resolve,
          reject
        });
        return;
      }
      this._emit({
        event,
        value,
        metas: metasObj,
        resolve,
        reject
      });
    }));
  }
  _emit(logObj) {
    return __awaiter$v(this, void 0, void 0, function* () {
      logObj.metas.uid = __uniqid();
      if (logObj.event === "ask") {
        this.constructor.global.on(`answer.${logObj.metas.askId}`, (answer, metas) => {
          logObj.resolve(answer);
        });
        this._emitEvents(logObj.event, logObj.value, Object.assign({}, logObj.metas));
      } else {
        const res = yield this._emitEvents(logObj.event, logObj.value, Object.assign({}, logObj.metas));
        logObj.resolve(res);
      }
    });
  }
  _registerNewEventsStacks(events) {
    if (typeof events === "string")
      events = events.split(",").map((s2) => s2.trim());
    events.forEach((event) => {
      if (!this._eventsStacks[event]) {
        this._eventsStacks[event] = {
          buffer: [],
          callStack: []
        };
      }
    });
  }
  _registerCallbackInEventStack(event, callback, settings = {}) {
    settings = Object.assign({ callNumber: void 0, filter: void 0, processor: void 0, id: void 0 }, settings);
    if (settings.id) {
      if (!this._onStackById[settings.id])
        this._onStackById[settings.id] = [];
      this._onStackById[settings.id].push({
        event,
        callback,
        settings
      });
    }
    if (!this._eventsStacks[event]) {
      this._registerNewEventsStacks(event);
    }
    const eventStackObj = this._eventsStacks[event];
    let callNumber = settings.callNumber;
    if (callNumber === void 0) {
      callNumber = -1;
    }
    if (typeof callback === "function")
      eventStackObj.callStack.push({
        callback,
        callNumber,
        filter: settings.filter,
        processor: settings.processor,
        called: 0
      });
    this._processBuffer();
    return this;
  }
  _processBuffer() {
    if (this._buffer.length > 0) {
      setTimeout(() => {
        this._buffer = this._buffer.filter((item) => {
          this._emit(item);
          return false;
        });
      }, this.settings.bufferTimeout);
    }
  }
  _emitEventStack(event, initialValue, metasObj) {
    return __awaiter$v(this, void 0, void 0, function* () {
      let currentCallbackReturnedValue = initialValue;
      if (!this._eventsStacks || Object.keys(this._eventsStacks).length === 0)
        return currentCallbackReturnedValue;
      if (!this._eventsStacks[event]) {
        this._registerNewEventsStacks(event);
      }
      let eventStackArray = [];
      const eventStackObj = this._eventsStacks[event];
      if (eventStackObj && eventStackObj.callStack) {
        eventStackArray = [
          ...eventStackArray,
          ...eventStackObj.callStack
        ];
      }
      Object.keys(this._eventsStacks).forEach((stackName) => {
        if (stackName === event)
          return currentCallbackReturnedValue;
        if (globToRegexp(stackName).test(event) && this._eventsStacks[stackName] !== void 0) {
          eventStackArray = [
            ...eventStackArray,
            ...this._eventsStacks[stackName].callStack
          ];
        }
      });
      eventStackArray.map((item) => item.called++);
      eventStackArray = eventStackArray.filter((item) => {
        if (item.callNumber === -1)
          return true;
        if (item.called <= item.callNumber)
          return true;
        return false;
      });
      for (let i2 = 0; i2 < eventStackArray.length; i2++) {
        const item = eventStackArray[i2];
        if (!item.callback)
          return currentCallbackReturnedValue;
        if (item.filter && !item.filter(currentCallbackReturnedValue, metasObj))
          continue;
        if (item.processor) {
          const res = item.processor(currentCallbackReturnedValue, metasObj);
          if (Array.isArray(res) && res.length === 2) {
            currentCallbackReturnedValue = res[0];
            metasObj = res[1];
          } else if (typeof res === "object" && res.value !== void 0 && res.metas !== void 0) {
            currentCallbackReturnedValue = res.value;
            metasObj = res.metas;
          } else {
            currentCallbackReturnedValue = res;
          }
        }
        const callbackResult = yield item.callback(currentCallbackReturnedValue, metasObj, (metasObj === null || metasObj === void 0 ? void 0 : metasObj.askId) ? (answer) => {
          this.constructor.global.emit(`answer.${metasObj.askId}`, answer, metasObj);
        } : void 0);
        if (callbackResult !== void 0) {
          currentCallbackReturnedValue = callbackResult;
        }
      }
      return currentCallbackReturnedValue;
    });
  }
  _emitEvents(events, initialValue, metas) {
    return new Promise((resolve, reject) => __awaiter$v(this, void 0, void 0, function* () {
      if (!events)
        return this;
      if (typeof events === "string")
        events = events.split(",").map((s2) => s2.trim());
      let currentStackResult = initialValue;
      for (let i2 = 0; i2 < events.length; i2++) {
        const stackResult = yield this._emitEventStack(events[i2], currentStackResult, metas);
        if (stackResult !== void 0) {
          currentStackResult = stackResult;
        }
      }
      resolve(currentStackResult);
    }));
  }
  on(events, callback, settings) {
    const set = __deepMerge({
      filter: void 0,
      processor: void 0,
      id: void 0
    }, settings);
    if (typeof events === "string")
      events = events.split(",").map((s2) => s2.trim());
    events.forEach((name2) => {
      const splitedName = name2.split(":");
      let callNumber = -1;
      if (splitedName.length === 2) {
        name2 = splitedName[0];
        callNumber = parseInt(splitedName[1]);
      }
      this._registerCallbackInEventStack(name2, callback, {
        callNumber,
        filter: set.filter,
        processor: set.processor,
        id: set.id
      });
    });
    return this;
  }
  off(event, callback) {
    if (!callback) {
      if (this._eventsStacks[event]) {
        delete this._eventsStacks[event];
      } else if (this._onStackById[event]) {
        this._onStackById[event].forEach((onStackByIdObj) => {
          this.off(onStackByIdObj.event, onStackByIdObj.callback);
        });
        delete this._onStackById[event];
      }
      return this;
    }
    const eventStackObj = this._eventsStacks[event];
    if (!eventStackObj)
      return this;
    eventStackObj.callStack = eventStackObj.callStack.filter((item) => {
      if (item.callback === callback)
        return false;
      return true;
    });
    this._eventsStacks[event] = eventStackObj;
    return this;
  }
  destroy() {
    this._eventsStacks = {};
  }
}
SEventEmitter$1.usableAsMixin = true;
class SEventEmitter extends SEventEmitter$1 {
}
function __convertTime(from2, to2 = "ms") {
  let fromMs = from2;
  if (typeof from2 === "string") {
    const fromNumber = parseFloat(from2);
    const fromLength = fromNumber.toString().length;
    const fromString2 = from2.slice(fromLength);
    if (fromString2 === "ms" || fromString2 === "millisecond" || fromString2 === "milliseconds") {
      fromMs = fromNumber;
    } else if (fromString2 === "s" || fromString2 === "second" || fromString2 === "seconds") {
      fromMs = fromNumber * 1e3;
    } else if (fromString2 === "m" || fromString2 === "minute" || fromString2 === "minutes") {
      fromMs = fromNumber * 60 * 1e3;
    } else if (fromString2 === "h" || fromString2 === "hour" || fromString2 === "hours") {
      fromMs = fromNumber * 60 * 60 * 1e3;
    } else if (fromString2 === "d" || fromString2 === "day" || fromString2 === "days") {
      fromMs = fromNumber * 24 * 60 * 60 * 1e3;
    } else if (fromString2 === "w" || fromString2 === "week" || fromString2 === "weeks") {
      fromMs = fromNumber * 7 * 24 * 60 * 60 * 1e3;
    } else if (fromString2 === "month" || fromString2 === "months") {
      fromMs = fromNumber * 31 * 24 * 60 * 60 * 1e3;
    } else if (fromString2 === "y" || fromString2 === "year" || fromString2 === "years") {
      fromMs = fromNumber * 365 * 24 * 60 * 60 * 1e3;
    }
  }
  switch (to2) {
    case "ms":
    case "millisecond":
    case "milliseconds":
      return fromMs;
    case "s":
    case "second":
    case "seconds":
      return fromMs / 1e3;
    case "m":
    case "minute":
    case "minutes":
      return fromMs / 1e3 / 60;
    case "h":
    case "hour":
    case "hours":
      return fromMs / 1e3 / 60 / 60;
    case "d":
    case "day":
    case "days":
      return fromMs / 1e3 / 60 / 60 / 24;
    case "w":
    case "week":
    case "weeks":
      return fromMs / 1e3 / 60 / 60 / 24 / 7;
    case "month":
    case "months":
      return fromMs / 1e3 / 60 / 60 / 24 / 31;
    case "y":
    case "year":
    case "years":
      return fromMs / 1e3 / 60 / 60 / 24 / 365;
    default:
      throw new Error(`You try to convert "${from2}" to "${to2}" but this format does not exist... The valids formats are "ms,s,m,h,d,w,month,y"...`);
  }
}
__convertTime.MILLISECOND = "ms";
__convertTime.SECOND = "s";
__convertTime.MINUTE = "m";
__convertTime.HOUR = "h";
__convertTime.DAY = "d";
__convertTime.WEEK = "w";
__convertTime.MONTH = "month";
__convertTime.YEAR = "y";
function __wait(timeout = 0) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, timeout);
  });
}
const fn = function treatAsValue(promise, settings = {}) {
  settings = Object.assign({ during: -1 }, settings);
  let during = settings.during || -1;
  try {
    const proxy = Proxy.revocable(promise, {
      get(target, prop, receiver) {
        if (prop === "then") {
          return target;
        }
        if (during > 0)
          during--;
        else if (during === 0) {
          proxy.revoke();
        }
        return Reflect.get(...arguments);
      }
    });
    proxy.proxy.restorePromiseBehavior = () => {
      proxy.revoke();
      return promise;
    };
    return proxy.proxy;
  } catch (e) {
    return promise;
  }
};
var __awaiter$u = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SPromise extends SClass.extends(Promise) {
  constructor(executorFnOrSettings = {}, settings) {
    var _a3;
    let executorFn, resolvers = {};
    super(__deepMerge({
      promise: {
        treatCancelAs: "resolve",
        destroyTimeout: 1,
        preventRejectOnThrow: false,
        emitLogErrorEventOnThrow: true,
        resolveAtResolveEvent: false,
        rejectAtRejectEvent: false,
        resolveProxies: [],
        rejectProxies: []
      }
    }, typeof executorFnOrSettings === "object" ? executorFnOrSettings : {}, settings !== null && settings !== void 0 ? settings : {}), (resolve, reject) => {
      resolvers.resolve = resolve;
      new Promise((rejectPromiseResolve, rejectPromiseReject) => {
        resolvers.reject = (...args) => {
          rejectPromiseReject(...args);
          if (this.promiseSettings.preventRejectOnThrow) {
            resolve(...args);
          } else {
            reject(...args);
          }
        };
      }).catch((e) => {
        this.emit("catch", e);
      });
    });
    this._promiseState = "pending";
    this._eventEmitter = new SEventEmitter(__deepMerge({
      metas: Object.assign({}, this.metas)
    }, (_a3 = this.settings.eventEmitter) !== null && _a3 !== void 0 ? _a3 : {}));
    this.expose(this._eventEmitter, {
      as: "eventEmitter",
      props: [
        "on",
        "off",
        "emit",
        "pipe",
        "pipeErrors",
        "pipeFrom",
        "pipeTo"
      ]
    });
    this.bind = this._eventEmitter.bind.bind(this);
    this._resolvers = resolvers;
    if (this.promiseSettings.destroyTimeout !== -1) {
      this.on("finally", (v, m2) => {
        setTimeout(() => {
          this.destroy();
        }, this.promiseSettings.destroyTimeout);
      });
    }
    executorFn = typeof executorFnOrSettings === "function" ? executorFnOrSettings : null;
    if (executorFn) {
      const api = {};
      __getMethods(this).forEach((func) => {
        if (func.slice(0, 1) === "_")
          return;
        api[func] = this[func].bind(this);
      });
      (() => __awaiter$u(this, void 0, void 0, function* () {
        yield __wait(0);
        try {
          yield executorFn(api);
        } catch (e) {
          if (this.promiseSettings.emitLogErrorEventOnThrow) {
            this.emit("log", {
              type: SLog.TYPE_ERROR,
              value: e
            });
          }
          this.reject(e);
        }
      }))();
    }
    if (this.promiseSettings.resolveAtResolveEvent) {
      this.on("resolve", (data2, metas) => {
        this.resolve(data2);
      });
    }
    if (this.promiseSettings.rejectAtRejectEvent) {
      this.on("reject", (data2, metas) => {
        this.reject(data2);
      });
    }
  }
  static queue(promises, before, after) {
    return new SPromise(({ resolve, reject, pipe }) => __awaiter$u(this, void 0, void 0, function* () {
      const results = {};
      function next() {
        return __awaiter$u(this, void 0, void 0, function* () {
          const firstKey = Object.keys(promises)[0];
          let promise = promises[firstKey];
          if (typeof promise === "function")
            promise = promise();
          try {
            delete promises[firstKey];
            if (before)
              yield before(firstKey, promise);
            if (promise instanceof SPromise) {
              pipe(promise);
            }
            let res = yield promise;
            results[firstKey] = res;
            if (after) {
              let afterRes = yield after(firstKey, result);
              if (afterRes !== void 0)
                result[firstKey] = afterRes;
            }
            if (Object.keys(promises).length) {
              next();
            } else {
              resolve(results);
            }
          } catch (e) {
            reject(promise);
          }
        });
      }
      next();
    }));
  }
  static treatAsValue(promise, settings = {}) {
    return fn(promise, settings);
  }
  get promiseSettings() {
    var _a3;
    return (_a3 = this.settings.promise) !== null && _a3 !== void 0 ? _a3 : this.settings;
  }
  static get [Symbol.species]() {
    return Promise;
  }
  get [Symbol.toStringTag]() {
    return "SPromise";
  }
  get promiseState() {
    return this._promiseState;
  }
  treatAsValue(settings = {}) {
    return fn(this, settings);
  }
  registerProxy(point, proxy) {
    const ar2 = point.split(",").map((l) => l.trim());
    ar2.forEach((a3) => {
      if (a3 === "resolve") {
        this.settings.promise.resolveProxies.push(proxy);
      } else if (a3 === "reject") {
        this.settings.promise.rejectProxies.push(proxy);
      }
    });
  }
  is(status) {
    const statusArray = status.split(",").map((l) => l.trim());
    if (statusArray.indexOf(this._promiseState) !== -1)
      return true;
    return false;
  }
  isPending() {
    return this._promiseState === "pending";
  }
  isResolved() {
    return this._promiseState === "resolved";
  }
  isRejected() {
    return this._promiseState === "rejected";
  }
  isCanceled() {
    return this._promiseState === "canceled";
  }
  isDestroyed() {
    return this._promiseState === "destroyed";
  }
  resolve(arg, stacksOrder = "resolve,finally") {
    return this._resolve(arg, stacksOrder);
  }
  _resolve(arg, stacksOrder = "resolve,finally") {
    return __awaiter$u(this, void 0, void 0, function* () {
      if (this._promiseState === "destroyed")
        return;
      this._promiseState = "resolved";
      const stacksOrderArray = stacksOrder.split(",").map((l) => l.trim());
      for (let i2 = 0; i2 < stacksOrderArray.length; i2++) {
        const stack = stacksOrderArray[i2];
        arg = yield this.eventEmitter.emit(stack, arg);
      }
      for (const proxyFn of this.settings.promise.resolveProxies || []) {
        arg = yield proxyFn(arg);
      }
      this._resolvers.resolve(arg);
      return arg;
    });
  }
  reject(arg, stacksOrder = `catch,reject,finally`) {
    return this._reject(arg, stacksOrder);
  }
  _reject(arg, stacksOrder = `catch,reject,finally`) {
    return __awaiter$u(this, void 0, void 0, function* () {
      if (this._promiseState === "destroyed")
        return;
      this._promiseState = "rejected";
      const stacksOrderArray = stacksOrder.split(",").map((l) => l.trim());
      for (let i2 = 0; i2 < stacksOrderArray.length; i2++) {
        const stack = stacksOrderArray[i2];
        arg = yield this.eventEmitter.emit(stack, arg);
      }
      for (const proxyFn of this.settings.promise.rejectProxies || []) {
        arg = yield proxyFn(arg);
      }
      this._resolvers.reject(arg);
      return arg;
    });
  }
  cancel(arg, stacksOrder = "cancel,finally") {
    return this._cancel(arg, stacksOrder);
  }
  _cancel(arg, stacksOrder = "cancel,finally") {
    if (this._promiseState === "destroyed")
      return;
    return new Promise((resolve, reject) => __awaiter$u(this, void 0, void 0, function* () {
      this._promiseState = "canceled";
      const stacksOrderArray = stacksOrder.split(",").map((l) => l.trim());
      for (let i2 = 0; i2 < stacksOrderArray.length; i2++) {
        const stack = stacksOrderArray[i2];
        arg = yield this.eventEmitter.emit(stack, arg);
      }
      if (this.settings.promise.treatCancelAs === "reject") {
        this._resolvers.reject(arg);
      } else {
        this._resolvers.resolve(arg);
      }
      resolve(arg);
    }));
  }
  catch(...args) {
    super.catch(...args);
    return this.on("catch", ...args);
  }
  finally(...args) {
    return this.on("finally", ...args);
  }
  destroy() {
    this._eventEmitter.destroy();
    this._promiseState = "destroyed";
  }
}
function autoCast(string) {
  if (typeof string !== "string")
    return string;
  if (string.substr(0, 1) === "'" && string.substr(-1) === "'") {
    return string.substr(1, string.length - 2);
  }
  const presumedNumber = parseFloat(string);
  if (!isNaN(presumedNumber)) {
    if (presumedNumber.toString() === string) {
      return presumedNumber;
    }
  }
  try {
    if (window[string]) {
      return string;
    }
  } catch (e) {
  }
  try {
    const obj = eval(`(${string})`);
    return obj;
  } catch (e) {
    return string;
  }
}
function parseSingleTypeString(typeString) {
  let ofStr = "", typeStr = typeString, ofTypes = [];
  if (typeStr.match(/^['"`]/)) {
    return {
      type: "string",
      of: void 0,
      value: typeStr.replace(/^['"`]/, "").replace(/['"`]$/, "")
    };
  }
  const autoCastedValue = autoCast(typeStr);
  if (typeof autoCastedValue === "number") {
    return {
      type: "number",
      of: void 0,
      value: autoCastedValue
    };
  }
  typeStr = typeStr.trim().replace(/^([a-zA-Z0-9-_]+)\[\]$/, "array<$1>");
  const ofPartsString = typeStr.match(/<(.+)>$/gm);
  if (ofPartsString && ofPartsString.length) {
    ofStr = ofPartsString[0].replace("<", "").replace(">", "");
  }
  if (ofStr !== "") {
    typeStr = typeStr.replace(`<${ofStr}>`, "");
  }
  ofTypes = ofStr !== "" ? [ofStr] : void 0;
  if (ofStr !== void 0 && ofStr.includes("|")) {
    ofTypes = ofStr.split("|").map((t) => t.trim());
  }
  const result2 = {
    type: typeStr,
    of: ofTypes
  };
  Object.defineProperty(result2, "toString", {
    get() {
      return () => typeString;
    }
  });
  return result2;
}
function __parseTypeString(typeString) {
  const originalTypeString = typeString;
  typeString = typeString.trim();
  typeString = typeString.replace(/^\{/, "").replace(/\}$/, "");
  let isArray2 = false;
  if (typeString.match(/\)\[\]$/)) {
    isArray2 = true;
    typeString = typeString.replace(/\)\[\]$/, "").replace(/^\(/, "");
  }
  const firstTypes = [];
  let inSubLevel = 0, typeStr = "", areSubLevels = false;
  for (let i2 = 0; i2 < typeString.length; i2++) {
    const char = typeString[i2];
    if (["(", "<"].includes(char)) {
      inSubLevel++;
      areSubLevels = true;
      typeStr += "^";
    } else if ([")", ">"].includes(char)) {
      inSubLevel--;
      typeStr += "$";
    } else if (char === "|" && inSubLevel === 0) {
      firstTypes.push({
        areSubLevels,
        type: typeStr
      });
      typeStr = "";
    } else {
      typeStr += char;
    }
    if (inSubLevel < 0) {
      throw new Error(`It seems that your type string "${typeString}" is not valid...`);
    }
  }
  firstTypes.push({
    areSubLevels,
    type: typeStr
  });
  let finalTypes = [];
  firstTypes.forEach((type) => {
    if (type.areSubLevels) {
      finalTypes = [...finalTypes, ...__parseTypeString(type.type)];
    } else {
      finalTypes.push(parseSingleTypeString(type.type.replace("^", "<").replace("$", ">")));
    }
  });
  if (isArray2) {
    const result2 = [
      {
        type: "array",
        of: finalTypes
      }
    ];
    result2.__proto__.toString = () => originalTypeString;
    return result2;
  }
  finalTypes = __deepMap(finalTypes, ({ object, prop, value, path: path2 }) => {
    if (typeof value === "string") {
      value = value.replace(/^\./, "").trim();
    }
    return value;
  });
  Object.defineProperty(finalTypes, "toString", {
    get() {
      return () => originalTypeString;
    }
  });
  return finalTypes;
}
function __decodeHtmlEntities(string2) {
  const txt = document.createElement("textarea");
  txt.innerHTML = string2;
  return txt.value;
}
var __assign$6 = function() {
  __assign$6 = Object.assign || function __assign2(t) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p))
          t[p] = s2[p];
    }
    return t;
  };
  return __assign$6.apply(this, arguments);
};
function lowerCase(str2) {
  return str2.toLowerCase();
}
var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
function noCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  var _a3 = options.splitRegexp, splitRegexp = _a3 === void 0 ? DEFAULT_SPLIT_REGEXP : _a3, _b2 = options.stripRegexp, stripRegexp = _b2 === void 0 ? DEFAULT_STRIP_REGEXP : _b2, _c2 = options.transform, transform = _c2 === void 0 ? lowerCase : _c2, _d2 = options.delimiter, delimiter = _d2 === void 0 ? " " : _d2;
  var result2 = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
  var start = 0;
  var end = result2.length;
  while (result2.charAt(start) === "\0")
    start++;
  while (result2.charAt(end - 1) === "\0")
    end--;
  return result2.slice(start, end).split("\0").map(transform).join(delimiter);
}
function replace(input, re2, value) {
  if (re2 instanceof RegExp)
    return input.replace(re2, value);
  return re2.reduce(function(input2, re3) {
    return input2.replace(re3, value);
  }, input);
}
function dotCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  return noCase(input, __assign$6({ delimiter: "." }, options));
}
function paramCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  return dotCase(input, __assign$6({ delimiter: "-" }, options));
}
function __dashCase(text) {
  return paramCase(text);
}
var toRegex$1 = { exports: {} };
var lib = { exports: {} };
var util$1 = {};
var types$4 = {
  ROOT: 0,
  GROUP: 1,
  POSITION: 2,
  SET: 3,
  RANGE: 4,
  REPETITION: 5,
  REFERENCE: 6,
  CHAR: 7
};
var sets$1 = {};
var types$3 = types$4;
var INTS = function() {
  return [{ type: types$3.RANGE, from: 48, to: 57 }];
};
var WORDS = function() {
  return [
    { type: types$3.CHAR, value: 95 },
    { type: types$3.RANGE, from: 97, to: 122 },
    { type: types$3.RANGE, from: 65, to: 90 }
  ].concat(INTS());
};
var WHITESPACE = function() {
  return [
    { type: types$3.CHAR, value: 9 },
    { type: types$3.CHAR, value: 10 },
    { type: types$3.CHAR, value: 11 },
    { type: types$3.CHAR, value: 12 },
    { type: types$3.CHAR, value: 13 },
    { type: types$3.CHAR, value: 32 },
    { type: types$3.CHAR, value: 160 },
    { type: types$3.CHAR, value: 5760 },
    { type: types$3.CHAR, value: 6158 },
    { type: types$3.CHAR, value: 8192 },
    { type: types$3.CHAR, value: 8193 },
    { type: types$3.CHAR, value: 8194 },
    { type: types$3.CHAR, value: 8195 },
    { type: types$3.CHAR, value: 8196 },
    { type: types$3.CHAR, value: 8197 },
    { type: types$3.CHAR, value: 8198 },
    { type: types$3.CHAR, value: 8199 },
    { type: types$3.CHAR, value: 8200 },
    { type: types$3.CHAR, value: 8201 },
    { type: types$3.CHAR, value: 8202 },
    { type: types$3.CHAR, value: 8232 },
    { type: types$3.CHAR, value: 8233 },
    { type: types$3.CHAR, value: 8239 },
    { type: types$3.CHAR, value: 8287 },
    { type: types$3.CHAR, value: 12288 },
    { type: types$3.CHAR, value: 65279 }
  ];
};
var NOTANYCHAR = function() {
  return [
    { type: types$3.CHAR, value: 10 },
    { type: types$3.CHAR, value: 13 },
    { type: types$3.CHAR, value: 8232 },
    { type: types$3.CHAR, value: 8233 }
  ];
};
sets$1.words = function() {
  return { type: types$3.SET, set: WORDS(), not: false };
};
sets$1.notWords = function() {
  return { type: types$3.SET, set: WORDS(), not: true };
};
sets$1.ints = function() {
  return { type: types$3.SET, set: INTS(), not: false };
};
sets$1.notInts = function() {
  return { type: types$3.SET, set: INTS(), not: true };
};
sets$1.whitespace = function() {
  return { type: types$3.SET, set: WHITESPACE(), not: false };
};
sets$1.notWhitespace = function() {
  return { type: types$3.SET, set: WHITESPACE(), not: true };
};
sets$1.anyChar = function() {
  return { type: types$3.SET, set: NOTANYCHAR(), not: true };
};
(function(exports) {
  var types2 = types$4;
  var sets2 = sets$1;
  var CTRL = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?";
  var SLSH = { "0": 0, "t": 9, "n": 10, "v": 11, "f": 12, "r": 13 };
  exports.strToChars = function(str2) {
    var chars_regex = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z\[\\\]\^?])|([0tnvfr]))/g;
    str2 = str2.replace(chars_regex, function(s2, b2, lbs, a16, b16, c8, dctrl, eslsh) {
      if (lbs) {
        return s2;
      }
      var code3 = b2 ? 8 : a16 ? parseInt(a16, 16) : b16 ? parseInt(b16, 16) : c8 ? parseInt(c8, 8) : dctrl ? CTRL.indexOf(dctrl) : SLSH[eslsh];
      var c = String.fromCharCode(code3);
      if (/[\[\]{}\^$.|?*+()]/.test(c)) {
        c = "\\" + c;
      }
      return c;
    });
    return str2;
  };
  exports.tokenizeClass = function(str2, regexpStr) {
    var tokens = [];
    var regexp = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(?:\\)?([^\]]))|(\])|(?:\\)?(.)/g;
    var rs2, c;
    while ((rs2 = regexp.exec(str2)) != null) {
      if (rs2[1]) {
        tokens.push(sets2.words());
      } else if (rs2[2]) {
        tokens.push(sets2.ints());
      } else if (rs2[3]) {
        tokens.push(sets2.whitespace());
      } else if (rs2[4]) {
        tokens.push(sets2.notWords());
      } else if (rs2[5]) {
        tokens.push(sets2.notInts());
      } else if (rs2[6]) {
        tokens.push(sets2.notWhitespace());
      } else if (rs2[7]) {
        tokens.push({
          type: types2.RANGE,
          from: (rs2[8] || rs2[9]).charCodeAt(0),
          to: rs2[10].charCodeAt(0)
        });
      } else if (c = rs2[12]) {
        tokens.push({
          type: types2.CHAR,
          value: c.charCodeAt(0)
        });
      } else {
        return [tokens, regexp.lastIndex];
      }
    }
    exports.error(regexpStr, "Unterminated character class");
  };
  exports.error = function(regexp, msg) {
    throw new SyntaxError("Invalid regular expression: /" + regexp + "/: " + msg);
  };
})(util$1);
var positions$1 = {};
var types$2 = types$4;
positions$1.wordBoundary = function() {
  return { type: types$2.POSITION, value: "b" };
};
positions$1.nonWordBoundary = function() {
  return { type: types$2.POSITION, value: "B" };
};
positions$1.begin = function() {
  return { type: types$2.POSITION, value: "^" };
};
positions$1.end = function() {
  return { type: types$2.POSITION, value: "$" };
};
var util = util$1;
var types$1 = types$4;
var sets = sets$1;
var positions = positions$1;
lib.exports = function(regexpStr) {
  var i2 = 0, l, c, start = { type: types$1.ROOT, stack: [] }, lastGroup = start, last = start.stack, groupStack = [];
  var repeatErr = function(i3) {
    util.error(regexpStr, "Nothing to repeat at column " + (i3 - 1));
  };
  var str2 = util.strToChars(regexpStr);
  l = str2.length;
  while (i2 < l) {
    c = str2[i2++];
    switch (c) {
      case "\\":
        c = str2[i2++];
        switch (c) {
          case "b":
            last.push(positions.wordBoundary());
            break;
          case "B":
            last.push(positions.nonWordBoundary());
            break;
          case "w":
            last.push(sets.words());
            break;
          case "W":
            last.push(sets.notWords());
            break;
          case "d":
            last.push(sets.ints());
            break;
          case "D":
            last.push(sets.notInts());
            break;
          case "s":
            last.push(sets.whitespace());
            break;
          case "S":
            last.push(sets.notWhitespace());
            break;
          default:
            if (/\d/.test(c)) {
              last.push({ type: types$1.REFERENCE, value: parseInt(c, 10) });
            } else {
              last.push({ type: types$1.CHAR, value: c.charCodeAt(0) });
            }
        }
        break;
      case "^":
        last.push(positions.begin());
        break;
      case "$":
        last.push(positions.end());
        break;
      case "[":
        var not2;
        if (str2[i2] === "^") {
          not2 = true;
          i2++;
        } else {
          not2 = false;
        }
        var classTokens = util.tokenizeClass(str2.slice(i2), regexpStr);
        i2 += classTokens[1];
        last.push({
          type: types$1.SET,
          set: classTokens[0],
          not: not2
        });
        break;
      case ".":
        last.push(sets.anyChar());
        break;
      case "(":
        var group = {
          type: types$1.GROUP,
          stack: [],
          remember: true
        };
        c = str2[i2];
        if (c === "?") {
          c = str2[i2 + 1];
          i2 += 2;
          if (c === "=") {
            group.followedBy = true;
          } else if (c === "!") {
            group.notFollowedBy = true;
          } else if (c !== ":") {
            util.error(
              regexpStr,
              "Invalid group, character '" + c + "' after '?' at column " + (i2 - 1)
            );
          }
          group.remember = false;
        }
        last.push(group);
        groupStack.push(lastGroup);
        lastGroup = group;
        last = group.stack;
        break;
      case ")":
        if (groupStack.length === 0) {
          util.error(regexpStr, "Unmatched ) at column " + (i2 - 1));
        }
        lastGroup = groupStack.pop();
        last = lastGroup.options ? lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;
        break;
      case "|":
        if (!lastGroup.options) {
          lastGroup.options = [lastGroup.stack];
          delete lastGroup.stack;
        }
        var stack = [];
        lastGroup.options.push(stack);
        last = stack;
        break;
      case "{":
        var rs2 = /^(\d+)(,(\d+)?)?\}/.exec(str2.slice(i2)), min2, max2;
        if (rs2 !== null) {
          if (last.length === 0) {
            repeatErr(i2);
          }
          min2 = parseInt(rs2[1], 10);
          max2 = rs2[2] ? rs2[3] ? parseInt(rs2[3], 10) : Infinity : min2;
          i2 += rs2[0].length;
          last.push({
            type: types$1.REPETITION,
            min: min2,
            max: max2,
            value: last.pop()
          });
        } else {
          last.push({
            type: types$1.CHAR,
            value: 123
          });
        }
        break;
      case "?":
        if (last.length === 0) {
          repeatErr(i2);
        }
        last.push({
          type: types$1.REPETITION,
          min: 0,
          max: 1,
          value: last.pop()
        });
        break;
      case "+":
        if (last.length === 0) {
          repeatErr(i2);
        }
        last.push({
          type: types$1.REPETITION,
          min: 1,
          max: Infinity,
          value: last.pop()
        });
        break;
      case "*":
        if (last.length === 0) {
          repeatErr(i2);
        }
        last.push({
          type: types$1.REPETITION,
          min: 0,
          max: Infinity,
          value: last.pop()
        });
        break;
      default:
        last.push({
          type: types$1.CHAR,
          value: c.charCodeAt(0)
        });
    }
  }
  if (groupStack.length !== 0) {
    util.error(regexpStr, "Unterminated group");
  }
  return start;
};
lib.exports.types = types$1;
var parse$1 = lib.exports;
var types = parse$1.types;
var safeRegex = function(re2, opts) {
  if (!opts)
    opts = {};
  var replimit = opts.limit === void 0 ? 25 : opts.limit;
  if (isRegExp(re2))
    re2 = re2.source;
  else if (typeof re2 !== "string")
    re2 = String(re2);
  try {
    re2 = parse$1(re2);
  } catch (err) {
    return false;
  }
  var reps = 0;
  return function walk(node, starHeight) {
    if (node.type === types.REPETITION) {
      starHeight++;
      reps++;
      if (starHeight > 1)
        return false;
      if (reps > replimit)
        return false;
    }
    if (node.options) {
      for (var i2 = 0, len = node.options.length; i2 < len; i2++) {
        var ok = walk({ stack: node.options[i2] }, starHeight);
        if (!ok)
          return false;
      }
    }
    var stack = node.stack || node.value && node.value.stack;
    if (!stack)
      return true;
    for (var i2 = 0; i2 < stack.length; i2++) {
      var ok = walk(stack[i2], starHeight);
      if (!ok)
        return false;
    }
    return true;
  }(re2, 0);
};
function isRegExp(x2) {
  return {}.toString.call(x2) === "[object RegExp]";
}
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var isobject$1 = function isObject2(val) {
  return val != null && typeof val === "object" && Array.isArray(val) === false;
};
var toString$2 = Object.prototype.toString;
var kindOf$1 = function kindOf2(val) {
  if (val === void 0)
    return "undefined";
  if (val === null)
    return "null";
  var type = typeof val;
  if (type === "boolean")
    return "boolean";
  if (type === "string")
    return "string";
  if (type === "number")
    return "number";
  if (type === "symbol")
    return "symbol";
  if (type === "function") {
    return isGeneratorFn(val) ? "generatorfunction" : "function";
  }
  if (isArray$2(val))
    return "array";
  if (isBuffer$1(val))
    return "buffer";
  if (isArguments$1(val))
    return "arguments";
  if (isDate$2(val))
    return "date";
  if (isError(val))
    return "error";
  if (isRegexp(val))
    return "regexp";
  switch (ctorName(val)) {
    case "Symbol":
      return "symbol";
    case "Promise":
      return "promise";
    case "WeakMap":
      return "weakmap";
    case "WeakSet":
      return "weakset";
    case "Map":
      return "map";
    case "Set":
      return "set";
    case "Int8Array":
      return "int8array";
    case "Uint8Array":
      return "uint8array";
    case "Uint8ClampedArray":
      return "uint8clampedarray";
    case "Int16Array":
      return "int16array";
    case "Uint16Array":
      return "uint16array";
    case "Int32Array":
      return "int32array";
    case "Uint32Array":
      return "uint32array";
    case "Float32Array":
      return "float32array";
    case "Float64Array":
      return "float64array";
  }
  if (isGeneratorObj(val)) {
    return "generator";
  }
  type = toString$2.call(val);
  switch (type) {
    case "[object Object]":
      return "object";
    case "[object Map Iterator]":
      return "mapiterator";
    case "[object Set Iterator]":
      return "setiterator";
    case "[object String Iterator]":
      return "stringiterator";
    case "[object Array Iterator]":
      return "arrayiterator";
  }
  return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
};
function ctorName(val) {
  return typeof val.constructor === "function" ? val.constructor.name : null;
}
function isArray$2(val) {
  if (Array.isArray)
    return Array.isArray(val);
  return val instanceof Array;
}
function isError(val) {
  return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
}
function isDate$2(val) {
  if (val instanceof Date)
    return true;
  return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
}
function isRegexp(val) {
  if (val instanceof RegExp)
    return true;
  return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
}
function isGeneratorFn(name2, val) {
  return ctorName(name2) === "GeneratorFunction";
}
function isGeneratorObj(val) {
  return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
}
function isArguments$1(val) {
  try {
    if (typeof val.length === "number" && typeof val.callee === "function") {
      return true;
    }
  } catch (err) {
    if (err.message.indexOf("callee") !== -1) {
      return true;
    }
  }
  return false;
}
function isBuffer$1(val) {
  if (val.constructor && typeof val.constructor.isBuffer === "function") {
    return val.constructor.isBuffer(val);
  }
  return false;
}
/*!
 * is-accessor-descriptor <https://github.com/jonschlinkert/is-accessor-descriptor>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var typeOf$2 = kindOf$1;
var accessor = {
  get: "function",
  set: "function",
  configurable: "boolean",
  enumerable: "boolean"
};
function isAccessorDescriptor(obj2, prop) {
  if (typeof prop === "string") {
    var val = Object.getOwnPropertyDescriptor(obj2, prop);
    return typeof val !== "undefined";
  }
  if (typeOf$2(obj2) !== "object") {
    return false;
  }
  if (has$1(obj2, "value") || has$1(obj2, "writable")) {
    return false;
  }
  if (!has$1(obj2, "get") || typeof obj2.get !== "function") {
    return false;
  }
  if (has$1(obj2, "set") && typeof obj2[key] !== "function" && typeof obj2[key] !== "undefined") {
    return false;
  }
  for (var key in obj2) {
    if (!accessor.hasOwnProperty(key)) {
      continue;
    }
    if (typeOf$2(obj2[key]) === accessor[key]) {
      continue;
    }
    if (typeof obj2[key] !== "undefined") {
      return false;
    }
  }
  return true;
}
function has$1(obj2, key) {
  return {}.hasOwnProperty.call(obj2, key);
}
var isAccessorDescriptor_1 = isAccessorDescriptor;
/*!
 * is-data-descriptor <https://github.com/jonschlinkert/is-data-descriptor>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var typeOf$1 = kindOf$1;
var isDataDescriptor = function isDataDescriptor2(obj2, prop) {
  var data2 = {
    configurable: "boolean",
    enumerable: "boolean",
    writable: "boolean"
  };
  if (typeOf$1(obj2) !== "object") {
    return false;
  }
  if (typeof prop === "string") {
    var val = Object.getOwnPropertyDescriptor(obj2, prop);
    return typeof val !== "undefined";
  }
  if (!("value" in obj2) && !("writable" in obj2)) {
    return false;
  }
  for (var key in obj2) {
    if (key === "value")
      continue;
    if (!data2.hasOwnProperty(key)) {
      continue;
    }
    if (typeOf$1(obj2[key]) === data2[key]) {
      continue;
    }
    if (typeof obj2[key] !== "undefined") {
      return false;
    }
  }
  return true;
};
/*!
 * is-descriptor <https://github.com/jonschlinkert/is-descriptor>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var typeOf = kindOf$1;
var isAccessor = isAccessorDescriptor_1;
var isData = isDataDescriptor;
var isDescriptor$1 = function isDescriptor2(obj2, key) {
  if (typeOf(obj2) !== "object") {
    return false;
  }
  if ("get" in obj2) {
    return isAccessor(obj2, key);
  }
  return isData(obj2, key);
};
/*!
 * define-property <https://github.com/jonschlinkert/define-property>
 *
 * Copyright (c) 2015-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
var isobject = isobject$1;
var isDescriptor = isDescriptor$1;
var define$v = typeof Reflect !== "undefined" && Reflect.defineProperty ? Reflect.defineProperty : Object.defineProperty;
var defineProperty = function defineProperty2(obj2, key, val) {
  if (!isobject(obj2) && typeof obj2 !== "function" && !Array.isArray(obj2)) {
    throw new TypeError("expected an object, function, or array");
  }
  if (typeof key !== "string") {
    throw new TypeError('expected "key" to be a string');
  }
  if (isDescriptor(val)) {
    define$v(obj2, key, val);
    return obj2;
  }
  define$v(obj2, key, {
    configurable: true,
    enumerable: false,
    writable: true,
    value: val
  });
  return obj2;
};
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var isObject$4 = isobject$1;
function isObjectObject(o) {
  return isObject$4(o) === true && Object.prototype.toString.call(o) === "[object Object]";
}
var isPlainObject$2 = function isPlainObject2(o) {
  var ctor, prot;
  if (isObjectObject(o) === false)
    return false;
  ctor = o.constructor;
  if (typeof ctor !== "function")
    return false;
  prot = ctor.prototype;
  if (isObjectObject(prot) === false)
    return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
};
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var isPlainObject$1 = isPlainObject$2;
var isExtendable$1 = function isExtendable2(val) {
  return isPlainObject$1(val) || typeof val === "function" || Array.isArray(val);
};
/*!
 * assign-symbols <https://github.com/jonschlinkert/assign-symbols>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var assignSymbols$1 = function(receiver, objects) {
  if (receiver === null || typeof receiver === "undefined") {
    throw new TypeError("expected first argument to be an object.");
  }
  if (typeof objects === "undefined" || typeof Symbol === "undefined") {
    return receiver;
  }
  if (typeof Object.getOwnPropertySymbols !== "function") {
    return receiver;
  }
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var target = Object(receiver);
  var len = arguments.length, i2 = 0;
  while (++i2 < len) {
    var provider = Object(arguments[i2]);
    var names = Object.getOwnPropertySymbols(provider);
    for (var j = 0; j < names.length; j++) {
      var key = names[j];
      if (isEnumerable.call(provider, key)) {
        target[key] = provider[key];
      }
    }
  }
  return target;
};
var isExtendable = isExtendable$1;
var assignSymbols = assignSymbols$1;
var extendShallow = Object.assign || function(obj2) {
  if (obj2 === null || typeof obj2 === "undefined") {
    throw new TypeError("Cannot convert undefined or null to object");
  }
  if (!isObject$3(obj2)) {
    obj2 = {};
  }
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var val = arguments[i2];
    if (isString$2(val)) {
      val = toObject(val);
    }
    if (isObject$3(val)) {
      assign$2(obj2, val);
      assignSymbols(obj2, val);
    }
  }
  return obj2;
};
function assign$2(a3, b2) {
  for (var key in b2) {
    if (hasOwn(b2, key)) {
      a3[key] = b2[key];
    }
  }
}
function isString$2(val) {
  return val && typeof val === "string";
}
function toObject(str2) {
  var obj2 = {};
  for (var i2 in str2) {
    obj2[i2] = str2[i2];
  }
  return obj2;
}
function isObject$3(val) {
  return val && typeof val === "object" || isExtendable(val);
}
function hasOwn(obj2, key) {
  return Object.prototype.hasOwnProperty.call(obj2, key);
}
var extend$2 = extendShallow;
var safe$1 = safeRegex;
function toRegex(pattern2, options) {
  return new RegExp(toRegex.create(pattern2, options));
}
toRegex.create = function(pattern2, options) {
  if (typeof pattern2 !== "string") {
    throw new TypeError("expected a string");
  }
  var opts = extend$2({}, options);
  if (opts.contains === true) {
    opts.strictNegate = false;
  }
  var open = opts.strictOpen !== false ? "^" : "";
  var close = opts.strictClose !== false ? "$" : "";
  var endChar = opts.endChar ? opts.endChar : "+";
  var str2 = pattern2;
  if (opts.strictNegate === false) {
    str2 = "(?:(?!(?:" + pattern2 + ")).)" + endChar;
  } else {
    str2 = "(?:(?!^(?:" + pattern2 + ")$).)" + endChar;
  }
  var res = open + str2 + close;
  if (opts.safe === true && safe$1(res) === false) {
    throw new Error("potentially unsafe regular expression: " + res);
  }
  return res;
};
var regexNot = toRegex;
var safe = safeRegex;
var define$u = defineProperty;
var extend$1 = extendShallow;
var not = regexNot;
var MAX_LENGTH = 1024 * 64;
var cache = {};
toRegex$1.exports = function(patterns, options) {
  if (!Array.isArray(patterns)) {
    return makeRe(patterns, options);
  }
  return makeRe(patterns.join("|"), options);
};
function makeRe(pattern2, options) {
  if (pattern2 instanceof RegExp) {
    return pattern2;
  }
  if (typeof pattern2 !== "string") {
    throw new TypeError("expected a string");
  }
  if (pattern2.length > MAX_LENGTH) {
    throw new Error("expected pattern to be less than " + MAX_LENGTH + " characters");
  }
  var key = pattern2;
  if (!options || options && options.cache !== false) {
    key = createKey(pattern2, options);
    if (cache.hasOwnProperty(key)) {
      return cache[key];
    }
  }
  var opts = extend$1({}, options);
  if (opts.contains === true) {
    if (opts.negate === true) {
      opts.strictNegate = false;
    } else {
      opts.strict = false;
    }
  }
  if (opts.strict === false) {
    opts.strictOpen = false;
    opts.strictClose = false;
  }
  var open = opts.strictOpen !== false ? "^" : "";
  var close = opts.strictClose !== false ? "$" : "";
  var flags = opts.flags || "";
  var regex2;
  if (opts.nocase === true && !/i/.test(flags)) {
    flags += "i";
  }
  try {
    if (opts.negate || typeof opts.strictNegate === "boolean") {
      pattern2 = not.create(pattern2, opts);
    }
    var str2 = open + "(?:" + pattern2 + ")" + close;
    regex2 = new RegExp(str2, flags);
    if (opts.safe === true && safe(regex2) === false) {
      throw new Error("potentially unsafe regular expression: " + regex2.source);
    }
  } catch (err) {
    if (opts.strictErrors === true || opts.safe === true) {
      err.key = key;
      err.pattern = pattern2;
      err.originalOptions = options;
      err.createdOptions = opts;
      throw err;
    }
    try {
      regex2 = new RegExp("^" + pattern2.replace(/(\W)/g, "\\$1") + "$");
    } catch (err2) {
      regex2 = /.^/;
    }
  }
  if (opts.cache !== false) {
    memoize(regex2, key, pattern2, opts);
  }
  return regex2;
}
function memoize(regex2, key, pattern2, options) {
  define$u(regex2, "cached", true);
  define$u(regex2, "pattern", pattern2);
  define$u(regex2, "options", options);
  define$u(regex2, "key", key);
  cache[key] = regex2;
}
function createKey(pattern2, options) {
  if (!options)
    return pattern2;
  var key = pattern2;
  for (var prop in options) {
    if (options.hasOwnProperty(prop)) {
      key += ";" + prop + "=" + String(options[prop]);
    }
  }
  return key;
}
toRegex$1.exports.makeRe = makeRe;
function format$2(string2, format2) {
  var _a3;
  let schema = [];
  switch (format2) {
    case "isoDate":
      schema = [
        "\\d",
        "\\d",
        "\\d",
        "\\d",
        "-",
        "\\d",
        "\\d",
        "-",
        "\\d",
        "\\d"
      ];
      break;
    case "isoDateTime":
      schema = [
        "\\d",
        "\\d",
        "\\d",
        "\\d",
        "-",
        "\\d",
        "\\d",
        "-",
        "\\d",
        "\\d",
        " ",
        "\\d",
        "\\d",
        ":",
        "\\d",
        "\\d",
        ":",
        "\\d",
        "\\d"
      ];
      break;
    case "isoTime":
      schema = ["\\d", "\\d", ":", "\\d", "\\d", ":", "\\d", "\\d"];
      break;
    case "hex":
      schema = ["#", "\\w", "\\w", "\\w", "\\w", "\\w", "\\w"];
      break;
    case "hexa":
      schema = [
        "#",
        "\\w",
        "\\w",
        "\\w",
        "\\w",
        "\\w",
        "\\w",
        "\\w",
        "\\w"
      ];
      break;
    case "integer":
      return string2.replace(/^[0-9]+$/i, "");
    case "number":
      return string2.replace(/^[0-9\.]+$/i, "");
    case "alphanum":
      return string2.replace(/^[a-z0-9]+$/i, "");
    case "creditCard":
      schema = [
        "\\d",
        "\\d",
        "\\d",
        "\\d",
        " ",
        "\\d",
        "\\d",
        "\\d",
        "\\d",
        " ",
        "\\d",
        "\\d",
        "\\d",
        "\\d",
        " ",
        "\\d",
        "\\d",
        "\\d",
        "\\d"
      ];
      break;
    default:
      return string2;
  }
  let newValue = "";
  const loopOn = string2.length > schema.length ? string2 : schema;
  let schemaCharI = 0;
  for (let i2 = 0; i2 < loopOn.length; i2++) {
    const schemaChar = schema[schemaCharI], char = (_a3 = string2[i2]) !== null && _a3 !== void 0 ? _a3 : "";
    if (!schemaChar || !char || i2 >= string2.length) {
      break;
    }
    if (schemaChar === char) {
      newValue += char;
      schemaCharI++;
    } else if (schemaChar.match(/^\\d/)) {
      if (char.match(/^\d$/)) {
        newValue += char;
        schemaCharI++;
      }
    } else if (schemaChar.match(/^\\w/)) {
      if (char.match(/^\w$/)) {
        newValue += char;
        schemaCharI++;
      }
    } else if (schemaChar !== char) {
      newValue += schemaChar;
      i2--;
      schemaCharI++;
    } else
      ;
  }
  return newValue;
}
format$2.formats = [
  "isoDate",
  "isoDateTime",
  "isoTime",
  "integer",
  "number",
  "alphanum",
  "hex",
  "hexa",
  "creditCard"
];
function __ltrim(string2, needle, trimResult = true) {
  if (string2.substr(0, needle.length) === needle) {
    return trimResult ? string2.substr(needle.length).trim() : string2.substr(needle.length);
  }
  return string2;
}
var sprintf = {};
(function(exports) {
  !function() {
    var re2 = {
      not_string: /[^s]/,
      not_bool: /[^t]/,
      not_type: /[^T]/,
      not_primitive: /[^v]/,
      number: /[diefg]/,
      numeric_arg: /[bcdiefguxX]/,
      json: /[j]/,
      not_json: /[^j]/,
      text: /^[^\x25]+/,
      modulo: /^\x25{2}/,
      placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
      key: /^([a-z_][a-z_\d]*)/i,
      key_access: /^\.([a-z_][a-z_\d]*)/i,
      index_access: /^\[(\d+)\]/,
      sign: /^[+-]/
    };
    function sprintf2(key) {
      return sprintf_format(sprintf_parse(key), arguments);
    }
    function vsprintf(fmt, argv) {
      return sprintf2.apply(null, [fmt].concat(argv || []));
    }
    function sprintf_format(parse_tree, argv) {
      var cursor = 1, tree_length = parse_tree.length, arg, output = "", i2, k2, ph, pad2, pad_character, pad_length, is_positive, sign2;
      for (i2 = 0; i2 < tree_length; i2++) {
        if (typeof parse_tree[i2] === "string") {
          output += parse_tree[i2];
        } else if (typeof parse_tree[i2] === "object") {
          ph = parse_tree[i2];
          if (ph.keys) {
            arg = argv[cursor];
            for (k2 = 0; k2 < ph.keys.length; k2++) {
              if (arg == void 0) {
                throw new Error(sprintf2('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k2], ph.keys[k2 - 1]));
              }
              arg = arg[ph.keys[k2]];
            }
          } else if (ph.param_no) {
            arg = argv[ph.param_no];
          } else {
            arg = argv[cursor++];
          }
          if (re2.not_type.test(ph.type) && re2.not_primitive.test(ph.type) && arg instanceof Function) {
            arg = arg();
          }
          if (re2.numeric_arg.test(ph.type) && (typeof arg !== "number" && isNaN(arg))) {
            throw new TypeError(sprintf2("[sprintf] expecting number but found %T", arg));
          }
          if (re2.number.test(ph.type)) {
            is_positive = arg >= 0;
          }
          switch (ph.type) {
            case "b":
              arg = parseInt(arg, 10).toString(2);
              break;
            case "c":
              arg = String.fromCharCode(parseInt(arg, 10));
              break;
            case "d":
            case "i":
              arg = parseInt(arg, 10);
              break;
            case "j":
              arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
              break;
            case "e":
              arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
              break;
            case "f":
              arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
              break;
            case "g":
              arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
              break;
            case "o":
              arg = (parseInt(arg, 10) >>> 0).toString(8);
              break;
            case "s":
              arg = String(arg);
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "t":
              arg = String(!!arg);
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "T":
              arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "u":
              arg = parseInt(arg, 10) >>> 0;
              break;
            case "v":
              arg = arg.valueOf();
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "x":
              arg = (parseInt(arg, 10) >>> 0).toString(16);
              break;
            case "X":
              arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
              break;
          }
          if (re2.json.test(ph.type)) {
            output += arg;
          } else {
            if (re2.number.test(ph.type) && (!is_positive || ph.sign)) {
              sign2 = is_positive ? "+" : "-";
              arg = arg.toString().replace(re2.sign, "");
            } else {
              sign2 = "";
            }
            pad_character = ph.pad_char ? ph.pad_char === "0" ? "0" : ph.pad_char.charAt(1) : " ";
            pad_length = ph.width - (sign2 + arg).length;
            pad2 = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
            output += ph.align ? sign2 + arg + pad2 : pad_character === "0" ? sign2 + pad2 + arg : pad2 + sign2 + arg;
          }
        }
      }
      return output;
    }
    var sprintf_cache = /* @__PURE__ */ Object.create(null);
    function sprintf_parse(fmt) {
      if (sprintf_cache[fmt]) {
        return sprintf_cache[fmt];
      }
      var _fmt = fmt, match5, parse_tree = [], arg_names = 0;
      while (_fmt) {
        if ((match5 = re2.text.exec(_fmt)) !== null) {
          parse_tree.push(match5[0]);
        } else if ((match5 = re2.modulo.exec(_fmt)) !== null) {
          parse_tree.push("%");
        } else if ((match5 = re2.placeholder.exec(_fmt)) !== null) {
          if (match5[2]) {
            arg_names |= 1;
            var field_list = [], replacement_field = match5[2], field_match = [];
            if ((field_match = re2.key.exec(replacement_field)) !== null) {
              field_list.push(field_match[1]);
              while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                if ((field_match = re2.key_access.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                } else if ((field_match = re2.index_access.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                } else {
                  throw new SyntaxError("[sprintf] failed to parse named argument key");
                }
              }
            } else {
              throw new SyntaxError("[sprintf] failed to parse named argument key");
            }
            match5[2] = field_list;
          } else {
            arg_names |= 2;
          }
          if (arg_names === 3) {
            throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
          }
          parse_tree.push(
            {
              placeholder: match5[0],
              param_no: match5[1],
              keys: match5[2],
              sign: match5[3],
              pad_char: match5[4],
              align: match5[5],
              width: match5[6],
              precision: match5[7],
              type: match5[8]
            }
          );
        } else {
          throw new SyntaxError("[sprintf] unexpected placeholder");
        }
        _fmt = _fmt.substring(match5[0].length);
      }
      return sprintf_cache[fmt] = parse_tree;
    }
    {
      exports["sprintf"] = sprintf2;
      exports["vsprintf"] = vsprintf;
    }
    if (typeof window !== "undefined") {
      window["sprintf"] = sprintf2;
      window["vsprintf"] = vsprintf;
    }
  }();
})(sprintf);
function __snakeCase(text) {
  const dashCase = __dashCase(text);
  return dashCase.replace(/\-/g, "_");
}
class STypeResult {
  constructor(data2) {
    this._data = data2;
  }
  get typeString() {
    return this._data.typeString;
  }
  get value() {
    return this._data.value;
  }
  get received() {
    return this._data.received;
  }
  get expected() {
    return this._data.expected;
  }
  get issues() {
    return this._data.issues;
  }
  get settings() {
    return this._data.settings;
  }
  hasIssues() {
    if (this._data)
      return true;
    return false;
  }
  toString() {
    if (__isNode()) {
      return this.toConsole();
    } else {
      return `The method "toHtml" has not being integrated for now...`;
    }
  }
  toConsole() {
    const headerArray = [
      `<underline><magenta>${this._data.settings.name}</magenta></underline>`,
      "",
      "<underline>Received value</underline>",
      "",
      `${fn$3(this._data.value, {
        beautify: true
      })}`,
      ""
    ];
    const issuesArray = [];
    Object.keys(this._data.issues).forEach((ruleId) => {
      const issueObj = this._data.issues[ruleId];
      const message = [];
      if (issueObj.expected.type) {
        message.push(`- Expected "<yellow>${issueObj.expected.type}</yellow>"`);
      }
      if (issueObj.received.type) {
        message.push(`- Received "<red>${issueObj.received.type}</red>"`);
      }
      if (issueObj.message) {
        message.push(["<underline>Details:</underline>", issueObj.message].join("\n"));
      }
      issuesArray.push(message.join("\n"));
    });
    const settingsArray = [
      "",
      `<underline>Settings</underline>`,
      "",
      `${fn$3(this._data.settings, {
        beautify: true
      })}`
    ];
    return __parseHtml(`
${headerArray.join("\n")}
${issuesArray.join("\n")}
${this.settings.verbose ? settingsArray.join("\n") : ""}
    `).trim();
  }
}
class SType {
  constructor(typeString, settings = {}) {
    this.typeString = typeString;
    typeString = typeString.toLowerCase().trim();
    if (this.constructor._instanciatedTypes[typeString] !== void 0)
      return this.constructor._instanciatedTypes[typeString];
    this.types = __parseTypeString(typeString);
    this.settings = __deepMerge({
      id: this.constructor.name,
      name: this.constructor.name,
      customTypes: true,
      interfaces: true
    }, settings);
    this.constructor._instanciatedTypes[typeString] = this;
  }
  static registerType(type) {
    if (type.id === void 0 || typeof type.id !== "string") {
      throw new Error(`Sorry but you try to register a type that does not fit the ISTypeDescriptor interface...`);
    }
    this._registeredTypes[type.id] = type;
  }
  static parseTypeString(typeString) {
    return __parseTypeString(typeString);
  }
  is(value, settings = {}) {
    const res = this.check(value, settings);
    if (res === true)
      return true;
    else if (res instanceof STypeResult)
      return !res.hasIssues();
    return true;
  }
  check(value, settings = {}) {
    settings = __deepMerge(this.settings, settings);
    const issues = {};
    for (let i2 = 0; i2 < this.types.length; i2++) {
      const typeObj = this.types[i2], typeId = typeObj.type;
      const res2 = this._isType(value, typeId, settings);
      if (res2 === true) {
        if (typeObj.of === void 0)
          return true;
        const typeOf2 = __typeof(value);
        if (typeOf2 !== "Array" && typeOf2 !== "Object" && typeOf2 !== "Map") {
          throw new Error(`Sorry but you have specified a type string "<yellow>${this.typeString}</yellow>" with some "<...>" definition on a type "<cyan>${typeOf2}</cyan>" that does not support "child" value(s)...`);
        }
        const loopOn = typeOf2 === "Object" ? Object.keys(value) : Array.from(value.keys());
        if (!loopOn.length)
          return true;
        for (let k2 = 0; k2 < loopOn.length; k2++) {
          for (let j = 0; j < typeObj.of.length; j++) {
            const type = typeObj.of[j];
            const idx = loopOn[k2];
            const v = typeOf2 === "Map" ? value.get(idx) : value[idx];
            const ofRes = this._isType(v, type, settings);
            if (ofRes !== true) {
              issues[typeObj.type] = {
                expected: {
                  type: typeObj.type
                },
                received: {
                  type: __typeof(v),
                  value: v
                }
              };
            } else {
              return true;
            }
          }
        }
      } else {
        const issueObj = {
          expected: {
            type: typeObj.type
          },
          received: {
            type: __typeof(value),
            value
          }
        };
        if (res2 !== void 0 && res2 !== null && res2 !== false && res2.toString && typeof res2.toString === "function") {
          issueObj.message = res2.toString();
        }
        issues[typeObj.type] = issueObj;
      }
    }
    const res = new STypeResult({
      typeString: this.typeString,
      value,
      expected: {
        type: this.typeString
      },
      received: {
        type: __typeof(value)
      },
      issues,
      settings
    });
    return res;
  }
  _isType(value, type, settings = {}) {
    settings = __deepMerge(this.settings, settings);
    if (this.constructor._registeredTypes[type.toLowerCase()] === void 0) {
      if (settings.interfaces === true) {
        const availableInterfaceTypes = SInterface.getAvailableTypes();
        if (availableInterfaceTypes[type] !== void 0) {
          const res = availableInterfaceTypes[type].apply(value, {});
          return res;
        }
      }
      if (settings.customTypes === true) {
        const typeOf2 = __typeof(value).toLowerCase();
        const extendsStack = Object.keys(fn$2(value)).map((s2) => s2.toLowerCase());
        if (type === typeOf2 || extendsStack.indexOf(type) !== -1)
          return true;
      }
      throw new Error(`Sorry but you try to validate a value with the type "<yellow>${type}</yellow>" but this type is not registered...`);
    }
    return this.constructor._registeredTypes[type.toLowerCase()].is(value);
  }
  cast(value, params, settings) {
    settings = __deepMerge(this.settings, settings);
    const verboseObj = {
      value,
      issues: {},
      settings,
      toString() {
        const strAr = Object.entries(this.issues);
        return strAr.map((l) => l[1]).join("\n");
      }
    };
    if (this.is(value)) {
      return value;
    }
    for (let i2 = 0; i2 < this.types.length; i2++) {
      const typeObj = this.types[i2], typeId = typeObj.type;
      const descriptorObj = this.constructor._registeredTypes[typeId.toLowerCase()];
      if (descriptorObj === void 0) {
        continue;
      }
      if (descriptorObj.cast === void 0)
        continue;
      let castedValue;
      castedValue = descriptorObj.cast(value, params);
      if (castedValue instanceof Error) {
        verboseObj.issues[typeId] = castedValue.toString();
        continue;
      }
      if (typeObj.of !== void 0 && this.canHaveChilds(castedValue) === false) {
        const issueStr = `Sorry but the passed type "<yellow>${typeId}</yellow>" has some child(s) dependencies "<green>${typeObj.of.join("|")}</green>" but this type can not have child(s)`;
        throw new Error(__parseHtml(issueStr));
      } else if (typeObj.of !== void 0) {
        const sTypeInstance = new SType(typeObj.of.join("|"));
        castedValue = fn$1(castedValue, ({ value: value2 }) => {
          return sTypeInstance.cast(value2, params, settings);
        });
      }
      if (castedValue === null && descriptorObj.id === "null")
        return null;
      if (castedValue === void 0 && descriptorObj.id === "undefined")
        return void 0;
      if (castedValue !== null && castedValue !== void 0)
        return castedValue;
      verboseObj.issues[typeId] = `Something goes wrong but no details are available... Sorry`;
    }
    const stack = [
      `Sorry but the value of type "<cyan>${__typeof(value)}</cyan>" passed to be casted in type "<yellow>${this.typeString}</yellow>" can not be casted correctly. Here's why:
`
    ];
    Object.keys(verboseObj.issues).forEach((descriptorId) => {
      stack.push(`- <red>${descriptorId}</red>: ${verboseObj.issues[descriptorId]}`);
    });
    throw new Error(__parseHtml(stack.join("\n")));
  }
  canHaveChilds(value) {
    const type = __typeof(value);
    return type === "Array" || type === "Object" || type === "Map";
  }
  get name() {
    return this.settings.name;
  }
  get id() {
    return this.settings.id;
  }
}
SType._instanciatedTypes = {};
SType._registeredTypes = {};
const descriptor$g = {
  name: "Array",
  id: "array",
  is: (value) => {
    return Array.isArray(value);
  },
  cast: (value, params = {}) => {
    if (!value)
      return [];
    if (params.splitChars && Array.isArray(params.splitChars)) {
      if (value === true)
        value = "";
      value = value.split(new RegExp(`(${params.splitChars.join("|")})`, "gm")).filter((l) => l.trim() !== "" && params.splitChars.indexOf(l) === -1);
    }
    if (Array.isArray(value))
      return value;
    return [value];
  }
};
const descriptor$f = {
  name: "Bigint",
  id: "bigint",
  is: (value) => typeof value === "bigint",
  cast: (value) => {
    if (typeof value === "bigint")
      return value;
    if (typeof value !== "string" && typeof value !== "number") {
      return new Error(`Sorry but only <yellow>String</yellow> and <yellow>Number</yellow> can be casted to <green>Bigint</green>`);
    }
    let res;
    try {
      res = BigInt(value);
    } catch (e) {
      res = new Error(`It seem's that the passed value "<yellow>${value}</yellow>" can not be casted to a <green>BigInt</green>`);
    }
    return res;
  }
};
const descriptor$e = {
  name: "Boolean",
  id: "boolean",
  is: (value) => typeof value === "boolean",
  cast: (value, params = {}) => {
    if (value !== false && params && params.nullishAsTrue && !value) {
      return true;
    }
    if (typeof value === "boolean")
      return value;
    if (value === null || value === void 0)
      return false;
    if (typeof value === "number") {
      if (value > 0)
        return true;
      return false;
    }
    if (typeof value === "string") {
      return value.length > 0 ? true : false;
    }
    if (Array.isArray(value)) {
      if (value.length > 0)
        return true;
      return false;
    }
    if (typeof value === "object") {
      return Object.keys(value).length > 0 ? true : false;
    }
    return new Error([
      `Sorry but for now only these types can be casted to boolean:`,
      "- <yellow>null</yellow>: Will be casted as <red>false</red>",
      "- <yellow>undefined</yellow>: Will be casted as <red>false</red>",
      "- <yellow>Number</yellow>: Will be casted as <green>true</green> when greater than 0, <red>false</red> otherwise",
      "- <yellow>String</yellow>: Will be casted as <green>true</green> when longer than 0 characters, <red>false</red> otherwise",
      "- <yellow>Array</yellow>: Will be casted as <green>true</green> when having more than 0 items, <red>false</red> otherwise",
      "- <yellow>Object</yellow>: Will be casted as <green>true</green> when have more than 0 properties, <red>false</red> otherwise"
    ].join("\n"));
  }
};
const descriptor$d = {
  name: "Class",
  id: "class",
  is: (value) => isClass$1(value),
  cast: (value) => {
    return new Error(`Sorry but nothing is castable to a Class`);
  }
};
const descriptor$c = {
  name: "Date",
  id: "date",
  is: (value) => value instanceof Date,
  cast: (value) => {
    if (typeof value === "string") {
      return new Date(value);
    }
    if (typeof value === "number") {
      return new Date(Math.round(value));
    }
    if (__isPlainObject(value)) {
      const now = new Date();
      let year = now.getFullYear(), month = 0, day = 1, hours = 0, minutes = 0, seconds = 0, milliseconds = 0;
      if (value.year && typeof value.year === "number") {
        year = value.year;
      }
      if (value.month && typeof value.month === "number") {
        month = value.month;
      }
      if (value.day && typeof value.day === "number") {
        day = value.day;
      }
      if (value.hours && typeof value.hours === "number") {
        hours = value.hours;
      }
      if (value.minutes && typeof value.minutes === "number") {
        minutes = value.minutes;
      }
      if (value.seconds && typeof value.seconds === "number") {
        seconds = value.seconds;
      }
      if (value.milliseconds && typeof value.milliseconds === "number") {
        milliseconds = value.milliseconds;
      }
      return new Date(year, month, day, hours, minutes, seconds, milliseconds);
    }
    return new Error(`Sorry but for now only <yellow>String</yellow>, <yellow>Number</yellow> and <yellow>Object</yellow> (with properties: year, month, day?, hours?, minutes?, seconds? and milliseconds?) are castable to Date`);
  }
};
const descriptor$b = {
  name: "Function",
  id: "function",
  is: (value) => typeof value === "function",
  cast: (value) => {
    return new Error(`Sorry but nothing is castable to a Function`);
  }
};
const descriptor$a = {
  name: "Integer",
  id: "integer",
  is: (value) => Number.isInteger(value),
  cast: (value) => {
    if (typeof value !== "string" && typeof value !== "number") {
      return new Error(`Sorry but only strings and numbers can be casted to integers... Passed value: ${value}`);
    }
    const res = parseInt(value);
    if (isNaN(res))
      return new Error(`Sorry but the conversion of "<yellow>${value}</yellow>" to a <green>Integer</green> does not work...`);
    return res;
  }
};
const descriptor$9 = {
  name: "Map",
  id: "map",
  is: (value) => __isMap(value),
  cast: (value) => {
    if (__isMap(value))
      return value;
    const map2 = /* @__PURE__ */ new Map();
    map2.set("value", value);
    return map2;
  }
};
const descriptor$8 = {
  name: "Null",
  id: "null",
  is: (value) => value === null,
  cast: (value) => {
    return null;
  }
};
const descriptor$7 = {
  name: "Number",
  id: "number",
  is: (value) => typeof value === "number",
  cast: (value) => {
    if (typeof value !== "string") {
      console.log("vv", value, typeof value);
      return new Error(`Sorry but only strings can be casted to numbers...`);
    }
    const res = parseFloat(value);
    if (isNaN(res))
      return new Error(`Sorry but the conversion of "<yellow>${value}</yellow>" to a <green>Number</green> does not work...`);
    return res;
  }
};
const descriptor$6 = {
  name: "Object",
  id: "object",
  is: (value) => __isObject(value),
  cast: (value) => {
    if (__isObject(value))
      return value;
    return {
      value
    };
  }
};
const descriptor$5 = {
  name: "Set",
  id: "set",
  is: (value) => value instanceof Set,
  cast: (value) => {
    if (value instanceof Set)
      return value;
    const set = /* @__PURE__ */ new Set();
    set.add(value);
    return set;
  }
};
const descriptor$4 = {
  name: "String",
  id: "string",
  is: (value) => __isString(value),
  cast: (value) => fn$3(value, {
    beautify: true
  })
};
const descriptor$3 = {
  name: "Symbol",
  id: "symbol",
  is: (value) => typeof value === "symbol",
  cast: (value) => {
    if (typeof value === "symbol")
      return value;
    return Symbol(value);
  }
};
const descriptor$2 = {
  name: "Undefined",
  id: "undefined",
  is: (value) => value === void 0,
  cast: (value) => {
    return void 0;
  }
};
const descriptor$1 = {
  name: "WeakMap",
  id: "weakmap",
  is: (value) => value instanceof WeakMap,
  cast: (value) => {
    return new Error(`Sorry but nothing can be casted to a WeakMap for now`);
  }
};
const descriptor = {
  name: "WeakSet",
  id: "weakset",
  is: (value) => value instanceof WeakSet,
  cast: (value) => {
    return new Error(`Sorry but nothing can be casted to a WeakSet for now`);
  }
};
SType.registerType(descriptor$4);
SType.registerType(descriptor$9);
SType.registerType(descriptor$6);
SType.registerType(descriptor$g);
SType.registerType(descriptor$a);
SType.registerType(descriptor$7);
SType.registerType(descriptor$e);
SType.registerType(descriptor$2);
SType.registerType(descriptor$8);
SType.registerType(descriptor$3);
SType.registerType(descriptor$f);
SType.registerType(descriptor$c);
SType.registerType(descriptor$b);
SType.registerType(descriptor$1);
SType.registerType(descriptor);
SType.registerType(descriptor$5);
SType.registerType(descriptor$d);
const ruleObj = {
  prority: 10,
  name: "Type",
  id: "type",
  settings: {},
  processParams: (params) => {
    var _a3, _b2;
    if (!(params === null || params === void 0 ? void 0 : params.type) && typeof params !== "string") {
      throw new Error(`<yellow>[sugar.shared.type.descriptors.typeRule]</yellow> Sorry but to use the <magenta>type</magenta> descriptor rule you need to specify a type string either directly under the "type" property, or in an object under the "type.type" property...`);
    }
    return Object.assign(Object.assign({}, typeof params !== "string" ? params : {}), { type: (_a3 = params.type) !== null && _a3 !== void 0 ? _a3 : params, cast: (_b2 = params.cast) !== null && _b2 !== void 0 ? _b2 : true });
  },
  apply: (value, params, ruleSettings, settings) => {
    const type = new SType(params.type, {
      metas: {
        id: settings.id
      }
    });
    if (params.cast && !type.is(value)) {
      value = type.cast(value, params);
    }
    if (!type.is(value)) {
      return new Error(`The value must be of type "<yellow>${params.type}</yellow>" but you've passed a value of type "<cyan>${typeof value}</cyan>"`);
    }
    return value;
  }
};
class SDescriptorResult extends SClass {
  constructor(descriptor2, value, descriptorSettings) {
    super({});
    this._issues = {};
    this._descriptor = descriptor2;
    this._descriptorSettings = descriptorSettings;
    try {
      this._originalValue = clone(value, { deep: true });
    } catch (e) {
      this._originalValue = value;
    }
    this.value = value;
  }
  hasIssues() {
    return Object.keys(this._issues).length >= 1;
  }
  add(ruleResult) {
    if (!ruleResult.__ruleObj.id)
      return;
    this._issues[ruleResult.__ruleObj.id] = ruleResult;
  }
  toString() {
    if (__isNode()) {
      return this.toConsole();
    } else {
      return this.toConsole();
    }
  }
  toConsole() {
    const headerArray = [
      `<underline><magenta>${this._descriptor.metas.name}</magenta></underline>`,
      "",
      `${fn$3(this.value, {
        beautify: true
      })}`,
      ""
    ];
    const issuesArray = [];
    Object.keys(this._issues).forEach((ruleId) => {
      const ruleResult = this._issues[ruleId];
      let message = "";
      if (ruleResult.__error && ruleResult.__error instanceof Error) {
        message = ruleResult.__error.message;
      } else if (ruleResult.__ruleObj.message !== void 0 && typeof ruleResult.__ruleObj.message === "function") {
        message = ruleResult.__ruleObj.message(ruleResult);
      } else if (ruleResult.__ruleObj.message !== void 0 && typeof ruleResult.__ruleObj.message === "string") {
        message = ruleResult.__ruleObj.message;
      }
      issuesArray.push(`-${typeof ruleResult.__propName === "string" ? ` [<magenta>${ruleResult.__propName}</magenta>]` : ""} <red>${ruleId}</red>: ${message}`);
    });
    const settingsArray = [
      "",
      `<underline>Settings</underline>`,
      "",
      `${fn$3(this._descriptorSettings, {
        beautify: true
      })}`
    ];
    return __parseHtml(`
${headerArray.join("\n")}
${issuesArray.join("\n")}
${settingsArray.join("\n")}
    `).trim();
  }
}
class SDescriptor extends SClass {
  constructor(settings) {
    super(__deepMerge({
      rules: {},
      type: "Object",
      arrayAsValue: false,
      throwOnMissingRule: false,
      defaults: true
    }, settings !== null && settings !== void 0 ? settings : {}));
  }
  static registerRule(rule) {
    if (rule.id === void 0 || typeof rule.id !== "string") {
      throw new Error(`Sorry but you try to register a rule that does not fit the ISDescriptionRule interface...`);
    }
    this._registeredRules[rule.id] = rule;
  }
  apply(value, settings) {
    const set = __deepMerge(this.settings, settings || {});
    if (value === void 0 || value === null)
      value = {};
    const valuesObjToProcess = {}, finalValuesObj = {};
    this._descriptorResult = new SDescriptorResult(this, finalValuesObj, Object.assign({}, set));
    const rules = set.rules;
    if (!__isOfType(value, set.type)) {
      throw new Error(`Sorry but this descriptor "<yellow>${this.metas.name}</yellow>" does not accept values of type "<cyan>${__typeof(value)}</cyan>" but only "<green>${set.type}</green>"...`);
    }
    if (Array.isArray(value) && !set.arrayAsValue) {
      throw new Error(`Sorry but the support for arrays like values has not been integrated for not...`);
    } else if (typeof value === "object" && value !== null && value !== void 0) {
      Object.keys(rules).forEach((propName) => {
        if (__isGlob(propName) && value)
          ;
        else {
          valuesObjToProcess[propName] = get(value, propName);
        }
      });
      Object.keys(valuesObjToProcess).forEach((propName) => {
        const ruleObj2 = rules[propName];
        if (valuesObjToProcess[propName] === void 0 && set.defaults && ruleObj2.default !== void 0) {
          valuesObjToProcess[propName] = ruleObj2.default;
        }
        if (ruleObj2.interface !== void 0) {
          const interfaceValue = valuesObjToProcess[propName];
          valuesObjToProcess[propName] = ruleObj2.interface.apply(interfaceValue || {}, {});
        }
        const validationResult = this._validate(valuesObjToProcess[propName], propName, ruleObj2, set);
        if (validationResult !== void 0 && validationResult !== null) {
          __set(finalValuesObj, propName, validationResult);
        }
      });
    } else {
      console.warn(value);
      throw new Error(`You can apply an <yellow>SDescriptor</yellow> only on an Object like value...`);
    }
    if (this._descriptorResult.hasIssues()) {
      throw new Error(this._descriptorResult.toString());
    }
    return this._descriptorResult;
  }
  _validate(value, propName, rulesObj, settings) {
    if (rulesObj === void 0)
      return value;
    if (rulesObj.required === void 0 || rulesObj.required === false) {
      if (value === void 0 || value === null)
        return value;
    }
    let rulesNamesInOrder = Object.keys(rulesObj).filter((l) => l !== "default");
    rulesNamesInOrder = rulesNamesInOrder.sort((a3, b2) => {
      const objA = this.constructor._registeredRules[a3];
      const objB = this.constructor._registeredRules[b2];
      if (!objA)
        return -1;
      if (!objB)
        return 1;
      if (objA.priority === void 0)
        objA.priority = 9999999999;
      if (objB.priority === void 0)
        objB.priority = 9999999999;
      return objA.priotity - objB.priority;
    }).reverse();
    let resultValue = value;
    rulesNamesInOrder.forEach((ruleName) => {
      const ruleValue = rulesObj[ruleName];
      if (this.constructor._registeredRules[ruleName] === void 0) {
        if (settings.throwOnMissingRule) {
          throw new Error(`Sorry but you try to validate a value using the "<yellow>${ruleName}</yellow>" rule but this rule is not registered. Here's the available rules:
              - ${Object.keys(this.constructor._registeredRules).join("\n- ")}`);
        }
      } else {
        const ruleObj2 = this.constructor._registeredRules[ruleName];
        const params = ruleObj2.processParams !== void 0 ? ruleObj2.processParams(ruleValue) : ruleValue;
        const ruleSettings = ruleObj2.settings !== void 0 ? ruleObj2.settings : {};
        if (ruleSettings.mapOnArray && Array.isArray(resultValue)) {
          let newResultValue = [];
          resultValue.forEach((v) => {
            const processedValue = this._processRule(v, ruleObj2, propName, params, ruleSettings, settings);
            if (Array.isArray(processedValue)) {
              newResultValue = [
                ...newResultValue,
                ...processedValue
              ];
            } else {
              newResultValue.push(processedValue);
            }
          });
          resultValue = newResultValue;
        } else {
          const processedValue = this._processRule(resultValue, ruleObj2, propName, params, ruleSettings, settings);
          resultValue = processedValue;
        }
      }
    });
    return resultValue;
  }
  _processRule(value, ruleObj2, propName, params, ruleSettings, settings) {
    const ruleResult = ruleObj2.apply(value, params, ruleSettings, Object.assign(Object.assign({}, settings), { propName, name: `${settings.name}.${propName}` }));
    if (params && params.type && params.type.toLowerCase() === "boolean" && ruleResult === true) {
      return true;
    }
    if (ruleResult instanceof Error) {
      const obj2 = {
        __error: ruleResult,
        __ruleObj: ruleObj2,
        __propName: propName
      };
      if (this._descriptorResult) {
        this._descriptorResult.add(obj2);
        throw new Error(this._descriptorResult.toString());
      }
    } else {
      return ruleResult;
    }
  }
}
SDescriptor._registeredRules = {};
SDescriptor.rules = {};
SDescriptor.type = "Object";
SDescriptor.registerRule(ruleObj$1);
SDescriptor.registerRule(ruleObj);
SDescriptor.registerRule(ruleObj$2);
SDescriptor.registerRule(ruleObj$3);
function __parseArgs(string2, settings) {
  settings = __deepMerge({
    valueQuote: void 0,
    treatNoAsBoolean: true,
    camelCase: true
  }, settings !== null && settings !== void 0 ? settings : {});
  string2 = string2.trim();
  string2 = string2.replace(/(["'`])--/gm, "$1--\xA7 --");
  if (settings.treatNoAsBoolean) {
    const noMatches = string2.match(/--no-[\w]+/g);
    noMatches === null || noMatches === void 0 ? void 0 : noMatches.forEach((match5) => {
      string2 = string2.replace(match5, `${match5.replace("--no-", "--")} false`);
    });
  }
  let valueQuote = settings.valueQuote;
  if (!valueQuote) {
    for (let i2 = 0; i2 < string2.length; i2++) {
      const char = string2[i2];
      if (char === '"' || char === "`" || char === "'") {
        valueQuote = char;
        break;
      }
    }
    if (!valueQuote)
      valueQuote = '"';
  }
  let stringArray = [];
  let isFunctionStyle = false;
  if (string2.match(/^\(/) && string2.match(/\)$/)) {
    isFunctionStyle = true;
    string2 = string2.slice(1, -1);
    let currentStr = "";
    let parenthesisCount = 0;
    let quotesCount = 0;
    for (let i2 = 0; i2 < string2.length; i2++) {
      const char = string2[i2];
      const previousChar = string2[i2 - 1] || string2[0];
      if (char === valueQuote && previousChar !== "\\" && !quotesCount) {
        quotesCount++;
      } else if (char === valueQuote && previousChar !== "\\" && quotesCount) {
        quotesCount--;
      }
      if (!quotesCount && char === "(") {
        parenthesisCount++;
      } else if (!quotesCount && char === ")") {
        parenthesisCount--;
      }
      if (char === ",") {
        if (quotesCount || parenthesisCount) {
          currentStr += char;
        } else {
          stringArray.push(currentStr.trim());
          currentStr = "";
        }
      } else {
        currentStr += char;
      }
    }
    if (parenthesisCount)
      currentStr += ")".repeat(parenthesisCount);
    stringArray.push(currentStr.trim());
  } else {
    let currentStr = "";
    let quotesCount = false;
    for (let i2 = 0; i2 < string2.length; i2++) {
      const char = string2[i2];
      const previousChar = string2[i2 - 1] || string2[0];
      if (char === valueQuote && previousChar !== "\\" && !quotesCount) {
        quotesCount = true;
      } else if (char === valueQuote && previousChar !== "\\" && quotesCount) {
        quotesCount = false;
      }
      if (char === " ") {
        if (quotesCount) {
          currentStr += char;
        } else {
          stringArray.push(currentStr.trim());
          currentStr = "";
        }
      } else {
        currentStr += char;
      }
    }
    stringArray.push(currentStr.trim());
  }
  if (stringArray)
    stringArray = stringArray.map((item) => __unquote(item));
  let argsObj = {};
  let currentArgName = void 0;
  let currentValue;
  stringArray = stringArray.forEach((part, i2) => {
    if (!isFunctionStyle && !part.includes(" ") && (part.slice(0, 2) === "--" || part.slice(0, 1) === "-")) {
      if (currentValue === void 0 && currentArgName !== -1 && currentArgName && argsObj[currentArgName] === void 0) {
        argsObj[currentArgName] = true;
      }
      currentArgName = part.replace(/^[-]{1,2}/, "");
      if (argsObj[currentArgName] === void 0) {
        argsObj[currentArgName] = true;
      }
    } else {
      let value;
      if (part && typeof part === "string") {
        value = part.replace(/^\\\\\\`/, "").replace(/\\\\\\`$/, "").replace(/^'/, "").replace(/'$/, "").replace(/^"/, "").replace(/"$/, "");
        if (value.match(/^\$[a-zA-Z0-9-_]+\s?:.*/)) {
          const parts = part.split(":");
          currentArgName = parts[0].trim().replace(/^\$/, "");
          value = parts.slice(1).join(":").trim();
        }
      }
      currentValue = __parseString(value);
      if (typeof currentValue === "string") {
        currentValue = currentValue.replace("--\xA7 ", "");
      }
      if (currentArgName !== void 0) {
        if (argsObj[currentArgName] !== void 0 && argsObj[currentArgName] !== true) {
          if (!Array.isArray(argsObj[currentArgName])) {
            argsObj[currentArgName] = [argsObj[currentArgName]];
          }
          argsObj[currentArgName].push(currentValue);
        } else {
          argsObj[currentArgName] = currentValue;
        }
        currentValue = void 0;
        currentArgName = void 0;
      } else {
        argsObj[i2] = currentValue;
      }
    }
  });
  if (settings.camelCase) {
    argsObj = __camelCaseProps(argsObj);
  }
  Object.keys(argsObj).forEach((key) => {
    const value = argsObj[key];
    if (value === void 0)
      delete argsObj[key];
  });
  return argsObj;
}
function getAvailableInterfaceTypes() {
  if (__isNode())
    return global._registeredInterfacesTypes || {};
  else if (window !== void 0)
    return window._registeredInterfacesTypes || {};
  else
    return {};
}
try {
  if (global)
    global._registeredInterfacesTypes = {};
  else
    window._registeredInterfacesTypes = {};
} catch (e) {
}
class SInterface extends SClass {
  constructor(settings) {
    super(__deepMerge({
      stripUnkown: false
    }, settings !== null && settings !== void 0 ? settings : {}));
    this._definition = {};
    this._definition = this.constructor.definition;
  }
  static get definition() {
    var _a3;
    if (this._cachedDefinition)
      return this._cachedDefinition;
    this._cachedDefinition = (_a3 = this._definition) !== null && _a3 !== void 0 ? _a3 : {};
    return this._cachedDefinition;
  }
  static set definition(value) {
    this._cachedDefinition = value;
  }
  static registerRenderer(rendererClass) {
    if (!rendererClass.id) {
      throw new Error(`Sorry but the interface renderer "<yellow>${rendererClass.name}</yellow>" that you want to register is missing the required <yellow>static</yellow> <green>id</green> property...`);
    }
    this._registeredRenderers[rendererClass.id] = rendererClass;
  }
  static mix(...ints) {
    const newInt = new SInterface();
    ints.forEach((int) => {
      if (int.definition) {
        newInt.definition = __deepMerge(newInt.definition, int.definition);
      }
    });
    return newInt;
  }
  static override(definition2) {
    const _this = this;
    class SInterfaceOverrided extends this {
    }
    SInterfaceOverrided.overridedName = `${_this.name} (overrided)`;
    SInterfaceOverrided.definition = __deepMerge(_this.definition, definition2);
    return SInterfaceOverrided;
  }
  static isDefault(prop, value) {
    const defaults2 = this.defaults();
    if (defaults2[prop] === void 0) {
      return false;
    }
    if (defaults2[prop] === value) {
      return true;
    }
    return false;
  }
  static getAvailableTypes() {
    return getAvailableInterfaceTypes();
  }
  static makeAvailableAsType(name2 = null) {
    const n = (name2 || this.name).toLowerCase();
    if (global !== void 0) {
      global._registeredInterfacesTypes[n] = this;
      global._registeredInterfacesTypes[n.replace("interface", "")] = this;
    } else if (window !== void 0) {
      window._registeredInterfacesTypes[n] = this;
      window._registeredInterfacesTypes[n.replace("interface", "")] = this;
    }
  }
  static toObject() {
    var _a3;
    return {
      name: this.name,
      description: (_a3 = this.description) !== null && _a3 !== void 0 ? _a3 : "",
      definition: Object.assign({}, this.definition)
    };
  }
  static defaults() {
    const defaults2 = {};
    Object.keys(this.definition).forEach((key) => {
      const propObj = this.definition[key];
      if (propObj.default !== void 0) {
        defaults2[key] = propObj.default;
      }
    });
    return defaults2;
  }
  static apply(objectOrString, settings) {
    const int = new this({
      interface: settings !== null && settings !== void 0 ? settings : {}
    });
    return int.apply(objectOrString);
  }
  static render(renderer = "terminal", settings) {
    const set = __deepMerge({
      renderer: "terminal",
      exclude: ["help"]
    }, settings);
    if (!this._registeredRenderers[renderer]) {
      throw new Error(`Sorry but the requested renderer "<yellow>${renderer}</yellow>" does not exists... Here's the available renderers: <green>${Object.keys(this._registeredRenderers).join(", ")}</green>`);
    }
    const rendererInstance = new this._registeredRenderers[renderer](this, set);
    return rendererInstance.render();
  }
  apply(objectOrString, settings) {
    var _a3;
    const set = __deepMerge(this.settings, settings !== null && settings !== void 0 ? settings : {});
    let objectOnWhichToApplyInterface = objectOrString;
    if (typeof objectOrString === "string") {
      objectOnWhichToApplyInterface = __parseArgs(objectOrString);
      Object.keys(objectOnWhichToApplyInterface).forEach((argName) => {
        for (let i2 = 0; i2 < Object.keys(this._definition).length; i2++) {
          const defArgName = Object.keys(this._definition)[i2];
          const obj2 = this._definition[defArgName];
          if (obj2.explicit) {
            if (obj2.alias && ` ${objectOrString} `.match(new RegExp(`\\s-${obj2.alias}\\s`)))
              return;
            else if (` ${objectOrString} `.match(new RegExp(`\\s--${argName}\\s`)))
              return;
            delete objectOnWhichToApplyInterface[argName];
          }
        }
      });
      Object.keys(objectOnWhichToApplyInterface).forEach((argName) => {
        for (let i2 = 0; i2 < Object.keys(this._definition).length; i2++) {
          const defArgName = Object.keys(this._definition)[i2];
          const obj2 = this._definition[defArgName];
          if (!obj2.alias)
            continue;
          if (obj2.alias === argName && objectOnWhichToApplyInterface[defArgName] === void 0) {
            objectOnWhichToApplyInterface[defArgName] = objectOnWhichToApplyInterface[argName];
            delete objectOnWhichToApplyInterface[argName];
          }
        }
      });
      Object.keys(objectOnWhichToApplyInterface).forEach((argName, i2) => {
        if (argName === `${i2}`) {
          const definitionKeys = Object.keys(this._definition);
          if (definitionKeys[i2]) {
            objectOnWhichToApplyInterface[definitionKeys[i2]] = objectOnWhichToApplyInterface[argName];
          }
          delete objectOnWhichToApplyInterface[argName];
        }
      });
    }
    const descriptor2 = new SDescriptor(Object.assign({ type: "Object", rules: this._definition }, (_a3 = set.descriptor) !== null && _a3 !== void 0 ? _a3 : {}));
    if (set.baseObj) {
      objectOnWhichToApplyInterface = __deepMerge(set.baseObj, objectOnWhichToApplyInterface);
    }
    const descriptorResult = descriptor2.apply(objectOnWhichToApplyInterface);
    if (descriptorResult.hasIssues()) {
      throw new Error(descriptorResult.toString());
    }
    let resultObj = descriptorResult.value;
    if (!set.stripUnkown) {
      resultObj = __deepMerge(objectOnWhichToApplyInterface, resultObj);
    }
    return resultObj;
  }
}
SInterface.description = "";
SInterface._registeredRenderers = {};
class SStateLsAdapter {
  constructor(id2) {
    this.async = false;
    this._id = id2;
  }
  save(state) {
    window.localStorage.setItem(`state-${this._id}`, JSON.stringify(state));
  }
  load() {
    var _a3;
    return JSON.parse((_a3 = window.localStorage.getItem(`state-${this._id}`)) !== null && _a3 !== void 0 ? _a3 : "{}");
  }
}
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule());
};
var __awaiter$t = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SStateFsAdapter {
  constructor(id2, settings) {
    this.async = true;
    this._id = id2;
    this._settings = settings;
  }
  _init() {
    var _a3, _b2;
    return __awaiter$t(this, void 0, void 0, function* () {
      const _packageTmpDir = (yield __vitePreload(() => import("./packageTmpDir.233ec198.js"), true ? [] : void 0)).default;
      this._statesDir = (_b2 = (_a3 = this._settings) === null || _a3 === void 0 ? void 0 : _a3.folder) !== null && _b2 !== void 0 ? _b2 : `${_packageTmpDir()}/states`;
      this._stateFile = `${this._statesDir}/${this._id}.state.json`;
    });
  }
  save(state) {
    return new Promise((resolve) => __awaiter$t(this, void 0, void 0, function* () {
      const _fs = yield __vitePreload(() => import("./__vite-browser-external_fs.addc2852.js"), true ? [] : void 0);
      yield this._init();
      if (!_fs.existsSync(this._statesDir)) {
        _fs.mkdirSync(this._statesDir);
      }
      if (_fs.existsSync(this._stateFile)) {
        _fs.unlinkSync(this._stateFile);
      }
      _fs.writeFileSync(this._stateFile, JSON.stringify(state, null, 4));
      resolve();
    }));
  }
  load() {
    return new Promise((resolve) => __awaiter$t(this, void 0, void 0, function* () {
      const _fs = yield __vitePreload(() => import("./__vite-browser-external_fs.addc2852.js"), true ? [] : void 0);
      yield this._init();
      let fileContent = "{}";
      if (_fs.existsSync(this._stateFile)) {
        fileContent = _fs.readFileSync(this._stateFile, "utf-8").toString();
      }
      resolve(JSON.parse(fileContent));
    }));
  }
}
var __awaiter$s = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SState extends SClass {
  constructor(object, settings) {
    super(__deepMerge({
      watchDeep: false,
      save: false,
      exclude: []
    }, settings !== null && settings !== void 0 ? settings : {}));
    if (this.settings.save && !this.settings.id) {
      throw new Error(`You MUST set an id for your state when using the "save" setting. Pass an "id" in the settings...`);
    }
    if (this.settings.save && !this.settings.adapter) {
      if (__isNode()) {
        this.settings.adapter = new SStateFsAdapter(this.settings.id);
      } else {
        this.settings.adapter = new SStateLsAdapter(this.settings.id);
      }
    }
    let saveTimeout;
    const proxy = __deepProxy(object, (actionObj) => {
      switch (actionObj.action) {
        case "set":
          this._eventEmitter.emit(`set.${actionObj.path}`, actionObj);
          break;
        case "delete":
          this._eventEmitter.emit(`delete.${actionObj.path}`, actionObj);
          break;
      }
      if (this.settings.save) {
        clearTimeout(saveTimeout);
        saveTimeout = setTimeout(() => {
          const stateToSave = JSON.parse(JSON.stringify(proxy));
          this.settings.exclude.forEach((prop) => {
            delete stateToSave[prop];
          });
          this.settings.adapter.save(stateToSave);
        });
      }
    }, {
      deep: this.settings.watchDeep
    });
    this._eventEmitter = new SEventEmitter();
    const _this = this;
    Object.defineProperty(proxy, "$set", {
      enumerable: false,
      get() {
        return (event, handler) => {
          return _this._eventEmitter.on(`set.${event}`, handler);
        };
      }
    });
    Object.defineProperty(proxy, "$delete", {
      enumerable: false,
      get() {
        return (event, handler) => {
          return _this._eventEmitter.on(`delete.${event}`, handler);
        };
      }
    });
    Object.defineProperty(proxy, "isSState", {
      enumerable: false,
      get() {
        return true;
      }
    });
    if (this.settings.save) {
      if (this.settings.adapter.async) {
        (() => __awaiter$s(this, void 0, void 0, function* () {
          const restoredState = yield this.settings.adapter.load();
          __deepAssign(proxy, restoredState);
        }))();
      } else {
        const restoredState = this.settings.adapter.load();
        __deepAssign(proxy, restoredState);
      }
    }
    this._proxy = proxy;
    return proxy;
  }
}
class SStateManager extends SClass {
  constructor(settings) {
    super(__deepMerge({}, settings !== null && settings !== void 0 ? settings : {}));
  }
  define(id2, state, settings) {
    this[id2] = new SState(state, Object.assign({ save: this.settings.save, id: id2 }, settings));
    return this[id2];
  }
}
function orRegex(regexes, flag) {
  if (flag === void 0) {
    flag = "i";
  }
  return new RegExp(regexes.map(function(r) {
    return r.source;
  }).join("|"), flag);
}
var HEXADECIMAL = /^(([0-9a-f])+([.]([0-9a-f])+)?)$/i;
var HEX_SHORT_WITHOUT_ALPHA = /^#(?:([0-9a-f]{3}))$/i;
var HEX_SHORT_WITH_ALPHA = /^#(?:([0-9a-f]{3})([0-9a-f]{1}))$/i;
var HEX_SHORT = orRegex([HEX_SHORT_WITHOUT_ALPHA, HEX_SHORT_WITH_ALPHA]);
var HEX_LONG_WITHOUT_ALPHA = /^#(?:([0-9a-f]{6}))$/i;
var HEX_LONG_WITH_ALPHA = /^#(?:([0-9a-f]{6})([0-9a-f]{2}))$/i;
var HEX_LONG = orRegex([HEX_LONG_WITHOUT_ALPHA, HEX_LONG_WITH_ALPHA]);
var HEX_COLOR = orRegex([HEX_SHORT, HEX_LONG]);
var HEX_ALPHA = /[0-9a-f]{2}$/i;
var HEX_REGEX = {
  generic: HEXADECIMAL,
  shortWithoutAlpha: HEX_SHORT_WITHOUT_ALPHA,
  shortWithAlpha: HEX_SHORT_WITH_ALPHA,
  short: HEX_SHORT,
  longWithoutAlpha: HEX_LONG_WITHOUT_ALPHA,
  longWithAlpha: HEX_LONG_WITH_ALPHA,
  long: HEX_LONG,
  color: HEX_COLOR,
  alpha: HEX_ALPHA
};
function between(value, range2) {
  var min2 = Math.min.apply(Math, range2);
  var max2 = Math.max.apply(Math, range2);
  return value >= min2 && value <= max2;
}
function hexadecimalToDecimal(hexadecimal) {
  if (!HEX_REGEX.generic.test(hexadecimal))
    throw new Error(hexadecimal + " is not a valid hexadecimal string.");
  var _a3 = hexadecimal.split("."), integerPart = _a3[0], decimalPart = _a3[1];
  if (!decimalPart)
    return parseInt(integerPart, 16);
  return parseInt(integerPart, 16) + parseInt(decimalPart, 16) / Math.pow(16, decimalPart.length);
}
function sameContent(a3, b2) {
  return a3.sort().toString() === b2.sort().toString();
}
function applyFnToEachObjValue(obj2, fn2) {
  var newObj = Object.assign({}, obj2);
  Object.entries(newObj).forEach(function(_a3) {
    var key = _a3[0], value = _a3[1];
    newObj[key] = fn2(value);
  });
  return newObj;
}
function isHex(color2) {
  return HEX_REGEX.color.test(color2);
}
function isRgb(color2) {
  var keys3 = Object.keys(color2);
  if (keys3.length !== 3)
    return false;
  if (!sameContent(keys3, ["r", "g", "b"]))
    return false;
  var isValid = function(value) {
    return typeof value === "number" && between(value, [0, 255]);
  };
  var r = isValid(color2.r);
  var g2 = isValid(color2.g);
  var b2 = isValid(color2.b);
  return r && g2 && b2;
}
function isRgba(color2) {
  var keys3 = Object.keys(color2);
  if (keys3.length !== 4)
    return false;
  if (!sameContent(keys3, ["r", "g", "b", "a"]))
    return false;
  var r = color2.r, g2 = color2.g, b2 = color2.b;
  var isValidRgb = isRgb({ r, g: g2, b: b2 });
  var a3 = typeof color2.a === "number" && between(color2.a, [0, 1]);
  return isValidRgb && a3;
}
function isHsl(color2) {
  var keys3 = Object.keys(color2);
  if (keys3.length !== 3)
    return false;
  if (!sameContent(keys3, ["h", "s", "l"]))
    return false;
  var isValid = function(value, range2) {
    return typeof value === "number" && between(value, range2);
  };
  var h2 = isValid(color2.h, [0, 359]);
  var s2 = isValid(color2.s, [0, 100]);
  var l = isValid(color2.l, [0, 100]);
  return h2 && s2 && l;
}
function isHsla(color2) {
  var keys3 = Object.keys(color2);
  if (keys3.length !== 4)
    return false;
  if (!sameContent(keys3, ["h", "s", "l", "a"]))
    return false;
  var h2 = color2.h, s2 = color2.s, l = color2.l;
  var isValidHsl = isHsl({ h: h2, s: s2, l });
  var a3 = typeof color2.a === "number" && between(color2.a, [0, 1]);
  return isValidHsl && a3;
}
var lodash = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function(module, exports) {
  (function() {
    var undefined$12;
    var VERSION2 = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar2 = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result2[resIndex++] = value;
        }
      }
      return result2;
    }
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result2 = Array(length);
      while (++index < length) {
        result2[index] = iteratee(array[index], index, array);
      }
      return result2;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset2 = array.length;
      while (++index < length) {
        array[offset2 + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string2) {
      return string2.split("");
    }
    function asciiWords(string2) {
      return string2.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result2;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result2 = key;
          return false;
        }
      });
      return result2;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (comparator(array[index], value)) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined$12 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined$12 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result2, index = -1, length = array.length;
      while (++index < length) {
        var current = iteratee(array[index]);
        if (current !== undefined$12) {
          result2 = result2 === undefined$12 ? current : result2 + current;
        }
      }
      return result2;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result2 = Array(n);
      while (++index < n) {
        result2[index] = iteratee(index);
      }
      return result2;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseTrim(string2) {
      return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function cacheHas(cache2, key) {
      return cache2.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index = -1, length = strSymbols.length;
      while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index = strSymbols.length;
      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function countHolders(array, placeholder) {
      var length = array.length, result2 = 0;
      while (length--) {
        if (array[length] === placeholder) {
          ++result2;
        }
      }
      return result2;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object, key) {
      return object == null ? undefined$12 : object[key];
    }
    function hasUnicode(string2) {
      return reHasUnicode.test(string2);
    }
    function hasUnicodeWord(string2) {
      return reHasUnicodeWord.test(string2);
    }
    function iteratorToArray(iterator) {
      var data2, result2 = [];
      while (!(data2 = iterator.next()).done) {
        result2.push(data2.value);
      }
      return result2;
    }
    function mapToArray(map2) {
      var index = -1, result2 = Array(map2.size);
      map2.forEach(function(value, key) {
        result2[++index] = [key, value];
      });
      return result2;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index = -1, length = array.length, resIndex = 0, result2 = [];
      while (++index < length) {
        var value = array[index];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index] = PLACEHOLDER;
          result2[resIndex++] = index;
        }
      }
      return result2;
    }
    function setToArray(set) {
      var index = -1, result2 = Array(set.size);
      set.forEach(function(value) {
        result2[++index] = value;
      });
      return result2;
    }
    function setToPairs(set) {
      var index = -1, result2 = Array(set.size);
      set.forEach(function(value) {
        result2[++index] = [value, value];
      });
      return result2;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      var index = fromIndex + 1;
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return index;
    }
    function stringSize(string2) {
      return hasUnicode(string2) ? unicodeSize(string2) : asciiSize(string2);
    }
    function stringToArray(string2) {
      return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
    }
    function trimmedEndIndex(string2) {
      var index = string2.length;
      while (index-- && reWhitespace.test(string2.charAt(index))) {
      }
      return index;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string2) {
      var result2 = reUnicode.lastIndex = 0;
      while (reUnicode.test(string2)) {
        ++result2;
      }
      return result2;
    }
    function unicodeToArray(string2) {
      return string2.match(reUnicode) || [];
    }
    function unicodeWords(string2) {
      return string2.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context) {
      context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
      var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root._;
      var reIsNative = RegExp2(
        "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Buffer2 = moduleExports ? context.Buffer : undefined$12, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$12, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$12, symIterator = Symbol2 ? Symbol2.iterator : undefined$12, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$12;
      var defineProperty3 = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$12, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2();
      var realNames = {};
      var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined$12, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$12, symbolToString = symbolProto ? symbolProto.toString : undefined$12;
      function lodash2(value) {
        if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty2.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = function() {
        function object() {
        }
        return function(proto2) {
          if (!isObject3(proto2)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto2);
          }
          object.prototype = proto2;
          var result3 = new object();
          object.prototype = undefined$12;
          return result3;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$12;
      }
      lodash2.templateSettings = {
        "escape": reEscape,
        "evaluate": reEvaluate,
        "interpolate": reInterpolate,
        "variable": "",
        "imports": {
          "_": lodash2
        }
      };
      lodash2.prototype = baseLodash.prototype;
      lodash2.prototype.constructor = lodash2;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result3 = new LazyWrapper(this.__wrapped__);
        result3.__actions__ = copyArray(this.__actions__);
        result3.__dir__ = this.__dir__;
        result3.__filtered__ = this.__filtered__;
        result3.__iteratees__ = copyArray(this.__iteratees__);
        result3.__takeCount__ = this.__takeCount__;
        result3.__views__ = copyArray(this.__views__);
        return result3;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result3 = new LazyWrapper(this);
          result3.__dir__ = -1;
          result3.__filtered__ = true;
        } else {
          result3 = this.clone();
          result3.__dir__ *= -1;
        }
        return result3;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result3 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1, value = array[index];
            while (++iterIndex < iterLength) {
              var data2 = iteratees[iterIndex], iteratee2 = data2.iteratee, type = data2.type, computed = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result3[resIndex++] = value;
          }
        return result3;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result3 = this.has(key) && delete this.__data__[key];
        this.size -= result3 ? 1 : 0;
        return result3;
      }
      function hashGet(key) {
        var data2 = this.__data__;
        if (nativeCreate) {
          var result3 = data2[key];
          return result3 === HASH_UNDEFINED ? undefined$12 : result3;
        }
        return hasOwnProperty2.call(data2, key) ? data2[key] : undefined$12;
      }
      function hashHas(key) {
        var data2 = this.__data__;
        return nativeCreate ? data2[key] !== undefined$12 : hasOwnProperty2.call(data2, key);
      }
      function hashSet(key, value) {
        var data2 = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data2[key] = nativeCreate && value === undefined$12 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data2 = this.__data__, index = assocIndexOf(data2, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data2.length - 1;
        if (index == lastIndex) {
          data2.pop();
        } else {
          splice.call(data2, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data2 = this.__data__, index = assocIndexOf(data2, key);
        return index < 0 ? undefined$12 : data2[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data2 = this.__data__, index = assocIndexOf(data2, key);
        if (index < 0) {
          ++this.size;
          data2.push([key, value]);
        } else {
          data2[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key) {
        var result3 = getMapData(this, key)["delete"](key);
        this.size -= result3 ? 1 : 0;
        return result3;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data2 = getMapData(this, key), size2 = data2.size;
        data2.set(key, value);
        this.size += data2.size == size2 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values2[index]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data2 = this.__data__ = new ListCache(entries);
        this.size = data2.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data2 = this.__data__, result3 = data2["delete"](key);
        this.size = data2.size;
        return result3;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data2 = this.__data__;
        if (data2 instanceof ListCache) {
          var pairs = data2.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data2.size;
            return this;
          }
          data2 = this.__data__ = new MapCache(pairs);
        }
        data2.set(key, value);
        this.size = data2.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray2(value), isArg = !isArr && isArguments5(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result3 = skipIndexes ? baseTimes(value.length, String2) : [], length = result3.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
            result3.push(key);
          }
        }
        return result3;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined$12;
      }
      function arraySampleSize(array, n) {
        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object, key, value) {
        if (value !== undefined$12 && !eq(object[key], value) || value === undefined$12 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === undefined$12 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source2) {
        return object && copyObject(source2, keys3(source2), object);
      }
      function baseAssignIn(object, source2) {
        return object && copyObject(source2, keysIn(source2), object);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty3) {
          defineProperty3(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      function baseAt(object, paths) {
        var index = -1, length = paths.length, result3 = Array2(length), skip = object == null;
        while (++index < length) {
          result3[index] = skip ? undefined$12 : get2(object, paths[index]);
        }
        return result3;
      }
      function baseClamp(number2, lower, upper) {
        if (number2 === number2) {
          if (upper !== undefined$12) {
            number2 = number2 <= upper ? number2 : upper;
          }
          if (lower !== undefined$12) {
            number2 = number2 >= lower ? number2 : lower;
          }
        }
        return number2;
      }
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result3, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result3 = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result3 !== undefined$12) {
          return result3;
        }
        if (!isObject3(value)) {
          return value;
        }
        var isArr = isArray2(value);
        if (isArr) {
          result3 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result3);
          }
        } else {
          var tag2 = getTag(value), isFunc = tag2 == funcTag || tag2 == genTag;
          if (isBuffer2(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag2 == objectTag || tag2 == argsTag || isFunc && !object) {
            result3 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result3, value)) : copySymbols(value, baseAssign(result3, value));
            }
          } else {
            if (!cloneableTags[tag2]) {
              return object ? value : {};
            }
            result3 = initCloneByTag(value, tag2, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result3);
        if (isSet3(value)) {
          value.forEach(function(subValue) {
            result3.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap3(value)) {
          value.forEach(function(subValue, key2) {
            result3.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys3;
        var props = isArr ? undefined$12 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result3, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result3;
      }
      function baseConforms(source2) {
        var props = keys3(source2);
        return function(object) {
          return baseConformsTo(object, source2, props);
        };
      }
      function baseConformsTo(object, source2, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key = props[length], predicate = source2[key], value = object[key];
          if (value === undefined$12 && !(key in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined$12, args);
        }, wait);
      }
      function baseDifference(array, values2, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result3 = [], valuesLength = values2.length;
        if (!length) {
          return result3;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result3.push(value);
            } else if (!includes2(values2, computed, comparator)) {
              result3.push(value);
            }
          }
        return result3;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result3 = true;
        baseEach(collection, function(value, index, collection2) {
          result3 = !!predicate(value, index, collection2);
          return result3;
        });
        return result3;
      }
      function baseExtremum(array, iteratee2, comparator) {
        var index = -1, length = array.length;
        while (++index < length) {
          var value = array[index], current = iteratee2(value);
          if (current != null && (computed === undefined$12 ? current === current && !isSymbol2(current) : comparator(current, computed))) {
            var computed = current, result3 = value;
          }
        }
        return result3;
      }
      function baseFill(array, value, start, end) {
        var length = array.length;
        start = toInteger2(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === undefined$12 || end > length ? length : toInteger2(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array[start++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result3 = [];
        baseEach(collection, function(value, index, collection2) {
          if (predicate(value, index, collection2)) {
            result3.push(value);
          }
        });
        return result3;
      }
      function baseFlatten(array, depth, predicate, isStrict, result3) {
        var index = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result3 || (result3 = []);
        while (++index < length) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result3);
            } else {
              arrayPush(result3, value);
            }
          } else if (!isStrict) {
            result3[result3.length] = value;
          }
        }
        return result3;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys3);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys3);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction2(object[key]);
        });
      }
      function baseGet(object, path2) {
        path2 = castPath(path2, object);
        var index = 0, length = path2.length;
        while (object != null && index < length) {
          object = object[toKey(path2[index++])];
        }
        return index && index == length ? object : undefined$12;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result3 = keysFunc(object);
        return isArray2(object) ? result3 : arrayPush(result3, symbolsFunc(object));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined$12 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key) {
        return object != null && hasOwnProperty2.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      function baseInRange(number2, start, end) {
        return number2 >= nativeMin(start, end) && number2 < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result3 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$12;
        }
        array = arrays[0];
        var index = -1, seen2 = caches[0];
        outer:
          while (++index < length && result3.length < maxLength) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen2 ? cacheHas(seen2, computed) : includes2(result3, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache2 = caches[othIndex];
                if (!(cache2 ? cacheHas(cache2, computed) : includes2(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen2) {
                seen2.push(computed);
              }
              result3.push(value);
            }
          }
        return result3;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value, key, object2) {
          setter(accumulator, iteratee2(value), key, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path2, args) {
        path2 = castPath(path2, object);
        object = parent(object, path2);
        var func = object == null ? object : object[toKey(last(path2))];
        return func == null ? undefined$12 : apply(func, object, args);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer2(object)) {
          if (!isBuffer2(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object, source2, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index--) {
          var data2 = matchData[index];
          if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data2 = matchData[index];
          var key = data2[0], objValue = object[key], srcValue = data2[1];
          if (noCustomizer && data2[2]) {
            if (objValue === undefined$12 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result3 = customizer(objValue, srcValue, key, object, source2, stack);
            }
            if (!(result3 === undefined$12 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result3)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject3(value) || isMasked(value)) {
          return false;
        }
        var pattern2 = isFunction2(value) ? reIsNative : reIsHostCtor;
        return pattern2.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity2;
        }
        if (typeof value == "object") {
          return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype2(object)) {
          return nativeKeys(object);
        }
        var result3 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty2.call(object, key) && key != "constructor") {
            result3.push(key);
          }
        }
        return result3;
      }
      function baseKeysIn(object) {
        if (!isObject3(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype2(object), result3 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
            result3.push(key);
          }
        }
        return result3;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index = -1, result3 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result3[++index] = iteratee2(value, key, collection2);
        });
        return result3;
      }
      function baseMatches(source2) {
        var matchData = getMatchData(source2);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source2 || baseIsMatch(object, source2, matchData);
        };
      }
      function baseMatchesProperty(path2, srcValue) {
        if (isKey(path2) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path2), srcValue);
        }
        return function(object) {
          var objValue = get2(object, path2);
          return objValue === undefined$12 && objValue === srcValue ? hasIn(object, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source2, srcIndex, customizer, stack) {
        if (object === source2) {
          return;
        }
        baseFor(source2, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject3(srcValue)) {
            baseMergeDeep(object, source2, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source2, stack) : undefined$12;
            if (newValue === undefined$12) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source2, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source2, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source2, stack) : undefined$12;
        var isCommon = newValue === undefined$12;
        if (isCommon) {
          var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray2(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject3(srcValue) || isArguments5(srcValue)) {
            newValue = objValue;
            if (isArguments5(objValue)) {
              newValue = toPlainObject2(objValue);
            } else if (!isObject3(objValue) || isFunction2(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseNth(array, n) {
        var length = array.length;
        if (!length) {
          return;
        }
        n += n < 0 ? length : 0;
        return isIndex(n, length) ? array[n] : undefined$12;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray2(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity2];
        }
        var index = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result3 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { "criteria": criteria, "index": ++index, "value": value };
        });
        return baseSortBy(result3, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path2) {
          return hasIn(object, path2);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index = -1, length = paths.length, result3 = {};
        while (++index < length) {
          var path2 = paths[index], value = baseGet(object, path2);
          if (predicate(value, path2)) {
            baseSet(result3, castPath(path2, object), value);
          }
        }
        return result3;
      }
      function basePropertyDeep(path2) {
        return function(object) {
          return baseGet(object, path2);
        };
      }
      function basePullAll(array, values2, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen2 = array;
        if (array === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen2 = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index < length) {
          var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf2(seen2, computed, fromIndex, comparator)) > -1) {
            if (seen2 !== array) {
              splice.call(seen2, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index = indexes[length];
          if (length == lastIndex || index !== previous) {
            var previous = index;
            if (isIndex(index)) {
              splice.call(array, index, 1);
            } else {
              baseUnset(array, index);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result3 = Array2(length);
        while (length--) {
          result3[fromRight ? length : ++index] = start;
          start += step;
        }
        return result3;
      }
      function baseRepeat(string2, n) {
        var result3 = "";
        if (!string2 || n < 1 || n > MAX_SAFE_INTEGER) {
          return result3;
        }
        do {
          if (n % 2) {
            result3 += string2;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string2 += string2;
          }
        } while (n);
        return result3;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity2), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n, 0, array.length));
      }
      function baseSet(object, path2, value, customizer) {
        if (!isObject3(object)) {
          return object;
        }
        path2 = castPath(path2, object);
        var index = -1, length = path2.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index < length) {
          var key = toKey(path2[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined$12;
            if (newValue === undefined$12) {
              newValue = isObject3(objValue) ? objValue : isIndex(path2[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity2 : function(func, data2) {
        metaMap.set(func, data2);
        return func;
      };
      var baseSetToString = !defineProperty3 ? identity2 : function(func, string2) {
        return defineProperty3(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string2),
          "writable": true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array, start, end) {
        var index = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result3 = Array2(length);
        while (++index < length) {
          result3[index] = array[index + start];
        }
        return result3;
      }
      function baseSome(collection, predicate) {
        var result3;
        baseEach(collection, function(value, index, collection2) {
          result3 = predicate(value, index, collection2);
          return !result3;
        });
        return !!result3;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed = array[mid];
            if (computed !== null && !isSymbol2(computed) && (retHighest ? computed <= value : computed < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity2, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol2(value), valIsUndefined = value === undefined$12;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined$12, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol2(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value : computed < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index = -1, length = array.length, resIndex = 0, result3 = [];
        while (++index < length) {
          var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
          if (!index || !eq(computed, seen2)) {
            var seen2 = computed;
            result3[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result3;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray2(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol2(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result3 = value + "";
        return result3 == "0" && 1 / value == -INFINITY ? "-0" : result3;
      }
      function baseUniq(array, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result3 = [], seen2 = result3;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set2 = iteratee2 ? null : createSet(array);
          if (set2) {
            return setToArray(set2);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen2 = new SetCache();
        } else {
          seen2 = iteratee2 ? [] : result3;
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen2.length;
              while (seenIndex--) {
                if (seen2[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen2.push(computed);
              }
              result3.push(value);
            } else if (!includes2(seen2, computed, comparator)) {
              if (seen2 !== result3) {
                seen2.push(computed);
              }
              result3.push(value);
            }
          }
        return result3;
      }
      function baseUnset(object, path2) {
        path2 = castPath(path2, object);
        object = parent(object, path2);
        return object == null || delete object[toKey(last(path2))];
      }
      function baseUpdate(object, path2, updater, customizer) {
        return baseSet(object, path2, updater(baseGet(object, path2)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index = fromRight ? length : -1;
        while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
      }
      function baseWrapperValue(value, actions) {
        var result3 = value;
        if (result3 instanceof LazyWrapper) {
          result3 = result3.value();
        }
        return arrayReduce(actions, function(result4, action) {
          return action.func.apply(action.thisArg, arrayPush([result4], action.args));
        }, result3);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index = -1, result3 = Array2(length);
        while (++index < length) {
          var array = arrays[index], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index) {
              result3[index] = baseDifference(result3[index] || array, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result3, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values2, assignFunc) {
        var index = -1, length = props.length, valsLength = values2.length, result3 = {};
        while (++index < length) {
          var value = index < valsLength ? values2[index] : undefined$12;
          assignFunc(result3, props[index], value);
        }
        return result3;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity2;
      }
      function castPath(value, object) {
        if (isArray2(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath3(toString2(value));
      }
      var castRest = baseRest;
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === undefined$12 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id2) {
        return root.clearTimeout(id2);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result3 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result3);
        return result3;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result3 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result3).set(new Uint8Array2(arrayBuffer));
        return result3;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result3 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result3.lastIndex = regexp.lastIndex;
        return result3;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined$12, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
          var othIsDefined = other !== undefined$12, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index < length) {
          var result3 = compareAscending(objCriteria[index], othCriteria[index]);
          if (result3) {
            if (index >= ordersLength) {
              return result3;
            }
            var order = orders[index];
            return result3 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result3 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result3[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result3[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result3[leftIndex++] = args[argsIndex++];
        }
        return result3;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result3 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result3[argsIndex] = args[argsIndex];
        }
        var offset2 = argsIndex;
        while (++rightIndex < rightLength) {
          result3[offset2 + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result3[offset2 + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result3;
      }
      function copyArray(source2, array) {
        var index = -1, length = source2.length;
        array || (array = Array2(length));
        while (++index < length) {
          array[index] = source2[index];
        }
        return array;
      }
      function copyObject(source2, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source2[key], key, object, source2) : undefined$12;
          if (newValue === undefined$12) {
            newValue = source2[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols(source2, object) {
        return copyObject(source2, getSymbols(source2), object);
      }
      function copySymbolsIn(source2, object) {
        return copyObject(source2, getSymbolsIn(source2), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$12, guard = length > 2 ? sources[2] : undefined$12;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$12;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined$12 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index < length) {
            var source2 = sources[index];
            if (source2) {
              assigner(object, source2, index, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee2(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn2.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string2) {
          string2 = toString2(string2);
          var strSymbols = hasUnicode(string2) ? stringToArray(string2) : undefined$12;
          var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string2) {
          return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result3 = Ctor.apply(thisBinding, args);
          return isObject3(result3) ? result3 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
          while (index--) {
            args[index] = arguments[index];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              undefined$12,
              args,
              holders,
              undefined$12,
              undefined$12,
              arity - length
            );
          }
          var fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply(fn2, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys3(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined$12;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index--) {
            var func = funcs[index];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index = wrapper ? index : length;
          while (++index < length) {
            func = funcs[index];
            var funcName = getFuncName(func), data2 = funcName == "wrapper" ? getData(func) : undefined$12;
            if (data2 && isLaziable(data2[0]) && data2[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data2[4].length && data2[9] == 1) {
              wrapper = wrapper[getFuncName(data2[0])].apply(wrapper, data2[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray2(value)) {
              return wrapper.plant(value).value();
            }
            var index2 = 0, result3 = length ? funcs[index2].apply(this, args) : value;
            while (++index2 < length) {
              result3 = funcs[index2].call(this, result3);
            }
            return result3;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$12 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length;
          while (index--) {
            args[index] = arguments[index];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              thisArg,
              args,
              newHolders,
              argPos,
              ary2,
              arity - length
            );
          }
          var thisBinding = isBind ? thisArg : this, fn2 = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn2 = Ctor || createCtor(fn2);
          }
          return fn2.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result3;
          if (value === undefined$12 && other === undefined$12) {
            return defaultValue;
          }
          if (value !== undefined$12) {
            result3 = value;
          }
          if (other !== undefined$12) {
            if (result3 === undefined$12) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result3 = operator(value, other);
          }
          return result3;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars2) {
        chars2 = chars2 === undefined$12 ? " " : baseToString(chars2);
        var charsLength = chars2.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars2, length) : chars2;
        }
        var result3 = baseRepeat(chars2, nativeCeil(length / stringSize(chars2)));
        return hasUnicode(chars2) ? castSlice(stringToArray(result3), 0, length).join("") : result3.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn2, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = undefined$12;
          }
          start = toFinite(start);
          if (end === undefined$12) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined$12 ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber(value);
            other = toNumber(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$12, newHoldersRight = isCurry ? undefined$12 : holders, newPartials = isCurry ? partials : undefined$12, newPartialsRight = isCurry ? undefined$12 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result3 = wrapFunc.apply(undefined$12, newData);
        if (isLaziable(func)) {
          setData(result3, newData);
        }
        result3.placeholder = placeholder;
        return setWrapToString(result3, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number2, precision) {
          number2 = toNumber(number2);
          precision = precision == null ? 0 : nativeMin(toInteger2(precision), 292);
          if (precision && nativeIsFinite(number2)) {
            var pair = (toString2(number2) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString2(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number2);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
        return new Set2(values2);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag2 = getTag(object);
          if (tag2 == mapTag) {
            return mapToArray(object);
          }
          if (tag2 == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$12;
        }
        ary2 = ary2 === undefined$12 ? ary2 : nativeMax(toInteger2(ary2), 0);
        arity = arity === undefined$12 ? arity : toInteger2(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$12;
        }
        var data2 = isBindKey ? undefined$12 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data2) {
          mergeData(newData, data2);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$12 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result3 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result3 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result3 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result3 = createHybrid.apply(undefined$12, newData);
        }
        var setter = data2 ? baseSetData : setData;
        return setWrapToString(setter(result3, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined$12 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source2, stack) {
        if (isObject3(objValue) && isObject3(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined$12, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject3(value) ? undefined$12 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result3 = true, seen2 = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$12;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== undefined$12) {
            if (compared) {
              continue;
            }
            result3 = false;
            break;
          }
          if (seen2) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen2, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen2.push(othIndex);
              }
            })) {
              result3 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result3 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result3;
      }
      function equalByTag(object, other, tag2, bitmask, customizer, equalFunc, stack) {
        switch (tag2) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert2 = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert2 || (convert2 = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result3 = equalArrays(convert2(object), convert2(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result3;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result3 = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined$12 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result3 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result3 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result3 = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result3;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined$12, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys3, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop2 : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result3 = func.name + "", array = realNames[result3], length = hasOwnProperty2.call(realNames, result3) ? array.length : 0;
        while (length--) {
          var data2 = array[length], otherFunc = data2.func;
          if (otherFunc == null || otherFunc == func) {
            return data2.name;
          }
        }
        return result3;
      }
      function getHolder(func) {
        var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result3 = lodash2.iteratee || iteratee;
        result3 = result3 === iteratee ? baseIteratee : result3;
        return arguments.length ? result3(arguments[0], arguments[1]) : result3;
      }
      function getMapData(map3, key) {
        var data2 = map3.__data__;
        return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
      }
      function getMatchData(object) {
        var result3 = keys3(object), length = result3.length;
        while (length--) {
          var key = result3[length], value = object[key];
          result3[length] = [key, value, isStrictComparable(value)];
        }
        return result3;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined$12;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag), tag2 = value[symToStringTag];
        try {
          value[symToStringTag] = undefined$12;
          var unmasked = true;
        } catch (e) {
        }
        var result3 = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag2;
          } else {
            delete value[symToStringTag];
          }
        }
        return result3;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result3 = [];
        while (object) {
          arrayPush(result3, getSymbols(object));
          object = getPrototype(object);
        }
        return result3;
      };
      var getTag = baseGetTag;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result3 = baseGetTag(value), Ctor = result3 == objectTag ? value.constructor : undefined$12, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result3;
        };
      }
      function getView(start, end, transforms) {
        var index = -1, length = transforms.length;
        while (++index < length) {
          var data2 = transforms[index], size2 = data2.size;
          switch (data2.type) {
            case "drop":
              start += size2;
              break;
            case "dropRight":
              end -= size2;
              break;
            case "take":
              end = nativeMin(end, start + size2);
              break;
            case "takeRight":
              start = nativeMax(start, end - size2);
              break;
          }
        }
        return { "start": start, "end": end };
      }
      function getWrapDetails(source2) {
        var match5 = source2.match(reWrapDetails);
        return match5 ? match5[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path2, hasFunc) {
        path2 = castPath(path2, object);
        var index = -1, length = path2.length, result3 = false;
        while (++index < length) {
          var key = toKey(path2[index]);
          if (!(result3 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result3 || ++index != length) {
          return result3;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments5(object));
      }
      function initCloneArray(array) {
        var length = array.length, result3 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
          result3.index = array.index;
          result3.input = array.input;
        }
        return result3;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype2(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag2, isDeep) {
        var Ctor = object.constructor;
        switch (tag2) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source2, details) {
        var length = details.length;
        if (!length) {
          return source2;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source2.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray2(value) || isArguments5(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index, object) {
        if (!isObject3(object)) {
          return false;
        }
        var type = typeof index;
        if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
          return eq(object[index], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray2(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol2(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data2 = getData(other);
        return !!data2 && func === data2[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction2 : stubFalse;
      function isPrototype2(value) {
        var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto2;
      }
      function isStrictComparable(value) {
        return value === value && !isObject3(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined$12 || key in Object2(object));
        };
      }
      function memoizeCapped(func) {
        var result3 = memoize2(func, function(key) {
          if (cache2.size === MAX_MEMOIZE_SIZE) {
            cache2.clear();
          }
          return key;
        });
        var cache2 = result3.cache;
        return result3;
      }
      function mergeData(data2, source2) {
        var bitmask = data2[1], srcBitmask = source2[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data2[7].length <= source2[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source2[7].length <= source2[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data2;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data2[2] = source2[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source2[3];
        if (value) {
          var partials = data2[3];
          data2[3] = partials ? composeArgs(partials, value, source2[4]) : value;
          data2[4] = partials ? replaceHolders(data2[3], PLACEHOLDER) : source2[4];
        }
        value = source2[5];
        if (value) {
          partials = data2[5];
          data2[5] = partials ? composeArgsRight(partials, value, source2[6]) : value;
          data2[6] = partials ? replaceHolders(data2[5], PLACEHOLDER) : source2[6];
        }
        value = source2[7];
        if (value) {
          data2[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data2[8] = data2[8] == null ? source2[8] : nativeMin(data2[8], source2[8]);
        }
        if (data2[9] == null) {
          data2[9] = source2[9];
        }
        data2[0] = source2[0];
        data2[1] = newBitmask;
        return data2;
      }
      function nativeKeysIn(object) {
        var result3 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result3.push(key);
          }
        }
        return result3;
      }
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start, transform2) {
        start = nativeMax(start === undefined$12 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
          while (++index < length) {
            array[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array2(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform2(array);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object, path2) {
        return path2.length < 2 ? object : baseGet(object, baseSlice(path2, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length--) {
          var index = indexes[length];
          array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$12;
        }
        return array;
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source2 = reference + "";
        return setToString(wrapper, insertWrapDetails(source2, updateWrapDetails(getWrapDetails(source2), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined$12, arguments);
        };
      }
      function shuffleSelf(array, size2) {
        var index = -1, length = array.length, lastIndex = length - 1;
        size2 = size2 === undefined$12 ? length : size2;
        while (++index < size2) {
          var rand = baseRandom(index, lastIndex), value = array[rand];
          array[rand] = array[index];
          array[index] = value;
        }
        array.length = size2;
        return array;
      }
      var stringToPath3 = memoizeCapped(function(string2) {
        var result3 = [];
        if (string2.charCodeAt(0) === 46) {
          result3.push("");
        }
        string2.replace(rePropName2, function(match5, number2, quote, subString) {
          result3.push(quote ? subString.replace(reEscapeChar2, "$1") : number2 || match5);
        });
        return result3;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol2(value)) {
          return value;
        }
        var result3 = value + "";
        return result3 == "0" && 1 / value == -INFINITY ? "-0" : result3;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result3 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result3.__actions__ = copyArray(wrapper.__actions__);
        result3.__index__ = wrapper.__index__;
        result3.__values__ = wrapper.__values__;
        return result3;
      }
      function chunk(array, size2, guard) {
        if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined$12) {
          size2 = 1;
        } else {
          size2 = nativeMax(toInteger2(size2), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size2 < 1) {
          return [];
        }
        var index = 0, resIndex = 0, result3 = Array2(nativeCeil(length / size2));
        while (index < length) {
          result3[resIndex++] = baseSlice(array, index, index += size2);
        }
        return result3;
      }
      function compact(array) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result3 = [];
        while (++index < length) {
          var value = array[index];
          if (value) {
            result3[resIndex++] = value;
          }
        }
        return result3;
      }
      function concat2() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array = arguments[0], index = length;
        while (index--) {
          args[index - 1] = arguments[index];
        }
        return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$12;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values2) {
        var comparator = last(values2);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined$12;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$12, comparator) : [];
      });
      function drop(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$12 ? 1 : toInteger2(n);
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function dropRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$12 ? 1 : toInteger2(n);
        n = length - n;
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array, value, start, end);
      }
      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger2(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length - 1;
        if (fromIndex !== undefined$12) {
          index = toInteger2(fromIndex);
          index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index, true);
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined$12 ? 1 : toInteger2(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs) {
        var index = -1, length = pairs == null ? 0 : pairs.length, result3 = {};
        while (++index < length) {
          var pair = pairs[index];
          result3[pair[0]] = pair[1];
        }
        return result3;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined$12;
      }
      function indexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger2(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseIndexOf(array, value, index);
      }
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined$12;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined$12;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$12, comparator) : [];
      });
      function join(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined$12;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length;
        if (fromIndex !== undefined$12) {
          index = toInteger2(fromIndex);
          index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
      }
      function nth(array, n) {
        return array && array.length ? baseNth(array, toInteger2(n)) : undefined$12;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
      }
      function pullAllBy(array, values2, iteratee2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values2, comparator) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$12, comparator) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result3 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index) {
          return isIndex(index, length) ? +index : index;
        }).sort(compareAscending));
        return result3;
      });
      function remove(array, predicate) {
        var result3 = [];
        if (!(array && array.length)) {
          return result3;
        }
        var index = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result3.push(value);
            indexes.push(index);
          }
        }
        basePullAt(array, indexes);
        return result3;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice2(array, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger2(start);
          end = end === undefined$12 ? length : toInteger2(end);
        }
        return baseSlice(array, start, end);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value);
          if (index < length && eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value, true) - 1;
          if (eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      function take(array, n, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n = guard || n === undefined$12 ? 1 : toInteger2(n);
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function takeRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$12 ? 1 : toInteger2(n);
        n = length - n;
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$12;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$12;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$12, comparator);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined$12;
        return array && array.length ? baseUniq(array, undefined$12, comparator) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index) {
          return arrayMap(array, baseProperty(index));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result3 = unzip(array);
        if (iteratee2 == null) {
          return result3;
        }
        return arrayMap(result3, function(group) {
          return apply(iteratee2, undefined$12, group);
        });
      }
      var without = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$12;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$12;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$12, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$12;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$12;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result3 = lodash2(value);
        result3.__chain__ = true;
        return result3;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value = value.slice(start, +start + (length ? 1 : 0));
        value.__actions__.push({
          "func": thru,
          "args": [interceptor],
          "thisArg": undefined$12
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined$12);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined$12) {
          this.__values__ = toArray2(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined$12 : this.__values__[this.__index__++];
        return { "done": done, "value": value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result3, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone3 = wrapperClone(parent2);
          clone3.__index__ = 0;
          clone3.__values__ = undefined$12;
          if (result3) {
            previous.__wrapped__ = clone3;
          } else {
            result3 = clone3;
          }
          var previous = clone3;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result3;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            "func": thru,
            "args": [reverse],
            "thisArg": undefined$12
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result3, value, key) {
        if (hasOwnProperty2.call(result3, key)) {
          ++result3[key];
        } else {
          baseAssignValue(result3, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray2(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$12;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter2(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined$12 ? 1 : toInteger2(depth);
        return baseFlatten(map2(collection, iteratee2), depth);
      }
      function forEach4(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result3, value, key) {
        if (hasOwnProperty2.call(result3, key)) {
          result3[key].push(value);
        } else {
          baseAssignValue(result3, key, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger2(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString3(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path2, args) {
        var index = -1, isFunc = typeof path2 == "function", result3 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result3[++index] = isFunc ? apply(path2, value, args) : baseInvoke(value, path2, args);
        });
        return result3;
      });
      var keyBy = createAggregator(function(result3, value, key) {
        baseAssignValue(result3, key, value);
      });
      function map2(collection, iteratee2) {
        var func = isArray2(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray2(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined$12 : orders;
        if (!isArray2(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result3, value, key) {
        result3[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray2(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n, guard) {
        if (guard ? isIterateeCall(collection, n, guard) : n === undefined$12) {
          n = 1;
        } else {
          n = toInteger2(n);
        }
        var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n);
      }
      function shuffle(collection) {
        var func = isArray2(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString3(collection) ? stringSize(collection) : collection.length;
        }
        var tag2 = getTag(collection);
        if (tag2 == mapTag || tag2 == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray2(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$12;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function() {
        return root.Date.now();
      };
      function after(n, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger2(n);
        return function() {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n, guard) {
        n = guard ? undefined$12 : n;
        n = func && n == null ? func.length : n;
        return createWrap(func, WRAP_ARY_FLAG, undefined$12, undefined$12, undefined$12, undefined$12, n);
      }
      function before(n, func) {
        var result3;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger2(n);
        return function() {
          if (--n > 0) {
            result3 = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = undefined$12;
          }
          return result3;
        };
      }
      var bind4 = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind4));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined$12 : arity;
        var result3 = createWrap(func, WRAP_CURRY_FLAG, undefined$12, undefined$12, undefined$12, undefined$12, undefined$12, arity);
        result3.placeholder = curry.placeholder;
        return result3;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$12 : arity;
        var result3 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$12, undefined$12, undefined$12, undefined$12, undefined$12, arity);
        result3.placeholder = curryRight.placeholder;
        return result3;
      }
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result3, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject3(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined$12;
          lastInvokeTime = time;
          result3 = func.apply(thisArg, args);
          return result3;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result3;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined$12 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined$12;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined$12;
          return result3;
        }
        function cancel() {
          if (timerId !== undefined$12) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$12;
        }
        function flush() {
          return timerId === undefined$12 ? result3 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined$12) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$12) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result3;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });
      function flip2(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize2(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
          if (cache2.has(key)) {
            return cache2.get(key);
          }
          var result3 = func.apply(this, args);
          memoized.cache = cache2.set(key, result3) || cache2;
          return result3;
        };
        memoized.cache = new (memoize2.Cache || MapCache)();
        return memoized;
      }
      memoize2.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index = -1, length = nativeMin(args.length, funcsLength);
          while (++index < length) {
            args[index] = transforms[index].call(this, args[index]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$12, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$12, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$12, undefined$12, undefined$12, indexes);
      });
      function rest(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start === undefined$12 ? start : toInteger2(start);
        return baseRest(func, start);
      }
      function spread2(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger2(start), 0);
        return baseRest(function(args) {
          var array = args[start], otherArgs = castSlice(args, 0, start);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject3(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap2(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray2(value) ? value : [value];
      }
      function clone2(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source2) {
        return source2 == null || baseConformsTo(object, source2, keys3(source2));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt2 = createRelationalOperation(baseGt);
      var gte2 = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments5 = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray2 = Array2.isArray;
      var isArrayBuffer2 = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction2(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function isBoolean3(value) {
        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
      }
      var isBuffer2 = nativeIsBuffer || stubFalse;
      var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement2(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject3(value);
      }
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray2(value) || isArguments5(value))) {
          return !value.length;
        }
        var tag2 = getTag(value);
        if (tag2 == mapTag || tag2 == setTag) {
          return !value.size;
        }
        if (isPrototype2(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty2.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        var result3 = customizer ? customizer(value, other) : undefined$12;
        return result3 === undefined$12 ? baseIsEqual(value, other, undefined$12, customizer) : !!result3;
      }
      function isError2(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        var tag2 = baseGetTag(value);
        return tag2 == errorTag || tag2 == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject3(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction2(value) {
        if (!isObject3(value)) {
          return false;
        }
        var tag2 = baseGetTag(value);
        return tag2 == funcTag || tag2 == genTag || tag2 == asyncTag || tag2 == proxyTag;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger2(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject3(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isMap3 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source2) {
        return object === source2 || baseIsMatch(object, source2, getMatchData(source2));
      }
      function isMatchWith(object, source2, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        return baseIsMatch(object, source2, getMatchData(source2), customizer);
      }
      function isNaN2(value) {
        return isNumber2(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber2(value) {
        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject3(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto2 = getPrototype(value);
        if (proto2 === null) {
          return true;
        }
        var Ctor = hasOwnProperty2.call(proto2, "constructor") && proto2.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp2 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet3 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString3(value) {
        return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol2(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined2(value) {
        return value === undefined$12;
      }
      function isWeakMap3(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet2(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }
      var lt2 = createRelationalOperation(baseLt);
      var lte2 = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray2(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString3(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag2 = getTag(value), func = tag2 == mapTag ? mapToArray : tag2 == setTag ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign2 = value < 0 ? -1 : 1;
          return sign2 * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger2(value) {
        var result3 = toFinite(value), remainder = result3 % 1;
        return result3 === result3 ? remainder ? result3 - remainder : result3 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger2(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN;
        }
        if (isObject3(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject3(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject2(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger2(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString2(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign2 = createAssigner(function(object, source2) {
        if (isPrototype2(source2) || isArrayLike(source2)) {
          copyObject(source2, keys3(source2), object);
          return;
        }
        for (var key in source2) {
          if (hasOwnProperty2.call(source2, key)) {
            assignValue(object, key, source2[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source2) {
        copyObject(source2, keysIn(source2), object);
      });
      var assignInWith = createAssigner(function(object, source2, srcIndex, customizer) {
        copyObject(source2, keysIn(source2), object, customizer);
      });
      var assignWith = createAssigner(function(object, source2, srcIndex, customizer) {
        copyObject(source2, keys3(source2), object, customizer);
      });
      var at2 = flatRest(baseAt);
      function create2(prototype2, properties2) {
        var result3 = baseCreate(prototype2);
        return properties2 == null ? result3 : baseAssign(result3, properties2);
      }
      var defaults2 = baseRest(function(object, sources) {
        object = Object2(object);
        var index = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined$12;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index < length) {
          var source2 = sources[index];
          var props = keysIn(source2);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === undefined$12 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
              object[key] = source2[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined$12, customDefaultsMerge);
        return apply(mergeWith, undefined$12, args);
      });
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys3(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get2(object, path2, defaultValue) {
        var result3 = object == null ? undefined$12 : baseGet(object, path2);
        return result3 === undefined$12 ? defaultValue : result3;
      }
      function has2(object, path2) {
        return object != null && hasPath(object, path2, baseHas);
      }
      function hasIn(object, path2) {
        return object != null && hasPath(object, path2, baseHasIn);
      }
      var invert = createInverter(function(result3, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result3[value] = key;
      }, constant(identity2));
      var invertBy = createInverter(function(result3, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty2.call(result3, value)) {
          result3[value].push(key);
        } else {
          result3[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys3(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result3 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result3, iteratee2(value, key, object2), value);
        });
        return result3;
      }
      function mapValues(object, iteratee2) {
        var result3 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result3, key, iteratee2(value, key, object2));
        });
        return result3;
      }
      var merge2 = createAssigner(function(object, source2, srcIndex) {
        baseMerge(object, source2, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source2, srcIndex, customizer) {
        baseMerge(object, source2, srcIndex, customizer);
      });
      var omit = flatRest(function(object, paths) {
        var result3 = {};
        if (object == null) {
          return result3;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path2) {
          path2 = castPath(path2, object);
          isDeep || (isDeep = path2.length > 1);
          return path2;
        });
        copyObject(object, getAllKeysIn(object), result3);
        if (isDeep) {
          result3 = baseClone(result3, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result3, paths[length]);
        }
        return result3;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value, path2) {
          return predicate(value, path2[0]);
        });
      }
      function result2(object, path2, defaultValue) {
        path2 = castPath(path2, object);
        var index = -1, length = path2.length;
        if (!length) {
          length = 1;
          object = undefined$12;
        }
        while (++index < length) {
          var value = object == null ? undefined$12 : object[toKey(path2[index])];
          if (value === undefined$12) {
            index = length;
            value = defaultValue;
          }
          object = isFunction2(value) ? value.call(object) : value;
        }
        return object;
      }
      function set(object, path2, value) {
        return object == null ? object : baseSet(object, path2, value);
      }
      function setWith(object, path2, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        return object == null ? object : baseSet(object, path2, value, customizer);
      }
      var toPairs = createToPairs(keys3);
      var toPairsIn = createToPairs(keysIn);
      function transform(object, iteratee2, accumulator) {
        var isArr = isArray2(object), isArrLike = isArr || isBuffer2(object) || isTypedArray2(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject3(object)) {
            accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
          return iteratee2(accumulator, value, index, object2);
        });
        return accumulator;
      }
      function unset(object, path2) {
        return object == null ? true : baseUnset(object, path2);
      }
      function update(object, path2, updater) {
        return object == null ? object : baseUpdate(object, path2, castFunction(updater));
      }
      function updateWith(object, path2, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        return object == null ? object : baseUpdate(object, path2, castFunction(updater), customizer);
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys3(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp(number2, lower, upper) {
        if (upper === undefined$12) {
          upper = lower;
          lower = undefined$12;
        }
        if (upper !== undefined$12) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined$12) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number2), lower, upper);
      }
      function inRange(number2, start, end) {
        start = toFinite(start);
        if (end === undefined$12) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number2 = toNumber(number2);
        return baseInRange(number2, start, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined$12;
        }
        if (floating === undefined$12) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined$12;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined$12;
          }
        }
        if (lower === undefined$12 && upper === undefined$12) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined$12) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result3, word, index) {
        word = word.toLowerCase();
        return result3 + (index ? capitalize(word) : word);
      });
      function capitalize(string2) {
        return upperFirst(toString2(string2).toLowerCase());
      }
      function deburr(string2) {
        string2 = toString2(string2);
        return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith2(string2, target, position) {
        string2 = toString2(string2);
        target = baseToString(target);
        var length = string2.length;
        position = position === undefined$12 ? length : baseClamp(toInteger2(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string2.slice(position, end) == target;
      }
      function escape2(string2) {
        string2 = toString2(string2);
        return string2 && reHasUnescapedHtml.test(string2) ? string2.replace(reUnescapedHtml, escapeHtmlChar) : string2;
      }
      function escapeRegExp(string2) {
        string2 = toString2(string2);
        return string2 && reHasRegExpChar.test(string2) ? string2.replace(reRegExpChar, "\\$&") : string2;
      }
      var kebabCase = createCompounder(function(result3, word, index) {
        return result3 + (index ? "-" : "") + word.toLowerCase();
      });
      var lowerCase2 = createCompounder(function(result3, word, index) {
        return result3 + (index ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad2(string2, length, chars2) {
        string2 = toString2(string2);
        length = toInteger2(length);
        var strLength = length ? stringSize(string2) : 0;
        if (!length || strLength >= length) {
          return string2;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars2) + string2 + createPadding(nativeCeil(mid), chars2);
      }
      function padEnd(string2, length, chars2) {
        string2 = toString2(string2);
        length = toInteger2(length);
        var strLength = length ? stringSize(string2) : 0;
        return length && strLength < length ? string2 + createPadding(length - strLength, chars2) : string2;
      }
      function padStart(string2, length, chars2) {
        string2 = toString2(string2);
        length = toInteger2(length);
        var strLength = length ? stringSize(string2) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars2) + string2 : string2;
      }
      function parseInt2(string2, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString2(string2).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string2, n, guard) {
        if (guard ? isIterateeCall(string2, n, guard) : n === undefined$12) {
          n = 1;
        } else {
          n = toInteger2(n);
        }
        return baseRepeat(toString2(string2), n);
      }
      function replace2() {
        var args = arguments, string2 = toString2(args[0]);
        return args.length < 3 ? string2 : string2.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result3, word, index) {
        return result3 + (index ? "_" : "") + word.toLowerCase();
      });
      function split(string2, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string2, separator, limit)) {
          separator = limit = undefined$12;
        }
        limit = limit === undefined$12 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string2 = toString2(string2);
        if (string2 && (typeof separator == "string" || separator != null && !isRegExp2(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string2)) {
            return castSlice(stringToArray(string2), 0, limit);
          }
        }
        return string2.split(separator, limit);
      }
      var startCase = createCompounder(function(result3, word, index) {
        return result3 + (index ? " " : "") + upperFirst(word);
      });
      function startsWith2(string2, target, position) {
        string2 = toString2(string2);
        position = position == null ? 0 : baseClamp(toInteger2(position), 0, string2.length);
        target = baseToString(target);
        return string2.slice(position, position + target.length) == target;
      }
      function template2(string2, options, guard) {
        var settings = lodash2.templateSettings;
        if (guard && isIterateeCall(string2, options, guard)) {
          options = undefined$12;
        }
        string2 = toString2(string2);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys3(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source2 = "__p += '";
        var reDelimiters = RegExp2(
          (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
          "g"
        );
        var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string2.replace(reDelimiters, function(match5, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source2 += string2.slice(index, offset2).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source2 += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source2 += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source2 += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index = offset2 + match5.length;
          return match5;
        });
        source2 += "';\n";
        var variable = hasOwnProperty2.call(options, "variable") && options.variable;
        if (!variable) {
          source2 = "with (obj) {\n" + source2 + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source2 = (isEvaluating ? source2.replace(reEmptyStringLeading, "") : source2).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source2 = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source2 + "return __p\n}";
        var result3 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source2).apply(undefined$12, importsValues);
        });
        result3.source = source2;
        if (isError2(result3)) {
          throw result3;
        }
        return result3;
      }
      function toLower(value) {
        return toString2(value).toLowerCase();
      }
      function toUpper(value) {
        return toString2(value).toUpperCase();
      }
      function trim2(string2, chars2, guard) {
        string2 = toString2(string2);
        if (string2 && (guard || chars2 === undefined$12)) {
          return baseTrim(string2);
        }
        if (!string2 || !(chars2 = baseToString(chars2))) {
          return string2;
        }
        var strSymbols = stringToArray(string2), chrSymbols = stringToArray(chars2), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string2, chars2, guard) {
        string2 = toString2(string2);
        if (string2 && (guard || chars2 === undefined$12)) {
          return string2.slice(0, trimmedEndIndex(string2) + 1);
        }
        if (!string2 || !(chars2 = baseToString(chars2))) {
          return string2;
        }
        var strSymbols = stringToArray(string2), end = charsEndIndex(strSymbols, stringToArray(chars2)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string2, chars2, guard) {
        string2 = toString2(string2);
        if (string2 && (guard || chars2 === undefined$12)) {
          return string2.replace(reTrimStart, "");
        }
        if (!string2 || !(chars2 = baseToString(chars2))) {
          return string2;
        }
        var strSymbols = stringToArray(string2), start = charsStartIndex(strSymbols, stringToArray(chars2));
        return castSlice(strSymbols, start).join("");
      }
      function truncate(string2, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject3(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger2(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string2 = toString2(string2);
        var strLength = string2.length;
        if (hasUnicode(string2)) {
          var strSymbols = stringToArray(string2);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string2;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result3 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string2.slice(0, end);
        if (separator === undefined$12) {
          return result3 + omission;
        }
        if (strSymbols) {
          end += result3.length - end;
        }
        if (isRegExp2(separator)) {
          if (string2.slice(end).search(separator)) {
            var match5, substring = result3;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match5 = separator.exec(substring)) {
              var newEnd = match5.index;
            }
            result3 = result3.slice(0, newEnd === undefined$12 ? end : newEnd);
          }
        } else if (string2.indexOf(baseToString(separator), end) != end) {
          var index = result3.lastIndexOf(separator);
          if (index > -1) {
            result3 = result3.slice(0, index);
          }
        }
        return result3 + omission;
      }
      function unescape2(string2) {
        string2 = toString2(string2);
        return string2 && reHasEscapedHtml.test(string2) ? string2.replace(reEscapedHtml, unescapeHtmlChar) : string2;
      }
      var upperCase = createCompounder(function(result3, word, index) {
        return result3 + (index ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string2, pattern2, guard) {
        string2 = toString2(string2);
        pattern2 = guard ? undefined$12 : pattern2;
        if (pattern2 === undefined$12) {
          return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
        }
        return string2.match(pattern2) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined$12, args);
        } catch (e) {
          return isError2(e) ? e : new Error2(e);
        }
      });
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object, key, bind4(object[key], object));
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index = -1;
          while (++index < length) {
            var pair = pairs[index];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source2) {
        return baseConforms(baseClone(source2, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity2(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source2) {
        return baseMatches(baseClone(source2, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path2, srcValue) {
        return baseMatchesProperty(path2, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path2, args) {
        return function(object) {
          return baseInvoke(object, path2, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path2) {
          return baseInvoke(object, path2, args);
        };
      });
      function mixin(object, source2, options) {
        var props = keys3(source2), methodNames = baseFunctions(source2, props);
        if (options == null && !(isObject3(source2) && (methodNames.length || !props.length))) {
          options = source2;
          source2 = object;
          object = this;
          methodNames = baseFunctions(source2, keys3(source2));
        }
        var chain2 = !(isObject3(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
        arrayEach(methodNames, function(methodName) {
          var func = source2[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result3 = object(this.__wrapped__), actions = result3.__actions__ = copyArray(this.__actions__);
                actions.push({ "func": func, "args": arguments, "thisArg": object });
                result3.__chain__ = chainAll;
                return result3;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop2() {
      }
      function nthArg(n) {
        n = toInteger2(n);
        return baseRest(function(args) {
          return baseNth(args, n);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path2) {
        return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
      }
      function propertyOf(object) {
        return function(path2) {
          return object == null ? undefined$12 : baseGet(object, path2);
        };
      }
      var range2 = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n, iteratee2) {
        n = toInteger2(n);
        if (n < 1 || n > MAX_SAFE_INTEGER) {
          return [];
        }
        var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n -= MAX_ARRAY_LENGTH;
        var result3 = baseTimes(length, iteratee2);
        while (++index < n) {
          iteratee2(index);
        }
        return result3;
      }
      function toPath(value) {
        if (isArray2(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol2(value) ? [value] : copyArray(stringToPath3(toString2(value)));
      }
      function uniqueId(prefix) {
        var id2 = ++idCounter;
        return toString2(prefix) + id2;
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor2 = createRound("floor");
      function max2(array) {
        return array && array.length ? baseExtremum(array, identity2, baseGt) : undefined$12;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$12;
      }
      function mean(array) {
        return baseMean(array, identity2);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min2(array) {
        return array && array.length ? baseExtremum(array, identity2, baseLt) : undefined$12;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$12;
      }
      var multiply2 = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round2 = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array) {
        return array && array.length ? baseSum(array, identity2) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash2.after = after;
      lodash2.ary = ary;
      lodash2.assign = assign2;
      lodash2.assignIn = assignIn;
      lodash2.assignInWith = assignInWith;
      lodash2.assignWith = assignWith;
      lodash2.at = at2;
      lodash2.before = before;
      lodash2.bind = bind4;
      lodash2.bindAll = bindAll;
      lodash2.bindKey = bindKey;
      lodash2.castArray = castArray;
      lodash2.chain = chain;
      lodash2.chunk = chunk;
      lodash2.compact = compact;
      lodash2.concat = concat2;
      lodash2.cond = cond;
      lodash2.conforms = conforms;
      lodash2.constant = constant;
      lodash2.countBy = countBy;
      lodash2.create = create2;
      lodash2.curry = curry;
      lodash2.curryRight = curryRight;
      lodash2.debounce = debounce;
      lodash2.defaults = defaults2;
      lodash2.defaultsDeep = defaultsDeep;
      lodash2.defer = defer;
      lodash2.delay = delay;
      lodash2.difference = difference;
      lodash2.differenceBy = differenceBy;
      lodash2.differenceWith = differenceWith;
      lodash2.drop = drop;
      lodash2.dropRight = dropRight;
      lodash2.dropRightWhile = dropRightWhile;
      lodash2.dropWhile = dropWhile;
      lodash2.fill = fill;
      lodash2.filter = filter2;
      lodash2.flatMap = flatMap;
      lodash2.flatMapDeep = flatMapDeep;
      lodash2.flatMapDepth = flatMapDepth;
      lodash2.flatten = flatten;
      lodash2.flattenDeep = flattenDeep;
      lodash2.flattenDepth = flattenDepth;
      lodash2.flip = flip2;
      lodash2.flow = flow;
      lodash2.flowRight = flowRight;
      lodash2.fromPairs = fromPairs;
      lodash2.functions = functions;
      lodash2.functionsIn = functionsIn;
      lodash2.groupBy = groupBy;
      lodash2.initial = initial;
      lodash2.intersection = intersection;
      lodash2.intersectionBy = intersectionBy;
      lodash2.intersectionWith = intersectionWith;
      lodash2.invert = invert;
      lodash2.invertBy = invertBy;
      lodash2.invokeMap = invokeMap;
      lodash2.iteratee = iteratee;
      lodash2.keyBy = keyBy;
      lodash2.keys = keys3;
      lodash2.keysIn = keysIn;
      lodash2.map = map2;
      lodash2.mapKeys = mapKeys;
      lodash2.mapValues = mapValues;
      lodash2.matches = matches;
      lodash2.matchesProperty = matchesProperty;
      lodash2.memoize = memoize2;
      lodash2.merge = merge2;
      lodash2.mergeWith = mergeWith;
      lodash2.method = method;
      lodash2.methodOf = methodOf;
      lodash2.mixin = mixin;
      lodash2.negate = negate;
      lodash2.nthArg = nthArg;
      lodash2.omit = omit;
      lodash2.omitBy = omitBy;
      lodash2.once = once;
      lodash2.orderBy = orderBy;
      lodash2.over = over;
      lodash2.overArgs = overArgs;
      lodash2.overEvery = overEvery;
      lodash2.overSome = overSome;
      lodash2.partial = partial;
      lodash2.partialRight = partialRight;
      lodash2.partition = partition;
      lodash2.pick = pick;
      lodash2.pickBy = pickBy;
      lodash2.property = property;
      lodash2.propertyOf = propertyOf;
      lodash2.pull = pull;
      lodash2.pullAll = pullAll;
      lodash2.pullAllBy = pullAllBy;
      lodash2.pullAllWith = pullAllWith;
      lodash2.pullAt = pullAt;
      lodash2.range = range2;
      lodash2.rangeRight = rangeRight;
      lodash2.rearg = rearg;
      lodash2.reject = reject;
      lodash2.remove = remove;
      lodash2.rest = rest;
      lodash2.reverse = reverse;
      lodash2.sampleSize = sampleSize;
      lodash2.set = set;
      lodash2.setWith = setWith;
      lodash2.shuffle = shuffle;
      lodash2.slice = slice2;
      lodash2.sortBy = sortBy;
      lodash2.sortedUniq = sortedUniq;
      lodash2.sortedUniqBy = sortedUniqBy;
      lodash2.split = split;
      lodash2.spread = spread2;
      lodash2.tail = tail;
      lodash2.take = take;
      lodash2.takeRight = takeRight;
      lodash2.takeRightWhile = takeRightWhile;
      lodash2.takeWhile = takeWhile;
      lodash2.tap = tap;
      lodash2.throttle = throttle;
      lodash2.thru = thru;
      lodash2.toArray = toArray2;
      lodash2.toPairs = toPairs;
      lodash2.toPairsIn = toPairsIn;
      lodash2.toPath = toPath;
      lodash2.toPlainObject = toPlainObject2;
      lodash2.transform = transform;
      lodash2.unary = unary;
      lodash2.union = union;
      lodash2.unionBy = unionBy;
      lodash2.unionWith = unionWith;
      lodash2.uniq = uniq;
      lodash2.uniqBy = uniqBy;
      lodash2.uniqWith = uniqWith;
      lodash2.unset = unset;
      lodash2.unzip = unzip;
      lodash2.unzipWith = unzipWith;
      lodash2.update = update;
      lodash2.updateWith = updateWith;
      lodash2.values = values;
      lodash2.valuesIn = valuesIn;
      lodash2.without = without;
      lodash2.words = words;
      lodash2.wrap = wrap2;
      lodash2.xor = xor;
      lodash2.xorBy = xorBy;
      lodash2.xorWith = xorWith;
      lodash2.zip = zip;
      lodash2.zipObject = zipObject;
      lodash2.zipObjectDeep = zipObjectDeep;
      lodash2.zipWith = zipWith;
      lodash2.entries = toPairs;
      lodash2.entriesIn = toPairsIn;
      lodash2.extend = assignIn;
      lodash2.extendWith = assignInWith;
      mixin(lodash2, lodash2);
      lodash2.add = add;
      lodash2.attempt = attempt;
      lodash2.camelCase = camelCase;
      lodash2.capitalize = capitalize;
      lodash2.ceil = ceil;
      lodash2.clamp = clamp;
      lodash2.clone = clone2;
      lodash2.cloneDeep = cloneDeep;
      lodash2.cloneDeepWith = cloneDeepWith;
      lodash2.cloneWith = cloneWith;
      lodash2.conformsTo = conformsTo;
      lodash2.deburr = deburr;
      lodash2.defaultTo = defaultTo;
      lodash2.divide = divide;
      lodash2.endsWith = endsWith2;
      lodash2.eq = eq;
      lodash2.escape = escape2;
      lodash2.escapeRegExp = escapeRegExp;
      lodash2.every = every;
      lodash2.find = find;
      lodash2.findIndex = findIndex;
      lodash2.findKey = findKey;
      lodash2.findLast = findLast;
      lodash2.findLastIndex = findLastIndex;
      lodash2.findLastKey = findLastKey;
      lodash2.floor = floor2;
      lodash2.forEach = forEach4;
      lodash2.forEachRight = forEachRight;
      lodash2.forIn = forIn;
      lodash2.forInRight = forInRight;
      lodash2.forOwn = forOwn;
      lodash2.forOwnRight = forOwnRight;
      lodash2.get = get2;
      lodash2.gt = gt2;
      lodash2.gte = gte2;
      lodash2.has = has2;
      lodash2.hasIn = hasIn;
      lodash2.head = head;
      lodash2.identity = identity2;
      lodash2.includes = includes;
      lodash2.indexOf = indexOf;
      lodash2.inRange = inRange;
      lodash2.invoke = invoke;
      lodash2.isArguments = isArguments5;
      lodash2.isArray = isArray2;
      lodash2.isArrayBuffer = isArrayBuffer2;
      lodash2.isArrayLike = isArrayLike;
      lodash2.isArrayLikeObject = isArrayLikeObject;
      lodash2.isBoolean = isBoolean3;
      lodash2.isBuffer = isBuffer2;
      lodash2.isDate = isDate2;
      lodash2.isElement = isElement2;
      lodash2.isEmpty = isEmpty;
      lodash2.isEqual = isEqual;
      lodash2.isEqualWith = isEqualWith;
      lodash2.isError = isError2;
      lodash2.isFinite = isFinite2;
      lodash2.isFunction = isFunction2;
      lodash2.isInteger = isInteger;
      lodash2.isLength = isLength;
      lodash2.isMap = isMap3;
      lodash2.isMatch = isMatch;
      lodash2.isMatchWith = isMatchWith;
      lodash2.isNaN = isNaN2;
      lodash2.isNative = isNative;
      lodash2.isNil = isNil;
      lodash2.isNull = isNull;
      lodash2.isNumber = isNumber2;
      lodash2.isObject = isObject3;
      lodash2.isObjectLike = isObjectLike;
      lodash2.isPlainObject = isPlainObject3;
      lodash2.isRegExp = isRegExp2;
      lodash2.isSafeInteger = isSafeInteger;
      lodash2.isSet = isSet3;
      lodash2.isString = isString3;
      lodash2.isSymbol = isSymbol2;
      lodash2.isTypedArray = isTypedArray2;
      lodash2.isUndefined = isUndefined2;
      lodash2.isWeakMap = isWeakMap3;
      lodash2.isWeakSet = isWeakSet2;
      lodash2.join = join;
      lodash2.kebabCase = kebabCase;
      lodash2.last = last;
      lodash2.lastIndexOf = lastIndexOf;
      lodash2.lowerCase = lowerCase2;
      lodash2.lowerFirst = lowerFirst;
      lodash2.lt = lt2;
      lodash2.lte = lte2;
      lodash2.max = max2;
      lodash2.maxBy = maxBy;
      lodash2.mean = mean;
      lodash2.meanBy = meanBy;
      lodash2.min = min2;
      lodash2.minBy = minBy;
      lodash2.stubArray = stubArray;
      lodash2.stubFalse = stubFalse;
      lodash2.stubObject = stubObject;
      lodash2.stubString = stubString;
      lodash2.stubTrue = stubTrue;
      lodash2.multiply = multiply2;
      lodash2.nth = nth;
      lodash2.noConflict = noConflict;
      lodash2.noop = noop2;
      lodash2.now = now;
      lodash2.pad = pad2;
      lodash2.padEnd = padEnd;
      lodash2.padStart = padStart;
      lodash2.parseInt = parseInt2;
      lodash2.random = random;
      lodash2.reduce = reduce;
      lodash2.reduceRight = reduceRight;
      lodash2.repeat = repeat;
      lodash2.replace = replace2;
      lodash2.result = result2;
      lodash2.round = round2;
      lodash2.runInContext = runInContext2;
      lodash2.sample = sample;
      lodash2.size = size;
      lodash2.snakeCase = snakeCase;
      lodash2.some = some;
      lodash2.sortedIndex = sortedIndex;
      lodash2.sortedIndexBy = sortedIndexBy;
      lodash2.sortedIndexOf = sortedIndexOf;
      lodash2.sortedLastIndex = sortedLastIndex;
      lodash2.sortedLastIndexBy = sortedLastIndexBy;
      lodash2.sortedLastIndexOf = sortedLastIndexOf;
      lodash2.startCase = startCase;
      lodash2.startsWith = startsWith2;
      lodash2.subtract = subtract;
      lodash2.sum = sum;
      lodash2.sumBy = sumBy;
      lodash2.template = template2;
      lodash2.times = times;
      lodash2.toFinite = toFinite;
      lodash2.toInteger = toInteger2;
      lodash2.toLength = toLength;
      lodash2.toLower = toLower;
      lodash2.toNumber = toNumber;
      lodash2.toSafeInteger = toSafeInteger;
      lodash2.toString = toString2;
      lodash2.toUpper = toUpper;
      lodash2.trim = trim2;
      lodash2.trimEnd = trimEnd;
      lodash2.trimStart = trimStart;
      lodash2.truncate = truncate;
      lodash2.unescape = unescape2;
      lodash2.uniqueId = uniqueId;
      lodash2.upperCase = upperCase;
      lodash2.upperFirst = upperFirst;
      lodash2.each = forEach4;
      lodash2.eachRight = forEachRight;
      lodash2.first = head;
      mixin(lodash2, function() {
        var source2 = {};
        baseForOwn(lodash2, function(func, methodName) {
          if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
            source2[methodName] = func;
          }
        });
        return source2;
      }(), { "chain": false });
      lodash2.VERSION = VERSION2;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      });
      arrayEach(["drop", "take"], function(methodName, index) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === undefined$12 ? 1 : nativeMax(toInteger2(n), 0);
          var result3 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
          if (result3.__filtered__) {
            result3.__takeCount__ = nativeMin(n, result3.__takeCount__);
          } else {
            result3.__views__.push({
              "size": nativeMin(n, MAX_ARRAY_LENGTH),
              "type": methodName + (result3.__dir__ < 0 ? "Right" : "")
            });
          }
          return result3;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
        var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result3 = this.clone();
          result3.__iteratees__.push({
            "iteratee": getIteratee(iteratee2, 3),
            "type": type
          });
          result3.__filtered__ = result3.__filtered__ || isFilter;
          return result3;
        };
      });
      arrayEach(["head", "last"], function(methodName, index) {
        var takeName = "take" + (index ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index) {
        var dropName = "drop" + (index ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity2);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path2, args) {
        if (typeof path2 == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path2, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger2(start);
        var result3 = this;
        if (result3.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result3);
        }
        if (start < 0) {
          result3 = result3.takeRight(-start);
        } else if (start) {
          result3 = result3.drop(start);
        }
        if (end !== undefined$12) {
          end = toInteger2(end);
          result3 = end < 0 ? result3.dropRight(-end) : result3.take(end - start);
        }
        return result3;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash2.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
          var interceptor = function(value2) {
            var result4 = lodashFunc.apply(lodash2, arrayPush([value2], args));
            return isTaker && chainAll ? result4[0] : result4;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result3 = func.apply(value, args);
            result3.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$12 });
            return new LodashWrapper(result3, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result3 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result3.value()[0] : result3.value() : result3;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray2(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray2(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty2.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ "name": methodName, "func": lodashFunc });
        }
      });
      realNames[createHybrid(undefined$12, WRAP_BIND_KEY_FLAG).name] = [{
        "name": "wrapper",
        "func": undefined$12
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash2.prototype.at = wrapperAt;
      lodash2.prototype.chain = wrapperChain;
      lodash2.prototype.commit = wrapperCommit;
      lodash2.prototype.next = wrapperNext;
      lodash2.prototype.plant = wrapperPlant;
      lodash2.prototype.reverse = wrapperReverse;
      lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
      lodash2.prototype.first = lodash2.prototype.head;
      if (symIterator) {
        lodash2.prototype[symIterator] = wrapperToIterator;
      }
      return lodash2;
    };
    var _ = runInContext();
    if (freeModule) {
      (freeModule.exports = _)._ = _;
      freeExports._ = _;
    } else {
      root._ = _;
    }
  }).call(commonjsGlobal);
})(lodash, lodash.exports);
function notValidHexMessage(functionName, hex2) {
  return functionName + ": " + hex2 + " is not a valid hex color.";
}
function notValidRgbMessage(functionName, rgb) {
  return functionName + ": " + JSON.stringify(rgb) + " is not a valid rgb color object.";
}
function notValidRgbaMessage(functionName, rgba) {
  return functionName + ": " + JSON.stringify(rgba) + " is not a valid rgba color object.";
}
function notValidHslMessage(functionName, hsl) {
  return functionName + ": " + JSON.stringify(hsl) + " is not a valid hsl color object.";
}
function notValidHslaMessage(functionName, hsla) {
  return functionName + ": " + JSON.stringify(hsla) + " is not a valid hsla color object.";
}
function notValidAlphaValueMessage(functionName, alpha) {
  return functionName + ": " + alpha + " is not in range [0, 1].";
}
function chunkString(str2, size) {
  return str2.match(new RegExp(".{1," + size + "}", "g"));
}
function alphaToHex(alpha) {
  if (!between(alpha, [0, 1]))
    throw new Error(alpha + " is not in the range [0, 1].");
  var integerIn0255 = Math.round(alpha * 255);
  var hexValue = integerIn0255.toString(16);
  return hexValue.padStart(2, "0").toUpperCase();
}
function hexToAlpha(hex2, precision) {
  if (precision === void 0) {
    precision = 2;
  }
  if (!HEX_REGEX.alpha.test(hex2))
    throw new Error(hex2 + " is not a valid hex color.");
  if (hex2.length !== 2)
    throw new Error(hex2 + " lenght is not 2.");
  var integer2 = hexadecimalToDecimal(hex2);
  var integerIn0255 = integer2 / 255;
  return lodash.exports.round(integerIn0255, precision);
}
function hexAlphaTo0255(hexAlpha) {
  return Math.round(hexToAlpha(hexAlpha) * 255);
}
function number0255ToHex(value) {
  if (!between(value, [0, 255]))
    throw new Error(value + " must be in [0, 255].");
  var hex2 = Math.round(value).toString(16);
  return hex2.padStart(2, "0").toUpperCase();
}
var __assign$5 = globalThis && globalThis.__assign || function() {
  __assign$5 = Object.assign || function(t) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p))
          t[p] = s2[p];
    }
    return t;
  };
  return __assign$5.apply(this, arguments);
};
function hslaToHex(hsla) {
  if (!isHsla(hsla))
    throw new Error(notValidHslaMessage("hslaToHex", hsla));
  var h2 = hsla.h, s2 = hsla.s, l = hsla.l, a3 = hsla.a;
  var hex2 = hslToHex({ h: h2, s: s2, l });
  return "" + hex2 + alphaToHex(a3);
}
function hslaToRgba(hsla) {
  if (!isHsla(hsla))
    throw new Error(notValidHslaMessage("hslaToRgba", hsla));
  var h2 = hsla.h, s2 = hsla.s, l = hsla.l, a3 = hsla.a;
  var rgb = hslToRgb({ h: h2, s: s2, l });
  return __assign$5(__assign$5({}, rgb), { a: a3 });
}
var __assign$4 = globalThis && globalThis.__assign || function() {
  __assign$4 = Object.assign || function(t) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p))
          t[p] = s2[p];
    }
    return t;
  };
  return __assign$4.apply(this, arguments);
};
function hslToHex(hsl) {
  if (!isHsl(hsl))
    throw new Error(notValidHslMessage("hslToHex", hsl));
  var rgb = hslToRgb(hsl);
  return rgbToHex(rgb);
}
function hslToRgb(hsl) {
  if (!isHsl(hsl))
    throw new Error(notValidHslMessage("hslToRgb", hsl));
  var h2 = hsl.h, s2 = hsl.s, l = hsl.l;
  var s01 = s2 / 100;
  var l01 = l / 100;
  if (s01 === 0) {
    var l_1 = l01 * 255;
    return { r: l_1, g: l_1, b: l_1 };
  }
  var angle = h2 / 60 % 6;
  var angleRangeIndex = Math.floor(angle);
  var f = angle - angleRangeIndex;
  var chroma = s01 * (1 - Math.abs(2 * l01 - 1));
  var p = l01 + chroma / 2;
  var q = l01 - chroma / 2;
  var t = p - chroma * f;
  var w2 = q + chroma * f;
  var rgb01 = { r: 0, g: 0, b: 0 };
  if (angleRangeIndex === 0) {
    rgb01 = { r: p, g: w2, b: q };
  } else if (angleRangeIndex === 1) {
    rgb01 = { r: t, g: p, b: q };
  } else if (angleRangeIndex === 2) {
    rgb01 = { r: q, g: p, b: w2 };
  } else if (angleRangeIndex === 3) {
    rgb01 = { r: q, g: t, b: p };
  } else if (angleRangeIndex === 4) {
    rgb01 = { r: w2, g: q, b: p };
  } else {
    rgb01 = { r: p, g: q, b: t };
  }
  var rgb = applyFnToEachObjValue(rgb01, function(c) {
    return lodash.exports.round(c * 255);
  });
  return rgb;
}
var __assign$3 = globalThis && globalThis.__assign || function() {
  __assign$3 = Object.assign || function(t) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p))
          t[p] = s2[p];
    }
    return t;
  };
  return __assign$3.apply(this, arguments);
};
var __assign$2 = globalThis && globalThis.__assign || function() {
  __assign$2 = Object.assign || function(t) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p))
          t[p] = s2[p];
    }
    return t;
  };
  return __assign$2.apply(this, arguments);
};
function rgbaToHex(rgba) {
  if (!isRgba(rgba))
    throw new Error(notValidRgbaMessage("rgbaToHex", rgba));
  var r = rgba.r, g2 = rgba.g, b2 = rgba.b, a3 = rgba.a;
  var rgbHex = rgbToHex({ r, g: g2, b: b2 });
  var alphaHex = alphaToHex(a3);
  return "" + rgbHex + alphaHex;
}
function rgbaToHsl(rgba) {
  if (!isRgba(rgba))
    throw new Error(notValidRgbaMessage("rgbaToHsl", rgba));
  var r = rgba.r, g2 = rgba.g, b2 = rgba.b;
  return rgbToHsl({ r, g: g2, b: b2 });
}
function rgbaToHsla(rgba) {
  if (!isRgba(rgba))
    throw new Error(notValidRgbaMessage("rgbaToHsla", rgba));
  return __assign$2(__assign$2({}, rgbaToHsl(rgba)), { a: rgba.a });
}
var ALPHA_PRECISION = 4;
var __assign$1 = globalThis && globalThis.__assign || function() {
  __assign$1 = Object.assign || function(t) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p))
          t[p] = s2[p];
    }
    return t;
  };
  return __assign$1.apply(this, arguments);
};
function hexToRgbOrRgba(hex2) {
  if (!isHex(hex2))
    throw new Error(notValidHexMessage("hexToRgbOrRgba", hex2));
  var hexLongWtihoutHashtag = shortToLongHex(hex2).substring(1);
  var _a3 = chunkString(hexLongWtihoutHashtag, 2), r = _a3[0], g2 = _a3[1], b2 = _a3[2], a3 = _a3[3];
  var r0255 = hexAlphaTo0255(r);
  var g0255 = hexAlphaTo0255(g2);
  var b0255 = hexAlphaTo0255(b2);
  var rgb = { r: r0255, g: g0255, b: b0255 };
  if (a3)
    return __assign$1(__assign$1({}, rgb), { a: hexToAlpha(a3, ALPHA_PRECISION) });
  return rgb;
}
function hexToRgba(hex2, alpha) {
  if (alpha === void 0) {
    alpha = 1;
  }
  if (!isHex(hex2))
    throw new Error(notValidHexMessage("hex2rgba", hex2));
  if (!between(alpha, [0, 1]))
    throw new Error(notValidAlphaValueMessage("hex2rgba", alpha));
  var rgbOrRgba = hexToRgbOrRgba(hex2);
  if (isRgb(rgbOrRgba))
    return __assign$1(__assign$1({}, rgbOrRgba), { a: alpha });
  return rgbOrRgba;
}
function shortToLongHex(hex2) {
  if (!isHex(hex2))
    throw new Error(notValidHexMessage("shortToLongHex", hex2));
  if (!HEX_REGEX.short.test(hex2))
    return hex2;
  var _a3 = Array.from(hex2), hashtag = _a3[0], r = _a3[1], g2 = _a3[2], b2 = _a3[3], a3 = _a3[4];
  return a3 ? "" + hashtag + r + r + g2 + g2 + b2 + b2 + a3 + a3 : "" + hashtag + r + r + g2 + g2 + b2 + b2;
}
var __assign = globalThis && globalThis.__assign || function() {
  __assign = Object.assign || function(t) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p))
          t[p] = s2[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function rgbToHex(rgb) {
  if (!isRgb(rgb))
    throw new Error(notValidRgbMessage("rgbToHex", rgb));
  var hex2 = Object.values(rgb).map(function(n) {
    return number0255ToHex(n);
  }).join("");
  return "#" + hex2;
}
function rgbToHsl(rgb) {
  if (!isRgb(rgb))
    throw new Error(notValidRgbMessage("rgbToHsl", rgb));
  var r = rgb.r, g2 = rgb.g, b2 = rgb.b;
  var max2 = Math.max(r, g2, b2);
  var min2 = Math.min(r, g2, b2);
  var l = (max2 + min2) / 2;
  if (max2 === min2)
    return { h: 0, s: 0, l: l / 255 * 100 };
  var chroma = max2 - min2;
  var s2 = Math.abs(chroma / (1 - Math.abs(2 * l - 1))) * 100 - 1;
  var h2;
  switch (max2) {
    case r:
      h2 = 60 * ((g2 - b2) / chroma) + (g2 < b2 ? 360 : 0);
      break;
    case g2:
      h2 = 120 + 60 * (b2 - r) / chroma;
      break;
    case b2:
      h2 = 240 + 60 * (r - g2) / chroma;
      break;
  }
  var hsl = { h: h2, s: s2, l: l / 255 * 100 };
  var hslRounded = applyFnToEachObjValue(hsl, function(c) {
    return lodash.exports.round(c);
  });
  return hslRounded;
}
function __hslaToRgba(h2, s2, l, a3 = 1) {
  if (typeof h2 === "object") {
    h2 = h2.h;
    s2 = h2.s;
    l = h2.l;
    a3 = h2.a;
  }
  const rgba = hslaToRgba({
    h: h2,
    s: s2,
    l,
    a: a3
  });
  return rgba;
}
function __hexToRgba(hex2) {
  return hexToRgba(hex2, 1);
}
function __parseHsla(hslaString) {
  hslaString = hslaString.toLowerCase();
  const string2 = hslaString.replace("hsla(", "").replace("hsl(", "").replace(")", "").replace(/\s/g, "");
  const array = string2.split(",");
  return {
    h: parseFloat(array[0]),
    s: parseFloat(array[1]),
    l: parseFloat(array[2]),
    a: array[3] ? parseFloat(array[3]) : 1
  };
}
function __parseRgba(rgbaString) {
  rgbaString = rgbaString.toLowerCase();
  const string2 = rgbaString.replace("rgba(", "").replace("rgb(", "").replace(")", "").replace(/\s/g, "");
  const array = string2.split(",");
  return {
    r: parseInt(array[0]),
    g: parseInt(array[1]),
    b: parseInt(array[2]),
    a: array[3] ? parseInt(array[3]) : 1
  };
}
function __rgbaToHsla(r, g2, b2, a3 = 1) {
  if (typeof r === "object") {
    g2 = r.g;
    b2 = r.b;
    a3 = r.a;
    r = r.r;
  }
  return rgbaToHsla({
    r,
    g: g2,
    b: b2,
    a: a3
  });
}
function __parse(color2, format2 = "rgba") {
  color2 = color2.replace(/\s/g, "");
  if (color2.indexOf("rgb") != -1) {
    color2 = __parseRgba(color2);
  } else if (color2.indexOf("hsl") != -1) {
    color2 = __parseHsla(color2);
    color2 = __hslaToRgba(color2.h, color2.s, color2.l);
  } else if (color2.substring(0, 1) == "#") {
    color2 = __hexToRgba(color2);
  }
  switch (format2) {
    case "hsla":
    case "hsl":
      return __rgbaToHsla(color2);
    case "rgba":
    case "rgb":
    default:
      return color2;
  }
}
function __rgbaToHex(r, g2, b2, a3 = 1) {
  if (typeof r === "object") {
    g2 = r.g;
    b2 = r.b;
    a3 = r.a;
    r = r.r;
  }
  let res = rgbaToHex({
    r,
    g: g2,
    b: b2,
    a: a3
  });
  if (res.length === 9) {
    res = res.slice(0, -2);
  }
  return res;
}
function __convert(input, format2 = "rgba") {
  let rgbaObj = {};
  if (typeof input === "string") {
    rgbaObj = __parse(input, "rgba");
  } else if (typeof input === "object") {
    if (input.r !== void 0 && input.g !== void 0 && input.b !== void 0) {
      rgbaObj = input;
    } else if (input.h !== void 0 && input.s !== void 0 && input.l !== void 0) {
      rgbaObj = __hslaToRgba(input);
    }
  }
  switch (format2) {
    case "rgba":
      return rgbaObj;
    case "hsl":
    case "hsla":
      return __rgbaToHsla(rgbaObj);
    case "hex":
    case "hexString":
      return __rgbaToHex(rgbaObj);
    case "rgbString":
      return `rgb(${rgbaObj.r},${rgbaObj.g},${rgbaObj.b})`;
    case "rgbaString":
      return `rgba(${rgbaObj.r},${rgbaObj.g},${rgbaObj.b},${rgbaObj.a})`;
    case "hslString":
      const hslObj = convert(rgbaObj, "hsl");
      return `hsl(${hslObj.h},${hslObj.s},${hslObj.l})`;
    case "hslaString":
      const hslaObj = convert(rgbaObj, "hsla");
      return `hsla(${hslaObj.h},${hslaObj.s},${hslaObj.l},${hslaObj.a})`;
  }
  return void 0;
}
function __hslaToHex(h2, s2, l, a3 = 1) {
  const hex2 = hslaToHex({
    h: h2,
    s: s2,
    l,
    a: a3
  });
  return hex2.slice(0, -2);
}
function __hslaToHexa(h2, s2, l, a3 = 1) {
  const hex2 = hslaToHex({
    h: h2,
    s: s2,
    l,
    a: a3
  });
  return hex2;
}
class SColorApplyParamsInterface extends SInterface {
  static get _definition() {
    return {
      desaturate: {
        type: "Number",
        default: 0,
        alias: "d",
        description: "Allows you to desaturate the color using a percentage"
      },
      saturate: {
        type: "Number",
        default: 0,
        alias: "s",
        description: "Allows you to saturate the color using a percentage"
      },
      greyscale: {
        type: "Boolean",
        default: false,
        alias: "g",
        description: "Allows you to get back the grayscale version of your color"
      },
      spin: {
        type: "Number",
        default: 0,
        description: "Spin the hue on the passed value (max 360)"
      },
      transparentize: {
        type: "Number",
        default: 0,
        description: "The amount of transparency to apply between 0-100|0-1"
      },
      alpha: {
        type: "Number",
        default: 0,
        alias: "a",
        description: "The new alpha value to apply between 0-100|0-1"
      },
      opacity: {
        type: "Number",
        default: 0,
        alias: "o",
        description: "The new alpha value to apply between 0-100|0-1"
      },
      opacify: {
        type: "Number",
        default: 0,
        description: "The amount of transparence to remove between 0-100|0-1"
      },
      darken: {
        type: "Number",
        default: 0,
        description: "The amount of darkness (of the nightmare of the shadow) to apply between 0-100"
      },
      lighten: {
        type: "Number",
        default: 0,
        alias: "l",
        description: "The amount of lightness (of the sky of the angels) to apply between 0-100"
      },
      invert: {
        type: "Boolean",
        default: false,
        alias: "i",
        description: "Specify if you want to invert the color to keep a good contrast ratio with a background for example"
      }
    };
  }
}
class SColorSettingsInterface extends SInterface {
  static get _definition() {
    return {
      returnNewInstance: {
        description: "Specify if the methods returns by default a new SColor instance or the same",
        type: "boolean",
        default: false
      },
      defaultFormat: {
        description: "Specify the default format of the color",
        type: "String",
        values: ["hex", "rgb", "rgba", "hsl", "hsla"],
        default: "hex"
      }
    };
  }
}
class SColor extends SClass {
  constructor(color2, settings) {
    var _c2, _d2;
    super(__deepMerge(
      SColorSettingsInterface.defaults(),
      settings !== null && settings !== void 0 ? settings : {}
    ));
    this._originalSColor = null;
    this._h = 0;
    this._s = 0;
    this._l = 0;
    this._r = 0;
    this._g = 0;
    this._b = 0;
    this._a = 1;
    color2 = this.getColor(color2);
    this._originalSColor = color2;
    if (typeof color2 === "string") {
      try {
        this._parse(color2);
      } catch (e) {
      }
    } else {
      if (color2.h !== void 0 && color2.s !== void 0 && color2.l !== void 0) {
        this._h = color2.h;
        this._s = color2.s;
        this._l = color2.l;
        this._a = (_c2 = color2.a) !== null && _c2 !== void 0 ? _c2 : 1;
      } else if (color2.r !== void 0 && color2.g !== void 0 && color2.b !== void 0) {
        const converted = __rgbaToHsla(color2.r, color2.g, color2.b, (_d2 = color2.a) !== null && _d2 !== void 0 ? _d2 : 1);
        this._h = converted.h;
        this._s = converted.s;
        this._l = converted.l;
        this._a = converted.a;
      } else {
        console.error(color2);
        throw new Error("Sorry but this passed value is not a valid color object or string...");
      }
    }
  }
  getColor(color2) {
    if (typeof color2 == "string" && SColor.colors[color2.toLowerCase()]) {
      return SColor.colors[color2.toLowerCase()];
    }
    return color2;
  }
  _parse(color2) {
    color2 = __convert(color2, "hsla");
    this.h = color2.h;
    this.s = color2.s;
    this.l = color2.l;
    this.a = color2.a;
    return color2;
  }
  _convert2(format2) {
    switch (format2) {
      case "rgba":
      case "rgb":
        return __hslaToRgba(this._h, this._s, this._l, this._a);
      case "hsla":
      case "hsl":
        return {
          h: this._h,
          s: this._s,
          l: this._l,
          a: this._a
        };
      case "hexa":
        return __hslaToHexa(this._h, this._s, this._l, this._a);
      case "hex":
        return __hslaToHex(this._h, this._s, this._l);
    }
  }
  toHex() {
    return this._convert2("hex");
  }
  toHexa() {
    return this._convert2("hexa");
  }
  toHsl() {
    return this._convert2("hsl");
  }
  toHsla() {
    return this._convert2("hsla");
  }
  toRgb() {
    return this._convert2("rgb");
  }
  toRgba() {
    return this._convert2("rgba");
  }
  get r() {
    return this._r;
  }
  set r(value) {
    value = parseInt(value);
    value = value > 255 ? 255 : value < 0 ? 0 : value;
    this._r = value;
    this._applyFromRgbaUpdate();
  }
  get g() {
    return this._g;
  }
  set g(value) {
    value = parseInt(value);
    value = value > 255 ? 255 : value < 0 ? 0 : value;
    this._g = value;
    this._applyFromRgbaUpdate();
  }
  get b() {
    return this._b;
  }
  set b(value) {
    value = parseInt(value);
    value = value > 255 ? 255 : value < 0 ? 0 : value;
    this._b = value;
    this._applyFromRgbaUpdate();
  }
  get a() {
    return this._a;
  }
  set a(value) {
    value = parseFloat(value);
    value = value > 1 ? 1 : value < 0 ? 0 : value;
    this._a = value;
  }
  get h() {
    return this._h;
  }
  set h(value) {
    value = parseInt(value);
    value = value > 360 ? 360 : value < 0 ? 0 : value;
    this._h = value;
    this._applyFromHslaUpdate();
  }
  get s() {
    return this._s;
  }
  set s(value) {
    value = parseInt(value);
    value = value > 100 ? 100 : value < 0 ? 0 : value;
    this._s = value;
    this._applyFromHslaUpdate();
  }
  get l() {
    return this._l;
  }
  set l(value) {
    value = parseInt(value);
    value = value > 100 ? 100 : value < 0 ? 0 : value;
    this._l = value;
    this._applyFromHslaUpdate();
  }
  clone() {
    const newColor = new SColor({
      h: this._h,
      s: this._s,
      l: this._l,
      a: this._a
    });
    return newColor;
  }
  reset() {
    this._parse(this._originalSColor);
  }
  _applyFromHslaUpdate() {
    const rgba = __hslaToRgba(this._h, this._s, this._l, this._a);
    this._r = rgba.r;
    this._g = rgba.g;
    this._b = rgba.b;
    this._a = rgba.a;
  }
  _applyFromRgbaUpdate() {
    const hsla = __rgbaToHsla(this._r, this._g, this._b, this._a);
    this._h = hsla.h;
    this._s = hsla.s;
    this._l = hsla.l;
    this._a = hsla.a;
  }
  apply(params, returnNewInstance = this.settings.returnNewInstance) {
    const intRes = SColorApplyParamsInterface.apply(params);
    params = intRes;
    let colorInstance = this;
    if (returnNewInstance) {
      colorInstance = new SColor(this.toHex());
    }
    Object.keys(params).forEach((action) => {
      const value = params[action];
      if (!value)
        return;
      if (!colorInstance[action] || typeof colorInstance[action] !== "function")
        return;
      if (action === "invert") {
        colorInstance.invert();
      } else {
        colorInstance[action](value);
      }
    });
    return colorInstance;
  }
  desaturate(amount, returnNewInstance = this.settings.returnNewInstance) {
    amount = parseInt(amount);
    if (returnNewInstance) {
      const n = this.clone();
      n.s -= amount;
      return n;
    }
    this.s -= amount;
    return this;
  }
  saturate(amount, returnNewInstance = this.settings.returnNewInstance) {
    amount = parseInt(amount);
    if (returnNewInstance) {
      const n = this.clone();
      n.s += amount;
      return n;
    }
    this.s += amount;
    return this;
  }
  grayscale(returnNewInstance = this.settings.returnNewInstance) {
    if (returnNewInstance) {
      const n = this.clone();
      n.s = 0;
      return n;
    }
    this.s = 0;
    return this;
  }
  spin(amount, returnNewInstance = this.settings.returnNewInstance) {
    amount = parseInt(amount);
    const hue = this.h;
    let newHue = hue + amount;
    if (newHue > 360) {
      newHue -= 360;
    }
    if (returnNewInstance) {
      const n = this.clone();
      n.h = newHue;
      return n;
    }
    this.h = newHue;
    return this;
  }
  alpha(alpha, returnNewInstance = this.settings.returnNewInstance) {
    alpha = parseFloat(alpha);
    if (returnNewInstance) {
      const n = this.clone();
      n.a = alpha;
      return n;
    }
    this.a = alpha;
    return this;
  }
  darken(amount, returnNewInstance = this.settings.returnNewInstance) {
    amount = parseInt(amount);
    if (returnNewInstance) {
      const n = this.clone();
      n.l -= amount;
      return n;
    }
    this.l -= amount;
    if (this.l < 0)
      this.l = 0;
    else if (this.l > 100)
      this.l = 100;
    return this;
  }
  lighten(amount, returnNewInstance = this.settings.returnNewInstance) {
    amount = parseInt(amount);
    if (returnNewInstance) {
      const n = this.clone();
      n.l += amount;
      return n;
    }
    this.l += amount;
    if (this.l < 0)
      this.l = 0;
    else if (this.l > 100)
      this.l = 100;
    return this;
  }
  invert(returnNewInstance = this.settings.returnNewInstance) {
    let lightness = this.l;
    if (this.l >= 50) {
      lightness -= 50;
    } else {
      lightness += 50;
    }
    if (returnNewInstance) {
      const n = this.clone();
      n.l = lightness;
      return n;
    } else {
      this.l = lightness;
    }
    if (this.l < 0)
      this.l = 0;
    else if (this.l > 100)
      this.l = 100;
    return this;
  }
  toObject() {
    return {
      r: this.r,
      g: this.b,
      b: this.b,
      a: this.a,
      h: this.h,
      s: this.s,
      l: this.l,
      hex: this.toHexString(),
      hexa: this.toHexaString(),
      rgb: this.toRgbString(),
      rgba: this.toRgbaString(),
      hsl: this.toHslString(),
      hsla: this.toHslaString()
    };
  }
  toHexString() {
    return this._convert2("hex");
  }
  toHexaString() {
    return this._convert2("hexa");
  }
  toRgbString() {
    return `rgb(${this._r},${this._g},${this._b})`;
  }
  toRgbaString() {
    return `rgba(${this._r},${this._g},${this._b},${this._a})`;
  }
  toHslString() {
    const hsl = this._convert2("hsl");
    return `hsl(${hsl.h},${hsl.s},${hsl.l})`;
  }
  toHslaString() {
    const hsla = this._convert2("hsla");
    return `hsla(${hsla.h},${hsla.s},${hsla.l},${hsla.a})`;
  }
  toString(format2 = this.settings.defaultFormat) {
    switch (format2) {
      case "hex":
        return this.toHexString();
      case "hsl":
        return this.toHslString();
      case "hsla":
        return this.toHslaString();
      case "rgb":
        return this.toRgbString();
      case "rgba":
      default:
        return this.toRgbaString();
    }
  }
}
SColor.colors = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  "indianred ": "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavender: "#e6e6fa",
  lavenderblush: "#fff0f5",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgrey: "#d3d3d3",
  lightgreen: "#90ee90",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370d8",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#d87093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
class SSugarConfig {
  static get finalConfig() {
    var _a3, _b2;
    if (SSugarConfig._finalConfig)
      return SSugarConfig._finalConfig;
    SSugarConfig._finalConfig = __deepMerge(
      (_b2 = (_a3 = document.env.SUGAR) === null || _a3 === void 0 ? void 0 : _a3.config) !== null && _b2 !== void 0 ? _b2 : {}
    );
    return SSugarConfig._finalConfig;
  }
  static get(dotpath) {
    return get(SSugarConfig.finalConfig, dotpath);
  }
  static set(dotpath, value) {
    return __set(SSugarConfig.finalConfig, dotpath, value);
  }
}
globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __awaiter$r = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function __adoptStyleInShadowRoot($shadowRoot, $context = document) {
  return __awaiter$r(this, void 0, void 0, function* () {
    const $links = $context.querySelectorAll('link[rel="stylesheet"]');
    if ($links && $shadowRoot) {
      Array.from($links).forEach(($link) => __awaiter$r(this, void 0, void 0, function* () {
        $shadowRoot === null || $shadowRoot === void 0 ? void 0 : $shadowRoot.appendChild($link.cloneNode());
      }));
    }
    return true;
  });
}
var fastdom = { exports: {} };
(function(module) {
  !function(win) {
    var debug = function() {
    };
    var raf = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.msRequestAnimationFrame || function(cb) {
      return setTimeout(cb, 16);
    };
    function FastDom() {
      var self2 = this;
      self2.reads = [];
      self2.writes = [];
      self2.raf = raf.bind(win);
    }
    FastDom.prototype = {
      constructor: FastDom,
      runTasks: function(tasks) {
        var task;
        while (task = tasks.shift())
          task();
      },
      measure: function(fn2, ctx) {
        var task = !ctx ? fn2 : fn2.bind(ctx);
        this.reads.push(task);
        scheduleFlush(this);
        return task;
      },
      mutate: function(fn2, ctx) {
        var task = !ctx ? fn2 : fn2.bind(ctx);
        this.writes.push(task);
        scheduleFlush(this);
        return task;
      },
      clear: function(task) {
        return remove(this.reads, task) || remove(this.writes, task);
      },
      extend: function(props) {
        if (typeof props != "object")
          throw new Error("expected object");
        var child = Object.create(this);
        mixin(child, props);
        child.fastdom = this;
        if (child.initialize)
          child.initialize();
        return child;
      },
      catch: null
    };
    function scheduleFlush(fastdom2) {
      if (!fastdom2.scheduled) {
        fastdom2.scheduled = true;
        fastdom2.raf(flush.bind(null, fastdom2));
      }
    }
    function flush(fastdom2) {
      var writes = fastdom2.writes;
      var reads = fastdom2.reads;
      var error2;
      try {
        debug("flushing reads", reads.length);
        fastdom2.runTasks(reads);
        debug("flushing writes", writes.length);
        fastdom2.runTasks(writes);
      } catch (e) {
        error2 = e;
      }
      fastdom2.scheduled = false;
      if (reads.length || writes.length)
        scheduleFlush(fastdom2);
      if (error2) {
        debug("task errored", error2.message);
        if (fastdom2.catch)
          fastdom2.catch(error2);
        else
          throw error2;
      }
    }
    function remove(array, item) {
      var index = array.indexOf(item);
      return !!~index && !!array.splice(index, 1);
    }
    function mixin(target, source2) {
      for (var key in source2) {
        if (source2.hasOwnProperty(key))
          target[key] = source2[key];
      }
    }
    var exports = win.fastdom = win.fastdom || new FastDom();
    module.exports = exports;
  }(typeof window !== "undefined" ? window : commonjsGlobal);
})(fastdom);
const __fastdom = fastdom.exports;
function __expandPleasantCssClassname(classesStr) {
  const classesArray = [];
  const classNames = classesStr.split(/\s+/);
  let currentMedia = "";
  classNames.forEach((className) => {
    if (className.slice(0, 1) == "@") {
      currentMedia = className.replace("@", "___");
      return;
    }
    const parts = className.split(":");
    if (parts.length === 1) {
      let name2 = className;
      if (currentMedia !== "")
        name2 = className + currentMedia;
      classesArray.push(name2);
    } else {
      const firstClass = parts[0];
      let name2 = firstClass;
      if (currentMedia !== "")
        name2 = firstClass + currentMedia;
      classesArray.push(name2);
      parts.forEach((part, i2) => {
        if (i2 > 0) {
          name2 = firstClass + "--" + part;
          if (currentMedia !== "")
            name2 = name2 + currentMedia;
          classesArray.push(name2);
        }
      });
    }
  });
  return classesArray.join(" ");
}
function __expandPleasantCssClassnamesLive(settings) {
  settings = Object.assign({ afterFirst: void 0, rootNode: document }, settings);
  __querySelectorLive('[class*=":"]:not(code [class*=":"]):not(template [class*=":"]),[class*="@"]:not(code [class*="@"]):not(template [class*="@"])', ($elm) => {
    const classesStr = $elm.getAttribute("class");
    const newClassesStr = __expandPleasantCssClassname(classesStr);
    __fastdom.mutate(() => {
      $elm.setAttribute("class", newClassesStr);
    });
  }, {
    afterFirst: settings.afterFirst,
    rootNode: settings === null || settings === void 0 ? void 0 : settings.rootNode
  });
}
var _a$7, _b$4;
let oldX = 0, oldY = 0;
const threshold = 0;
try {
  (_a$7 = document === null || document === void 0 ? void 0 : document.addEventListener) === null || _a$7 === void 0 ? void 0 : _a$7.call(document, "pointermove", (e) => {
    calculateDirection(e);
  });
  (_b$4 = document === null || document === void 0 ? void 0 : document.addEventListener) === null || _b$4 === void 0 ? void 0 : _b$4.call(document, "pointerdown", (e) => {
    calculateDirection(e);
  });
} catch (e) {
}
function calculateDirection(e) {
  if (e.pageX < oldX - threshold) {
    oldX - e.pageX;
    oldX = e.pageX;
  } else if (e.pageX > oldX + threshold) {
    e.pageX - oldX;
    oldX = e.pageX;
  }
  if (e.pageY < oldY - threshold) {
    oldY - e.pageY;
    oldY = e.pageY;
  } else if (e.pageY > oldY + threshold) {
    e.pageY - oldY;
    oldY = e.pageY;
  }
}
function __onScrollEnd($elm, callback, settings) {
  const finalSettings = Object.assign({ offset: 20, once: false, times: -1 }, settings !== null && settings !== void 0 ? settings : {});
  let isBody = false;
  let $scrollListenedElm = $elm;
  let $scrollHeightElm = $elm;
  if ($elm === window.document.body) {
    isBody = true;
    $scrollListenedElm = document;
    $scrollHeightElm = window.document.body;
  } else if ($elm === window.document) {
    isBody = true;
    $elm = window.document.body;
    $scrollHeightElm = window.document.body;
  }
  let active = true, count = 0;
  const internalCallback = (e) => {
    let fullHeight, viewportHeight, scrollTop2;
    if (isBody) {
      viewportHeight = window.innerHeight;
      scrollTop2 = $scrollHeightElm.scrollTop;
      fullHeight = Math.max(window.document.body.scrollHeight, window.document.documentElement.scrollHeight, window.document.body.offsetHeight, window.document.documentElement.offsetHeight, window.document.body.clientHeight, window.document.documentElement.clientHeight);
    } else {
      viewportHeight = $scrollHeightElm.offsetHeight;
      scrollTop2 = $scrollHeightElm.scrollTop;
      fullHeight = $scrollHeightElm.scrollHeight;
    }
    if (active && scrollTop2 + viewportHeight >= fullHeight - finalSettings.offset) {
      callback();
      count++;
      if (finalSettings.once) {
        $scrollListenedElm.removeEventListener("scroll", internalCallback);
        active = false;
      } else if (finalSettings.times > 0 && count >= finalSettings.times) {
        $scrollListenedElm.removeEventListener("scroll", internalCallback);
        active = false;
      }
    } else if ($scrollHeightElm.offsetHeight + $scrollHeightElm.scrollTop < $scrollHeightElm.scrollHeight - finalSettings.offset) {
      active = true;
    }
  };
  $scrollListenedElm.addEventListener("scroll", internalCallback);
}
function __onSwipe(elm, cb, settings = {}) {
  settings = Object.assign({ threshold: 100 }, settings);
  let touchstartX = 0;
  let touchstartY = 0;
  let touchendX = 0;
  let touchendY = 0;
  const gesuredZone = elm;
  gesuredZone.addEventListener("touchstart", function(event) {
    touchstartX = event.changedTouches[0].screenX;
    touchstartY = event.changedTouches[0].screenY;
  }, false);
  gesuredZone.addEventListener("touchend", function(event) {
    touchendX = event.changedTouches[0].screenX;
    touchendY = event.changedTouches[0].screenY;
    handleGesure();
  }, false);
  function handleGesure() {
    const swipeNfo = {
      distanceX: Math.abs(touchendX - touchstartX),
      distanceY: Math.abs(touchendY - touchstartY)
    };
    if (touchendX + settings.threshold < touchstartX) {
      swipeNfo.left = true;
    }
    if (touchendX - settings.threshold > touchstartX) {
      swipeNfo.right = true;
    }
    if (touchendY + settings.threshold < touchstartY) {
      swipeNfo.up = true;
    }
    if (touchendY - settings.threshold > touchstartY) {
      swipeNfo.down = true;
    }
    if (swipeNfo.left || swipeNfo.right || swipeNfo.down || swipeNfo.up) {
      cb(swipeNfo);
    }
  }
}
var __awaiter$q = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const triggers = [
  "direct",
  "directly",
  "inViewport",
  "nearViewport",
  "enterViewport",
  "outOfViewport",
  "interact",
  "visible",
  "stylesheetsReady",
  "domReady",
  "animationEnd",
  "lod:0",
  "lod:1",
  "lod:2",
  "lod:3",
  "lod:4"
];
function __when($elm, trigger2, settings) {
  const finalSettings = Object.assign({ whenInViewport: {}, whenNearViewport: {}, whenOutOfViewport: {}, whenInteract: {}, whenVisible: {}, whenStylesheetsReady: {} }, settings !== null && settings !== void 0 ? settings : {});
  return new SPromise(({ resolve, reject }) => __awaiter$q(this, void 0, void 0, function* () {
    if (!Array.isArray(trigger2))
      trigger2 = trigger2.split(",").map((t) => t.trim());
    const promises = [];
    trigger2.forEach((t) => {
      const lodMatches = t.match(/^lod\:([0-9]{1,2})/);
      if (lodMatches && lodMatches[1]) {
        const level = parseInt(lodMatches[1]);
        promises.push(whenLod(level));
        return;
      }
      switch (t) {
        case "inViewport":
          promises.push(__whenInViewport($elm, finalSettings.whenInViewport));
          break;
        case "nearViewport":
          promises.push(__whenNearViewport($elm, finalSettings.whenNearViewport));
          break;
        case "entersViewport":
          promises.push(__whenEntersViewport($elm, finalSettings.whenEntersViewport));
          break;
        case "outOfViewport":
          promises.push(__whenOutOfViewport($elm, finalSettings.whenOutOfViewport));
          break;
        case "interact":
          promises.push(__whenInteract($elm, finalSettings.whenInteract));
          break;
        case "visible":
          promises.push(__whenVisible($elm, {
            whenVisible: finalSettings.whenVisible,
            once: true
          }));
          break;
        case "domReady":
          promises.push(__whenDomReady());
          break;
        case "stylesheetsReady":
          promises.push(__whenStylesheetsReady($elm ? [$elm] : null));
          break;
        case "animationEnd":
          promises.push(__whenAnimationEnd($elm));
          break;
      }
    });
    if (!trigger2.length || trigger2.includes("direct") || trigger2.includes("directly")) {
      resolve($elm);
      return;
    }
    yield Promise.race(promises);
    resolve($elm);
  }));
}
function __whenAnimationEnd($elm) {
  return new SPromise(({ resolve }) => {
    __addEventListenerOnce($elm, "animationend", (e) => {
      resolve($elm);
    });
  });
}
globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function __whenDomReady() {
  return new Promise((resolve) => {
    if (document.readyState === "complete") {
      resolve();
    } else {
      document.onreadystatechange = () => {
        if (document.readyState === "complete") {
          resolve();
        }
      };
    }
  });
}
var __awaiter$p = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function __whenEntersViewport(elm, settings = {}) {
  function getRootMargin() {
    return [
      `${Math.round(window.innerHeight * 0.15 * -1)}px`,
      `${Math.round(window.innerWidth * 0.15 * -1)}px`,
      `${Math.round(window.innerHeight * 0.15 * -1)}px`,
      `${Math.round(window.innerWidth * 0.15 * -1)}px`
    ].join(" ");
  }
  settings = Object.assign({}, settings);
  let observer, resizeTimeout;
  return new Promise((resolve) => __awaiter$p(this, void 0, void 0, function* () {
    var _a3;
    const options = {
      root: null,
      rootMargin: (_a3 = settings.offset) !== null && _a3 !== void 0 ? _a3 : getRootMargin(),
      threshold: 0
    };
    if (__isInViewport(elm)) {
      return resolve(elm);
    }
    function onChange(changes, observer2) {
      changes.forEach((change) => {
        var _a4;
        if (change.intersectionRatio > 0) {
          (_a4 = observer2.disconnect) === null || _a4 === void 0 ? void 0 : _a4.call(observer2);
          resolve(elm);
        }
      });
    }
    observer = new IntersectionObserver(onChange, options);
    observer.observe(elm);
    window.addEventListener("resize", (e) => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        var _a4, _b2;
        (_a4 = observer.disconnect) === null || _a4 === void 0 ? void 0 : _a4.call(observer);
        options.rootMargin = (_b2 = settings.offset) !== null && _b2 !== void 0 ? _b2 : getRootMargin();
        observer = new IntersectionObserver(onChange, options);
        observer.observe(elm);
      }, 500);
    });
  }));
}
function __whenImageLoaded($img, callback = null) {
  let imgLoadedHandler, imgErrorHandler;
  const pro = new SPromise(({ resolve, reject }) => {
    if ($img.hasAttribute("src") && $img.complete) {
      resolve($img);
      callback && callback($img);
    } else {
      imgLoadedHandler = (e) => {
        resolve($img);
        callback && callback($img);
      };
      $img.addEventListener("load", imgLoadedHandler);
      imgErrorHandler = (e) => {
        reject(e);
      };
      $img.addEventListener("error", imgErrorHandler);
    }
  }, {
    id: "whenImageLoaded"
  });
  pro.on("finally", () => {
    imgLoadedHandler && $img.removeEventListener("load", imgLoadedHandler);
    imgErrorHandler && $img.removeEventListener("error", imgErrorHandler);
  });
  return pro;
}
function __whenImagesLoaded($imgs, cb = null) {
  return new SPromise(({ resolve, reject, emit }) => {
    const promises = [], loadedImages = [];
    Array.from($imgs).forEach(($img) => {
      promises.push(__whenImageLoaded($img).then((_$img) => {
        loadedImages.push(_$img);
        emit("img.loaded", _$img);
        if (loadedImages.length === $imgs.length) {
          emit("loaded", loadedImages);
          if (cb)
            cb(loadedImages);
          resolve(loadedImages);
        }
      }).catch((error2) => {
        reject(error2);
      }));
    });
  });
}
class WhenInteractSettingsInterface extends SInterface {
  static get _definition() {
    return {
      pointerover: {
        description: "Specify if the pointerover event has to be used",
        type: "Boolean",
        default: true
      },
      pointerout: {
        description: "Specify if the pointerout event has to be used",
        type: "Boolean",
        default: true
      },
      click: {
        description: "Specify if the click event has to be used",
        type: "Boolean",
        default: true
      },
      touchstart: {
        description: "Specify if the touchstart event has to be used",
        type: "Boolean",
        default: true
      },
      touchend: {
        description: "Specify if the touchend event has to be used",
        type: "Boolean",
        default: true
      },
      focus: {
        description: "Specify if the focus event has to be used",
        type: "Boolean",
        default: true
      }
    };
  }
}
function __whenInteract(elm, settings) {
  return new Promise((resolve, reject) => {
    settings = WhenInteractSettingsInterface.apply(settings !== null && settings !== void 0 ? settings : {});
    function interacted(interaction) {
      console.log("interacted", interaction);
      resolve(interaction);
      elm.removeEventListener("pointerover", pointerover);
      elm.removeEventListener("pointerout", pointerout);
      elm.removeEventListener("pointerdown", pointerdown);
      elm.removeEventListener("touchstart", touchstart);
      elm.removeEventListener("touchend", touchend);
      elm.removeEventListener("focus", focus);
      elm.removeEventListener("focusin", focus);
    }
    function pointerover(e) {
      interacted("pointerover");
    }
    if (settings.pointerover) {
      elm.addEventListener("pointerover", pointerover);
    }
    function pointerout(e) {
      interacted("pointerout");
    }
    if (settings.pointerout) {
      elm.addEventListener("pointerout", pointerout);
    }
    function pointerdown(e) {
      interacted("pointerdown");
    }
    if (settings.pointerdown) {
      elm.addEventListener("pointerdown", pointerdown);
    }
    function touchstart(e) {
      interacted("touchstart");
    }
    if (settings.touchstart) {
      elm.addEventListener("touchstart", touchstart, {
        passive: true
      });
    }
    function touchend(e) {
      interacted("touchend");
    }
    if (settings.touchend) {
      elm.addEventListener("touchend", touchend);
    }
    function focus(e) {
      interacted("focus");
    }
    if (settings.focus === true) {
      elm.addEventListener("focus", focus);
      elm.addEventListener("focusin", focus);
    }
  });
}
function __whenInViewport($elm, settings = {}) {
  settings = Object.assign({ offset: "10px", once: true, whenIn: null, whenOut: null }, settings);
  let observer;
  const id2 = __uniqid();
  const pro = new SPromise(({ resolve, emit }) => {
    const options = {
      root: null,
      rootMargin: settings.offset,
      threshold: 0
    };
    if (!$elm._whenInViewportStatus) {
      $elm._whenInViewportStatus = {};
    }
    function onChange(changes) {
      changes.forEach((change) => {
        var _a3, _b2;
        if (change.intersectionRatio === 0) {
          if (!$elm._whenInViewportStatus[id2]) {
            return;
          }
          $elm._whenInViewportStatus[id2] = false;
          (_a3 = settings.whenOut) === null || _a3 === void 0 ? void 0 : _a3.call(settings, $elm);
          emit("out", $elm);
        } else {
          if (settings.once) {
            observer.disconnect();
          }
          if ($elm._whenInViewportStatus[id2]) {
            return;
          }
          $elm._whenInViewportStatus[id2] = true;
          (_b2 = settings.whenIn) === null || _b2 === void 0 ? void 0 : _b2.call(settings, $elm);
          emit("in", $elm);
          if (settings.once) {
            resolve($elm);
          }
        }
      });
    }
    observer = new IntersectionObserver(onChange, options);
    observer.observe($elm);
  });
  pro.on("cancel", () => {
    observer === null || observer === void 0 ? void 0 : observer.disconnect();
  });
  return pro;
}
function alreadyLoaded(link) {
  const href = link.href;
  let result2 = false;
  for (let i2 = 0; i2 < document.styleSheets.length; i2++) {
    if (document.styleSheets[i2].href && document.styleSheets[i2].href.match(href)) {
      result2 = true;
    } else if (i2 == document.styleSheets.length - 1)
      ;
  }
  return result2;
}
function __whenLinkLoaded(link, cb = null) {
  return new Promise((resolve, reject) => {
    if (alreadyLoaded(link)) {
      resolve(link);
      cb === null || cb === void 0 ? void 0 : cb(link);
    } else {
      const img = document.createElement("img");
      img.addEventListener("error", (e) => {
        resolve(link);
        cb === null || cb === void 0 ? void 0 : cb(link);
      });
      img.src = link.href;
    }
  });
}
function whenLod(level) {
  return new Promise((resolve) => {
    if (document.body.classList.contains(`s-lod--${level}`)) {
      return resolve();
    }
    const observer = new MutationObserver((mutationList, observer2) => {
      for (const mutation of mutationList) {
        if (mutation.type === "attributes" && mutation.attributeName === "class") {
          if (document.body.classList.contains(`s-lod--${level}`)) {
            observer2.disconnect();
            return resolve();
          }
        }
      }
    });
    observer.observe(document.body, {
      attributeFilter: ["class"],
      attributes: true
    });
  });
}
var __awaiter$o = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function __whenNearViewport(elm, settings = {}) {
  function getRootMargin() {
    return [
      `${Math.round(window.innerHeight * 0.5)}px`,
      `${Math.round(window.innerWidth * 0.5)}px`,
      `${Math.round(window.innerHeight * 0.5)}px`,
      `${Math.round(window.innerWidth * 0.5)}px`
    ].join(" ");
  }
  settings = Object.assign({}, settings);
  let observer, resizeTimeout;
  let $closest = __closestScrollable(elm);
  if (($closest === null || $closest === void 0 ? void 0 : $closest.tagName) === "HTML")
    $closest = null;
  return new SPromise(({ resolve }) => __awaiter$o(this, void 0, void 0, function* () {
    var _a3;
    const options = {
      root: $closest,
      rootMargin: (_a3 = settings.offset) !== null && _a3 !== void 0 ? _a3 : getRootMargin(),
      threshold: 0
    };
    function onChange(changes, observer2) {
      changes.forEach((change) => {
        var _a4;
        if (change.intersectionRatio > 0) {
          (_a4 = observer2.disconnect) === null || _a4 === void 0 ? void 0 : _a4.call(observer2);
          resolve(elm);
        }
      });
    }
    observer = new IntersectionObserver(onChange, options);
    observer.observe(elm);
    window.addEventListener("resize", (e) => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        var _a4, _b2;
        (_a4 = observer.disconnect) === null || _a4 === void 0 ? void 0 : _a4.call(observer);
        options.rootMargin = (_b2 = settings.offset) !== null && _b2 !== void 0 ? _b2 : getRootMargin();
        observer = new IntersectionObserver(onChange, options);
        observer.observe(elm);
      }, 500);
    });
  }));
}
function __whenOutOfViewport(elm, settings = {}) {
  return new Promise((resolve, reject) => {
    settings = Object.assign({ offset: "10px" }, settings);
    let isInViewport = false;
    const _cb = () => {
      if (!isInViewport) {
        observer.disconnect();
        resolve(elm);
      }
    };
    const observer = new IntersectionObserver((entries, observer2) => {
      if (!entries.length)
        return;
      const entry = entries[0];
      if (entry.intersectionRatio > 0) {
        isInViewport = true;
      } else {
        isInViewport = false;
      }
      _cb();
    }, {
      root: null,
      rootMargin: settings.offset,
      threshold: [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]
    });
    observer.observe(elm);
  });
}
function __whenRemoved($elm) {
  return new Promise((resolve, reject) => {
    const observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mutation) {
        mutation.removedNodes.forEach(function(removedNode) {
          if (removedNode === $elm) {
            resolve($elm);
            observer.disconnect();
          }
        });
      });
    });
    observer.observe($elm.parentElement, {
      subtree: false,
      childList: true
    });
  });
}
function __whenStylesheetsReady(links = null, cb = null) {
  if (!links) {
    links = Array.from(document.querySelectorAll('link[rel="stylesheet"]'));
  }
  const promises = [];
  [].forEach.call(links, ($link) => {
    promises.push(__whenLinkLoaded($link));
  });
  const allPromises = Promise.all(promises);
  allPromises.then(() => {
    cb === null || cb === void 0 ? void 0 : cb();
  });
  return allPromises;
}
function splitIfNeeded(what, separator) {
  var _a3;
  if ((_a3 = what.includes) === null || _a3 === void 0 ? void 0 : _a3.call(what, separator)) {
    return what.split(separator).map((item) => item.trim());
  }
  return [what];
}
function getTransitionProperties(elm) {
  const property = __getStyleProperty(elm, "transition-property");
  const duration = __getStyleProperty(elm, "transition-duration") || 0;
  const timingFunction = __getStyleProperty(elm, "transition-timing-function");
  const delay = __getStyleProperty(elm, "transition-delay");
  const props = {
    property: splitIfNeeded(property, ","),
    duration: splitIfNeeded(duration, ",").map((value) => __convertTime(value, "ms")),
    delay: splitIfNeeded(delay, ",").map((value) => __convertTime(value, "ms")),
    timingFunction: splitIfNeeded(timingFunction, ",")
  };
  let totalDuration = 0;
  let i2 = 0;
  const delays = [0].concat(props.delay);
  [0].concat(props.duration).forEach((val) => {
    if (val + delays[i2] > totalDuration) {
      totalDuration = val + delays[i2];
    }
    i2++;
  });
  props.totalDuration = totalDuration;
  return props;
}
function __whenVisible($elm, settings) {
  const pro = new SPromise(({ resolve, reject, emit }) => {
    const finalSettings = Object.assign({ whenVisible: null, whenInvisible: null, once: true }, settings !== null && settings !== void 0 ? settings : {});
    if (!$elm._whenVisibleStatus) {
      $elm._whenVisibleStatus = {};
    }
    const id2 = __uniqid();
    var observer = new IntersectionObserver(function(entries) {
      var _a3, _b2;
      if (entries[0]["intersectionRatio"] == 0) {
        if (!$elm._whenVisibleStatus[id2]) {
          return;
        }
        $elm._whenVisibleStatus[id2] = false;
        (_a3 = finalSettings.whenInvisible) === null || _a3 === void 0 ? void 0 : _a3.call(finalSettings, $elm);
        emit("invisible", $elm);
      } else {
        if (finalSettings.once) {
          observer.disconnect();
        }
        if ($elm._whenVisibleStatus[id2]) {
          return;
        }
        $elm._whenVisibleStatus[id2] = true;
        (_b2 = finalSettings.whenVisible) === null || _b2 === void 0 ? void 0 : _b2.call(finalSettings, $elm);
        emit("visible", $elm);
        if (finalSettings.once) {
          resolve($elm);
        }
      }
    });
    observer.observe($elm);
    pro.on("cancel", () => {
      observer === null || observer === void 0 ? void 0 : observer.disconnect();
    });
    return pro;
  });
}
function __distanceFromElementTopToViewportBottom(elm) {
  const offsets = __offsetFromViewport(elm);
  const scrollTop$1 = scrollTop();
  const viewportHeight = window.innerHeight;
  const distance = viewportHeight - offsets.top + scrollTop$1;
  return distance;
}
function __distanceFromElementTopToViewportTop(elm) {
  const offsets = __offsetFromViewport(elm);
  const scrollTop$1 = scrollTop();
  return offsets.top - scrollTop$1;
}
function __scrollLeft() {
  return window.pageXOffset || document.scrollLeft || document.body.scrollLeft;
}
function scrollTop() {
  return window.pageYOffset || document.scrollTop || document.body.scrollTop;
}
function __elementAreaStats($elm, settings) {
  const finalSettings = Object.assign({ relativeTo: "visible" }, settings !== null && settings !== void 0 ? settings : {});
  if (finalSettings.relativeTo === "visible") {
    finalSettings.relativeTo = __traverseUp($elm, ($item) => {
      const style = window.getComputedStyle($item);
      if (style.overflow === "hidden")
        return $item;
      return false;
    });
  }
  let rootBoundingRect;
  if ((finalSettings === null || finalSettings === void 0 ? void 0 : finalSettings.relativeTo) && finalSettings.relativeTo instanceof HTMLElement) {
    rootBoundingRect = finalSettings === null || finalSettings === void 0 ? void 0 : finalSettings.relativeTo.getBoundingClientRect();
  } else {
    rootBoundingRect = {
      top: scrollTop(),
      left: __scrollLeft(),
      width: Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0),
      height: Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0)
    };
  }
  const boundingRect = $elm.getBoundingClientRect();
  const left = boundingRect.left - rootBoundingRect.left, top = boundingRect.top - rootBoundingRect.top;
  let percentageX, percentageY;
  if (boundingRect.left + boundingRect.width < rootBoundingRect.left) {
    percentageX = 0;
  } else if (boundingRect.left > rootBoundingRect.left + rootBoundingRect.width) {
    percentageX = 0;
  } else if (boundingRect.left >= rootBoundingRect.left && boundingRect.left + boundingRect.width <= rootBoundingRect.left + rootBoundingRect.width) {
    percentageX = 100;
  } else if (boundingRect.left < rootBoundingRect.left && boundingRect.left + boundingRect.width > rootBoundingRect.left + rootBoundingRect.width) {
    percentageX = 100 / boundingRect.width * rootBoundingRect.width;
  } else if (boundingRect.left < rootBoundingRect.left && boundingRect.left + boundingRect.width <= rootBoundingRect.left + rootBoundingRect.width) {
    percentageX = 100 / boundingRect.width * (boundingRect.left + boundingRect.width - rootBoundingRect.left);
  } else if (boundingRect.left < rootBoundingRect.left + rootBoundingRect.width && boundingRect.left + boundingRect.width > rootBoundingRect.left + rootBoundingRect.width) {
    percentageX = 100 / boundingRect.width * (boundingRect.width - (boundingRect.left + boundingRect.width - (rootBoundingRect.left + rootBoundingRect.width)));
  }
  if (boundingRect.left + boundingRect.height < rootBoundingRect.top) {
    percentageY = 0;
  } else if (boundingRect.top > rootBoundingRect.top + rootBoundingRect.height) {
    percentageY = 0;
  } else if (boundingRect.top >= rootBoundingRect.top && boundingRect.top + boundingRect.height <= rootBoundingRect.top + rootBoundingRect.height) {
    percentageY = 100;
  } else if (boundingRect.top < rootBoundingRect.top && boundingRect.top + boundingRect.height > rootBoundingRect.top + rootBoundingRect.height) {
    percentageY = 100 / boundingRect.height * rootBoundingRect.height;
  } else if (boundingRect.top < rootBoundingRect.top && boundingRect.top + boundingRect.height <= rootBoundingRect.top + rootBoundingRect.height) {
    percentageY = 100 / boundingRect.height * (boundingRect.top + boundingRect.height - rootBoundingRect.top);
  } else if (boundingRect.top < rootBoundingRect.top + rootBoundingRect.height && boundingRect.top + boundingRect.height > rootBoundingRect.top + rootBoundingRect.height) {
    percentageY = 100 / boundingRect.height * (boundingRect.height - (boundingRect.top + boundingRect.height - (rootBoundingRect.top + rootBoundingRect.height)));
  }
  const surfaceX = boundingRect.width / 100 * percentageX, surfaceY = boundingRect.height / 100 * percentageY;
  const percentage = percentageX > 0 && percentageY > 0 ? 100 / 200 * (percentageX + percentageY) : 0;
  return {
    percentage,
    percentageX: percentageY > 0 ? percentageX : 0,
    percentageY: percentageX > 0 ? percentageY : 0,
    centerOffsetX: (rootBoundingRect.width * 0.5 - left - boundingRect.width * 0.5) * -1,
    centerOffsetY: (rootBoundingRect.height * 0.5 - top - boundingRect.height * 0.5) * -1,
    width: percentageX > 0 && percentageY > 0 ? surfaceX : 0,
    height: percentageY > 0 && percentageX > 0 ? surfaceY : 0,
    left: boundingRect.left,
    relLeft: left,
    top: boundingRect.top,
    relTop: top
  };
}
function __addEventListener($elm, eventNames, callback = null, useCapture = false) {
  if (!Array.isArray(eventNames))
    eventNames = eventNames.split(",").map((e) => e.trim());
  if (callback && typeof callback === "function")
    callback = callback;
  else if (callback && typeof callback === "boolean")
    useCapture = callback;
  const eventsStack = {};
  const promise = new SPromise({
    id: "addEventListener"
  }).on("finally", () => {
    eventNames.forEach((eventName) => {
      const stack = eventsStack[eventName];
      $elm.removeEventListener(eventName, stack.callback, stack.useCapture);
    });
  });
  eventNames.forEach((eventName) => {
    const internalCallback = (event) => {
      if (callback)
        callback.apply(this, [event]);
      promise.emit(eventName, event);
    };
    eventsStack[eventName] = {
      callback: internalCallback,
      useCapture
    };
    $elm.addEventListener(eventName, internalCallback, useCapture);
  });
  return promise;
}
function __addEventListenerOnce($elm, eventNames, callback = null, useCapture = false) {
  if (!Array.isArray(eventNames))
    eventNames = [eventNames];
  const globalPromise = new SPromise({
    id: "addEventListenerOnce"
  });
  const eventsStack = {};
  globalPromise.on("finally", () => {
    eventNames.forEach((eventName) => {
      eventsStack[eventName].promise.cancel();
    });
  });
  eventNames.forEach((eventName) => {
    const promise = __addEventListener($elm, eventName, null, useCapture);
    eventsStack[eventName] = {
      promise
    };
    promise.on(eventNames, (event) => {
      if (callback && typeof callback === "function") {
        callback.apply(this, [event]);
      }
      globalPromise.emit(eventName, event);
      promise.cancel();
    });
  });
  return globalPromise;
}
function __injectStyle(style, settings) {
  var _a3;
  const finalSettings = Object.assign({ id: `injected-style-${__uniqid()}`, rootNode: void 0 }, settings !== null && settings !== void 0 ? settings : {});
  if (document.querySelector(`#${finalSettings.id}`))
    return;
  const $tag = document.createElement("style");
  $tag.type = "text/css";
  $tag.setAttribute("id", finalSettings.id);
  $tag.innerHTML = style;
  if (finalSettings.rootNode) {
    finalSettings.rootNode.appendChild($tag);
  } else {
    const $firstLink = document.querySelector('head link[rel="stylesheet"]');
    if ($firstLink) {
      (_a3 = $firstLink.parentElement) === null || _a3 === void 0 ? void 0 : _a3.insertBefore($tag, $firstLink);
    } else {
      document.head.appendChild($tag);
    }
  }
  return $tag;
}
function __cursorToEnd($input) {
  $input.focus();
  setTimeout(() => {
    if (typeof $input.selectionStart == "number") {
      $input.selectionStart = $input.selectionEnd = $input.value.length;
    } else if (typeof $input.createTextRange != "undefined") {
      var range2 = $input.createTextRange();
      range2.collapse(false);
      range2.select();
    }
  });
}
function __isFocusWithin($elm) {
  return $elm.parentElement.querySelector(":focus-within") === $elm;
}
function __isInViewport(elm, settings = {}) {
  settings = Object.assign({}, settings);
  const scrollTop2 = document.documentElement.scrollTop || document.body.scrollTop, scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;
  const containerHeight = window.innerHeight || document.documentElement.clientHeight, containerWidth = window.innerWidth || document.documentElement.clientWidth, rect = elm.getBoundingClientRect();
  const top = rect.top - scrollTop2, left = rect.left - scrollLeft, right = rect.right - scrollLeft, bottom = rect.bottom - scrollTop2;
  const isTopIn = top - containerHeight <= 0, isBottomIn = bottom <= containerHeight, isLeftIn = left >= 0 && left <= containerWidth, isRightIn = right >= 0 && right <= containerWidth;
  if ((isTopIn || isBottomIn) && (isLeftIn || isRightIn)) {
    return true;
  }
  if (top <= 0 && bottom >= containerHeight && left <= 0 && right >= containerWidth) {
    return true;
  }
  if (top <= 0 && bottom >= containerHeight && left <= 0 && isRightIn) {
    return true;
  }
  if (top <= 0 && bottom >= containerHeight && right >= containerWidth && isLeftIn) {
    return true;
  }
  if (left <= 0 && right >= containerWidth && top <= 0 && isBottomIn) {
    return true;
  }
  if (left <= 0 && right >= containerWidth && bottom >= containerHeight && isTopIn) {
    return true;
  }
  return false;
}
function __isScrollable($elm, settings) {
  settings = Object.assign({ x: true, y: true }, settings !== null && settings !== void 0 ? settings : {});
  const style = window.getComputedStyle($elm);
  var overflowY = style.overflowY.trim();
  var overflowX = style.overflowX.trim();
  const dir = {
    vertical: (overflowY === "scroll" || overflowY === "auto") && $elm.scrollHeight > $elm.clientHeight,
    horizontal: (overflowX === "scroll" || overflowX === "auto") && $elm.scrollWidth > $elm.clientWidth
  };
  if (settings.x && dir.horizontal)
    return true;
  if (settings.y && dir.vertical)
    return true;
  return false;
}
var _a$6, _b$3;
let _isUserScrolling = false, _isUserScrollingTimeout;
try {
  (_a$6 = document === null || document === void 0 ? void 0 : document.addEventListener) === null || _a$6 === void 0 ? void 0 : _a$6.call(document, "wheel", (e) => {
    _isUserScrolling = true;
    clearTimeout(_isUserScrollingTimeout);
    _isUserScrollingTimeout = setTimeout(() => {
      _isUserScrolling = false;
    }, 200);
  });
  (_b$3 = document === null || document === void 0 ? void 0 : document.addEventListener) === null || _b$3 === void 0 ? void 0 : _b$3.call(document, "touchmove", (e) => {
    _isUserScrolling = true;
    clearTimeout(_isUserScrollingTimeout);
    _isUserScrollingTimeout = setTimeout(() => {
      _isUserScrolling = false;
    }, 200);
  });
} catch (e) {
}
function __isUserScrolling($elm) {
  if ($elm._isUserInteractive !== void 0) {
    return $elm._isUserInteractive && _isUserScrolling;
  }
  $elm.addEventListener("mouseover", (e) => {
    $elm._isUserInteractive = true;
  });
  $elm.addEventListener("mouseout", (e) => {
    $elm._isUserInteractive = false;
  });
  $elm.addEventListener("touchstart", (e) => {
    $elm._isUserInteractive = true;
  });
  $elm.addEventListener("touchend", (e) => {
    $elm._isUserInteractive = false;
  });
  return $elm._isUserInteractive && _isUserScrolling;
}
function __stripTags(html2) {
  const tmp = document.createElement("div");
  tmp.innerHTML = html2;
  return tmp.textContent || tmp.innerText || "";
}
function __offsetFromViewport(elm) {
  const box = elm.getBoundingClientRect(), body = document.body, docEl = document.documentElement, scrollTop2 = window.pageYOffset || docEl.scrollTop || body.scrollTop, scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft, clientTop = docEl.clientTop || body.clientTop || 0, clientLeft = docEl.clientLeft || body.clientLeft || 0, top = box.top + scrollTop2 - clientTop, left = box.left + scrollLeft - clientLeft;
  return {
    top: Math.round(top),
    left: Math.round(left)
  };
}
function __closestScrollable($elm, selector) {
  const res = __traverseUp($elm, ($e2) => __isScrollable($e2));
  return res;
}
function __matches(el2, selector) {
  if (el2.nodeName == "#comment" || el2.nodeName == "#text") {
    return false;
  }
  const p = Element.prototype;
  const f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function(s2) {
    return [].indexOf.call(document.querySelectorAll(s2), this) !== -1;
  };
  return f.call(el2, selector);
}
var __awaiter$n = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function __querySelectorLive(selector, cb = null, settings = {}, _isFirstLevel = true) {
  var _a3, _b2, _c2, _d2, _e2;
  let _emit, noScopeSelector, observer, canceled = false;
  __uniqid();
  const selectedNodes = [];
  settings = __deepMerge({
    rootNode: document,
    once: true,
    afterFirst: null,
    scopes: true,
    firstOnly: false,
    attributes: [],
    when: void 0
  }, settings);
  const innerPromises = [];
  if (settings.scopes) {
    noScopeSelector = selector.split(",").map((sel) => {
      return `${sel.trim()}:not([s-scope] ${sel.trim()})`;
    }).join(",");
  }
  const pro = new SPromise(({ resolve, reject, emit, pipe }) => {
    _emit = emit;
  });
  function isCanceled() {
    return selectedNodes.length && canceled && _isFirstLevel;
  }
  if (isCanceled()) {
    return;
  }
  function handleNode(node, sel) {
    if (isCanceled()) {
      return;
    }
    _emit === null || _emit === void 0 ? void 0 : _emit("node", {
      node,
      cancel() {
        pro.cancel();
      }
    });
    cb === null || cb === void 0 ? void 0 : cb(node, {
      cancel() {
        pro.cancel();
      }
    });
    if (settings.firstOnly) {
      pro.cancel();
    }
    if (!selectedNodes.includes(node)) {
      selectedNodes.push(node);
    }
  }
  function processNode(node, sel) {
    return __awaiter$n(this, void 0, void 0, function* () {
      if (!node.matches || isCanceled()) {
        return;
      }
      if (node.matches(selector) && (!settings.once || !selectedNodes.includes(node))) {
        if (settings.when) {
          yield __when(node, settings.when);
          if (isCanceled()) {
            return;
          }
          handleNode(node);
        } else {
          handleNode(node);
        }
      }
      findAndProcess(node, sel);
    });
  }
  function findAndProcess($root, sel) {
    if (!$root.querySelectorAll || isCanceled()) {
      return;
    }
    const nodes = Array.from($root === null || $root === void 0 ? void 0 : $root.querySelectorAll(sel));
    nodes.forEach((node) => {
      processNode(node, sel);
    });
  }
  if (settings.scopes && (settings.rootNode === document || !((_a3 = settings.rootNode) === null || _a3 === void 0 ? void 0 : _a3.hasAttribute("s-scope")))) {
    let isAfterCalledByScopeId = {};
    innerPromises.push(__querySelectorLive("[s-scope]", ($scope) => __awaiter$n(this, void 0, void 0, function* () {
      const scopeId = $scope.id || `s-scope-${__uniqid()}`;
      if ($scope.id !== scopeId) {
        $scope.setAttribute("id", scopeId);
      }
      if (isCanceled()) {
        return;
      }
      yield __when($scope, "nearViewport");
      if (isCanceled()) {
        return;
      }
      innerPromises.push(__querySelectorLive(selector, ($elm) => {
        processNode($elm, selector);
      }, Object.assign({}, settings, {
        rootNode: $scope,
        scopes: false,
        afterFirst() {
          if (isAfterCalledByScopeId[scopeId] && $scope._sQuerySelectorLiveScopeDirty) {
            return;
          }
          $scope._sQuerySelectorLiveScopeDirty = true;
          isAfterCalledByScopeId[scopeId] = true;
          __fastdom.mutate(() => {
            $scope.classList.add("ready");
            $scope.setAttribute("ready", "true");
          });
        }
      }), true));
    }), Object.assign({}, settings, {
      firstOnly: false,
      scopes: false
    }), false));
    innerPromises.push(__querySelectorLive(noScopeSelector, ($elm) => {
      processNode($elm, selector);
    }, Object.assign({}, settings, {
      scopes: false
    }), false));
    (_b2 = settings.afterFirst) === null || _b2 === void 0 ? void 0 : _b2.call(settings);
  } else {
    observer = new MutationObserver((mutations, obs) => {
      mutations.forEach((mutation) => {
        if (mutation.attributeName) {
          processNode(mutation.target, selector);
        }
        if (mutation.addedNodes) {
          mutation.addedNodes.forEach((node) => {
            processNode(node, selector);
          });
        }
      });
    });
    let observeSettings = {
      childList: true,
      subtree: true
    };
    selector.split(",").map((l) => l.trim()).forEach((sel) => {
      const attrMatches = sel.match(/\[[^\]]+\]/gm);
      if (attrMatches === null || attrMatches === void 0 ? void 0 : attrMatches.length) {
        attrMatches.forEach((attrStr) => {
          var _a4, _b3;
          const attrName = attrStr.split("=")[0].replace(/^\[/, "").replace(/\]$/, "");
          if (!((_a4 = settings.attributes) === null || _a4 === void 0 ? void 0 : _a4.includes(attrName))) {
            (_b3 = settings.attributes) === null || _b3 === void 0 ? void 0 : _b3.push(attrName);
          }
        });
      }
    });
    if ((_c2 = settings.attributes) === null || _c2 === void 0 ? void 0 : _c2.length) {
      observeSettings = Object.assign(Object.assign({}, observeSettings), { attributes: (_d2 = settings.attributes) === null || _d2 === void 0 ? void 0 : _d2.length, attributeFilter: settings.attributes.length ? settings.attributes : null });
    }
    observer.observe(settings.rootNode, observeSettings);
    findAndProcess(settings.rootNode, selector);
    (_e2 = settings.afterFirst) === null || _e2 === void 0 ? void 0 : _e2.call(settings);
  }
  pro.on("cancel", () => {
    canceled = true;
    innerPromises.forEach((promise) => {
      promise.cancel();
    });
    observer === null || observer === void 0 ? void 0 : observer.disconnect();
  });
  return pro;
}
function __querySelectorUp($elm, selector) {
  const originalElm = $elm;
  $elm = $elm.parentNode;
  while ($elm && $elm != originalElm.ownerDocument) {
    if (typeof selector === "function") {
      if (selector($elm))
        return $elm;
    } else if (typeof selector === "string" && __matches($elm, selector)) {
      return $elm;
    }
    $elm = $elm.parentNode;
  }
  return null;
}
function __easeInOutQuad(t) {
  return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
}
let requestAnimationFrame$1;
try {
  requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
} catch (e) {
}
const requestAnimationFrame$2 = requestAnimationFrame$1;
function __scrollTo(target, settings = {}) {
  return new Promise((resolve, reject) => {
    var _a3, _b2, _c2, _d2, _e2, _f2, _g, _h, _j, _k, _l2;
    settings = Object.assign({ $elm: window, duration: 500, easing: __easeInOutQuad, offset: 0, offsetX: void 0, offsetY: void 0, align: "start", justify: "start", onFinish: null }, settings);
    if (settings.$elm === document.body)
      settings.$elm = window;
    if (settings.$elm === document)
      settings.$elm = window;
    const $scrollElm = settings.$elm === window ? document.body : settings.$elm;
    let elmHeight = settings.$elm === window ? window.innerHeight : settings.$elm.offsetHeight;
    let elmWidth = settings.$elm === window ? window.innerWidth : settings.$elm.offsetWidth;
    let elmTop = settings.$elm === window ? 0 : (_a3 = settings.$elm) === null || _a3 === void 0 ? void 0 : _a3.getBoundingClientRect().top;
    let elmLeft = settings.$elm === window ? 0 : (_b2 = settings.$elm) === null || _b2 === void 0 ? void 0 : _b2.getBoundingClientRect().left;
    let maxScrollY = $scrollElm.scrollHeight - elmHeight;
    let maxScrollX = $scrollElm.scrollWidth - elmWidth;
    const currentY = settings.$elm === window ? window.pageYOffset : (_c2 = settings.$elm) === null || _c2 === void 0 ? void 0 : _c2.scrollTop;
    const currentX = settings.$elm === window ? window.pageXOffset : (_d2 = settings.$elm) === null || _d2 === void 0 ? void 0 : _d2.scrollLeft;
    if (settings.$elm !== window) {
      const computedScrollStyles = window.getComputedStyle(settings.$elm);
      maxScrollY += parseInt(computedScrollStyles.paddingTop);
      maxScrollY += parseInt(computedScrollStyles.paddingBottom);
      maxScrollX += parseInt(computedScrollStyles.paddingLeft);
      maxScrollX += parseInt(computedScrollStyles.paddingRight);
    }
    let targetY = currentY, targetX = currentX;
    let targetBounds;
    try {
      targetBounds = target.getBoundingClientRect();
    } catch (e) {
      targetBounds = {
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      };
    }
    const offsetY = (_e2 = settings.offsetY) !== null && _e2 !== void 0 ? _e2 : settings.offset;
    const offsetX = (_f2 = settings.offsetX) !== null && _f2 !== void 0 ? _f2 : settings.offset;
    if (target === "top") {
      targetY = 0;
    } else if (target === "bottom") {
      targetY = (_h = (_g = settings.$elm) === null || _g === void 0 ? void 0 : _g.scrollHeight) !== null && _h !== void 0 ? _h : document.documentElement.scrollHeight;
    }
    if (target === "left") {
      targetX = 0;
    } else if (target === "right") {
      targetY = (_k = (_j = settings.$elm) === null || _j === void 0 ? void 0 : _j.scrollWidth) !== null && _k !== void 0 ? _k : document.documentElement.scrollWidth;
    }
    if (settings.align === "center") {
      targetY += targetBounds.top + targetBounds.height / 2;
      targetY -= elmHeight / 2;
      targetY -= offsetY;
    } else if (settings.align === "end") {
      targetY += targetBounds.bottom;
      targetY -= elmHeight;
      targetY += offsetY;
    } else {
      targetY += targetBounds.top;
      targetY -= offsetY;
    }
    targetY = Math.max(Math.min(maxScrollY, targetY), 0);
    const deltaY = targetY - currentY - elmTop;
    if (settings.justify === "center") {
      targetX += targetBounds.left + targetBounds.width / 2;
      targetX -= elmWidth / 2;
      targetX -= offsetX;
    } else if (settings.justify === "end") {
      targetX += targetBounds.right;
      targetX -= elmWidth;
      targetX += offsetX;
    } else {
      targetX += targetBounds.left;
      targetX -= offsetX;
    }
    targetX = Math.max(Math.min(maxScrollX, targetX), 0);
    const deltaX = targetX - currentX - elmLeft;
    if ((_l2 = settings.$elm) === null || _l2 === void 0 ? void 0 : _l2.getBoundingClientRect) {
      const elmBounds = settings.$elm.getBoundingClientRect();
      targetY -= elmBounds.top;
      targetX -= elmBounds.left;
    }
    const obj2 = {
      targetY,
      targetX,
      deltaY,
      deltaX,
      currentY,
      currentX,
      duration: settings.duration,
      easing: settings.easing,
      $elm: settings.$elm,
      onFinish() {
        settings.onFinish && settings.onFinish();
        resolve();
      },
      startTime: Date.now(),
      step: __scrollTo.step
    };
    requestAnimationFrame$2(obj2.step.bind(obj2));
  });
}
__scrollTo.step = function() {
  const t = Math.min((Date.now() - this.startTime) / this.duration, 1);
  let $scrollElm = this.$elm;
  if (this.$elm === document.body || this.$elm === document) {
    $scrollElm = window;
  }
  const x2 = this.targetX - (1 - this.easing(t)) * this.deltaX;
  const y = this.targetY - (1 - this.easing(t)) * this.deltaY;
  $scrollElm.scrollTo(x2, y);
  if (__isUserScrolling(this.$elm))
    return;
  if (t !== 1) {
    requestAnimationFrame$2(this.step.bind(this));
  } else {
    if (this.onFinish)
      this.onFinish();
  }
};
/*! @license Rematrix v0.7.2

	Copyright 2021 Julian Lloyd.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
*/
function format$1(source2) {
  if (source2 && source2.constructor === Array) {
    var values = source2.filter(function(value) {
      return typeof value === "number";
    }).filter(function(value) {
      return !isNaN(value);
    });
    if (source2.length === 6 && values.length === 6) {
      var matrix = identity();
      matrix[0] = values[0];
      matrix[1] = values[1];
      matrix[4] = values[2];
      matrix[5] = values[3];
      matrix[12] = values[4];
      matrix[13] = values[5];
      return matrix;
    } else if (source2.length === 16 && values.length === 16) {
      return source2;
    }
  }
  throw new TypeError("Expected a `number[]` with length 6 or 16.");
}
function fromString(source2) {
  if (typeof source2 === "string") {
    var match5 = source2.match(/matrix(3d)?\(([^)]+)\)/);
    if (match5) {
      var raw = match5[2].split(",").map(parseFloat);
      return format$1(raw);
    }
    if (source2 === "none" || source2 === "") {
      return identity();
    }
  }
  throw new TypeError("Expected a string containing `matrix()` or `matrix3d()");
}
function identity() {
  var matrix = [];
  for (var i2 = 0; i2 < 16; i2++) {
    i2 % 5 == 0 ? matrix.push(1) : matrix.push(0);
  }
  return matrix;
}
function multiply(matrixA, matrixB) {
  var fma = format$1(matrixA);
  var fmb = format$1(matrixB);
  var product = [];
  for (var i2 = 0; i2 < 4; i2++) {
    var row = [fma[i2], fma[i2 + 4], fma[i2 + 8], fma[i2 + 12]];
    for (var j = 0; j < 4; j++) {
      var k2 = j * 4;
      var col = [fmb[k2], fmb[k2 + 1], fmb[k2 + 2], fmb[k2 + 3]];
      var result2 = row[0] * col[0] + row[1] * col[1] + row[2] * col[2] + row[3] * col[3];
      product[i2 + k2] = result2;
    }
  }
  return product;
}
function rotateX(angle) {
  var theta = Math.PI / 180 * angle;
  var matrix = identity();
  matrix[5] = matrix[10] = Math.cos(theta);
  matrix[6] = matrix[9] = Math.sin(theta);
  matrix[9] *= -1;
  return matrix;
}
function rotateY(angle) {
  var theta = Math.PI / 180 * angle;
  var matrix = identity();
  matrix[0] = matrix[10] = Math.cos(theta);
  matrix[2] = matrix[8] = Math.sin(theta);
  matrix[2] *= -1;
  return matrix;
}
function rotateZ(angle) {
  var theta = Math.PI / 180 * angle;
  var matrix = identity();
  matrix[0] = matrix[5] = Math.cos(theta);
  matrix[1] = matrix[4] = Math.sin(theta);
  matrix[4] *= -1;
  return matrix;
}
function toString$1(source2) {
  return "matrix3d(" + format$1(source2).join(", ") + ")";
}
function translate3d(distanceX, distanceY, distanceZ) {
  var matrix = identity();
  if (distanceX !== void 0 && distanceY !== void 0 && distanceZ !== void 0) {
    matrix[12] = distanceX;
    matrix[13] = distanceY;
    matrix[14] = distanceZ;
  }
  return matrix;
}
function translateX(distance) {
  var matrix = identity();
  matrix[12] = distance;
  return matrix;
}
function translateY(distance) {
  var matrix = identity();
  matrix[13] = distance;
  return matrix;
}
class SSugarElement {
  constructor($elm) {
    this.$elm = $elm;
  }
  get matrix() {
    var _a3;
    return (_a3 = this._tmpMatrix) !== null && _a3 !== void 0 ? _a3 : fromString(this.matrixStr);
  }
  get matrixStr() {
    return window.getComputedStyle(this.$elm).transform;
  }
  simulateTransform(transform) {
    var _a3, _b2, _c2, _d2, _e2, _f2;
    const translateMatrix = translate3d((_a3 = transform.translateX) !== null && _a3 !== void 0 ? _a3 : 0, (_b2 = transform.translateY) !== null && _b2 !== void 0 ? _b2 : 0, (_c2 = transform.translateZ) !== null && _c2 !== void 0 ? _c2 : 0), rotateXMatrix = rotateX((_d2 = transform.rotateX) !== null && _d2 !== void 0 ? _d2 : 0), rotateYMatrix = rotateY((_e2 = transform.rotateY) !== null && _e2 !== void 0 ? _e2 : 0), rotateZMatrix = rotateZ((_f2 = transform.rotateZ) !== null && _f2 !== void 0 ? _f2 : 0);
    let newMatrix = this.matrix;
    newMatrix = [newMatrix, translateMatrix, rotateXMatrix, rotateYMatrix, rotateZMatrix].reduce(multiply);
    const newTranslates = this.getTranslates(newMatrix), newRotates = this.getRotates(newMatrix);
    return {
      translateX: newTranslates.x,
      translateY: newTranslates.y,
      translateZ: newTranslates.z,
      rotateX: newRotates.x,
      rotateY: newRotates.y,
      rotateZ: newRotates.z,
      matrix: toString$1(newMatrix)
    };
  }
  applyMatrix(...matrix) {
    var _a3;
    let newMatrix = (_a3 = this._tmpMatrix) !== null && _a3 !== void 0 ? _a3 : this.matrix;
    matrix.forEach((m2) => {
      newMatrix = multiply(newMatrix, m2);
    });
    this._tmpMatrix = newMatrix;
    setTimeout(() => {
      this.$elm.style.transform = toString$1(newMatrix);
      this._tmpMatrix = null;
    });
    return this;
  }
  overrideMatrix(matrix) {
    this._tmpMatrix = matrix;
    setTimeout(() => {
      this.$elm.style.transform = toString$1(matrix);
      this._tmpMatrix = null;
    });
    return this;
  }
  getTranslates(fromMatrix = this.matrix) {
    return {
      x: isNaN(fromMatrix[12]) ? 0 : fromMatrix[12],
      y: isNaN(fromMatrix[13]) ? 0 : fromMatrix[13],
      z: isNaN(fromMatrix[14]) ? 0 : fromMatrix[14]
    };
  }
  getRotates(fromMatrix = this.matrix) {
    const matrix = fromMatrix.toString();
    var values = matrix.split(","), pi = Math.PI, sinB = parseFloat(values[8]), b2 = Math.round(Math.asin(sinB) * 180 / pi), cosB = Math.cos(b2 * pi / 180), matrixVal10 = parseFloat(values[9]), a3 = Math.round(Math.asin(-matrixVal10 / cosB) * 180 / pi), matrixVal1 = parseFloat(values[0]), c = Math.round(Math.acos(matrixVal1 / cosB) * 180 / pi);
    return {
      x: a3,
      y: b2,
      z: c
    };
  }
  setTranslate(x2, y, z) {
    const newMatrix = this.matrix;
    if (x2 !== void 0)
      newMatrix[12] = x2;
    if (y !== void 0)
      newMatrix[13] = y;
    if (z !== void 0)
      newMatrix[14] = z;
    return this.overrideMatrix(newMatrix);
  }
  translate(x2, y, z) {
    const translateMatrix = translate3d(x2 !== null && x2 !== void 0 ? x2 : 0, y !== null && y !== void 0 ? y : 0, z !== null && z !== void 0 ? z : 0);
    return this.applyMatrix(translateMatrix);
  }
  rotate(x2, y, z) {
    const rotateXMatrix = rotateX(x2 !== null && x2 !== void 0 ? x2 : 0), rotateYMatrix = rotateY(y !== null && y !== void 0 ? y : 0), rotateZMatrix = rotateZ(z !== null && z !== void 0 ? z : 0);
    return this.applyMatrix(rotateXMatrix, rotateYMatrix, rotateZMatrix);
  }
  setRotate(x2, y, z) {
    const rotateMatrix = [rotateX(x2 !== null && x2 !== void 0 ? x2 : 0), rotateX(y !== null && y !== void 0 ? y : 0), rotateX(z !== null && z !== void 0 ? z : 0)].reduce(multiply);
    const newMatrix = this.matrix;
    if (x2 !== void 0) {
      newMatrix[5] = rotateMatrix[5];
      newMatrix[6] = rotateMatrix[6];
      newMatrix[9] = rotateMatrix[9];
    }
    if (y !== void 0) {
      newMatrix[0] = rotateMatrix[0];
      newMatrix[2] = rotateMatrix[2];
    }
    if (z !== void 0) {
      newMatrix[0] = rotateMatrix[0];
      newMatrix[1] = rotateMatrix[1];
      newMatrix[4] = rotateMatrix[4];
    }
    return this.overrideMatrix(newMatrix);
  }
}
function __easeOutQuad(t) {
  return t * (2 - t);
}
function __easeInOutQuart(t) {
  return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
}
function __easeInterval(duration, cb, settings = {}) {
  let cleared = false, animationFrame;
  const pro = new SPromise(({ resolve, reject, emit, on: on2 }) => {
    settings = Object.assign({ interval: 1e3 / 25, easing: __easeInOutQuart, from: 0, to: 100, onEnd: void 0 }, settings);
    const startTime = Date.now();
    on2("cancel", () => {
      cleared = true;
      cancelAnimationFrame(animationFrame);
    });
    function animate() {
      var _a3;
      if (cleared)
        return;
      const percent = 100 / duration * (Date.now() - startTime);
      const easedPercent = settings.easing(percent / 100) * 100;
      cb(easedPercent);
      if (percent < 100) {
        if (cleared)
          return;
        animationFrame = requestAnimationFrame(animate);
      } else {
        (_a3 = settings.onEnd) === null || _a3 === void 0 ? void 0 : _a3.call(settings);
        resolve(easedPercent);
      }
    }
    animate();
  });
  return pro;
}
function __compressVarName(name2) {
  return name2;
}
function __getStyleProperty(elm, property) {
  setTimeout(() => {
    elm._sComputedStyle = null;
  });
  const computed = elm._sComputedStyle || window.getComputedStyle(elm);
  elm._sComputedStyle = computed;
  const prefixes = ["", "webkit-", "moz-", "ms-", "o-", "khtml-"];
  for (let i2 = 0; i2 < prefixes.length; i2++) {
    const prefix = prefixes[i2];
    const value = computed[__camelize(`${prefix}${property}`)];
    if (value && value.trim() !== "")
      return autoCast(value);
  }
  return null;
}
function __preventViewportMovement($elm) {
  function cb(e) {
    e.preventDefault();
  }
  function cancel() {
    $elm.removeEventListener("touchstart", cb);
    $elm.removeEventListener("touchmove", cb);
    $elm.removeEventListener("touchend", cb);
    $elm.removeEventListener("touchcancel", cb);
  }
  $elm.addEventListener("touchstart", cb, {
    passive: true
  });
  $elm.addEventListener("touchmove", cb, {
    passive: true
  });
  $elm.addEventListener("touchend", cb, {
    passive: true
  });
  $elm.addEventListener("touchcancel", cb, {
    passive: true
  });
  return cancel;
}
function __clearTransmations($elm = document.body, settings) {
  const cls = `s-clear-transmations-${__uniqid()}`;
  $elm.classList.add(cls);
  const $tag = document.createElement("style");
  $tag.type = "text/css";
  $tag.innerHTML = `
        .${cls},
        .${cls}:before,
        .${cls}:after,
        .${cls} *,
        .${cls} *:before,
        .${cls} *:after {
            animation: none !important;
            transition: none !important;
        }
    `;
  document.head.appendChild($tag);
  function reset() {
    $elm.classList.remove(cls);
    $tag.remove();
  }
  if (settings === null || settings === void 0 ? void 0 : settings.timeout) {
    setTimeout(() => {
      reset();
    }, settings.timeout);
  }
  return reset;
}
function __traverseUp($elm, callback) {
  const originalElm = $elm;
  $elm = $elm.parentNode;
  while ($elm && $elm != originalElm.ownerDocument) {
    if (callback($elm)) {
      return $elm;
    }
    $elm = $elm.parentNode;
  }
  return null;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "x" : "y";
}
function getLengthFromAxis(axis) {
  return axis === "y" ? "height" : "width";
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  const commonAlign = reference[length] / 2 - floating[length] / 2;
  const side = getSide(placement);
  const isVertical = mainAxis === "x";
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config2;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  {
    if (platform2 == null) {
      console.error(["Floating UI: `platform` property was not passed to config. If you", "want to use Floating UI on the web, install @floating-ui/dom", "instead of the /core package. Otherwise, you can create your own", "`platform`: https://floating-ui.com/docs/platform"].join(" "));
    }
    if (middleware.filter((_ref) => {
      let {
        name: name2
      } = _ref;
      return name2 === "autoPlacement" || name2 === "flip";
    }).length > 1) {
      throw new Error(["Floating UI: duplicate `flip` and/or `autoPlacement`", "middleware detected. This will lead to an infinite loop. Ensure only", "one of either has been passed to the `middleware` array."].join(" "));
    }
  }
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0; i2 < middleware.length; i2++) {
    const {
      name: name2,
      fn: fn2
    } = middleware[i2];
    const {
      x: nextX,
      y: nextY,
      data: data2,
      reset
    } = await fn2({
      x: x2,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name2]: {
        ...middlewareData[name2],
        ...data2
      }
    };
    {
      if (resetCount > 50) {
        console.warn(["Floating UI: The middleware lifecycle appears to be running in an", "infinite loop. This is usually caused by a `reset` continually", "being returned without a break condition."].join(" "));
      }
    }
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
      continue;
    }
  }
  return {
    x: x2,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getSideObjectFromPadding(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
async function detectOverflow(middlewareArguments, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = middlewareArguments;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = options;
  const paddingObject = getSideObjectFromPadding(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: elementContext === "floating" ? {
      ...rects.floating,
      x: x2,
      y
    } : rects.reference,
    offsetParent: await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating)),
    strategy
  }) : rects[elementContext]);
  return {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
}
const min$2 = Math.min;
const max$3 = Math.max;
function within(min$12, value, max$12) {
  return max$3(min$12, min$2(value, max$12));
}
const arrow = (options) => ({
  name: "arrow",
  options,
  async fn(middlewareArguments) {
    const {
      element,
      padding = 0
    } = options != null ? options : {};
    const {
      x: x2,
      y,
      placement,
      rects,
      platform: platform2
    } = middlewareArguments;
    if (element == null) {
      {
        console.warn("Floating UI: No `element` was passed to the `arrow` middleware.");
      }
      return {};
    }
    const paddingObject = getSideObjectFromPadding(padding);
    const coords = {
      x: x2,
      y
    };
    const axis = getMainAxisFromPlacement(placement);
    const alignment = getAlignment(placement);
    const length = getLengthFromAxis(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const minProp = axis === "y" ? "top" : "left";
    const maxProp = axis === "y" ? "bottom" : "right";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    if (clientSize === 0) {
      clientSize = rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const min2 = paddingObject[minProp];
    const max2 = clientSize - arrowDimensions[length] - paddingObject[maxProp];
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = within(min2, center, max2);
    const alignmentPadding = alignment === "start" ? paddingObject[minProp] : paddingObject[maxProp];
    const shouldAddOffset = alignmentPadding > 0 && center !== offset2 && rects.reference[length] <= rects.floating[length];
    const alignmentOffset = shouldAddOffset ? center < min2 ? min2 - center : max2 - center : 0;
    return {
      [axis]: coords[axis] - alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2
      }
    };
  }
});
const hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (matched) => hash$1[matched]);
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement(mainAlignmentSide)
  };
}
const hash = {
  start: "end",
  end: "start"
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (matched) => hash[matched]);
}
const sides = ["top", "right", "bottom", "left"];
const allPlacements = /* @__PURE__ */ sides.reduce((acc, side) => acc.concat(side, side + "-start", side + "-end"), []);
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getSide(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter((placement) => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
const autoPlacement = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "autoPlacement",
    options,
    async fn(middlewareArguments) {
      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _placementsSortedByLe;
      const {
        x: x2,
        y,
        rects,
        middlewareData,
        placement,
        platform: platform2,
        elements
      } = middlewareArguments;
      const {
        alignment = null,
        allowedPlacements = allPlacements,
        autoAlignment = true,
        ...detectOverflowOptions
      } = options;
      const placements = getPlacementList(alignment, autoAlignment, allowedPlacements);
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const currentIndex = (_middlewareData$autoP = (_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.index) != null ? _middlewareData$autoP : 0;
      const currentPlacement = placements[currentIndex];
      if (currentPlacement == null) {
        return {};
      }
      const {
        main: main2,
        cross
      } = getAlignmentSides(currentPlacement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
      if (placement !== currentPlacement) {
        return {
          x: x2,
          y,
          reset: {
            placement: placements[0]
          }
        };
      }
      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main2], overflow[cross]];
      const allOverflows = [...(_middlewareData$autoP3 = (_middlewareData$autoP4 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP4.overflows) != null ? _middlewareData$autoP3 : [], {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements[currentIndex + 1];
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a3, b2) => a3.overflows[0] - b2.overflows[0]);
      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find((_ref) => {
        let {
          overflows
        } = _ref;
        return overflows.every((overflow2) => overflow2 <= 0);
      })) == null ? void 0 : _placementsSortedByLe.placement;
      const resetPlacement = placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement;
      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
const flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(middlewareArguments) {
      var _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = middlewareArguments;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        flipAlignment = true,
        ...detectOverflowOptions
      } = options;
      const side = getSide(placement);
      const isBasePlacement = side === initialPlacement;
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const {
          main: main2,
          cross
        } = getAlignmentSides(placement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
        overflows.push(overflow[main2], overflow[cross]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip$, _middlewareData$flip2;
        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = "bottom";
        switch (fallbackStrategy) {
          case "bestFit": {
            var _overflowsData$map$so;
            const placement2 = (_overflowsData$map$so = overflowsData.map((d4) => [d4, d4.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a3, b2) => a3[1] - b2[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;
            if (placement2) {
              resetPlacement = placement2;
            }
            break;
          }
          case "initialPlacement":
            resetPlacement = initialPlacement;
            break;
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(middlewareArguments, value) {
  const {
    placement,
    platform: platform2,
    elements
  } = middlewareArguments;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getMainAxisFromPlacement(placement) === "x";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = typeof value === "function" ? value(middlewareArguments) : value;
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset = function(value) {
  if (value === void 0) {
    value = 0;
  }
  return {
    name: "offset",
    options: value,
    async fn(middlewareArguments) {
      const {
        x: x2,
        y
      } = middlewareArguments;
      const diffCoords = await convertValueToCoords(middlewareArguments, value);
      return {
        x: x2 + diffCoords.x,
        y: y + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
function getCrossAxis(axis) {
  return axis === "x" ? "y" : "x";
}
const shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(middlewareArguments) {
      const {
        x: x2,
        y,
        placement
      } = middlewareArguments;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y2
            } = _ref;
            return {
              x: x3,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = options;
      const coords = {
        x: x2,
        y
      };
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement(getSide(placement));
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = within(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = within(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...middlewareArguments,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y
        }
      };
    }
  };
};
const inline = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "inline",
    options,
    async fn(middlewareArguments) {
      var _await$platform$getCl;
      const {
        placement,
        elements,
        rects,
        platform: platform2,
        strategy
      } = middlewareArguments;
      const {
        padding = 2,
        x: x2,
        y
      } = options;
      const fallback = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
        rect: rects.reference,
        offsetParent: await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating)),
        strategy
      }) : rects.reference);
      const clientRects = (_await$platform$getCl = await (platform2.getClientRects == null ? void 0 : platform2.getClientRects(elements.reference))) != null ? _await$platform$getCl : [];
      const paddingObject = getSideObjectFromPadding(padding);
      function getBoundingClientRect2() {
        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x2 != null && y != null) {
          var _clientRects$find;
          return (_clientRects$find = clientRects.find((rect) => x2 > rect.left - paddingObject.left && x2 < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom)) != null ? _clientRects$find : fallback;
        }
        if (clientRects.length >= 2) {
          if (getMainAxisFromPlacement(placement) === "x") {
            const firstRect = clientRects[0];
            const lastRect = clientRects[clientRects.length - 1];
            const isTop = getSide(placement) === "top";
            const top2 = firstRect.top;
            const bottom2 = lastRect.bottom;
            const left2 = isTop ? firstRect.left : lastRect.left;
            const right2 = isTop ? firstRect.right : lastRect.right;
            const width2 = right2 - left2;
            const height2 = bottom2 - top2;
            return {
              top: top2,
              bottom: bottom2,
              left: left2,
              right: right2,
              width: width2,
              height: height2,
              x: left2,
              y: top2
            };
          }
          const isLeftSide = getSide(placement) === "left";
          const maxRight = max$3(...clientRects.map((rect) => rect.right));
          const minLeft = min$2(...clientRects.map((rect) => rect.left));
          const measureRects = clientRects.filter((rect) => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
          const top = measureRects[0].top;
          const bottom = measureRects[measureRects.length - 1].bottom;
          const left = minLeft;
          const right = maxRight;
          const width = right - left;
          const height = bottom - top;
          return {
            top,
            bottom,
            left,
            right,
            width,
            height,
            x: left,
            y: top
          };
        }
        return fallback;
      }
      const resetRects = await platform2.getElementRects({
        reference: {
          getBoundingClientRect: getBoundingClientRect2
        },
        floating: elements.floating,
        strategy
      });
      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
        return {
          reset: {
            rects: resetRects
          }
        };
      }
      return {};
    }
  };
};
function isWindow(value) {
  return value && value.document && value.location && value.alert && value.setInterval;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (!isWindow(node)) {
    const ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeName(node) {
  return isWindow(node) ? "" : node ? (node.nodeName || "").toLowerCase() : "";
}
function getUAString() {
  const uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands) {
    return uaData.brands.map((item) => item.brand + "/" + item.version).join(" ");
  }
  return navigator.userAgent;
}
function isHTMLElement(value) {
  return value instanceof getWindow(value).HTMLElement;
}
function isElement(value) {
  return value instanceof getWindow(value).Element;
}
function isNode(value) {
  return value instanceof getWindow(value).Node;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  const OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const isFirefox = /firefox/i.test(getUAString());
  const css2 = getComputedStyle$1(element);
  return css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].includes(css2.willChange) || isFirefox && css2.willChange === "filter" || isFirefox && (css2.filter ? css2.filter !== "none" : false);
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
const min$1 = Math.min;
const max$2 = Math.max;
const round = Math.round;
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  let scaleX = 1;
  let scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  const win = isElement(element) ? getWindow(element) : window;
  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  const x2 = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;
  const y = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;
  const width = clientRect.width / scaleX;
  const height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x2 + width,
    bottom: y + height,
    left: x2,
    x: x2,
    y
  };
}
function getDocumentElement(node) {
  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function isScaled(element) {
  const rect = getBoundingClientRect(element);
  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const rect = getBoundingClientRect(
    element,
    isOffsetParentAnElement && isScaled(offsetParent),
    strategy === "fixed"
  );
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  return node.assignedSlot || node.parentNode || (isShadowRoot(node) ? node.host : null) || getDocumentElement(node);
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && !["html", "body"].includes(getNodeName(currentNode))) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  const window2 = getWindow(element);
  let offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getDimensions(element) {
  if (isHTMLElement(element)) {
    return {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
  }
  const rect = getBoundingClientRect(element);
  return {
    width: rect.width,
    height: rect.height
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    ...rect,
    x: rect.x - scroll.scrollLeft + offsets.x,
    y: rect.y - scroll.scrollTop + offsets.y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html2 = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html2.clientWidth;
  let height = html2.clientHeight;
  let x2 = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  const html2 = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  const width = max$2(html2.scrollWidth, html2.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  const height = max$2(html2.scrollHeight, html2.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body || html2).direction === "rtl") {
    x2 += max$2(html2.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y
  };
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (["html", "body", "#document"].includes(getNodeName(parentNode))) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list) {
  var _node$ownerDocument;
  if (list === void 0) {
    list = [];
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow(scrollableAncestor);
  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;
  const updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(getOverflowAncestors(target));
}
function contains$2(parent, child) {
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    do {
      if (next && parent === next) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, false, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  return {
    top,
    left,
    x: left,
    y: top,
    right: left + element.clientWidth,
    bottom: top + element.clientHeight,
    width: element.clientWidth,
    height: element.clientHeight
  };
}
function getClientRectFromClippingAncestor(element, clippingParent, strategy) {
  if (clippingParent === "viewport") {
    return rectToClientRect(getViewportRect(element, strategy));
  }
  if (isElement(clippingParent)) {
    return getInnerBoundingClientRect(clippingParent, strategy);
  }
  return rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingAncestors(element) {
  const clippingAncestors = getOverflowAncestors(element);
  const canEscapeClipping = ["absolute", "fixed"].includes(getComputedStyle$1(element).position);
  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingAncestors.filter((clippingAncestors2) => isElement(clippingAncestors2) && contains$2(clippingAncestors2, clipperElement) && getNodeName(clippingAncestors2) !== "body");
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const mainClippingAncestors = boundary === "clippingAncestors" ? getClippingAncestors(element) : [].concat(boundary);
  const clippingAncestors = [...mainClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max$2(rect.top, accRect.top);
    accRect.right = min$1(rect.right, accRect.right);
    accRect.bottom = min$1(rect.bottom, accRect.bottom);
    accRect.left = max$2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
const platform = {
  getClippingRect,
  convertOffsetParentRelativeRectToViewportRelativeRect,
  isElement,
  getDimensions,
  getOffsetParent,
  getDocumentElement,
  getElementRects: (_ref) => {
    let {
      reference,
      floating,
      strategy
    } = _ref;
    return {
      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),
      floating: {
        ...getDimensions(floating),
        x: 0,
        y: 0
      }
    };
  },
  getClientRects: (element) => Array.from(element.getClientRects()),
  isRTL: (element) => getComputedStyle$1(element).direction === "rtl"
};
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll: _ancestorScroll = true,
    ancestorResize: _ancestorResize = true,
    elementResize = true,
    animationFrame = false
  } = options;
  const ancestorScroll = _ancestorScroll && !animationFrame;
  const ancestorResize = _ancestorResize && !animationFrame;
  const ancestors = ancestorScroll || ancestorResize ? [...isElement(reference) ? getOverflowAncestors(reference) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  let observer = null;
  if (elementResize) {
    let initialUpdate = true;
    observer = new ResizeObserver(() => {
      if (!initialUpdate) {
        update();
      }
      initialUpdate = false;
    });
    isElement(reference) && !animationFrame && observer.observe(reference);
    observer.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _observer;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    (_observer = observer) == null ? void 0 : _observer.disconnect();
    observer = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const computePosition = (reference, floating, options) => computePosition$1(reference, floating, {
  platform,
  ...options
});
var __awaiter$m = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function __makeFloat($elm, $depending, settings) {
  const finalSettings = Object.assign({ position: "auto", shift: 10, offset: 0, arrow: false, arrowSize: 15, arrowPadding: 10 }, settings !== null && settings !== void 0 ? settings : {});
  $depending.classList.add("s-floating");
  const middlewares = [
    offset(finalSettings.offset),
    shift({
      padding: finalSettings.shift
    }),
    inline()
  ];
  if (finalSettings.position !== "auto") {
    middlewares.push(flip());
  } else {
    middlewares.push(autoPlacement());
  }
  let $arrow;
  if (finalSettings.arrow) {
    $arrow = document.createElement("div");
    $arrow.classList.add("s-floating__arrow");
    $elm.append($arrow);
    middlewares.push(arrow({
      element: $arrow,
      padding: finalSettings.arrowPadding
    }));
  }
  if (finalSettings.arrowSize) {
    $elm.style.setProperty(`--arrow-size`, `${finalSettings.arrowSize}px`);
  }
  const update = () => __awaiter$m(this, void 0, void 0, function* () {
    yield computePosition($depending, $elm, {
      placement: finalSettings.position,
      middleware: middlewares
    });
    computePosition($depending, $elm, {
      placement: finalSettings.position,
      middleware: middlewares
    }).then(({ x: x2, y, placement, middlewareData }) => {
      Object.assign($elm.style, {
        position: "absolute",
        top: `${y}px`,
        left: `${x2}px`
      });
      if (middlewareData.arrow) {
        const staticSide = {
          top: "bottom",
          right: "left",
          bottom: "top",
          left: "right"
        }[placement.split("-")[0]];
        Object.assign($arrow.style, {
          position: "absolute",
          left: middlewareData.arrow.x != null ? `${middlewareData.arrow.x}px` : "",
          top: middlewareData.arrow.y != null ? `${middlewareData.arrow.y}px` : "",
          right: "",
          bottom: "",
          [staticSide]: "-4px"
        });
      }
    });
  });
  update();
  const cleanup = autoUpdate($depending, $elm, () => {
    update();
  });
  __whenRemoved($elm).then(() => {
    cleanup();
  });
  __whenRemoved($depending).then(() => {
    cleanup();
  });
  $depending.addEventListener("pointerover", () => {
    update();
  });
  return {
    update,
    cleanup
  };
}
let map$1 = {};
try {
  map$1 = {
    a: window.HTMLAnchorElement,
    audio: window.HTMLAudioElement,
    body: window.HTMLBodyElement,
    button: window.HTMLButtonElement,
    canvas: window.HTMLCanvasElement,
    dl: window.HTMLDListElement,
    data: window.HTMLDataElement,
    datalist: window.HTMLDataListElement,
    details: window.HTMLDetailsElement,
    dir: window.HTMLDirectoryElement,
    div: window.HTMLDivElement,
    html: window.HTMLDocument,
    embed: window.HTMLEmbedElement,
    fieldset: window.HTMLFieldSetElement,
    font: window.HTMLFontElement,
    form: window.HTMLFormElement,
    frame: window.HTMLFrameElement,
    head: window.HTMLHeadElement,
    html: window.HTMLHtmlElement,
    iframe: window.HTMLIFrameElement,
    img: window.HTMLImageElement,
    input: window.HTMLInputElement,
    label: window.HTMLLabelElement,
    legend: window.HTMLLegendElement,
    link: window.HTMLLinkElement,
    map: window.HTMLMapElement,
    marquee: window.HTMLMarqueeElement,
    media: window.HTMLMediaElement,
    menu: window.HTMLMenuElement,
    meta: window.HTMLMetaElement,
    meter: window.HTMLMeterElement,
    del: window.HTMLModElement,
    ins: window.HTMLModElement,
    dol: window.HTMLOListElement,
    object: window.HTMLObjectElement,
    optgroup: window.HTMLOptGroupElement,
    option: window.HTMLOptionElement,
    output: window.HTMLOutputElement,
    p: window.HTMLParagraphElement,
    param: window.HTMLParamElement,
    picture: window.HTMLPictureElement,
    pre: window.HTMLPreElement,
    progress: window.HTMLProgressElement,
    quote: window.HTMLQuoteElement,
    script: window.HTMLScriptElement,
    select: window.HTMLSelectElement,
    slot: window.HTMLSlotElement,
    source: window.HTMLSourceElement,
    span: window.HTMLSpanElement,
    style: window.HTMLStyleElement,
    td: window.HTMLTableCellElement,
    th: window.HTMLTableCellElement,
    col: window.HTMLTableColElement,
    colgroup: window.HTMLTableColElement,
    table: window.HTMLTableElement,
    tr: window.HTMLTableRowElement,
    tfoot: window.HTMLTableSectionElement,
    thead: window.HTMLTableSectionElement,
    tbody: window.HTMLTableSectionElement,
    template: window.HTMLTemplateElement,
    textarea: window.HTMLTextAreaElement,
    time: window.HTMLTimeElement,
    title: window.HTMLTitleElement,
    track: window.HTMLTrackElement,
    ul: window.HTMLUListElement,
    video: window.HTMLVideoElement,
    area: window.HTMLAreaElement
  };
} catch (e) {
}
var knownCssProperties = {};
const properties = [
  "-epub-caption-side",
  "-epub-hyphens",
  "-epub-text-combine",
  "-epub-text-emphasis",
  "-epub-text-emphasis-color",
  "-epub-text-emphasis-style",
  "-epub-text-orientation",
  "-epub-text-transform",
  "-epub-word-break",
  "-epub-writing-mode",
  "-internal-text-autosizing-status",
  "accelerator",
  "accent-color",
  "-wap-accesskey",
  "additive-symbols",
  "align-content",
  "-webkit-align-content",
  "align-items",
  "-webkit-align-items",
  "align-self",
  "-webkit-align-self",
  "alignment-baseline",
  "all",
  "alt",
  "-webkit-alt",
  "animation",
  "animation-delay",
  "-moz-animation-delay",
  "-ms-animation-delay",
  "-webkit-animation-delay",
  "animation-direction",
  "-moz-animation-direction",
  "-ms-animation-direction",
  "-webkit-animation-direction",
  "animation-duration",
  "-moz-animation-duration",
  "-ms-animation-duration",
  "-webkit-animation-duration",
  "animation-fill-mode",
  "-moz-animation-fill-mode",
  "-ms-animation-fill-mode",
  "-webkit-animation-fill-mode",
  "animation-iteration-count",
  "-moz-animation-iteration-count",
  "-ms-animation-iteration-count",
  "-webkit-animation-iteration-count",
  "-moz-animation",
  "-ms-animation",
  "animation-name",
  "-moz-animation-name",
  "-ms-animation-name",
  "-webkit-animation-name",
  "animation-play-state",
  "-moz-animation-play-state",
  "-ms-animation-play-state",
  "-webkit-animation-play-state",
  "animation-timing-function",
  "-moz-animation-timing-function",
  "-ms-animation-timing-function",
  "-webkit-animation-timing-function",
  "-webkit-animation-trigger",
  "-webkit-animation",
  "app-region",
  "-webkit-app-region",
  "appearance",
  "-moz-appearance",
  "-webkit-appearance",
  "ascent-override",
  "aspect-ratio",
  "-webkit-aspect-ratio",
  "audio-level",
  "azimuth",
  "backdrop-filter",
  "-webkit-backdrop-filter",
  "backface-visibility",
  "-moz-backface-visibility",
  "-ms-backface-visibility",
  "-webkit-backface-visibility",
  "background",
  "background-attachment",
  "-webkit-background-attachment",
  "background-blend-mode",
  "background-clip",
  "-moz-background-clip",
  "-webkit-background-clip",
  "background-color",
  "-webkit-background-color",
  "-webkit-background-composite",
  "background-image",
  "-webkit-background-image",
  "-moz-background-inline-policy",
  "background-origin",
  "-moz-background-origin",
  "-webkit-background-origin",
  "background-position",
  "-webkit-background-position",
  "background-position-x",
  "-webkit-background-position-x",
  "background-position-y",
  "-webkit-background-position-y",
  "background-repeat",
  "-webkit-background-repeat",
  "background-repeat-x",
  "background-repeat-y",
  "background-size",
  "-moz-background-size",
  "-webkit-background-size",
  "-webkit-background",
  "base-palette",
  "baseline-shift",
  "baseline-source",
  "behavior",
  "-moz-binding",
  "block-ellipsis",
  "-ms-block-progression",
  "block-size",
  "block-step",
  "block-step-align",
  "block-step-insert",
  "block-step-round",
  "block-step-size",
  "bookmark-label",
  "bookmark-level",
  "bookmark-state",
  "border",
  "-webkit-border-after-color",
  "-webkit-border-after-style",
  "-webkit-border-after",
  "-webkit-border-after-width",
  "-webkit-border-before-color",
  "-webkit-border-before-style",
  "-webkit-border-before",
  "-webkit-border-before-width",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "-moz-border-bottom-colors",
  "border-bottom-left-radius",
  "-webkit-border-bottom-left-radius",
  "border-bottom-right-radius",
  "-webkit-border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-boundary",
  "border-collapse",
  "border-color",
  "-moz-border-end-color",
  "-webkit-border-end-color",
  "border-end-end-radius",
  "-moz-border-end",
  "border-end-start-radius",
  "-moz-border-end-style",
  "-webkit-border-end-style",
  "-webkit-border-end",
  "-moz-border-end-width",
  "-webkit-border-end-width",
  "-webkit-border-fit",
  "-webkit-border-horizontal-spacing",
  "border-image",
  "-moz-border-image",
  "-o-border-image",
  "border-image-outset",
  "-webkit-border-image-outset",
  "border-image-repeat",
  "-webkit-border-image-repeat",
  "border-image-slice",
  "-webkit-border-image-slice",
  "border-image-source",
  "-webkit-border-image-source",
  "-webkit-border-image",
  "border-image-width",
  "-webkit-border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "-moz-border-left-colors",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "-moz-border-radius-bottomleft",
  "-moz-border-radius-bottomright",
  "-moz-border-radius",
  "-moz-border-radius-topleft",
  "-moz-border-radius-topright",
  "-webkit-border-radius",
  "border-right",
  "border-right-color",
  "-moz-border-right-colors",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "-moz-border-start-color",
  "-webkit-border-start-color",
  "border-start-end-radius",
  "-moz-border-start",
  "border-start-start-radius",
  "-moz-border-start-style",
  "-webkit-border-start-style",
  "-webkit-border-start",
  "-moz-border-start-width",
  "-webkit-border-start-width",
  "border-style",
  "border-top",
  "border-top-color",
  "-moz-border-top-colors",
  "border-top-left-radius",
  "-webkit-border-top-left-radius",
  "border-top-right-radius",
  "-webkit-border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "-webkit-border-vertical-spacing",
  "border-width",
  "bottom",
  "-moz-box-align",
  "-webkit-box-align",
  "box-decoration-break",
  "-webkit-box-decoration-break",
  "-moz-box-direction",
  "-webkit-box-direction",
  "-webkit-box-flex-group",
  "-moz-box-flex",
  "-webkit-box-flex",
  "-webkit-box-lines",
  "-moz-box-ordinal-group",
  "-webkit-box-ordinal-group",
  "-moz-box-orient",
  "-webkit-box-orient",
  "-moz-box-pack",
  "-webkit-box-pack",
  "-webkit-box-reflect",
  "box-shadow",
  "-moz-box-shadow",
  "-webkit-box-shadow",
  "box-sizing",
  "-moz-box-sizing",
  "-webkit-box-sizing",
  "box-snap",
  "break-after",
  "break-before",
  "break-inside",
  "buffered-rendering",
  "caption-side",
  "caret",
  "caret-color",
  "caret-shape",
  "chains",
  "clear",
  "clip",
  "clip-path",
  "-webkit-clip-path",
  "clip-rule",
  "color",
  "color-adjust",
  "-webkit-color-correction",
  "-apple-color-filter",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "color-scheme",
  "-webkit-column-axis",
  "-webkit-column-break-after",
  "-webkit-column-break-before",
  "-webkit-column-break-inside",
  "column-count",
  "-moz-column-count",
  "-webkit-column-count",
  "column-fill",
  "-moz-column-fill",
  "-webkit-column-fill",
  "column-gap",
  "-moz-column-gap",
  "-webkit-column-gap",
  "column-progression",
  "-webkit-column-progression",
  "column-rule",
  "column-rule-color",
  "-moz-column-rule-color",
  "-webkit-column-rule-color",
  "-moz-column-rule",
  "column-rule-style",
  "-moz-column-rule-style",
  "-webkit-column-rule-style",
  "-webkit-column-rule",
  "column-rule-width",
  "-moz-column-rule-width",
  "-webkit-column-rule-width",
  "column-span",
  "-moz-column-span",
  "-webkit-column-span",
  "column-width",
  "-moz-column-width",
  "-webkit-column-width",
  "columns",
  "-moz-columns",
  "-webkit-columns",
  "-webkit-composition-fill-color",
  "-webkit-composition-frame-color",
  "contain",
  "contain-intrinsic-block-size",
  "contain-intrinsic-height",
  "contain-intrinsic-inline-size",
  "contain-intrinsic-size",
  "contain-intrinsic-width",
  "container",
  "container-name",
  "container-type",
  "content",
  "content-visibility",
  "-ms-content-zoom-chaining",
  "-ms-content-zoom-limit-max",
  "-ms-content-zoom-limit-min",
  "-ms-content-zoom-limit",
  "-ms-content-zoom-snap",
  "-ms-content-zoom-snap-points",
  "-ms-content-zoom-snap-type",
  "-ms-content-zooming",
  "continue",
  "counter-increment",
  "counter-reset",
  "counter-set",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "-webkit-cursor-visibility",
  "cx",
  "cy",
  "d",
  "-apple-dashboard-region",
  "-webkit-dashboard-region",
  "descent-override",
  "direction",
  "display",
  "display-align",
  "dominant-baseline",
  "elevation",
  "empty-cells",
  "enable-background",
  "epub-caption-side",
  "epub-hyphens",
  "epub-text-combine",
  "epub-text-emphasis",
  "epub-text-emphasis-color",
  "epub-text-emphasis-style",
  "epub-text-orientation",
  "epub-text-transform",
  "epub-word-break",
  "epub-writing-mode",
  "fallback",
  "fill",
  "fill-break",
  "fill-color",
  "fill-image",
  "fill-opacity",
  "fill-origin",
  "fill-position",
  "fill-repeat",
  "fill-rule",
  "fill-size",
  "filter",
  "-ms-filter",
  "-webkit-filter",
  "flex",
  "-ms-flex-align",
  "-webkit-flex-align",
  "flex-basis",
  "-webkit-flex-basis",
  "flex-direction",
  "-ms-flex-direction",
  "-webkit-flex-direction",
  "flex-flow",
  "-ms-flex-flow",
  "-webkit-flex-flow",
  "flex-grow",
  "-webkit-flex-grow",
  "-ms-flex-item-align",
  "-webkit-flex-item-align",
  "-ms-flex-line-pack",
  "-webkit-flex-line-pack",
  "-ms-flex",
  "-ms-flex-negative",
  "-ms-flex-order",
  "-webkit-flex-order",
  "-ms-flex-pack",
  "-webkit-flex-pack",
  "-ms-flex-positive",
  "-ms-flex-preferred-size",
  "flex-shrink",
  "-webkit-flex-shrink",
  "-webkit-flex",
  "flex-wrap",
  "-ms-flex-wrap",
  "-webkit-flex-wrap",
  "float",
  "float-defer",
  "-moz-float-edge",
  "float-offset",
  "float-reference",
  "flood-color",
  "flood-opacity",
  "flow",
  "flow-from",
  "-ms-flow-from",
  "-webkit-flow-from",
  "flow-into",
  "-ms-flow-into",
  "-webkit-flow-into",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "-moz-font-feature-settings",
  "-ms-font-feature-settings",
  "-webkit-font-feature-settings",
  "font-kerning",
  "-webkit-font-kerning",
  "font-language-override",
  "-moz-font-language-override",
  "font-optical-sizing",
  "font-palette",
  "font-size",
  "font-size-adjust",
  "-webkit-font-size-delta",
  "-webkit-font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-synthesis-small-caps",
  "font-synthesis-style",
  "font-synthesis-weight",
  "font-variant",
  "font-variant-alternates",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-emoji",
  "font-variant-ligatures",
  "-webkit-font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "footnote-display",
  "footnote-policy",
  "-moz-force-broken-image-icon",
  "forced-color-adjust",
  "gap",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "grid",
  "-webkit-grid-after",
  "grid-area",
  "grid-auto-columns",
  "-webkit-grid-auto-columns",
  "grid-auto-flow",
  "-webkit-grid-auto-flow",
  "grid-auto-rows",
  "-webkit-grid-auto-rows",
  "-webkit-grid-before",
  "grid-column",
  "-ms-grid-column-align",
  "grid-column-end",
  "grid-column-gap",
  "-ms-grid-column",
  "-ms-grid-column-span",
  "grid-column-start",
  "-webkit-grid-column",
  "-ms-grid-columns",
  "-webkit-grid-columns",
  "-webkit-grid-end",
  "grid-gap",
  "grid-row",
  "-ms-grid-row-align",
  "grid-row-end",
  "grid-row-gap",
  "-ms-grid-row",
  "-ms-grid-row-span",
  "grid-row-start",
  "-webkit-grid-row",
  "-ms-grid-rows",
  "-webkit-grid-rows",
  "-webkit-grid-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "-ms-high-contrast-adjust",
  "-webkit-highlight",
  "hyphenate-character",
  "-webkit-hyphenate-character",
  "-webkit-hyphenate-limit-after",
  "-webkit-hyphenate-limit-before",
  "hyphenate-limit-chars",
  "-ms-hyphenate-limit-chars",
  "hyphenate-limit-last",
  "hyphenate-limit-lines",
  "-ms-hyphenate-limit-lines",
  "-webkit-hyphenate-limit-lines",
  "hyphenate-limit-zone",
  "-ms-hyphenate-limit-zone",
  "hyphens",
  "-moz-hyphens",
  "-ms-hyphens",
  "-webkit-hyphens",
  "image-orientation",
  "-moz-image-region",
  "image-rendering",
  "image-resolution",
  "-ms-ime-align",
  "ime-mode",
  "inherits",
  "initial-letter",
  "initial-letter-align",
  "-webkit-initial-letter",
  "initial-letter-wrap",
  "initial-value",
  "inline-size",
  "inline-sizing",
  "input-format",
  "-wap-input-format",
  "-wap-input-required",
  "input-security",
  "inset",
  "inset-block",
  "inset-block-end",
  "inset-block-start",
  "inset-inline",
  "inset-inline-end",
  "inset-inline-start",
  "-ms-interpolation-mode",
  "isolation",
  "justify-content",
  "-webkit-justify-content",
  "justify-items",
  "-webkit-justify-items",
  "justify-self",
  "-webkit-justify-self",
  "kerning",
  "layout-flow",
  "layout-grid",
  "layout-grid-char",
  "layout-grid-line",
  "layout-grid-mode",
  "layout-grid-type",
  "leading-trim",
  "left",
  "letter-spacing",
  "lighting-color",
  "-webkit-line-align",
  "-webkit-line-box-contain",
  "line-break",
  "-webkit-line-break",
  "line-clamp",
  "-webkit-line-clamp",
  "line-gap-override",
  "line-grid",
  "-webkit-line-grid-snap",
  "-webkit-line-grid",
  "line-height",
  "line-height-step",
  "line-increment",
  "line-padding",
  "line-snap",
  "-webkit-line-snap",
  "-o-link",
  "-o-link-source",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "-webkit-locale",
  "-webkit-logical-height",
  "-webkit-logical-width",
  "margin",
  "-webkit-margin-after-collapse",
  "-webkit-margin-after",
  "-webkit-margin-before-collapse",
  "-webkit-margin-before",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "-webkit-margin-bottom-collapse",
  "margin-break",
  "-webkit-margin-collapse",
  "-moz-margin-end",
  "-webkit-margin-end",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "-moz-margin-start",
  "-webkit-margin-start",
  "margin-top",
  "-webkit-margin-top-collapse",
  "margin-trim",
  "marker",
  "marker-end",
  "marker-knockout-left",
  "marker-knockout-right",
  "marker-mid",
  "marker-offset",
  "marker-pattern",
  "marker-segment",
  "marker-side",
  "marker-start",
  "marks",
  "-wap-marquee-dir",
  "-webkit-marquee-direction",
  "-webkit-marquee-increment",
  "-wap-marquee-loop",
  "-webkit-marquee-repetition",
  "-wap-marquee-speed",
  "-webkit-marquee-speed",
  "-wap-marquee-style",
  "-webkit-marquee-style",
  "-webkit-marquee",
  "mask",
  "-webkit-mask-attachment",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "-webkit-mask-box-image-outset",
  "-webkit-mask-box-image-repeat",
  "-webkit-mask-box-image-slice",
  "-webkit-mask-box-image-source",
  "-webkit-mask-box-image",
  "-webkit-mask-box-image-width",
  "mask-clip",
  "-webkit-mask-clip",
  "mask-composite",
  "-webkit-mask-composite",
  "mask-image",
  "-webkit-mask-image",
  "mask-mode",
  "mask-origin",
  "-webkit-mask-origin",
  "mask-position",
  "-webkit-mask-position",
  "mask-position-x",
  "-webkit-mask-position-x",
  "mask-position-y",
  "-webkit-mask-position-y",
  "mask-repeat",
  "-webkit-mask-repeat",
  "-webkit-mask-repeat-x",
  "-webkit-mask-repeat-y",
  "mask-size",
  "-webkit-mask-size",
  "mask-source-type",
  "-webkit-mask-source-type",
  "mask-type",
  "-webkit-mask",
  "-webkit-match-nearest-mail-blockquote-color",
  "math-style",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-lines",
  "-webkit-max-logical-height",
  "-webkit-max-logical-width",
  "max-width",
  "max-zoom",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-intrinsic-sizing",
  "-webkit-min-logical-height",
  "-webkit-min-logical-width",
  "min-width",
  "min-zoom",
  "mix-blend-mode",
  "motion",
  "motion-offset",
  "motion-path",
  "motion-rotation",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "-webkit-nbsp-mode",
  "negative",
  "object-fit",
  "-o-object-fit",
  "object-overflow",
  "object-position",
  "-o-object-position",
  "object-view-box",
  "offset",
  "offset-anchor",
  "offset-block-end",
  "offset-block-start",
  "offset-distance",
  "offset-inline-end",
  "offset-inline-start",
  "offset-path",
  "offset-position",
  "offset-rotate",
  "offset-rotation",
  "opacity",
  "-moz-opacity",
  "-webkit-opacity",
  "order",
  "-webkit-order",
  "-moz-orient",
  "orientation",
  "orphans",
  "-moz-osx-font-smoothing",
  "outline",
  "outline-color",
  "-moz-outline-color",
  "-moz-outline",
  "outline-offset",
  "-moz-outline-offset",
  "-moz-outline-radius-bottomleft",
  "-moz-outline-radius-bottomright",
  "-moz-outline-radius",
  "-moz-outline-radius-topleft",
  "-moz-outline-radius-topright",
  "outline-style",
  "-moz-outline-style",
  "outline-width",
  "-moz-outline-width",
  "overflow",
  "overflow-anchor",
  "overflow-block",
  "overflow-clip-margin",
  "overflow-inline",
  "-webkit-overflow-scrolling",
  "-ms-overflow-style",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "override-colors",
  "overscroll-behavior",
  "overscroll-behavior-block",
  "overscroll-behavior-inline",
  "overscroll-behavior-x",
  "overscroll-behavior-y",
  "pad",
  "padding",
  "-webkit-padding-after",
  "-webkit-padding-before",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "-moz-padding-end",
  "-webkit-padding-end",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "-moz-padding-start",
  "-webkit-padding-start",
  "padding-top",
  "page",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "page-orientation",
  "paint-order",
  "pause",
  "pause-after",
  "pause-before",
  "-apple-pay-button-style",
  "-apple-pay-button-type",
  "pen-action",
  "perspective",
  "-moz-perspective",
  "-ms-perspective",
  "perspective-origin",
  "-moz-perspective-origin",
  "-ms-perspective-origin",
  "-webkit-perspective-origin",
  "perspective-origin-x",
  "-webkit-perspective-origin-x",
  "perspective-origin-y",
  "-webkit-perspective-origin-y",
  "-webkit-perspective",
  "pitch",
  "pitch-range",
  "place-content",
  "place-items",
  "place-self",
  "play-during",
  "pointer-events",
  "position",
  "prefix",
  "print-color-adjust",
  "-webkit-print-color-adjust",
  "property-name",
  "quotes",
  "r",
  "range",
  "-webkit-region-break-after",
  "-webkit-region-break-before",
  "-webkit-region-break-inside",
  "region-fragment",
  "-webkit-region-fragment",
  "-webkit-region-overflow",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "richness",
  "right",
  "rotate",
  "row-gap",
  "-webkit-rtl-ordering",
  "ruby-align",
  "ruby-merge",
  "ruby-overhang",
  "ruby-position",
  "-webkit-ruby-position",
  "running",
  "rx",
  "ry",
  "scale",
  "scroll-behavior",
  "-ms-scroll-chaining",
  "-ms-scroll-limit",
  "-ms-scroll-limit-x-max",
  "-ms-scroll-limit-x-min",
  "-ms-scroll-limit-y-max",
  "-ms-scroll-limit-y-min",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "-ms-scroll-rails",
  "scroll-snap-align",
  "scroll-snap-coordinate",
  "-webkit-scroll-snap-coordinate",
  "scroll-snap-destination",
  "-webkit-scroll-snap-destination",
  "scroll-snap-margin",
  "scroll-snap-margin-bottom",
  "scroll-snap-margin-left",
  "scroll-snap-margin-right",
  "scroll-snap-margin-top",
  "scroll-snap-points-x",
  "-ms-scroll-snap-points-x",
  "-webkit-scroll-snap-points-x",
  "scroll-snap-points-y",
  "-ms-scroll-snap-points-y",
  "-webkit-scroll-snap-points-y",
  "scroll-snap-stop",
  "scroll-snap-type",
  "-ms-scroll-snap-type",
  "-webkit-scroll-snap-type",
  "scroll-snap-type-x",
  "scroll-snap-type-y",
  "-ms-scroll-snap-x",
  "-ms-scroll-snap-y",
  "-ms-scroll-translation",
  "scrollbar-arrow-color",
  "scrollbar-base-color",
  "scrollbar-color",
  "scrollbar-dark-shadow-color",
  "scrollbar-darkshadow-color",
  "scrollbar-face-color",
  "scrollbar-gutter",
  "scrollbar-highlight-color",
  "scrollbar-shadow-color",
  "scrollbar-track-color",
  "scrollbar-width",
  "scrollbar3d-light-color",
  "scrollbar3dlight-color",
  "shape-image-threshold",
  "-webkit-shape-image-threshold",
  "shape-inside",
  "-webkit-shape-inside",
  "shape-margin",
  "-webkit-shape-margin",
  "shape-outside",
  "-webkit-shape-outside",
  "-webkit-shape-padding",
  "shape-rendering",
  "size",
  "size-adjust",
  "snap-height",
  "solid-color",
  "solid-opacity",
  "spatial-navigation-action",
  "spatial-navigation-contain",
  "spatial-navigation-function",
  "speak",
  "speak-as",
  "speak-header",
  "speak-numeral",
  "speak-punctuation",
  "speech-rate",
  "src",
  "-moz-stack-sizing",
  "stop-color",
  "stop-opacity",
  "stress",
  "string-set",
  "stroke",
  "stroke-align",
  "stroke-alignment",
  "stroke-break",
  "stroke-color",
  "stroke-dash-corner",
  "stroke-dash-justify",
  "stroke-dashadjust",
  "stroke-dasharray",
  "stroke-dashcorner",
  "stroke-dashoffset",
  "stroke-image",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-origin",
  "stroke-position",
  "stroke-repeat",
  "stroke-size",
  "stroke-width",
  "suffix",
  "supported-color-schemes",
  "-webkit-svg-shadow",
  "symbols",
  "syntax",
  "system",
  "tab-size",
  "-moz-tab-size",
  "-o-tab-size",
  "-o-table-baseline",
  "table-layout",
  "-webkit-tap-highlight-color",
  "text-align",
  "text-align-all",
  "text-align-last",
  "-moz-text-align-last",
  "text-anchor",
  "text-autospace",
  "-moz-text-blink",
  "-ms-text-combine-horizontal",
  "text-combine-upright",
  "-webkit-text-combine",
  "text-decoration",
  "text-decoration-blink",
  "text-decoration-color",
  "-moz-text-decoration-color",
  "-webkit-text-decoration-color",
  "text-decoration-line",
  "-moz-text-decoration-line",
  "text-decoration-line-through",
  "-webkit-text-decoration-line",
  "text-decoration-none",
  "text-decoration-overline",
  "text-decoration-skip",
  "text-decoration-skip-box",
  "text-decoration-skip-ink",
  "text-decoration-skip-inset",
  "text-decoration-skip-self",
  "text-decoration-skip-spaces",
  "-webkit-text-decoration-skip",
  "text-decoration-style",
  "-moz-text-decoration-style",
  "-webkit-text-decoration-style",
  "text-decoration-thickness",
  "text-decoration-underline",
  "-webkit-text-decoration",
  "-webkit-text-decorations-in-effect",
  "text-edge",
  "text-emphasis",
  "text-emphasis-color",
  "-webkit-text-emphasis-color",
  "text-emphasis-position",
  "-webkit-text-emphasis-position",
  "text-emphasis-skip",
  "text-emphasis-style",
  "-webkit-text-emphasis-style",
  "-webkit-text-emphasis",
  "-webkit-text-fill-color",
  "text-group-align",
  "text-indent",
  "text-justify",
  "text-justify-trim",
  "text-kashida",
  "text-kashida-space",
  "text-line-through",
  "text-line-through-color",
  "text-line-through-mode",
  "text-line-through-style",
  "text-line-through-width",
  "text-orientation",
  "-webkit-text-orientation",
  "text-overflow",
  "text-overline",
  "text-overline-color",
  "text-overline-mode",
  "text-overline-style",
  "text-overline-width",
  "text-rendering",
  "-webkit-text-security",
  "text-shadow",
  "text-size-adjust",
  "-moz-text-size-adjust",
  "-ms-text-size-adjust",
  "-webkit-text-size-adjust",
  "text-space-collapse",
  "text-space-trim",
  "text-spacing",
  "-webkit-text-stroke-color",
  "-webkit-text-stroke",
  "-webkit-text-stroke-width",
  "text-transform",
  "text-underline",
  "text-underline-color",
  "text-underline-mode",
  "text-underline-offset",
  "text-underline-position",
  "-webkit-text-underline-position",
  "text-underline-style",
  "text-underline-width",
  "text-wrap",
  "-webkit-text-zoom",
  "top",
  "touch-action",
  "touch-action-delay",
  "-ms-touch-action",
  "-webkit-touch-callout",
  "-ms-touch-select",
  "-apple-trailing-word",
  "transform",
  "transform-box",
  "-moz-transform",
  "-ms-transform",
  "-o-transform",
  "transform-origin",
  "-moz-transform-origin",
  "-ms-transform-origin",
  "-o-transform-origin",
  "-webkit-transform-origin",
  "transform-origin-x",
  "-webkit-transform-origin-x",
  "transform-origin-y",
  "-webkit-transform-origin-y",
  "transform-origin-z",
  "-webkit-transform-origin-z",
  "transform-style",
  "-moz-transform-style",
  "-ms-transform-style",
  "-webkit-transform-style",
  "-webkit-transform",
  "transition",
  "transition-delay",
  "-moz-transition-delay",
  "-ms-transition-delay",
  "-o-transition-delay",
  "-webkit-transition-delay",
  "transition-duration",
  "-moz-transition-duration",
  "-ms-transition-duration",
  "-o-transition-duration",
  "-webkit-transition-duration",
  "-moz-transition",
  "-ms-transition",
  "-o-transition",
  "transition-property",
  "-moz-transition-property",
  "-ms-transition-property",
  "-o-transition-property",
  "-webkit-transition-property",
  "transition-timing-function",
  "-moz-transition-timing-function",
  "-ms-transition-timing-function",
  "-o-transition-timing-function",
  "-webkit-transition-timing-function",
  "-webkit-transition",
  "translate",
  "uc-alt-skin",
  "uc-skin",
  "unicode-bidi",
  "unicode-range",
  "-webkit-user-drag",
  "-moz-user-focus",
  "-moz-user-input",
  "-moz-user-modify",
  "-webkit-user-modify",
  "user-select",
  "-moz-user-select",
  "-ms-user-select",
  "-webkit-user-select",
  "user-zoom",
  "vector-effect",
  "vertical-align",
  "viewport-fill",
  "viewport-fill-opacity",
  "viewport-fit",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "volume",
  "white-space",
  "-webkit-widget-region",
  "widows",
  "width",
  "will-change",
  "-moz-window-dragging",
  "-moz-window-shadow",
  "word-boundary-detection",
  "word-boundary-expansion",
  "word-break",
  "word-spacing",
  "word-wrap",
  "wrap-after",
  "wrap-before",
  "wrap-flow",
  "-ms-wrap-flow",
  "-webkit-wrap-flow",
  "wrap-inside",
  "-ms-wrap-margin",
  "-webkit-wrap-margin",
  "-webkit-wrap-padding",
  "-webkit-wrap-shape-inside",
  "-webkit-wrap-shape-outside",
  "wrap-through",
  "-ms-wrap-through",
  "-webkit-wrap-through",
  "-webkit-wrap",
  "writing-mode",
  "-webkit-writing-mode",
  "x",
  "y",
  "z-index",
  "zoom"
];
const require$$0$2 = {
  properties
};
knownCssProperties.all = require$$0$2.properties;
var __awaiter$l = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class colorSchemaNameInterface extends SInterface {
  static get _definition() {
    return {
      saturate: {
        type: "Number|String",
        default: 0
      },
      desaturate: {
        type: "Number",
        default: 0
      },
      darken: {
        type: "Number",
        default: 0
      },
      lighten: {
        type: "Number",
        default: 0
      },
      spin: {
        type: "Number",
        default: 0
      },
      alpha: {
        type: "Number",
        default: 1
      }
    };
  }
}
class SThemeBase extends SEventEmitter {
  constructor(theme, variant) {
    super({});
    this._overridedConfig = {};
    this.theme = theme !== null && theme !== void 0 ? theme : SSugarConfig.get("theme.theme");
    this.variant = variant !== null && variant !== void 0 ? variant : SSugarConfig.get("theme.variant");
    if (!SSugarConfig.get(`theme.themes.${this.theme}-${this.variant}`)) {
      throw new Error(`Sorry but the requested theme "<yellow>${this.theme}-${this.variant}</yellow>" does not exists...`);
    }
  }
  static sortMedia(media) {
    var _a3;
    if (!media.defaultAction) {
      return media;
    }
    const queries = __sort((_a3 = media.queries) !== null && _a3 !== void 0 ? _a3 : {}, (a3, b2) => {
      if (media.defaultAction === "<=") {
        return a3.value.minWidth < b2.value.minWidth ? 1 : -1;
      } else if (media.defaultAction === ">=") {
        return a3.value.minWidth > b2.value.minWidth ? 1 : -1;
      }
      return 0;
    });
    media.queries = queries;
    return media;
  }
  get id() {
    return `${this.theme}-${this.variant}`;
  }
  static get theme() {
    return SSugarConfig.get("theme.theme");
  }
  static get variant() {
    return SSugarConfig.get("theme.variant");
  }
  static get themesNames() {
    return Object.keys(SSugarConfig.get("theme.themes"));
  }
  static isDark() {
    return this.variant === "dark";
  }
  static isMobileFirst() {
    return this.getSafe("media.defaultAction") === ">=";
  }
  static getThemeMetas() {
    var _a3;
    let defaultTheme = SSugarConfig.get("theme.theme"), defaultVariant = SSugarConfig.get("theme.variant");
    let theme = defaultTheme, variant = defaultVariant;
    const metas = (_a3 = SSugarConfig.get(`theme.themes.${theme}-${variant}.metas`)) !== null && _a3 !== void 0 ? _a3 : {};
    return __deepMerge({
      name: `${theme !== null && theme !== void 0 ? theme : defaultTheme}-${variant !== null && variant !== void 0 ? variant : defaultVariant}`,
      theme: theme !== null && theme !== void 0 ? theme : defaultTheme,
      variant: variant !== null && variant !== void 0 ? variant : defaultVariant
    }, metas);
  }
  static get themes() {
    var _a3, _b2;
    const themes = SSugarConfig.get("theme.themes");
    const returnedThemes = {};
    for (let [themeName, themeObj] of Object.entries(themes)) {
      const parts = themeName.split("-"), name2 = parts[0], variant = (_a3 = parts[1]) !== null && _a3 !== void 0 ? _a3 : "light";
      if (!returnedThemes[name2]) {
        returnedThemes[name2] = {
          metas: (_b2 = themeObj.metas) !== null && _b2 !== void 0 ? _b2 : {},
          variants: {}
        };
      }
      if (!returnedThemes[name2].variants[variant]) {
        returnedThemes[name2].variants[variant] = themeObj;
      }
    }
    return returnedThemes;
  }
  static getTheme(settings = {}) {
    const themesNames = Object.keys(SSugarConfig.get("theme.themes"));
    let theme = settings.theme, variant = settings.variant;
    if (!theme) {
      theme = SSugarConfig.get("theme.theme");
    }
    if (!variant) {
      variant = SSugarConfig.get("theme.variant");
    }
    if (!themesNames.includes(`${theme}-${variant}`)) {
      theme = SSugarConfig.get("theme.theme");
      variant = SSugarConfig.get("theme.variant");
    }
    if (this._instanciatedThemes[`${theme}-${variant}`]) {
      return this._instanciatedThemes[`${theme}-${variant}`];
    }
    if (!themesNames[`${theme}-${variant}`]) {
      this._instanciatedThemes[`${theme}-${variant}`] = new this(theme, variant);
    }
    return this._instanciatedThemes[`${theme}-${variant}`];
  }
  static hash(dotPath = "", settings) {
    const config2 = this.get(dotPath, settings);
    return __objectHash(config2);
  }
  static resolveFontSize(size, settings) {
    const theme = this.getTheme(settings);
    return theme.resolveFontSize(size);
  }
  static resolvePadding(size, settings) {
    const theme = this.getTheme(settings);
    return theme.resolvePadding(size);
  }
  static resolveMargin(size, settings) {
    const theme = this.getTheme(settings);
    return theme.resolveMargin(size);
  }
  static resolveBorderRadius(size, settings) {
    const theme = this.getTheme(settings);
    return theme.resolveBorderRadius(size);
  }
  static resolveBorderWidth(size, settings) {
    const theme = this.getTheme(settings);
    return theme.resolveBorderWidth(size);
  }
  static resolveColor(color2, schema, modifier, settings) {
    const theme = this.getTheme({
      theme: settings.theme,
      variant: settings.variant
    });
    return theme.resolveColor(color2, schema, modifier, settings);
  }
  static cssVar(dotPath, fallback = true, settings) {
    const theme = this.getTheme(settings);
    dotPath = theme.proxyNonExistingUiDotpath(dotPath);
    let fb = theme.get(dotPath);
    if (!fallback || typeof fb === "string" && fb.includes(","))
      fb = 0;
    const v = `var(${__compressVarName(`--s-theme-${dotPath.replace(/\./gm, "-").replace(/:/gm, "-").replace(/\?/gm, "").replace(/--/gm, "-")}`)}, ${fb})`;
    return v;
  }
  static buildMediaQuery(queryString) {
    let currentQueryList = [];
    const mediaConfig = this.sortMedia(this.get("media")), sortedMedia = Object.keys(mediaConfig.queries);
    const queryAr = queryString.split(" ").map((l) => l.trim()).filter((l) => l !== "");
    queryAr.forEach((query2, i2) => {
      if (query2 === "and" || query2 === "or") {
        currentQueryList.push(query2);
        return;
      }
      const firstChar = query2.slice(0, 1);
      const firstTwoChar = query2.slice(0, 2);
      const lastChar = query2.slice(-1);
      let action = this.get("media.defaultAction");
      let mediaName = query2;
      if (lastChar === "-" || lastChar === "|")
        mediaName = mediaName.slice(0, -1);
      if (firstTwoChar === ">=" || firstTwoChar === "<=" || firstTwoChar === "==") {
        mediaName = mediaName.slice(2);
        action = firstTwoChar;
      } else if (firstChar === "<" || firstChar === ">" || firstChar === "=") {
        mediaName = mediaName.slice(1);
        action = firstChar;
      }
      const mediaQueryConfig = this.get("media.queries")[mediaName];
      if (!mediaQueryConfig)
        throw new Error(`<red>[postcssSugarPlugin.media]</red> Sorry but the requested media "<yellow>${mediaName}</yellow>" does not exists in the config. Here's the available medias: ${Object.keys(this.get("media.queries")).map((l) => `<green>${l}</green>`).join(",")}`);
      const queryList = [];
      Object.keys(mediaQueryConfig).forEach((prop) => {
        const dashProp = __dashCase(prop);
        let value = mediaQueryConfig[prop];
        if (!value) {
          if (prop === "minWidth") {
            value = 0;
          } else if (prop === "maxWidth") {
            value = 99999;
          }
        }
        if (["min-width", "max-width"].indexOf(dashProp) !== -1) {
          if (action === ">") {
            if (dashProp === "max-width") {
              let argName = "min-width";
              queryList.push(`(${argName}: ${value + 1}px)`);
            }
          } else if (action === "<") {
            if (dashProp === "min-width") {
              let argName = "max-width";
              queryList.push(`(${argName}: ${value}px)`);
            }
          } else if (action === "=") {
            queryList.push(`(${dashProp}: ${value}px)`);
          } else if (action === ">=") {
            if (sortedMedia.at(-1) === mediaName) {
              return;
            }
            if (dashProp === "min-width") {
              queryList.push(`(${dashProp}: ${value}px)`);
            }
          } else if (action === "<=") {
            if (sortedMedia[0] === mediaName) {
              return;
            }
            if (dashProp === "max-width") {
              queryList.push(`(${dashProp}: ${value}px)`);
            }
          } else {
            queryList.push(`(${dashProp}: ${value}px)`);
          }
        } else {
          queryList.push(`(${dashProp}: ${value}px)`);
        }
      });
      if (lastChar === "-") {
        queryList.push("(orientation: landscape)");
      } else if (lastChar === "|") {
        queryList.push("(orientation: portrait)");
      }
      currentQueryList.push(queryList.join(" and "));
    });
    currentQueryList = currentQueryList.filter((l) => l.trim() !== "");
    if (currentQueryList.length) {
      currentQueryList.unshift("and");
    }
    currentQueryList.unshift(this.get("media.defaultQuery"));
    return `@media ${currentQueryList.join(" ")}`;
  }
  static resolveCssPropertyValue(property, value, settings) {
    var _a3, _b2, _c2, _d2, _e2, _f2, _g, _h, _j;
    const dashProp = __dashCase(property);
    switch (dashProp) {
      case "font-family":
        const fontObj = this.get(`font.family.${value}`);
        return (_a3 = fontObj === null || fontObj === void 0 ? void 0 : fontObj.fontFamily) !== null && _a3 !== void 0 ? _a3 : value;
      case "font-size":
        return (_b2 = this.resolveFontSize(value, settings)) !== null && _b2 !== void 0 ? _b2 : value;
      case "color":
      case "background-color":
        let color2 = value, schema;
        if (Array.isArray(value) && value.length === 2) {
          color2 = value[0];
          schema = value[1];
        }
        return (_c2 = this.resolveColor(color2, schema, null, Object.assign(Object.assign({}, settings !== null && settings !== void 0 ? settings : {}), { return: "value" }))) !== null && _c2 !== void 0 ? _c2 : value;
      case "border-radius":
      case "border-top-left-radius":
      case "border-top-right-radius":
      case "border-bottom-right-radius":
      case "border-bottom-left-radius":
        return (_d2 = this.resolveBorderRadius(value)) !== null && _d2 !== void 0 ? _d2 : value;
      case "border-width":
        return (_e2 = this.resolveBorderWidth(value)) !== null && _e2 !== void 0 ? _e2 : value;
      case "transition":
        return (_f2 = this.getSafe(`transition.${value}`)) !== null && _f2 !== void 0 ? _f2 : value;
      case "margin-inline":
      case "margin-block":
      case "margin-inline-start":
      case "margin-inline-end":
      case "margin-block-start":
      case "margin-block-end":
      case "margin":
      case "margin-top":
      case "margin-bottom":
      case "margin-left":
      case "margin-right":
        return (_g = this.resolveMargin(value)) !== null && _g !== void 0 ? _g : value;
      case "padding-inline":
      case "padding-block":
      case "padding-inline-start":
      case "padding-inline-end":
      case "padding-block-start":
      case "padding-block-end":
      case "padding":
      case "padding-top":
      case "padding-bottom":
      case "padding-left":
      case "padding-right":
        return (_h = this.resolvePadding(value)) !== null && _h !== void 0 ? _h : value;
      case "depth":
        return (_j = this.getSafe(`depth.${value}`, settings)) !== null && _j !== void 0 ? _j : value;
    }
    return value;
  }
  static resolveCssObjectPropertiesValues(object, settings) {
    const newObj = Object.assign({}, object);
    for (let [prop, value] of Object.entries(newObj)) {
      newObj[prop] = this.resolveCssPropertyValue(prop, value, settings);
    }
    return newObj;
  }
  static jsObjectToCssProperties(jsObject, settings) {
    const finalSettings = __deepMerge({
      exclude: [],
      only: []
    }, settings);
    const propsStack = [];
    Object.keys(jsObject).forEach((prop) => {
      if (finalSettings.exclude.indexOf(prop) !== -1)
        return;
      if (finalSettings.exclude.indexOf(__dashCase(prop)) !== -1)
        return;
      const originalProp = prop;
      prop = __dashCase(prop).trim();
      if (finalSettings.exclude.length && finalSettings.exclude.indexOf(prop) !== -1)
        return;
      if (finalSettings.only.length && finalSettings.only.indexOf(prop) === -1)
        return;
      const value = jsObject[originalProp];
      if (!value)
        return;
      let color2, schema;
      const medias = Object.keys(this.get("media.queries"));
      if (medias.includes(originalProp)) {
        propsStack.push(`@sugar.media(${prop.replace(/^@/, "")}) {`);
        propsStack.push(this.jsObjectToCssProperties(value, finalSettings));
        propsStack.push(`}`);
      } else {
        switch (prop) {
          case "font-family":
            propsStack.push(`@sugar.font.family(${value});`);
            break;
          case "font-size":
            propsStack.push(`@sugar.font.size(${value});`);
            break;
          case "color":
            color2 = value;
            schema = "";
            if (Array.isArray(value)) {
              color2 = value[0];
              schema = value[1];
            }
            propsStack.push(`color: sugar.color(${color2}, ${schema});`);
            break;
          case "background-color":
            color2 = value;
            schema = "";
            if (Array.isArray(value)) {
              color2 = value[0];
              schema = value[1];
            }
            propsStack.push(`background-color: sugar.color(${color2}, ${schema});`);
            break;
          case "border-radius":
          case "border-top-left-radius":
          case "border-top-right-radius":
          case "border-bottom-right-radius":
          case "border-bottom-left-radius":
            propsStack.push(`border-radius: sugar.border.radius(${value});`);
            break;
          case "border-width":
            propsStack.push(`border-width: sugar.border.width(${value});`);
            break;
          case "transition":
            propsStack.push(`transition: sugar.transition(${value});`);
            break;
          case "margin-inline":
          case "margin-block":
          case "margin-inline-start":
          case "margin-inline-end":
          case "margin-block-start":
          case "margin-block-end":
          case "margin":
          case "margin-top":
          case "margin-bottom":
          case "margin-left":
          case "margin-right":
            propsStack.push(`${prop}: sugar.margin(${value});`);
            break;
          case "padding-inline":
          case "padding-block":
          case "padding-inline-start":
          case "padding-inline-end":
          case "padding-block-start":
          case "padding-block-end":
          case "padding":
          case "padding-top":
          case "padding-bottom":
          case "padding-left":
          case "padding-right":
            propsStack.push(`${prop}: sugar.padding(${value});`);
            break;
          case "depth":
            propsStack.push(`@sugar.depth(${value});`);
            break;
          case "default-color":
            propsStack.push(`@sugar.color(${value});`);
            break;
          default:
            const props = knownCssProperties.all;
            if (props.indexOf(prop) === -1)
              return;
            propsStack.push(`${prop}: ${value};`);
            break;
        }
      }
    });
    return propsStack.join("\n");
  }
  static jsConfigObjectToCssProperties(obj2) {
    let vars = [];
    for (let [key, value] of Object.entries(__flatten(obj2))) {
      if (__isColor(value)) {
        const color2 = key.match(/^color\.([a-zA-Z0-9]+)\./);
        if (!(color2 === null || color2 === void 0 ? void 0 : color2[1]))
          continue;
        const props = this.remapCssColor(color2[1], value);
        vars = [...vars, ...props.vars];
      }
      const varKey = key.replace(/\./gm, "-").replace(/:/gm, "-").replace(/\?/gm, "").replace(/--/gm, "-");
      let variable = __compressVarName(`--s-theme-${varKey}`);
      if (`${value}`.match(/:/)) {
        vars.push(`${variable}: "${value}";`);
      } else {
        vars.push(`${variable}: ${value};`);
      }
    }
    return vars;
  }
  static remapCssColor(from2, to2, settings) {
    const result2 = {
      vars: [],
      properties: {}
    };
    if (__isColor(to2)) {
      const color2 = new SColor(to2);
      result2.vars = [
        `${__compressVarName(`--s-theme-color-${from2}-h`)}: ${color2.h};`,
        `${__compressVarName(`--s-theme-color-${from2}-s`)}: ${color2.s};`,
        `${__compressVarName(`--s-theme-color-${from2}-l`)}: ${color2.l};`,
        `${__compressVarName(`--s-theme-color-${from2}-a`)}: ${color2.a};`
      ];
      result2.properties[__compressVarName(`--s-theme-color-${from2}-h`)] = color2.h;
      result2.properties[__compressVarName(`--s-theme-color-${from2}-s`)] = color2.s;
      result2.properties[__compressVarName(`--s-theme-color-${from2}-l`)] = color2.l;
      result2.properties[__compressVarName(`--s-theme-color-${from2}-a`)] = color2.a;
    } else {
      const toColorName = to2.split("-").slice(0, 1)[0], fromColorName = from2.split("-").slice(0, 1)[0];
      let toColorVariant = to2.split("-").pop();
      from2.split("-").pop();
      if (toColorName === toColorVariant)
        toColorVariant = void 0;
      let fromVariable = `--s-theme-color-${fromColorName}`, toVariable = `--s-theme-color-${toColorName}`;
      this.getTheme(settings).loopOnColors((colorObj) => {
        if (colorObj.name === toColorName) {
          if (toColorVariant) {
            if (colorObj.schema === toColorVariant) {
              result2.vars.push(`${__compressVarName(`${fromVariable}-saturation-offset`)}: var(${__compressVarName(`${toVariable}-${colorObj.schema}-saturation-offset`)}, 0);`);
              result2.properties[`${__compressVarName(`${fromVariable}-saturation-offset`)}`] = `var(${__compressVarName(`${toVariable}-${colorObj.schema}-saturation-offset`)}, 0)`;
              result2.vars.push(`${__compressVarName(`${fromVariable}-lightness-offset`)}: var(${__compressVarName(`${toVariable}-${colorObj.schema}-lightness-offset`)}, 0);`);
              result2.properties[`${__compressVarName(`${fromVariable}-lightness-offset`)}`] = `var(${__compressVarName(`${toVariable}-${colorObj.schema}-lightness-offset`)}, 0)`;
              result2.vars.push(`${__compressVarName(`${fromVariable}-a`)}: var(${__compressVarName(`${toVariable}-a`)}, 1);`);
              result2.properties[`${__compressVarName(`${fromVariable}-a`)}`] = `var(${__compressVarName(`${toVariable}-a`)}, 1)`;
            }
          } else {
            if (!colorObj.schema && colorObj.value.color) {
              result2.vars.push(`${__compressVarName(`${fromVariable}-h`)}: var(${__compressVarName(`${toVariable}-h`)});`);
              result2.properties[`${__compressVarName(`${fromVariable}-h`)}`] = `var(${__compressVarName(`${toVariable}-h`)})`;
              result2.vars.push(`${__compressVarName(`${fromVariable}-s`)}: var(${__compressVarName(`${toVariable}-s`)});`);
              result2.properties[`${__compressVarName(`${fromVariable}-s`)}`] = `var(${__compressVarName(`${toVariable}-s`)})`;
              result2.vars.push(`${__compressVarName(`${fromVariable}-l`)}: var(${__compressVarName(`${toVariable}-l`)});`);
              result2.properties[`${__compressVarName(`${fromVariable}-l`)}`] = `var(${__compressVarName(`${toVariable}-l`)})`;
            } else {
              result2.vars.push(`${__compressVarName(`${fromVariable}-${colorObj.schema}-saturation-offset`)}: var(${__compressVarName(`${toVariable}-${colorObj.schema}-saturation-offset`)}, 0);`);
              result2.properties[`${__compressVarName(`${fromVariable}-${colorObj.schema}-saturation-offset`)}`] = `var(${__compressVarName(`${toVariable}-${colorObj.schema}-saturation-offset`)}, 0)`;
              result2.vars.push(`${__compressVarName(`${fromVariable}-${colorObj.schema}-lightness-offset`)}: var(${__compressVarName(`${toVariable}-${colorObj.schema}-lightness-offset`)}, 0);`);
              result2.properties[`${__compressVarName(`${fromVariable}-${colorObj.schema}-lightness-offset`)}`] = `var(${__compressVarName(`${toVariable}-${colorObj.schema}-lightness-offset`)}, 0)`;
              result2.vars.push(`${__compressVarName(`${fromVariable}-a: var(${toVariable}-a`)}, 1);`);
              result2.properties[`${__compressVarName(`${fromVariable}-a`)}`] = `var(${__compressVarName(`${toVariable}-a`)}, 1)`;
            }
          }
        }
      });
    }
    return result2;
  }
  static toCssVars(settings) {
    const themeInstance = this.getTheme(settings);
    if (!themeInstance)
      throw new Error(`Sorry but the requested theme "<yellow>${settings.theme}-${settings.variant}</yellow>" does not exists...`);
    let vars = [
      `--s-theme: ${themeInstance.theme};`,
      `--s-theme-variant: ${themeInstance.variant};`
    ];
    themeInstance.loopOnColors((colorObj) => {
      const baseVariable = colorObj.value.variable;
      if (!colorObj.schema && colorObj.value.color) {
        vars.push(`${__compressVarName(`${baseVariable}-h`)}: ${colorObj.value.h};`);
        vars.push(`${__compressVarName(`${baseVariable}-s`)}: ${colorObj.value.s};`);
        vars.push(`${__compressVarName(`${baseVariable}-l`)}: ${colorObj.value.l};`);
        vars.push(`${__compressVarName(`${baseVariable}-a`)}: ${colorObj.value.a};`);
        vars.push(`${__compressVarName(`${baseVariable}-origin-h`)}: ${colorObj.value.h};`);
        vars.push(`${__compressVarName(`${baseVariable}-origin-s`)}: ${colorObj.value.s};`);
        vars.push(`${__compressVarName(`${baseVariable}-origin-l`)}: ${colorObj.value.l};`);
        vars.push(`${__compressVarName(`${baseVariable}-origin-a`)}: ${colorObj.value.a};`);
      } else if (colorObj.schema) {
        if (colorObj.value.saturate) {
          vars.push(`${__compressVarName(`${baseVariable}-saturation-offset`)}: ${colorObj.value.saturate};`);
        } else if (colorObj.value.desaturate) {
          vars.push(`${__compressVarName(`${baseVariable}-saturation-offset`)}: ${colorObj.value.desaturate * -1};`);
        } else {
          vars.push(`${__compressVarName(`${baseVariable}-saturation-offset`)}: 0;`);
        }
        if (colorObj.value.lighten) {
          vars.push(`${__compressVarName(`${baseVariable}-lightness-offset`)}: ${colorObj.value.lighten};`);
        } else if (colorObj.value.darken) {
          vars.push(`${__compressVarName(`${baseVariable}-lightness-offset`)}: ${colorObj.value.darken * -1};`);
        } else {
          vars.push(`${__compressVarName(`${baseVariable}-lightness-offset`)}: 0;`);
        }
        if (colorObj.value.alpha >= 0 && colorObj.value.alpha <= 1) {
          vars.push(`${__compressVarName(`${baseVariable}-a`)}: ${colorObj.value.alpha};`);
        }
      }
    });
    const themeObjWithoutColors = Object.assign({}, themeInstance.get("."));
    delete themeObjWithoutColors.color;
    const flattenedTheme = __flatten(themeObjWithoutColors);
    Object.keys(flattenedTheme).forEach((key) => {
      const value = flattenedTheme[key];
      const varKey = key.replace(/\./gm, "-").replace(/:/gm, "-").replace(/\?/gm, "").replace(/--/gm, "-");
      let variable = `--s-theme-${varKey}`;
      if (`${value}`.match(/:/)) {
        vars.push(`${__compressVarName(`${variable}`)}: "${flattenedTheme[key]}";`);
      } else {
        vars.push(`${__compressVarName(`${variable}`)}: ${flattenedTheme[key]};`);
      }
    });
    return vars;
  }
  static getSafe(dotPath, settings) {
    const instance = this.getTheme(settings);
    return instance.get(dotPath, {
      preventThrow: true
    });
  }
  static get(dotPath, settings) {
    const instance = this.getTheme(settings);
    return instance.get(dotPath);
  }
  static set(dotPath, value, settings) {
    const instance = this.getTheme(settings);
    return instance.set(dotPath, value);
  }
  get themes() {
    return SSugarConfig.get("theme.themes");
  }
  proxyNonExistingUiDotpath(dotPath) {
    let value = get(this._config, dotPath);
    if (value === void 0 && dotPath.match(/^ui\.[a-zA-Z0-9]+\./)) {
      dotPath = dotPath.replace(/^ui\.[a-zA-Z0-9]+\./, "ui.default.");
    }
    return dotPath;
  }
  getSafe(dotPath) {
    return this.get(dotPath, {
      preventThrow: true
    });
  }
  get _config() {
    if (this._cachedConfig) {
      return this._cachedConfig;
    }
    this._cachedConfig = Object.assign({}, __deepMerge(SSugarConfig.get("theme.themes")[this.id], this._overridedConfig));
    return this._cachedConfig;
  }
  get(dotPath, settings = {}) {
    const finalSettings = __deepMerge({
      preventThrow: false,
      defaultFallback: true
    }, settings);
    dotPath = this.proxyNonExistingUiDotpath(dotPath);
    let value = get(this._config, dotPath);
    if (value && dotPath === "media") {
      value = this.constructor.sortMedia(value);
    }
    if (value === void 0 && !finalSettings.preventThrow) {
      throw new Error(`<red>[${this.constructor.name}]</red> Sorry but the requested "<yellow>${this.id}</yellow>" theme config "<cyan>${dotPath}</cyan>" does not exists...`);
    }
    return value;
  }
  getOverridedConfig() {
    return this._overridedConfig;
  }
  emitSavedEvent() {
    this.emit("saved", {
      theme: this.theme,
      variant: this.variant,
      overridedConfig: Object.assign({}, this._overridedConfig)
    });
    return this;
  }
  hash(dotPath = "") {
    const config2 = this.get(dotPath);
    return __objectHash(config2);
  }
  themesConfig() {
    return SSugarConfig.get("theme");
  }
  set(dotPath, value) {
    __set(this._overridedConfig, dotPath, value);
    this.emit("update", {
      dotPath,
      value
    });
    return this;
  }
  restore(configs) {
    this._overridedConfig = __deepMerge(this._overridedConfig, configs !== null && configs !== void 0 ? configs : {});
    this.emit("restored", {
      overridedConfigs: Object.assign({}, this._overridedConfig)
    });
    return this;
  }
  clear() {
    this._overridedConfig = {};
    return this;
  }
  baseColors() {
    const map2 = {};
    for (let [colorName2, colorValue] of Object.entries(this.get("color"))) {
      const c = new SColor(colorValue);
      map2[colorName2] = {
        color: colorValue,
        variable: __compressVarName(`--s-theme-color-${colorName2}`),
        r: c.r,
        g: c.g,
        b: c.b,
        h: c.h,
        s: c.s,
        l: c.l,
        a: c.a
      };
    }
    return map2;
  }
  resolveFontSize(size) {
    const defaultSizeStr = this.get("font.size.default"), defaultSizeUnit = defaultSizeStr.replace(/[0-9]+/gm, ""), defaultSize = parseInt(defaultSizeStr);
    const registeredValue = this.getSafe(`font.size.${size}`);
    if (registeredValue !== void 0) {
      if (typeof registeredValue === "number") {
        return `${defaultSize * registeredValue}${defaultSizeUnit}`;
      }
    } else if (typeof size === "number") {
      return `${defaultSize * size}${defaultSizeUnit}`;
    }
    return registeredValue !== null && registeredValue !== void 0 ? registeredValue : size;
  }
  resolvePadding(size) {
    const defaultSizeStr = this.get("padding.default"), defaultSizeUnit = defaultSizeStr.replace(/[0-9]+/gm, ""), defaultSize = parseInt(defaultSizeStr);
    const registeredValue = this.getSafe(`padding.${size}`);
    if (registeredValue !== void 0) {
      if (typeof registeredValue === "number") {
        return `${defaultSize * registeredValue}${defaultSizeUnit}`;
      }
    } else if (typeof size === "number") {
      return `${defaultSize * size}${defaultSizeUnit}`;
    }
    return registeredValue !== null && registeredValue !== void 0 ? registeredValue : size;
  }
  resolveMargin(size) {
    const defaultSizeStr = this.get("margin.default"), defaultSizeUnit = defaultSizeStr.replace(/[0-9]+/gm, ""), defaultSize = parseInt(defaultSizeStr);
    const registeredValue = this.getSafe(`margin.${size}`);
    if (registeredValue !== void 0) {
      if (typeof registeredValue === "number") {
        return `${defaultSize * registeredValue}${defaultSizeUnit}`;
      }
    } else if (typeof size === "number") {
      return `${defaultSize * size}${defaultSizeUnit}`;
    }
    return registeredValue !== null && registeredValue !== void 0 ? registeredValue : size;
  }
  resolveBorderRadius(size) {
    const defaultSizeStr = this.get("border.radius.default"), defaultSizeUnit = defaultSizeStr.replace(/[0-9]+/gm, ""), defaultSize = parseInt(defaultSizeStr);
    const registeredValue = this.getSafe(`border.radius.${size}`);
    if (registeredValue !== void 0) {
      if (typeof registeredValue === "number") {
        return `${defaultSize * registeredValue}${defaultSizeUnit}`;
      }
    } else if (typeof size === "number") {
      return `${defaultSize * size}${defaultSizeUnit}`;
    }
    return registeredValue !== null && registeredValue !== void 0 ? registeredValue : size;
  }
  resolveBorderWidth(size) {
    const defaultSizeStr = this.get("border.width.default"), defaultSizeUnit = defaultSizeStr.replace(/[0-9]+/gm, ""), defaultSize = parseInt(defaultSizeStr);
    const registeredValue = this.getSafe(`border.width.${size}`);
    if (registeredValue !== void 0) {
      if (typeof registeredValue === "number") {
        return `${defaultSize * registeredValue}${defaultSizeUnit}`;
      }
    } else if (typeof size === "number") {
      return `${defaultSize * size}${defaultSizeUnit}`;
    }
    return registeredValue !== null && registeredValue !== void 0 ? registeredValue : size;
  }
  resolveColor(color2, schema, modifier, settings) {
    var _a3, _b2;
    if (color2.match(/^(hsla?|rgba?|hsv)\(/))
      return color2;
    if (color2.match(/^var\(--/))
      return color2;
    const finalSettings = Object.assign({ return: "value" }, settings !== null && settings !== void 0 ? settings : {});
    let colorName2 = color2;
    let colorSchemaName = schema !== null && schema !== void 0 ? schema : "";
    let colorModifier = modifier !== null && modifier !== void 0 ? modifier : "";
    if (colorSchemaName.match(/^--[a-z]+/)) {
      colorModifier = colorSchemaName;
      colorSchemaName = void 0;
    }
    let modifierParams = {};
    if (colorModifier) {
      modifierParams = colorSchemaNameInterface.apply(colorModifier);
    }
    let finalValue;
    if (__isColor(colorName2)) {
      const color3 = new SColor(colorName2);
      if (colorModifier) {
        color3.apply(colorModifier);
      }
      return color3.toString();
    } else {
      switch (finalSettings.return) {
        case "var":
          const colorVar = `--s-theme-color-${colorName2}`;
          let colorSchemaNameVar = `s-theme-color-${colorName2}`;
          if (colorSchemaName) {
            colorSchemaNameVar += `-${colorSchemaName}`;
          }
          colorSchemaNameVar = "--" + colorSchemaNameVar.replace(/-{2,999}/gm, "-");
          finalValue = colorVar;
          const hParts = [
            `var(${colorVar}-h, 0)`,
            `var(${colorSchemaNameVar}-spin ,${(_a3 = modifierParams.spin) !== null && _a3 !== void 0 ? _a3 : 0})`
          ];
          const sParts = [`var(${colorVar}-s, 0)`];
          if (colorSchemaName) {
            sParts.push(`var(${colorSchemaNameVar}-saturation-offset, 0)`);
          }
          let saturationOffset = modifierParams.saturate ? modifierParams.saturate : modifierParams.desaturate ? modifierParams.desaturate * -1 : void 0;
          if (saturationOffset !== void 0) {
            sParts.push(saturationOffset);
          }
          const lParts = [`var(${colorVar}-l, 0)`];
          if (colorSchemaName) {
            lParts.push(`var(${colorSchemaNameVar}-lightness-offset, 0)`);
          }
          let lightnessOffset = modifierParams.lighten ? modifierParams.lighten : modifierParams.darken ? modifierParams.darken * -1 : void 0;
          if (lightnessOffset !== void 0) {
            lParts.push(lightnessOffset);
          }
          modifierParams.alpha !== void 0 ? modifierParams.alpha : 1;
          finalValue = `hsla(
                    calc(
                        ${hParts.join(" + ")}
                    ),
                    calc(
                        (${sParts.join(" + ")}) * 1%
                    ),
                    calc(
                        (${lParts.join(" + ")}) * 1%
                    ),
                    ${modifierParams.alpha !== void 0 ? modifierParams.alpha : `var(${colorSchemaNameVar}-a, 1)`}
                    )`;
          finalValue = finalValue.replace(/(\n|\s{2,99999999})/gm, "").replace(/\t/gm, " ").replace(/\s?\+\s?/gm, " + ").replace(/\)\-\s?/gm, ") - ").replace(/\s?\*\s?/gm, " * ").replace(/\s?\/\s?/gm, " / ");
          break;
        case "value":
        default:
          const colorValue = (_b2 = this.getSafe(`color.${color2}`)) !== null && _b2 !== void 0 ? _b2 : color2;
          if (!schema && !modifier) {
            finalValue = colorValue;
          }
          let colorInstance = new SColor(colorValue);
          if (schema) {
            let finalSchema = schema;
            if (typeof schema === "string") {
              finalSchema = this.getSafe(`colorSchema.${schema}.color.${color2}`);
              if (!finalSchema) {
                finalSchema = this.getSafe(`colorSchema.${schema}`);
              }
            }
            if (finalSchema) {
              colorInstance = colorInstance.apply(finalSchema);
            }
          }
          if (modifier) {
            colorInstance = colorInstance.apply(modifier);
          }
          finalValue = colorInstance.toString();
          break;
      }
    }
    return finalValue;
  }
  loopOnColors(callback) {
    return __awaiter$l(this, void 0, void 0, function* () {
      const colorsObj = this.get("color"), colorSchemasObj = this.get("colorSchema");
      for (let [colorName2, colorValue] of Object.entries(colorsObj)) {
        const c = new SColor(colorValue);
        callback({
          name: colorName2,
          schema: "",
          value: {
            color: colorValue,
            variable: __compressVarName(`--s-theme-color-${colorName2}`),
            r: c.r,
            g: c.g,
            b: c.b,
            h: c.h,
            s: c.s,
            l: c.l,
            a: c.a
          }
        });
        for (let [schemaName, schemaObj] of Object.entries(colorSchemasObj)) {
          const newColor = c.apply(schemaObj, true);
          callback({
            name: colorName2,
            schema: schemaName,
            value: Object.assign(Object.assign({ variable: __compressVarName(`--s-theme-color-${colorName2}-${schemaName}`) }, schemaObj), { r: newColor.r, g: newColor.g, b: newColor.b, h: newColor.h, s: newColor.s, l: newColor.l, a: newColor.a })
          });
          if (schemaObj.color) {
            for (let [
              colorSchemaColorName,
              colorSchemaObj
            ] of Object.entries(schemaObj.color)) {
              if (colorSchemaColorName !== colorName2)
                continue;
              const newColor2 = c.apply(colorSchemaObj, true);
              callback({
                name: colorSchemaColorName,
                schema: schemaName,
                value: Object.assign(Object.assign({ variable: __compressVarName(`--s-theme-color-${colorSchemaColorName}-${schemaName}`) }, colorSchemaObj), { r: newColor2.r, g: newColor2.g, b: newColor2.b, h: newColor2.h, s: newColor2.s, l: newColor2.l, a: newColor2.a })
              });
            }
          }
        }
      }
      return true;
    });
  }
}
SThemeBase._instanciatedThemes = {};
var __awaiter$k = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class STheme extends SThemeBase {
  constructor(theme, variant) {
    super(theme, variant);
    this.state = {
      lod: void 0,
      overridedConfigs: {}
    };
    this.restore();
  }
  static get theme() {
    var _a3;
    const themeAttr = (_a3 = document.querySelector("html")) === null || _a3 === void 0 ? void 0 : _a3.getAttribute("theme");
    if (!themeAttr) {
      return SSugarConfig.get("theme.theme");
    }
    return themeAttr.split("-")[0];
  }
  static get variant() {
    var _a3;
    const themeAttr = (_a3 = document.querySelector("html")) === null || _a3 === void 0 ? void 0 : _a3.getAttribute("theme");
    if (!themeAttr) {
      return SSugarConfig.get("theme.variant");
    }
    return themeAttr.split("-")[1];
  }
  static get lod() {
    const currentTheme = this.getCurrentTheme();
    return currentTheme.lod;
  }
  static setLod(level, settings) {
    const currentTheme = this.getCurrentTheme();
    currentTheme.setLod(level, settings);
    return currentTheme;
  }
  static whenLodChange(cb) {
    const currentTheme = this.getCurrentTheme();
    return currentTheme.whenLodChange(cb);
  }
  static setTheme(theme, variant, $context = document.querySelector("html")) {
    let themeStr;
    if (theme && variant) {
      themeStr = `${theme}-${variant}`;
    } else if (theme) {
      themeStr = `${theme}-light`;
    } else if (variant) {
      themeStr = `default-${variant}`;
    }
    STheme.applyTheme(theme, variant, $context);
    localStorage.setItem("s-theme", themeStr);
    const currentTheme = this.getCurrentTheme($context);
    document.dispatchEvent(new CustomEvent("s-theme.change", {
      detail: {
        theme: currentTheme
      }
    }));
    return currentTheme;
  }
  static applyTheme(theme, variant, $context = document.querySelector("html")) {
    __fastdom.mutate(() => {
      __clearTransmations(document.querySelector("html"), {
        timeout: 100
      });
      if (theme && variant) {
        $context.setAttribute("theme", `${theme}-${variant}`);
      } else if (theme) {
        $context.setAttribute("theme", `${theme}-${SSugarConfig.get("theme.variant")}`);
      } else if (variant) {
        $context.setAttribute("theme", `${SSugarConfig.get("theme.theme")}-${variant}`);
      }
    });
  }
  static isDark($context = document.querySelector("html")) {
    const metas = STheme.getThemeMetas($context);
    return metas.variant === "dark";
  }
  static preferDark() {
    return window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
  }
  static setThemeVariant(variant, $context = document.querySelector("html")) {
    return this.setTheme(void 0, variant, $context);
  }
  static init(settings) {
    return __awaiter$k(this, void 0, void 0, function* () {
      const finalSettings = Object.assign({ $context: document.querySelector("html"), theme: void 0, variant: void 0, lod: void 0 }, settings !== null && settings !== void 0 ? settings : {});
      let themeInstance;
      STheme.defaultThemeMetas = {
        theme: finalSettings.theme,
        variant: finalSettings.variant
      };
      themeInstance = this.getCurrentTheme(finalSettings.$context);
      if (!document.env)
        document.env = {};
      if (!document.env.SUGAR)
        document.env.SUGAR = {};
      document.env.SUGAR.theme = themeInstance;
      STheme.applyTheme(themeInstance.theme, themeInstance.variant, finalSettings.$context);
      return themeInstance;
    });
  }
  static ensureIsInited(throwError = true) {
    if (!document.env.SUGAR.theme) {
      if (throwError) {
        throw new Error(`<red>[STheme]</red> You must init your theme using the __STheme.init() static method...`);
      }
      return false;
    }
    return true;
  }
  static getThemeMetas($context = document.querySelector("html")) {
    var _a3, _b2, _c2;
    let defaultTheme = (_a3 = STheme.defaultThemeMetas.theme) !== null && _a3 !== void 0 ? _a3 : SSugarConfig.get("theme.theme"), defaultVariant = (_b2 = STheme.defaultThemeMetas.variant) !== null && _b2 !== void 0 ? _b2 : SSugarConfig.get("theme.variant");
    let theme = defaultTheme, variant = defaultVariant;
    if ($context) {
      const computedStyle = getComputedStyle($context);
      const cssDefinedTheme = computedStyle.getPropertyValue("--s-theme"), cssDefinedVariant = computedStyle.getPropertyValue("--s-theme-variant");
      if (cssDefinedTheme) {
        theme = cssDefinedTheme.trim();
      }
      if (cssDefinedVariant) {
        variant = cssDefinedVariant.trim();
      }
    }
    const name2 = `${theme !== null && theme !== void 0 ? theme : defaultTheme}-${variant !== null && variant !== void 0 ? variant : defaultVariant}`;
    const metas = (_c2 = SSugarConfig.get(`theme.themes.${name2}.metas`)) !== null && _c2 !== void 0 ? _c2 : {};
    return __deepMerge({
      name: name2,
      theme: theme !== null && theme !== void 0 ? theme : defaultTheme,
      variant: variant !== null && variant !== void 0 ? variant : defaultVariant
    }, metas);
  }
  static getCurrentTheme($context = document.querySelector("html")) {
    const themeMetas = STheme.getThemeMetas($context);
    return this.getTheme({
      theme: themeMetas.theme,
      variant: themeMetas.variant
    });
  }
  static applyCurrentColor(color2, $context = document.querySelector("html")) {
    const vars = this.remapCssColor("current", color2);
    for (let [key, value] of Object.entries(vars.properties)) {
      $context.style.setProperty(key, value);
    }
  }
  get lod() {
    return this.state.lod || this.get("lod.defaultLevel");
  }
  setColor(color2, value) {
    this.set(`color.${color2}.color`, value);
  }
  setLod(level, settings) {
    const finalSettings = Object.assign({ $context: document.body }, settings !== null && settings !== void 0 ? settings : {});
    level = parseInt(`${level}`);
    this.state.lod = level;
    this.save();
    for (let i2 = 0; i2 <= 10; i2++) {
      if (i2 > level) {
        finalSettings.$context.classList.remove(`s-lod--${i2}`);
      }
    }
    for (let i2 = 0; i2 <= level; i2++) {
      finalSettings.$context.classList.add("s-lod", `s-lod--${i2}`);
    }
    document.dispatchEvent(new CustomEvent("s-theme.lod.change", {
      detail: {
        level,
        theme: this
      }
    }));
    return this;
  }
  set(dotPath, value) {
    super.set(dotPath, value);
    this.applyState();
    this.save();
    return this;
  }
  whenLod(level) {
    return new Promise((resolve) => {
      if (document.body.classList.contains(`s-lod--${level}`)) {
        return resolve();
      }
    });
  }
  whenLodChange(cb) {
    document.addEventListener("s-theme.lod.change", cb);
    return () => {
      document.removeEventListener("s-theme.lod.change", cb);
    };
  }
  getColor(name2, variant, $context = document.querySelector("html")) {
    const $elm = document.createElement("p");
    $elm.classList.add(`s-bg--${name2}${variant ? `-${variant}` : ""}`);
    const $wrapper = document.createElement("div");
    $wrapper.setAttribute("hidden", "true");
    $wrapper.setAttribute("theme", this.theme);
    $wrapper.setAttribute("variant", this.variant);
    $wrapper.appendChild($elm);
    $context.appendChild($wrapper);
    const style = getComputedStyle($elm);
    const color2 = new SColor(style.backgroundColor);
    $wrapper.remove();
    return color2;
  }
  applyState($context = document.querySelector("html")) {
    const properties2 = SThemeBase.jsConfigObjectToCssProperties(this.getOverridedConfig());
    this._applyOverridedConfigs(properties2, $context);
    if (this.state.lod !== void 0) {
      this.setLod(this.state.lod);
    }
    return this;
  }
  _applyOverridedConfigs(properties2, $context = document.querySelector("html")) {
    if (!$context._sThemeOverridedConfigs) {
      $context._sThemeOverridedConfigs = {};
    }
    if (!$context._sThemeOverridedConfigs[this.id]) {
      $context._sThemeOverridedConfigs[this.id] = document.createElement("style");
      $context._sThemeOverridedConfigs[this.id].setAttribute("id", this.id);
      $context.appendChild($context._sThemeOverridedConfigs[this.id]);
    }
    $context._sThemeOverridedConfigs[this.id].innerHTML = `
            [theme="${this.theme}-${this.variant}"] {
                ${properties2.join("\n")}
            }
        `;
  }
  save() {
    clearTimeout(this._saveTimeout);
    this._saveTimeout = setTimeout(() => {
      localStorage.setItem(`s-theme-${this.theme}`, JSON.stringify(this.state));
      this.emitSavedEvent();
    }, 500);
    return this;
  }
  restore() {
    var _a3;
    let savedState = {};
    try {
      savedState = JSON.parse(
        (_a3 = localStorage.getItem(`s-theme-${this.theme}`)) !== null && _a3 !== void 0 ? _a3 : "{}"
      );
      this.state = savedState !== null && savedState !== void 0 ? savedState : {};
    } catch (e) {
      savedState = {};
    }
    super.restore(savedState.overridedConfigs);
    this.applyState();
    return this;
  }
  clear() {
    localStorage.removeItem(`s-theme-${this.theme}`);
    super.clear();
    this.state = {};
    this.applyState();
    this.constructor.setTheme();
    return this;
  }
}
STheme.defaultThemeMetas = {};
function __debounce(fn2, delay) {
  let timer = null;
  return function() {
    const context = this, args = arguments;
    clearTimeout(timer);
    timer = setTimeout(function() {
      fn2.apply(context, args);
    }, delay);
  };
}
var noop = function() {
};
var _undefined$1 = noop();
var isValue$5 = function(val) {
  return val !== _undefined$1 && val !== null;
};
var isValue$4 = isValue$5;
var forEach$1 = Array.prototype.forEach, create = Object.create;
var process$1 = function(src2, obj2) {
  var key;
  for (key in src2)
    obj2[key] = src2[key];
};
var normalizeOptions = function(opts1) {
  var result2 = create(null);
  forEach$1.call(arguments, function(options) {
    if (!isValue$4(options))
      return;
    process$1(Object(options), result2);
  });
  return result2;
};
var isImplemented$6 = function() {
  var sign2 = Math.sign;
  if (typeof sign2 !== "function")
    return false;
  return sign2(10) === 1 && sign2(-20) === -1;
};
var shim$4;
var hasRequiredShim$4;
function requireShim$4() {
  if (hasRequiredShim$4)
    return shim$4;
  hasRequiredShim$4 = 1;
  shim$4 = function(value) {
    value = Number(value);
    if (isNaN(value) || value === 0)
      return value;
    return value > 0 ? 1 : -1;
  };
  return shim$4;
}
var sign$1 = isImplemented$6() ? Math.sign : requireShim$4();
var sign = sign$1, abs = Math.abs, floor = Math.floor;
var toInteger$1 = function(value) {
  if (isNaN(value))
    return 0;
  value = Number(value);
  if (value === 0 || !isFinite(value))
    return value;
  return sign(value) * floor(abs(value));
};
var toInteger = toInteger$1, max$1 = Math.max;
var toPosInteger = function(value) {
  return max$1(0, toInteger(value));
};
var validCallable = function(fn2) {
  if (typeof fn2 !== "function")
    throw new TypeError(fn2 + " is not a function");
  return fn2;
};
var isValue$3 = isValue$5;
var validValue = function(value) {
  if (!isValue$3(value))
    throw new TypeError("Cannot use null or undefined");
  return value;
};
var custom = { exports: {} };
var isImplemented$5 = function() {
  var assign2 = Object.assign, obj2;
  if (typeof assign2 !== "function")
    return false;
  obj2 = { foo: "raz" };
  assign2(obj2, { bar: "dwa" }, { trzy: "trzy" });
  return obj2.foo + obj2.bar + obj2.trzy === "razdwatrzy";
};
var isImplemented$4;
var hasRequiredIsImplemented$3;
function requireIsImplemented$3() {
  if (hasRequiredIsImplemented$3)
    return isImplemented$4;
  hasRequiredIsImplemented$3 = 1;
  isImplemented$4 = function() {
    try {
      Object.keys("primitive");
      return true;
    } catch (e) {
      return false;
    }
  };
  return isImplemented$4;
}
var shim$3;
var hasRequiredShim$3;
function requireShim$3() {
  if (hasRequiredShim$3)
    return shim$3;
  hasRequiredShim$3 = 1;
  var isValue2 = isValue$5;
  var keys3 = Object.keys;
  shim$3 = function(object) {
    return keys3(isValue2(object) ? Object(object) : object);
  };
  return shim$3;
}
var keys;
var hasRequiredKeys;
function requireKeys() {
  if (hasRequiredKeys)
    return keys;
  hasRequiredKeys = 1;
  keys = requireIsImplemented$3()() ? Object.keys : requireShim$3();
  return keys;
}
var shim$2;
var hasRequiredShim$2;
function requireShim$2() {
  if (hasRequiredShim$2)
    return shim$2;
  hasRequiredShim$2 = 1;
  var keys3 = requireKeys(), value = validValue, max2 = Math.max;
  shim$2 = function(dest, src2) {
    var error2, i2, length = max2(arguments.length, 2), assign2;
    dest = Object(value(dest));
    assign2 = function(key) {
      try {
        dest[key] = src2[key];
      } catch (e) {
        if (!error2)
          error2 = e;
      }
    };
    for (i2 = 1; i2 < length; ++i2) {
      src2 = arguments[i2];
      keys3(src2).forEach(assign2);
    }
    if (error2 !== void 0)
      throw error2;
    return dest;
  };
  return shim$2;
}
var assign$1 = isImplemented$5() ? Object.assign : requireShim$2();
var isValue$2 = isValue$5;
var map = { function: true, object: true };
var isObject$2 = function(value) {
  return isValue$2(value) && map[typeof value] || false;
};
(function(module) {
  var assign2 = assign$1, isObject3 = isObject$2, isValue2 = isValue$5, captureStackTrace = Error.captureStackTrace;
  module.exports = function(message) {
    var err = new Error(message), code3 = arguments[1], ext2 = arguments[2];
    if (!isValue2(ext2)) {
      if (isObject3(code3)) {
        ext2 = code3;
        code3 = null;
      }
    }
    if (isValue2(ext2))
      assign2(err, ext2);
    if (isValue2(code3))
      err.code = code3;
    if (captureStackTrace)
      captureStackTrace(err, module.exports);
    return err;
  };
})(custom);
var test = function(arg1, arg2) {
  return arg2;
};
try {
  Object.defineProperty(test, "length", {
    configurable: true,
    writable: false,
    enumerable: false,
    value: 1
  });
} catch (ignore) {
}
if (test.length === 1)
  ;
var d$2 = { exports: {} };
var _undefined = void 0;
var is$6 = function(value) {
  return value !== _undefined && value !== null;
};
var isValue$1 = is$6;
var possibleTypes = { "object": true, "function": true, "undefined": true };
var is$5 = function(value) {
  if (!isValue$1(value))
    return false;
  return hasOwnProperty.call(possibleTypes, typeof value);
};
var isObject$1 = is$5;
var is$4 = function(value) {
  if (!isObject$1(value))
    return false;
  try {
    if (!value.constructor)
      return false;
    return value.constructor.prototype === value;
  } catch (error2) {
    return false;
  }
};
var isPrototype = is$4;
var is$3 = function(value) {
  if (typeof value !== "function")
    return false;
  if (!hasOwnProperty.call(value, "length"))
    return false;
  try {
    if (typeof value.length !== "number")
      return false;
    if (typeof value.call !== "function")
      return false;
    if (typeof value.apply !== "function")
      return false;
  } catch (error2) {
    return false;
  }
  return !isPrototype(value);
};
var isFunction$2 = is$3;
var classRe = /^\s*class[\s{/}]/, functionToString = Function.prototype.toString;
var is$2 = function(value) {
  if (!isFunction$2(value))
    return false;
  if (classRe.test(functionToString.call(value)))
    return false;
  return true;
};
var str = "razdwatrzy";
var isImplemented$3 = function() {
  if (typeof str.contains !== "function")
    return false;
  return str.contains("dwa") === true && str.contains("foo") === false;
};
var shim$1;
var hasRequiredShim$1;
function requireShim$1() {
  if (hasRequiredShim$1)
    return shim$1;
  hasRequiredShim$1 = 1;
  var indexOf = String.prototype.indexOf;
  shim$1 = function(searchString) {
    return indexOf.call(this, searchString, arguments[1]) > -1;
  };
  return shim$1;
}
var contains$1 = isImplemented$3() ? String.prototype.contains : requireShim$1();
var isValue = is$6, isPlainFunction = is$2, assign = assign$1, normalizeOpts = normalizeOptions, contains = contains$1;
var d$1 = d$2.exports = function(dscr, value) {
  var c, e, w2, options, desc;
  if (arguments.length < 2 || typeof dscr !== "string") {
    options = value;
    value = dscr;
    dscr = null;
  } else {
    options = arguments[2];
  }
  if (isValue(dscr)) {
    c = contains.call(dscr, "c");
    e = contains.call(dscr, "e");
    w2 = contains.call(dscr, "w");
  } else {
    c = w2 = true;
    e = false;
  }
  desc = { value, configurable: c, enumerable: e, writable: w2 };
  return !options ? desc : assign(normalizeOpts(options), desc);
};
d$1.gs = function(dscr, get2, set) {
  var c, e, options, desc;
  if (typeof dscr !== "string") {
    options = set;
    set = get2;
    get2 = dscr;
    dscr = null;
  } else {
    options = arguments[3];
  }
  if (!isValue(get2)) {
    get2 = void 0;
  } else if (!isPlainFunction(get2)) {
    options = get2;
    get2 = set = void 0;
  } else if (!isValue(set)) {
    set = void 0;
  } else if (!isPlainFunction(set)) {
    options = set;
    set = void 0;
  }
  if (isValue(dscr)) {
    c = contains.call(dscr, "c");
    e = contains.call(dscr, "e");
  } else {
    c = true;
    e = false;
  }
  desc = { get: get2, set, configurable: c, enumerable: e };
  return !options ? desc : assign(normalizeOpts(options), desc);
};
var eventEmitter = { exports: {} };
(function(module, exports) {
  var d4 = d$2.exports, callable = validCallable, apply = Function.prototype.apply, call = Function.prototype.call, create2 = Object.create, defineProperty3 = Object.defineProperty, defineProperties2 = Object.defineProperties, hasOwnProperty2 = Object.prototype.hasOwnProperty, descriptor2 = { configurable: true, enumerable: false, writable: true }, on2, once, off, emit, methods, descriptors2, base;
  on2 = function(type, listener) {
    var data2;
    callable(listener);
    if (!hasOwnProperty2.call(this, "__ee__")) {
      data2 = descriptor2.value = create2(null);
      defineProperty3(this, "__ee__", descriptor2);
      descriptor2.value = null;
    } else {
      data2 = this.__ee__;
    }
    if (!data2[type])
      data2[type] = listener;
    else if (typeof data2[type] === "object")
      data2[type].push(listener);
    else
      data2[type] = [data2[type], listener];
    return this;
  };
  once = function(type, listener) {
    var once2, self2;
    callable(listener);
    self2 = this;
    on2.call(this, type, once2 = function() {
      off.call(self2, type, once2);
      apply.call(listener, this, arguments);
    });
    once2.__eeOnceListener__ = listener;
    return this;
  };
  off = function(type, listener) {
    var data2, listeners, candidate, i2;
    callable(listener);
    if (!hasOwnProperty2.call(this, "__ee__"))
      return this;
    data2 = this.__ee__;
    if (!data2[type])
      return this;
    listeners = data2[type];
    if (typeof listeners === "object") {
      for (i2 = 0; candidate = listeners[i2]; ++i2) {
        if (candidate === listener || candidate.__eeOnceListener__ === listener) {
          if (listeners.length === 2)
            data2[type] = listeners[i2 ? 0 : 1];
          else
            listeners.splice(i2, 1);
        }
      }
    } else {
      if (listeners === listener || listeners.__eeOnceListener__ === listener) {
        delete data2[type];
      }
    }
    return this;
  };
  emit = function(type) {
    var i2, l, listener, listeners, args;
    if (!hasOwnProperty2.call(this, "__ee__"))
      return;
    listeners = this.__ee__[type];
    if (!listeners)
      return;
    if (typeof listeners === "object") {
      l = arguments.length;
      args = new Array(l - 1);
      for (i2 = 1; i2 < l; ++i2)
        args[i2 - 1] = arguments[i2];
      listeners = listeners.slice();
      for (i2 = 0; listener = listeners[i2]; ++i2) {
        apply.call(listener, this, args);
      }
    } else {
      switch (arguments.length) {
        case 1:
          call.call(listeners, this);
          break;
        case 2:
          call.call(listeners, this, arguments[1]);
          break;
        case 3:
          call.call(listeners, this, arguments[1], arguments[2]);
          break;
        default:
          l = arguments.length;
          args = new Array(l - 1);
          for (i2 = 1; i2 < l; ++i2) {
            args[i2 - 1] = arguments[i2];
          }
          apply.call(listeners, this, args);
      }
    }
  };
  methods = {
    on: on2,
    once,
    off,
    emit
  };
  descriptors2 = {
    on: d4(on2),
    once: d4(once),
    off: d4(off),
    emit: d4(emit)
  };
  base = defineProperties2({}, descriptors2);
  module.exports = exports = function(o) {
    return o == null ? create2(base) : defineProperties2(Object(o), descriptors2);
  };
  exports.methods = methods;
})(eventEmitter, eventEmitter.exports);
var isImplemented$2;
var hasRequiredIsImplemented$2;
function requireIsImplemented$2() {
  if (hasRequiredIsImplemented$2)
    return isImplemented$2;
  hasRequiredIsImplemented$2 = 1;
  isImplemented$2 = function() {
    var from2 = Array.from, arr, result2;
    if (typeof from2 !== "function")
      return false;
    arr = ["raz", "dwa"];
    result2 = from2(arr);
    return Boolean(result2 && result2 !== arr && result2[1] === "dwa");
  };
  return isImplemented$2;
}
var isImplemented$1;
var hasRequiredIsImplemented$1;
function requireIsImplemented$1() {
  if (hasRequiredIsImplemented$1)
    return isImplemented$1;
  hasRequiredIsImplemented$1 = 1;
  isImplemented$1 = function() {
    if (typeof globalThis !== "object")
      return false;
    if (!globalThis)
      return false;
    return globalThis.Array === Array;
  };
  return isImplemented$1;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation)
    return implementation;
  hasRequiredImplementation = 1;
  var naiveFallback = function() {
    if (typeof self === "object" && self)
      return self;
    if (typeof window === "object" && window)
      return window;
    throw new Error("Unable to resolve global `this`");
  };
  implementation = function() {
    if (this)
      return this;
    try {
      Object.defineProperty(Object.prototype, "__global__", {
        get: function() {
          return this;
        },
        configurable: true
      });
    } catch (error2) {
      return naiveFallback();
    }
    try {
      if (!__global__)
        return naiveFallback();
      return __global__;
    } finally {
      delete Object.prototype.__global__;
    }
  }();
  return implementation;
}
var globalThis_1;
var hasRequiredGlobalThis;
function requireGlobalThis() {
  if (hasRequiredGlobalThis)
    return globalThis_1;
  hasRequiredGlobalThis = 1;
  globalThis_1 = requireIsImplemented$1()() ? globalThis : requireImplementation();
  return globalThis_1;
}
var isImplemented;
var hasRequiredIsImplemented;
function requireIsImplemented() {
  if (hasRequiredIsImplemented)
    return isImplemented;
  hasRequiredIsImplemented = 1;
  var global2 = requireGlobalThis(), validTypes = { object: true, symbol: true };
  isImplemented = function() {
    var Symbol2 = global2.Symbol;
    var symbol;
    if (typeof Symbol2 !== "function")
      return false;
    symbol = Symbol2("test symbol");
    try {
      String(symbol);
    } catch (e) {
      return false;
    }
    if (!validTypes[typeof Symbol2.iterator])
      return false;
    if (!validTypes[typeof Symbol2.toPrimitive])
      return false;
    if (!validTypes[typeof Symbol2.toStringTag])
      return false;
    return true;
  };
  return isImplemented;
}
var isSymbol;
var hasRequiredIsSymbol;
function requireIsSymbol() {
  if (hasRequiredIsSymbol)
    return isSymbol;
  hasRequiredIsSymbol = 1;
  isSymbol = function(value) {
    if (!value)
      return false;
    if (typeof value === "symbol")
      return true;
    if (!value.constructor)
      return false;
    if (value.constructor.name !== "Symbol")
      return false;
    return value[value.constructor.toStringTag] === "Symbol";
  };
  return isSymbol;
}
var validateSymbol;
var hasRequiredValidateSymbol;
function requireValidateSymbol() {
  if (hasRequiredValidateSymbol)
    return validateSymbol;
  hasRequiredValidateSymbol = 1;
  var isSymbol2 = requireIsSymbol();
  validateSymbol = function(value) {
    if (!isSymbol2(value))
      throw new TypeError(value + " is not a symbol");
    return value;
  };
  return validateSymbol;
}
var generateName;
var hasRequiredGenerateName;
function requireGenerateName() {
  if (hasRequiredGenerateName)
    return generateName;
  hasRequiredGenerateName = 1;
  var d4 = d$2.exports;
  var create2 = Object.create, defineProperty3 = Object.defineProperty, objPrototype = Object.prototype;
  var created = create2(null);
  generateName = function(desc) {
    var postfix = 0, name2, ie11BugWorkaround;
    while (created[desc + (postfix || "")])
      ++postfix;
    desc += postfix || "";
    created[desc] = true;
    name2 = "@@" + desc;
    defineProperty3(
      objPrototype,
      name2,
      d4.gs(null, function(value) {
        if (ie11BugWorkaround)
          return;
        ie11BugWorkaround = true;
        defineProperty3(this, name2, d4(value));
        ie11BugWorkaround = false;
      })
    );
    return name2;
  };
  return generateName;
}
var standardSymbols;
var hasRequiredStandardSymbols;
function requireStandardSymbols() {
  if (hasRequiredStandardSymbols)
    return standardSymbols;
  hasRequiredStandardSymbols = 1;
  var d4 = d$2.exports, NativeSymbol = requireGlobalThis().Symbol;
  standardSymbols = function(SymbolPolyfill) {
    return Object.defineProperties(SymbolPolyfill, {
      hasInstance: d4(
        "",
        NativeSymbol && NativeSymbol.hasInstance || SymbolPolyfill("hasInstance")
      ),
      isConcatSpreadable: d4(
        "",
        NativeSymbol && NativeSymbol.isConcatSpreadable || SymbolPolyfill("isConcatSpreadable")
      ),
      iterator: d4("", NativeSymbol && NativeSymbol.iterator || SymbolPolyfill("iterator")),
      match: d4("", NativeSymbol && NativeSymbol.match || SymbolPolyfill("match")),
      replace: d4("", NativeSymbol && NativeSymbol.replace || SymbolPolyfill("replace")),
      search: d4("", NativeSymbol && NativeSymbol.search || SymbolPolyfill("search")),
      species: d4("", NativeSymbol && NativeSymbol.species || SymbolPolyfill("species")),
      split: d4("", NativeSymbol && NativeSymbol.split || SymbolPolyfill("split")),
      toPrimitive: d4(
        "",
        NativeSymbol && NativeSymbol.toPrimitive || SymbolPolyfill("toPrimitive")
      ),
      toStringTag: d4(
        "",
        NativeSymbol && NativeSymbol.toStringTag || SymbolPolyfill("toStringTag")
      ),
      unscopables: d4(
        "",
        NativeSymbol && NativeSymbol.unscopables || SymbolPolyfill("unscopables")
      )
    });
  };
  return standardSymbols;
}
var symbolRegistry;
var hasRequiredSymbolRegistry;
function requireSymbolRegistry() {
  if (hasRequiredSymbolRegistry)
    return symbolRegistry;
  hasRequiredSymbolRegistry = 1;
  var d4 = d$2.exports, validateSymbol2 = requireValidateSymbol();
  var registry = /* @__PURE__ */ Object.create(null);
  symbolRegistry = function(SymbolPolyfill) {
    return Object.defineProperties(SymbolPolyfill, {
      for: d4(function(key) {
        if (registry[key])
          return registry[key];
        return registry[key] = SymbolPolyfill(String(key));
      }),
      keyFor: d4(function(symbol) {
        var key;
        validateSymbol2(symbol);
        for (key in registry) {
          if (registry[key] === symbol)
            return key;
        }
        return void 0;
      })
    });
  };
  return symbolRegistry;
}
var polyfill;
var hasRequiredPolyfill;
function requirePolyfill() {
  if (hasRequiredPolyfill)
    return polyfill;
  hasRequiredPolyfill = 1;
  var d4 = d$2.exports, validateSymbol2 = requireValidateSymbol(), NativeSymbol = requireGlobalThis().Symbol, generateName2 = requireGenerateName(), setupStandardSymbols = requireStandardSymbols(), setupSymbolRegistry = requireSymbolRegistry();
  var create2 = Object.create, defineProperties2 = Object.defineProperties, defineProperty3 = Object.defineProperty;
  var SymbolPolyfill, HiddenSymbol, isNativeSafe;
  if (typeof NativeSymbol === "function") {
    try {
      String(NativeSymbol());
      isNativeSafe = true;
    } catch (ignore) {
    }
  } else {
    NativeSymbol = null;
  }
  HiddenSymbol = function Symbol2(description2) {
    if (this instanceof HiddenSymbol)
      throw new TypeError("Symbol is not a constructor");
    return SymbolPolyfill(description2);
  };
  polyfill = SymbolPolyfill = function Symbol2(description2) {
    var symbol;
    if (this instanceof Symbol2)
      throw new TypeError("Symbol is not a constructor");
    if (isNativeSafe)
      return NativeSymbol(description2);
    symbol = create2(HiddenSymbol.prototype);
    description2 = description2 === void 0 ? "" : String(description2);
    return defineProperties2(symbol, {
      __description__: d4("", description2),
      __name__: d4("", generateName2(description2))
    });
  };
  setupStandardSymbols(SymbolPolyfill);
  setupSymbolRegistry(SymbolPolyfill);
  defineProperties2(HiddenSymbol.prototype, {
    constructor: d4(SymbolPolyfill),
    toString: d4("", function() {
      return this.__name__;
    })
  });
  defineProperties2(SymbolPolyfill.prototype, {
    toString: d4(function() {
      return "Symbol (" + validateSymbol2(this).__description__ + ")";
    }),
    valueOf: d4(function() {
      return validateSymbol2(this);
    })
  });
  defineProperty3(
    SymbolPolyfill.prototype,
    SymbolPolyfill.toPrimitive,
    d4("", function() {
      var symbol = validateSymbol2(this);
      if (typeof symbol === "symbol")
        return symbol;
      return symbol.toString();
    })
  );
  defineProperty3(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d4("c", "Symbol"));
  defineProperty3(
    HiddenSymbol.prototype,
    SymbolPolyfill.toStringTag,
    d4("c", SymbolPolyfill.prototype[SymbolPolyfill.toStringTag])
  );
  defineProperty3(
    HiddenSymbol.prototype,
    SymbolPolyfill.toPrimitive,
    d4("c", SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive])
  );
  return polyfill;
}
var es6Symbol;
var hasRequiredEs6Symbol;
function requireEs6Symbol() {
  if (hasRequiredEs6Symbol)
    return es6Symbol;
  hasRequiredEs6Symbol = 1;
  es6Symbol = requireIsImplemented()() ? requireGlobalThis().Symbol : requirePolyfill();
  return es6Symbol;
}
var isArguments;
var hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments)
    return isArguments;
  hasRequiredIsArguments = 1;
  var objToString = Object.prototype.toString, id2 = objToString.call(function() {
    return arguments;
  }());
  isArguments = function(value) {
    return objToString.call(value) === id2;
  };
  return isArguments;
}
var isFunction$1;
var hasRequiredIsFunction;
function requireIsFunction() {
  if (hasRequiredIsFunction)
    return isFunction$1;
  hasRequiredIsFunction = 1;
  var objToString = Object.prototype.toString, isFunctionStringTag = RegExp.prototype.test.bind(/^[object [A-Za-z0-9]*Function]$/);
  isFunction$1 = function(value) {
    return typeof value === "function" && isFunctionStringTag(objToString.call(value));
  };
  return isFunction$1;
}
var isString$1;
var hasRequiredIsString;
function requireIsString() {
  if (hasRequiredIsString)
    return isString$1;
  hasRequiredIsString = 1;
  var objToString = Object.prototype.toString, id2 = objToString.call("");
  isString$1 = function(value) {
    return typeof value === "string" || value && typeof value === "object" && (value instanceof String || objToString.call(value) === id2) || false;
  };
  return isString$1;
}
var shim;
var hasRequiredShim;
function requireShim() {
  if (hasRequiredShim)
    return shim;
  hasRequiredShim = 1;
  var iteratorSymbol = requireEs6Symbol().iterator, isArguments5 = requireIsArguments(), isFunction2 = requireIsFunction(), toPosInt = toPosInteger, callable = validCallable, validValue$1 = validValue, isValue2 = isValue$5, isString3 = requireIsString(), isArray2 = Array.isArray, call = Function.prototype.call, desc = { configurable: true, enumerable: true, writable: true, value: null }, defineProperty3 = Object.defineProperty;
  shim = function(arrayLike) {
    var mapFn = arguments[1], thisArg = arguments[2], Context, i2, j, arr, length, code3, iterator, result2, getIterator, value;
    arrayLike = Object(validValue$1(arrayLike));
    if (isValue2(mapFn))
      callable(mapFn);
    if (!this || this === Array || !isFunction2(this)) {
      if (!mapFn) {
        if (isArguments5(arrayLike)) {
          length = arrayLike.length;
          if (length !== 1)
            return Array.apply(null, arrayLike);
          arr = new Array(1);
          arr[0] = arrayLike[0];
          return arr;
        }
        if (isArray2(arrayLike)) {
          arr = new Array(length = arrayLike.length);
          for (i2 = 0; i2 < length; ++i2)
            arr[i2] = arrayLike[i2];
          return arr;
        }
      }
      arr = [];
    } else {
      Context = this;
    }
    if (!isArray2(arrayLike)) {
      if ((getIterator = arrayLike[iteratorSymbol]) !== void 0) {
        iterator = callable(getIterator).call(arrayLike);
        if (Context)
          arr = new Context();
        result2 = iterator.next();
        i2 = 0;
        while (!result2.done) {
          value = mapFn ? call.call(mapFn, thisArg, result2.value, i2) : result2.value;
          if (Context) {
            desc.value = value;
            defineProperty3(arr, i2, desc);
          } else {
            arr[i2] = value;
          }
          result2 = iterator.next();
          ++i2;
        }
        length = i2;
      } else if (isString3(arrayLike)) {
        length = arrayLike.length;
        if (Context)
          arr = new Context();
        for (i2 = 0, j = 0; i2 < length; ++i2) {
          value = arrayLike[i2];
          if (i2 + 1 < length) {
            code3 = value.charCodeAt(0);
            if (code3 >= 55296 && code3 <= 56319)
              value += arrayLike[++i2];
          }
          value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
          if (Context) {
            desc.value = value;
            defineProperty3(arr, j, desc);
          } else {
            arr[j] = value;
          }
          ++j;
        }
        length = j;
      }
    }
    if (length === void 0) {
      length = toPosInt(arrayLike.length);
      if (Context)
        arr = new Context(length);
      for (i2 = 0; i2 < length; ++i2) {
        value = mapFn ? call.call(mapFn, thisArg, arrayLike[i2], i2) : arrayLike[i2];
        if (Context) {
          desc.value = value;
          defineProperty3(arr, i2, desc);
        } else {
          arr[i2] = value;
        }
      }
    }
    if (Context) {
      desc.value = null;
      arr.length = length;
    }
    return arr;
  };
  return shim;
}
var from;
var hasRequiredFrom;
function requireFrom() {
  if (hasRequiredFrom)
    return from;
  hasRequiredFrom = 1;
  from = requireIsImplemented$2()() ? Array.from : requireShim();
  return from;
}
requireFrom();
var ee$1 = eventEmitter.exports.methods;
ee$1.on;
ee$1.emit;
class SComponentUtilsDefaultPropsInterface extends SInterface {
  static get _definition() {
    return {
      id: {
        description: "Specify an id for your component",
        type: "String",
        physical: true
      },
      mountWhen: {
        description: "Specify when your component will be mounted",
        type: "String",
        values: triggers,
        default: "direct"
      },
      activeWhen: {
        description: "Specify when your component is active and when it is not",
        type: "String[]",
        values: ["inViewport", "lod"],
        default: ["inViewport", "lod"]
      },
      lod: {
        description: "Specify the minimum lod (level of details) from when this component is active",
        type: "Number"
      },
      adoptStyle: {
        description: "Specify if your component adopt the style of the global DOM. This worts only if you are using a shadowRoot element",
        type: "Boolean",
        default: true
      },
      saveState: {
        description: "Specify if you want to save the state of your component",
        type: "Boolean",
        default: false
      },
      lnf: {
        description: "Specify the lnf (look-and-feel) of your component. This is used by the css to style your component",
        type: "String",
        default: "default",
        physical: true
      },
      responsive: {
        description: 'Specify some responsive properties. A "media" property is required and has to be either a media query, or a media query name defined in the config.themeMedia.queries theme setting',
        type: "Object",
        default: {}
      },
      prefixEvent: {
        description: 'Specify if you want the emitted events to be prefixed by the name of the feature/component like "s-slider.change" or not',
        type: "Boolean",
        default: true
      },
      verbose: {
        description: "Specify if you want this component/feature to log informations about activity or not",
        type: "Boolean",
        default: false
      }
    };
  }
}
class SComponentUtilsSettingsInterface extends SInterface {
  static get _definition() {
    return {
      name: {
        type: "String",
        description: "The name of the component/feature that will be used to generate className, etc..."
      },
      interface: {
        description: "Specify an SInterface class to use as our properties definition",
        type: "SInterface"
      },
      props: {
        description: "Specify a properties object to use as our properties definition",
        type: "Object"
      },
      style: {
        description: "Specify a style string to use as style to inject for our component",
        type: "String"
      },
      defaultProps: {
        description: "Pass an object that act as the default properties value for our component",
        type: "Object"
      },
      useTagNameForClassName: {
        type: "Boolean",
        description: 'Specify if the method "className" will generate a class using the node tagName additionaly to the passed "name" setting',
        default: true
      }
    };
  }
}
var __awaiter$j = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SComponentUtils extends SClass {
  constructor(node, settings) {
    super(__deepMerge(SComponentUtilsSettingsInterface.defaults(), settings !== null && settings !== void 0 ? settings : {}));
    this.fastdom = __fastdom;
    this.state = "pending";
    this.DefaultPropsInterface = SComponentUtilsDefaultPropsInterface;
    this._isInViewport = false;
    this._mediaQueries = {};
    this.node = node;
    const whenInViewportPromise = __whenInViewport(this.node, {
      once: false
    });
    whenInViewportPromise.on("in", () => {
      this._isInViewport = true;
    }).on("out", () => {
      this._isInViewport = false;
    });
    const styleStr = this.settings.style;
    this.injectStyle(styleStr !== null && styleStr !== void 0 ? styleStr : "");
  }
  get props() {
    var _a3, _b2;
    return (_b2 = (_a3 = this._props) !== null && _a3 !== void 0 ? _a3 : this.node.props) !== null && _b2 !== void 0 ? _b2 : SComponentUtilsDefaultPropsInterface.defaults();
  }
  get name() {
    var _a3;
    return (_a3 = this.settings.name) !== null && _a3 !== void 0 ? _a3 : this.node.tagName.toLowerCase();
  }
  static setDefaultProps(selector, props) {
    selector = Array.isArray(selector) ? selector : [selector];
    selector.forEach((sel) => {
      var _a3;
      this._defaultProps[sel] = Object.assign(Object.assign({}, (_a3 = this._defaultProps[sel]) !== null && _a3 !== void 0 ? _a3 : {}), props);
    });
  }
  static getDefaultProps(selector) {
    var _a3, _b2;
    return Object.assign(Object.assign({}, (_a3 = this._defaultProps["*"]) !== null && _a3 !== void 0 ? _a3 : {}), (_b2 = this._defaultProps[selector]) !== null && _b2 !== void 0 ? _b2 : {});
  }
  get componentUtilsSettings() {
    return this.settings.componentUtils;
  }
  setProps(props) {
    this._props = props;
  }
  initProps(props, settings) {
    let finalProps = {}, PropsInterface = this.PropsInterface(settings.interface);
    for (let [prop, definition2] of Object.entries(PropsInterface.definition)) {
      const camelProp = __camelCase(prop), dashProp = __dashCase(prop);
      if (this.node.getAttribute(dashProp) !== null) {
        let rawValue = this.node.getAttribute(dashProp), value = rawValue;
        if (rawValue === null || rawValue.trim() === "") {
          value = true;
        } else {
          value = value;
        }
        finalProps[camelProp] = value;
      } else if (props[camelProp] !== void 0) {
        finalProps[camelProp] = props[camelProp];
      } else {
        finalProps[camelProp] = definition2.default;
      }
    }
    finalProps = PropsInterface.apply(finalProps);
    const _this = this;
    const _props = Object.assign({}, finalProps);
    for (let [prop, value] of Object.entries(finalProps)) {
      Object.defineProperty(finalProps, prop, {
        enumarable: true,
        get() {
          return _props[prop];
        },
        set(value2) {
          if (settings.reflectAttributes) {
            const propDef = PropsInterface.definition[prop];
            if (propDef === null || propDef === void 0 ? void 0 : propDef.physical) {
              __fastdom.mutate(() => {
                if (value2 === false || value2 === void 0 || value2 === null) {
                  _this.node.removeAttribute(__dashCase(prop));
                } else {
                  _this.node.setAttribute(__dashCase(prop), String(value2));
                }
              });
            }
          }
          _props[prop] = value2;
        }
      });
      finalProps[prop] = value;
    }
    return finalProps;
  }
  handleProps(props, settings) {
    const finalSettings = Object.assign({ reflectAttributes: true, responsive: true }, settings !== null && settings !== void 0 ? settings : {});
    props = this.initProps(Object.assign(Object.assign({}, SComponentUtils.getDefaultProps(this.name.toLowerCase())), props), finalSettings);
    if (finalSettings.responsive) {
      this.makePropsResponsive(props);
    }
    this._props = props;
    return props;
  }
  handleState(state, settings) {
    var _a3;
    const finalStateSettings = Object.assign(Object.assign({ id: this.node.id }, (_a3 = this.settings.state) !== null && _a3 !== void 0 ? _a3 : {}), settings !== null && settings !== void 0 ? settings : {});
    Object.defineProperty(state, "preventSave", {
      enumerable: false,
      get() {
        return () => {
        };
      }
    });
    if (finalStateSettings.save && !finalStateSettings.id) {
      console.log("HTMLElement", this.node);
      throw new Error(`To save the state of your component, the HTMLElement must have an id...`);
    }
    let _state;
    if (state.isSState) {
      _state = state;
    } else {
      _state = new SState(Object.assign({}, state), {
        id: finalStateSettings.id,
        save: finalStateSettings.save,
        exclude: ["status"]
      });
    }
    return _state;
  }
  makePropsResponsive(props) {
    var _a3;
    props.responsive = __deepMerge({}, (_a3 = props.responsive) !== null && _a3 !== void 0 ? _a3 : {});
    Object.defineProperty(props, "toResetResponsiveProps", {
      enumerable: false,
      writable: true,
      value: {}
    });
    const $responsives = Array.from(this.node.children).filter(($child) => $child.tagName === "RESPONSIVE");
    if ($responsives.length) {
      $responsives.forEach(($responsive) => {
        const attrs = $responsive.attributes, responsiveProps = {};
        let media;
        Object.keys(attrs).forEach((key) => {
          var _a4, _b2, _c2;
          let value;
          if (((_a4 = attrs[key]) === null || _a4 === void 0 ? void 0 : _a4.nodeValue) !== void 0) {
            if (attrs[key].nodeValue === "")
              value = true;
            else
              value = attrs[key].nodeValue;
          }
          if (!value)
            return;
          const propName = (_c2 = (_b2 = attrs[key]) === null || _b2 === void 0 ? void 0 : _b2.name) !== null && _c2 !== void 0 ? _c2 : key;
          if (propName === "media") {
            media = value;
          } else {
            responsiveProps[__camelCase(propName)] = value;
          }
        });
        if (media) {
          if (!props.responsive[media]) {
            props.responsive[media] = {};
          }
          props.responsive[media] = responsiveProps;
        }
      });
    }
    if (Object.keys(props.responsive).length === 1 && props.responsive.original) {
      return;
    }
    window.addEventListener("resize", __debounce(() => {
      this._applyResponsiveProps(props);
    }, 100));
    this._applyResponsiveProps(props);
  }
  _applyResponsiveProps(props = {}) {
    var _a3;
    let matchedMedia = [];
    const responsiveObj = Object.assign({}, props.responsive);
    for (let [media, responsiveProps] of Object.entries(props.responsive)) {
      let applyProps = function() {
        for (let [key, value] of Object.entries(responsiveProps)) {
          props.toResetResponsiveProps[key] = props[key];
          props[key] = value;
        }
      };
      const queries = STheme.get(`media.queries`);
      media.replace(/(<|>|=|\|)/gm, "");
      if (media === "toResetResponsiveProps") {
        continue;
      }
      if (media.match(/[a-zA-Z0-9<>=]/) && queries[media]) {
        let mediaQuery = this._mediaQueries[media];
        if (!mediaQuery) {
          this._mediaQueries[media] = STheme.buildMediaQuery(media);
          mediaQuery = this._mediaQueries[media];
        }
        if (window.matchMedia(mediaQuery.replace(/^@media\s/, "")).matches) {
          applyProps();
          matchedMedia.push(media);
        }
      } else {
        if (window.matchMedia(media).matches) {
          applyProps();
          matchedMedia.push(media);
        }
      }
    }
    if (!matchedMedia.length) {
      for (let [key, value] of Object.entries((_a3 = props.toResetResponsiveProps) !== null && _a3 !== void 0 ? _a3 : {})) {
        props[key] = value;
        delete props.toResetResponsiveProps[key];
      }
    }
    props.responsive = responsiveObj;
  }
  waitAndExecute(when, callback) {
    return new Promise((resolve, reject) => __awaiter$j(this, void 0, void 0, function* () {
      if (!Array.isArray(when)) {
        when = [when];
      }
      if (this.props.lod !== void 0) {
        yield __when(this.node, `lod:${this.props.lod}`);
      }
      STheme.ensureIsInited();
      yield __when(this.node, when);
      callback === null || callback === void 0 ? void 0 : callback(this.node);
      resolve(this.node);
    }));
  }
  dispatchEvent(eventName, settings) {
    var _a3;
    const finalSettings = Object.assign({ $elm: this.node, bubbles: true, cancelable: true, detail: {} }, settings !== null && settings !== void 0 ? settings : {});
    const componentName = this.name;
    if ((_a3 = this.props) === null || _a3 === void 0 ? void 0 : _a3.prefixEvent) {
      finalSettings.$elm.dispatchEvent(new CustomEvent(`${componentName}.${eventName}`, finalSettings));
    } else {
      finalSettings.$elm.dispatchEvent(new CustomEvent(eventName, Object.assign(Object.assign({}, finalSettings), { detail: Object.assign(Object.assign({}, finalSettings.detail), { eventComponent: componentName }) })));
    }
    finalSettings.$elm.dispatchEvent(new CustomEvent(componentName, Object.assign(Object.assign({}, finalSettings), { detail: Object.assign(Object.assign({}, finalSettings.detail), { eventType: eventName }) })));
  }
  adoptStyleInShadowRoot($shadowRoot, $context) {
    return __adoptStyleInShadowRoot($shadowRoot, $context);
  }
  defaultProps(interf) {
    var _a3, _b2, _c2, _d2;
    if (this._defaultProps)
      return Object.assign({}, this._defaultProps);
    this._defaultProps = Object.assign({}, __deepMerge(
      SComponentUtilsDefaultPropsInterface.defaults(),
      (_a3 = this.settings.defaultProps) !== null && _a3 !== void 0 ? _a3 : {},
      (_b2 = this.constructor._defaultProps["*"]) !== null && _b2 !== void 0 ? _b2 : {},
      (_c2 = this.constructor._defaultProps[this.name]) !== null && _c2 !== void 0 ? _c2 : {},
      (_d2 = interf === null || interf === void 0 ? void 0 : interf.defaults()) !== null && _d2 !== void 0 ? _d2 : {}
    ));
    return this._defaultProps;
  }
  PropsInterface(interf) {
    var _a3, _b2;
    if (this._PropsInterface)
      return this._PropsInterface;
    class PropsInterface extends SInterface {
    }
    PropsInterface.definition = __deepMerge((_a3 = SComponentUtilsDefaultPropsInterface.definition) !== null && _a3 !== void 0 ? _a3 : {}, (_b2 = interf === null || interf === void 0 ? void 0 : interf.definition) !== null && _b2 !== void 0 ? _b2 : {});
    this._PropsInterface = PropsInterface;
    return this._PropsInterface;
  }
  injectStyle(css2, id2 = this.tagName) {
    if (this.constructor._injectedStyles.indexOf(id2) !== -1)
      return;
    this.constructor._injectedStyles.push(id2);
    __injectStyle(css2, {
      id: id2
    });
  }
  exposeApi(apiObj, ctx = this.node) {
    setTimeout(() => {
      let $on = this.node;
      Object.keys(apiObj).forEach((apiFnName) => {
        const apiFn = apiObj[apiFnName].bind(ctx);
        $on[apiFnName] = apiFn;
      });
    });
  }
  className(cls = "", style = "") {
    let clsString = cls.split(" ").map((clsName) => {
      let clses = [];
      if (this.settings.useTagNameForClassName) {
        clses.push(`${this.node.tagName.toLowerCase()}${clsName && !clsName.match(/^(__|-)/) ? "-" : ""}${clsName}`);
      }
      if (this.settings.name && this.node.tagName.toLowerCase() !== this.settings.name) {
        clses.push(`${this.settings.name.toLowerCase()}${clsName && !clsName.match(/^(__|-)/) ? "-" : ""}${clsName}`);
      }
      clses = clses.map((c) => c.replace("---", "--"));
      return clses.join(" ");
    }).join(" ");
    if (style) {
      clsString += ` ${style}`;
    }
    return clsString;
  }
  uniqueClassName(cls = "", style = "") {
    let clsString = cls.split(" ").map((clsName) => {
      const clses = [];
      if (this.settings.name && this.node.tagName.toLowerCase() !== this.settings.name) {
        clses.push(`${this.settings.name.toLowerCase()}${clsName && !clsName.match(/^__/) ? "-" : ""}${clsName}`);
      } else {
        clses.push(`${this.node.tagName.toLowerCase()}${clsName && !clsName.match(/^__/) ? "-" : ""}${clsName}`);
      }
      return clses.join(" ");
    }).join("");
    return clsString;
  }
  isMounted() {
    var _a3;
    return (_a3 = this.node) === null || _a3 === void 0 ? void 0 : _a3.hasAttribute("mounted");
  }
  isInViewport() {
    return this._isInViewport;
  }
  isActive() {
    if (this.props.activeWhen.includes("lod") && this.props.lod !== void 0 && STheme.lod < this.props.lod) {
      return false;
    }
    if (this.props.activeWhen.includes("inViewport") && !this._isInViewport) {
      return false;
    }
    return true;
  }
}
SComponentUtils.fastdom = __fastdom;
SComponentUtils._defaultProps = {};
SComponentUtils._injectedStyles = [];
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const supportsAdoptingStyleSheets = window.ShadowRoot && (window.ShadyCSS === void 0 || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
const constructionToken = Symbol();
const cssTagCache = /* @__PURE__ */ new WeakMap();
class CSSResult {
  constructor(cssText, strings, safeToken) {
    this["_$cssResult$"] = true;
    if (safeToken !== constructionToken) {
      throw new Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    }
    this.cssText = cssText;
    this._strings = strings;
  }
  get styleSheet() {
    let styleSheet = this._styleSheet;
    const strings = this._strings;
    if (supportsAdoptingStyleSheets && styleSheet === void 0) {
      const cacheable = strings !== void 0 && strings.length === 1;
      if (cacheable) {
        styleSheet = cssTagCache.get(strings);
      }
      if (styleSheet === void 0) {
        (this._styleSheet = styleSheet = new CSSStyleSheet()).replaceSync(this.cssText);
        if (cacheable) {
          cssTagCache.set(strings, styleSheet);
        }
      }
    }
    return styleSheet;
  }
  toString() {
    return this.cssText;
  }
}
const textFromCSSResult = (value) => {
  if (value["_$cssResult$"] === true) {
    return value.cssText;
  } else if (typeof value === "number") {
    return value;
  } else {
    throw new Error(`Value passed to 'css' function must be a 'css' function result: ${value}. Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.`);
  }
};
const unsafeCSS = (value) => new CSSResult(typeof value === "string" ? value : String(value), void 0, constructionToken);
const css$1 = (strings, ...values) => {
  const cssText = strings.length === 1 ? strings[0] : values.reduce((acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1], strings[0]);
  return new CSSResult(cssText, strings, constructionToken);
};
const adoptStyles = (renderRoot, styles2) => {
  if (supportsAdoptingStyleSheets) {
    renderRoot.adoptedStyleSheets = styles2.map((s2) => s2 instanceof CSSStyleSheet ? s2 : s2.styleSheet);
  } else {
    styles2.forEach((s2) => {
      const style = document.createElement("style");
      const nonce = window["litNonce"];
      if (nonce !== void 0) {
        style.setAttribute("nonce", nonce);
      }
      style.textContent = s2.cssText;
      renderRoot.appendChild(style);
    });
  }
};
const cssResultFromStyleSheet = (sheet) => {
  let cssText = "";
  for (const rule of sheet.cssRules) {
    cssText += rule.cssText;
  }
  return unsafeCSS(cssText);
};
const getCompatibleStyle = supportsAdoptingStyleSheets ? (s2) => s2 : (s2) => s2 instanceof CSSStyleSheet ? cssResultFromStyleSheet(s2) : s2;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var _a$5, _b$2, _c$2;
var _d$2;
let requestUpdateThenable;
let issueWarning$2;
const trustedTypes$1 = window.trustedTypes;
const emptyStringForBooleanAttribute$1 = trustedTypes$1 ? trustedTypes$1.emptyScript : "";
const polyfillSupport$2 = window.reactiveElementPolyfillSupportDevMode;
{
  const issuedWarnings = (_a$5 = globalThis.litIssuedWarnings) !== null && _a$5 !== void 0 ? _a$5 : globalThis.litIssuedWarnings = /* @__PURE__ */ new Set();
  issueWarning$2 = (code3, warning) => {
    warning += ` See https://lit.dev/msg/${code3} for more information.`;
    if (!issuedWarnings.has(warning)) {
      console.warn(warning);
      issuedWarnings.add(warning);
    }
  };
  issueWarning$2("dev-mode", `Lit is in dev mode. Not recommended for production!`);
  if (((_b$2 = window.ShadyDOM) === null || _b$2 === void 0 ? void 0 : _b$2.inUse) && polyfillSupport$2 === void 0) {
    issueWarning$2("polyfill-support-missing", `Shadow DOM is being polyfilled via \`ShadyDOM\` but the \`polyfill-support\` module has not been loaded.`);
  }
  requestUpdateThenable = (name2) => ({
    then: (onfulfilled, _onrejected) => {
      issueWarning$2("request-update-promise", `The \`requestUpdate\` method should no longer return a Promise but does so on \`${name2}\`. Use \`updateComplete\` instead.`);
      if (onfulfilled !== void 0) {
        onfulfilled(false);
      }
    }
  });
}
const debugLogEvent$1 = (event) => {
  const shouldEmit = window.emitLitDebugLogEvents;
  if (!shouldEmit) {
    return;
  }
  window.dispatchEvent(new CustomEvent("lit-debug", {
    detail: event
  }));
};
const JSCompiler_renameProperty = (prop, _obj) => prop;
const defaultConverter = {
  toAttribute(value, type) {
    switch (type) {
      case Boolean:
        value = value ? emptyStringForBooleanAttribute$1 : null;
        break;
      case Object:
      case Array:
        value = value == null ? value : JSON.stringify(value);
        break;
    }
    return value;
  },
  fromAttribute(value, type) {
    let fromValue = value;
    switch (type) {
      case Boolean:
        fromValue = value !== null;
        break;
      case Number:
        fromValue = value === null ? null : Number(value);
        break;
      case Object:
      case Array:
        try {
          fromValue = JSON.parse(value);
        } catch (e) {
          fromValue = null;
        }
        break;
    }
    return fromValue;
  }
};
const notEqual = (value, old) => {
  return old !== value && (old === old || value === value);
};
const defaultPropertyDeclaration = {
  attribute: true,
  type: String,
  converter: defaultConverter,
  reflect: false,
  hasChanged: notEqual
};
const finalized = "finalized";
class ReactiveElement extends HTMLElement {
  constructor() {
    super();
    this.__instanceProperties = /* @__PURE__ */ new Map();
    this.isUpdatePending = false;
    this.hasUpdated = false;
    this.__reflectingProperty = null;
    this._initialize();
  }
  static addInitializer(initializer) {
    var _a3;
    (_a3 = this._initializers) !== null && _a3 !== void 0 ? _a3 : this._initializers = [];
    this._initializers.push(initializer);
  }
  static get observedAttributes() {
    this.finalize();
    const attributes = [];
    this.elementProperties.forEach((v, p) => {
      const attr = this.__attributeNameForProperty(p, v);
      if (attr !== void 0) {
        this.__attributeToPropertyMap.set(attr, p);
        attributes.push(attr);
      }
    });
    return attributes;
  }
  static createProperty(name2, options = defaultPropertyDeclaration) {
    var _a3;
    if (options.state) {
      options.attribute = false;
    }
    this.finalize();
    this.elementProperties.set(name2, options);
    if (!options.noAccessor && !this.prototype.hasOwnProperty(name2)) {
      const key = typeof name2 === "symbol" ? Symbol() : `__${name2}`;
      const descriptor2 = this.getPropertyDescriptor(name2, key, options);
      if (descriptor2 !== void 0) {
        Object.defineProperty(this.prototype, name2, descriptor2);
        {
          if (!this.hasOwnProperty("__reactivePropertyKeys")) {
            this.__reactivePropertyKeys = new Set((_a3 = this.__reactivePropertyKeys) !== null && _a3 !== void 0 ? _a3 : []);
          }
          this.__reactivePropertyKeys.add(name2);
        }
      }
    }
  }
  static getPropertyDescriptor(name2, key, options) {
    return {
      get() {
        return this[key];
      },
      set(value) {
        const oldValue = this[name2];
        this[key] = value;
        this.requestUpdate(name2, oldValue, options);
      },
      configurable: true,
      enumerable: true
    };
  }
  static getPropertyOptions(name2) {
    return this.elementProperties.get(name2) || defaultPropertyDeclaration;
  }
  static finalize() {
    if (this.hasOwnProperty(finalized)) {
      return false;
    }
    this[finalized] = true;
    const superCtor = Object.getPrototypeOf(this);
    superCtor.finalize();
    this.elementProperties = new Map(superCtor.elementProperties);
    this.__attributeToPropertyMap = /* @__PURE__ */ new Map();
    if (this.hasOwnProperty(JSCompiler_renameProperty("properties"))) {
      const props = this.properties;
      const propKeys = [
        ...Object.getOwnPropertyNames(props),
        ...Object.getOwnPropertySymbols(props)
      ];
      for (const p of propKeys) {
        this.createProperty(p, props[p]);
      }
    }
    this.elementStyles = this.finalizeStyles(this.styles);
    {
      const warnRemovedOrRenamed = (name2, renamed = false) => {
        if (this.prototype.hasOwnProperty(name2)) {
          issueWarning$2(renamed ? "renamed-api" : "removed-api", `\`${name2}\` is implemented on class ${this.name}. It has been ${renamed ? "renamed" : "removed"} in this version of LitElement.`);
        }
      };
      warnRemovedOrRenamed("initialize");
      warnRemovedOrRenamed("requestUpdateInternal");
      warnRemovedOrRenamed("_getUpdateComplete", true);
    }
    return true;
  }
  static finalizeStyles(styles2) {
    const elementStyles = [];
    if (Array.isArray(styles2)) {
      const set = new Set(styles2.flat(Infinity).reverse());
      for (const s2 of set) {
        elementStyles.unshift(getCompatibleStyle(s2));
      }
    } else if (styles2 !== void 0) {
      elementStyles.push(getCompatibleStyle(styles2));
    }
    return elementStyles;
  }
  static __attributeNameForProperty(name2, options) {
    const attribute = options.attribute;
    return attribute === false ? void 0 : typeof attribute === "string" ? attribute : typeof name2 === "string" ? name2.toLowerCase() : void 0;
  }
  _initialize() {
    var _a3;
    this.__updatePromise = new Promise((res) => this.enableUpdating = res);
    this._$changedProperties = /* @__PURE__ */ new Map();
    this.__saveInstanceProperties();
    this.requestUpdate();
    (_a3 = this.constructor._initializers) === null || _a3 === void 0 ? void 0 : _a3.forEach((i2) => i2(this));
  }
  addController(controller) {
    var _a3, _b2;
    ((_a3 = this.__controllers) !== null && _a3 !== void 0 ? _a3 : this.__controllers = []).push(controller);
    if (this.renderRoot !== void 0 && this.isConnected) {
      (_b2 = controller.hostConnected) === null || _b2 === void 0 ? void 0 : _b2.call(controller);
    }
  }
  removeController(controller) {
    var _a3;
    (_a3 = this.__controllers) === null || _a3 === void 0 ? void 0 : _a3.splice(this.__controllers.indexOf(controller) >>> 0, 1);
  }
  __saveInstanceProperties() {
    this.constructor.elementProperties.forEach((_v, p) => {
      if (this.hasOwnProperty(p)) {
        this.__instanceProperties.set(p, this[p]);
        delete this[p];
      }
    });
  }
  createRenderRoot() {
    var _a3;
    const renderRoot = (_a3 = this.shadowRoot) !== null && _a3 !== void 0 ? _a3 : this.attachShadow(this.constructor.shadowRootOptions);
    adoptStyles(renderRoot, this.constructor.elementStyles);
    return renderRoot;
  }
  connectedCallback() {
    var _a3;
    if (this.renderRoot === void 0) {
      this.renderRoot = this.createRenderRoot();
    }
    this.enableUpdating(true);
    (_a3 = this.__controllers) === null || _a3 === void 0 ? void 0 : _a3.forEach((c) => {
      var _a4;
      return (_a4 = c.hostConnected) === null || _a4 === void 0 ? void 0 : _a4.call(c);
    });
  }
  enableUpdating(_requestedUpdate) {
  }
  disconnectedCallback() {
    var _a3;
    (_a3 = this.__controllers) === null || _a3 === void 0 ? void 0 : _a3.forEach((c) => {
      var _a4;
      return (_a4 = c.hostDisconnected) === null || _a4 === void 0 ? void 0 : _a4.call(c);
    });
  }
  attributeChangedCallback(name2, _old, value) {
    this._$attributeToProperty(name2, value);
  }
  __propertyToAttribute(name2, value, options = defaultPropertyDeclaration) {
    var _a3, _b2;
    const attr = this.constructor.__attributeNameForProperty(name2, options);
    if (attr !== void 0 && options.reflect === true) {
      const toAttribute = (_b2 = (_a3 = options.converter) === null || _a3 === void 0 ? void 0 : _a3.toAttribute) !== null && _b2 !== void 0 ? _b2 : defaultConverter.toAttribute;
      const attrValue = toAttribute(value, options.type);
      if (this.constructor.enabledWarnings.indexOf("migration") >= 0 && attrValue === void 0) {
        issueWarning$2("undefined-attribute-value", `The attribute value for the ${name2} property is undefined on element ${this.localName}. The attribute will be removed, but in the previous version of \`ReactiveElement\`, the attribute would not have changed.`);
      }
      this.__reflectingProperty = name2;
      if (attrValue == null) {
        this.removeAttribute(attr);
      } else {
        this.setAttribute(attr, attrValue);
      }
      this.__reflectingProperty = null;
    }
  }
  _$attributeToProperty(name2, value) {
    var _a3, _b2;
    const ctor = this.constructor;
    const propName = ctor.__attributeToPropertyMap.get(name2);
    if (propName !== void 0 && this.__reflectingProperty !== propName) {
      const options = ctor.getPropertyOptions(propName);
      const converter = options.converter;
      const fromAttribute = (_b2 = (_a3 = converter === null || converter === void 0 ? void 0 : converter.fromAttribute) !== null && _a3 !== void 0 ? _a3 : typeof converter === "function" ? converter : null) !== null && _b2 !== void 0 ? _b2 : defaultConverter.fromAttribute;
      this.__reflectingProperty = propName;
      this[propName] = fromAttribute(value, options.type);
      this.__reflectingProperty = null;
    }
  }
  requestUpdate(name2, oldValue, options) {
    let shouldRequestUpdate = true;
    if (name2 !== void 0) {
      options = options || this.constructor.getPropertyOptions(name2);
      const hasChanged = options.hasChanged || notEqual;
      if (hasChanged(this[name2], oldValue)) {
        if (!this._$changedProperties.has(name2)) {
          this._$changedProperties.set(name2, oldValue);
        }
        if (options.reflect === true && this.__reflectingProperty !== name2) {
          if (this.__reflectingProperties === void 0) {
            this.__reflectingProperties = /* @__PURE__ */ new Map();
          }
          this.__reflectingProperties.set(name2, options);
        }
      } else {
        shouldRequestUpdate = false;
      }
    }
    if (!this.isUpdatePending && shouldRequestUpdate) {
      this.__updatePromise = this.__enqueueUpdate();
    }
    return requestUpdateThenable(this.localName);
  }
  async __enqueueUpdate() {
    this.isUpdatePending = true;
    try {
      await this.__updatePromise;
    } catch (e) {
      Promise.reject(e);
    }
    const result2 = this.scheduleUpdate();
    if (result2 != null) {
      await result2;
    }
    return !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var _a3, _b2;
    if (!this.isUpdatePending) {
      return;
    }
    debugLogEvent$1 === null || debugLogEvent$1 === void 0 ? void 0 : debugLogEvent$1({ kind: "update" });
    if (!this.hasUpdated) {
      {
        const shadowedProperties = [];
        (_a3 = this.constructor.__reactivePropertyKeys) === null || _a3 === void 0 ? void 0 : _a3.forEach((p) => {
          var _a4;
          if (this.hasOwnProperty(p) && !((_a4 = this.__instanceProperties) === null || _a4 === void 0 ? void 0 : _a4.has(p))) {
            shadowedProperties.push(p);
          }
        });
        if (shadowedProperties.length) {
          throw new Error(`The following properties on element ${this.localName} will not trigger updates as expected because they are set using class fields: ${shadowedProperties.join(", ")}. Native class fields and some compiled output will overwrite accessors used for detecting changes. See https://lit.dev/msg/class-field-shadowing for more information.`);
        }
      }
    }
    if (this.__instanceProperties) {
      this.__instanceProperties.forEach((v, p) => this[p] = v);
      this.__instanceProperties = void 0;
    }
    let shouldUpdate = false;
    const changedProperties = this._$changedProperties;
    try {
      shouldUpdate = this.shouldUpdate(changedProperties);
      if (shouldUpdate) {
        this.willUpdate(changedProperties);
        (_b2 = this.__controllers) === null || _b2 === void 0 ? void 0 : _b2.forEach((c) => {
          var _a4;
          return (_a4 = c.hostUpdate) === null || _a4 === void 0 ? void 0 : _a4.call(c);
        });
        this.update(changedProperties);
      } else {
        this.__markUpdated();
      }
    } catch (e) {
      shouldUpdate = false;
      this.__markUpdated();
      throw e;
    }
    if (shouldUpdate) {
      this._$didUpdate(changedProperties);
    }
  }
  willUpdate(_changedProperties) {
  }
  _$didUpdate(changedProperties) {
    var _a3;
    (_a3 = this.__controllers) === null || _a3 === void 0 ? void 0 : _a3.forEach((c) => {
      var _a4;
      return (_a4 = c.hostUpdated) === null || _a4 === void 0 ? void 0 : _a4.call(c);
    });
    if (!this.hasUpdated) {
      this.hasUpdated = true;
      this.firstUpdated(changedProperties);
    }
    this.updated(changedProperties);
    if (this.isUpdatePending && this.constructor.enabledWarnings.indexOf("change-in-update") >= 0) {
      issueWarning$2("change-in-update", `Element ${this.localName} scheduled an update (generally because a property was set) after an update completed, causing a new update to be scheduled. This is inefficient and should be avoided unless the next update can only be scheduled as a side effect of the previous update.`);
    }
  }
  __markUpdated() {
    this._$changedProperties = /* @__PURE__ */ new Map();
    this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this.__updatePromise;
  }
  shouldUpdate(_changedProperties) {
    return true;
  }
  update(_changedProperties) {
    if (this.__reflectingProperties !== void 0) {
      this.__reflectingProperties.forEach((v, k2) => this.__propertyToAttribute(k2, this[k2], v));
      this.__reflectingProperties = void 0;
    }
    this.__markUpdated();
  }
  updated(_changedProperties) {
  }
  firstUpdated(_changedProperties) {
  }
}
_d$2 = finalized;
ReactiveElement[_d$2] = true;
ReactiveElement.elementProperties = /* @__PURE__ */ new Map();
ReactiveElement.elementStyles = [];
ReactiveElement.shadowRootOptions = { mode: "open" };
polyfillSupport$2 === null || polyfillSupport$2 === void 0 ? void 0 : polyfillSupport$2({ ReactiveElement });
{
  ReactiveElement.enabledWarnings = ["change-in-update"];
  const ensureOwnWarnings = function(ctor) {
    if (!ctor.hasOwnProperty(JSCompiler_renameProperty("enabledWarnings"))) {
      ctor.enabledWarnings = ctor.enabledWarnings.slice();
    }
  };
  ReactiveElement.enableWarning = function(warning) {
    ensureOwnWarnings(this);
    if (this.enabledWarnings.indexOf(warning) < 0) {
      this.enabledWarnings.push(warning);
    }
  };
  ReactiveElement.disableWarning = function(warning) {
    ensureOwnWarnings(this);
    const i2 = this.enabledWarnings.indexOf(warning);
    if (i2 >= 0) {
      this.enabledWarnings.splice(i2, 1);
    }
  };
}
((_c$2 = globalThis.reactiveElementVersions) !== null && _c$2 !== void 0 ? _c$2 : globalThis.reactiveElementVersions = []).push("1.3.4");
if (globalThis.reactiveElementVersions.length > 1) {
  issueWarning$2("multiple-versions", `Multiple versions of Lit loaded. Loading multiple versions is not recommended.`);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var _a$4, _b$1, _c$1, _d$1;
const debugLogEvent = (event) => {
  const shouldEmit = window.emitLitDebugLogEvents;
  if (!shouldEmit) {
    return;
  }
  window.dispatchEvent(new CustomEvent("lit-debug", {
    detail: event
  }));
};
let debugLogRenderId = 0;
let issueWarning$1;
{
  (_a$4 = globalThis.litIssuedWarnings) !== null && _a$4 !== void 0 ? _a$4 : globalThis.litIssuedWarnings = /* @__PURE__ */ new Set();
  issueWarning$1 = (code3, warning) => {
    warning += code3 ? ` See https://lit.dev/msg/${code3} for more information.` : "";
    if (!globalThis.litIssuedWarnings.has(warning)) {
      console.warn(warning);
      globalThis.litIssuedWarnings.add(warning);
    }
  };
  issueWarning$1("dev-mode", `Lit is in dev mode. Not recommended for production!`);
}
const wrap = ((_b$1 = window.ShadyDOM) === null || _b$1 === void 0 ? void 0 : _b$1.inUse) && ((_c$1 = window.ShadyDOM) === null || _c$1 === void 0 ? void 0 : _c$1.noPatch) === true ? window.ShadyDOM.wrap : (node) => node;
const trustedTypes = globalThis.trustedTypes;
const policy = trustedTypes ? trustedTypes.createPolicy("lit-html", {
  createHTML: (s2) => s2
}) : void 0;
const identityFunction = (value) => value;
const noopSanitizer = (_node, _name, _type) => identityFunction;
const setSanitizer = (newSanitizer) => {
  if (sanitizerFactoryInternal !== noopSanitizer) {
    throw new Error(`Attempted to overwrite existing lit-html security policy. setSanitizeDOMValueFactory should be called at most once.`);
  }
  sanitizerFactoryInternal = newSanitizer;
};
const _testOnlyClearSanitizerFactoryDoNotCallOrElse = () => {
  sanitizerFactoryInternal = noopSanitizer;
};
const createSanitizer = (node, name2, type) => {
  return sanitizerFactoryInternal(node, name2, type);
};
const boundAttributeSuffix = "$lit$";
const marker = `lit$${String(Math.random()).slice(9)}$`;
const markerMatch = "?" + marker;
const nodeMarker = `<${markerMatch}>`;
const d = document;
const createMarker = (v = "") => d.createComment(v);
const isPrimitive = (value) => value === null || typeof value != "object" && typeof value != "function";
const isArray$1 = Array.isArray;
const isIterable = (value) => isArray$1(value) || typeof (value === null || value === void 0 ? void 0 : value[Symbol.iterator]) === "function";
const SPACE_CHAR = `[ 	
\f\r]`;
const ATTR_VALUE_CHAR = `[^ 	
\f\r"'\`<>=]`;
const NAME_CHAR = `[^\\s"'>=/]`;
const textEndRegex = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
const COMMENT_START = 1;
const TAG_NAME = 2;
const DYNAMIC_TAG_NAME = 3;
const commentEndRegex = /-->/g;
const comment2EndRegex = />/g;
const tagEndRegex = new RegExp(`>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|("|')|))|$)`, "g");
const ENTIRE_MATCH = 0;
const ATTRIBUTE_NAME = 1;
const SPACES_AND_EQUALS = 2;
const QUOTE_CHAR = 3;
const singleQuoteAttrEndRegex = /'/g;
const doubleQuoteAttrEndRegex = /"/g;
const rawTextElement = /^(?:script|style|textarea|title)$/i;
const HTML_RESULT$1 = 1;
const SVG_RESULT = 2;
const ATTRIBUTE_PART = 1;
const CHILD_PART = 2;
const PROPERTY_PART = 3;
const BOOLEAN_ATTRIBUTE_PART = 4;
const EVENT_PART = 5;
const ELEMENT_PART = 6;
const COMMENT_PART = 7;
const tag = (type) => (strings, ...values) => {
  if (strings.some((s2) => s2 === void 0)) {
    console.warn("Some template strings are undefined.\nThis is probably caused by illegal octal escape sequences.");
  }
  return {
    ["_$litType$"]: type,
    strings,
    values
  };
};
const html = tag(HTML_RESULT$1);
const noChange = Symbol.for("lit-noChange");
const nothing = Symbol.for("lit-nothing");
const templateCache = /* @__PURE__ */ new WeakMap();
const render = (value, container, options) => {
  var _a3, _b2;
  if (container == null) {
    throw new TypeError(`The container to render into may not be ${container}`);
  }
  const renderId = debugLogRenderId++;
  const partOwnerNode = (_a3 = options === null || options === void 0 ? void 0 : options.renderBefore) !== null && _a3 !== void 0 ? _a3 : container;
  let part = partOwnerNode["_$litPart$"];
  debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
    kind: "begin render",
    id: renderId,
    value,
    container,
    options,
    part
  });
  if (part === void 0) {
    const endNode = (_b2 = options === null || options === void 0 ? void 0 : options.renderBefore) !== null && _b2 !== void 0 ? _b2 : null;
    partOwnerNode["_$litPart$"] = part = new ChildPart(container.insertBefore(createMarker(), endNode), endNode, void 0, options !== null && options !== void 0 ? options : {});
  }
  part._$setValue(value);
  debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
    kind: "end render",
    id: renderId,
    value,
    container,
    options,
    part
  });
  return part;
};
{
  render.setSanitizer = setSanitizer;
  render.createSanitizer = createSanitizer;
  {
    render._testOnlyClearSanitizerFactoryDoNotCallOrElse = _testOnlyClearSanitizerFactoryDoNotCallOrElse;
  }
}
const walker = d.createTreeWalker(d, 129, null, false);
let sanitizerFactoryInternal = noopSanitizer;
const getTemplateHtml = (strings, type) => {
  const l = strings.length - 1;
  const attrNames = [];
  let html2 = type === SVG_RESULT ? "<svg>" : "";
  let rawTextEndRegex;
  let regex2 = textEndRegex;
  for (let i2 = 0; i2 < l; i2++) {
    const s2 = strings[i2];
    let attrNameEndIndex = -1;
    let attrName;
    let lastIndex = 0;
    let match5;
    while (lastIndex < s2.length) {
      regex2.lastIndex = lastIndex;
      match5 = regex2.exec(s2);
      if (match5 === null) {
        break;
      }
      lastIndex = regex2.lastIndex;
      if (regex2 === textEndRegex) {
        if (match5[COMMENT_START] === "!--") {
          regex2 = commentEndRegex;
        } else if (match5[COMMENT_START] !== void 0) {
          regex2 = comment2EndRegex;
        } else if (match5[TAG_NAME] !== void 0) {
          if (rawTextElement.test(match5[TAG_NAME])) {
            rawTextEndRegex = new RegExp(`</${match5[TAG_NAME]}`, "g");
          }
          regex2 = tagEndRegex;
        } else if (match5[DYNAMIC_TAG_NAME] !== void 0) {
          {
            throw new Error("Bindings in tag names are not supported. Please use static templates instead. See https://lit.dev/docs/templates/expressions/#static-expressions");
          }
        }
      } else if (regex2 === tagEndRegex) {
        if (match5[ENTIRE_MATCH] === ">") {
          regex2 = rawTextEndRegex !== null && rawTextEndRegex !== void 0 ? rawTextEndRegex : textEndRegex;
          attrNameEndIndex = -1;
        } else if (match5[ATTRIBUTE_NAME] === void 0) {
          attrNameEndIndex = -2;
        } else {
          attrNameEndIndex = regex2.lastIndex - match5[SPACES_AND_EQUALS].length;
          attrName = match5[ATTRIBUTE_NAME];
          regex2 = match5[QUOTE_CHAR] === void 0 ? tagEndRegex : match5[QUOTE_CHAR] === '"' ? doubleQuoteAttrEndRegex : singleQuoteAttrEndRegex;
        }
      } else if (regex2 === doubleQuoteAttrEndRegex || regex2 === singleQuoteAttrEndRegex) {
        regex2 = tagEndRegex;
      } else if (regex2 === commentEndRegex || regex2 === comment2EndRegex) {
        regex2 = textEndRegex;
      } else {
        regex2 = tagEndRegex;
        rawTextEndRegex = void 0;
      }
    }
    {
      console.assert(attrNameEndIndex === -1 || regex2 === tagEndRegex || regex2 === singleQuoteAttrEndRegex || regex2 === doubleQuoteAttrEndRegex, "unexpected parse state B");
    }
    const end = regex2 === tagEndRegex && strings[i2 + 1].startsWith("/>") ? " " : "";
    html2 += regex2 === textEndRegex ? s2 + nodeMarker : attrNameEndIndex >= 0 ? (attrNames.push(attrName), s2.slice(0, attrNameEndIndex) + boundAttributeSuffix + s2.slice(attrNameEndIndex)) + marker + end : s2 + marker + (attrNameEndIndex === -2 ? (attrNames.push(void 0), i2) : end);
  }
  const htmlResult = html2 + (strings[l] || "<?>") + (type === SVG_RESULT ? "</svg>" : "");
  if (!Array.isArray(strings) || !strings.hasOwnProperty("raw")) {
    let message = "invalid template strings array";
    {
      message = `
          Internal Error: expected template strings to be an array
          with a 'raw' field. Faking a template strings array by
          calling html or svg like an ordinary function is effectively
          the same as calling unsafeHtml and can lead to major security
          issues, e.g. opening your code up to XSS attacks.

          If you're using the html or svg tagged template functions normally
          and and still seeing this error, please file a bug at
          https://github.com/lit/lit/issues/new?template=bug_report.md
          and include information about your build tooling, if any.
        `.trim().replace(/\n */g, "\n");
    }
    throw new Error(message);
  }
  return [
    policy !== void 0 ? policy.createHTML(htmlResult) : htmlResult,
    attrNames
  ];
};
class Template {
  constructor({ strings, ["_$litType$"]: type }, options) {
    this.parts = [];
    let node;
    let nodeIndex = 0;
    let attrNameIndex = 0;
    const partCount = strings.length - 1;
    const parts = this.parts;
    const [html2, attrNames] = getTemplateHtml(strings, type);
    this.el = Template.createElement(html2, options);
    walker.currentNode = this.el.content;
    if (type === SVG_RESULT) {
      const content = this.el.content;
      const svgElement = content.firstChild;
      svgElement.remove();
      content.append(...svgElement.childNodes);
    }
    while ((node = walker.nextNode()) !== null && parts.length < partCount) {
      if (node.nodeType === 1) {
        {
          const tag2 = node.localName;
          if (/^(?:textarea|template)$/i.test(tag2) && node.innerHTML.includes(marker)) {
            const m2 = `Expressions are not supported inside \`${tag2}\` elements. See https://lit.dev/msg/expression-in-${tag2} for more information.`;
            if (tag2 === "template") {
              throw new Error(m2);
            } else
              issueWarning$1("", m2);
          }
        }
        if (node.hasAttributes()) {
          const attrsToRemove = [];
          for (const name2 of node.getAttributeNames()) {
            if (name2.endsWith(boundAttributeSuffix) || name2.startsWith(marker)) {
              const realName = attrNames[attrNameIndex++];
              attrsToRemove.push(name2);
              if (realName !== void 0) {
                const value = node.getAttribute(realName.toLowerCase() + boundAttributeSuffix);
                const statics = value.split(marker);
                const m2 = /([.?@])?(.*)/.exec(realName);
                parts.push({
                  type: ATTRIBUTE_PART,
                  index: nodeIndex,
                  name: m2[2],
                  strings: statics,
                  ctor: m2[1] === "." ? PropertyPart : m2[1] === "?" ? BooleanAttributePart : m2[1] === "@" ? EventPart : AttributePart
                });
              } else {
                parts.push({
                  type: ELEMENT_PART,
                  index: nodeIndex
                });
              }
            }
          }
          for (const name2 of attrsToRemove) {
            node.removeAttribute(name2);
          }
        }
        if (rawTextElement.test(node.tagName)) {
          const strings2 = node.textContent.split(marker);
          const lastIndex = strings2.length - 1;
          if (lastIndex > 0) {
            node.textContent = trustedTypes ? trustedTypes.emptyScript : "";
            for (let i2 = 0; i2 < lastIndex; i2++) {
              node.append(strings2[i2], createMarker());
              walker.nextNode();
              parts.push({ type: CHILD_PART, index: ++nodeIndex });
            }
            node.append(strings2[lastIndex], createMarker());
          }
        }
      } else if (node.nodeType === 8) {
        const data2 = node.data;
        if (data2 === markerMatch) {
          parts.push({ type: CHILD_PART, index: nodeIndex });
        } else {
          let i2 = -1;
          while ((i2 = node.data.indexOf(marker, i2 + 1)) !== -1) {
            parts.push({ type: COMMENT_PART, index: nodeIndex });
            i2 += marker.length - 1;
          }
        }
      }
      nodeIndex++;
    }
    debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
      kind: "template prep",
      template: this,
      clonableTemplate: this.el,
      parts: this.parts,
      strings
    });
  }
  static createElement(html2, _options) {
    const el2 = d.createElement("template");
    el2.innerHTML = html2;
    return el2;
  }
}
function resolveDirective(part, value, parent = part, attributeIndex) {
  var _a3, _b2, _c2;
  var _d2;
  if (value === noChange) {
    return value;
  }
  let currentDirective = attributeIndex !== void 0 ? (_a3 = parent.__directives) === null || _a3 === void 0 ? void 0 : _a3[attributeIndex] : parent.__directive;
  const nextDirectiveConstructor = isPrimitive(value) ? void 0 : value["_$litDirective$"];
  if ((currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective.constructor) !== nextDirectiveConstructor) {
    (_b2 = currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective["_$notifyDirectiveConnectionChanged"]) === null || _b2 === void 0 ? void 0 : _b2.call(currentDirective, false);
    if (nextDirectiveConstructor === void 0) {
      currentDirective = void 0;
    } else {
      currentDirective = new nextDirectiveConstructor(part);
      currentDirective._$initialize(part, parent, attributeIndex);
    }
    if (attributeIndex !== void 0) {
      ((_c2 = (_d2 = parent).__directives) !== null && _c2 !== void 0 ? _c2 : _d2.__directives = [])[attributeIndex] = currentDirective;
    } else {
      parent.__directive = currentDirective;
    }
  }
  if (currentDirective !== void 0) {
    value = resolveDirective(part, currentDirective._$resolve(part, value.values), currentDirective, attributeIndex);
  }
  return value;
}
class TemplateInstance {
  constructor(template2, parent) {
    this._parts = [];
    this._$disconnectableChildren = void 0;
    this._$template = template2;
    this._$parent = parent;
  }
  get parentNode() {
    return this._$parent.parentNode;
  }
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _clone(options) {
    var _a3;
    const { el: { content }, parts } = this._$template;
    const fragment = ((_a3 = options === null || options === void 0 ? void 0 : options.creationScope) !== null && _a3 !== void 0 ? _a3 : d).importNode(content, true);
    walker.currentNode = fragment;
    let node = walker.nextNode();
    let nodeIndex = 0;
    let partIndex = 0;
    let templatePart = parts[0];
    while (templatePart !== void 0) {
      if (nodeIndex === templatePart.index) {
        let part;
        if (templatePart.type === CHILD_PART) {
          part = new ChildPart(node, node.nextSibling, this, options);
        } else if (templatePart.type === ATTRIBUTE_PART) {
          part = new templatePart.ctor(node, templatePart.name, templatePart.strings, this, options);
        } else if (templatePart.type === ELEMENT_PART) {
          part = new ElementPart(node, this, options);
        }
        this._parts.push(part);
        templatePart = parts[++partIndex];
      }
      if (nodeIndex !== (templatePart === null || templatePart === void 0 ? void 0 : templatePart.index)) {
        node = walker.nextNode();
        nodeIndex++;
      }
    }
    return fragment;
  }
  _update(values) {
    let i2 = 0;
    for (const part of this._parts) {
      if (part !== void 0) {
        debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
          kind: "set part",
          part,
          value: values[i2],
          valueIndex: i2,
          values,
          templateInstance: this
        });
        if (part.strings !== void 0) {
          part._$setValue(values, part, i2);
          i2 += part.strings.length - 2;
        } else {
          part._$setValue(values[i2]);
        }
      }
      i2++;
    }
  }
}
class ChildPart {
  constructor(startNode, endNode, parent, options) {
    var _a3;
    this.type = CHILD_PART;
    this._$committedValue = nothing;
    this._$disconnectableChildren = void 0;
    this._$startNode = startNode;
    this._$endNode = endNode;
    this._$parent = parent;
    this.options = options;
    this.__isConnected = (_a3 = options === null || options === void 0 ? void 0 : options.isConnected) !== null && _a3 !== void 0 ? _a3 : true;
    {
      this._textSanitizer = void 0;
    }
  }
  get _$isConnected() {
    var _a3, _b2;
    return (_b2 = (_a3 = this._$parent) === null || _a3 === void 0 ? void 0 : _a3._$isConnected) !== null && _b2 !== void 0 ? _b2 : this.__isConnected;
  }
  get parentNode() {
    let parentNode = wrap(this._$startNode).parentNode;
    const parent = this._$parent;
    if (parent !== void 0 && parentNode.nodeType === 11) {
      parentNode = parent.parentNode;
    }
    return parentNode;
  }
  get startNode() {
    return this._$startNode;
  }
  get endNode() {
    return this._$endNode;
  }
  _$setValue(value, directiveParent = this) {
    if (this.parentNode === null) {
      throw new Error(`This \`ChildPart\` has no \`parentNode\` and therefore cannot accept a value. This likely means the element containing the part was manipulated in an unsupported way outside of Lit's control such that the part's marker nodes were ejected from DOM. For example, setting the element's \`innerHTML\` or \`textContent\` can do this.`);
    }
    value = resolveDirective(this, value, directiveParent);
    if (isPrimitive(value)) {
      if (value === nothing || value == null || value === "") {
        if (this._$committedValue !== nothing) {
          debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
            kind: "commit nothing to child",
            start: this._$startNode,
            end: this._$endNode,
            parent: this._$parent,
            options: this.options
          });
          this._$clear();
        }
        this._$committedValue = nothing;
      } else if (value !== this._$committedValue && value !== noChange) {
        this._commitText(value);
      }
    } else if (value["_$litType$"] !== void 0) {
      this._commitTemplateResult(value);
    } else if (value.nodeType !== void 0) {
      this._commitNode(value);
    } else if (isIterable(value)) {
      this._commitIterable(value);
    } else {
      this._commitText(value);
    }
  }
  _insert(node, ref = this._$endNode) {
    return wrap(wrap(this._$startNode).parentNode).insertBefore(node, ref);
  }
  _commitNode(value) {
    var _a3;
    if (this._$committedValue !== value) {
      this._$clear();
      if (sanitizerFactoryInternal !== noopSanitizer) {
        const parentNodeName = (_a3 = this._$startNode.parentNode) === null || _a3 === void 0 ? void 0 : _a3.nodeName;
        if (parentNodeName === "STYLE" || parentNodeName === "SCRIPT") {
          let message = "Forbidden";
          {
            if (parentNodeName === "STYLE") {
              message = `Lit does not support binding inside style nodes. This is a security risk, as style injection attacks can exfiltrate data and spoof UIs. Consider instead using css\`...\` literals to compose styles, and make do dynamic styling with css custom properties, ::parts, <slot>s, and by mutating the DOM rather than stylesheets.`;
            } else {
              message = `Lit does not support binding inside script nodes. This is a security risk, as it could allow arbitrary code execution.`;
            }
          }
          throw new Error(message);
        }
      }
      debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
        kind: "commit node",
        start: this._$startNode,
        parent: this._$parent,
        value,
        options: this.options
      });
      this._$committedValue = this._insert(value);
    }
  }
  _commitText(value) {
    if (this._$committedValue !== nothing && isPrimitive(this._$committedValue)) {
      const node = wrap(this._$startNode).nextSibling;
      {
        if (this._textSanitizer === void 0) {
          this._textSanitizer = createSanitizer(node, "data", "property");
        }
        value = this._textSanitizer(value);
      }
      debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
        kind: "commit text",
        node,
        value,
        options: this.options
      });
      node.data = value;
    } else {
      {
        const textNode = document.createTextNode("");
        this._commitNode(textNode);
        if (this._textSanitizer === void 0) {
          this._textSanitizer = createSanitizer(textNode, "data", "property");
        }
        value = this._textSanitizer(value);
        debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
          kind: "commit text",
          node: textNode,
          value,
          options: this.options
        });
        textNode.data = value;
      }
    }
    this._$committedValue = value;
  }
  _commitTemplateResult(result2) {
    var _a3;
    const { values, ["_$litType$"]: type } = result2;
    const template2 = typeof type === "number" ? this._$getTemplate(result2) : (type.el === void 0 && (type.el = Template.createElement(type.h, this.options)), type);
    if (((_a3 = this._$committedValue) === null || _a3 === void 0 ? void 0 : _a3._$template) === template2) {
      debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
        kind: "template updating",
        template: template2,
        instance: this._$committedValue,
        parts: this._$committedValue._parts,
        options: this.options,
        values
      });
      this._$committedValue._update(values);
    } else {
      const instance = new TemplateInstance(template2, this);
      const fragment = instance._clone(this.options);
      debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
        kind: "template instantiated",
        template: template2,
        instance,
        parts: instance._parts,
        options: this.options,
        fragment,
        values
      });
      instance._update(values);
      debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
        kind: "template instantiated and updated",
        template: template2,
        instance,
        parts: instance._parts,
        options: this.options,
        fragment,
        values
      });
      this._commitNode(fragment);
      this._$committedValue = instance;
    }
  }
  _$getTemplate(result2) {
    let template2 = templateCache.get(result2.strings);
    if (template2 === void 0) {
      templateCache.set(result2.strings, template2 = new Template(result2));
    }
    return template2;
  }
  _commitIterable(value) {
    if (!isArray$1(this._$committedValue)) {
      this._$committedValue = [];
      this._$clear();
    }
    const itemParts = this._$committedValue;
    let partIndex = 0;
    let itemPart;
    for (const item of value) {
      if (partIndex === itemParts.length) {
        itemParts.push(itemPart = new ChildPart(this._insert(createMarker()), this._insert(createMarker()), this, this.options));
      } else {
        itemPart = itemParts[partIndex];
      }
      itemPart._$setValue(item);
      partIndex++;
    }
    if (partIndex < itemParts.length) {
      this._$clear(itemPart && wrap(itemPart._$endNode).nextSibling, partIndex);
      itemParts.length = partIndex;
    }
  }
  _$clear(start = wrap(this._$startNode).nextSibling, from2) {
    var _a3;
    (_a3 = this._$notifyConnectionChanged) === null || _a3 === void 0 ? void 0 : _a3.call(this, false, true, from2);
    while (start && start !== this._$endNode) {
      const n = wrap(start).nextSibling;
      wrap(start).remove();
      start = n;
    }
  }
  setConnected(isConnected) {
    var _a3;
    if (this._$parent === void 0) {
      this.__isConnected = isConnected;
      (_a3 = this._$notifyConnectionChanged) === null || _a3 === void 0 ? void 0 : _a3.call(this, isConnected);
    } else {
      throw new Error("part.setConnected() may only be called on a RootPart returned from render().");
    }
  }
}
class AttributePart {
  constructor(element, name2, strings, parent, options) {
    this.type = ATTRIBUTE_PART;
    this._$committedValue = nothing;
    this._$disconnectableChildren = void 0;
    this.element = element;
    this.name = name2;
    this._$parent = parent;
    this.options = options;
    if (strings.length > 2 || strings[0] !== "" || strings[1] !== "") {
      this._$committedValue = new Array(strings.length - 1).fill(new String());
      this.strings = strings;
    } else {
      this._$committedValue = nothing;
    }
    {
      this._sanitizer = void 0;
    }
  }
  get tagName() {
    return this.element.tagName;
  }
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _$setValue(value, directiveParent = this, valueIndex, noCommit) {
    const strings = this.strings;
    let change = false;
    if (strings === void 0) {
      value = resolveDirective(this, value, directiveParent, 0);
      change = !isPrimitive(value) || value !== this._$committedValue && value !== noChange;
      if (change) {
        this._$committedValue = value;
      }
    } else {
      const values = value;
      value = strings[0];
      let i2, v;
      for (i2 = 0; i2 < strings.length - 1; i2++) {
        v = resolveDirective(this, values[valueIndex + i2], directiveParent, i2);
        if (v === noChange) {
          v = this._$committedValue[i2];
        }
        change || (change = !isPrimitive(v) || v !== this._$committedValue[i2]);
        if (v === nothing) {
          value = nothing;
        } else if (value !== nothing) {
          value += (v !== null && v !== void 0 ? v : "") + strings[i2 + 1];
        }
        this._$committedValue[i2] = v;
      }
    }
    if (change && !noCommit) {
      this._commitValue(value);
    }
  }
  _commitValue(value) {
    if (value === nothing) {
      wrap(this.element).removeAttribute(this.name);
    } else {
      {
        if (this._sanitizer === void 0) {
          this._sanitizer = sanitizerFactoryInternal(this.element, this.name, "attribute");
        }
        value = this._sanitizer(value !== null && value !== void 0 ? value : "");
      }
      debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
        kind: "commit attribute",
        element: this.element,
        name: this.name,
        value,
        options: this.options
      });
      wrap(this.element).setAttribute(this.name, value !== null && value !== void 0 ? value : "");
    }
  }
}
class PropertyPart extends AttributePart {
  constructor() {
    super(...arguments);
    this.type = PROPERTY_PART;
  }
  _commitValue(value) {
    {
      if (this._sanitizer === void 0) {
        this._sanitizer = sanitizerFactoryInternal(this.element, this.name, "property");
      }
      value = this._sanitizer(value);
    }
    debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
      kind: "commit property",
      element: this.element,
      name: this.name,
      value,
      options: this.options
    });
    this.element[this.name] = value === nothing ? void 0 : value;
  }
}
const emptyStringForBooleanAttribute = trustedTypes ? trustedTypes.emptyScript : "";
class BooleanAttributePart extends AttributePart {
  constructor() {
    super(...arguments);
    this.type = BOOLEAN_ATTRIBUTE_PART;
  }
  _commitValue(value) {
    debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
      kind: "commit boolean attribute",
      element: this.element,
      name: this.name,
      value: !!(value && value !== nothing),
      options: this.options
    });
    if (value && value !== nothing) {
      wrap(this.element).setAttribute(this.name, emptyStringForBooleanAttribute);
    } else {
      wrap(this.element).removeAttribute(this.name);
    }
  }
}
class EventPart extends AttributePart {
  constructor(element, name2, strings, parent, options) {
    super(element, name2, strings, parent, options);
    this.type = EVENT_PART;
    if (this.strings !== void 0) {
      throw new Error(`A \`<${element.localName}>\` has a \`@${name2}=...\` listener with invalid content. Event listeners in templates must have exactly one expression and no surrounding text.`);
    }
  }
  _$setValue(newListener, directiveParent = this) {
    var _a3;
    newListener = (_a3 = resolveDirective(this, newListener, directiveParent, 0)) !== null && _a3 !== void 0 ? _a3 : nothing;
    if (newListener === noChange) {
      return;
    }
    const oldListener = this._$committedValue;
    const shouldRemoveListener = newListener === nothing && oldListener !== nothing || newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive;
    const shouldAddListener = newListener !== nothing && (oldListener === nothing || shouldRemoveListener);
    debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
      kind: "commit event listener",
      element: this.element,
      name: this.name,
      value: newListener,
      options: this.options,
      removeListener: shouldRemoveListener,
      addListener: shouldAddListener,
      oldListener
    });
    if (shouldRemoveListener) {
      this.element.removeEventListener(this.name, this, oldListener);
    }
    if (shouldAddListener) {
      this.element.addEventListener(this.name, this, newListener);
    }
    this._$committedValue = newListener;
  }
  handleEvent(event) {
    var _a3, _b2;
    if (typeof this._$committedValue === "function") {
      this._$committedValue.call((_b2 = (_a3 = this.options) === null || _a3 === void 0 ? void 0 : _a3.host) !== null && _b2 !== void 0 ? _b2 : this.element, event);
    } else {
      this._$committedValue.handleEvent(event);
    }
  }
}
class ElementPart {
  constructor(element, parent, options) {
    this.element = element;
    this.type = ELEMENT_PART;
    this._$disconnectableChildren = void 0;
    this._$parent = parent;
    this.options = options;
  }
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _$setValue(value) {
    debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
      kind: "commit to element binding",
      element: this.element,
      value,
      options: this.options
    });
    resolveDirective(this, value);
  }
}
const polyfillSupport$1 = window.litHtmlPolyfillSupportDevMode;
polyfillSupport$1 === null || polyfillSupport$1 === void 0 ? void 0 : polyfillSupport$1(Template, ChildPart);
((_d$1 = globalThis.litHtmlVersions) !== null && _d$1 !== void 0 ? _d$1 : globalThis.litHtmlVersions = []).push("2.2.7");
if (globalThis.litHtmlVersions.length > 1) {
  issueWarning$1("multiple-versions", `Multiple versions of Lit loaded. Loading multiple versions is not recommended.`);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var _a$3, _b, _c;
let issueWarning;
{
  const issuedWarnings = (_a$3 = globalThis.litIssuedWarnings) !== null && _a$3 !== void 0 ? _a$3 : globalThis.litIssuedWarnings = /* @__PURE__ */ new Set();
  issueWarning = (code3, warning) => {
    warning += ` See https://lit.dev/msg/${code3} for more information.`;
    if (!issuedWarnings.has(warning)) {
      console.warn(warning);
      issuedWarnings.add(warning);
    }
  };
}
class LitElement extends ReactiveElement {
  constructor() {
    super(...arguments);
    this.renderOptions = { host: this };
    this.__childPart = void 0;
  }
  createRenderRoot() {
    var _a3;
    var _b2;
    const renderRoot = super.createRenderRoot();
    (_a3 = (_b2 = this.renderOptions).renderBefore) !== null && _a3 !== void 0 ? _a3 : _b2.renderBefore = renderRoot.firstChild;
    return renderRoot;
  }
  update(changedProperties) {
    const value = this.render();
    if (!this.hasUpdated) {
      this.renderOptions.isConnected = this.isConnected;
    }
    super.update(changedProperties);
    this.__childPart = render(value, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var _a3;
    super.connectedCallback();
    (_a3 = this.__childPart) === null || _a3 === void 0 ? void 0 : _a3.setConnected(true);
  }
  disconnectedCallback() {
    var _a3;
    super.disconnectedCallback();
    (_a3 = this.__childPart) === null || _a3 === void 0 ? void 0 : _a3.setConnected(false);
  }
  render() {
    return noChange;
  }
}
LitElement["finalized"] = true;
LitElement["_$litElement$"] = true;
(_b = globalThis.litElementHydrateSupport) === null || _b === void 0 ? void 0 : _b.call(globalThis, { LitElement });
const polyfillSupport = globalThis.litElementPolyfillSupportDevMode;
polyfillSupport === null || polyfillSupport === void 0 ? void 0 : polyfillSupport({ LitElement });
{
  LitElement["finalize"] = function() {
    const finalized2 = ReactiveElement.finalize.call(this);
    if (!finalized2) {
      return false;
    }
    const warnRemovedOrRenamed = (obj2, name2, renamed = false) => {
      if (obj2.hasOwnProperty(name2)) {
        const ctorName2 = (typeof obj2 === "function" ? obj2 : obj2.constructor).name;
        issueWarning(renamed ? "renamed-api" : "removed-api", `\`${name2}\` is implemented on class ${ctorName2}. It has been ${renamed ? "renamed" : "removed"} in this version of LitElement.`);
      }
    };
    warnRemovedOrRenamed(this, "render");
    warnRemovedOrRenamed(this, "getStyles", true);
    warnRemovedOrRenamed(this.prototype, "adoptStyles");
    return true;
  };
}
((_c = globalThis.litElementVersions) !== null && _c !== void 0 ? _c : globalThis.litElementVersions = []).push("3.2.2");
if (globalThis.litElementVersions.length > 1) {
  issueWarning("multiple-versions", `Multiple versions of Lit loaded. Loading multiple versions is not recommended.`);
}
var __awaiter$i = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SLitComponent extends LitElement {
  constructor(settings = {}) {
    var _a3, _b2, _c2, _d2, _e2, _f2, _g, _h, _j, _k;
    super();
    this.settings = {};
    this.props = {};
    this._shouldUpdate = false;
    this._state = {};
    this.settings = __deepMerge({
      componentUtils: {},
      shadowDom: false,
      get rootNode() {
        var _a4;
        return (_a4 = this.shadowRoot) === null || _a4 === void 0 ? void 0 : _a4.querySelector("*:first-child");
      }
    }, settings);
    if (this.constructor.state) {
      this.state = Object.assign({}, this.constructor.state);
    } else {
      this.state = {};
    }
    if (!((_a3 = this.state) === null || _a3 === void 0 ? void 0 : _a3.status)) {
      this.state.status = "idle";
    }
    if (this.settings.shadowDom === false) {
      this.createRenderRoot = () => {
        return this;
      };
    }
    if (!SLitComponent._keepInjectedCssBeforeStylesheetLinksInited) {
      const $firstStylesheetLink = document.head.querySelector('link[rel="stylesheet"]');
      __querySelectorLive("style", ($style) => {
        if ($firstStylesheetLink) {
          document.head.insertBefore($style, $firstStylesheetLink);
        }
      }, {
        rootNode: document.head
      });
      SLitComponent._keepInjectedCssBeforeStylesheetLinksInited = true;
    }
    const nodeFirstUpdated = (_b2 = this.firstUpdated) === null || _b2 === void 0 ? void 0 : _b2.bind(this);
    this.firstUpdated = () => __awaiter$i(this, void 0, void 0, function* () {
      if (nodeFirstUpdated) {
        yield nodeFirstUpdated();
      }
      this.setAttribute("mounted", true);
    });
    const nodeShouldUpdate = (_c2 = this.shouldUpdate) === null || _c2 === void 0 ? void 0 : _c2.bind(this);
    this.shouldUpdate = () => {
      if (nodeShouldUpdate) {
        const res = nodeShouldUpdate();
        if (!res)
          return false;
      }
      return this._shouldUpdate;
    };
    this.componentUtils = new SComponentUtils(this, Object.assign(Object.assign(Object.assign({}, (_d2 = this.settings) !== null && _d2 !== void 0 ? _d2 : {}), (_e2 = this.settings.componentUtils) !== null && _e2 !== void 0 ? _e2 : {}), { style: (_k = (_h = (_g = (_f2 = this.constructor.styles) === null || _f2 === void 0 ? void 0 : _f2.cssText) !== null && _g !== void 0 ? _g : this.settings.style) !== null && _h !== void 0 ? _h : (_j = this.settings.componentUtils) === null || _j === void 0 ? void 0 : _j.style) !== null && _k !== void 0 ? _k : "" }));
    (() => __awaiter$i(this, void 0, void 0, function* () {
      var _l2, _m2;
      const defaultProps = SComponentUtils.getDefaultProps(this.tagName.toLowerCase());
      const mountWhen = (_m2 = (_l2 = this.getAttribute("mount-when")) !== null && _l2 !== void 0 ? _l2 : defaultProps.mountWhen) !== null && _m2 !== void 0 ? _m2 : "direct";
      this.classList.add(...this.componentUtils.className("").split(" "));
      yield __wait();
      yield __wait();
      if (!mountWhen.match(/^direct(ly)?$/)) {
        yield this.componentUtils.waitAndExecute(mountWhen, () => {
          this._mount();
        });
      } else {
        this._mount();
      }
    }))();
  }
  get state() {
    return this._state;
  }
  set state(state) {
    Object.assign(this._state, state);
  }
  static define(tagName, Cls, props = {}, settings = {}) {
    var _a3;
    const win = (_a3 = settings.window) !== null && _a3 !== void 0 ? _a3 : window;
    if (win.customElements.get(tagName.toLowerCase())) {
      return;
    }
    SLitComponent.setDefaultProps(tagName, props);
    win.customElements.define(tagName.toLowerCase(), class extends Cls {
    });
  }
  static setDefaultProps(selector, props) {
    SComponentUtils.setDefaultProps(selector, props);
  }
  static propertiesFromInterface(properties2, int) {
    var _a3;
    const propertiesObj = {};
    class SLitComponentPropsInterface extends SComponentUtilsDefaultPropsInterface {
    }
    SLitComponentPropsInterface.definition = Object.assign(Object.assign({}, SLitComponentPropsInterface.definition), (_a3 = int === null || int === void 0 ? void 0 : int.definition) !== null && _a3 !== void 0 ? _a3 : {});
    Object.keys(SLitComponentPropsInterface.definition).forEach((prop) => {
      var _a4, _b2, _c2, _d2, _e2, _f2, _g, _h, _j, _k, _l2, _m2, _o2;
      const definition2 = SLitComponentPropsInterface.definition[prop];
      propertiesObj[prop] = Object.assign({}, (_a4 = definition2.lit) !== null && _a4 !== void 0 ? _a4 : {});
      let type = String, typeStr = (_c2 = (_b2 = definition2.type) === null || _b2 === void 0 ? void 0 : _b2.type) !== null && _c2 !== void 0 ? _c2 : definition2.type;
      switch (typeStr.toLowerCase()) {
        case "boolean":
          type = Boolean;
          break;
        case "object":
          type = Object;
          break;
        case "number":
          type = Number;
          break;
        default:
          if (typeStr.match(/\[\]$/)) {
            type = Array;
          }
          break;
      }
      propertiesObj[prop].type = type;
      propertiesObj[prop].default = definition2.default;
      if (definition2.physical || ((_f2 = (_e2 = (_d2 = definition2.type) === null || _d2 === void 0 ? void 0 : _d2.type) === null || _e2 === void 0 ? void 0 : _e2.toLowerCase) === null || _f2 === void 0 ? void 0 : _f2.call(_e2)) === "boolean" || ((_h = (_g = definition2.type) === null || _g === void 0 ? void 0 : _g.toLowerCase) === null || _h === void 0 ? void 0 : _h.call(_g)) === "boolean" || ((_l2 = (_k = (_j = definition2.type) === null || _j === void 0 ? void 0 : _j.type) === null || _k === void 0 ? void 0 : _k.toLowerCase) === null || _l2 === void 0 ? void 0 : _l2.call(_k)) === "object" || ((_o2 = (_m2 = definition2.type) === null || _m2 === void 0 ? void 0 : _m2.toLowerCase) === null || _o2 === void 0 ? void 0 : _o2.call(_m2)) === "object") {
        propertiesObj[prop].reflect = true;
        propertiesObj[prop].attribute = __dashCase(prop);
        propertiesObj[prop].converter = {
          fromAttribute: (value, type2) => {
            var _a5, _b3, _c3, _d3;
            const typeStr2 = (_c3 = (_b3 = (_a5 = definition2.type) === null || _a5 === void 0 ? void 0 : _a5.type) === null || _b3 === void 0 ? void 0 : _b3.toLowerCase()) !== null && _c3 !== void 0 ? _c3 : (_d3 = definition2.type) === null || _d3 === void 0 ? void 0 : _d3.toLowerCase();
            if (typeStr2 === "object" && typeof value === "string") {
              try {
                const json = JSON.parse(value);
                return json;
              } catch (e) {
                console.error(e);
              }
            }
            if (value === "true" || value === "")
              return true;
            return value;
          },
          toAttribute(value) {
            if (typeof value !== "string" && typeof value !== "boolean") {
              try {
                const jsonStr = JSON.stringify(value);
                return jsonStr;
              } catch (e) {
              }
            }
            if (value === "false" || value === false || value === null) {
              return void 0;
            }
            return value;
          }
        };
      }
    });
    const props = Object.assign(Object.assign({}, propertiesObj), properties2 !== null && properties2 !== void 0 ? properties2 : {});
    return props;
  }
  disconnectedCallback() {
  }
  _mount() {
    var _a3, _b2, _c2;
    return __awaiter$i(this, void 0, void 0, function* () {
      const _this = this, defaultProps = SComponentUtils.getDefaultProps(this.tagName.toLowerCase());
      let properties2 = this.constructor.properties;
      if (!properties2) {
        properties2 = this.constructor.propertiesFromInterface();
      }
      let finalProps = {};
      for (let [prop, obj2] of Object.entries(properties2)) {
        Object.defineProperty(this.props, prop, {
          enumerable: true,
          get() {
            return _this[prop];
          },
          set(value) {
            var _a4;
            value = (_a4 = value === null || value === void 0 ? void 0 : value.value) !== null && _a4 !== void 0 ? _a4 : value;
            if (value && typeof value === "string") {
              try {
                _this[prop] = JSON.parse(value);
                return;
              } catch (e) {
              }
            }
            _this[prop] = value;
          }
        });
        let attrValue = this.getAttribute(__dashCase(prop));
        if (attrValue !== null) {
          if (attrValue === "false")
            attrValue = false;
          if (attrValue === "")
            attrValue = true;
          finalProps[prop] = attrValue;
        }
        if (finalProps[prop] === void 0 && this[prop] === void 0) {
          finalProps[prop] = (_a3 = defaultProps[prop]) !== null && _a3 !== void 0 ? _a3 : obj2.default;
        }
      }
      if (this.settings.interface) {
        finalProps = this.settings.interface.apply(finalProps);
      }
      Object.assign(this.props, finalProps);
      this.componentUtils.makePropsResponsive(this.props);
      if (this.props.verbose) {
        console.log(`[${this.tagName.toLowerCase()}]${this.id ? ` #${this.id} ` : " "}mounting`);
      }
      if (this.state) {
        const state = Object.assign({}, this.state);
        delete this.state;
        Object.defineProperty(this, "state", {
          enumerable: true,
          value: this.componentUtils.handleState(state, {
            save: this.props.saveState
          })
        });
        this.state.$set("*", () => {
          this.requestUpdate();
        });
      }
      if (this.mount && typeof this.mount === "function") {
        yield this.mount();
      }
      this._shouldUpdate = true;
      this.requestUpdate();
      yield this.updateComplete;
      this.componentUtils.injectStyle((_c2 = (_b2 = this.constructor.styles) === null || _b2 === void 0 ? void 0 : _b2.cssText) !== null && _c2 !== void 0 ? _c2 : "", this.tagName);
      yield __wait();
      if (this.props.adoptStyle && this.shadowRoot) {
        yield this.componentUtils.adoptStyleInShadowRoot(this.shadowRoot);
      }
      return true;
    });
  }
}
SLitComponent._keepInjectedCssBeforeStylesheetLinksInited = false;
var axios$2 = { exports: {} };
var axios$1 = { exports: {} };
var bind$2 = function bind3(fn2, thisArg) {
  return function wrap2() {
    var args = new Array(arguments.length);
    for (var i2 = 0; i2 < args.length; i2++) {
      args[i2] = arguments[i2];
    }
    return fn2.apply(thisArg, args);
  };
};
var bind$1 = bind$2;
var toString = Object.prototype.toString;
var kindOf = function(cache2) {
  return function(thing) {
    var str2 = toString.call(thing);
    return cache2[str2] || (cache2[str2] = str2.slice(8, -1).toLowerCase());
  };
}(/* @__PURE__ */ Object.create(null));
function kindOfTest(type) {
  type = type.toLowerCase();
  return function isKindOf(thing) {
    return kindOf(thing) === type;
  };
}
function isArray(val) {
  return Array.isArray(val);
}
function isUndefined(val) {
  return typeof val === "undefined";
}
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  var result2;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result2 = ArrayBuffer.isView(val);
  } else {
    result2 = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result2;
}
function isString(val) {
  return typeof val === "string";
}
function isNumber(val) {
  return typeof val === "number";
}
function isObject(val) {
  return val !== null && typeof val === "object";
}
function isPlainObject(val) {
  if (kindOf(val) !== "object") {
    return false;
  }
  var prototype2 = Object.getPrototypeOf(val);
  return prototype2 === null || prototype2 === Object.prototype;
}
var isDate$1 = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
function isFunction(val) {
  return toString.call(val) === "[object Function]";
}
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}
function isFormData(thing) {
  var pattern2 = "[object FormData]";
  return thing && (typeof FormData === "function" && thing instanceof FormData || toString.call(thing) === pattern2 || isFunction(thing.toString) && thing.toString() === pattern2);
}
var isURLSearchParams = kindOfTest("URLSearchParams");
function trim(str2) {
  return str2.trim ? str2.trim() : str2.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
  if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function forEach(obj2, fn2) {
  if (obj2 === null || typeof obj2 === "undefined") {
    return;
  }
  if (typeof obj2 !== "object") {
    obj2 = [obj2];
  }
  if (isArray(obj2)) {
    for (var i2 = 0, l = obj2.length; i2 < l; i2++) {
      fn2.call(null, obj2[i2], i2, obj2);
    }
  } else {
    for (var key in obj2) {
      if (Object.prototype.hasOwnProperty.call(obj2, key)) {
        fn2.call(null, obj2[key], key, obj2);
      }
    }
  }
}
function merge() {
  var result2 = {};
  function assignValue(val, key) {
    if (isPlainObject(result2[key]) && isPlainObject(val)) {
      result2[key] = merge(result2[key], val);
    } else if (isPlainObject(val)) {
      result2[key] = merge({}, val);
    } else if (isArray(val)) {
      result2[key] = val.slice();
    } else {
      result2[key] = val;
    }
  }
  for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
    forEach(arguments[i2], assignValue);
  }
  return result2;
}
function extend(a3, b2, thisArg) {
  forEach(b2, function assignValue(val, key) {
    if (thisArg && typeof val === "function") {
      a3[key] = bind$1(val, thisArg);
    } else {
      a3[key] = val;
    }
  });
  return a3;
}
function stripBOM(content) {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
}
function inherits(constructor, superConstructor, props, descriptors2) {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  props && Object.assign(constructor.prototype, props);
}
function toFlatObject(sourceObj, destObj, filter2) {
  var props;
  var i2;
  var prop;
  var merged = {};
  destObj = destObj || {};
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i2 = props.length;
    while (i2-- > 0) {
      prop = props[i2];
      if (!merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = Object.getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
}
function endsWith(str2, searchString, position) {
  str2 = String(str2);
  if (position === void 0 || position > str2.length) {
    position = str2.length;
  }
  position -= searchString.length;
  var lastIndex = str2.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}
function toArray(thing) {
  if (!thing)
    return null;
  var i2 = thing.length;
  if (isUndefined(i2))
    return null;
  var arr = new Array(i2);
  while (i2-- > 0) {
    arr[i2] = thing[i2];
  }
  return arr;
}
var isTypedArray = function(TypedArray2) {
  return function(thing) {
    return TypedArray2 && thing instanceof TypedArray2;
  };
}(typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array));
var utils$b = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isObject,
  isPlainObject,
  isUndefined,
  isDate: isDate$1,
  isFile,
  isBlob,
  isFunction,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  isTypedArray,
  isFileList
};
var utils$a = utils$b;
function encode$1(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$1 = function buildURL2(url, params, paramsSerializer) {
  if (!params) {
    return url;
  }
  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils$a.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils$a.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === "undefined") {
        return;
      }
      if (utils$a.isArray(val)) {
        key = key + "[]";
      } else {
        val = [val];
      }
      utils$a.forEach(val, function parseValue(v) {
        if (utils$a.isDate(v)) {
          v = v.toISOString();
        } else if (utils$a.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode$1(key) + "=" + encode$1(v));
      });
    });
    serializedParams = parts.join("&");
  }
  if (serializedParams) {
    var hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
};
var utils$9 = utils$b;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled,
    rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};
InterceptorManager$1.prototype.eject = function eject(id2) {
  if (this.handlers[id2]) {
    this.handlers[id2] = null;
  }
};
InterceptorManager$1.prototype.forEach = function forEach3(fn2) {
  utils$9.forEach(this.handlers, function forEachHandler(h2) {
    if (h2 !== null) {
      fn2(h2);
    }
  });
};
var InterceptorManager_1 = InterceptorManager$1;
var utils$8 = utils$b;
var normalizeHeaderName$1 = function normalizeHeaderName2(headers, normalizedName) {
  utils$8.forEach(headers, function processHeader(value, name2) {
    if (name2 !== normalizedName && name2.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name2];
    }
  });
};
var utils$7 = utils$b;
function AxiosError$2(message, code3, config2, request2, response) {
  Error.call(this);
  this.message = message;
  this.name = "AxiosError";
  code3 && (this.code = code3);
  config2 && (this.config = config2);
  request2 && (this.request = request2);
  response && (this.response = response);
}
utils$7.inherits(AxiosError$2, Error, {
  toJSON: function toJSON() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError$2.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED"
].forEach(function(code3) {
  descriptors[code3] = { value: code3 };
});
Object.defineProperties(AxiosError$2, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError$2.from = function(error2, code3, config2, request2, response, customProps) {
  var axiosError = Object.create(prototype);
  utils$7.toFlatObject(error2, axiosError, function filter2(obj2) {
    return obj2 !== Error.prototype;
  });
  AxiosError$2.call(axiosError, error2.message, code3, config2, request2, response);
  axiosError.name = error2.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_1 = AxiosError$2;
var transitional = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
var utils$6 = utils$b;
function toFormData$1(obj2, formData) {
  formData = formData || new FormData();
  var stack = [];
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils$6.isDate(value)) {
      return value.toISOString();
    }
    if (utils$6.isArrayBuffer(value) || utils$6.isTypedArray(value)) {
      return typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function build(data2, parentKey) {
    if (utils$6.isPlainObject(data2) || utils$6.isArray(data2)) {
      if (stack.indexOf(data2) !== -1) {
        throw Error("Circular reference detected in " + parentKey);
      }
      stack.push(data2);
      utils$6.forEach(data2, function each(value, key) {
        if (utils$6.isUndefined(value))
          return;
        var fullKey = parentKey ? parentKey + "." + key : key;
        var arr;
        if (value && !parentKey && typeof value === "object") {
          if (utils$6.endsWith(key, "{}")) {
            value = JSON.stringify(value);
          } else if (utils$6.endsWith(key, "[]") && (arr = utils$6.toArray(value))) {
            arr.forEach(function(el2) {
              !utils$6.isUndefined(el2) && formData.append(fullKey, convertValue(el2));
            });
            return;
          }
        }
        build(value, fullKey);
      });
      stack.pop();
    } else {
      formData.append(parentKey, convertValue(data2));
    }
  }
  build(obj2);
  return formData;
}
var toFormData_1 = toFormData$1;
var settle;
var hasRequiredSettle;
function requireSettle() {
  if (hasRequiredSettle)
    return settle;
  hasRequiredSettle = 1;
  var AxiosError2 = AxiosError_1;
  settle = function settle2(resolve, reject, response) {
    var validateStatus2 = response.config.validateStatus;
    if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
      resolve(response);
    } else {
      reject(new AxiosError2(
        "Request failed with status code " + response.status,
        [AxiosError2.ERR_BAD_REQUEST, AxiosError2.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  };
  return settle;
}
var cookies;
var hasRequiredCookies;
function requireCookies() {
  if (hasRequiredCookies)
    return cookies;
  hasRequiredCookies = 1;
  var utils2 = utils$b;
  cookies = utils2.isStandardBrowserEnv() ? function standardBrowserEnv() {
    return {
      write: function write(name2, value, expires, path2, domain, secure) {
        var cookie = [];
        cookie.push(name2 + "=" + encodeURIComponent(value));
        if (utils2.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils2.isString(path2)) {
          cookie.push("path=" + path2);
        }
        if (utils2.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read(name2) {
        var match5 = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
        return match5 ? decodeURIComponent(match5[3]) : null;
      },
      remove: function remove(name2) {
        this.write(name2, "", Date.now() - 864e5);
      }
    };
  }() : function nonStandardBrowserEnv() {
    return {
      write: function write() {
      },
      read: function read() {
        return null;
      },
      remove: function remove() {
      }
    };
  }();
  return cookies;
}
var isAbsoluteURL$1 = function isAbsoluteURL2(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
};
var combineURLs$1 = function combineURLs2(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
};
var isAbsoluteURL = isAbsoluteURL$1;
var combineURLs = combineURLs$1;
var buildFullPath$1 = function buildFullPath2(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};
var parseHeaders;
var hasRequiredParseHeaders;
function requireParseHeaders() {
  if (hasRequiredParseHeaders)
    return parseHeaders;
  hasRequiredParseHeaders = 1;
  var utils2 = utils$b;
  var ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  parseHeaders = function parseHeaders2(headers) {
    var parsed = {};
    var key;
    var val;
    var i2;
    if (!headers) {
      return parsed;
    }
    utils2.forEach(headers.split("\n"), function parser(line) {
      i2 = line.indexOf(":");
      key = utils2.trim(line.substr(0, i2)).toLowerCase();
      val = utils2.trim(line.substr(i2 + 1));
      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }
        if (key === "set-cookie") {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      }
    });
    return parsed;
  };
  return parseHeaders;
}
var isURLSameOrigin;
var hasRequiredIsURLSameOrigin;
function requireIsURLSameOrigin() {
  if (hasRequiredIsURLSameOrigin)
    return isURLSameOrigin;
  hasRequiredIsURLSameOrigin = 1;
  var utils2 = utils$b;
  isURLSameOrigin = utils2.isStandardBrowserEnv() ? function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement("a");
    var originURL;
    function resolveURL(url) {
      var href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      var parsed = utils2.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }() : function nonStandardBrowserEnv() {
    return function isURLSameOrigin2() {
      return true;
    };
  }();
  return isURLSameOrigin;
}
var CanceledError_1;
var hasRequiredCanceledError;
function requireCanceledError() {
  if (hasRequiredCanceledError)
    return CanceledError_1;
  hasRequiredCanceledError = 1;
  var AxiosError2 = AxiosError_1;
  var utils2 = utils$b;
  function CanceledError2(message) {
    AxiosError2.call(this, message == null ? "canceled" : message, AxiosError2.ERR_CANCELED);
    this.name = "CanceledError";
  }
  utils2.inherits(CanceledError2, AxiosError2, {
    __CANCEL__: true
  });
  CanceledError_1 = CanceledError2;
  return CanceledError_1;
}
var parseProtocol;
var hasRequiredParseProtocol;
function requireParseProtocol() {
  if (hasRequiredParseProtocol)
    return parseProtocol;
  hasRequiredParseProtocol = 1;
  parseProtocol = function parseProtocol2(url) {
    var match5 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match5 && match5[1] || "";
  };
  return parseProtocol;
}
var xhr;
var hasRequiredXhr;
function requireXhr() {
  if (hasRequiredXhr)
    return xhr;
  hasRequiredXhr = 1;
  var utils2 = utils$b;
  var settle2 = requireSettle();
  var cookies2 = requireCookies();
  var buildURL3 = buildURL$1;
  var buildFullPath3 = buildFullPath$1;
  var parseHeaders2 = requireParseHeaders();
  var isURLSameOrigin2 = requireIsURLSameOrigin();
  var transitionalDefaults2 = transitional;
  var AxiosError2 = AxiosError_1;
  var CanceledError2 = requireCanceledError();
  var parseProtocol2 = requireParseProtocol();
  xhr = function xhrAdapter(config2) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      var requestData = config2.data;
      var requestHeaders = config2.headers;
      var responseType = config2.responseType;
      var onCanceled;
      function done() {
        if (config2.cancelToken) {
          config2.cancelToken.unsubscribe(onCanceled);
        }
        if (config2.signal) {
          config2.signal.removeEventListener("abort", onCanceled);
        }
      }
      if (utils2.isFormData(requestData) && utils2.isStandardBrowserEnv()) {
        delete requestHeaders["Content-Type"];
      }
      var request2 = new XMLHttpRequest();
      if (config2.auth) {
        var username = config2.auth.username || "";
        var password2 = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
        requestHeaders.Authorization = "Basic " + btoa(username + ":" + password2);
      }
      var fullPath = buildFullPath3(config2.baseURL, config2.url);
      request2.open(config2.method.toUpperCase(), buildURL3(fullPath, config2.params, config2.paramsSerializer), true);
      request2.timeout = config2.timeout;
      function onloadend() {
        if (!request2) {
          return;
        }
        var responseHeaders = "getAllResponseHeaders" in request2 ? parseHeaders2(request2.getAllResponseHeaders()) : null;
        var responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
        var response = {
          data: responseData,
          status: request2.status,
          statusText: request2.statusText,
          headers: responseHeaders,
          config: config2,
          request: request2
        };
        settle2(function _resolve(value) {
          resolve(value);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);
        request2 = null;
      }
      if ("onloadend" in request2) {
        request2.onloadend = onloadend;
      } else {
        request2.onreadystatechange = function handleLoad() {
          if (!request2 || request2.readyState !== 4) {
            return;
          }
          if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request2.onabort = function handleAbort() {
        if (!request2) {
          return;
        }
        reject(new AxiosError2("Request aborted", AxiosError2.ECONNABORTED, config2, request2));
        request2 = null;
      };
      request2.onerror = function handleError() {
        reject(new AxiosError2("Network Error", AxiosError2.ERR_NETWORK, config2, request2, request2));
        request2 = null;
      };
      request2.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
        var transitional3 = config2.transitional || transitionalDefaults2;
        if (config2.timeoutErrorMessage) {
          timeoutErrorMessage = config2.timeoutErrorMessage;
        }
        reject(new AxiosError2(
          timeoutErrorMessage,
          transitional3.clarifyTimeoutError ? AxiosError2.ETIMEDOUT : AxiosError2.ECONNABORTED,
          config2,
          request2
        ));
        request2 = null;
      };
      if (utils2.isStandardBrowserEnv()) {
        var xsrfValue = (config2.withCredentials || isURLSameOrigin2(fullPath)) && config2.xsrfCookieName ? cookies2.read(config2.xsrfCookieName) : void 0;
        if (xsrfValue) {
          requestHeaders[config2.xsrfHeaderName] = xsrfValue;
        }
      }
      if ("setRequestHeader" in request2) {
        utils2.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
            delete requestHeaders[key];
          } else {
            request2.setRequestHeader(key, val);
          }
        });
      }
      if (!utils2.isUndefined(config2.withCredentials)) {
        request2.withCredentials = !!config2.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request2.responseType = config2.responseType;
      }
      if (typeof config2.onDownloadProgress === "function") {
        request2.addEventListener("progress", config2.onDownloadProgress);
      }
      if (typeof config2.onUploadProgress === "function" && request2.upload) {
        request2.upload.addEventListener("progress", config2.onUploadProgress);
      }
      if (config2.cancelToken || config2.signal) {
        onCanceled = function(cancel) {
          if (!request2) {
            return;
          }
          reject(!cancel || cancel && cancel.type ? new CanceledError2() : cancel);
          request2.abort();
          request2 = null;
        };
        config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
        if (config2.signal) {
          config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
        }
      }
      if (!requestData) {
        requestData = null;
      }
      var protocol = parseProtocol2(fullPath);
      if (protocol && ["http", "https", "file"].indexOf(protocol) === -1) {
        reject(new AxiosError2("Unsupported protocol " + protocol + ":", AxiosError2.ERR_BAD_REQUEST, config2));
        return;
      }
      request2.send(requestData);
    });
  };
  return xhr;
}
var _null;
var hasRequired_null;
function require_null() {
  if (hasRequired_null)
    return _null;
  hasRequired_null = 1;
  _null = null;
  return _null;
}
var utils$5 = utils$b;
var normalizeHeaderName = normalizeHeaderName$1;
var AxiosError$1 = AxiosError_1;
var transitionalDefaults = transitional;
var toFormData = toFormData_1;
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset(headers, value) {
  if (!utils$5.isUndefined(headers) && utils$5.isUndefined(headers["Content-Type"])) {
    headers["Content-Type"] = value;
  }
}
function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== "undefined") {
    adapter = requireXhr();
  } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
    adapter = requireXhr();
  }
  return adapter;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$5.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$5.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults$3 = {
  transitional: transitionalDefaults,
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data2, headers) {
    normalizeHeaderName(headers, "Accept");
    normalizeHeaderName(headers, "Content-Type");
    if (utils$5.isFormData(data2) || utils$5.isArrayBuffer(data2) || utils$5.isBuffer(data2) || utils$5.isStream(data2) || utils$5.isFile(data2) || utils$5.isBlob(data2)) {
      return data2;
    }
    if (utils$5.isArrayBufferView(data2)) {
      return data2.buffer;
    }
    if (utils$5.isURLSearchParams(data2)) {
      setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
      return data2.toString();
    }
    var isObjectPayload = utils$5.isObject(data2);
    var contentType = headers && headers["Content-Type"];
    var isFileList2;
    if ((isFileList2 = utils$5.isFileList(data2)) || isObjectPayload && contentType === "multipart/form-data") {
      var _FormData = this.env && this.env.FormData;
      return toFormData(isFileList2 ? { "files[]": data2 } : data2, _FormData && new _FormData());
    } else if (isObjectPayload || contentType === "application/json") {
      setContentTypeIfUnset(headers, "application/json");
      return stringifySafely(data2);
    }
    return data2;
  }],
  transformResponse: [function transformResponse(data2) {
    var transitional3 = this.transitional || defaults$3.transitional;
    var silentJSONParsing = transitional3 && transitional3.silentJSONParsing;
    var forcedJSONParsing = transitional3 && transitional3.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
    if (strictJSONParsing || forcedJSONParsing && utils$5.isString(data2) && data2.length) {
      try {
        return JSON.parse(data2);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data2;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: require_null()
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils$5.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults$3.headers[method] = {};
});
utils$5.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults$3.headers[method] = utils$5.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$3;
var utils$4 = utils$b;
var defaults$2 = defaults_1;
var transformData$1 = function transformData2(data2, headers, fns) {
  var context = this || defaults$2;
  utils$4.forEach(fns, function transform(fn2) {
    data2 = fn2.call(context, data2, headers);
  });
  return data2;
};
var isCancel$1;
var hasRequiredIsCancel;
function requireIsCancel() {
  if (hasRequiredIsCancel)
    return isCancel$1;
  hasRequiredIsCancel = 1;
  isCancel$1 = function isCancel2(value) {
    return !!(value && value.__CANCEL__);
  };
  return isCancel$1;
}
var utils$3 = utils$b;
var transformData = transformData$1;
var isCancel = requireIsCancel();
var defaults$1 = defaults_1;
var CanceledError = requireCanceledError();
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError();
  }
}
var dispatchRequest$1 = function dispatchRequest2(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = config2.headers || {};
  config2.data = transformData.call(
    config2,
    config2.data,
    config2.headers,
    config2.transformRequest
  );
  config2.headers = utils$3.merge(
    config2.headers.common || {},
    config2.headers[config2.method] || {},
    config2.headers
  );
  utils$3.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function cleanHeaderConfig(method) {
      delete config2.headers[method];
    }
  );
  var adapter = config2.adapter || defaults$1.adapter;
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData.call(
      config2,
      response.data,
      response.headers,
      config2.transformResponse
    );
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          reason.response.data,
          reason.response.headers,
          config2.transformResponse
        );
      }
    }
    return Promise.reject(reason);
  });
};
var utils$2 = utils$b;
var mergeConfig$2 = function mergeConfig2(config1, config2) {
  config2 = config2 || {};
  var config3 = {};
  function getMergedValue(target, source2) {
    if (utils$2.isPlainObject(target) && utils$2.isPlainObject(source2)) {
      return utils$2.merge(target, source2);
    } else if (utils$2.isPlainObject(source2)) {
      return utils$2.merge({}, source2);
    } else if (utils$2.isArray(source2)) {
      return source2.slice();
    }
    return source2;
  }
  function mergeDeepProperties(prop) {
    if (!utils$2.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils$2.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function valueFromConfig2(prop) {
    if (!utils$2.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    }
  }
  function defaultToConfig2(prop) {
    if (!utils$2.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    } else if (!utils$2.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  var mergeMap = {
    "url": valueFromConfig2,
    "method": valueFromConfig2,
    "data": valueFromConfig2,
    "baseURL": defaultToConfig2,
    "transformRequest": defaultToConfig2,
    "transformResponse": defaultToConfig2,
    "paramsSerializer": defaultToConfig2,
    "timeout": defaultToConfig2,
    "timeoutMessage": defaultToConfig2,
    "withCredentials": defaultToConfig2,
    "adapter": defaultToConfig2,
    "responseType": defaultToConfig2,
    "xsrfCookieName": defaultToConfig2,
    "xsrfHeaderName": defaultToConfig2,
    "onUploadProgress": defaultToConfig2,
    "onDownloadProgress": defaultToConfig2,
    "decompress": defaultToConfig2,
    "maxContentLength": defaultToConfig2,
    "maxBodyLength": defaultToConfig2,
    "beforeRedirect": defaultToConfig2,
    "transport": defaultToConfig2,
    "httpAgent": defaultToConfig2,
    "httpsAgent": defaultToConfig2,
    "cancelToken": defaultToConfig2,
    "socketPath": defaultToConfig2,
    "responseEncoding": defaultToConfig2,
    "validateStatus": mergeDirectKeys
  };
  utils$2.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge2 = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge2(prop);
    utils$2.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
};
var data;
var hasRequiredData;
function requireData() {
  if (hasRequiredData)
    return data;
  hasRequiredData = 1;
  data = {
    "version": "0.27.2"
  };
  return data;
}
var VERSION = requireData().version;
var AxiosError = AxiosError_1;
var validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i2) {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators$1.transitional = function transitional2(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return function(value, opt, opts) {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  var keys3 = Object.keys(options);
  var i2 = keys3.length;
  while (i2-- > 0) {
    var opt = keys3[i2];
    var validator2 = schema[opt];
    if (validator2) {
      var value = options[opt];
      var result2 = value === void 0 || validator2(value, opt, options);
      if (result2 !== true) {
        throw new AxiosError("option " + opt + " must be " + result2, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
var validator$1 = {
  assertOptions,
  validators: validators$1
};
var utils$1 = utils$b;
var buildURL = buildURL$1;
var InterceptorManager = InterceptorManager_1;
var dispatchRequest = dispatchRequest$1;
var mergeConfig$1 = mergeConfig$2;
var buildFullPath = buildFullPath$1;
var validator = validator$1;
var validators = validator.validators;
function Axios$1(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
Axios$1.prototype.request = function request(configOrUrl, config2) {
  if (typeof configOrUrl === "string") {
    config2 = config2 || {};
    config2.url = configOrUrl;
  } else {
    config2 = configOrUrl || {};
  }
  config2 = mergeConfig$1(this.defaults, config2);
  if (config2.method) {
    config2.method = config2.method.toLowerCase();
  } else if (this.defaults.method) {
    config2.method = this.defaults.method.toLowerCase();
  } else {
    config2.method = "get";
  }
  var transitional3 = config2.transitional;
  if (transitional3 !== void 0) {
    validator.assertOptions(transitional3, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
      return;
    }
    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });
  var promise;
  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, void 0];
    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);
    promise = Promise.resolve(config2);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }
    return promise;
  }
  var newConfig = config2;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error2) {
      onRejected(error2);
      break;
    }
  }
  try {
    promise = dispatchRequest(newConfig);
  } catch (error2) {
    return Promise.reject(error2);
  }
  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }
  return promise;
};
Axios$1.prototype.getUri = function getUri(config2) {
  config2 = mergeConfig$1(this.defaults, config2);
  var fullPath = buildFullPath(config2.baseURL, config2.url);
  return buildURL(fullPath, config2.params, config2.paramsSerializer);
};
utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios$1.prototype[method] = function(url, config2) {
    return this.request(mergeConfig$1(config2 || {}, {
      method,
      url,
      data: (config2 || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data2, config2) {
      return this.request(mergeConfig$1(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data: data2
      }));
    };
  }
  Axios$1.prototype[method] = generateHTTPMethod();
  Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_1 = Axios$1;
var CancelToken_1;
var hasRequiredCancelToken;
function requireCancelToken() {
  if (hasRequiredCancelToken)
    return CancelToken_1;
  hasRequiredCancelToken = 1;
  var CanceledError2 = requireCanceledError();
  function CancelToken(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    var token = this;
    this.promise.then(function(cancel) {
      if (!token._listeners)
        return;
      var i2;
      var l = token._listeners.length;
      for (i2 = 0; i2 < l; i2++) {
        token._listeners[i2](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = function(onfulfilled) {
      var _resolve;
      var promise = new Promise(function(resolve) {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError2(message);
      resolvePromise(token.reason);
    });
  }
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  CancelToken.prototype.subscribe = function subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  };
  CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    var index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  };
  CancelToken.source = function source2() {
    var cancel;
    var token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  };
  CancelToken_1 = CancelToken;
  return CancelToken_1;
}
var spread;
var hasRequiredSpread;
function requireSpread() {
  if (hasRequiredSpread)
    return spread;
  hasRequiredSpread = 1;
  spread = function spread2(callback) {
    return function wrap2(arr) {
      return callback.apply(null, arr);
    };
  };
  return spread;
}
var isAxiosError;
var hasRequiredIsAxiosError;
function requireIsAxiosError() {
  if (hasRequiredIsAxiosError)
    return isAxiosError;
  hasRequiredIsAxiosError = 1;
  var utils2 = utils$b;
  isAxiosError = function isAxiosError2(payload) {
    return utils2.isObject(payload) && payload.isAxiosError === true;
  };
  return isAxiosError;
}
var utils = utils$b;
var bind = bind$2;
var Axios = Axios_1;
var mergeConfig = mergeConfig$2;
var defaults = defaults_1;
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);
  utils.extend(instance, Axios.prototype, context);
  utils.extend(instance, context);
  instance.create = function create2(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults);
axios.Axios = Axios;
axios.CanceledError = requireCanceledError();
axios.CancelToken = requireCancelToken();
axios.isCancel = requireIsCancel();
axios.VERSION = requireData().version;
axios.toFormData = toFormData_1;
axios.AxiosError = AxiosError_1;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = requireSpread();
axios.isAxiosError = requireIsAxiosError();
axios$1.exports = axios;
axios$1.exports.default = axios;
(function(module) {
  module.exports = axios$1.exports;
})(axios$2);
const __axios = /* @__PURE__ */ getDefaultExportFromCjs(axios$2.exports);
class SRequestParamsInterface extends SInterface {
  static get _definition() {
    return {
      url: {
        description: "The url of the request",
        type: "String",
        required: true
      },
      baseUrl: {
        description: `Specify the base url to call like "https://api.github.com/2.0" for example. If the "url" setting is absolute, this setting will don't have any impact on your request...`,
        type: "String"
      },
      method: {
        description: "The request method to use like GET, DELETE, HEAD, POST, OPTIONS, PUT or PATCH",
        type: "String",
        values: [
          "GET",
          "DELETE",
          "HEAD",
          "OPTIONS",
          "POST",
          "PUT",
          "PATCH"
        ],
        default: "GET"
      },
      headers: {
        description: "Specify some headers to add to the request",
        type: "Object",
        default: {}
      },
      params: {
        description: "Specify some params to be sent through the URL. Must be a plain object or a URLSearchParams object",
        type: "Object",
        default: {}
      },
      data: {
        description: "Specify some data you want to send with the request. This setting is available only for `PUT`, `POST`, and `PATCH` requests...",
        type: "Object",
        default: {}
      },
      timeout: {
        description: "Specify time to wait before aborting the actual request. If setted in number format, this will mean milliseconds.",
        type: "Number",
        default: 0
      },
      transformRequest: {
        description: "Allows changes to the request data before it is sent to the server. See [axios](https://github.com/axios/axios#response-schema) documentation for more.",
        type: "Function"
      },
      transformResponse: {
        description: "Allows changes to the response data to be made before it is passed to then/catch. See [axios](https://github.com/axios/axios#response-schema) documentation for more.",
        type: "Function"
      },
      paramsSerializer: {
        description: "An optional function in charge of serializing. See [axios](https://github.com/axios/axios#response-schema) documentation for more.",
        type: "Function"
      },
      withCredentials: {
        description: "Indicates whether or not cross-site Access-Control requests should be made using credentials. See [axios](https://github.com/axios/axios#response-schema) documentation for more.",
        type: "Boolean",
        default: false
      },
      auth: {
        description: "indicates that HTTP Basic auth should be used, and supplies credentials. See [axios](https://github.com/axios/axios#response-schema) documentation for more.",
        type: "Object"
      },
      responseType: {
        description: "Indicates encoding to use for decoding responses (Node.js only)",
        type: "String",
        values: [
          "arraybuffer",
          "blob",
          "document",
          "json",
          "text",
          "stream",
          "blob"
        ],
        default: "json"
      },
      responseEncoding: {
        description: "indicates encoding to use for decoding responses (Node.js only). See [axios](https://github.com/axios/axios#response-schema) documentation for more.",
        type: "String",
        default: "utf8"
      },
      xsrfCookieName: {
        description: "The name of the cookie to use as a value for xsrf token",
        type: "String",
        default: "XSRF-TOKEN"
      },
      xsrfHeaderName: {
        description: "The name of the http header that carries the xsrf token value",
        type: "String",
        default: "X-XSRF-TOKEN"
      },
      onUploadProgress: {
        description: "Allows handling of progress events for uploads browser only",
        type: "Function"
      },
      onDownloadProgress: {
        description: "Allows handling of progress events for downloads browser only",
        type: "Function"
      },
      maxContentLength: {
        description: "Defines the max size of the http response content in bytes allowed in node.js",
        type: "Number"
      },
      maxBodyLength: {
        description: "(Node only option) defines the max size of the http request content in bytes allowed",
        type: "Number"
      },
      validateStatus: {
        description: "Defines whether to resolve or reject the promise for a give HTTP response status code. See [axios](https://github.com/axios/axios#response-schema) documentation for more.",
        type: "Function"
      },
      maxRedirects: {
        description: "Defines the maximum number of redirects to follow in node.js",
        type: "Number",
        default: 5
      },
      socketPath: {
        description: "Defines a UNIX Socket to be used in node.js. See [axios](https://github.com/axios/axios#response-schema) documentation for more.",
        type: "String"
      },
      httpAgent: {
        description: "Define a custom agent to be used when performing http. See [axios](https://github.com/axios/axios#response-schema) documentation for more.",
        type: "Object"
      },
      httpsAgent: {
        description: "Define a custom agent to be used when performing https. See [axios](https://github.com/axios/axios#response-schema) documentation for more.",
        type: "Object"
      },
      proxy: {
        description: "Defines the hostname, port, and protocol of the proxy server. See [axios](https://github.com/axios/axios#response-schema) documentation for more.",
        type: "Object"
      },
      cancelToken: {
        description: "Specifies a cancel token that can be used to cancel the request. See [axios](https://github.com/axios/axios#response-schema) documentation for more.",
        type: "Object"
      },
      signal: {
        description: "an alternative way to cancel Axios requests using AbortController",
        type: "Object"
      },
      decompress: {
        description: "indicates whether or not the response body should be decompressed automatically. See [axios](https://github.com/axios/axios#response-schema) documentation for more.",
        type: "Boolean",
        default: true
      },
      insecureHTTPParser: {
        description: "Indicates where to use an insecure HTTP parser that accepts invalid HTTP headers. See [axios](https://github.com/axios/axios#response-schema) documentation for more.",
        type: "Object"
      }
    };
  }
}
class SRequest extends SClass {
  constructor(params, settings) {
    super(__deepMerge({}, settings !== null && settings !== void 0 ? settings : {}));
    this._defaultRequestParams = {};
    this._currentRequestSettings = {};
    this._requestsCount = 0;
    this._defaultRequestParams = SRequestParamsInterface.apply(params !== null && params !== void 0 ? params : {});
  }
  _formatSuccessResponse(response) {
    let finalResponse = response.data;
    response.headers["content-type"] || "text/plain";
    try {
      finalResponse = JSON.parse(response.data);
    } catch (e) {
    }
    response.data = finalResponse;
    this._responsesArray.push(response);
    const lastResponse = this._responsesArray.slice(-1)[0];
    if (this._requestsCount >= this._currentRequestSettings.sendCount) {
      return {
        status: lastResponse.status,
        statusText: lastResponse.statusText,
        data: lastResponse.data,
        count: this._responsesArray.length,
        axiosResponse: lastResponse,
        axiosResponses: this._responsesArray
      };
    } else {
      return this.send();
    }
  }
  _formatErrorResponse(error2) {
    const lastResponse = this._responsesArray.slice(-1)[0];
    const data2 = {
      count: this._responsesArray.length,
      axiosResponse: lastResponse,
      axiosResponses: this._responsesArray
    };
    if (error2.response) {
      data2.status = error2.response.status;
      data2.statusText = error2.response.statusText;
      data2.data = error2.response.data;
    } else if (error2.request) {
      data2.status = 404;
      data2.statusText = "Not Found";
      data2.data = null;
    } else {
      data2.status = 404;
      data2.statusText = "Not Found";
      data2.data = error2.message;
    }
    return data2;
  }
  _send(requestSettings = {}) {
    return new Promise((resolve, reject) => {
      this._requestsCount++;
      requestSettings = __deepMerge(this._defaultRequestParams, requestSettings, {
        sendCount: 0
      });
      if (requestSettings.beforeSend) {
        requestSettings = requestSettings.beforeSend(requestSettings, this._requestsCount);
      }
      this._currentRequestSettings = Object.assign(requestSettings);
      __axios(Object.assign({ validateStatus: function() {
        return true;
      } }, requestSettings)).then((response) => {
        resolve(this._formatSuccessResponse(response));
      }).catch((error2) => {
        resolve(this._formatErrorResponse(error2));
      });
    });
  }
  retry() {
    return this.send();
  }
  send(requestSettings = {}) {
    return new Promise((resolve, reject) => {
      this._requestsCount = 0;
      this._responsesArray = [];
      resolve(this._send(requestSettings));
    });
  }
}
class ApiNav extends SLitComponent {
  constructor() {
    super({
      shadowDom: false
    });
    __publicField(this, "_openedNamespaces", []);
    __publicField(this, "_menuStack", {});
    __publicField(this, "_menuStates", {});
  }
  async firstUpdated() {
    var _a3;
    const request2 = new SRequest({
      url: "/docmap.json",
      method: "get"
    });
    let _dispatchTimeout;
    this.addEventListener("actual", (e) => {
      console.log("ACTUAL", e.target);
      for (let [key, value] of Object.entries(this._menuStates)) {
        if (e.target.getAttribute("namespace").startsWith(key + ".")) {
          value.opened = true;
        }
      }
      if (_dispatchTimeout)
        return;
      _dispatchTimeout = setTimeout(() => {
        e.target.dispatchEvent(
          new CustomEvent("actual", {
            bubbles: true
          })
        );
      }, 1e3);
    });
    this._menuStates = JSON.parse(
      (_a3 = window.localStorage.getItem("apiNavStates")) != null ? _a3 : "{}"
    );
    const cachedNav = {};
    if (Object.keys(cachedNav).length) {
      this._menuStack = cachedNav;
      this.state.loaded = true;
    }
    const res = await request2.send();
    const types2 = [];
    res.data.map = __filter(res.data.map, (key, item) => {
      var _a4, _b2, _c2, _d2;
      const supportedTypes = [
        "function",
        "class",
        "cssmixin",
        "postcssmixin",
        "cssfunction",
        "postcssfunction",
        "object",
        "customelement",
        "feature"
      ];
      let type = (_d2 = (_c2 = (_b2 = (_a4 = item.type) == null ? void 0 : _a4.types) == null ? void 0 : _b2[0]) == null ? void 0 : _c2.type) != null ? _d2 : item.type;
      if (!type)
        return false;
      if (types2.indexOf(type.toLowerCase()) === -1)
        types2.push(type.toLowerCase());
      if (supportedTypes.indexOf(type.toLowerCase()) === -1)
        return false;
      return true;
    });
    this._menuStack = {};
    Object.keys(res.data.map).forEach((namespace) => {
      if (!namespace.match(/^@coffeekraken/))
        return;
      __set(this._menuStack, namespace, res.data.map[namespace]);
    });
    this.state.loaded = true;
    this.requestUpdate();
  }
  _isAcive(namespace) {
    var _a3;
    return (_a3 = this._menuStates[namespace]) == null ? void 0 : _a3.opened;
  }
  _toggle(namespace) {
    if (!this._menuStates[namespace]) {
      this._menuStates[namespace] = {
        opened: true
      };
    } else {
      this._menuStates[namespace].opened = !this._menuStates[namespace].opened;
    }
    window.localStorage.setItem(
      "apiNavStates",
      JSON.stringify(this._menuStates)
    );
    this.requestUpdate();
  }
  _renderList(obj2, currentNamespace = "", level = 0) {
    if (!obj2)
      return "";
    const itemsKeys = Object.keys(obj2);
    const items = itemsKeys.map((itemName) => {
      const itemObj = obj2[itemName];
      const itemNamespace = `${currentNamespace ? `${currentNamespace}.` : ""}${itemName}`;
      if (!this._menuStates[itemNamespace]) {
        this._menuStates[itemNamespace] = {
          opened: false
        };
      }
      if (itemObj.name && itemObj.namespace) {
        return html`
          <li>
            <div class="s-flex">
              <a
                href="/api/${itemNamespace}"
                namespace="${itemNamespace}"
                class="s-link:stretch s-order:2"
                >${itemObj.name}</a
              >
              <i
                class="s-icon:file-${itemObj.extension} s-tc:accent s-until:sibling:loading s-mie:10"
              ></i>
              <div
                class="s-loader:spinner s-color:accent s-mie:10 s-float:right s-when:siblings:loading"
              ></div>
            </div>
          </li>
        `;
      } else {
        return html`
          <li
            class="${level === 0 || this._isAcive(itemNamespace) ? "active" : ""}"
          >
            <div
              @click=${() => {
          this._toggle(itemNamespace);
        }}
            >
              <i
                class="s-icon:folder-opened s-tc:complementary s-when:grandparent:active"
              ></i>
              <i class="s-icon:folder"></i>
              ${itemName}
            </div>
            ${this._renderList(
          get(this._menuStack, itemNamespace),
          itemNamespace,
          level + 1
        )}
          </li>
        `;
      }
    });
    return html`
      <ul class="${!currentNamespace ? "s-fs-tree" : ""}">
        ${items}
      </ul>
    `;
  }
  render() {
    if (!this.state.loaded) {
      return html`
        <div>
          <i class="s-loader:spinner s-color:accent"></i>
          &nbsp;
          <p class="s-typo:p s-display:inline-block">
            Loading API navigation.<br />Please wait...
          </p>
        </div>
      `;
    }
    return html`
      <div class="${this.componentUtils.className("")}">
        ${this._renderList(this._menuStack)}
      </div>
    `;
  }
}
__publicField(ApiNav, "state", {
  loaded: false
});
(() => {
  if (!customElements.get("api-nav")) {
    customElements.define("api-nav", ApiNav);
  }
})();
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const PartType = {
  ATTRIBUTE: 1,
  CHILD: 2,
  PROPERTY: 3,
  BOOLEAN_ATTRIBUTE: 4,
  EVENT: 5,
  ELEMENT: 6
};
const directive = (c) => (...values) => ({
  ["_$litDirective$"]: c,
  values
});
class Directive {
  constructor(_partInfo) {
  }
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _$initialize(part, parent, attributeIndex) {
    this.__part = part;
    this._$parent = parent;
    this.__attributeIndex = attributeIndex;
  }
  _$resolve(part, props) {
    return this.update(part, props);
  }
  update(_part, props) {
    return this.render(...props);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const HTML_RESULT = 1;
class UnsafeHTMLDirective extends Directive {
  constructor(partInfo) {
    super(partInfo);
    this._value = nothing;
    if (partInfo.type !== PartType.CHILD) {
      throw new Error(`${this.constructor.directiveName}() can only be used in child bindings`);
    }
  }
  render(value) {
    if (value === nothing || value == null) {
      this._templateResult = void 0;
      return this._value = value;
    }
    if (value === noChange) {
      return value;
    }
    if (typeof value != "string") {
      throw new Error(`${this.constructor.directiveName}() called with a non-string value`);
    }
    if (value === this._value) {
      return this._templateResult;
    }
    this._value = value;
    const strings = [value];
    strings.raw = strings;
    return this._templateResult = {
      ["_$litType$"]: this.constructor.resultType,
      strings,
      values: []
    };
  }
}
UnsafeHTMLDirective.directiveName = "unsafeHTML";
UnsafeHTMLDirective.resultType = HTML_RESULT;
const unsafeHTML = directive(UnsafeHTMLDirective);
class SFiltrableInputComponentInterface extends SInterface {
  static get _definition() {
    return {
      items: {
        description: 'Specify an array of items to use in your filtrable list. Can be a JSON string, a function that take an object with the "value" property and must return an array of items to use',
        type: "String|Function"
      },
      value: {
        description: "Specify the attribute in your items to use as a value. Can be also a function that will be called with an object containing the selected item and must return the string you want to use as value",
        type: "String",
        default: "value"
      },
      label: {
        description: "Specify the attribute in your items to use as a label. Can be also a function that will be called with an object containing the selected item and must return the string you want to use as label",
        type: "String|Function",
        default: "value"
      },
      emptyText: {
        description: 'Specify the text to use for the default "empty" (no result) state',
        type: "String",
        default: "No item to display"
      },
      searchValuePreprocess: {
        description: "Specify a function used to preprocess the value just before actually searching through the items",
        type: "Function"
      },
      loadingText: {
        description: 'Specify the text to use for the default "loading" state',
        type: "String",
        default: "Loading please wait..."
      },
      filter: {
        description: "Specify a function to use to filter the items. Must return the filtered list of items",
        type: "Function"
      },
      filtrable: {
        description: 'Specify all the properties of your "item" to use as source for the filtrable process',
        type: {
          type: "Array<String>",
          splitChars: [","]
        },
        default: []
      },
      showKeywords: {
        description: 'Specify if you want to display the "keywords" section on top of the list results',
        type: "Boolean",
        default: false
      },
      templates: {
        description: 'Specify either an object with properties like "item", "empty" and "loading", or a function returning the good template depending on tne "type" argument property',
        type: "Object|Function"
      },
      closeTimeout: {
        description: "Specify the duration before closing the list when having selected an item",
        type: "Number",
        default: 100
      },
      interactive: {
        description: "Specify if your items in the list are interactive or not to let the user click and interact with them",
        type: "Boolean",
        default: false
      },
      closeOnSelect: {
        description: "Specify if you wantr to close the list when selecting an item",
        type: "Boolean",
        default: false
      },
      resetOnSelect: {
        description: "Specify if you want your filtrable input to be reseted on select",
        type: "Boolean",
        default: true
      },
      notSelectable: {
        description: "Specify if you want the items to be not selectable",
        type: "Boolean",
        default: false
      },
      maxItems: {
        description: "Specify the maximum number of items to display at first in the list",
        type: "Number",
        default: 25
      },
      classes: {
        description: "Specify some additional classes to add to the component elements",
        type: "Object",
        default: {}
      },
      inline: {
        description: "Specify if you want the filterable input list to be always displayed and inline in the html",
        type: "Boolean",
        default: false,
        physical: true
      }
    };
  }
}
var isff = typeof navigator !== "undefined" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : false;
function addEvent(object, event, method, useCapture) {
  if (object.addEventListener) {
    object.addEventListener(event, method, useCapture);
  } else if (object.attachEvent) {
    object.attachEvent("on".concat(event), function() {
      method(window.event);
    });
  }
}
function getMods(modifier, key) {
  var mods = key.slice(0, key.length - 1);
  for (var i2 = 0; i2 < mods.length; i2++) {
    mods[i2] = modifier[mods[i2].toLowerCase()];
  }
  return mods;
}
function getKeys(key) {
  if (typeof key !== "string")
    key = "";
  key = key.replace(/\s/g, "");
  var keys3 = key.split(",");
  var index = keys3.lastIndexOf("");
  for (; index >= 0; ) {
    keys3[index - 1] += ",";
    keys3.splice(index, 1);
    index = keys3.lastIndexOf("");
  }
  return keys3;
}
function compareArray(a1, a22) {
  var arr1 = a1.length >= a22.length ? a1 : a22;
  var arr2 = a1.length >= a22.length ? a22 : a1;
  var isIndex = true;
  for (var i2 = 0; i2 < arr1.length; i2++) {
    if (arr2.indexOf(arr1[i2]) === -1)
      isIndex = false;
  }
  return isIndex;
}
var _keyMap = {
  backspace: 8,
  tab: 9,
  clear: 12,
  enter: 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  "\u21EA": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": isff ? 173 : 189,
  "=": isff ? 61 : 187,
  ";": isff ? 59 : 186,
  "'": 222,
  "[": 219,
  "]": 221,
  "\\": 220
};
var _modifier = {
  "\u21E7": 16,
  shift: 16,
  "\u2325": 18,
  alt: 18,
  option: 18,
  "\u2303": 17,
  ctrl: 17,
  control: 17,
  "\u2318": 91,
  cmd: 91,
  command: 91
};
var modifierMap = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
};
var _mods = {
  16: false,
  18: false,
  17: false,
  91: false
};
var _handlers = {};
for (var k = 1; k < 20; k++) {
  _keyMap["f".concat(k)] = 111 + k;
}
var _downKeys = [];
var winListendFocus = false;
var _scope = "all";
var elementHasBindEvent = [];
var code = function code2(x2) {
  return _keyMap[x2.toLowerCase()] || _modifier[x2.toLowerCase()] || x2.toUpperCase().charCodeAt(0);
};
function setScope(scope) {
  _scope = scope || "all";
}
function getScope() {
  return _scope || "all";
}
function getPressedKeyCodes() {
  return _downKeys.slice(0);
}
function filter(event) {
  var target = event.target || event.srcElement;
  var tagName = target.tagName;
  var flag = true;
  if (target.isContentEditable || (tagName === "INPUT" || tagName === "TEXTAREA" || tagName === "SELECT") && !target.readOnly) {
    flag = false;
  }
  return flag;
}
function isPressed(keyCode) {
  if (typeof keyCode === "string") {
    keyCode = code(keyCode);
  }
  return _downKeys.indexOf(keyCode) !== -1;
}
function deleteScope(scope, newScope) {
  var handlers;
  var i2;
  if (!scope)
    scope = getScope();
  for (var key in _handlers) {
    if (Object.prototype.hasOwnProperty.call(_handlers, key)) {
      handlers = _handlers[key];
      for (i2 = 0; i2 < handlers.length; ) {
        if (handlers[i2].scope === scope)
          handlers.splice(i2, 1);
        else
          i2++;
      }
    }
  }
  if (getScope() === scope)
    setScope(newScope || "all");
}
function clearModifier(event) {
  var key = event.keyCode || event.which || event.charCode;
  var i2 = _downKeys.indexOf(key);
  if (i2 >= 0) {
    _downKeys.splice(i2, 1);
  }
  if (event.key && event.key.toLowerCase() === "meta") {
    _downKeys.splice(0, _downKeys.length);
  }
  if (key === 93 || key === 224)
    key = 91;
  if (key in _mods) {
    _mods[key] = false;
    for (var k2 in _modifier) {
      if (_modifier[k2] === key)
        hotkeys[k2] = false;
    }
  }
}
function unbind(keysInfo) {
  if (typeof keysInfo === "undefined") {
    Object.keys(_handlers).forEach(function(key) {
      return delete _handlers[key];
    });
  } else if (Array.isArray(keysInfo)) {
    keysInfo.forEach(function(info) {
      if (info.key)
        eachUnbind(info);
    });
  } else if (typeof keysInfo === "object") {
    if (keysInfo.key)
      eachUnbind(keysInfo);
  } else if (typeof keysInfo === "string") {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    var scope = args[0], method = args[1];
    if (typeof scope === "function") {
      method = scope;
      scope = "";
    }
    eachUnbind({
      key: keysInfo,
      scope,
      method,
      splitKey: "+"
    });
  }
}
var eachUnbind = function eachUnbind2(_ref) {
  var key = _ref.key, scope = _ref.scope, method = _ref.method, _ref$splitKey = _ref.splitKey, splitKey = _ref$splitKey === void 0 ? "+" : _ref$splitKey;
  var multipleKeys = getKeys(key);
  multipleKeys.forEach(function(originKey) {
    var unbindKeys = originKey.split(splitKey);
    var len = unbindKeys.length;
    var lastKey = unbindKeys[len - 1];
    var keyCode = lastKey === "*" ? "*" : code(lastKey);
    if (!_handlers[keyCode])
      return;
    if (!scope)
      scope = getScope();
    var mods = len > 1 ? getMods(_modifier, unbindKeys) : [];
    _handlers[keyCode] = _handlers[keyCode].filter(function(record) {
      var isMatchingMethod = method ? record.method === method : true;
      return !(isMatchingMethod && record.scope === scope && compareArray(record.mods, mods));
    });
  });
};
function eventHandler(event, handler, scope, element) {
  if (handler.element !== element) {
    return;
  }
  var modifiersMatch;
  if (handler.scope === scope || handler.scope === "all") {
    modifiersMatch = handler.mods.length > 0;
    for (var y in _mods) {
      if (Object.prototype.hasOwnProperty.call(_mods, y)) {
        if (!_mods[y] && handler.mods.indexOf(+y) > -1 || _mods[y] && handler.mods.indexOf(+y) === -1) {
          modifiersMatch = false;
        }
      }
    }
    if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === "*") {
      if (handler.method(event, handler) === false) {
        if (event.preventDefault)
          event.preventDefault();
        else
          event.returnValue = false;
        if (event.stopPropagation)
          event.stopPropagation();
        if (event.cancelBubble)
          event.cancelBubble = true;
      }
    }
  }
}
function dispatch(event, element) {
  var asterisk = _handlers["*"];
  var key = event.keyCode || event.which || event.charCode;
  if (!hotkeys.filter.call(this, event))
    return;
  if (key === 93 || key === 224)
    key = 91;
  if (_downKeys.indexOf(key) === -1 && key !== 229)
    _downKeys.push(key);
  ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach(function(keyName) {
    var keyNum = modifierMap[keyName];
    if (event[keyName] && _downKeys.indexOf(keyNum) === -1) {
      _downKeys.push(keyNum);
    } else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) {
      _downKeys.splice(_downKeys.indexOf(keyNum), 1);
    } else if (keyName === "metaKey" && event[keyName] && _downKeys.length === 3) {
      if (!(event.ctrlKey || event.shiftKey || event.altKey)) {
        _downKeys = _downKeys.slice(_downKeys.indexOf(keyNum));
      }
    }
  });
  if (key in _mods) {
    _mods[key] = true;
    for (var k2 in _modifier) {
      if (_modifier[k2] === key)
        hotkeys[k2] = true;
    }
    if (!asterisk)
      return;
  }
  for (var e in _mods) {
    if (Object.prototype.hasOwnProperty.call(_mods, e)) {
      _mods[e] = event[modifierMap[e]];
    }
  }
  if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState("AltGraph")) {
    if (_downKeys.indexOf(17) === -1) {
      _downKeys.push(17);
    }
    if (_downKeys.indexOf(18) === -1) {
      _downKeys.push(18);
    }
    _mods[17] = true;
    _mods[18] = true;
  }
  var scope = getScope();
  if (asterisk) {
    for (var i2 = 0; i2 < asterisk.length; i2++) {
      if (asterisk[i2].scope === scope && (event.type === "keydown" && asterisk[i2].keydown || event.type === "keyup" && asterisk[i2].keyup)) {
        eventHandler(event, asterisk[i2], scope, element);
      }
    }
  }
  if (!(key in _handlers))
    return;
  for (var _i = 0; _i < _handlers[key].length; _i++) {
    if (event.type === "keydown" && _handlers[key][_i].keydown || event.type === "keyup" && _handlers[key][_i].keyup) {
      if (_handlers[key][_i].key) {
        var record = _handlers[key][_i];
        var splitKey = record.splitKey;
        var keyShortcut = record.key.split(splitKey);
        var _downKeysCurrent = [];
        for (var a3 = 0; a3 < keyShortcut.length; a3++) {
          _downKeysCurrent.push(code(keyShortcut[a3]));
        }
        if (_downKeysCurrent.sort().join("") === _downKeys.sort().join("")) {
          eventHandler(event, record, scope, element);
        }
      }
    }
  }
}
function isElementBind(element) {
  return elementHasBindEvent.indexOf(element) > -1;
}
function hotkeys(key, option, method) {
  _downKeys = [];
  var keys3 = getKeys(key);
  var mods = [];
  var scope = "all";
  var element = document;
  var i2 = 0;
  var keyup = false;
  var keydown = true;
  var splitKey = "+";
  var capture = false;
  if (method === void 0 && typeof option === "function") {
    method = option;
  }
  if (Object.prototype.toString.call(option) === "[object Object]") {
    if (option.scope)
      scope = option.scope;
    if (option.element)
      element = option.element;
    if (option.keyup)
      keyup = option.keyup;
    if (option.keydown !== void 0)
      keydown = option.keydown;
    if (option.capture !== void 0)
      capture = option.capture;
    if (typeof option.splitKey === "string")
      splitKey = option.splitKey;
  }
  if (typeof option === "string")
    scope = option;
  for (; i2 < keys3.length; i2++) {
    key = keys3[i2].split(splitKey);
    mods = [];
    if (key.length > 1)
      mods = getMods(_modifier, key);
    key = key[key.length - 1];
    key = key === "*" ? "*" : code(key);
    if (!(key in _handlers))
      _handlers[key] = [];
    _handlers[key].push({
      keyup,
      keydown,
      scope,
      mods,
      shortcut: keys3[i2],
      method,
      key: keys3[i2],
      splitKey,
      element
    });
  }
  if (typeof element !== "undefined" && !isElementBind(element) && window) {
    elementHasBindEvent.push(element);
    addEvent(element, "keydown", function(e) {
      dispatch(e, element);
    }, capture);
    if (!winListendFocus) {
      winListendFocus = true;
      addEvent(window, "focus", function() {
        _downKeys = [];
      }, capture);
    }
    addEvent(element, "keyup", function(e) {
      dispatch(e, element);
      clearModifier(e);
    }, capture);
  }
}
function trigger(shortcut) {
  var scope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all";
  Object.keys(_handlers).forEach(function(key) {
    var data2 = _handlers[key].find(function(item) {
      return item.scope === scope && item.shortcut === shortcut;
    });
    if (data2 && data2.method) {
      data2.method();
    }
  });
}
var _api = {
  setScope,
  getScope,
  deleteScope,
  getPressedKeyCodes,
  isPressed,
  filter,
  trigger,
  unbind,
  keyMap: _keyMap,
  modifier: _modifier,
  modifierMap
};
for (var a in _api) {
  if (Object.prototype.hasOwnProperty.call(_api, a)) {
    hotkeys[a] = _api[a];
  }
}
if (typeof window !== "undefined") {
  var _hotkeys = window.hotkeys;
  hotkeys.noConflict = function(deep) {
    if (deep && window.hotkeys === hotkeys) {
      window.hotkeys = _hotkeys;
    }
    return hotkeys;
  };
  window.hotkeys = hotkeys;
}
var hotkeys_common = hotkeys;
hotkeys_common.filter = function() {
  return true;
};
function __hotkey(hotkey, settings = {}) {
  return new SPromise(({ resolve, reject, emit, cancel }) => {
    settings = Object.assign({ element: null, keyup: false, keydown: true, once: false, splitKey: "+" }, settings);
    hotkeys_common(hotkey, settings, (e, h2) => {
      emit("press", e);
      if (settings.once)
        cancel();
    });
  }, {
    id: "hotkey"
  }).on("finally", () => {
    hotkeys_common.unbind(hotkey);
  });
}
const __css$i = ".s-filtrable-input {\n    font-size: calc(1rem * var(--s-scale, 1) * var(--s-scale-global, 1));\n    display: inline-flex;\n    flex-direction: column;\n    position: relative;\n}\n\n    .s-filtrable-input .s-filtrable-input__input {\n    }\n\n    .s-filtrable-input .s-filtrable-input__keywords,\n    .s-filtrable-input .s-filtrable-input__before,\n    .s-filtrable-input .s-filtrable-input__after {\n        flex-grow: 0;\n        width: 100%;\n    }\n\n    .s-filtrable-input .s-filtrable-input__dropdown {\n        position: absolute;\n        z-index: 10;\n        top: 100%;\n        left: 0;\n        opacity: 0;\n        max-width: calc(100vw - 100px);\n        width: 100%;\n        pointer-events: none;\n        margin: 20px 0;\n        overflow: hidden;\n        display: flex;\n        flex-direction: column;\n    }\n\n    .s-filtrable-input:focus-within .s-filtrable-input__dropdown {\n        pointer-events: all;\n        opacity: 1;\n    }\n\n    .s-filtrable-input.s-filtrable-input--top .s-filtrable-input__dropdown {\n            top: auto;\n            bottom: 100%;\n        }\n\n    .s-filtrable-input .s-filtrable-input__input:focus + .s-filtrable-input__dropdown,\n    .s-filtrable-input .s-filtrable-input__dropdown:focus,\n    .s-filtrable-input .s-filtrable-input__dropdown:focus-within {\n        opacity: 1;\n        pointer-events: all !important;\n    }\n\n    .s-filtrable-input .s-filtrable-input__list {\n        overflow-x: hidden;\n        overflow-y: auto;\n    }\n\n    .s-filtrable-input .s-filtrable-input__list-item {\n        position: relative;\n        -webkit-user-select: none;\n           -moz-user-select: none;\n                user-select: none;\n    }\n\n    .s-filtrable-input:not([interactive]) .s-filtrable-input__list-item {\n        cursor: pointer;\n    }\n\n    .s-filtrable-input:not([interactive]) .s-filtrable-input__list-item * {\n            pointer-events: none;\n        }\n\n.s-filtrable-input[inline] .s-filtrable-input__dropdown {\n        position: static;\n        margin: 0;\n        max-width: 100%;\n        pointer-events: all;\n        opacity: 1;\n    }\n";
var __awaiter$h = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SFiltrableInputComponent extends SLitComponent {
  constructor() {
    super(__deepMerge({
      name: "s-filtrable-input",
      interface: SFiltrableInputComponentInterface
    }));
    this.preselectedItems = [];
    this.selectedItems = [];
    this.filteredItems = [];
    this._templatesFromHtml = {};
    this._baseTemplates = {};
  }
  static get styles() {
    return css$1`
            ${unsafeCSS(__css$i)}
        `;
  }
  static get properties() {
    return SLitComponent.propertiesFromInterface({}, SFiltrableInputComponentInterface);
  }
  static get state() {
    return {
      displayedMaxItems: 0,
      value: "",
      isActive: false,
      isLoading: false,
      items: []
    };
  }
  mount() {
    return __awaiter$h(this, void 0, void 0, function* () {
      this.state.displayedMaxItems = this.props.maxItems;
      if (this.props.items && typeof this.props.items === "string") {
        try {
          this.state.items = JSON.parse(this.props.items);
        } catch (e) {
          const $itemsElm = document.querySelector(this.props.items);
          if ($itemsElm) {
            this.state.items = JSON.parse($itemsElm.innerHTML.trim());
          }
        }
        this.requestUpdate();
        this.componentUtils.dispatchEvent("items", {
          detail: {
            items: this.state.items
          }
        });
      }
      this._baseTemplates = ({ type, item, html: html2 }) => {
        switch (type) {
          case "item":
            return html2`
                        <div class="${this.componentUtils.className("__item")}">
                            ${unsafeHTML(typeof this.props.label === "function" ? this.props.label({ item }) : item[this.props.label])}
                        </div>
                    `;
          case "empty":
            return html2`
                        <div
                            class="${this.componentUtils.className("__empty")}"
                        >
                            ${this.props.emptyText}
                        </div>
                    `;
          case "loading":
            return html2`
                        <div
                            class="${this.componentUtils.className("__loading")}"
                        >
                            ${this.props.loadingText}
                        </div>
                    `;
        }
      };
      if (__isFocusWithin(this)) {
        setTimeout(() => {
          this.$input.focus();
        });
      }
    });
  }
  firstUpdated() {
    var _a3, _b2;
    return __awaiter$h(this, void 0, void 0, function* () {
      this.$input = this.querySelector("input");
      this.componentUtils.fastdom.mutate(() => {
        this.$input.setAttribute("autocomplete", "off");
      });
      this.$form = this.$input.form;
      (_a3 = this.$form) === null || _a3 === void 0 ? void 0 : _a3.addEventListener("submit", (e) => {
        if (this.state.isActive) {
          e.preventDefault();
        }
      });
      this._grabTemplates();
      if (!this.props.bare) {
        (_b2 = this.$input.classList) === null || _b2 === void 0 ? void 0 : _b2.add("s-input");
      }
      this.$input.addEventListener("keyup", (e) => {
        if (this.state.isActive) {
          return;
        }
        this.state.isActive = true;
        const value = e.target.value;
        this.state.value = value;
        this.state.displayedMaxItems = this.props.maxItems;
        this.filterItems();
      });
      this.$input.addEventListener("focus", (e) => {
        if (this.state.isActive) {
          return;
        }
        const value = e.target.value;
        this.state.value = value;
        this.state.isActive = true;
        this.filterItems();
        this._updateListSizeAndPosition();
      });
      this.$input.classList.add(...this.componentUtils.className("__input").split(" "));
      if (this.props.classes.input) {
        this.$input.classList.add(this.props.classes.input);
      }
      this.$container = this;
      this.$container.classList.add("s-filtrable-input");
      this.$container.classList.add(...this.componentUtils.className().split(" "));
      if (this.props.classes.container) {
        this.$container.classList.add(this.props.classes.container);
      }
      this.$list = this.querySelector("ul");
      this.$dropdown = this.querySelector(`.s-filtrable-input__dropdown`);
      this.prepend(this.$input);
      this.filterItems();
      document.addEventListener("scroll", () => {
        this._updateListSizeAndPosition();
      });
      this._updateListSizeAndPosition();
      __onScrollEnd(this.$list, () => {
        var _a4;
        this.state.displayedMaxItems = ((_a4 = this.state.displayedMaxItems) !== null && _a4 !== void 0 ? _a4 : 0) + this.props.maxItems;
        this.filterItems(false);
      });
      __hotkey("escape").on("press", (e) => {
        e.preventDefault();
        if (!this.state.isActive)
          return;
        this.close();
      });
      __hotkey("up").on("press", (e) => __awaiter$h(this, void 0, void 0, function* () {
        e.preventDefault();
        yield __wait();
        if (!this.state.isActive)
          return;
        if (!this.filteredItems.length)
          return;
        if (!this.preselectedItems.length) {
          this.preselectedItems.push(this.filteredItems[this.filteredItems.length - 1]);
        } else {
          const currentIdx = this.filteredItems.indexOf(this.preselectedItems[0]);
          if (currentIdx === -1) {
            return;
          }
          const newIdx = currentIdx - 1;
          if (newIdx < 0)
            return;
          this.preselectedItems = [];
          this.preselectedItems.push(this.filteredItems[newIdx]);
        }
        this.requestUpdate();
        const $item = this.$list.children[this.filteredItems.indexOf(this.preselectedItems[0])];
        $item.focus();
      }));
      __hotkey("down").on("press", (e) => __awaiter$h(this, void 0, void 0, function* () {
        e.preventDefault();
        yield __wait();
        if (!this.state.isActive)
          return;
        if (!this.filteredItems.length)
          return;
        if (!this.preselectedItems.length) {
          this.preselectedItems.push(this.filteredItems[0]);
        } else {
          const currentIdx = this.filteredItems.indexOf(this.preselectedItems[0]);
          if (currentIdx === -1) {
            return;
          }
          const newIdx = currentIdx + 1;
          if (newIdx > this.filteredItems.length - 1)
            return;
          this.preselectedItems = [];
          this.preselectedItems.push(this.filteredItems[newIdx]);
        }
        this.requestUpdate();
        const $item = this.$list.children[this.filteredItems.indexOf(this.preselectedItems[0])];
        $item.focus();
      }));
      __hotkey("return").on("press", (e) => {
        if (!this.state.isActive)
          return;
        this.validateAndClose();
      });
      if (this.state.value) {
        this.$input.value = this.state.value;
      }
      if (this.$input.value) {
        this.state.value = this.$input.value;
        this.filterItems(true);
      }
    });
  }
  _grabTemplates() {
    this.querySelectorAll("template").forEach(($template) => {
      if (!$template.hasAttribute("type"))
        return;
      this._templatesFromHtml[$template.getAttribute("type")] = $template.innerHTML;
    });
  }
  _getTemplate(type) {
    if (this.props.templates) {
      const res = this.props.templates({
        type,
        html
      });
      if (res)
        return res;
    }
    if (this._templatesFromHtml[type]) {
      return html` ${unsafeHTML(this._templatesFromHtml[type])} `;
    }
    return this._baseTemplates({
      type,
      html
    });
  }
  validate() {
    var _a3;
    this.selectedItems = this.preselectedItems;
    this.preselectedItems = [];
    if (!this.selectedItems.length)
      return;
    const item = this.selectedItems[0];
    const itemProps = __deepMerge(Object.assign({}, this.props), (_a3 = item.props) !== null && _a3 !== void 0 ? _a3 : {});
    if (!item.preventSet) {
      if (typeof itemProps.value === "string" && item[itemProps.value]) {
        this.$input.value = __stripTags(
          item[itemProps.value]
        );
      } else if (typeof itemProps.value === "function") {
        const v = itemProps.value({
          items: [item]
        });
        if (typeof v !== "string") {
          throw new Error(`<red>[s-filtrable-input]</red> Sorry but the returned value "<yellow>${v}</yellow>" has to be a string...`);
        }
        this.$input.value = __stripTags(v);
      }
    }
    let selectedItemItem = 0;
    for (let i2 = 0; i2 < this.filteredItems.length; i2++) {
      const itemObj = this.filteredItems[i2];
      if (itemObj.id === item.id) {
        selectedItemItem = i2;
        break;
      }
    }
    const $selectedItem = this.$list.children[selectedItemItem];
    this.componentUtils.dispatchEvent("select", {
      detail: {
        item: this.selectedItems[0],
        items: this.selectedItems,
        $elm: $selectedItem
      }
    });
    this.state.value = this.$input.value;
    this.requestUpdate();
    if (this.props.closeOnSelect && !item.preventClose) {
      this.close();
    }
    if (this.props.resetOnSelect && !item.preventReset) {
      this.reset();
      this.filterItems();
    }
  }
  validateAndClose() {
    this.validate();
    setTimeout(() => {
      this.close();
    }, this.props.closeTimeout);
  }
  resetSelected() {
    this.preselectedItems = [];
    this.selectedItems = [];
  }
  reset() {
    this.resetSelected();
    this.$input.value = "";
  }
  close() {
    __cursorToEnd(this.$input);
    this.$input.blur();
    this.state.isActive = false;
  }
  refreshItems() {
    return __awaiter$h(this, void 0, void 0, function* () {
      if (typeof this.props.items === "function") {
        this.state.isLoading = true;
        this.requestUpdate();
        const items = yield this.props.items({
          value: this.$input.value
        });
        if (__isPlainObject(items)) {
          this.state.items = Object.values(items);
        } else if (Array.isArray(items)) {
          this.state.items = items;
        } else {
          throw new Error(`Sorry but the "items" MUST be an Array...`);
        }
        this.requestUpdate();
        this.componentUtils.dispatchEvent("items", {
          detail: {
            items: this.state.items
          }
        });
      }
    });
  }
  filterItems(needUpdate = true) {
    return __awaiter$h(this, void 0, void 0, function* () {
      if (needUpdate)
        yield this.refreshItems();
      this.resetSelected();
      let items = this.state.items;
      let searchValue = this.state.value;
      if (this.props.searchValuePreprocess) {
        searchValue = this.props.searchValuePreprocess(searchValue);
      }
      let filteredItems = items;
      if (this.props.filter) {
        filteredItems = yield this.props.filter(filteredItems, searchValue, this.state);
      } else {
        let matchedItemsCount = 0;
        filteredItems = filteredItems.filter((item) => {
          if (matchedItemsCount >= this.state.displayedMaxItems)
            return false;
          if (!this.props.filtrable.length)
            return true;
          let matchFilter = false;
          for (let i2 = 0; i2 < Object.keys(item).length; i2++) {
            const propName = Object.keys(item)[i2], propValue = item[propName];
            if (typeof propValue !== "string")
              continue;
            if (this.props.filtrable.indexOf(propName) !== -1) {
              const reg = new RegExp(searchValue.split(" ").join("|"), "gi");
              if (propValue.match(reg)) {
                matchFilter = true;
                if (searchValue && searchValue !== "") {
                  const reg2 = new RegExp(searchValue.split(" ").join("|"), "gi");
                  const finalString = propValue.replace(reg2, (str2) => {
                    return `<span class="${this.componentUtils.className("__list-item-highlight")} s-highlight"
                                                    >${str2}</span>`;
                  });
                  item[propName] = finalString;
                }
              }
            }
          }
          if (matchFilter) {
            matchedItemsCount++;
          }
          return matchFilter;
        });
      }
      this.filteredItems = filteredItems;
      this.state.isLoading = false;
      this.requestUpdate();
    });
  }
  preselectAndValidate(item) {
    this._setPreselectedItem(item);
    this.validate();
  }
  preselectValidateAndClose(item) {
    this._setPreselectedItem(item);
    this.validateAndClose();
  }
  _setPreselectedItem(item) {
    if (this.props.notSelectable)
      return;
    !this.preselectedItems.includes(item) && this.preselectedItems.push(item);
    this.requestUpdate();
  }
  _updateListSizeAndPosition() {
    if (!this.state.isActive || this.props.inline)
      return;
    const marginTop = __getStyleProperty(this.$dropdown, "marginTop");
    __getStyleProperty(this.$dropdown, "marginLeft");
    __getStyleProperty(this.$dropdown, "marginRight");
    const marginBottom = __getStyleProperty(this.$dropdown, "marginBottom");
    const distanceTop = __distanceFromElementTopToViewportTop(this.$input);
    const distanceBottom = __distanceFromElementTopToViewportBottom(this.$input) - this.$input.clientHeight;
    let maxHeight;
    if (distanceTop > distanceBottom) {
      this.$container.classList.add("s-filtrable-input--top");
      this.$dropdown.style.top = `auto`;
      this.$dropdown.style.bottom = `calc(100% - ${marginBottom})`;
      maxHeight = distanceTop - parseInt(marginTop);
    } else {
      this.$container.classList.remove("s-filtrable-input--top");
      this.$dropdown.style.bottom = `auto`;
      this.$dropdown.style.top = `calc(100% - ${marginTop})`;
      maxHeight = distanceBottom - parseInt(marginBottom);
    }
    this.$dropdown.style.maxHeight = `${maxHeight}px`;
  }
  _removeKeyword(keyword) {
    const newValue = this.state.value.split(" ").filter((k2) => k2 !== keyword).join(" ");
    this.$input.value = newValue;
    this.state.value = newValue;
    this.filterItems();
    __cursorToEnd(this.$input);
  }
  render() {
    var _a3, _b2, _c2, _d2, _e2, _f2, _g, _h;
    return html`
            <div class="${this.componentUtils.className("")}">
                <div
                    class="${this.componentUtils.className("__dropdown")} ${this.props.classes.dropdown}"
                >
                    <div
                        class="${this.componentUtils.className("__before")} ${this.props.classes.before}"
                        tabindex="-1"
                    >
                        ${this._getTemplate("before")}
                    </div>
                    ${this.$input && this.$input.value && this.props.showKeywords ? html`
                              <div
                                  tabindex="-1"
                                  class="${this.componentUtils.className("__keywords")} ${this.props.classes.keywords}"
                              >
                                  ${this.$input.value.split(" ").filter((s2) => s2 !== "").map((keyword) => html`
                                              <span
                                                  tabindex="-1"
                                                  @click=${() => this._removeKeyword(keyword)}
                                                  class="${this.componentUtils.className("__keyword", "s-badge")}"
                                                  >${keyword}</span
                                              >
                                          `)}
                              </div>
                          ` : ""}
                    <ul
                        class="${this.componentUtils.className("__list")} ${this.props.classes.list}"
                    >
                        ${this.state.isLoading ? html`
                                  <li
                                      class="${this.componentUtils.className("__list-item")} ${this.props.classes.listItem} ${this.componentUtils.className("__list-loading")}"
                                  >
                                      ${(_c2 = (_b2 = (_a3 = this.props).templates) === null || _b2 === void 0 ? void 0 : _b2.call(_a3, {
      type: "loading",
      html
    })) !== null && _c2 !== void 0 ? _c2 : this._baseTemplates({
      type: "loading",
      html
    })}
                                  </li>
                              ` : !this.state.isLoading && this.filteredItems.length <= 0 ? html`
                                  <li
                                      class="${this.componentUtils.className("__list-item")} ${this.props.classes.listItem} ${this.componentUtils.className("__list-no-item")}"
                                  >
                                      ${(_f2 = (_e2 = (_d2 = this.props).templates) === null || _e2 === void 0 ? void 0 : _e2.call(_d2, {
      type: "empty",
      html
    })) !== null && _f2 !== void 0 ? _f2 : this._baseTemplates({
      type: "empty",
      html
    })}
                                  </li>
                              ` : !this.state.isLoading && this.filteredItems.length ? this.filteredItems.map((item, idx) => {
      var _a4, _b3, _c3;
      return idx < this.state.displayedMaxItems ? html`
                                            <li
                                                @click=${() => this.preselectAndValidate(item)}
                                                @dblclick=${() => this.preselectValidateAndClose(item)}
                                                @focus=${() => this._setPreselectedItem(item)}
                                                style="z-index: ${999999999 - idx}"
                                                tabindex="-1"
                                                class="${this.componentUtils.className("__list-item")} ${this.props.classes.listItem} ${this.selectedItems.includes(item) ? "active" : ""}"
                                                hoverable
                                            >
                                                ${(_c3 = (_b3 = (_a4 = this.props).templates) === null || _b3 === void 0 ? void 0 : _b3.call(_a4, {
        type: "item",
        html,
        unsafeHTML,
        item,
        idx
      })) !== null && _c3 !== void 0 ? _c3 : this._baseTemplates({
        type: "item",
        html,
        unsafeHTML,
        item,
        idx
      })}
                                            </li>
                                        ` : "";
    }) : ""}
                    </ul>
                    <div
                        class="${this.componentUtils.className("__after")} ${this.props.classes.after}"
                        tabindex="-1"
                    >
                        ${(_h = (_g = this.props).templates) === null || _h === void 0 ? void 0 : _h.call(_g, {
      type: "after",
      html
    })}
                    </div>
                </div>
            </div>
        `;
  }
}
function define$t(props = {}, tagName = "s-filtrable-input") {
  SLitComponent.define(tagName, SFiltrableInputComponent, props);
}
(() => {
  define$t(
    {
      items: async () => {
        await __wait(1e3);
        return [
          { title: "Hello", value: "World" },
          { title: "Plop", value: "Yop" }
        ];
      },
      templates: ({ type, item, html: html2 }) => {
        switch (type) {
          case "item":
            return html2`
                            <li class="__item">My title: ${item.title}</li>
                        `;
          case "loading":
            return html2`
                            <li class="__loading">Loading, please wait...</li>
                        `;
          case "empty":
            return html2`
                            <li class="__empty">No items found...</li>
                        `;
        }
      }
    },
    "my-cool-filtrable-input"
  );
})();
var __awaiter$g = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SFeature extends SClass {
  constructor(name2, node, settings) {
    var _a3, _b2, _c2, _d2;
    super(__deepMerge({}, settings));
    if (this.settings.style) {
      __injectStyle(this.settings.style, {
        id: `s-feature-${name2}`
      });
    }
    this.componentUtils = new SComponentUtils(node, Object.assign(Object.assign(Object.assign({}, (_a3 = this.settings) !== null && _a3 !== void 0 ? _a3 : {}), (_b2 = this.settings.componentUtils) !== null && _b2 !== void 0 ? _b2 : {}), { useTagNameForClassName: false, name: name2 }));
    this.name = name2;
    this.node = node;
    this.props = this.componentUtils.handleProps({}, {
      interface: (_c2 = this.settings.interface) !== null && _c2 !== void 0 ? _c2 : (_d2 = this.settings.componentUtils) === null || _d2 === void 0 ? void 0 : _d2.interface
    });
    this.node.classList.add(...this.componentUtils.className("").split(" "));
    this.componentUtils.waitAndExecute(
      this.props.mountWhen,
      () => __awaiter$g(this, void 0, void 0, function* () {
        var _e2;
        yield (_e2 = this.mount) === null || _e2 === void 0 ? void 0 : _e2.call(this);
        this.props.mounted = true;
      })
    );
  }
  static setDefaultProps(selector, props) {
    SComponentUtils.setDefaultProps(selector, props);
  }
  static define(name2, featureCls, defaultProps = {}) {
    this.setDefaultProps(name2, defaultProps);
    __querySelectorLive(`[${name2}]`, ($elm) => {
      new featureCls(name2, $elm, SComponentUtils.getDefaultProps(name2));
    }, {});
  }
}
class SActivateFeatureInterface extends SInterface {
  static get _definition() {
    return {
      href: {
        description: "Specify the target element(s) to activate/unactivate",
        type: "String",
        default: ""
      },
      group: {
        description: "Specify a group id for your element. This is used for things like tabs, etc...",
        type: "String"
      },
      toggle: {
        description: "Specify if you want to be able to click on the same element to activate/unactivate it.",
        type: {
          type: "Boolean",
          nullishAsTrue: true
        },
        default: false
      },
      history: {
        description: "Specify if you want to store and react to history hash changes",
        type: {
          type: "Boolean",
          nullishAsTrue: true
        },
        default: false
      },
      active: {
        description: "Specify the initial state of your element",
        type: {
          type: "Boolean",
          nullishAsTrue: true
        },
        default: false,
        physical: true
      },
      activeClass: {
        description: 'Specify the class applied on target(s) when active. Default is "active"',
        type: "String",
        default: "active"
      },
      activeAttribute: {
        description: "Specify the attribute name applied on target(s) when active.",
        type: "String",
        default: "active"
      },
      saveState: {
        description: "Specify if you want to save state in localStorage to restore it on page reload, etc...",
        type: "Boolean",
        default: false
      },
      activateTimeout: {
        description: "Specify a timeout before actiavting the target(s)",
        type: "Number",
        default: 0
      },
      unactivateTimeout: {
        description: "Specify a timeout before unactivate the target(s)",
        type: "Number",
        default: 0
      },
      triggerer: {
        description: "Specify an element selector that will be used as the triggerer instead of this current element",
        type: "String"
      },
      trigger: {
        description: 'Specify what trigger an activate/unactivate action. Can be "click", "mouseover", "mouseout" and/or "anchor"',
        type: {
          type: "Array<String>",
          splitChars: [","]
        },
        values: [
          "click",
          "mouseover",
          "mouseenter",
          "mouseout",
          "mouseleave",
          "anchor"
        ],
        default: ["click"]
      },
      unactivateOn: {
        description: "Specify some event(s) catched on the body tag that will unactivate the target(s)",
        type: "Array<String>"
      }
    };
  }
}
function define$s(props = {}, name2 = "s-activate") {
  SActivateFeature.define(name2, SActivateFeature, props);
}
var __awaiter$f = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SActivateFeature extends SFeature {
  constructor(name2, node, settings) {
    super(name2, node, __deepMerge({
      interface: SActivateFeatureInterface
    }, settings !== null && settings !== void 0 ? settings : {}));
    this._$groupElements = [];
    this.state = {
      active: void 0
    };
    this.groupState = {
      activeId: void 0
    };
    this.state = this.componentUtils.handleState(this.state, {
      save: this.props.saveState
    });
    if (this.props.group) {
      this.componentUtils.handleState(this.groupState, {
        save: this.props.saveState,
        id: `s-activate-feature-group-${this.props.group}`
      });
    }
    if (this.props.triggerer) {
      this._$triggerers = Array.from(document.querySelectorAll(this.props.triggerer));
    } else {
      this._$triggerers = [this.node];
    }
    this.componentUtils.exposeApi({
      activate: this.activate,
      unactivate: this.unactivate,
      isActive: this.isActive
    }, this);
  }
  mount() {
    if (this.props.href) {
      this._hrefSelector = this.props.href;
    }
    let targets;
    if (this._hrefSelector)
      targets = Array.from(document.querySelectorAll(this._hrefSelector));
    if (targets === null || targets === void 0 ? void 0 : targets.length)
      this._$targets = targets;
    else
      this._$targets = [this.node];
    if (this.props.group) {
      __querySelectorLive(`[${this.name}][group="${this.props.group}"]`, ($elm) => {
        var _a3, _b2;
        if ((_a3 = this._$groupElements) === null || _a3 === void 0 ? void 0 : _a3.includes($elm))
          return;
        (_b2 = this._$groupElements) === null || _b2 === void 0 ? void 0 : _b2.push($elm);
      }, {});
    }
    this._$triggerers.forEach(($triggerer) => {
      const triggererTriggers = $triggerer.hasAttribute("trigger") ? $triggerer.getAttribute("trigger").split(",").map((l) => l.trim()) : [];
      const triggers2 = __unique([
        ...this.props.trigger,
        ...triggererTriggers
      ]);
      triggers2.forEach((trigger2) => {
        if (trigger2.match(/^event:/)) {
          this.node.addEventListener("actual", (e) => {
            this.activate({
              preventSave: true
            });
          });
        } else {
          switch (trigger2) {
            case "click":
              $triggerer.addEventListener("click", (e) => {
                if (e.target !== $triggerer) {
                  if (e.target.parentElement !== $triggerer)
                    return;
                  if (e.currentTarget !== $triggerer)
                    return;
                }
                e.preventDefault();
                e.stopPropagation();
                if (this.isActive() && this.props.toggle) {
                  this.unactivate();
                } else {
                  this.activate();
                }
              });
              break;
            case "mousenter":
            case "mouseover":
              $triggerer.addEventListener("mouseover", (e) => {
                this.activate();
              });
              break;
            case "mouseout":
            case "mouseleave":
              $triggerer.addEventListener("mouseleave", (e) => {
                this.unactivate();
              });
              break;
            case "anchor":
              if (document.location.hash === this._hrefSelector) {
                this.activate();
              }
              window.addEventListener("hashchange", (e) => {
                if (document.location.hash === this._hrefSelector) {
                  this.activate();
                }
              });
              break;
          }
        }
      });
    });
    if (this.props.unactivateOn) {
      this.props.unactivateOn.forEach((what) => {
        if (what.match(/^event:/)) {
          document.body.addEventListener(what.replace(/^event:/, ""), (e) => {
            this.unactivate();
          });
        } else {
          switch (what) {
            case "click":
              document.addEventListener("click", (e) => {
                this.unactivate();
              });
              break;
          }
        }
      });
    }
    if (this.props.saveState) {
      this._restoreState();
    } else if (this.props.active) {
      this.activate();
    } else if (this.props.group && this._$groupElements[0] === this.node) {
      this.activate();
    }
  }
  isActive() {
    return this.state.active;
  }
  _restoreState() {
    if (this.groupState.activeId && this.groupState.activeId === this.node.id) {
      return this.activate({
        force: true
      });
    }
    if (this.groupState.activeId && this.groupState.activeId !== this.node.id) {
      return;
    }
    if (this.state.active) {
      return this.activate({
        force: true
      });
    }
    if (this.state.active === void 0 && this.props.active) {
      return this.activate({
        force: true
      });
    }
    return this.unactivate({
      force: true
    });
  }
  activate(params) {
    return __awaiter$f(this, void 0, void 0, function* () {
      const finalParams = Object.assign({ force: false, preventSave: false }, params !== null && params !== void 0 ? params : {});
      clearTimeout(this._unactivateTimeout);
      if (!finalParams.force && this.isActive())
        return;
      setTimeout(() => {
        if (this.props.history && this._hrefSelector) {
          document.location.hash = this._hrefSelector;
        }
        if (this._$groupElements) {
          this.groupState.activeId = this.node.id;
          this._$groupElements.forEach(($element) => {
            if ($element === this.node) {
              return;
            }
            $element.unactivate();
          });
        }
        this.state.active = true;
        this.props.active = true;
        this.node.classList.add(this.props.activeClass);
        if (this._$targets) {
          this._$targets.forEach(($target) => {
            if (this.props.activeClass) {
              $target.classList.add(this.props.activeClass);
            }
            if (this.props.activeAttribute) {
              this.componentUtils.fastdom.mutate(() => {
                $target.setAttribute(this.props.activeAttribute, "true");
              });
            }
            if ($target.children.length === 1 && $target.children[0].tagName === "TEMPLATE") {
              const $template = $target.children[0];
              const $container = document.createElement("div");
              const html2 = [];
              Array.from($template.content.childNodes).forEach(($child) => {
                var _a3;
                if ($child.tagName === "SCRIPT") {
                  document.head.appendChild($child);
                } else {
                  html2.push((_a3 = $child.outerHTML) !== null && _a3 !== void 0 ? _a3 : $child.textContent);
                }
              });
              $container.innerHTML = html2.join("\n");
              $target.appendChild($container);
              $template.remove();
            }
          });
        }
      }, this.props.activateTimeout);
    });
  }
  unactivate(params) {
    return __awaiter$f(this, void 0, void 0, function* () {
      const finalParams = Object.assign({ force: false, preventSave: false }, params !== null && params !== void 0 ? params : {});
      if (!finalParams.force && !this.isActive())
        return;
      this._unactivateTimeout = setTimeout(() => {
        this.state.active = false;
        this.props.active = false;
        this.node.classList.remove(this.props.activeClass);
        if (this._$targets) {
          this._$targets.forEach(($target) => {
            if (this.props.activeClass) {
              $target.classList.remove(this.props.activeClass);
            }
            if (this.props.activeAttribute) {
              $target.removeAttribute(this.props.activeAttribute);
            }
          });
        }
      }, this.props.unactivateTimeout);
    });
  }
}
class SAppearFeatureInterface extends SInterface {
  static get _definition() {
    return {
      in: {
        description: "Specify the animation you want to use to display your element",
        type: "String",
        default: "bottom",
        physical: true
      },
      out: {
        description: "Specify the animation you want to use to hide your item",
        type: "String",
        physical: true
      },
      delay: {
        description: "Specify a delay before animation in or out your element. Can be an array of two number that define the min delay and the max delay. The real delay will be random between these two numbers",
        type: {
          type: "Array<Number>",
          splitChars: [","]
        },
        default: [500]
      },
      duration: {
        description: "Specify the duration of the animation in ms. Can be an array of two number that define the min delay and the max duration. The real duration will be random between these two numbers",
        type: {
          type: "Array<Number>",
          splitChars: [","]
        },
        default: [500]
      },
      distance: {
        description: 'Specify the distance that your element will move if you have set an "in" direction. Can be an array of two number that define the min delay and the max distance. The real duration will be random between these two numbers',
        type: {
          type: "Array<Number>",
          splitChars: [","]
        },
        default: [100, 120]
      },
      appear: {
        description: "Specify if the element has to appear. This is usually setted automatically when needed",
        type: "Boolean",
        default: false,
        physical: true
      }
    };
  }
}
function define$r(props = {}, name2 = "s-appear") {
  SAppearFeature.define(name2, SAppearFeature, Object.assign({ mountWhen: "entersViewport" }, props));
}
const __css$h = "/* [s-appear] {\n    opacity: 0;\n\n    &[appear] {\n        opacity: 1;\n    }\n} */\n";
var __awaiter$e = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SAppearFeature extends SFeature {
  constructor(name2, node, settings) {
    super(name2, node, __deepMerge({
      name: "s-appear",
      interface: SAppearFeatureInterface,
      style: __css$h
    }, settings !== null && settings !== void 0 ? settings : {}));
    this.componentUtils.fastdom.mutate(() => {
      if (!this.node.hasAttribute("s-appear")) {
        this.node.setAttribute("s-appear", true);
      }
    });
  }
  mount() {
    return __awaiter$e(this, void 0, void 0, function* () {
      switch (this.node.tagName.toLowerCase()) {
        case "img":
          yield __whenImageLoaded(this.node);
          this.appear();
          break;
        default:
          const $imgs = this.node.querySelectorAll("img");
          if ($imgs.length) {
            yield __whenImagesLoaded($imgs);
          }
          this.appear();
          break;
      }
    });
  }
  appear() {
    const appearId = __uniqid();
    let delay = this.props.delay[0];
    if (this.props.delay.length === 2) {
      const minDelay = this.props.delay[0], maxDelay = this.props.delay[1];
      delay = minDelay + (maxDelay - minDelay) * Math.random();
    }
    let duration = this.props.duration[0];
    if (this.props.duration.length === 2) {
      const minDuration = this.props.duration[0], maxDuration = this.props.duration[1];
      duration = minDuration + (maxDuration - minDuration) * Math.random();
    }
    let distance = this.props.distance[0];
    if (this.props.distance.length === 2) {
      const minDistance = this.props.distance[0], maxDistance = this.props.distance[1];
      distance = minDistance + (maxDistance - minDistance) * Math.random();
    }
    const sugarElement = new SSugarElement(this.node);
    setTimeout(() => {
      this.props.appear = true;
      let distanceX = 0, distanceY = 0;
      switch (this.props.in) {
        case "top":
          distanceY = distance * -1;
          break;
        case "bottom":
          distanceY = distance;
          break;
        case "left":
          distanceX = distance * -1;
          break;
        case "right":
          distanceX = distance;
          break;
      }
      const newTransforms = sugarElement.simulateTransform({
        translateX: distanceX,
        translateY: distanceY
      });
      const animationStr = `
                @keyframes s-appear-${appearId} {
                    from {
                        transform: ${newTransforms.matrix};
                        opacity: 0;
                    }
                    to {
                        transform: ${sugarElement.matrixStr};
                        opacity: 1;
                    }
                }
                [s-appear-id="${appearId}"] {
                    animation: s-appear-${appearId} ${duration / 1e3}s ${STheme.get("easing.default")} forwards;
                }
            `;
      const $style = __injectStyle(animationStr);
      this.node.setAttribute("s-appear-id", appearId);
      setTimeout(() => {
        this.node.removeAttribute("s-appear-id");
        $style.remove();
      }, duration);
    }, delay);
  }
}
/*! clipboard-copy. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var clipboardCopy_1 = clipboardCopy;
function makeError() {
  return new DOMException("The request is not allowed", "NotAllowedError");
}
async function copyClipboardApi(text) {
  if (!navigator.clipboard) {
    throw makeError();
  }
  return navigator.clipboard.writeText(text);
}
async function copyExecCommand(text) {
  const span = document.createElement("span");
  span.textContent = text;
  span.style.whiteSpace = "pre";
  span.style.webkitUserSelect = "auto";
  span.style.userSelect = "all";
  document.body.appendChild(span);
  const selection = window.getSelection();
  const range2 = window.document.createRange();
  selection.removeAllRanges();
  range2.selectNode(span);
  selection.addRange(range2);
  let success = false;
  try {
    success = window.document.execCommand("copy");
  } finally {
    selection.removeAllRanges();
    window.document.body.removeChild(span);
  }
  if (!success)
    throw makeError();
}
async function clipboardCopy(text) {
  try {
    await copyClipboardApi(text);
  } catch (err) {
    try {
      await copyExecCommand(text);
    } catch (err2) {
      throw err2 || err || makeError();
    }
  }
}
function copy(text) {
  return clipboardCopy_1(text);
}
globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SClipboardCopyComponentInterface extends SInterface {
  static get _definition() {
    return {
      from: {
        description: 'Specify the element you want to copy from with a simple css selector. Try to get "value" first, then "innerHTML"',
        type: "String"
      },
      successTimeout: {
        description: 'Specify the duration for displaying the "success" icon',
        type: "Number",
        default: 1500
      },
      errorTimeout: {
        description: 'Specify the duration for displaying the "error" icon',
        type: "Number",
        default: 3e3
      }
    };
  }
}
const __css$g = ".s-clipboard-copy {\n    display: inline-block;\n    width: 1em;\n    height: 1em;\n    position: relative;\n    cursor: pointer;\n}\n\n    .s-clipboard-copy:not([mounted]) > * {\n        opacity: 0.001;\n        pointer-events: none;\n    }\n\n    .s-clipboard-copy .s-clipboard-copy__root[state='pending'] .icon-copy {\n            opacity: 1;\n        }\n\n    .s-clipboard-copy .s-clipboard-copy__root[state='copy'] .icon-copy {\n            opacity: 1;\n        }\n\n    .s-lod--1 .s-clipboard-copy .s-clipboard-copy__root[state='success'] {\n        color: hsla(calc(var(--s-theme-color-success-h, 0) + var(--s-theme-color-success-spin ,0)),calc((var(--s-theme-color-success-s, 0)) * 1%),calc((var(--s-theme-color-success-l, 0)) * 1%),var(--s-theme-color-success-a, 1));\n}\n\n    .s-clipboard-copy .s-clipboard-copy__root[state='success'] .icon-success {\n            opacity: 1;\n        }\n\n    .s-lod--1 .s-clipboard-copy .s-clipboard-copy__root[state='error'] {\n        color: hsla(calc(var(--s-theme-color-error-h, 0) + var(--s-theme-color-error-spin ,0)),calc((var(--s-theme-color-error-s, 0)) * 1%),calc((var(--s-theme-color-error-l, 0)) * 1%),var(--s-theme-color-error-a, 1));\n}\n\n    .s-clipboard-copy .s-clipboard-copy__root[state='error'] .icon-error {\n            opacity: 1;\n        }\n\n    .s-clipboard-copy svg {\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        display: block;\n        width: 1em;\n        height: 1em;\n        opacity: 0;\n        pointer-events: none;\n    }\n\n    .s-lod--2 .s-clipboard-copy svg {\n        background-size: contain;\n}\n";
function define$q(props = {}, tagName = "s-clipboard-copy") {
  SClipboardCopyComponent.define(tagName, SClipboardCopyComponent, props);
}
class SClipboardCopyComponent extends SLitComponent {
  constructor() {
    super(__deepMerge({
      name: "s-clipboard-copy",
      interface: SClipboardCopyComponentInterface
    }));
    this.state = {
      state: "pending"
    };
  }
  static get properties() {
    return SLitComponent.propertiesFromInterface({}, SClipboardCopyComponentInterface);
  }
  static get styles() {
    return css$1`
            ${unsafeCSS(__css$g)}
        `;
  }
  _copyFromTarget() {
    var _a3;
    if (!this.props.from)
      return;
    let $elm = document.querySelector(this.props.from);
    if (!$elm) {
      $elm = document.querySelector(`#${this.props.from}`);
    }
    if (!$elm) {
      throw new Error(`[SClipboardCopy] The target element "${this.props.from}" does not exist`);
    }
    const text = (_a3 = $elm.value) !== null && _a3 !== void 0 ? _a3 : $elm.innerHTML;
    this.copy(text);
  }
  copy(text) {
    this.state.state = "copy";
    copy(text).then(() => {
      this.state.state = "success";
      setTimeout(() => {
        this.state.state = "pending";
      }, this.props.successTimeout);
    }).catch((e) => {
      this.state.state = "error";
      setTimeout(() => {
        this.state.state = "pending";
      }, this.props.errorTimeout);
    });
  }
  render() {
    return html`
            <div
                @click=${() => this._copyFromTarget()}
                class="${this.componentUtils.className("__root")}"
                state="${this.state.state}"
            >
                <svg
                    ref="svg"
                    class="icon-copy"
                    width="20"
                    height="20"
                    viewBox="0 0 20 20"
                    fill="none"
                    xmlns="http://www.w3.org/2000/svg"
                >
                    <g clip-path="url(#clip0)">
                        <path
                            d="M4.55512 0.00402832L2.07324 2.4859H4.55512V0.00402832Z"
                            fill="currentColor"
                        />
                        <path
                            d="M14.9937 0H5.72598V3.65762H2.06836V17.0624H14.9937V0H14.9937ZM12.5801 11.3218H4.48195V10.1499H12.5801V11.3218ZM12.5801 8.83219H4.48195V7.66031H12.5801V8.83219ZM12.5801 6.34254H4.48195V5.17066H12.5801V6.34254Z"
                            fill="currentColor"
                        />
                        <path
                            d="M16.1655 2.93762V18.2343H5.00586V20H17.9312V2.93762H16.1655Z"
                            fill="currentColor"
                        />
                    </g>
                    <defs>
                        <clipPath id="clip0">
                            <rect width="20" height="20" fill="currentColor" />
                        </clipPath>
                    </defs>
                </svg>
                <svg
                    class="icon-success"
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                >
                    <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                    <polyline points="22 4 12 14.01 9 11.01"></polyline>
                </svg>
                <svg
                    class="icon-error"
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                >
                    <polygon
                        points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"
                    ></polygon>
                    <line x1="15" y1="9" x2="9" y2="15"></line>
                    <line x1="9" y1="9" x2="15" y2="15"></line>
                </svg>
            </div>
        `;
  }
}
class SFloatingFeatureInterface extends SInterface {
  static get _definition() {
    return {
      ref: {
        description: "Specify the reference HTMLElement from which to position the floating one. If not specified, will take the previous element in the DOM",
        type: "String"
      },
      position: {
        description: "Specify the placement of your floating element. By default it will try to be placed as good as possible.",
        type: "String",
        values: [
          "top",
          "right",
          "bottom",
          "left",
          "top-start",
          "top-end",
          "right-start",
          "right-end",
          "bottom-start",
          "bottom-end",
          "left-start",
          "left-end",
          "auto"
        ],
        default: "auto"
      },
      shift: {
        description: "Specify a space between the floating element and the viewport side to respect",
        type: "Number",
        default: 10
      },
      offset: {
        description: "Specify a space between the floating element and the reference one to respect",
        type: "Number"
      },
      arrow: {
        description: "Specify if you want an arrow or not",
        type: "Boolean",
        default: true
      },
      arrowSize: {
        description: "Specify the size of the arrow in px",
        type: "Number",
        default: 15
      },
      arrowPadding: {
        description: "Specify the padding of the arrow in px",
        type: "Number",
        default: 10
      }
    };
  }
}
function define$p(props = {}, name2 = "s-floating") {
  SFloatingFeature.define(name2, SFloatingFeature, Object.assign({}, props));
}
const __css$f = ".s-floating {\n    transform: none;\n}\n\n.s-lod--2 .s-floating {\n    transition: none;\n}\n\n    .s-floating:before {\n        content: none;\n    }\n\n    .s-floating:after {\n        content: none;\n    }\n\n    .s-floating .s-floating__arrow {\n        position: absolute;\n        width: var(--arrow-size, 8px);\n        height: var(--arrow-size, 8px);\n        transform: rotate(45deg);\n    }\n\n    .s-lod--1 .s-floating .s-floating__arrow {\n        background: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-spin ,0)),calc((var(--s-theme-color-current-s, 0)) * 1%),calc((var(--s-theme-color-current-l, 0)) * 1%),var(--s-theme-color-current-a, 1));\n}";
class SFloatingFeature extends SFeature {
  constructor(name2, node, settings) {
    super(name2, node, __deepMerge({
      name: "s-floating",
      interface: SFloatingFeatureInterface,
      style: __css$f
    }, settings !== null && settings !== void 0 ? settings : {}));
    if (!this.props.ref) {
      this._$ref = this.node.parentElement;
    } else {
      this._$ref = document.querySelector(this.props.ref);
    }
  }
  mount() {
    if (this.props.offset === void 0 && this.props.arrow) {
      this.props.offset = this.props.arrowSize;
    }
    __makeFloat(this.node, this._$ref, this.props);
  }
}
const __en = {
  min: {
    string: "Must have at least %n characters",
    object: "Must have at least %n properties",
    number: "Must be greater than %n",
    array: "Must have at least %n items"
  },
  max: {
    string: "Must have at max %n characters",
    object: "Must have at max %n properties",
    number: "Must be lower than %n",
    array: "Must have at max %n items"
  },
  email: {
    string: "Must be a valid email address"
  },
  required: {
    default: "This is required"
  },
  isoDate: {
    string: "Must be a valid ISO date"
  },
  isoTime: {
    string: "Must be a valid ISO time"
  },
  isoDateTime: {
    string: "Must be a valid ISO date time"
  },
  integer: {
    string: "Must be an integer"
  },
  number: {
    string: "Must be an number"
  },
  negative: {
    string: "Must be a negative number"
  },
  positive: {
    string: "Must be a positive number"
  },
  pattern: {
    string: "Must match the pattern %pattern"
  },
  alphanum: {
    string: "Must contain only alphanumeric characters"
  },
  creditCard: {
    string: "Must be a valid credit card number"
  },
  color: {
    string: "Must be a valid color (hex, rgb, rgba, hsl, hsla)"
  },
  hex: {
    string: "Must be a valid hex color"
  },
  password: {
    weak: "",
    medium: "Must be >=6 characters, at least 1 lowercase/uppercase/special character",
    strong: "Must be >=8 characters, at least 1 lowercase/uppercase/digit/special character"
  }
};
const definition$g = {
  description: "Validate an alphanum string",
  type: "String"
};
function alphanum(value, settings) {
  var _a3;
  let message, valid;
  const finalSettings = __deepMerge({
    i18n: __en.alphanum,
    trim: true
  }, settings !== null && settings !== void 0 ? settings : {});
  if (typeof value !== "string") {
    throw new Error(`Sorry but the "alphanum" validation only works with string`);
  }
  if (finalSettings.trim) {
    value = value.trim();
  }
  valid = value.match(/^[a-z0-9]+$/i);
  if (!valid) {
    message = (_a3 = finalSettings.i18n) === null || _a3 === void 0 ? void 0 : _a3.string;
  }
  return {
    valid,
    message
  };
}
const definition$f = {
  description: "Validate a color string",
  type: "String"
};
function color(value, settings) {
  var _a3;
  let message, valid;
  const finalSettings = __deepMerge({
    i18n: __en.color,
    trim: true
  }, settings !== null && settings !== void 0 ? settings : {});
  if (typeof value !== "string") {
    throw new Error(`Sorry but the "color" validation only works with string`);
  }
  if (finalSettings.trim) {
    value = value.trim();
  }
  valid = __isColor(value);
  if (!valid) {
    message = (_a3 = finalSettings.i18n) === null || _a3 === void 0 ? void 0 : _a3.string;
  }
  return {
    valid,
    message
  };
}
const definition$e = {
  description: "Validate a credit card string",
  type: "String"
};
function creditCard(value, settings) {
  var _a3;
  let message, valid;
  const finalSettings = __deepMerge({
    i18n: __en.creditCard,
    trim: true
  }, settings !== null && settings !== void 0 ? settings : {});
  if (typeof value !== "string") {
    throw new Error(`Sorry but the "creditCard" validation only works with string`);
  }
  if (finalSettings.trim) {
    value = value.trim();
  }
  valid = __isCreditCard(value);
  if (!valid) {
    message = (_a3 = finalSettings.i18n) === null || _a3 === void 0 ? void 0 : _a3.string;
  }
  return {
    valid,
    message
  };
}
const definition$d = {
  description: "Validate an email string",
  type: "String"
};
function email(value, settings) {
  var _a3;
  let message, valid;
  const finalSettings = __deepMerge({
    i18n: __en.email,
    trim: true
  }, settings !== null && settings !== void 0 ? settings : {});
  if (typeof value !== "string") {
    throw new Error(`Sorry but the "email" validation only works with string`);
  }
  if (finalSettings.trim) {
    value = value.trim();
  }
  valid = __isEmail(value);
  if (!valid) {
    message = (_a3 = finalSettings.i18n) === null || _a3 === void 0 ? void 0 : _a3.string;
  }
  return {
    valid,
    message
  };
}
const definition$c = {
  description: "Validate a hexadecimal string",
  type: "String"
};
function hex(value, settings) {
  var _a3;
  let message, valid;
  const finalSettings = __deepMerge({
    i18n: __en.hex,
    trim: true
  }, settings !== null && settings !== void 0 ? settings : {});
  if (typeof value !== "string") {
    throw new Error(`Sorry but the "hex" validation only works with string`);
  }
  if (finalSettings.trim) {
    value = value.trim();
  }
  valid = value.match(/^#[a-zA-Z0-9]{3,6}$/);
  if (!valid) {
    message = (_a3 = finalSettings.i18n) === null || _a3 === void 0 ? void 0 : _a3.string;
  }
  return {
    valid,
    message
  };
}
const definition$b = {
  description: "Validate an integer",
  type: "number"
};
function integer(value, settings) {
  var _a3;
  let message, valid;
  const finalSettings = __deepMerge({
    i18n: __en.integer,
    cast: true,
    trim: true
  }, settings !== null && settings !== void 0 ? settings : {});
  if (typeof value !== "string" && typeof value !== "number") {
    throw new Error(`Sorry but the "integer" validation only works with string and number`);
  }
  if (typeof value === "string" && finalSettings.trim) {
    value = value.trim();
  }
  if (typeof value === "string" && finalSettings.cast) {
    value = Number(value);
  }
  if (isNaN(value)) {
    valid = false;
  } else {
    valid = Number.isInteger(value);
  }
  if (!valid) {
    message = (_a3 = finalSettings.i18n) === null || _a3 === void 0 ? void 0 : _a3.string;
  }
  return {
    valid,
    message
  };
}
const definition$a = {
  description: "Validate an iso date string",
  type: "String"
};
function isoDate(value, settings) {
  var _a3;
  let message, valid;
  const finalSettings = __deepMerge({
    i18n: __en.isoDate,
    trim: true
  }, settings !== null && settings !== void 0 ? settings : {});
  if (typeof value !== "string") {
    throw new Error(`Sorry but the "isoDate" validation only works with string`);
  }
  if (finalSettings.trim) {
    value = value.trim();
  }
  valid = __isIsoDate(value);
  if (!valid) {
    message = (_a3 = finalSettings.i18n) === null || _a3 === void 0 ? void 0 : _a3.string;
  }
  return {
    valid,
    message
  };
}
const definition$9 = {
  description: "Validate an iso date string",
  type: "String"
};
function isoDateTime(value, settings) {
  var _a3;
  let message, valid;
  const finalSettings = __deepMerge({
    i18n: __en.isoDateTime,
    trim: true
  }, settings !== null && settings !== void 0 ? settings : {});
  if (typeof value !== "string") {
    throw new Error(`Sorry but the "isoDateTime" validation only works with string`);
  }
  if (finalSettings.trim) {
    value = value.trim();
  }
  valid = __isIsoDateTime(value);
  if (!valid) {
    message = (_a3 = finalSettings.i18n) === null || _a3 === void 0 ? void 0 : _a3.string;
  }
  return {
    valid,
    message
  };
}
const definition$8 = {
  description: "Validate an iso time string",
  type: "String"
};
function isoTime(value, settings) {
  var _a3;
  let message, valid;
  const finalSettings = __deepMerge({
    i18n: __en.isoTime,
    trim: true
  }, settings !== null && settings !== void 0 ? settings : {});
  if (typeof value !== "string") {
    throw new Error(`Sorry but the "isoTime" validation only works with string`);
  }
  if (finalSettings.trim) {
    value = value.trim();
  }
  valid = __isIsoTime(value);
  if (!valid) {
    message = (_a3 = finalSettings.i18n) === null || _a3 === void 0 ? void 0 : _a3.string;
  }
  return {
    valid,
    message
  };
}
const definition$7 = {
  description: 'Validate string, array, object and number using the "max" rule',
  type: "String|Array|Object|Number"
};
function max(value, n, settings) {
  var _a3, _b2, _c2, _d2;
  let message, valid;
  const finalSettings = __deepMerge({
    i18n: __en.max,
    trim: true
  }, settings !== null && settings !== void 0 ? settings : {});
  switch (true) {
    case typeof value === "string":
      if (finalSettings.trim) {
        value = value.trim();
      }
      valid = value.length <= n;
      message = (_a3 = finalSettings.i18n) === null || _a3 === void 0 ? void 0 : _a3.string.replace("%n", n);
      break;
    case typeof value === "number":
      valid = value <= n;
      message = (_b2 = finalSettings.i18n) === null || _b2 === void 0 ? void 0 : _b2.number.replace("%n", n);
      break;
    case Array.isArray(value):
      valid = value.length <= n;
      message = (_c2 = finalSettings.i18n) === null || _c2 === void 0 ? void 0 : _c2.array.replace("%n", n);
      break;
    case typeof value === "object":
      valid = Object.keys(value).length <= n;
      message = (_d2 = finalSettings.i18n) === null || _d2 === void 0 ? void 0 : _d2.object.replace("%n", n);
      break;
    default:
      throw new Error(`Sorry but the "max" validation only works with string, number, array or object values.`);
  }
  return {
    valid,
    message
  };
}
const definition$6 = {
  description: 'Validate string, array, object and number using the "min" rule',
  type: "String|Array|Object|Number"
};
function min(value, n, settings) {
  var _a3, _b2, _c2, _d2;
  let message, valid;
  const finalSettings = __deepMerge({
    i18n: __en.min,
    trim: true
  }, settings !== null && settings !== void 0 ? settings : {});
  switch (true) {
    case typeof value === "string":
      if (finalSettings.trim) {
        value = value.trim();
      }
      valid = value.length >= n;
      message = (_a3 = finalSettings.i18n) === null || _a3 === void 0 ? void 0 : _a3.string.replace("%n", n);
      break;
    case typeof value === "number":
      valid = value >= n;
      message = (_b2 = finalSettings.i18n) === null || _b2 === void 0 ? void 0 : _b2.number.replace("%n", n);
      break;
    case Array.isArray(value):
      valid = value.length >= n;
      message = (_c2 = finalSettings.i18n) === null || _c2 === void 0 ? void 0 : _c2.array.replace("%n", n);
      break;
    case typeof value === "object":
      valid = Object.keys(value).length >= n;
      message = (_d2 = finalSettings.i18n) === null || _d2 === void 0 ? void 0 : _d2.object.replace("%n", n);
      break;
    default:
      throw new Error(`Sorry but the "min" validation only works with string, number, array or object values.`);
  }
  return {
    valid,
    message
  };
}
const definition$5 = {
  description: "Validate an negative number",
  type: "number"
};
function negative(value, settings) {
  var _a3;
  let message, valid;
  const finalSettings = __deepMerge({
    i18n: __en.negative,
    cast: true,
    trim: true
  }, settings !== null && settings !== void 0 ? settings : {});
  if (typeof value !== "string" && typeof value !== "number") {
    throw new Error(`Sorry but the "negative" validation only works with string and number`);
  }
  if (typeof value === "string" && finalSettings.trim) {
    value = value.trim();
  }
  if (typeof value === "string" && finalSettings.cast) {
    value = Number(value);
  }
  if (isNaN(value)) {
    valid = false;
  } else {
    valid = value < 0;
  }
  if (!valid) {
    message = (_a3 = finalSettings.i18n) === null || _a3 === void 0 ? void 0 : _a3.string;
  }
  return {
    valid,
    message
  };
}
const definition$4 = {
  description: "Validate an number",
  type: "number"
};
function number(value, settings) {
  var _a3;
  let message, valid;
  const finalSettings = __deepMerge({
    i18n: __en.number,
    cast: true,
    trim: true
  }, settings !== null && settings !== void 0 ? settings : {});
  if (typeof value !== "string" && typeof value !== "number") {
    throw new Error(`Sorry but the "number" validation only works with string and number`);
  }
  if (typeof value === "string" && finalSettings.trim) {
    value = value.trim();
  }
  if (typeof value === "string" && finalSettings.cast) {
    value = Number(value);
  }
  if (isNaN(value)) {
    valid = false;
  } else {
    valid = true;
  }
  if (!valid) {
    message = (_a3 = finalSettings.i18n) === null || _a3 === void 0 ? void 0 : _a3.string;
  }
  return {
    valid,
    message
  };
}
const definition$3 = {
  description: "Validate a password string",
  type: "String"
};
function password(value, level, settings) {
  var _a3;
  let message, valid = false;
  const finalSettings = __deepMerge({
    i18n: __en.password,
    trim: true,
    weakReg: /.*/,
    mediumReg: /((?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[^A-Za-z0-9])(?=.{6,}))|((?=.*[a-z])(?=.*[A-Z])(?=.*[^A-Za-z0-9])(?=.{8,}))/,
    strongReg: /(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[^A-Za-z0-9])(?=.{8,})/
  }, settings !== null && settings !== void 0 ? settings : {});
  if (typeof value !== "string") {
    throw new Error(`Sorry but the "password" validation only works with string`);
  }
  if (finalSettings.trim) {
    value = value.trim();
  }
  let validLevels = [];
  if (finalSettings.weakReg.test(value)) {
    if (value) {
      validLevels.push("weak");
    }
    if (level === "weak") {
      valid = true;
    }
  }
  if (finalSettings.mediumReg.test(value)) {
    if (value) {
      validLevels.push("medium");
    }
    if (level === "medium") {
      valid = true;
    }
  }
  if (finalSettings.strongReg.test(value)) {
    if (value) {
      validLevels.push("strong");
    }
    if (level === "strong") {
      valid = true;
    }
  }
  if (!valid) {
    message = (_a3 = finalSettings.i18n) === null || _a3 === void 0 ? void 0 : _a3[level];
  }
  return {
    valid,
    message,
    metas: {
      levels: ["weak", "medium", "strong"],
      validLevels
    }
  };
}
const definition$2 = {
  description: "Validate a string using a regex pattern",
  type: "String"
};
function pattern(value, pattern2, settings) {
  var _a3;
  let message, valid;
  const finalSettings = __deepMerge({
    i18n: __en.pattern,
    trim: true
  }, settings !== null && settings !== void 0 ? settings : {});
  if (typeof value !== "string") {
    throw new Error(`Sorry but the "pattern" validation only works with string`);
  }
  if (finalSettings.trim) {
    value = value.trim();
  }
  const reg = new RegExp(pattern2);
  valid = reg.test(value);
  if (!valid) {
    message = (_a3 = finalSettings.i18n) === null || _a3 === void 0 ? void 0 : _a3.string.replace("%pattern", pattern2);
  }
  return {
    valid,
    message
  };
}
const definition$1 = {
  description: "Validate an positive number",
  type: "number"
};
function positive(value, settings) {
  var _a3;
  let message, valid;
  const finalSettings = __deepMerge({
    i18n: __en.positive,
    cast: true,
    trim: true
  }, settings !== null && settings !== void 0 ? settings : {});
  if (typeof value !== "string" && typeof value !== "number") {
    throw new Error(`Sorry but the "positive" validation only works with string and number`);
  }
  if (typeof value === "string" && finalSettings.trim) {
    value = value.trim();
  }
  if (typeof value === "string" && finalSettings.cast) {
    value = Number(value);
  }
  if (isNaN(value)) {
    valid = false;
  } else {
    valid = value >= 0;
  }
  if (!valid) {
    message = (_a3 = finalSettings.i18n) === null || _a3 === void 0 ? void 0 : _a3.string;
  }
  return {
    valid,
    message
  };
}
const definition = {
  description: "Make sure a value has been provided",
  type: "Boolean"
};
function required(value, settings) {
  var _a3;
  let message, valid;
  const finalSettings = __deepMerge({
    i18n: __en.required,
    trim: true
  }, settings !== null && settings !== void 0 ? settings : {});
  if (typeof value === "string" && finalSettings.trim) {
    value = value.trim();
  }
  valid = value !== void 0 && value !== null && value !== "";
  if (!valid) {
    message = (_a3 = finalSettings.i18n) === null || _a3 === void 0 ? void 0 : _a3.default;
  }
  return {
    valid,
    message
  };
}
class SValidator extends SClass {
  constructor(settings) {
    super(__deepMerge({
      i18n: __en
    }, settings !== null && settings !== void 0 ? settings : {}));
  }
  static registerValidator(name2, validator2, settings) {
    SValidator._validators[name2] = {
      validator: validator2,
      settings
    };
  }
  static registerPreset(name2, rules, settings) {
    SValidator._presets[name2] = {
      rules,
      settings
    };
  }
  static getValidatorsDefinition() {
    const definition2 = {};
    for (let [name2, validatorObj] of Object.entries(SValidator._validators)) {
      if (!validatorObj.settings.definition)
        continue;
      definition2[name2] = validatorObj.settings.definition;
    }
    return definition2;
  }
  validate(value, rulesOrPreset, settings) {
    var _a3, _b2, _c2;
    let result2 = {
      valid: true,
      rules: {},
      messages: []
    };
    let rules = rulesOrPreset;
    if (typeof rulesOrPreset === "string") {
      if (!SValidator._presets[rulesOrPreset]) {
        throw new Error(`Sorry but the preset "${rulesOrPreset}" is not registered`);
      }
      rules = SValidator._presets[rulesOrPreset].rules;
    }
    for (let [validator2, valueOrObj] of Object.entries(rules)) {
      let validatorSettings = (_a3 = valueOrObj.settings) !== null && _a3 !== void 0 ? _a3 : {}, validatorValue = (_b2 = valueOrObj.value) !== null && _b2 !== void 0 ? _b2 : valueOrObj, res;
      const validatorObj = SValidator._validators[validator2];
      if (!validatorObj) {
        throw new Error(`Sorry but the validator "${validator2}" is not registered`);
      }
      const finalValidatorSettings = Object.assign(Object.assign({}, validatorSettings), { i18n: (_c2 = this.settings.i18n[validator2]) !== null && _c2 !== void 0 ? _c2 : {} });
      if (typeof rulesOrPreset === "boolean") {
        res = validatorObj.validator(value, finalValidatorSettings);
      } else {
        res = validatorObj.validator(value, validatorValue, finalValidatorSettings);
      }
      if (!res.valid) {
        res.message = res.message.replace("%value", value).replace("%validator", validator2);
        result2.valid = false;
        result2.rules[validator2] = res;
        result2.messages.push(res.message);
      } else {
        result2.rules[validator2] = res;
      }
    }
    return result2;
  }
}
SValidator._validators = {};
SValidator._presets = {};
SValidator.registerValidator("min", min, {
  definition: definition$6
});
SValidator.registerValidator("max", max, {
  definition: definition$7
});
SValidator.registerValidator("email", email, {
  definition: definition$d
});
SValidator.registerValidator("required", required, {
  definition
});
SValidator.registerValidator("isoDate", isoDate, {
  definition: definition$a
});
SValidator.registerValidator("isoTime", isoTime, {
  definition: definition$8
});
SValidator.registerValidator("isoDateTime", isoDateTime, {
  definition: definition$9
});
SValidator.registerValidator("integer", integer, {
  definition: definition$b
});
SValidator.registerValidator("number", number, {
  definition: definition$4
});
SValidator.registerValidator("negative", negative, {
  definition: definition$5
});
SValidator.registerValidator("positive", positive, {
  definition: definition$1
});
SValidator.registerValidator("pattern", pattern, {
  definition: definition$2
});
SValidator.registerValidator("alphanum", alphanum, {
  definition: definition$g
});
SValidator.registerValidator("creditCard", creditCard, {
  definition: definition$e
});
SValidator.registerValidator("color", color, {
  definition: definition$f
});
SValidator.registerValidator("hex", hex, {
  definition: definition$c
});
SValidator.registerValidator("password", password, {
  definition: definition$3
});
const __css$e = "@-webkit-keyframes error-message-appear {\n    from {\n        max-height: 0;\n    }\n    .s-lod--1 from {\n        line-height: 1;\n    }\n    to {\n        max-height: 2em;\n    }\n    .s-lod--1 to {\n        line-height: 2;\n    }\n}\n\n@keyframes error-message-appear {\n    from {\n        max-height: 0;\n    }\n    .s-lod--1 from {\n        line-height: 1;\n    }\n    to {\n        max-height: 2em;\n    }\n    .s-lod--1 to {\n        line-height: 2;\n    }\n}\n\n.s-form-validate + .s-form-validate-error-message {\n    text-align: end;\n    overflow: hidden;\n    max-height: 0;\n    margin: 0;\n}\n\n.s-lod--3 .s-form-validate + .s-form-validate-error-message {\n    -webkit-animation: 0.2s error-message-appear var(--s-theme-easing-default, 0) forwards;\n            animation: 0.2s error-message-appear var(--s-theme-easing-default, 0) forwards;\n}\n\n.s-lod--1 .s-form-validate + .s-form-validate-error-message {\n    color: hsla(calc(var(--s-theme-color-error-h, 0) + var(--s-theme-color-error-spin ,0)),calc((var(--s-theme-color-error-s, 0)) * 1%),calc((var(--s-theme-color-error-l, 0)) * 1%),var(--s-theme-color-error-a, 1));\n    line-height: 1;\n}\n";
const validatorsDefinition = SValidator.getValidatorsDefinition(), validatorsMessagesDefinition = {};
for (let [validator2, definition2] of Object.entries(validatorsDefinition)) {
  validatorsMessagesDefinition[`${validator2}Message`] = {
    description: `The message to display when the validator "${validator2}" fails`,
    type: "String"
  };
}
class SFormValidateFeatureInterface extends SInterface {
  static get _definition() {
    return Object.assign(Object.assign(Object.assign({}, validatorsDefinition), validatorsMessagesDefinition), { type: {
      description: "Specify the validation type. Usually automatically detected depending on the field type",
      type: "String",
      default: "text"
    }, on: {
      description: 'Specify when to trigger a validation. Can be "change","submit","enter" and/or "reset"',
      type: "Array<String>",
      values: ["keyup", "change", "submit", "enter", "reset"],
      default: ["keyup", "change", "submit", "enter", "reset"]
    }, format: {
      description: 'Specify if you want your value to be formatted a certain way. You can specify every "import { __format } from `@coffeekraken/sugar/string`" supported formats',
      type: "String",
      values: format$2.formats
    }, errorClass: {
      description: "Specify the class to apply when theres an error",
      type: "String",
      default: "s-form-validate--error s-color--error"
    }, validClass: {
      description: "Specify the class to apply on your s-form-validate element when validation is passed successfully",
      type: "String",
      default: "s-form-validate--valid s-color--success"
    }, handlers: {
      description: 'Specify some custom handlers by validator that will be executed in addition to the default validate behavior. The handler will take as argument an object containing the "result" SValidator result, the "$feature" that represent the s-validate node, the "$form" node if exists, the "$node" attached node if using the "nodes" property, the "$field" that represent the input field handled and the "props" that represent the feature properties',
      type: "Object",
      default: {}
    }, nodes: {
      description: 'Specify a css selector that target some HTMLElements used for the validation. Every HTMLElement has to specify 1 validator by using element attributes (same as on the feature itself). Classes are applied on each "node" to specify if the validator is valid or not',
      type: "String"
    }, language: {
      description: "Specify the language you want to use for messages",
      type: "String",
      default: "en"
    }, displayError: {
      description: "Specify if you want to display the error messages or not",
      type: "Boolean",
      default: true
    }, errorContainerAttr: {
      description: "Specify the attribute to search for the error container. If not found, a default container will be created and inserted after your s-form-validate element",
      type: "String",
      default: "s-form-validate-error"
    } });
  }
}
function define$o(props = {}, name2 = "s-form-validate") {
  SFormValidateFeature.define(name2, SFormValidateFeature, Object.assign({ mountWhen: "interact" }, props));
}
var __awaiter$d = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SFormValidateFeature extends SFeature {
  constructor(name2, node, settings) {
    var _a3, _b2, _c2, _d2;
    Object.keys((_b2 = (_a3 = SComponentUtils.getDefaultProps(name2)) === null || _a3 === void 0 ? void 0 : _a3.customValidations) !== null && _b2 !== void 0 ? _b2 : {}).forEach((validationName) => {
      if (SFormValidateFeatureInterface.definition[validationName])
        return;
      SFormValidateFeatureInterface.definition[validationName] = {
        type: "String|Boolean"
      };
    });
    super(name2, node, __deepMerge({
      name: "s-form-validate",
      interface: SFormValidateFeatureInterface,
      style: __css$e
    }, settings !== null && settings !== void 0 ? settings : {}));
    this._nodeByValidator = {};
    this._isDirty = false;
    this._isValidating = false;
    if (!((_c2 = this.props.handlers) === null || _c2 === void 0 ? void 0 : _c2.password)) {
      (_d2 = this.props.handlers) === null || _d2 === void 0 ? void 0 : _d2.password = this._passwordDefaultHandler;
    }
    this._validator = new SValidator();
    this._$form = __querySelectorUp(this.node, "form");
    if (this._$form) {
      this._$form.addEventListener("submit", (e) => {
        var _a4;
        if (!this._$form._submitHandler) {
          this._$form._submitHandler = true;
          const collectedErrors = [];
          const errorHandler = (e2) => {
            collectedErrors.push(e2.detail);
          };
          this._$form.addEventListener("s-form-validate.error", errorHandler);
          e.preventDefault();
          if (e instanceof CustomEvent && !((_a4 = e.detail) === null || _a4 === void 0 ? void 0 : _a4.internal))
            ;
          else {
            e.stopPropagation();
          }
          setTimeout(() => {
            delete this._$form._submitHandler;
            this._$form.removeEventListener("s-form-validate.error", errorHandler);
            if (!collectedErrors.length) {
              this._$form.submit();
              if (e instanceof CustomEvent)
                ;
              else {
                this._$form.dispatchEvent(new CustomEvent("submit", {
                  bubbles: true,
                  cancelable: true
                }));
              }
            }
          });
        }
      });
    }
    this.componentUtils.exposeApi({
      validate: this.validate
    }, this);
    if (this.props.nodes) {
      this._$nodes = this.node.querySelectorAll(this.props.nodes);
      this._$nodes.forEach(($node) => {
        for (let i2 = 0; i2 < $node.attributes.length; i2++) {
          const attr = $node.attributes[i2];
          if (attr.name in this.props) {
            this.props[__camelCase(attr.name)] = autoCast(attr.value);
            this._nodeByValidator[__camelCase(attr.name)] = $node;
          }
        }
      });
    }
  }
  mount() {
    __querySelectorLive("input,textarea,select", ($field) => {
      this._initField($field);
    }, {
      rootNode: this.node,
      scopes: false
    });
    if (this.props.type) {
      if (this.props.type === "text")
        this._validationType = "string";
      else
        this._validationType = this.props.type;
    }
  }
  _passwordDefaultHandler({ result: result2, $feature }) {
    var _a3;
    if (result2.valid) {
      $feature.classList.remove(`password-weak`);
      $feature.classList.remove(`password-medium`);
      $feature.classList.remove(`password-strong`);
    } else if ((_a3 = result2.metas) === null || _a3 === void 0 ? void 0 : _a3.levels) {
      result2.metas.levels.forEach((level) => {
        if (level !== result2.metas.validLevels.slice(-1)[0]) {
          $feature.classList.remove(`password-${level}`);
        } else {
          $feature.classList.add(`password-${level}`);
        }
      });
    }
  }
  _initField($field) {
    this._$field = $field;
    this._$field = this.node;
    const $insideField = this.node.querySelector("input,textarea,select");
    if ($insideField)
      this._$field = $insideField;
    this.componentUtils.fastdom.mutate(() => {
      this._$field.setAttribute("novalidate", "true");
      [
        "required",
        "maxlength",
        "minlength",
        "max",
        "min",
        "pattern"
      ].forEach((type) => {
        if (this._$field.hasAttribute(type)) {
          if (this.props[type])
            return;
          this.props[type] = this._$field.getAttribute(type);
          if (type !== "maxlength" && type !== "minlength") {
            this._$field.removeAttribute(type);
          }
        }
      });
    });
    ["keydown", "change"].forEach((eventType) => {
      this._$field.addEventListener(eventType, (e) => {
        if (this.props.format && (e.target.type === "text" || e.target.tagName.toLowerCase() === "textarea")) {
          setTimeout(() => {
            var _a3;
            const newValue = this.format((_a3 = e.target.value) !== null && _a3 !== void 0 ? _a3 : "", this.props.format);
            if (newValue !== e.target.value) {
              this._$field.value = newValue;
            }
          });
        }
      });
    });
    this.props.on.forEach((on2) => {
      var _a3, _b2;
      if (on2 === "enter") {
        this._$field.addEventListener("keyup", (e) => {
          if (e.keyCode !== 13)
            return;
          if (this._$form) {
            this._$form.dispatchEvent(new CustomEvent("submit", {
              bubbles: false,
              detail: {
                internal: true
              }
            }));
          } else {
            this.validate(e);
          }
        });
      } else if (on2 === "reset") {
        (_a3 = this._$field.form) === null || _a3 === void 0 ? void 0 : _a3.addEventListener(on2, (e) => {
          setTimeout(() => {
            this.validate(e);
          });
        });
      } else if (on2 === "submit") {
        (_b2 = this._$field.form) === null || _b2 === void 0 ? void 0 : _b2.addEventListener(on2, (e) => {
          var _a4;
          e.preventDefault();
          if (e instanceof CustomEvent && !((_a4 = e.detail) === null || _a4 === void 0 ? void 0 : _a4.internal))
            return;
          e.stopPropagation();
          this.validate(e);
        });
      } else if (on2 === "keyup") {
        this.node.addEventListener(on2, (e) => {
          if (!this._isDirty)
            return;
          this.validate(e);
        });
      } else {
        this.node.addEventListener(on2, (e) => {
          this.validate(e);
        });
      }
    });
  }
  format(value, format2) {
    const newValue = format$2(value, format2);
    return newValue;
  }
  validate(event) {
    var _a3;
    if (!this._$field) {
      throw new Error(`No $field has been found to be validated...`);
    }
    let value = this._getFieldValue();
    if (((_a3 = event === null || event === void 0 ? void 0 : event.currentTarget) === null || _a3 === void 0 ? void 0 : _a3.tagName.toLowerCase()) === "form" && event.type !== "reset") {
      event.preventDefault();
    }
    if (this._isValidating)
      return;
    this._isValidating = true;
    setTimeout(() => {
      this._isValidating = false;
    });
    let resultObj;
    const validatorRules = {};
    for (let [validator2, definition2] of Object.entries(SValidator.getValidatorsDefinition())) {
      if (this.props[validator2] !== void 0) {
        validatorRules[validator2] = this.props[validator2];
      }
    }
    resultObj = this._validator.validate(value, validatorRules);
    if (event.type === "reset") {
      resultObj = {
        valid: true
      };
    }
    this._applyResult(resultObj, event);
  }
  _getFieldValue() {
    switch (true) {
      case this._$field.type === "checkbox":
        return this._getCheckboxValues();
      case this._$field.type === "range":
        return this._getRangeValue();
      case this._$field.tagName.toLowerCase() === "select":
        return this._getSelectValues();
      case this._$field.type === "radio":
        return this._getRadioValue();
      default:
        return this._$field.value;
    }
  }
  _getCheckboxValues() {
    return Array.from(
      this.node.querySelectorAll('input[type="checkbox"]:checked')
    ).map(($item) => $item.value);
  }
  _getRadioValue() {
    return this.node.querySelector('input[type="radio"]:checked').value;
  }
  _getRangeValue() {
    return parseFloat(this._$field.value);
  }
  _getSelectValues() {
    return Array.from(this._$field.querySelectorAll("option")).filter(($item) => $item.selected).map(($item) => $item.value);
  }
  _applyResult(res, event) {
    var _a3, _b2, _c2, _d2, _e2, _f2;
    return __awaiter$d(this, void 0, void 0, function* () {
      for (let [validator2, definition2] of Object.entries(SValidator.getValidatorsDefinition())) {
        if (!this.props[validator2]) {
          continue;
        }
        if (this.props.handlers[validator2]) {
          yield this.props.handlers[validator2]({
            result: Object.assign({}, (_b2 = (_a3 = res.rules) === null || _a3 === void 0 ? void 0 : _a3[validator2]) !== null && _b2 !== void 0 ? _b2 : res),
            props: this.props,
            $feature: this.node,
            $form: this._$form,
            $field: this._$field,
            $node: (_c2 = this._nodeByValidator) === null || _c2 === void 0 ? void 0 : _c2[validator2]
          });
        }
      }
      if (!res.valid) {
        this._isDirty = true;
        this.node.classList.add(...this.props.errorClass.split(" "));
        this.node.classList.remove(...this.props.validClass.split(" "));
        const firstInvalidValidator = Object.keys(res.rules)[0];
        if (!Object.keys(this._nodeByValidator).length) {
          const finalMessage = this.props[`${firstInvalidValidator}Message`] || res.messages[0];
          if (this.props.displayError) {
            this._$error = (_d2 = this.node.querySelector(`[${this.props.errorContainerAttr}]`)) !== null && _d2 !== void 0 ? _d2 : this.node.nextElementSibling;
            if (!this._$error || !this._$error.hasAttribute("s-form-validate-error")) {
              this._$error = document.createElement("p");
              this._$error.setAttribute("s-form-validate-error", "true");
              this._$error.classList.add("s-form-validate-error-message");
              this.node.parentNode.insertBefore(this._$error, this.node.nextSibling);
            }
            this._$error.innerHTML = finalMessage;
          }
        } else {
          for (let [validator2, validationObj] of Object.entries(res.rules)) {
            if (!this._nodeByValidator[validator2])
              continue;
            if (validationObj.valid) {
              this._nodeByValidator[validator2].classList.remove(...this.props.errorClass.split(" "));
              this._nodeByValidator[validator2].classList.add(...this.props.validClass.split(" "));
            } else {
              this._nodeByValidator[validator2].classList.remove(...this.props.validClass.split(" "));
              this._nodeByValidator[validator2].classList.add(...this.props.errorClass.split(" "));
            }
          }
        }
        this.componentUtils.dispatchEvent("error", {
          detail: res
        });
      } else {
        this._isDirty = false;
        if (event.type !== "reset") {
          this.node.classList.add(...this.props.validClass.split(" "));
        } else {
          this.node.classList.remove(...this.props.validClass.split(" "));
        }
        this.node.classList.remove(...this.props.errorClass.split(" "));
        if ((_e2 = this._$error) === null || _e2 === void 0 ? void 0 : _e2.hasAttribute("s-form-validate-error")) {
          (_f2 = this._$error) === null || _f2 === void 0 ? void 0 : _f2.remove();
        }
        if (Object.keys(this._nodeByValidator).length) {
          for (let [validator2, validationObj] of Object.entries(res.rules)) {
            if (!this._nodeByValidator[validator2])
              continue;
            this._nodeByValidator[validator2].classList.remove(...this.props.errorClass.split(" "));
            this._nodeByValidator[validator2].classList.add(...this.props.validClass.split(" "));
          }
        }
        this.componentUtils.dispatchEvent("valid", {
          detail: res
        });
      }
    });
  }
}
class SInlineFeatureInterface extends SInterface {
  static get _definition() {
    return {};
  }
}
function define$n(props = {}, name2 = "s-inline") {
  SInlineFeature.define(name2, SInlineFeature, props);
}
const sInlineFeature = "";
var __awaiter$c = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SInlineFeature extends SFeature {
  constructor(name2, node, settings) {
    super(name2, node, __deepMerge({
      name: "s-inline",
      interface: SInlineFeatureInterface
    }, settings !== null && settings !== void 0 ? settings : {}));
  }
  mount() {
    if (this.node.tagName === "IMG") {
      const src2 = this.node.src;
      this._inlineImg(src2);
    } else {
      throw new Error(`Sorry but your s-inline marked Element cannot be inlined. At least for now...`);
    }
  }
  _inlineImg(src2) {
    return __awaiter$c(this, void 0, void 0, function* () {
      const r = yield fetch(src2);
      const text = yield r.text();
      const parser = new DOMParser();
      const $svg = parser.parseFromString(text, "text/html").body.firstChild;
      $svg.setAttribute("class", this.node.getAttribute("class"));
      this.node.after($svg);
      this.node.remove();
    });
  }
}
class SPanelComponentInterface extends SInterface {
  static get _definition() {
    return {
      position: {
        description: 'Specify the side where to display the panel. Can be "top","left","bottom" or "right"',
        type: "String",
        values: ["top", "left", "bottom", "right", "modal"],
        default: "modal",
        physical: true
      },
      active: {
        description: "Specify the panel initial state",
        type: "Boolean",
        default: false,
        physical: true
      },
      backdrop: {
        description: 'Specify if you want an "backdrop" between the panel and your content',
        type: "Boolean",
        default: false
      },
      triggerer: {
        description: "Specify a css selector that targets the elements in your UI you want to open the panel on click",
        type: "String"
      },
      closeOn: {
        description: 'Specify which "action(s)" close the panel. Valid values are "click" or/and "escape" or/and "event:%eventName',
        type: {
          type: "Array<String>",
          splitChars: [","]
        },
        values: ["click", "escape"],
        default: ["click", "escape"]
      }
    };
  }
}
const __css$d = ".s-panel {\n    display: block;\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    z-index: 99999;\n    pointer-events: none;\n}\n\n    .s-panel[active] {\n        pointer-events: all;\n    }\n\n    .s-panel:not([mounted]) > * {\n        display: none;\n    }\n\n.s-pane__root {\n    display: block;\n    position: fixed;\n    top: 0;\n    left: 0;\n}\n\n.s-panel__backdrop {\n    /* position: absolute;\n    top: 0;\n    left: 0;\n    z-index: 0;\n    width: 100%;\n    height: 100%; */position: fixed;\n        top: 0;\n        left: 0;\n        width: 200vw;\n        height: calc(200 * var(--vh,1vh)) ;\n        z-index: 100;\n        transform: translate(-50%, -50%);\n     \n \n                    background: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-background-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-background-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-background-lightness-offset, 0)) * 1%),0.7);\n                    -webkit-backdrop-filter: blur(5px);\n                            backdrop-filter: blur(5px);\n    z-index: 0;\n}\n\n.s-panel__container {\n    display: none;\n    position: absolute;\n    z-index: 1;\n    overflow: auto;\n}\n\n.s-panel__container::-webkit-scrollbar {\n          width: 2px;\n          height: 2px;\n      }\n\n.s-panel__container::-webkit-scrollbar-track {\n            \n                background-color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),0.1);\n            \n\n      }\n\n.s-panel__container::-webkit-scrollbar-thumb {\n          \n            background-color: hsla(calc(var(--s-theme-color-accent-h, 0) + var(--s-theme-color-accent-spin ,0)),calc((var(--s-theme-color-accent-s, 0)) * 1%),calc((var(--s-theme-color-accent-l, 0)) * 1%),var(--s-theme-color-accent-a, 1));\n          \n      }\n\n@media screen and (max-width: 639px) {\n\n.s-panel__container {\n        width: 90vw;\n        min-width: auto;\n        max-width: auto;\n}\n}\n\n[mounted] .s-panel__container {\n        display: block;\n    }\n\n[position='left'] .s-panel__container {\n        left: 0;\n        top: 0;\n        height: 100%;\n        min-width: 40px;\n        max-width: 90vw;\n        transform: translateX(-100%);\n    }\n\n[position='top'] .s-panel__container {\n        left: 0;\n        top: 0;\n        width: 100%;\n        min-height: 40px;\n        max-height: calc(90 * var(--vh,1vh)) ;\n        transform: translateY(-100%);\n    }\n\n[position='right'] .s-panel__container {\n        right: 0;\n        top: 0;\n        height: 100%;\n        min-width: 40px;\n        max-width: 90vw;\n        transform: translateX(100%);\n    }\n\n[position='bottom'] .s-panel__container {\n        left: 0;\n        bottom: 0;\n        width: 100%;\n        min-height: 40px;\n        max-height: calc(90 * var(--vh,1vh)) ;\n        transform: translateY(100%);\n    }\n\n[position='modal'] .s-panel__container {\n        max-width: 90vw;\n        max-height: calc(90 * var(--vh,1vh)) ;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -40%);\n    }\n\n[active][position='modal'] .s-panel__container {\n        transform: translate(-50%, -50%);\n    }\n\n[active] .s-panel__container {\n        transform: translateX(0) translateY(0);\n    }\n\n.s-panel__root {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n}\n\n.s-panel[lnf='default'] .s-panel__backdrop {\n        background: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-surface-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-surface-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-surface-lightness-offset, 0)) * 1%),0.6);\n        transition: var(--s-theme-ui-panel-transition, 0);\n        opacity: 0;\n    }\n\n.s-panel[lnf='default'] .s-panel__container {\n        transition: var(--s-theme-ui-panel-transition, 0);\n        background: hsla(calc(var(--s-theme-color-main-h, 0) + var(--s-theme-color-main-background-spin ,0)),calc((var(--s-theme-color-main-s, 0) + var(--s-theme-color-main-background-saturation-offset, 0)) * 1%),calc((var(--s-theme-color-main-l, 0) + var(--s-theme-color-main-background-lightness-offset, 0)) * 1%),var(--s-theme-color-main-background-a, 1));box-shadow: var(--s-theme-depth-5, 0);border-radius: calc(calc(var(--s-theme-border-radius-default, 5px) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 1);\n        opacity: 0;\n    }\n\n.s-panel[lnf='default'][active] .s-panel__container,\n        .s-panel[lnf='default'][active] .s-panel__backdrop {\n            opacity: 1;\n        }\n";
var __awaiter$b = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SPanelComponent extends SLitComponent {
  constructor() {
    super(__deepMerge({
      name: "s-panel",
      interface: SPanelComponentInterface
    }));
    if (this.id) {
      const $panels = document.querySelectorAll(`s-panel#${this.id}`);
      $panels.forEach(($panel) => $panel !== this && $panel.remove());
    }
  }
  static get properties() {
    return SLitComponent.propertiesFromInterface({}, SPanelComponentInterface);
  }
  static get styles() {
    return css$1`
            ${unsafeCSS(__css$d)}
        `;
  }
  mount() {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (this.props.active) {
        this.constructor._activePanels.push(this);
      }
      const $tpl = this.querySelector("template");
      if ($tpl) {
        this._template = $tpl.content;
      }
    });
  }
  isTopPanel() {
    const stackIdx = this.constructor._activePanels.indexOf(this);
    return stackIdx === this.constructor._activePanels.length - 1;
  }
  updated(changedProperties) {
    changedProperties.forEach((oldValue, propName) => {
      if (propName === "active") {
        if (this.props.active) {
          this.open();
        } else {
          this.close();
        }
      }
    });
  }
  firstUpdated() {
    this._$container = this.querySelector(`.${this.componentUtils.uniqueClassName("__container")}`);
    this._$backdrop = this.querySelector(`.${this.componentUtils.uniqueClassName("__backdrop")}`);
    this._containerTransitionProps = getTransitionProperties(this._$container);
    if (this._$backdrop) {
      this._backdropTransitionProps = getTransitionProperties(this._$backdrop);
    }
    this.props.closeOn.forEach((what) => {
      if (what === "click") {
        this.addEventListener("click", (e) => {
          !this._$container.contains(e.target) && this.isTopPanel() && this.close();
        });
      } else if (what === "escape") {
        __hotkey("escape").on("press", () => {
          this.isTopPanel() && this.close();
        });
      } else if (what.match(/^event\:/)) {
        const event = what.split(":").pop();
        this.addEventListener(event, (e) => {
          this.close();
        });
      }
    });
    if (this.id) {
      const $panels = document.querySelectorAll(`s-panel#${this.id}`);
      if ($panels.length > 1) {
        throw new Error(`[s-panel] Be careful. You have multiple panels with the same "${this.id}" id...`);
      }
      __querySelectorLive(`[href="#${this.id}"]`, ($elm) => {
        $elm.addEventListener("click", (e) => {
          e.preventDefault();
          this.open();
        });
      }, {});
      __querySelectorLive(`[s-panel-open="${this.id}"]`, ($elm) => {
        $elm.addEventListener("click", (e) => {
          e.preventDefault();
          this.open();
        });
      }, {});
      __querySelectorLive(`[s-panel-close="${this.id}"]`, ($elm) => {
        $elm.addEventListener("click", (e) => {
          e.preventDefault();
          this.close();
        });
      }, {});
    }
    if (this.props.triggerer) {
      __querySelectorLive(this.props.triggerer, ($triggerer) => {
        $triggerer.addEventListener("click", (e) => {
          this.open();
        });
      });
    }
  }
  open() {
    if (this.props.active)
      return;
    if (!this._$ghost) {
      this._$ghost = document.createElement("div");
      this._$ghost.setAttribute("s-panel-ghost", "true");
      this.parentNode.insertBefore(this._$ghost, this);
    }
    if (this.parentNode !== document.body) {
      document.body.appendChild(this);
    }
    if (!this.constructor._activePanels.includes(this)) {
      this.constructor._activePanels.push(this);
    }
    setTimeout(() => {
      this.props.active = true;
      this.requestUpdate();
      this.componentUtils.dispatchEvent("open");
    });
  }
  activate() {
    return this.open();
  }
  close() {
    var _a3, _b2;
    if (!this.props.active)
      return;
    const stackIdx = this.constructor._activePanels.indexOf(this);
    if (stackIdx !== -1) {
      delete this.constructor._activePanels[stackIdx];
    }
    this.props.active = false;
    this.requestUpdate();
    this.componentUtils.dispatchEvent("close");
    let duration = 0;
    if (this._containerTransitionProps.totalDuration > duration)
      duration = this._containerTransitionProps.totalDuration;
    if (((_a3 = this._backdropTransitionProps) === null || _a3 === void 0 ? void 0 : _a3.totalDuration) > duration)
      duration = (_b2 = this._backdropTransitionProps) === null || _b2 === void 0 ? void 0 : _b2.totalDuration;
    setTimeout(() => {
      if (!this._$ghost)
        return;
      this._$ghost.parentNode.insertBefore(this, this._$ghost);
    }, duration);
  }
  unactivate() {
    return this.close();
  }
  render() {
    var _a3;
    return html`
            <div
                class="${this.componentUtils.className("__root")} ${this.componentUtils.className(`--${this.props.position}`)}"
            >
                ${this.props.backdrop ? html`
                          <div
                              class="${this.componentUtils.className("__backdrop")}"
                          ></div>
                      ` : ""}
                <div class="${this.componentUtils.className("__container")}">
                    ${(_a3 = this._template) !== null && _a3 !== void 0 ? _a3 : ""}
                </div>
            </div>
        `;
  }
}
SPanelComponent._activePanels = [];
function define$m(props = {}, tagName = "s-panel") {
  SLitComponent.define(tagName, SPanelComponent, props);
}
class SRangeComponentInterface extends SInterface {
  static get _definition() {
    return {
      name: {
        type: "String",
        description: 'Specify the name to assign to the internal input[type="range"]'
      },
      value: {
        type: "Number",
        description: "Specify the initial range value"
      },
      values: {
        type: "Object",
        description: 'Specify some values in array like ["hello","world"] that will be used for tooltip. Your range steps MUST be integers for this to work properly'
      },
      min: {
        type: "Number",
        description: "Specify the minimal value or the range",
        default: 0
      },
      max: {
        type: "Number",
        description: "Specify the maximal value of the range",
        default: 100
      },
      step: {
        type: "Number",
        description: "Specify the steps between each values"
      },
      target: {
        type: "String",
        description: "Specify a css selector of any HTMLElement or HTMLInputElement in which to inject the value when the range is updated"
      },
      tooltip: {
        type: "Boolean",
        description: "Specify if you want to display the value inside a tooltip on top of the thumb",
        default: false
      },
      disabled: {
        type: "Boolean",
        description: "Specify if this range is disabled",
        default: false
      }
    };
  }
}
const __css$c = ".s-range {\n    display: block;\n    width: 100%;\n}\n\n    .s-range:not([mounted]) > * {\n        display: none;\n    }\n\n    .s-range[disabled] {\n        pointer-events: none;\n    }\n.s-range__root {\n    display: flex;\n    width: 100%;\n}\n.s-range__input {\n    flex-grow: 1;\n    opacity: 1 !important;\n}\n.s-range__input:hover + .s-range__tooltip,\n.s-range__input:focus + .s-range__tooltip {\n    opacity: 1 !important;\n}\n.s-lod--2 .s-range__tooltip {\n    transition: none;\n}\n";
var __awaiter$a = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SRangeComponent extends SLitComponent {
  static get properties() {
    return SLitComponent.propertiesFromInterface({}, SRangeComponentInterface);
  }
  static get styles() {
    return css$1`
            ${unsafeCSS(`
                ${__css$c}
            `)}
        `;
  }
  constructor() {
    super(__deepMerge({
      name: "s-range",
      interface: SRangeComponentInterface
    }));
  }
  firstUpdated() {
    var _a3;
    return __awaiter$a(this, void 0, void 0, function* () {
      this._$input = this.querySelector("input");
      this._$tooltip = this.querySelector(".s-range__tooltip");
      this._$input.addEventListener("input", (e) => {
        this._handleTooltip();
        this._handleTarget();
      });
      if (this.props.target) {
        this._$targets = Array.from(document.querySelectorAll(this.props.target));
      }
      this._$input.value = this.props.value;
      if ((_a3 = this._$input) === null || _a3 === void 0 ? void 0 : _a3.form) {
        this._$input.form.addEventListener("reset", () => {
          setTimeout(() => {
            this._handleTooltip();
            this._handleTarget();
          });
        });
      }
      this._handleTooltip();
      this._handleTarget();
    });
  }
  _handleTarget() {
    if (!this._$targets)
      return;
    this._$targets.forEach(($target) => {
      $target.innerHTML = this._$input.value;
      $target.value = this._$input.value;
    });
  }
  _handleTooltip() {
    if (!this._$tooltip)
      return;
    const val = this._$input.value;
    const min2 = this._$input.min ? this._$input.min : 0;
    const max2 = this._$input.max ? this._$input.max : 100;
    const newVal = Number((val - min2) * 100 / (max2 - min2));
    this._$tooltip.style.left = `calc(${newVal}% + (${8 - newVal * 0.15}px))`;
    let tooltipValue = val;
    if (this.props.values && this.props.values[val]) {
      tooltipValue = this.props.values[val];
    }
    this._$tooltip.innerHTML = tooltipValue;
  }
  render() {
    return html`
            <div
                class="${this.componentUtils.className("__root", "s-tooltip-container")}"
            >
                <input
                    class="${this.componentUtils.className("__input", "s-range")}"
                    type="range"
                    ?disabled="${this.props.disabled}"
                    name="${this.props.name}"
                    value="${this.props.value}"
                    min="${this.props.min}"
                    max="${this.props.max}"
                    step="${this.props.step}"
                />
                ${this.props.tooltip ? html`
                          <div
                              class="${this.componentUtils.className("__tooltip", "s-tooltip")}"
                          ></div>
                      ` : ""}
            </div>
        `;
  }
}
function define$l(props = {}, tagName = "s-range") {
  SLitComponent.define(tagName, SRangeComponent, props);
}
class SRefocusFeatureInterface extends SInterface {
  static get _definition() {
    return {
      trigger: {
        description: "Specify some trigger(s) on which to refocus a particular element like `event:actual`, `anchor`, `history`, etc...",
        type: {
          type: "Array<String>",
          splitChars: [","]
        },
        values: ["event:eventName", "anchor", "history"],
        default: []
      },
      timeout: {
        description: "Specify a timeout to wait before refocus the element",
        type: "Number",
        default: 500
      },
      duration: {
        description: "Specify the duration of the refocus animation",
        type: "Number"
      },
      easing: {
        description: "Specify the easing function of the refocus animation",
        type: "Function"
      },
      offset: {
        description: "Specify the offset of the refocus animation in px",
        type: "Number"
      },
      offsetX: {
        description: "Specify the offset x of the refocus animation in px",
        type: "Number"
      },
      offsetY: {
        description: "Specify the offset y of the refocus animation in px",
        type: "Number"
      },
      align: {
        description: "Specify the alignment of the refocus animation",
        type: "String",
        values: ["start", "center", "end"]
      },
      justify: {
        description: "Specify the justification of the refocus animation",
        type: "String",
        values: ["start", "center", "end"]
      }
    };
  }
}
function define$k(props = {}, name2 = "s-refocus") {
  SRefocusFeature.define(name2, SRefocusFeature, Object.assign({}, props));
}
class SRefocusFeature extends SFeature {
  constructor(name2, node, settings) {
    super(name2, node, __deepMerge({
      name: "s-refocus",
      interface: SRefocusFeatureInterface
    }, settings !== null && settings !== void 0 ? settings : {}));
  }
  mount() {
    this.props.trigger.forEach((trigger2) => {
      switch (trigger2) {
        case "anchor":
          setTimeout(() => {
            if (document.location.hash) {
              const $targetElm = this.node.querySelector(document.location.hash);
              if ($targetElm) {
                this._scrollTo($targetElm);
              }
            }
          }, this.props.timeout);
          break;
        case "history":
          window.addEventListener("hashchange", (e) => {
            if (document.location.hash) {
              const $targetElm = this.node.querySelector(document.location.hash);
              if ($targetElm) {
                this._scrollTo($targetElm);
              }
            }
          });
          window.addEventListener("popstate", (e) => {
            if (document.location.hash) {
              const $targetElm = this.node.querySelector(document.location.hash);
              if ($targetElm) {
                this._scrollTo($targetElm);
              }
            }
          });
          break;
        default:
          if (trigger2.match(/^event:/)) {
            const event = trigger2.replace("event:", "").trim();
            this.node.addEventListener(event, (e) => {
              this._scrollTo(e.target);
            });
          }
          break;
      }
    });
  }
  _scrollTo($elm) {
    const scrollToSettings = {
      $elm: this.node
    };
    if (this.props.duration)
      scrollToSettings.duration = this.props.duration;
    if (this.props.easing)
      scrollToSettings.easing = this.props.easing;
    if (this.props.offset)
      scrollToSettings.offset = this.props.offset;
    if (this.props.offsetX)
      scrollToSettings.offsetX = this.props.offsetX;
    if (this.props.offsetY)
      scrollToSettings.offsetY = this.props.offsetY;
    if (this.props.align)
      scrollToSettings.align = this.props.align;
    if (this.props.justify)
      scrollToSettings.justify = this.props.justify;
    __scrollTo($elm, scrollToSettings);
  }
}
class SScrollComponentInterface extends SInterface {
  static get _definition() {
    return {
      to: {
        description: "The target when to scroll. Must be a valid css selector",
        type: "String",
        required: true
      },
      duration: {
        description: "Specify the duration of the scroll in ms",
        type: "number",
        default: STheme.get("scroll.duration")
      },
      offset: {
        description: "Specify the offset of the scroll in px. Usefull if you have a sticky header, etc...",
        type: "number",
        default: STheme.get("scroll.offset")
      },
      offsetX: {
        description: "Specify the offset of the scroll x in px. Usefull if you have a sticky header, etc...",
        type: "number",
        default: STheme.get("scroll.offsetX")
      },
      offsetY: {
        description: "Specify the offset of the scroll y in px. Usefull if you have a sticky header, etc...",
        type: "number",
        default: STheme.get("scroll.offsetY")
      }
    };
  }
}
function define$j(props = {}, tagName = "s-scroll") {
  SScrollComponent.define(tagName, SScrollComponent, props);
}
const __css$b = "s-scroll {\n    display: inline-block;\n    cursor: pointer;\n}\n";
var __awaiter$9 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SScrollComponent extends SLitComponent {
  static get properties() {
    return SLitComponent.propertiesFromInterface({}, SScrollComponentInterface);
  }
  static get styles() {
    return css$1`
            ${unsafeCSS(`
                ${__css$b}
            `)}
        `;
  }
  constructor() {
    super(__deepMerge({
      name: "s-scroll",
      interface: SScrollComponentInterface
    }));
  }
  firstUpdated() {
    return __awaiter$9(this, void 0, void 0, function* () {
      this.addEventListener("click", (e) => {
        e.preventDefault();
        this._scrollTo(this.props.to);
      });
    });
  }
  _scrollTo(target) {
    const scrollConfig = STheme.get("scroll");
    const duration = this.props.duration || (scrollConfig === null || scrollConfig === void 0 ? void 0 : scrollConfig.duration) || 300;
    const offset2 = this.props.offset || scrollConfig.offset || 0;
    const offsetX = this.props.offsetX || scrollConfig.offsetX || offset2;
    const offsetY = this.props.offsetY || scrollConfig.offsetY || offset2;
    switch (target) {
      case "top":
        __scrollTo("top", {
          duration,
          offset: offset2,
          offsetX,
          offsetY
        });
        break;
      case "bottom":
        __scrollTo("bottom", {
          duration,
          offset: offset2,
          offsetX,
          offsetY
        });
        break;
      default:
        const $target = document.querySelector(target);
        if (!$target)
          return;
        __scrollTo($target, {
          duration,
          offset: offset2,
          offsetX,
          offsetY
        });
        break;
    }
  }
  render() {
    return html``;
  }
}
const __css$a = ".s-slider {\n    display: block;\n    font-size: calc(1rem * var(--s-scale, 1) * var(--s-scale-global, 1));\n    --s-slider-space: 20px;\n}\n\n    .s-slider > .s-slider__root,\n    .s-slider > .s-slider__root > .s-slider__slides-wrapper,\n    .s-slider > .s-slider__root > .s-slider__slides-wrapper > .s-slider__slides {\n        height: 100%;\n        width: 100%;\n    }\n\n    .s-slider[direction='vertical'][pad] > .s-slider__root > .s-slider__slides-wrapper > .s-slider__slides > .s-slider__pad-start {\n                    height: var(--s-slider-pad-start, 0);\n                }\n\n    .s-slider[direction='vertical'][pad] > .s-slider__root > .s-slider__slides-wrapper > .s-slider__slides > .s-slider__pad-end {\n                    height: var(--s-slider-pad-end, 0);\n                }\n\n    .s-slider[direction='horizontal'][pad] > .s-slider__root > .s-slider__slides-wrapper > .s-slider__slides > .s-slider__pad-start {\n                    width: var(--s-slider-pad-start, 0);\n                }\n\n    .s-slider[direction='horizontal'][pad] > .s-slider__root > .s-slider__slides-wrapper > .s-slider__slides > .s-slider__pad-end {\n                    width: var(--s-slider-pad-end, 0);\n                }\n\n.s-slider[behavior='scroll'] > .s-slider__root > .s-slider__slides-wrapper {\n            overflow: auto;\n            scroll-snap-type: x mandatory;\n\n            /* hide scrollbar */\n            -ms-overflow-style: none;\n            scrollbar-width: none;\n        }\n\n.s-slider[behavior='scroll'] > .s-slider__root > .s-slider__slides-wrapper::-webkit-scrollbar {\n                display: none;\n            }\n\n.s-slider[behavior='scroll'] > .s-slider__root > .s-slider__slides-wrapper > .s-slider__slides > .s-slider__slide {\n                    scroll-snap-align: center;\n                }\n\n.s-slider[behavior='scroll'][direction='vertical'] > .s-slider__root > .s-slider__slides-wrapper {\n                scroll-snap-type: y mandatory;\n            }\n\n.s-slider[lnf^='default'] {\n    position: relative;\n    --s-slider-space: 20px;\n}\n\n.s-slider[lnf^='default']:not([class*='s-ratio']) {\n        aspect-ratio: 16/9;\n    }\n\n.s-slider[lnf^='default']:not([mounted]) {\n        opacity: 0;\n    }\n\n.s-slider[lnf^='default'] .s-slider__ui {\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        width: 100%;\n        height: 100%;\n        transform: translate(-50%, -50%);\n        pointer-events: none;\n    }\n\n.s-slider[lnf^='default'] .s-slider__ui * {\n            pointer-events: all;\n        }\n\n.s-slider[lnf^='default'][pad] > .s-slider__root > .s-slider__slides-wrapper > .s-slider__slides > .s-slider__pad {\n                    flex-shrink: 0;\n                    flex-grow: 0;\n                }\n\n.s-slider[lnf^='default'] > .s-slider__root {\n        position: relative;\n    }\n\n.s-slider[lnf^='default'] > .s-slider__root > .s-slider__slides-wrapper {\n            /* position: absolute;\n            top: 0;\n            left: 0; */\n            width: 100%;\n            height: 100%;\n        }\n\n.s-slider[lnf^='default'] > .s-slider__root > .s-slider__slides-wrapper > .s-slider__slides {\n                display: inline-flex;\n                -webkit-user-select: none;\n                   -moz-user-select: none;\n                        user-select: none;\n                height: 100%;\n            }\n\n/* white-space: nowrap; */\n\n.s-slider[lnf^='default'] > .s-slider__root > .s-slider__slides-wrapper > .s-slider__slides > .s-slider__slide {\n                    display: block;\n                    flex-shrink: 0;\n                    flex-grow: 0;\n                    width: 100%;\n                    height: 100%;\n                    scroll-snap-align: center;\n\n                    /* &:nth-child(1) {\n                        background: red;\n                        width: 500px !important;\n                    }\n                    &:nth-child(2) {\n                        background: yellow;\n                        width: 800px !important;\n                    }\n                    &:nth-child(3) {\n                        background: blue;\n                        width: 80vw !important;\n                    } */\n                }\n\n.s-slider[lnf^='default'] > .s-slider__root > .s-slider__ui > .s-slider__nav {\n                position: absolute;\n                top: calc(100% + var(--s-slider-space));\n                left: 50%;\n                transform: translate(-50%);\n                display: flex;\n                gap: calc(var(--s-slider-space) * 0.5);\n            }\n\n.s-slider[lnf^='default'] > .s-slider__root > .s-slider__ui > .s-slider__nav > * {\n                    border-radius: 50%;\n                    display: block;\n                    width: 0.5em;\n                    height: 0.5em;\n                    background: currentColor;\n                    opacity: 0.3;\n                    cursor: pointer;\n                }\n\n.s-slider[lnf^='default'] > .s-slider__root > .s-slider__ui > .s-slider__nav > *:hover {\n                        opacity: 0.6;\n                    }\n\n.s-slider[lnf^='default'] > .s-slider__root > .s-slider__ui > .s-slider__nav > *.active {\n                        opacity: 1;\n                    }\n\n.s-slider[lnf^='default'][direction='vertical']\n        > .s-slider__root\n        > .s-slider__slides-wrapper\n        > .s-slider__slides {\n        display: block;\n        width: 100%;\n        height: auto;\n    }\n\n.s-slider[lnf^='default'][direction='vertical']\n        > .s-slider__root\n        > .s-slider__slides-wrapper\n        > .s-slider__slides > .s-slider__slide {\n            display: block;\n            width: 100% !important;\n\n            /* &:nth-child(1) {\n                background: red;\n                height: 500px !important;\n            }\n            &:nth-child(2) {\n                background: yellow;\n                height: 800px !important;\n            }\n            &:nth-child(3) {\n                background: blue;\n                height: 400px !important;\n            } */\n        }\n\n.s-slider[lnf^='default'][lnf*='contained'] .s-slider__root > .s-slider__ui > .s-slider__nav {\n        top: auto;\n        bottom: calc(var(--s-slider-space) - 0.5em);\n        transform: translate(-50%, -100%);\n    }\n\n.s-slider[lnf^='default'][direction='vertical'] .s-slider__root > .s-slider__ui > .s-slider__nav {\n        top: 50%;\n        left: calc(100% + var(--s-slider-space));\n        transform: translate(0, -50%);\n        flex-direction: column;\n    }\n\n.s-slider[lnf^='default'][lnf*='contained'][direction='vertical']\n        .s-slider__root\n        > .s-slider__ui\n        > .s-slider__nav {\n        bottom: auto;\n        left: auto;\n        right: calc(var(--s-slider-space));\n        transform: translate(0, -50%);\n    }\n\n.s-slider[lnf^='default'][lnf*='tight'][direction='horizontal'][controls] {\n        padding-left: calc(var(--s-slider-space) + 1em);\n        padding-right: calc(var(--s-slider-space) + 1em);\n    }\n\n.s-slider[lnf^='default'][lnf*='tight'][direction='horizontal'][nav] {\n        padding-bottom: calc(var(--s-slider-space) + 1em);\n    }\n\n.s-slider[lnf^='default'][lnf*='tight'][direction='vertical'][controls] {\n        padding-top: calc(var(--s-slider-space) + 1em);\n        padding-bottom: calc(var(--s-slider-space) + 1em);\n    }\n\n.s-slider[lnf^='default'][lnf*='tight'][direction='vertical'][nav] {\n        padding-right: calc(var(--s-slider-space) + 1em);\n    }\n\n.s-slider[lnf^='default'] > .s-slider__root > .s-slider__ui > .s-slider__progress {\n        position: absolute;\n        bottom: var(--s-slider-space);\n        left: var(--s-slider-space);\n        right: var(--s-slider-space);\n        height: 0.5em;\n    }\n\n.s-slider[lnf^='default'] > .s-slider__root > .s-slider__ui > .s-slider__progress:before {\n            content: '';\n            display: block;\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: currentColor;\n            opacity: 0.3;\n        }\n\n.s-slider[lnf^='default'] > .s-slider__root > .s-slider__ui > .s-slider__progress > .s-slider__progress-bar {\n            position: absolute;\n            top: 0;\n            left: 0;\n            height: 100%;\n            width: calc(\n                100% / (var(--s-slider-total-pages)) *\n                    (var(--s-slider-page) + 1)\n            );\n            background: currentColor;\n        }\n\n.s-slider[lnf^='default'][lnf*='contained'] .s-slider__root > .s-slider__ui > .s-slider__progress {\n        bottom: calc(var(--s-slider-space) * 2);\n    }\n\n.s-slider[lnf^='default'] > .s-slider__root > .s-slider__ui > .s-slider__controls .s-slider__controls-next,\n        .s-slider[lnf^='default'] > .s-slider__root > .s-slider__ui > .s-slider__controls .s-slider__controls-previous {\n            width: 1em;\n            height: 1em;\n            position: absolute;\n            top: 50%;\n            transform: translateY(-50%);\n            cursor: pointer;\n            opacity: 0.3;\n            pointer-events: none;\n            color: currentColor;\n        }\n\n.s-slider[lnf^='default'] > .s-slider__root > .s-slider__ui > .s-slider__controls .s-slider__controls-next.active, .s-slider[lnf^='default'] > .s-slider__root > .s-slider__ui > .s-slider__controls .s-slider__controls-previous.active {\n                pointer-events: all;\n                opacity: 1;\n            }\n\n.s-slider[lnf^='default'] > .s-slider__root > .s-slider__ui > .s-slider__controls .s-slider__controls-previous {\n            right: calc(100% + var(--s-slider-space));\n        }\n\n.s-slider[lnf^='default'] > .s-slider__root > .s-slider__ui > .s-slider__controls .s-slider__controls-next {\n            left: calc(100% + var(--s-slider-space));\n        }\n\n.s-slider[lnf^='default'][lnf*='contained']\n        > .s-slider__root\n        > .s-slider__ui\n        > .s-slider__controls\n        .s-slider__controls-previous {\n        left: var(--s-slider-space);\n        transform: translate(0, -50%);\n    }\n\n.s-slider[lnf^='default'][lnf*='contained']\n        > .s-slider__root\n        > .s-slider__ui\n        > .s-slider__controls\n        .s-slider__controls-next {\n        left: auto;\n        right: var(--s-slider-space);\n        transform: translate(0, -50%);\n    }\n\n.s-slider[lnf^='default'][direction='vertical']\n        > .s-slider__root\n        > .s-slider__ui\n        > .s-slider__controls\n        .s-slider__controls-next {\n        left: 50%;\n        top: calc(100% + var(--s-slider-space));\n        transform: translate(-50%, 0) rotate(90deg);\n    }\n\n.s-slider[lnf^='default'][direction='vertical']\n        > .s-slider__root\n        > .s-slider__ui\n        > .s-slider__controls\n        .s-slider__controls-previous {\n        left: 50%;\n        bottom: calc(100% + var(--s-slider-space));\n        top: auto;\n        transform: translate(-50%, 0) rotate(90deg);\n    }\n\n.s-slider[lnf^='default'][direction='vertical'][lnf*='contained']\n        > .s-slider__root\n        > .s-slider__ui\n        > .s-slider__controls\n        .s-slider__controls-previous {\n        top: calc(var(--s-slider-space));\n    }\n\n.s-slider[lnf^='default'][direction='vertical'][lnf*='contained']\n        > .s-slider__root\n        > .s-slider__ui\n        > .s-slider__controls\n        .s-slider__controls-next {\n        top: auto;\n        bottom: calc(var(--s-slider-space));\n    }\n\n.s-slider[lnf^='default'] > .s-slider__root\n        > .s-slider__ui\n        > .s-slider__controls\n        .s-slider__controls-next-arrow,\n    .s-slider[lnf^='default'] > .s-slider__root\n        > .s-slider__ui\n        > .s-slider__controls\n        .s-slider__controls-previous-arrow {\n        width: 1em;\n        height: 1em;\n        position: absolute;\n        top: 0;\n        left: 0;\n    }\n\n.s-slider[lnf^='default'] > .s-slider__root\n        > .s-slider__ui\n        > .s-slider__controls\n        .s-slider__controls-next-arrow:before,\n        .s-slider[lnf^='default'] > .s-slider__root\n        > .s-slider__ui\n        > .s-slider__controls\n        .s-slider__controls-next-arrow:after,\n        .s-slider[lnf^='default'] > .s-slider__root\n        > .s-slider__ui\n        > .s-slider__controls\n        .s-slider__controls-previous-arrow:before,\n        .s-slider[lnf^='default'] > .s-slider__root\n        > .s-slider__ui\n        > .s-slider__controls\n        .s-slider__controls-previous-arrow:after {\n            display: block;\n            content: '';\n            position: absolute;\n            top: calc(50% - 0.1em);\n            left: 0;\n            background: currentColor;\n            width: 100%;\n            height: 0.2em;\n        }\n\n.s-slider[lnf^='default'] > .s-slider__root\n        > .s-slider__ui\n        > .s-slider__controls\n        .s-slider__controls-next-arrow:before, .s-slider[lnf^='default'] > .s-slider__root\n        > .s-slider__ui\n        > .s-slider__controls\n        .s-slider__controls-previous-arrow:before {\n            transform-origin: 0 0;\n            transform: rotate(45deg);\n        }\n\n.s-slider[lnf^='default'] > .s-slider__root\n        > .s-slider__ui\n        > .s-slider__controls\n        .s-slider__controls-next-arrow:after, .s-slider[lnf^='default'] > .s-slider__root\n        > .s-slider__ui\n        > .s-slider__controls\n        .s-slider__controls-previous-arrow:after {\n            transform-origin: 0 100%;\n            transform: rotate(-45deg);\n        }\n\n.s-slider[lnf^='default'] > .s-slider__root\n        > .s-slider__ui\n        > .s-slider__controls\n        .s-slider__controls-next-arrow {\n        transform: rotate(180deg);\n    }\n";
class SSliderComponentInterface extends SInterface {
  static get _definition() {
    return {
      direction: {
        description: "Specify the slider direction. Can be `horizontal` or `vertical`",
        values: ["horizontal", "vertical"],
        type: "String",
        physical: true,
        default: "horizontal"
      },
      behaviors: {
        description: "Specify the available behaviors for the slider",
        type: "Object",
        default: {}
      },
      behavior: {
        description: 'Specify which behavior your want to use for your slider. Behavior are like "presets" with different animations, etc...',
        values: ["none", "scroll", "transform"],
        type: "String",
        default: "scroll",
        physical: true
      },
      pad: {
        type: "Boolean",
        description: "Specify if you want to pad the slides if for example the first slide does not take the while width of the slider, a padding-(block|inline)-start will be applied to center this first slide. Same for the last one",
        default: false
      },
      nextIconClass: {
        description: "Specify the class of the next icon",
        type: "String"
      },
      previousIconClass: {
        description: "Specify the class of the previous icon",
        type: "String"
      },
      uiContainer: {
        description: 'Specify if you want an "s-container:..." class applied on the .s-slider__ui element',
        type: "String|Boolean"
      },
      controls: {
        description: "Specify if you want to display the controls or not. Controls are the previous and next icons",
        type: "Boolean",
        default: false
      },
      nav: {
        description: "Specify if you want to display the nav or not. Nav are the dots",
        type: "Boolean",
        default: false
      },
      swipe: {
        description: "Specify if you want your slider to support swipe navigation or not",
        type: "Boolean",
        default: false
      },
      mousewheel: {
        description: "Specify if you want to enable the mousewheel event on the slider or not",
        type: "Boolean",
        default: false
      },
      clickOnSlide: {
        description: "Specify if you want to enable the click on the slides to navigate or not",
        type: "Boolean",
        default: false
      },
      loop: {
        description: "Specify if you want to enable the loop behavior or not",
        type: "Boolean",
        default: false
      },
      slide: {
        description: "Specify the active slide id",
        type: "Number",
        default: 0,
        physical: true
      },
      slidesByPage: {
        description: 'Specify how many slides you want by page. Pages are what is used to construct the dot nav and will determine how many slides will be passed on "next" and "previous"',
        type: "Number",
        default: 1
      },
      progress: {
        description: "Specify if you want to display the progress bar or not",
        type: "Boolean",
        default: false
      },
      timer: {
        description: 'Specify a timer that will be applied on each slides and go to the next one after the timer is over. For custom timer by slide, specify the `timer="1200"` attribute on the slides you want',
        type: "Number"
      },
      autoplay: {
        description: "Specify if you want the slider to auto play itself when some timer(s) has been set",
        type: "Boolean",
        default: true
      },
      intersectionClasses: {
        description: 'Specify if you want the classes that describe each slide intersection classes like "in-10", "in-20", etc...',
        type: "Boolean",
        default: false
      },
      transitionDuration: {
        description: "Specify the transition duration of the slider in ms",
        type: "Number",
        default: 500
      },
      transitionEasing: {
        description: "Specify the transition easing of the slider",
        type: "Function",
        default: __easeOutQuad
      },
      transitionHandler: {
        description: "Specify a function that will take care of transitioning the slider from the current item to the next/previous",
        type: "Function"
      }
    };
  }
}
const __scrollBehavior = {
  setup() {
    return new Promise((resolve, reject) => {
      let scrollTimeout;
      this.$slidesWrapper.addEventListener("scroll", (e) => {
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
          if (this.props.slidesByPage > 1) {
            return;
          }
          let $elm, lowerToCenter = 999999999999;
          for (let [key, $slide] of this.$slides.entries()) {
            const stats = __elementAreaStats($slide, {
              relativeTo: this.$slidesWrapper
            });
            if (this.props.direction === "vertical" && Math.abs(stats.centerOffsetY) <= lowerToCenter) {
              lowerToCenter = Math.abs(stats.centerOffsetY);
              $elm = $slide;
            } else if (this.props.direction === "horizontal" && Math.abs(stats.centerOffsetX) <= lowerToCenter) {
              lowerToCenter = Math.abs(stats.centerOffsetX);
              $elm = $slide;
            }
          }
          if ($elm) {
            const slideObj = this.getSlide($elm);
            this.setCurrentSlideByIdx(slideObj.idx);
          }
        }, 200);
      });
      resolve();
    });
  },
  transition($from, $to) {
    return new Promise((resolve, reject) => {
      this.$slidesWrapper.style.scrollSnapType = "none";
      const toRect = this.getPageRect($to), fromRect = this.getPageRect($from), sliderRect = this.getBoundingClientRect(), _this = this;
      let startX = this.$slidesWrapper.scrollLeft, startY = this.$slidesWrapper.scrollTop, fromOffset, toOffset, dist = 0;
      if (this.props.direction === "vertical") {
        fromOffset = (sliderRect.height - fromRect.height) * 0.5;
        toOffset = (sliderRect.height - toRect.height) * 0.5;
        dist = toRect.y - fromRect.y - toOffset + fromOffset;
      } else {
        fromOffset = (sliderRect.width - fromRect.width) * 0.5;
        toOffset = (sliderRect.width - toRect.width) * 0.5;
        dist = toRect.x - fromRect.x - toOffset + fromOffset;
      }
      __easeInterval(this.props.transitionDuration, (percentage) => {
        const offset2 = dist / 100 * percentage;
        if (_this.props.direction === "vertical") {
          _this.$slidesWrapper.scroll(0, Math.round(startY + offset2));
        } else {
          _this.$slidesWrapper.scroll(Math.round(startX + offset2), 0);
        }
      }, {
        easing: _this.props.transitionEasing,
        onEnd() {
          if (_this.props.direction === "vertical") {
            _this.$slidesWrapper.style.scrollSnapType = "y mandatory";
          } else {
            _this.$slidesWrapper.style.scrollSnapType = "x mandatory";
          }
          resolve();
        }
      });
    });
  }
};
var __awaiter$8 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SSliderComponent extends SLitComponent {
  constructor() {
    super(__deepMerge({
      name: "s-slider",
      interface: SSliderComponentInterface
    }));
    this._timer = {
      total: 0,
      current: 0,
      percentage: 0
    };
    this._bindedBehaviors = {};
  }
  static get properties() {
    return SLitComponent.propertiesFromInterface({}, SSliderComponentInterface);
  }
  static get styles() {
    return css$1`
            ${unsafeCSS(`
                ${__css$a}
            `)}
        `;
  }
  static get state() {
    return {
      currentPage: 0,
      previousSlideIdx: 0,
      currentSlideIdx: 0,
      playing: true
    };
  }
  mount() {
    return __awaiter$8(this, void 0, void 0, function* () {
      this.props.behaviors.scroll = __scrollBehavior;
      if (!this.id) {
        this.setAttribute("id", `s-slider-${__uniqid()}`);
      }
      this.$slides = Array.from(this.querySelectorAll(`[s-slider-slide],s-slider-slide`)).filter(($slide) => {
        const $parentSlider = __querySelectorUp($slide, ".s-slider");
        if (!$parentSlider || $parentSlider === this) {
          $slide.classList.add(...this.componentUtils.className("__slide").split(" "));
          return true;
        }
        return false;
      });
      if (this.props.slide) {
        this.setCurrentSlide(this.props.slide);
      }
      let resizeTimeout;
      window.addEventListener("resize", (e) => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => __awaiter$8(this, void 0, void 0, function* () {
          yield this.applyPad();
          this.goTo(this.getCurrentSlideIdx(), true);
        }), 200);
      });
    });
  }
  firstUpdated() {
    var _a3, _b2, _c2, _d2, _e2, _f2, _g;
    return __awaiter$8(this, void 0, void 0, function* () {
      this.$root = this.querySelector(`.${this.componentUtils.uniqueClassName("__root")}`);
      this.$slidesWrapper = this.querySelector(`.${this.componentUtils.uniqueClassName("__slides-wrapper")}:not(s-slider#${this.id} s-slider .${this.componentUtils.uniqueClassName("__slides-wrapper")})`);
      this.$slidesContainer = this.querySelector(`.${this.componentUtils.uniqueClassName("__slides")}:not(s-slider#${this.id} s-slider .${this.componentUtils.uniqueClassName("__slides")})`);
      if (this.props.behavior && this.props.behavior !== "scroll" && this.props.behavior !== "transform") {
        if (typeof this.props.behavior === "string") {
          let behavior;
          for (let [behaviorId, behaviorObj] of Object.entries(this.props.behaviors)) {
            const id2 = (_b2 = (_a3 = behaviorObj.class) === null || _a3 === void 0 ? void 0 : _a3.id) !== null && _b2 !== void 0 ? _b2 : behaviorObj.id;
            if (id2 === this.props.behavior) {
              behavior = behaviorObj;
              break;
            }
          }
          if (!behavior) {
            throw new Error(`The behavior "${this.props.behavior}" is not available`);
          }
          if (!behavior.class) {
            throw new Error(`The behavior "${this.props.behavior}" is not valid. You must provide the "<yellow>class</yellow>" property and an optional "<yellow>settings</yellow>" one...`);
          }
          this.behavior = new behavior.class((_c2 = behavior.settings) !== null && _c2 !== void 0 ? _c2 : {});
        } else if (isClass$1(this.props.behavior)) {
          this.behavior = new this.props.behavior({});
        } else if (this.props.behavior instanceof __SSliderBehavior) {
          this.behavior = this.props.behavior;
        } else {
          throw new Error(`Invalid behavior type, must be a string, an SSliderBehavior extended class or an SSliderBehavior instance`);
        }
        (_e2 = (_d2 = this.behavior).firstUpdated) === null || _e2 === void 0 ? void 0 : _e2.call(_d2);
      }
      yield (_g = (_f2 = this.getBehavior()).setup) === null || _g === void 0 ? void 0 : _g.call(_f2);
      this.applyPad();
      this._preventUserScrollForDefaultBehavior();
      this.props.intersectionClasses && this._handleIntersections();
      this._handleMousewheel();
      this.props.clickOnSlide && this._handleClickOnSlide();
      this.props.swipe && this._handleSwipe();
      this._initAttributesActions();
      this.goTo(this.props.slide, true);
      if (this.props.autoplay && this.props.timer) {
        this.play();
      }
    });
  }
  applyPad() {
    return __awaiter$8(this, void 0, void 0, function* () {
      setTimeout(() => __awaiter$8(this, void 0, void 0, function* () {
        if (this.getBehavior().pad) {
          yield this.getBehavior().pad();
        } else {
          yield this._pad();
        }
      }), 20);
    });
  }
  _pad() {
    const sliderRect = this.getBoundingClientRect(), firstPageRect = this.getFirstPageRect(), lastPageRect = this.getLastPageRect();
    let padStart = 0, padEnd = 0;
    if (this.props.direction === "vertical") {
      padStart = (sliderRect.height - firstPageRect.height) * 0.5;
      padEnd = (sliderRect.height - lastPageRect.height) * 0.5;
    } else {
      padStart = (sliderRect.width - firstPageRect.width) * 0.5;
      padEnd = (sliderRect.width - lastPageRect.width) * 0.5;
    }
    this.style.setProperty("--s-slider-pad-start", `${Math.round(padStart)}px`);
    this.style.setProperty("--s-slider-pad-end", `${Math.round(padEnd)}px`);
  }
  _handleSwipe() {
    __onSwipe(this.$root, (swipe) => {
      if (this.props.direction === "horizontal") {
        if (swipe.left) {
          this.next();
        } else if (swipe.right) {
          this.previous();
        }
      } else if (this.props.direction === "vertical") {
        if (swipe.top) {
          this.next();
        } else if (swipe.down) {
          this.previous();
        }
      }
    });
  }
  _preventUserScrollForDefaultBehavior() {
    return;
  }
  _handleMousewheel() {
    this.$slidesWrapper.addEventListener("wheel", (e) => {
      if (!this.props.mousewheel) {
        if (this.props.direction === "horizontal" && Math.abs(e.deltaX) > 0) {
          e.preventDefault();
        } else if (this.props.direction === "vertical" && Math.abs(e.deltaY) > 0) {
          e.preventDefault();
        }
      }
    });
  }
  _handleClickOnSlide() {
    this.$slidesContainer.addEventListener("pointerup", (e) => {
      for (let [i2, $slide] of this.$slides.entries()) {
        if ($slide.contains(e.target) || $slide === e.target) {
          if (this.currentSlide !== $slide) {
            const slide = this.getSlide($slide);
            this.goTo(slide.idx);
          }
        }
      }
    });
  }
  _handleIntersections() {
    var _a3;
    (_a3 = this.$slides) === null || _a3 === void 0 ? void 0 : _a3.forEach(($slide) => {
      function buildThresholdList() {
        let thresholds = [];
        let numSteps = 10;
        for (let i2 = 1; i2 <= numSteps; i2++) {
          let ratio = i2 / numSteps;
          thresholds.push(ratio);
        }
        thresholds.push(0);
        return thresholds;
      }
      function handleIntersect(entries, observer2) {
        let highestRatio = 0;
        entries.forEach((entry) => {
          if (entry.intersectionRatio > highestRatio) {
            highestRatio = entry.intersectionRatio;
          }
        });
        [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1].forEach((threshold2, idx) => {
          if (highestRatio >= threshold2) {
            $slide.classList.add(`in-${threshold2 * 100}`);
          } else {
            $slide.classList.remove(`in-${threshold2 * 100}`);
          }
        });
      }
      let observer;
      let options = {
        root: this.$root,
        rootMargin: "0px",
        threshold: buildThresholdList()
      };
      observer = new IntersectionObserver(handleIntersect, options);
      observer.observe($slide);
    });
  }
  _initAttributesActions() {
    ["next", "previous"].forEach((action) => {
      __querySelectorLive(`[s-slider-${action}]:not(s-slider#${this.id} s-slider [s-slider-${action}])`, ($elm) => {
        $elm.addEventListener("pointerup", (e) => {
          e.preventDefault();
          this[action](true);
        });
      }, {
        scopes: false,
        rootNode: this
      });
    });
    __querySelectorLive(`[s-slider-goto]:not(s-slider#${this.id} .s-slider [s-slider-goto])`, ($elm) => {
      $elm.addEventListener("pointerup", (e) => {
        var _a3;
        const slideIdx = (_a3 = parseInt($elm.getAttribute("s-slider-goto"))) !== null && _a3 !== void 0 ? _a3 : 0;
        this.goTo(slideIdx, true);
      });
    }, {
      scopes: false,
      rootNode: this
    });
  }
  _dispatch(name2, detail = {}) {
    this.componentUtils.dispatchEvent(name2, {
      detail
    });
  }
  isSlideInPage(slide, page = this.state.currentPage) {
    const slideObj = this.getSlide(slide);
    return slideObj.idx >= page * this.props.slidesByPage && slideObj.idx < (page + 1) * this.props.slidesByPage;
  }
  isLast() {
    return this.state.currentSlideIdx >= this.$slides.length - 1;
  }
  isFirst() {
    return this.state.currentSlideIdx <= 0;
  }
  getCurrentSlideIdx() {
    return this.state.currentSlideIdx;
  }
  setCurrentSlideByIdx(idx) {
    if (idx === this.state.currentSlideIdx) {
      return;
    }
    this.state.previousSlideIdx = this.state.currentSlideIdx;
    this.props.slide = idx;
    this.state.currentSlideIdx = idx;
    this.state.currentPage = Math.ceil(idx / this.props.slidesByPage);
    this.updateSlidesClasses();
  }
  setCurrentSlide(idIdxOrElement) {
    const slide = this.getSlide(idIdxOrElement);
    this.setCurrentSlideByIdx(slide.idx);
    return this;
  }
  get currentSlideIdx() {
    return this.getCurrentSlideIdx();
  }
  getCurrentSlideElement() {
    return this.$slides[this.state.currentSlideIdx];
  }
  get currentSlideElement() {
    return this.getCurrentSlideElement();
  }
  getNextSlideIdx() {
    const nextSlideIdx = this.state.currentSlideIdx + 1;
    if (nextSlideIdx >= this.$slides.length - 1)
      return this.$slides.length - 1;
    return nextSlideIdx;
  }
  get nextSlideIdx() {
    return this.getNextSlideIdx();
  }
  getNextSlideElement() {
    return this.$slides[this.getNextSlideIdx()];
  }
  get nextSlideElement() {
    return this.getNextSlideElement();
  }
  getPreviousSlideIdx() {
    const previousSlideIdx = this.state.currentSlideIdx - 1;
    if (previousSlideIdx <= 0)
      return 0;
    return previousSlideIdx;
  }
  get previousSlideIdx() {
    return this.getPreviousSlideIdx();
  }
  getPreviousSlideElement() {
    return this.$slides[this.getPreviousSlideIdx()];
  }
  get previousSlideItem() {
    return this.$slides[this.getPreviousSlideIdx()];
  }
  getSlideIdxById(id2) {
    for (let i2 = 0; i2 < this.$slides.length; i2++) {
      if (this.$slides[i2].getAttribute("s-slider-slide") === id2)
        return i2;
    }
  }
  getSlideElementByIdx(idx) {
    return this.$slides[idx];
  }
  getCurrentSlide() {
    return this.getSlide(this.state.currentSlideIdx);
  }
  get currentSlide() {
    return this.getCurrentSlide();
  }
  getLastPage() {
    return Math.ceil(this.$slides.length / this.props.slidesByPage) - 1;
  }
  getFirstPageSlides() {
    return this.getPageSlides(0);
  }
  getLastPageSlides() {
    return this.getPageSlides(this.getLastPage());
  }
  getPageRect(pageOrSlideElement = this.state.currentPage) {
    let page = pageOrSlideElement;
    if (pageOrSlideElement instanceof HTMLElement) {
      const slide = this.getSlide(pageOrSlideElement);
      page = slide.page;
    }
    const slides = this.getPageSlides(page);
    const rect = {
      top: -1,
      left: -1,
      right: -1,
      bottom: -1,
      width: -1,
      height: -1,
      x: -1,
      y: -1
    };
    slides.forEach((slide) => {
      const slideRect = slide.$slide.getBoundingClientRect();
      if (rect.top === -1 || slideRect.top < rect.top) {
        rect.top = slideRect.top;
      }
      if (rect.left === -1 || slideRect.left < rect.left) {
        rect.left = slideRect.left;
      }
      if (rect.right === -1 || slideRect.right > rect.right) {
        rect.right = slideRect.right;
      }
      if (rect.bottom === -1 || slideRect.bottom > rect.bottom) {
        rect.bottom = slideRect.bottom;
      }
    });
    rect.width = rect.right - rect.left;
    rect.height = rect.bottom - rect.top;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  getFirstPageRect() {
    return this.getPageRect(0);
  }
  getLastPageRect() {
    return this.getPageRect(this.getLastPage());
  }
  getPageSlides(page) {
    const slides = [];
    for (let i2 = page * this.props.slidesByPage; i2 < (page + 1) * this.props.slidesByPage; i2++) {
      if (i2 < this.$slides.length) {
        slides.push(this.getSlide(i2));
      }
    }
    return slides;
  }
  getSlide(idIdxOrElement) {
    var _a3, _b2;
    let $slide, id2, idx, timer;
    if (idIdxOrElement instanceof HTMLElement) {
      const id3 = idIdxOrElement.getAttribute("s-slider-slide");
      if (id3)
        return this.getSlide(id3);
      return this.getSlide(Array.from(this.$slides).indexOf(idIdxOrElement));
    } else if (typeof idIdxOrElement === "number") {
      idx = idIdxOrElement;
      $slide = this.getSlideElementByIdx(idx);
      id2 = $slide.getAttribute("s-slider-slide");
      timer = $slide._sSliderComponentTimer;
      if (!timer) {
        timer = {
          total: (_a3 = $slide.getAttribute("timer")) !== null && _a3 !== void 0 ? _a3 : this.props.timer,
          current: 0,
          percentage: 0
        };
        $slide._sSliderComponentTimer = timer;
      }
    } else if (typeof idIdxOrElement === "string") {
      idx = this.getSlideIdxById(idIdxOrElement);
      id2 = idIdxOrElement;
      $slide = this.getSlideElementByIdx(idx);
      timer = $slide._sSliderComponentTimer;
      if (!timer) {
        timer = {
          total: (_b2 = $slide.getAttribute("timer")) !== null && _b2 !== void 0 ? _b2 : this.props.timer,
          current: 0,
          percentage: 0
        };
        $slide._sSliderComponentTimer = timer;
      }
    }
    if (!$slide)
      return;
    return {
      id: id2,
      idx,
      page: Math.ceil(idx / this.props.slidesByPage),
      $slide,
      timer
    };
  }
  getFirstSlide() {
    return this.getSlide(0);
  }
  getLastSlide() {
    return this.getSlide(this.$slides.length - 1);
  }
  getBehavior() {
    if (this._bindedBehaviors[this.props.behavior]) {
      return this._bindedBehaviors[this.props.behavior];
    }
    const behavior = Object.assign({}, this.props.behaviors[this.props.behavior]);
    if (!behavior) {
      throw new Error(`[SSliderComponent] The requested "${this.props.behavior}" does not exists. Here's the available ones:
${Object.keys(this.props.behaviors).map((b2) => `
- ${b2}`)}`);
    }
    Object.keys(behavior).forEach((fnName) => {
      if (typeof behavior[fnName] === "function") {
        behavior[fnName] = behavior[fnName].bind(this);
      }
    });
    this._bindedBehaviors[this.props.behavior] = behavior;
    return behavior;
  }
  updateSlidesClasses() {
    const currentSlide = this.getCurrentSlide();
    this.$slides.forEach(($slide, i2) => {
      if (this.props.slidesByPage > 1 && this.isSlideInPage($slide)) {
        $slide.classList.add("active");
      } else if ($slide === currentSlide.$slide) {
        $slide.classList.add("active");
      } else {
        $slide.classList.remove("active");
      }
    });
  }
  goTo(slideIdIdxOrElement, force = false) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const nextSlide = this.getSlide(slideIdIdxOrElement);
      if (!force && (!nextSlide || nextSlide.idx === this.currentSlide.idx)) {
        return;
      }
      const currentSlide = this.getCurrentSlide();
      this.setCurrentSlideByIdx(nextSlide.idx);
      this.props.slide = nextSlide.idx;
      if (currentSlide.idx + 1 === nextSlide.idx) {
        this._dispatch("next", {
          currentSlide,
          nextSlide
        });
      } else if (currentSlide.idx - 1 === nextSlide.idx) {
        this._dispatch("previous", {
          currentSlide,
          nextSlide
        });
      }
      this._dispatch("goto", {
        currentSlide,
        nextSlide
      });
      this.updateSlidesClasses();
      currentSlide.$slide.classList.add("post-active");
      currentSlide.$slide.classList.remove("active");
      nextSlide.$slide.classList.add("pre-active");
      yield this._transitionHandler(currentSlide.$slide, nextSlide.$slide);
      currentSlide.$slide.classList.remove("post-active");
      nextSlide.$slide.classList.remove("pre-active");
      nextSlide.$slide.classList.add("active");
      this._dispatch("goto-end", {
        currentSlide,
        nextSlide
      });
      if (this.isPlaying()) {
        this._playSlide(this.state.currentSlideIdx);
      }
      return this;
    });
  }
  next() {
    if (this.props.loop && this.isLast()) {
      return this.goTo(0);
    }
    return this.goTo(this.nextSlideIdx);
  }
  previous() {
    if (this.props.loop && this.isFirst()) {
      return this.goTo(this.getLastSlide().idx);
    }
    return this.goTo(this.getPreviousSlideIdx());
  }
  getTimer(slideIdIdxOrElement) {
    var _a3;
    if (!slideIdIdxOrElement) {
      let total = 0, current = 0;
      for (let i2 = 0; i2 < this.$slides.length; i2++) {
        const slide2 = this.getSlide(i2);
        if (i2 < this.state.currentSlideIdx) {
          current += slide2.timer.total;
        } else if (i2 === this.state.currentSlideIdx) {
          current += slide2.timer.current;
        }
        total += (_a3 = slide2.timer.total) !== null && _a3 !== void 0 ? _a3 : 0;
      }
      this._timer.total = total;
      this._timer.current = current;
      this._timer.percentage = Math.round(100 / total * current);
      return this._timer;
    }
    const slide = this.getSlide(slideIdIdxOrElement);
    return slide.timer;
  }
  isPlaying() {
    if (!this.state.playing)
      return false;
    return this.props.timer !== void 0;
  }
  play() {
    if (!this.props.timer)
      return;
    this.componentUtils.dispatchEvent("play", {
      detail: this
    });
    this.state.playing = true;
    this._playSlide(this.currentSlide.idx);
    return this;
  }
  stop() {
    this.componentUtils.dispatchEvent("stop", {
      detail: this
    });
    this.state.playing = false;
    return this;
  }
  _playSlide(idIdxOrElement) {
    const slide = this.getSlide(idIdxOrElement);
    if (!slide || !slide.timer)
      return;
    const interval = 100;
    let elapsed = 0;
    const slideInterval = setInterval(() => {
      if (!this.isPlaying())
        return;
      elapsed += interval;
      slide.timer.current = elapsed;
      slide.timer.percentage = 100 / slide.timer.total * elapsed;
      if (elapsed >= slide.timer.total) {
        clearInterval(slideInterval);
        slide.timer.current = 0;
        slide.timer.percentage = 0;
        this.next(false);
      }
    }, interval);
    return this;
  }
  _transitionHandler($from, $to) {
    return new Promise((resolve, reject) => __awaiter$8(this, void 0, void 0, function* () {
      var _a3, _b2, _c2;
      this.style.setProperty("--s-slider-slide-height", `${Math.round(this.getCurrentSlide().$slide.getBoundingClientRect().height)}px`);
      this.style.setProperty("--s-slider-slide-width", `${Math.round(this.getCurrentSlide().$slide.getBoundingClientRect().width)}px`);
      if (this.props.transitionHandler) {
        yield this.props.transitionHandler($from, $to);
        return resolve();
      }
      if ((_a3 = this.props.behavior) === null || _a3 === void 0 ? void 0 : _a3.goTo) {
        yield this.props.behavior.goTo($from, $to);
        return resolve();
      }
      yield (_c2 = (_b2 = this.getBehavior()).transition) === null || _c2 === void 0 ? void 0 : _c2.call(_b2, $from, $to);
      resolve();
    }));
  }
  render() {
    var _a3;
    if (!this.$slides.length)
      return;
    const currentSlide = this.getCurrentSlide();
    let slide = this.getCurrentSlide();
    this.style.setProperty("--s-slider-slide", this.state.currentSlideIdx);
    this.style.setProperty("--s-slider-total-slides", this.$slides.length);
    this.style.setProperty("--s-slider-page", this.state.currentPage);
    this.style.setProperty("--s-slider-total-pages", Math.ceil(this.$slides.length / this.props.slidesByPage));
    this.style.setProperty("--s-slider-slides-by-page", this.props.slidesByPage);
    this.style.setProperty("--s-slider-slide-timer-total", `${(_a3 = slide.timer.total) !== null && _a3 !== void 0 ? _a3 : 0 / 1e3}s`);
    return html`
            <div class="${this.componentUtils.className("__root")}">
                <div
                    class="${this.componentUtils.className("__slides-wrapper")}"
                >
                    <div class="${this.componentUtils.className("__slides")}">
                        <div
                            class="${this.componentUtils.className("__pad __pad-start")}"
                        ></div>
                        ${this.$slides.map(($slide) => {
      return $slide;
    })}
                        <div
                            class="${this.componentUtils.className("__pad __pad-end")}"
                        ></div>
                    </div>
                </div>
                <div
                    class="${this.componentUtils.className("__ui", `${typeof this.props.uiContainer === "string" ? `s-container--${this.props.uiContainer}` : this.props.uiContainer === true ? "s-container" : ""}`)}"
                >
                    ${this.props.progress ? html`
                              <div
                                  class="${this.componentUtils.className("__progress")}"
                              >
                                  <div
                                      class="${this.componentUtils.className("__progress-bar")}"
                                  ></div>
                              </div>
                          ` : ""}
                    <div class="${this.componentUtils.className("__nav")}">
                        ${[
      ...Array(Math.ceil(this.$slides.length / this.props.slidesByPage))
    ].map((i2, idx) => {
      return html`
                                <div
                                    class="${this.componentUtils.className("__nav-item")} ${this.isSlideInPage(currentSlide.idx, idx) ? "active" : ""}"
                                    @pointerup=${() => this.goTo(idx * this.props.slidesByPage)}
                                ></div>
                            `;
    })}
                    </div>
                    ${this.props.controls ? html`
                              <div
                                  class="${this.componentUtils.className("__controls")}"
                              >
                                  <div
                                      class="${this.componentUtils.className("__controls-previous")} ${this.isFirst() && !this.props.loop ? "" : "active"}"
                                      @pointerup=${() => this.previous()}
                                  >
                                      ${this.props.previousIconClass ? html`
                                                <i
                                                    class="${this.props.previousIconClass}"
                                                ></i>
                                            ` : html`<div
                                                class="${this.componentUtils.className("__controls-previous-arrow")}"
                                            ></div>`}
                                  </div>
                                  <div
                                      class="${this.componentUtils.className("__controls-next")} ${this.isLast() && !this.props.loop ? "" : "active"}"
                                      @pointerup=${() => this.next()}
                                  >
                                      ${this.props.nextIconClass ? html`
                                                <i
                                                    class="${this.props.nextIconClass}"
                                                ></i>
                                            ` : html`<div
                                                class="${this.componentUtils.className("__controls-next-arrow")}"
                                            ></div>`}
                                  </div>
                              </div>
                          ` : ""}
                </div>
            </div>
        `;
  }
}
function define$i(props = {}, tagName = "s-slider") {
  SLitComponent.define(tagName, SSliderComponent, props);
}
SLitComponent.properties;
const __css$9 = '.s-slider[behavior="slideable"] {\n\n}';
/*! (C) 2017 Andrea Giammarchi - @WebReflection - ISC License */
document.addEventListener("click", function(t) {
  var e = t.target.shadowRoot ? t.path[0] : t.target, a3 = (e.closest || function(t2) {
    for (; e && e.nodeName !== t2; )
      e = e.parentNode;
    return e;
  }).call(e, "A");
  if (a3 && /^(?:_self)?$/i.test(a3.target) && !a3.hasAttribute("download") && "external" !== a3.getAttribute("rel") && !t.ctrlKey && !t.metaKey && !t.shiftKey && !t.altKey && a3.href) {
    var n = new URL(a3.href), o = location;
    if (n.origin === o.origin) {
      var r = n.pathname + n.search, i2 = n.hash, s2 = true;
      if (t.preventDefault(), r === o.pathname + o.search) {
        if (/^#[a-z][a-z0-9.:_-]+$/i.test(i2)) {
          var e = document.querySelector(i2 + ',[name="' + i2.slice(1) + '"]');
          e && (t.preventDefault = function() {
            s2 = false;
          }, setTimeout(function() {
            s2 && e.scrollIntoView(true);
          }));
        }
        history.replaceState(history.state, document.title, r + i2);
      } else {
        var c = new CustomEvent("pushstate");
        c.state = o.href, setTimeout(function() {
          dispatchEvent(c), window.onpushstate && onpushstate(c);
        }), history.pushState(c.state, document.title, r + i2);
      }
    }
  }
}, true);
var querystringify$1 = {};
var has = Object.prototype.hasOwnProperty, undef;
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, " "));
  } catch (e) {
    return null;
  }
}
function encode(input) {
  try {
    return encodeURIComponent(input);
  } catch (e) {
    return null;
  }
}
function querystring(query2) {
  var parser = /([^=?#&]+)=?([^&]*)/g, result2 = {}, part;
  while (part = parser.exec(query2)) {
    var key = decode(part[1]), value = decode(part[2]);
    if (key === null || value === null || key in result2)
      continue;
    result2[key] = value;
  }
  return result2;
}
function querystringify(obj2, prefix) {
  prefix = prefix || "";
  var pairs = [], value, key;
  if ("string" !== typeof prefix)
    prefix = "?";
  for (key in obj2) {
    if (has.call(obj2, key)) {
      value = obj2[key];
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = "";
      }
      key = encode(key);
      value = encode(value);
      if (key === null || value === null)
        continue;
      pairs.push(key + "=" + value);
    }
  }
  return pairs.length ? prefix + pairs.join("&") : "";
}
querystringify$1.stringify = querystringify;
querystringify$1.parse = querystring;
class SSugarFeatureInterface extends SInterface {
  static get _definition() {
    return {
      pleasantCss: {
        description: 'Specify if you want the "pleasant css" syntax in your pages',
        type: "Boolean",
        default: true
      },
      containerQuery: {
        description: "Specify if you want support for container queries in your css or not",
        type: "Boolean",
        default: true
      },
      scrolled: {
        description: "Specify if you want the `scrolled` class to be applied on the `body` element when the page has been scrolled",
        type: "Boolean",
        default: true
      },
      scrolledDelta: {
        description: "Specify after how many scroll the scrolled class will be applied",
        type: "Number",
        default: 200
      },
      vhvar: {
        description: "Specify if you want the `--vh` css variable to be computed and available",
        type: "Boolean",
        default: true
      },
      inputAdditionalAttributes: {
        description: 'Specify if you want to have the additional attributes on inputs like "has-value", "empty" and "dirty" or not',
        type: "Boolean",
        default: true
      },
      resizeTransmations: {
        description: "Specify if you want all the transitions and animations cleared during window resize",
        type: "Boolean",
        default: true
      },
      linksStateAttributes: {
        description: 'Specify if you want to have the state attributes on links like "actual" and "actual-child" or not',
        type: "Boolean",
        default: true
      },
      preventScrollRestoration: {
        description: "Specify if you want to prevent the scroll restoration behavior on chrome that can usually be anoying",
        type: "Boolean",
        default: true
      },
      env: {
        description: "Specify if you want to display the current environment at start",
        type: "Boolean",
        default: true
      }
    };
  }
}
function define$h(props = {}, name2 = "s-sugar") {
  SSugarFeature.define(name2, SSugarFeature, Object.assign({ mountWhen: "direct" }, props));
}
var __awaiter$7 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SSugarFeature extends SFeature {
  constructor(name2, node, settings) {
    super(name2, node, __deepMerge({
      name: "s-sugar",
      interface: SSugarFeatureInterface
    }, settings !== null && settings !== void 0 ? settings : {}));
    this._isResizing = false;
  }
  mount() {
    return __awaiter$7(this, void 0, void 0, function* () {
      return;
    });
  }
  _clearTransmationsOnResize() {
    let resetFn;
    window.addEventListener("resize", () => {
      if (!this._isResizing) {
        resetFn = __clearTransmations();
      }
      this._isResizing = true;
      clearTimeout(this._clearTransmationsOnResizeTimeout);
      this._clearTransmationsOnResizeTimeout = setTimeout(() => {
        this._isResizing = false;
        resetFn === null || resetFn === void 0 ? void 0 : resetFn();
      }, 100);
    });
  }
  _pleasantCss() {
    __expandPleasantCssClassnamesLive({
      afterFirst() {
        setTimeout(() => {
          document.body.classList.remove("initial-loading");
          document.body.classList.remove("loading");
        }, 500);
      }
    });
  }
  _scrolled() {
    document.addEventListener("scroll", (e) => {
      if (window.scrollY >= this.props.scrolledDelta) {
        if (!document.body.classList.contains("scrolled")) {
          document.body.classList.add("scrolled");
        }
      } else {
        if (document.body.classList.contains("scrolled")) {
          document.body.classList.remove("scrolled");
        }
      }
    });
  }
  _vhvar() {
    let vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty("--vh", `${vh}px`);
    window.addEventListener("resize", () => {
      vh = window.innerHeight * 0.01;
      document.documentElement.style.setProperty("--vh", `${vh}px`);
    });
  }
}
function SPackEssentials() {
  define$q();
  define$m();
  define$l();
  define$j();
  define$i();
  define$h();
  define$s();
  define$r();
  define$p();
  define$o();
  define$n();
  define$k();
}
var deepFreezeEs6 = { exports: {} };
function deepFreeze(obj2) {
  if (obj2 instanceof Map) {
    obj2.clear = obj2.delete = obj2.set = function() {
      throw new Error("map is read-only");
    };
  } else if (obj2 instanceof Set) {
    obj2.add = obj2.clear = obj2.delete = function() {
      throw new Error("set is read-only");
    };
  }
  Object.freeze(obj2);
  Object.getOwnPropertyNames(obj2).forEach(function(name2) {
    var prop = obj2[name2];
    if (typeof prop == "object" && !Object.isFrozen(prop)) {
      deepFreeze(prop);
    }
  });
  return obj2;
}
deepFreezeEs6.exports = deepFreeze;
deepFreezeEs6.exports.default = deepFreeze;
class Response {
  constructor(mode) {
    if (mode.data === void 0)
      mode.data = {};
    this.data = mode.data;
    this.isMatchIgnored = false;
  }
  ignoreMatch() {
    this.isMatchIgnored = true;
  }
}
function escapeHTML(value) {
  return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function inherit$1(original, ...objects) {
  const result2 = /* @__PURE__ */ Object.create(null);
  for (const key in original) {
    result2[key] = original[key];
  }
  objects.forEach(function(obj2) {
    for (const key in obj2) {
      result2[key] = obj2[key];
    }
  });
  return result2;
}
const SPAN_CLOSE = "</span>";
const emitsWrappingTags = (node) => {
  return !!node.scope || node.sublanguage && node.language;
};
const scopeToCSSClass = (name2, { prefix }) => {
  if (name2.includes(".")) {
    const pieces = name2.split(".");
    return [
      `${prefix}${pieces.shift()}`,
      ...pieces.map((x2, i2) => `${x2}${"_".repeat(i2 + 1)}`)
    ].join(" ");
  }
  return `${prefix}${name2}`;
};
class HTMLRenderer {
  constructor(parseTree, options) {
    this.buffer = "";
    this.classPrefix = options.classPrefix;
    parseTree.walk(this);
  }
  addText(text) {
    this.buffer += escapeHTML(text);
  }
  openNode(node) {
    if (!emitsWrappingTags(node))
      return;
    let className = "";
    if (node.sublanguage) {
      className = `language-${node.language}`;
    } else {
      className = scopeToCSSClass(node.scope, { prefix: this.classPrefix });
    }
    this.span(className);
  }
  closeNode(node) {
    if (!emitsWrappingTags(node))
      return;
    this.buffer += SPAN_CLOSE;
  }
  value() {
    return this.buffer;
  }
  span(className) {
    this.buffer += `<span class="${className}">`;
  }
}
const newNode = (opts = {}) => {
  const result2 = { children: [] };
  Object.assign(result2, opts);
  return result2;
};
class TokenTree {
  constructor() {
    this.rootNode = newNode();
    this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  add(node) {
    this.top.children.push(node);
  }
  openNode(scope) {
    const node = newNode({ scope });
    this.add(node);
    this.stack.push(node);
  }
  closeNode() {
    if (this.stack.length > 1) {
      return this.stack.pop();
    }
    return void 0;
  }
  closeAllNodes() {
    while (this.closeNode())
      ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  walk(builder) {
    return this.constructor._walk(builder, this.rootNode);
  }
  static _walk(builder, node) {
    if (typeof node === "string") {
      builder.addText(node);
    } else if (node.children) {
      builder.openNode(node);
      node.children.forEach((child) => this._walk(builder, child));
      builder.closeNode(node);
    }
    return builder;
  }
  static _collapse(node) {
    if (typeof node === "string")
      return;
    if (!node.children)
      return;
    if (node.children.every((el2) => typeof el2 === "string")) {
      node.children = [node.children.join("")];
    } else {
      node.children.forEach((child) => {
        TokenTree._collapse(child);
      });
    }
  }
}
class TokenTreeEmitter extends TokenTree {
  constructor(options) {
    super();
    this.options = options;
  }
  addKeyword(text, scope) {
    if (text === "") {
      return;
    }
    this.openNode(scope);
    this.addText(text);
    this.closeNode();
  }
  addText(text) {
    if (text === "") {
      return;
    }
    this.add(text);
  }
  addSublanguage(emitter, name2) {
    const node = emitter.root;
    node.sublanguage = true;
    node.language = name2;
    this.add(node);
  }
  toHTML() {
    const renderer = new HTMLRenderer(this, this.options);
    return renderer.value();
  }
  finalize() {
    return true;
  }
}
function source(re2) {
  if (!re2)
    return null;
  if (typeof re2 === "string")
    return re2;
  return re2.source;
}
function lookahead(re2) {
  return concat("(?=", re2, ")");
}
function anyNumberOfTimes(re2) {
  return concat("(?:", re2, ")*");
}
function optional(re2) {
  return concat("(?:", re2, ")?");
}
function concat(...args) {
  const joined = args.map((x2) => source(x2)).join("");
  return joined;
}
function stripOptionsFromArgs(args) {
  const opts = args[args.length - 1];
  if (typeof opts === "object" && opts.constructor === Object) {
    args.splice(args.length - 1, 1);
    return opts;
  } else {
    return {};
  }
}
function either(...args) {
  const opts = stripOptionsFromArgs(args);
  const joined = "(" + (opts.capture ? "" : "?:") + args.map((x2) => source(x2)).join("|") + ")";
  return joined;
}
function countMatchGroups(re2) {
  return new RegExp(re2.toString() + "|").exec("").length - 1;
}
function startsWith(re2, lexeme) {
  const match5 = re2 && re2.exec(lexeme);
  return match5 && match5.index === 0;
}
const BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function _rewriteBackreferences(regexps, { joinWith }) {
  let numCaptures = 0;
  return regexps.map((regex2) => {
    numCaptures += 1;
    const offset2 = numCaptures;
    let re2 = source(regex2);
    let out = "";
    while (re2.length > 0) {
      const match5 = BACKREF_RE.exec(re2);
      if (!match5) {
        out += re2;
        break;
      }
      out += re2.substring(0, match5.index);
      re2 = re2.substring(match5.index + match5[0].length);
      if (match5[0][0] === "\\" && match5[1]) {
        out += "\\" + String(Number(match5[1]) + offset2);
      } else {
        out += match5[0];
        if (match5[0] === "(") {
          numCaptures++;
        }
      }
    }
    return out;
  }).map((re2) => `(${re2})`).join(joinWith);
}
const MATCH_NOTHING_RE = /\b\B/;
const IDENT_RE$1 = "[a-zA-Z]\\w*";
const UNDERSCORE_IDENT_RE = "[a-zA-Z_]\\w*";
const NUMBER_RE = "\\b\\d+(\\.\\d+)?";
const C_NUMBER_RE = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
const BINARY_NUMBER_RE = "\\b(0b[01]+)";
const RE_STARTERS_RE = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
const SHEBANG = (opts = {}) => {
  const beginShebang = /^#![ ]*\//;
  if (opts.binary) {
    opts.begin = concat(
      beginShebang,
      /.*\b/,
      opts.binary,
      /\b.*/
    );
  }
  return inherit$1({
    scope: "meta",
    begin: beginShebang,
    end: /$/,
    relevance: 0,
    "on:begin": (m2, resp) => {
      if (m2.index !== 0)
        resp.ignoreMatch();
    }
  }, opts);
};
const BACKSLASH_ESCAPE = {
  begin: "\\\\[\\s\\S]",
  relevance: 0
};
const APOS_STRING_MODE = {
  scope: "string",
  begin: "'",
  end: "'",
  illegal: "\\n",
  contains: [BACKSLASH_ESCAPE]
};
const QUOTE_STRING_MODE = {
  scope: "string",
  begin: '"',
  end: '"',
  illegal: "\\n",
  contains: [BACKSLASH_ESCAPE]
};
const PHRASAL_WORDS_MODE = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
};
const COMMENT = function(begin, end, modeOptions = {}) {
  const mode = inherit$1(
    {
      scope: "comment",
      begin,
      end,
      contains: []
    },
    modeOptions
  );
  mode.contains.push({
    scope: "doctag",
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: true,
    relevance: 0
  });
  const ENGLISH_WORD = either(
    "I",
    "a",
    "is",
    "so",
    "us",
    "to",
    "at",
    "if",
    "in",
    "it",
    "on",
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
    /[A-Za-z]+[-][a-z]+/,
    /[A-Za-z][a-z]{2,}/
  );
  mode.contains.push(
    {
      begin: concat(
        /[ ]+/,
        "(",
        ENGLISH_WORD,
        /[.]?[:]?([.][ ]|[ ])/,
        "){3}"
      )
    }
  );
  return mode;
};
const C_LINE_COMMENT_MODE = COMMENT("//", "$");
const C_BLOCK_COMMENT_MODE = COMMENT("/\\*", "\\*/");
const HASH_COMMENT_MODE = COMMENT("#", "$");
const NUMBER_MODE = {
  scope: "number",
  begin: NUMBER_RE,
  relevance: 0
};
const C_NUMBER_MODE = {
  scope: "number",
  begin: C_NUMBER_RE,
  relevance: 0
};
const BINARY_NUMBER_MODE = {
  scope: "number",
  begin: BINARY_NUMBER_RE,
  relevance: 0
};
const REGEXP_MODE = {
  begin: /(?=\/[^/\n]*\/)/,
  contains: [{
    scope: "regexp",
    begin: /\//,
    end: /\/[gimuy]*/,
    illegal: /\n/,
    contains: [
      BACKSLASH_ESCAPE,
      {
        begin: /\[/,
        end: /\]/,
        relevance: 0,
        contains: [BACKSLASH_ESCAPE]
      }
    ]
  }]
};
const TITLE_MODE = {
  scope: "title",
  begin: IDENT_RE$1,
  relevance: 0
};
const UNDERSCORE_TITLE_MODE = {
  scope: "title",
  begin: UNDERSCORE_IDENT_RE,
  relevance: 0
};
const METHOD_GUARD = {
  begin: "\\.\\s*" + UNDERSCORE_IDENT_RE,
  relevance: 0
};
const END_SAME_AS_BEGIN = function(mode) {
  return Object.assign(
    mode,
    {
      "on:begin": (m2, resp) => {
        resp.data._beginMatch = m2[1];
      },
      "on:end": (m2, resp) => {
        if (resp.data._beginMatch !== m2[1])
          resp.ignoreMatch();
      }
    }
  );
};
var MODES$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MATCH_NOTHING_RE,
  IDENT_RE: IDENT_RE$1,
  UNDERSCORE_IDENT_RE,
  NUMBER_RE,
  C_NUMBER_RE,
  BINARY_NUMBER_RE,
  RE_STARTERS_RE,
  SHEBANG,
  BACKSLASH_ESCAPE,
  APOS_STRING_MODE,
  QUOTE_STRING_MODE,
  PHRASAL_WORDS_MODE,
  COMMENT,
  C_LINE_COMMENT_MODE,
  C_BLOCK_COMMENT_MODE,
  HASH_COMMENT_MODE,
  NUMBER_MODE,
  C_NUMBER_MODE,
  BINARY_NUMBER_MODE,
  REGEXP_MODE,
  TITLE_MODE,
  UNDERSCORE_TITLE_MODE,
  METHOD_GUARD,
  END_SAME_AS_BEGIN
});
function skipIfHasPrecedingDot(match5, response) {
  const before = match5.input[match5.index - 1];
  if (before === ".") {
    response.ignoreMatch();
  }
}
function scopeClassName(mode, _parent) {
  if (mode.className !== void 0) {
    mode.scope = mode.className;
    delete mode.className;
  }
}
function beginKeywords(mode, parent) {
  if (!parent)
    return;
  if (!mode.beginKeywords)
    return;
  mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)";
  mode.__beforeBegin = skipIfHasPrecedingDot;
  mode.keywords = mode.keywords || mode.beginKeywords;
  delete mode.beginKeywords;
  if (mode.relevance === void 0)
    mode.relevance = 0;
}
function compileIllegal(mode, _parent) {
  if (!Array.isArray(mode.illegal))
    return;
  mode.illegal = either(...mode.illegal);
}
function compileMatch(mode, _parent) {
  if (!mode.match)
    return;
  if (mode.begin || mode.end)
    throw new Error("begin & end are not supported with match");
  mode.begin = mode.match;
  delete mode.match;
}
function compileRelevance(mode, _parent) {
  if (mode.relevance === void 0)
    mode.relevance = 1;
}
const beforeMatchExt = (mode, parent) => {
  if (!mode.beforeMatch)
    return;
  if (mode.starts)
    throw new Error("beforeMatch cannot be used with starts");
  const originalMode = Object.assign({}, mode);
  Object.keys(mode).forEach((key) => {
    delete mode[key];
  });
  mode.keywords = originalMode.keywords;
  mode.begin = concat(originalMode.beforeMatch, lookahead(originalMode.begin));
  mode.starts = {
    relevance: 0,
    contains: [
      Object.assign(originalMode, { endsParent: true })
    ]
  };
  mode.relevance = 0;
  delete originalMode.beforeMatch;
};
const COMMON_KEYWORDS = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  "list",
  "value"
];
const DEFAULT_KEYWORD_SCOPE = "keyword";
function compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {
  const compiledKeywords = /* @__PURE__ */ Object.create(null);
  if (typeof rawKeywords === "string") {
    compileList(scopeName, rawKeywords.split(" "));
  } else if (Array.isArray(rawKeywords)) {
    compileList(scopeName, rawKeywords);
  } else {
    Object.keys(rawKeywords).forEach(function(scopeName2) {
      Object.assign(
        compiledKeywords,
        compileKeywords(rawKeywords[scopeName2], caseInsensitive, scopeName2)
      );
    });
  }
  return compiledKeywords;
  function compileList(scopeName2, keywordList) {
    if (caseInsensitive) {
      keywordList = keywordList.map((x2) => x2.toLowerCase());
    }
    keywordList.forEach(function(keyword) {
      const pair = keyword.split("|");
      compiledKeywords[pair[0]] = [scopeName2, scoreForKeyword(pair[0], pair[1])];
    });
  }
}
function scoreForKeyword(keyword, providedScore) {
  if (providedScore) {
    return Number(providedScore);
  }
  return commonKeyword(keyword) ? 0 : 1;
}
function commonKeyword(keyword) {
  return COMMON_KEYWORDS.includes(keyword.toLowerCase());
}
const seenDeprecations = {};
const error = (message) => {
  console.error(message);
};
const warn = (message, ...args) => {
  console.log(`WARN: ${message}`, ...args);
};
const deprecated = (version2, message) => {
  if (seenDeprecations[`${version2}/${message}`])
    return;
  console.log(`Deprecated as of ${version2}. ${message}`);
  seenDeprecations[`${version2}/${message}`] = true;
};
const MultiClassError = new Error();
function remapScopeNames(mode, regexes, { key }) {
  let offset2 = 0;
  const scopeNames = mode[key];
  const emit = {};
  const positions2 = {};
  for (let i2 = 1; i2 <= regexes.length; i2++) {
    positions2[i2 + offset2] = scopeNames[i2];
    emit[i2 + offset2] = true;
    offset2 += countMatchGroups(regexes[i2 - 1]);
  }
  mode[key] = positions2;
  mode[key]._emit = emit;
  mode[key]._multi = true;
}
function beginMultiClass(mode) {
  if (!Array.isArray(mode.begin))
    return;
  if (mode.skip || mode.excludeBegin || mode.returnBegin) {
    error("skip, excludeBegin, returnBegin not compatible with beginScope: {}");
    throw MultiClassError;
  }
  if (typeof mode.beginScope !== "object" || mode.beginScope === null) {
    error("beginScope must be object");
    throw MultiClassError;
  }
  remapScopeNames(mode, mode.begin, { key: "beginScope" });
  mode.begin = _rewriteBackreferences(mode.begin, { joinWith: "" });
}
function endMultiClass(mode) {
  if (!Array.isArray(mode.end))
    return;
  if (mode.skip || mode.excludeEnd || mode.returnEnd) {
    error("skip, excludeEnd, returnEnd not compatible with endScope: {}");
    throw MultiClassError;
  }
  if (typeof mode.endScope !== "object" || mode.endScope === null) {
    error("endScope must be object");
    throw MultiClassError;
  }
  remapScopeNames(mode, mode.end, { key: "endScope" });
  mode.end = _rewriteBackreferences(mode.end, { joinWith: "" });
}
function scopeSugar(mode) {
  if (mode.scope && typeof mode.scope === "object" && mode.scope !== null) {
    mode.beginScope = mode.scope;
    delete mode.scope;
  }
}
function MultiClass(mode) {
  scopeSugar(mode);
  if (typeof mode.beginScope === "string") {
    mode.beginScope = { _wrap: mode.beginScope };
  }
  if (typeof mode.endScope === "string") {
    mode.endScope = { _wrap: mode.endScope };
  }
  beginMultiClass(mode);
  endMultiClass(mode);
}
function compileLanguage(language) {
  function langRe(value, global2) {
    return new RegExp(
      source(value),
      "m" + (language.case_insensitive ? "i" : "") + (language.unicodeRegex ? "u" : "") + (global2 ? "g" : "")
    );
  }
  class MultiRegex {
    constructor() {
      this.matchIndexes = {};
      this.regexes = [];
      this.matchAt = 1;
      this.position = 0;
    }
    addRule(re2, opts) {
      opts.position = this.position++;
      this.matchIndexes[this.matchAt] = opts;
      this.regexes.push([opts, re2]);
      this.matchAt += countMatchGroups(re2) + 1;
    }
    compile() {
      if (this.regexes.length === 0) {
        this.exec = () => null;
      }
      const terminators = this.regexes.map((el2) => el2[1]);
      this.matcherRe = langRe(_rewriteBackreferences(terminators, { joinWith: "|" }), true);
      this.lastIndex = 0;
    }
    exec(s2) {
      this.matcherRe.lastIndex = this.lastIndex;
      const match5 = this.matcherRe.exec(s2);
      if (!match5) {
        return null;
      }
      const i2 = match5.findIndex((el2, i3) => i3 > 0 && el2 !== void 0);
      const matchData = this.matchIndexes[i2];
      match5.splice(0, i2);
      return Object.assign(match5, matchData);
    }
  }
  class ResumableMultiRegex {
    constructor() {
      this.rules = [];
      this.multiRegexes = [];
      this.count = 0;
      this.lastIndex = 0;
      this.regexIndex = 0;
    }
    getMatcher(index) {
      if (this.multiRegexes[index])
        return this.multiRegexes[index];
      const matcher = new MultiRegex();
      this.rules.slice(index).forEach(([re2, opts]) => matcher.addRule(re2, opts));
      matcher.compile();
      this.multiRegexes[index] = matcher;
      return matcher;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    addRule(re2, opts) {
      this.rules.push([re2, opts]);
      if (opts.type === "begin")
        this.count++;
    }
    exec(s2) {
      const m2 = this.getMatcher(this.regexIndex);
      m2.lastIndex = this.lastIndex;
      let result2 = m2.exec(s2);
      if (this.resumingScanAtSamePosition()) {
        if (result2 && result2.index === this.lastIndex)
          ;
        else {
          const m22 = this.getMatcher(0);
          m22.lastIndex = this.lastIndex + 1;
          result2 = m22.exec(s2);
        }
      }
      if (result2) {
        this.regexIndex += result2.position + 1;
        if (this.regexIndex === this.count) {
          this.considerAll();
        }
      }
      return result2;
    }
  }
  function buildModeRegex(mode) {
    const mm3 = new ResumableMultiRegex();
    mode.contains.forEach((term) => mm3.addRule(term.begin, { rule: term, type: "begin" }));
    if (mode.terminatorEnd) {
      mm3.addRule(mode.terminatorEnd, { type: "end" });
    }
    if (mode.illegal) {
      mm3.addRule(mode.illegal, { type: "illegal" });
    }
    return mm3;
  }
  function compileMode(mode, parent) {
    const cmode = mode;
    if (mode.isCompiled)
      return cmode;
    [
      scopeClassName,
      compileMatch,
      MultiClass,
      beforeMatchExt
    ].forEach((ext2) => ext2(mode, parent));
    language.compilerExtensions.forEach((ext2) => ext2(mode, parent));
    mode.__beforeBegin = null;
    [
      beginKeywords,
      compileIllegal,
      compileRelevance
    ].forEach((ext2) => ext2(mode, parent));
    mode.isCompiled = true;
    let keywordPattern = null;
    if (typeof mode.keywords === "object" && mode.keywords.$pattern) {
      mode.keywords = Object.assign({}, mode.keywords);
      keywordPattern = mode.keywords.$pattern;
      delete mode.keywords.$pattern;
    }
    keywordPattern = keywordPattern || /\w+/;
    if (mode.keywords) {
      mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
    }
    cmode.keywordPatternRe = langRe(keywordPattern, true);
    if (parent) {
      if (!mode.begin)
        mode.begin = /\B|\b/;
      cmode.beginRe = langRe(cmode.begin);
      if (!mode.end && !mode.endsWithParent)
        mode.end = /\B|\b/;
      if (mode.end)
        cmode.endRe = langRe(cmode.end);
      cmode.terminatorEnd = source(cmode.end) || "";
      if (mode.endsWithParent && parent.terminatorEnd) {
        cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd;
      }
    }
    if (mode.illegal)
      cmode.illegalRe = langRe(mode.illegal);
    if (!mode.contains)
      mode.contains = [];
    mode.contains = [].concat(...mode.contains.map(function(c) {
      return expandOrCloneMode(c === "self" ? mode : c);
    }));
    mode.contains.forEach(function(c) {
      compileMode(c, cmode);
    });
    if (mode.starts) {
      compileMode(mode.starts, parent);
    }
    cmode.matcher = buildModeRegex(cmode);
    return cmode;
  }
  if (!language.compilerExtensions)
    language.compilerExtensions = [];
  if (language.contains && language.contains.includes("self")) {
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  }
  language.classNameAliases = inherit$1(language.classNameAliases || {});
  return compileMode(language);
}
function dependencyOnParent(mode) {
  if (!mode)
    return false;
  return mode.endsWithParent || dependencyOnParent(mode.starts);
}
function expandOrCloneMode(mode) {
  if (mode.variants && !mode.cachedVariants) {
    mode.cachedVariants = mode.variants.map(function(variant) {
      return inherit$1(mode, { variants: null }, variant);
    });
  }
  if (mode.cachedVariants) {
    return mode.cachedVariants;
  }
  if (dependencyOnParent(mode)) {
    return inherit$1(mode, { starts: mode.starts ? inherit$1(mode.starts) : null });
  }
  if (Object.isFrozen(mode)) {
    return inherit$1(mode);
  }
  return mode;
}
var version = "11.6.0";
class HTMLInjectionError extends Error {
  constructor(reason, html2) {
    super(reason);
    this.name = "HTMLInjectionError";
    this.html = html2;
  }
}
const escape$1 = escapeHTML;
const inherit = inherit$1;
const NO_MATCH = Symbol("nomatch");
const MAX_KEYWORD_HITS = 7;
const HLJS = function(hljs) {
  const languages = /* @__PURE__ */ Object.create(null);
  const aliases = /* @__PURE__ */ Object.create(null);
  const plugins = [];
  let SAFE_MODE = true;
  const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
  const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: "Plain text", contains: [] };
  let options = {
    ignoreUnescapedHTML: false,
    throwUnescapedHTML: false,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    __emitter: TokenTreeEmitter
  };
  function shouldNotHighlight(languageName) {
    return options.noHighlightRe.test(languageName);
  }
  function blockLanguage(block) {
    let classes = block.className + " ";
    classes += block.parentNode ? block.parentNode.className : "";
    const match5 = options.languageDetectRe.exec(classes);
    if (match5) {
      const language = getLanguage(match5[1]);
      if (!language) {
        warn(LANGUAGE_NOT_FOUND.replace("{}", match5[1]));
        warn("Falling back to no-highlight mode for this block.", block);
      }
      return language ? match5[1] : "no-highlight";
    }
    return classes.split(/\s+/).find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
  }
  function highlight2(codeOrLanguageName, optionsOrCode, ignoreIllegals) {
    let code3 = "";
    let languageName = "";
    if (typeof optionsOrCode === "object") {
      code3 = codeOrLanguageName;
      ignoreIllegals = optionsOrCode.ignoreIllegals;
      languageName = optionsOrCode.language;
    } else {
      deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
      deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
      languageName = codeOrLanguageName;
      code3 = optionsOrCode;
    }
    if (ignoreIllegals === void 0) {
      ignoreIllegals = true;
    }
    const context = {
      code: code3,
      language: languageName
    };
    fire("before:highlight", context);
    const result2 = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals);
    result2.code = context.code;
    fire("after:highlight", result2);
    return result2;
  }
  function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
    const keywordHits = /* @__PURE__ */ Object.create(null);
    function keywordData(mode, matchText) {
      return mode.keywords[matchText];
    }
    function processKeywords() {
      if (!top.keywords) {
        emitter.addText(modeBuffer);
        return;
      }
      let lastIndex = 0;
      top.keywordPatternRe.lastIndex = 0;
      let match5 = top.keywordPatternRe.exec(modeBuffer);
      let buf = "";
      while (match5) {
        buf += modeBuffer.substring(lastIndex, match5.index);
        const word = language.case_insensitive ? match5[0].toLowerCase() : match5[0];
        const data2 = keywordData(top, word);
        if (data2) {
          const [kind, keywordRelevance] = data2;
          emitter.addText(buf);
          buf = "";
          keywordHits[word] = (keywordHits[word] || 0) + 1;
          if (keywordHits[word] <= MAX_KEYWORD_HITS)
            relevance += keywordRelevance;
          if (kind.startsWith("_")) {
            buf += match5[0];
          } else {
            const cssClass = language.classNameAliases[kind] || kind;
            emitter.addKeyword(match5[0], cssClass);
          }
        } else {
          buf += match5[0];
        }
        lastIndex = top.keywordPatternRe.lastIndex;
        match5 = top.keywordPatternRe.exec(modeBuffer);
      }
      buf += modeBuffer.substring(lastIndex);
      emitter.addText(buf);
    }
    function processSubLanguage() {
      if (modeBuffer === "")
        return;
      let result3 = null;
      if (typeof top.subLanguage === "string") {
        if (!languages[top.subLanguage]) {
          emitter.addText(modeBuffer);
          return;
        }
        result3 = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
        continuations[top.subLanguage] = result3._top;
      } else {
        result3 = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
      }
      if (top.relevance > 0) {
        relevance += result3.relevance;
      }
      emitter.addSublanguage(result3._emitter, result3.language);
    }
    function processBuffer() {
      if (top.subLanguage != null) {
        processSubLanguage();
      } else {
        processKeywords();
      }
      modeBuffer = "";
    }
    function emitMultiClass(scope, match5) {
      let i2 = 1;
      const max2 = match5.length - 1;
      while (i2 <= max2) {
        if (!scope._emit[i2]) {
          i2++;
          continue;
        }
        const klass = language.classNameAliases[scope[i2]] || scope[i2];
        const text = match5[i2];
        if (klass) {
          emitter.addKeyword(text, klass);
        } else {
          modeBuffer = text;
          processKeywords();
          modeBuffer = "";
        }
        i2++;
      }
    }
    function startNewMode(mode, match5) {
      if (mode.scope && typeof mode.scope === "string") {
        emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);
      }
      if (mode.beginScope) {
        if (mode.beginScope._wrap) {
          emitter.addKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);
          modeBuffer = "";
        } else if (mode.beginScope._multi) {
          emitMultiClass(mode.beginScope, match5);
          modeBuffer = "";
        }
      }
      top = Object.create(mode, { parent: { value: top } });
      return top;
    }
    function endOfMode(mode, match5, matchPlusRemainder) {
      let matched = startsWith(mode.endRe, matchPlusRemainder);
      if (matched) {
        if (mode["on:end"]) {
          const resp = new Response(mode);
          mode["on:end"](match5, resp);
          if (resp.isMatchIgnored)
            matched = false;
        }
        if (matched) {
          while (mode.endsParent && mode.parent) {
            mode = mode.parent;
          }
          return mode;
        }
      }
      if (mode.endsWithParent) {
        return endOfMode(mode.parent, match5, matchPlusRemainder);
      }
    }
    function doIgnore(lexeme) {
      if (top.matcher.regexIndex === 0) {
        modeBuffer += lexeme[0];
        return 1;
      } else {
        resumeScanAtSamePosition = true;
        return 0;
      }
    }
    function doBeginMatch(match5) {
      const lexeme = match5[0];
      const newMode = match5.rule;
      const resp = new Response(newMode);
      const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
      for (const cb of beforeCallbacks) {
        if (!cb)
          continue;
        cb(match5, resp);
        if (resp.isMatchIgnored)
          return doIgnore(lexeme);
      }
      if (newMode.skip) {
        modeBuffer += lexeme;
      } else {
        if (newMode.excludeBegin) {
          modeBuffer += lexeme;
        }
        processBuffer();
        if (!newMode.returnBegin && !newMode.excludeBegin) {
          modeBuffer = lexeme;
        }
      }
      startNewMode(newMode, match5);
      return newMode.returnBegin ? 0 : lexeme.length;
    }
    function doEndMatch(match5) {
      const lexeme = match5[0];
      const matchPlusRemainder = codeToHighlight.substring(match5.index);
      const endMode = endOfMode(top, match5, matchPlusRemainder);
      if (!endMode) {
        return NO_MATCH;
      }
      const origin = top;
      if (top.endScope && top.endScope._wrap) {
        processBuffer();
        emitter.addKeyword(lexeme, top.endScope._wrap);
      } else if (top.endScope && top.endScope._multi) {
        processBuffer();
        emitMultiClass(top.endScope, match5);
      } else if (origin.skip) {
        modeBuffer += lexeme;
      } else {
        if (!(origin.returnEnd || origin.excludeEnd)) {
          modeBuffer += lexeme;
        }
        processBuffer();
        if (origin.excludeEnd) {
          modeBuffer = lexeme;
        }
      }
      do {
        if (top.scope) {
          emitter.closeNode();
        }
        if (!top.skip && !top.subLanguage) {
          relevance += top.relevance;
        }
        top = top.parent;
      } while (top !== endMode.parent);
      if (endMode.starts) {
        startNewMode(endMode.starts, match5);
      }
      return origin.returnEnd ? 0 : lexeme.length;
    }
    function processContinuations() {
      const list = [];
      for (let current = top; current !== language; current = current.parent) {
        if (current.scope) {
          list.unshift(current.scope);
        }
      }
      list.forEach((item) => emitter.openNode(item));
    }
    let lastMatch = {};
    function processLexeme(textBeforeMatch, match5) {
      const lexeme = match5 && match5[0];
      modeBuffer += textBeforeMatch;
      if (lexeme == null) {
        processBuffer();
        return 0;
      }
      if (lastMatch.type === "begin" && match5.type === "end" && lastMatch.index === match5.index && lexeme === "") {
        modeBuffer += codeToHighlight.slice(match5.index, match5.index + 1);
        if (!SAFE_MODE) {
          const err = new Error(`0 width match regex (${languageName})`);
          err.languageName = languageName;
          err.badRule = lastMatch.rule;
          throw err;
        }
        return 1;
      }
      lastMatch = match5;
      if (match5.type === "begin") {
        return doBeginMatch(match5);
      } else if (match5.type === "illegal" && !ignoreIllegals) {
        const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.scope || "<unnamed>") + '"');
        err.mode = top;
        throw err;
      } else if (match5.type === "end") {
        const processed = doEndMatch(match5);
        if (processed !== NO_MATCH) {
          return processed;
        }
      }
      if (match5.type === "illegal" && lexeme === "") {
        return 1;
      }
      if (iterations > 1e5 && iterations > match5.index * 3) {
        const err = new Error("potential infinite loop, way more iterations than matches");
        throw err;
      }
      modeBuffer += lexeme;
      return lexeme.length;
    }
    const language = getLanguage(languageName);
    if (!language) {
      error(LANGUAGE_NOT_FOUND.replace("{}", languageName));
      throw new Error('Unknown language: "' + languageName + '"');
    }
    const md2 = compileLanguage(language);
    let result2 = "";
    let top = continuation || md2;
    const continuations = {};
    const emitter = new options.__emitter(options);
    processContinuations();
    let modeBuffer = "";
    let relevance = 0;
    let index = 0;
    let iterations = 0;
    let resumeScanAtSamePosition = false;
    try {
      top.matcher.considerAll();
      for (; ; ) {
        iterations++;
        if (resumeScanAtSamePosition) {
          resumeScanAtSamePosition = false;
        } else {
          top.matcher.considerAll();
        }
        top.matcher.lastIndex = index;
        const match5 = top.matcher.exec(codeToHighlight);
        if (!match5)
          break;
        const beforeMatch = codeToHighlight.substring(index, match5.index);
        const processedCount = processLexeme(beforeMatch, match5);
        index = match5.index + processedCount;
      }
      processLexeme(codeToHighlight.substring(index));
      emitter.closeAllNodes();
      emitter.finalize();
      result2 = emitter.toHTML();
      return {
        language: languageName,
        value: result2,
        relevance,
        illegal: false,
        _emitter: emitter,
        _top: top
      };
    } catch (err) {
      if (err.message && err.message.includes("Illegal")) {
        return {
          language: languageName,
          value: escape$1(codeToHighlight),
          illegal: true,
          relevance: 0,
          _illegalBy: {
            message: err.message,
            index,
            context: codeToHighlight.slice(index - 100, index + 100),
            mode: err.mode,
            resultSoFar: result2
          },
          _emitter: emitter
        };
      } else if (SAFE_MODE) {
        return {
          language: languageName,
          value: escape$1(codeToHighlight),
          illegal: false,
          relevance: 0,
          errorRaised: err,
          _emitter: emitter,
          _top: top
        };
      } else {
        throw err;
      }
    }
  }
  function justTextHighlightResult(code3) {
    const result2 = {
      value: escape$1(code3),
      illegal: false,
      relevance: 0,
      _top: PLAINTEXT_LANGUAGE,
      _emitter: new options.__emitter(options)
    };
    result2._emitter.addText(code3);
    return result2;
  }
  function highlightAuto(code3, languageSubset) {
    languageSubset = languageSubset || options.languages || Object.keys(languages);
    const plaintext = justTextHighlightResult(code3);
    const results = languageSubset.filter(getLanguage).filter(autoDetection).map(
      (name2) => _highlight(name2, code3, false)
    );
    results.unshift(plaintext);
    const sorted = results.sort((a3, b2) => {
      if (a3.relevance !== b2.relevance)
        return b2.relevance - a3.relevance;
      if (a3.language && b2.language) {
        if (getLanguage(a3.language).supersetOf === b2.language) {
          return 1;
        } else if (getLanguage(b2.language).supersetOf === a3.language) {
          return -1;
        }
      }
      return 0;
    });
    const [best, secondBest] = sorted;
    const result2 = best;
    result2.secondBest = secondBest;
    return result2;
  }
  function updateClassName(element, currentLang, resultLang) {
    const language = currentLang && aliases[currentLang] || resultLang;
    element.classList.add("hljs");
    element.classList.add(`language-${language}`);
  }
  function highlightElement(element) {
    let node = null;
    const language = blockLanguage(element);
    if (shouldNotHighlight(language))
      return;
    fire(
      "before:highlightElement",
      { el: element, language }
    );
    if (element.children.length > 0) {
      if (!options.ignoreUnescapedHTML) {
        console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk.");
        console.warn("https://github.com/highlightjs/highlight.js/wiki/security");
        console.warn("The element with unescaped HTML:");
        console.warn(element);
      }
      if (options.throwUnescapedHTML) {
        const err = new HTMLInjectionError(
          "One of your code blocks includes unescaped HTML.",
          element.innerHTML
        );
        throw err;
      }
    }
    node = element;
    const text = node.textContent;
    const result2 = language ? highlight2(text, { language, ignoreIllegals: true }) : highlightAuto(text);
    element.innerHTML = result2.value;
    updateClassName(element, language, result2.language);
    element.result = {
      language: result2.language,
      re: result2.relevance,
      relevance: result2.relevance
    };
    if (result2.secondBest) {
      element.secondBest = {
        language: result2.secondBest.language,
        relevance: result2.secondBest.relevance
      };
    }
    fire("after:highlightElement", { el: element, result: result2, text });
  }
  function configure(userOptions) {
    options = inherit(options, userOptions);
  }
  const initHighlighting = () => {
    highlightAll();
    deprecated("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function initHighlightingOnLoad() {
    highlightAll();
    deprecated("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  let wantsHighlight = false;
  function highlightAll() {
    if (document.readyState === "loading") {
      wantsHighlight = true;
      return;
    }
    const blocks = document.querySelectorAll(options.cssSelector);
    blocks.forEach(highlightElement);
  }
  function boot() {
    if (wantsHighlight)
      highlightAll();
  }
  if (typeof window !== "undefined" && window.addEventListener) {
    window.addEventListener("DOMContentLoaded", boot, false);
  }
  function registerLanguage(languageName, languageDefinition) {
    let lang = null;
    try {
      lang = languageDefinition(hljs);
    } catch (error$1) {
      error("Language definition for '{}' could not be registered.".replace("{}", languageName));
      if (!SAFE_MODE) {
        throw error$1;
      } else {
        error(error$1);
      }
      lang = PLAINTEXT_LANGUAGE;
    }
    if (!lang.name)
      lang.name = languageName;
    languages[languageName] = lang;
    lang.rawDefinition = languageDefinition.bind(null, hljs);
    if (lang.aliases) {
      registerAliases(lang.aliases, { languageName });
    }
  }
  function unregisterLanguage(languageName) {
    delete languages[languageName];
    for (const alias of Object.keys(aliases)) {
      if (aliases[alias] === languageName) {
        delete aliases[alias];
      }
    }
  }
  function listLanguages() {
    return Object.keys(languages);
  }
  function getLanguage(name2) {
    name2 = (name2 || "").toLowerCase();
    return languages[name2] || languages[aliases[name2]];
  }
  function registerAliases(aliasList, { languageName }) {
    if (typeof aliasList === "string") {
      aliasList = [aliasList];
    }
    aliasList.forEach((alias) => {
      aliases[alias.toLowerCase()] = languageName;
    });
  }
  function autoDetection(name2) {
    const lang = getLanguage(name2);
    return lang && !lang.disableAutodetect;
  }
  function upgradePluginAPI(plugin) {
    if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
      plugin["before:highlightElement"] = (data2) => {
        plugin["before:highlightBlock"](
          Object.assign({ block: data2.el }, data2)
        );
      };
    }
    if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
      plugin["after:highlightElement"] = (data2) => {
        plugin["after:highlightBlock"](
          Object.assign({ block: data2.el }, data2)
        );
      };
    }
  }
  function addPlugin(plugin) {
    upgradePluginAPI(plugin);
    plugins.push(plugin);
  }
  function fire(event, args) {
    const cb = event;
    plugins.forEach(function(plugin) {
      if (plugin[cb]) {
        plugin[cb](args);
      }
    });
  }
  function deprecateHighlightBlock(el2) {
    deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
    deprecated("10.7.0", "Please use highlightElement now.");
    return highlightElement(el2);
  }
  Object.assign(hljs, {
    highlight: highlight2,
    highlightAuto,
    highlightAll,
    highlightElement,
    highlightBlock: deprecateHighlightBlock,
    configure,
    initHighlighting,
    initHighlightingOnLoad,
    registerLanguage,
    unregisterLanguage,
    listLanguages,
    getLanguage,
    registerAliases,
    autoDetection,
    inherit,
    addPlugin
  });
  hljs.debugMode = function() {
    SAFE_MODE = false;
  };
  hljs.safeMode = function() {
    SAFE_MODE = true;
  };
  hljs.versionString = version;
  hljs.regex = {
    concat,
    lookahead,
    either,
    optional,
    anyNumberOfTimes
  };
  for (const key in MODES$1) {
    if (typeof MODES$1[key] === "object") {
      deepFreezeEs6.exports(MODES$1[key]);
    }
  }
  Object.assign(hljs, MODES$1);
  return hljs;
};
var highlight = HLJS({});
var core = highlight;
highlight.HighlightJS = highlight;
highlight.default = highlight;
const HighlightJS = core;
function bash(hljs) {
  const regex2 = hljs.regex;
  const VAR = {};
  const BRACED_VAR = {
    begin: /\$\{/,
    end: /\}/,
    contains: [
      "self",
      {
        begin: /:-/,
        contains: [VAR]
      }
    ]
  };
  Object.assign(VAR, {
    className: "variable",
    variants: [
      { begin: regex2.concat(
        /\$[\w\d#@][\w\d_]*/,
        `(?![\\w\\d])(?![$])`
      ) },
      BRACED_VAR
    ]
  });
  const SUBST = {
    className: "subst",
    begin: /\$\(/,
    end: /\)/,
    contains: [hljs.BACKSLASH_ESCAPE]
  };
  const HERE_DOC = {
    begin: /<<-?\s*(?=\w+)/,
    starts: { contains: [
      hljs.END_SAME_AS_BEGIN({
        begin: /(\w+)/,
        end: /(\w+)/,
        className: "string"
      })
    ] }
  };
  const QUOTE_STRING = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [
      hljs.BACKSLASH_ESCAPE,
      VAR,
      SUBST
    ]
  };
  SUBST.contains.push(QUOTE_STRING);
  const ESCAPED_QUOTE = {
    className: "",
    begin: /\\"/
  };
  const APOS_STRING = {
    className: "string",
    begin: /'/,
    end: /'/
  };
  const ARITHMETIC = {
    begin: /\$\(\(/,
    end: /\)\)/,
    contains: [
      {
        begin: /\d+#[0-9a-f]+/,
        className: "number"
      },
      hljs.NUMBER_MODE,
      VAR
    ]
  };
  const SH_LIKE_SHELLS = [
    "fish",
    "bash",
    "zsh",
    "sh",
    "csh",
    "ksh",
    "tcsh",
    "dash",
    "scsh"
  ];
  const KNOWN_SHEBANG = hljs.SHEBANG({
    binary: `(${SH_LIKE_SHELLS.join("|")})`,
    relevance: 10
  });
  const FUNCTION = {
    className: "function",
    begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
    returnBegin: true,
    contains: [hljs.inherit(hljs.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
    relevance: 0
  };
  const KEYWORDS2 = [
    "if",
    "then",
    "else",
    "elif",
    "fi",
    "for",
    "while",
    "in",
    "do",
    "done",
    "case",
    "esac",
    "function"
  ];
  const LITERALS2 = [
    "true",
    "false"
  ];
  const PATH_MODE = { match: /(\/[a-z._-]+)+/ };
  const SHELL_BUILT_INS = [
    "break",
    "cd",
    "continue",
    "eval",
    "exec",
    "exit",
    "export",
    "getopts",
    "hash",
    "pwd",
    "readonly",
    "return",
    "shift",
    "test",
    "times",
    "trap",
    "umask",
    "unset"
  ];
  const BASH_BUILT_INS = [
    "alias",
    "bind",
    "builtin",
    "caller",
    "command",
    "declare",
    "echo",
    "enable",
    "help",
    "let",
    "local",
    "logout",
    "mapfile",
    "printf",
    "read",
    "readarray",
    "source",
    "type",
    "typeset",
    "ulimit",
    "unalias"
  ];
  const ZSH_BUILT_INS = [
    "autoload",
    "bg",
    "bindkey",
    "bye",
    "cap",
    "chdir",
    "clone",
    "comparguments",
    "compcall",
    "compctl",
    "compdescribe",
    "compfiles",
    "compgroups",
    "compquote",
    "comptags",
    "comptry",
    "compvalues",
    "dirs",
    "disable",
    "disown",
    "echotc",
    "echoti",
    "emulate",
    "fc",
    "fg",
    "float",
    "functions",
    "getcap",
    "getln",
    "history",
    "integer",
    "jobs",
    "kill",
    "limit",
    "log",
    "noglob",
    "popd",
    "print",
    "pushd",
    "pushln",
    "rehash",
    "sched",
    "setcap",
    "setopt",
    "stat",
    "suspend",
    "ttyctl",
    "unfunction",
    "unhash",
    "unlimit",
    "unsetopt",
    "vared",
    "wait",
    "whence",
    "where",
    "which",
    "zcompile",
    "zformat",
    "zftp",
    "zle",
    "zmodload",
    "zparseopts",
    "zprof",
    "zpty",
    "zregexparse",
    "zsocket",
    "zstyle",
    "ztcp"
  ];
  const GNU_CORE_UTILS = [
    "chcon",
    "chgrp",
    "chown",
    "chmod",
    "cp",
    "dd",
    "df",
    "dir",
    "dircolors",
    "ln",
    "ls",
    "mkdir",
    "mkfifo",
    "mknod",
    "mktemp",
    "mv",
    "realpath",
    "rm",
    "rmdir",
    "shred",
    "sync",
    "touch",
    "truncate",
    "vdir",
    "b2sum",
    "base32",
    "base64",
    "cat",
    "cksum",
    "comm",
    "csplit",
    "cut",
    "expand",
    "fmt",
    "fold",
    "head",
    "join",
    "md5sum",
    "nl",
    "numfmt",
    "od",
    "paste",
    "ptx",
    "pr",
    "sha1sum",
    "sha224sum",
    "sha256sum",
    "sha384sum",
    "sha512sum",
    "shuf",
    "sort",
    "split",
    "sum",
    "tac",
    "tail",
    "tr",
    "tsort",
    "unexpand",
    "uniq",
    "wc",
    "arch",
    "basename",
    "chroot",
    "date",
    "dirname",
    "du",
    "echo",
    "env",
    "expr",
    "factor",
    "groups",
    "hostid",
    "id",
    "link",
    "logname",
    "nice",
    "nohup",
    "nproc",
    "pathchk",
    "pinky",
    "printenv",
    "printf",
    "pwd",
    "readlink",
    "runcon",
    "seq",
    "sleep",
    "stat",
    "stdbuf",
    "stty",
    "tee",
    "test",
    "timeout",
    "tty",
    "uname",
    "unlink",
    "uptime",
    "users",
    "who",
    "whoami",
    "yes"
  ];
  return {
    name: "Bash",
    aliases: ["sh"],
    keywords: {
      $pattern: /\b[a-z][a-z0-9._-]+\b/,
      keyword: KEYWORDS2,
      literal: LITERALS2,
      built_in: [
        ...SHELL_BUILT_INS,
        ...BASH_BUILT_INS,
        "set",
        "shopt",
        ...ZSH_BUILT_INS,
        ...GNU_CORE_UTILS
      ]
    },
    contains: [
      KNOWN_SHEBANG,
      hljs.SHEBANG(),
      FUNCTION,
      ARITHMETIC,
      hljs.HASH_COMMENT_MODE,
      HERE_DOC,
      PATH_MODE,
      QUOTE_STRING,
      ESCAPED_QUOTE,
      APOS_STRING,
      VAR
    ]
  };
}
function twig(hljs) {
  const regex2 = hljs.regex;
  const FUNCTION_NAMES = [
    "absolute_url",
    "asset|0",
    "asset_version",
    "attribute",
    "block",
    "constant",
    "controller|0",
    "country_timezones",
    "csrf_token",
    "cycle",
    "date",
    "dump",
    "expression",
    "form|0",
    "form_end",
    "form_errors",
    "form_help",
    "form_label",
    "form_rest",
    "form_row",
    "form_start",
    "form_widget",
    "html_classes",
    "include",
    "is_granted",
    "logout_path",
    "logout_url",
    "max",
    "min",
    "parent",
    "path|0",
    "random",
    "range",
    "relative_path",
    "render",
    "render_esi",
    "source",
    "template_from_string",
    "url|0"
  ];
  const FILTERS = [
    "abs",
    "abbr_class",
    "abbr_method",
    "batch",
    "capitalize",
    "column",
    "convert_encoding",
    "country_name",
    "currency_name",
    "currency_symbol",
    "data_uri",
    "date",
    "date_modify",
    "default",
    "escape",
    "file_excerpt",
    "file_link",
    "file_relative",
    "filter",
    "first",
    "format",
    "format_args",
    "format_args_as_text",
    "format_currency",
    "format_date",
    "format_datetime",
    "format_file",
    "format_file_from_text",
    "format_number",
    "format_time",
    "html_to_markdown",
    "humanize",
    "inky_to_html",
    "inline_css",
    "join",
    "json_encode",
    "keys",
    "language_name",
    "last",
    "length",
    "locale_name",
    "lower",
    "map",
    "markdown",
    "markdown_to_html",
    "merge",
    "nl2br",
    "number_format",
    "raw",
    "reduce",
    "replace",
    "reverse",
    "round",
    "slice",
    "slug",
    "sort",
    "spaceless",
    "split",
    "striptags",
    "timezone_name",
    "title",
    "trans",
    "transchoice",
    "trim",
    "u|0",
    "upper",
    "url_encode",
    "yaml_dump",
    "yaml_encode"
  ];
  let TAG_NAMES = [
    "apply",
    "autoescape",
    "block",
    "cache",
    "deprecated",
    "do",
    "embed",
    "extends",
    "filter",
    "flush",
    "for",
    "form_theme",
    "from",
    "if",
    "import",
    "include",
    "macro",
    "sandbox",
    "set",
    "stopwatch",
    "trans",
    "trans_default_domain",
    "transchoice",
    "use",
    "verbatim",
    "with"
  ];
  TAG_NAMES = TAG_NAMES.concat(TAG_NAMES.map((t) => `end${t}`));
  const STRING = {
    scope: "string",
    variants: [
      {
        begin: /'/,
        end: /'/
      },
      {
        begin: /"/,
        end: /"/
      }
    ]
  };
  const NUMBER = {
    scope: "number",
    match: /\d+/
  };
  const PARAMS = {
    begin: /\(/,
    end: /\)/,
    excludeBegin: true,
    excludeEnd: true,
    contains: [
      STRING,
      NUMBER
    ]
  };
  const FUNCTIONS = {
    beginKeywords: FUNCTION_NAMES.join(" "),
    keywords: { name: FUNCTION_NAMES },
    relevance: 0,
    contains: [PARAMS]
  };
  const FILTER = {
    match: /\|(?=[A-Za-z_]+:?)/,
    beginScope: "punctuation",
    relevance: 0,
    contains: [
      {
        match: /[A-Za-z_]+:?/,
        keywords: FILTERS
      }
    ]
  };
  const tagNamed = (tagnames, { relevance }) => {
    return {
      beginScope: {
        1: "template-tag",
        3: "name"
      },
      relevance: relevance || 2,
      endScope: "template-tag",
      begin: [
        /\{%/,
        /\s*/,
        regex2.either(...tagnames)
      ],
      end: /%\}/,
      keywords: "in",
      contains: [
        FILTER,
        FUNCTIONS,
        STRING,
        NUMBER
      ]
    };
  };
  const CUSTOM_TAG_RE = /[a-z_]+/;
  const TAG = tagNamed(TAG_NAMES, { relevance: 2 });
  const CUSTOM_TAG = tagNamed([CUSTOM_TAG_RE], { relevance: 1 });
  return {
    name: "Twig",
    aliases: ["craftcms"],
    case_insensitive: true,
    subLanguage: "xml",
    contains: [
      hljs.COMMENT(/\{#/, /#\}/),
      TAG,
      CUSTOM_TAG,
      {
        className: "template-variable",
        begin: /\{\{/,
        end: /\}\}/,
        contains: [
          "self",
          FILTER,
          FUNCTIONS,
          STRING,
          NUMBER
        ]
      }
    ]
  };
}
var htmlTags = { exports: {} };
const require$$0$1 = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "math",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rb",
  "rp",
  "rt",
  "rtc",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "slot",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "svg",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr"
];
(function(module) {
  module.exports = require$$0$1;
})(htmlTags);
const __htmlTags = /* @__PURE__ */ getDefaultExportFromCjs(htmlTags.exports);
var _void = { exports: {} };
const require$$0 = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "link",
  "menuitem",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
(function(module) {
  module.exports = require$$0;
})(_void);
const __selfClosingHtmlTags = /* @__PURE__ */ getDefaultExportFromCjs(_void.exports);
const MODES = (hljs) => {
  return {
    IMPORTANT: {
      className: "meta",
      begin: "!important"
    },
    HEXCOLOR: {
      className: "number",
      begin: "#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})"
    },
    ATTRIBUTE_SELECTOR_MODE: {
      className: "selector-attr",
      begin: /\[/,
      end: /\]/,
      illegal: "$",
      contains: [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE]
    }
  };
};
const TAGS = [...__htmlTags, ...__selfClosingHtmlTags];
const MEDIA_FEATURES = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  "min-width",
  "max-width",
  "min-height",
  "max-height"
];
const PSEUDO_CLASSES = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  "host",
  "host-context",
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  "nth-child",
  "nth-col",
  "nth-last-child",
  "nth-last-col",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
];
const PSEUDO_ELEMENTS = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
];
const ATTRIBUTES = knownCssProperties.all.reverse();
function css(hljs) {
  const modes = MODES(hljs);
  const PSEUDO_ELEMENTS$1 = PSEUDO_ELEMENTS;
  const PSEUDO_CLASSES$1 = PSEUDO_CLASSES;
  const AT_IDENTIFIER = "@[a-z-.]+";
  const AT_MODIFIERS = "and or not only";
  const IDENT_RE2 = "[a-zA-Z-.][a-zA-Z0-9_.-]*";
  const VARIABLE = {
    className: "variable",
    begin: "(\\$" + IDENT_RE2 + ")\\b"
  };
  const ret = {
    name: "CSS",
    case_insensitive: true,
    illegal: "[=/|']",
    contains: [
      {
        className: "sugar-function",
        begin: "sugar\\.[a-zA-Z0-9-_\\.]+",
        contains: [hljs.QUOTE_STRING_MODE, hljs.APOS_STRING_MODE]
      },
      {
        className: "sugar-mixin",
        begin: "@sugar\\.[a-zA-Z0-9-_\\.]+",
        contains: [hljs.QUOTE_STRING_MODE, hljs.APOS_STRING_MODE]
      },
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      {
        className: "selector-id",
        begin: "#[A-Za-z0-9_-]+",
        relevance: 0
      },
      {
        className: "selector-class",
        begin: "\\.[A-Za-z0-9_-]+",
        relevance: 0
      },
      modes.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-tag",
        begin: "\\b(" + TAGS.join("|") + ")\\b",
        relevance: 0
      },
      {
        className: "selector-pseudo",
        begin: ":(" + PSEUDO_CLASSES$1.join("|") + ")"
      },
      {
        className: "selector-pseudo",
        begin: "::(" + PSEUDO_ELEMENTS$1.join("|") + ")"
      },
      VARIABLE,
      {
        begin: /\(/,
        end: /\)/,
        contains: [hljs.NUMBER_MODE]
      },
      {
        className: "attribute",
        begin: "\\b(" + ATTRIBUTES.join("|") + ")\\b"
      },
      {
        begin: "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b"
      },
      {
        begin: "@(page|font-face)",
        lexemes: AT_IDENTIFIER,
        keywords: "@page @font-face"
      },
      {
        begin: "@",
        end: "[{;]",
        returnBegin: true,
        keywords: {
          $pattern: /[a-zA-Z-\.]+/,
          keyword: AT_MODIFIERS,
          attribute: MEDIA_FEATURES.join(" ")
        },
        contains: [
          {
            begin: AT_IDENTIFIER,
            className: "keyword"
          },
          {
            begin: /[a-zA-Z\.-]+(?=:)/,
            className: "attribute"
          },
          VARIABLE,
          hljs.QUOTE_STRING_MODE,
          hljs.APOS_STRING_MODE,
          modes.HEXCOLOR,
          hljs.NUMBER_MODE
        ]
      }
    ]
  };
  return ret;
}
const IDENT_RE = "[A-Za-z$_][0-9A-Za-z$_]*";
const KEYWORDS = [
  "as",
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
];
const LITERALS = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
];
const TYPES = [
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  "Math",
  "Date",
  "Number",
  "BigInt",
  "String",
  "RegExp",
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  "Reflect",
  "Proxy",
  "Intl",
  "WebAssembly"
];
const ERROR_TYPES = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
];
const BUILT_IN_GLOBALS = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
];
const BUILT_IN_VARIABLES = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "module",
  "global"
];
const BUILT_INS = [].concat(
  BUILT_IN_GLOBALS,
  TYPES,
  ERROR_TYPES
);
function javascript(hljs) {
  const regex2 = hljs.regex;
  const hasClosingTag = (match5, { after }) => {
    const tag2 = "</" + match5[0].slice(1);
    const pos = match5.input.indexOf(tag2, after);
    return pos !== -1;
  };
  const IDENT_RE$12 = IDENT_RE;
  const FRAGMENT = {
    begin: "<>",
    end: "</>"
  };
  const XML_SELF_CLOSING = /<[A-Za-z0-9\\._:-]+\s*\/>/;
  const XML_TAG = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    isTrulyOpeningTag: (match5, response) => {
      const afterMatchIndex = match5[0].length + match5.index;
      const nextChar = match5.input[afterMatchIndex];
      if (nextChar === "<" || nextChar === ",") {
        response.ignoreMatch();
        return;
      }
      if (nextChar === ">") {
        if (!hasClosingTag(match5, { after: afterMatchIndex })) {
          response.ignoreMatch();
        }
      }
      let m2;
      const afterMatch = match5.input.substring(afterMatchIndex);
      if (m2 = afterMatch.match(/^\s+extends\s+/)) {
        if (m2.index === 0) {
          response.ignoreMatch();
          return;
        }
      }
    }
  };
  const KEYWORDS$1 = {
    $pattern: IDENT_RE,
    keyword: KEYWORDS,
    literal: LITERALS,
    built_in: BUILT_INS,
    "variable.language": BUILT_IN_VARIABLES
  };
  const decimalDigits = "[0-9](_?[0-9])*";
  const frac = `\\.(${decimalDigits})`;
  const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
  const NUMBER = {
    className: "number",
    variants: [
      { begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})\\b` },
      { begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b` },
      { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  };
  const SUBST = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: KEYWORDS$1,
    contains: []
  };
  const HTML_TEMPLATE = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: "xml"
    }
  };
  const CSS_TEMPLATE = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: "css"
    }
  };
  const TEMPLATE_STRING = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      hljs.BACKSLASH_ESCAPE,
      SUBST
    ]
  };
  const JSDOC_COMMENT = hljs.COMMENT(
    /\/\*\*(?!\/)/,
    "\\*/",
    {
      relevance: 0,
      contains: [
        {
          begin: "(?=@[A-Za-z]+)",
          relevance: 0,
          contains: [
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            },
            {
              className: "type",
              begin: "\\{",
              end: "\\}",
              excludeEnd: true,
              excludeBegin: true,
              relevance: 0
            },
            {
              className: "variable",
              begin: IDENT_RE$12 + "(?=\\s*(-)|$)",
              endsParent: true,
              relevance: 0
            },
            {
              begin: /(?=[^\n])\s/,
              relevance: 0
            }
          ]
        }
      ]
    }
  );
  const COMMENT2 = {
    className: "comment",
    variants: [
      JSDOC_COMMENT,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.C_LINE_COMMENT_MODE
    ]
  };
  const SUBST_INTERNALS = [
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE,
    HTML_TEMPLATE,
    CSS_TEMPLATE,
    TEMPLATE_STRING,
    NUMBER
  ];
  SUBST.contains = SUBST_INTERNALS.concat({
    begin: /\{/,
    end: /\}/,
    keywords: KEYWORDS$1,
    contains: [
      "self"
    ].concat(SUBST_INTERNALS)
  });
  const SUBST_AND_COMMENTS = [].concat(COMMENT2, SUBST.contains);
  const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
    {
      begin: /\(/,
      end: /\)/,
      keywords: KEYWORDS$1,
      contains: ["self"].concat(SUBST_AND_COMMENTS)
    }
  ]);
  const PARAMS = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: true,
    excludeEnd: true,
    keywords: KEYWORDS$1,
    contains: PARAMS_CONTAINS
  };
  const CLASS_OR_EXTENDS = {
    variants: [
      {
        match: [
          /class/,
          /\s+/,
          IDENT_RE$12,
          /\s+/,
          /extends/,
          /\s+/,
          regex2.concat(IDENT_RE$12, "(", regex2.concat(/\./, IDENT_RE$12), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      {
        match: [
          /class/,
          /\s+/,
          IDENT_RE$12
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  };
  const CLASS_REFERENCE = {
    relevance: 0,
    match: regex2.either(
      /\bJSON/,
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
    ),
    className: "title.class",
    keywords: {
      _: [
        ...TYPES,
        ...ERROR_TYPES
      ]
    }
  };
  const USE_STRICT = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  };
  const FUNCTION_DEFINITION = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          IDENT_RE$12,
          /(?=\s*\()/
        ]
      },
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [PARAMS],
    illegal: /%/
  };
  const UPPER_CASE_CONSTANT = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function noneOf(list) {
    return regex2.concat("(?!", list.join("|"), ")");
  }
  const FUNCTION_CALL = {
    match: regex2.concat(
      /\b/,
      noneOf([
        ...BUILT_IN_GLOBALS,
        "super"
      ]),
      IDENT_RE$12,
      regex2.lookahead(/\(/)
    ),
    className: "title.function",
    relevance: 0
  };
  const PROPERTY_ACCESS = {
    begin: regex2.concat(/\./, regex2.lookahead(
      regex2.concat(IDENT_RE$12, /(?![0-9A-Za-z$_(])/)
    )),
    end: IDENT_RE$12,
    excludeBegin: true,
    keywords: "prototype",
    className: "property",
    relevance: 0
  };
  const GETTER_OR_SETTER = {
    match: [
      /get|set/,
      /\s+/,
      IDENT_RE$12,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        begin: /\(\)/
      },
      PARAMS
    ]
  };
  const FUNC_LEAD_IN_RE = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + hljs.UNDERSCORE_IDENT_RE + ")\\s*=>";
  const FUNCTION_VARIABLE = {
    match: [
      /const|var|let/,
      /\s+/,
      IDENT_RE$12,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      regex2.lookahead(FUNC_LEAD_IN_RE)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      PARAMS
    ]
  };
  return {
    name: "Javascript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: KEYWORDS$1,
    exports: { PARAMS_CONTAINS, CLASS_REFERENCE },
    illegal: /#(?![$_A-z])/,
    contains: [
      hljs.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      USE_STRICT,
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      HTML_TEMPLATE,
      CSS_TEMPLATE,
      TEMPLATE_STRING,
      COMMENT2,
      NUMBER,
      CLASS_REFERENCE,
      {
        className: "attr",
        begin: IDENT_RE$12 + regex2.lookahead(":"),
        relevance: 0
      },
      FUNCTION_VARIABLE,
      {
        begin: "(" + hljs.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          COMMENT2,
          hljs.REGEXP_MODE,
          {
            className: "function",
            begin: FUNC_LEAD_IN_RE,
            returnBegin: true,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: hljs.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: true
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: true,
                    excludeEnd: true,
                    keywords: KEYWORDS$1,
                    contains: PARAMS_CONTAINS
                  }
                ]
              }
            ]
          },
          {
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            variants: [
              { begin: FRAGMENT.begin, end: FRAGMENT.end },
              { match: XML_SELF_CLOSING },
              {
                begin: XML_TAG.begin,
                "on:begin": XML_TAG.isTrulyOpeningTag,
                end: XML_TAG.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: XML_TAG.begin,
                end: XML_TAG.end,
                skip: true,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      FUNCTION_DEFINITION,
      {
        beginKeywords: "while if switch catch for"
      },
      {
        begin: "\\b(?!function)" + hljs.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        returnBegin: true,
        label: "func.def",
        contains: [
          PARAMS,
          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$12, className: "title.function" })
        ]
      },
      {
        match: /\.\.\./,
        relevance: 0
      },
      PROPERTY_ACCESS,
      {
        match: "\\$" + IDENT_RE$12,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [PARAMS]
      },
      FUNCTION_CALL,
      UPPER_CASE_CONSTANT,
      CLASS_OR_EXTENDS,
      GETTER_OR_SETTER,
      {
        match: /\$[(.]/
      }
    ]
  };
}
function php(hljs) {
  const regex2 = hljs.regex;
  const NOT_PERL_ETC = /(?![A-Za-z0-9])(?![$])/;
  const IDENT_RE2 = regex2.concat(
    /[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/,
    NOT_PERL_ETC
  );
  const PASCAL_CASE_CLASS_NAME_RE = regex2.concat(
    /(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/,
    NOT_PERL_ETC
  );
  const VARIABLE = {
    scope: "variable",
    match: "\\$+" + IDENT_RE2
  };
  const PREPROCESSOR = {
    scope: "meta",
    variants: [
      { begin: /<\?php/, relevance: 10 },
      { begin: /<\?=/ },
      { begin: /<\?/, relevance: 0.1 },
      { begin: /\?>/ }
    ]
  };
  const SUBST = {
    scope: "subst",
    variants: [
      { begin: /\$\w+/ },
      {
        begin: /\{\$/,
        end: /\}/
      }
    ]
  };
  const SINGLE_QUOTED = hljs.inherit(hljs.APOS_STRING_MODE, { illegal: null });
  const DOUBLE_QUOTED = hljs.inherit(hljs.QUOTE_STRING_MODE, {
    illegal: null,
    contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST)
  });
  const HEREDOC = hljs.END_SAME_AS_BEGIN({
    begin: /<<<[ \t]*(\w+)\n/,
    end: /[ \t]*(\w+)\b/,
    contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST)
  });
  const WHITESPACE2 = "[ 	\n]";
  const STRING = {
    scope: "string",
    variants: [
      DOUBLE_QUOTED,
      SINGLE_QUOTED,
      HEREDOC
    ]
  };
  const NUMBER = {
    scope: "number",
    variants: [
      { begin: `\\b0[bB][01]+(?:_[01]+)*\\b` },
      { begin: `\\b0[oO][0-7]+(?:_[0-7]+)*\\b` },
      { begin: `\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b` },
      { begin: `(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?` }
    ],
    relevance: 0
  };
  const LITERALS2 = [
    "false",
    "null",
    "true"
  ];
  const KWS = [
    "__CLASS__",
    "__DIR__",
    "__FILE__",
    "__FUNCTION__",
    "__COMPILER_HALT_OFFSET__",
    "__LINE__",
    "__METHOD__",
    "__NAMESPACE__",
    "__TRAIT__",
    "die",
    "echo",
    "exit",
    "include",
    "include_once",
    "print",
    "require",
    "require_once",
    "array",
    "abstract",
    "and",
    "as",
    "binary",
    "bool",
    "boolean",
    "break",
    "callable",
    "case",
    "catch",
    "class",
    "clone",
    "const",
    "continue",
    "declare",
    "default",
    "do",
    "double",
    "else",
    "elseif",
    "empty",
    "enddeclare",
    "endfor",
    "endforeach",
    "endif",
    "endswitch",
    "endwhile",
    "enum",
    "eval",
    "extends",
    "final",
    "finally",
    "float",
    "for",
    "foreach",
    "from",
    "global",
    "goto",
    "if",
    "implements",
    "instanceof",
    "insteadof",
    "int",
    "integer",
    "interface",
    "isset",
    "iterable",
    "list",
    "match|0",
    "mixed",
    "new",
    "never",
    "object",
    "or",
    "private",
    "protected",
    "public",
    "readonly",
    "real",
    "return",
    "string",
    "switch",
    "throw",
    "trait",
    "try",
    "unset",
    "use",
    "var",
    "void",
    "while",
    "xor",
    "yield"
  ];
  const BUILT_INS2 = [
    "Error|0",
    "AppendIterator",
    "ArgumentCountError",
    "ArithmeticError",
    "ArrayIterator",
    "ArrayObject",
    "AssertionError",
    "BadFunctionCallException",
    "BadMethodCallException",
    "CachingIterator",
    "CallbackFilterIterator",
    "CompileError",
    "Countable",
    "DirectoryIterator",
    "DivisionByZeroError",
    "DomainException",
    "EmptyIterator",
    "ErrorException",
    "Exception",
    "FilesystemIterator",
    "FilterIterator",
    "GlobIterator",
    "InfiniteIterator",
    "InvalidArgumentException",
    "IteratorIterator",
    "LengthException",
    "LimitIterator",
    "LogicException",
    "MultipleIterator",
    "NoRewindIterator",
    "OutOfBoundsException",
    "OutOfRangeException",
    "OuterIterator",
    "OverflowException",
    "ParentIterator",
    "ParseError",
    "RangeException",
    "RecursiveArrayIterator",
    "RecursiveCachingIterator",
    "RecursiveCallbackFilterIterator",
    "RecursiveDirectoryIterator",
    "RecursiveFilterIterator",
    "RecursiveIterator",
    "RecursiveIteratorIterator",
    "RecursiveRegexIterator",
    "RecursiveTreeIterator",
    "RegexIterator",
    "RuntimeException",
    "SeekableIterator",
    "SplDoublyLinkedList",
    "SplFileInfo",
    "SplFileObject",
    "SplFixedArray",
    "SplHeap",
    "SplMaxHeap",
    "SplMinHeap",
    "SplObjectStorage",
    "SplObserver",
    "SplPriorityQueue",
    "SplQueue",
    "SplStack",
    "SplSubject",
    "SplTempFileObject",
    "TypeError",
    "UnderflowException",
    "UnexpectedValueException",
    "UnhandledMatchError",
    "ArrayAccess",
    "BackedEnum",
    "Closure",
    "Fiber",
    "Generator",
    "Iterator",
    "IteratorAggregate",
    "Serializable",
    "Stringable",
    "Throwable",
    "Traversable",
    "UnitEnum",
    "WeakReference",
    "WeakMap",
    "Directory",
    "__PHP_Incomplete_Class",
    "parent",
    "php_user_filter",
    "self",
    "static",
    "stdClass"
  ];
  const dualCase = (items) => {
    const result2 = [];
    items.forEach((item) => {
      result2.push(item);
      if (item.toLowerCase() === item) {
        result2.push(item.toUpperCase());
      } else {
        result2.push(item.toLowerCase());
      }
    });
    return result2;
  };
  const KEYWORDS2 = {
    keyword: KWS,
    literal: dualCase(LITERALS2),
    built_in: BUILT_INS2
  };
  const normalizeKeywords = (items) => {
    return items.map((item) => {
      return item.replace(/\|\d+$/, "");
    });
  };
  const CONSTRUCTOR_CALL = { variants: [
    {
      match: [
        /new/,
        regex2.concat(WHITESPACE2, "+"),
        regex2.concat("(?!", normalizeKeywords(BUILT_INS2).join("\\b|"), "\\b)"),
        PASCAL_CASE_CLASS_NAME_RE
      ],
      scope: {
        1: "keyword",
        4: "title.class"
      }
    }
  ] };
  const CONSTANT_REFERENCE = regex2.concat(IDENT_RE2, "\\b(?!\\()");
  const LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON = { variants: [
    {
      match: [
        regex2.concat(
          /::/,
          regex2.lookahead(/(?!class\b)/)
        ),
        CONSTANT_REFERENCE
      ],
      scope: { 2: "variable.constant" }
    },
    {
      match: [
        /::/,
        /class/
      ],
      scope: { 2: "variable.language" }
    },
    {
      match: [
        PASCAL_CASE_CLASS_NAME_RE,
        regex2.concat(
          /::/,
          regex2.lookahead(/(?!class\b)/)
        ),
        CONSTANT_REFERENCE
      ],
      scope: {
        1: "title.class",
        3: "variable.constant"
      }
    },
    {
      match: [
        PASCAL_CASE_CLASS_NAME_RE,
        regex2.concat(
          "::",
          regex2.lookahead(/(?!class\b)/)
        )
      ],
      scope: { 1: "title.class" }
    },
    {
      match: [
        PASCAL_CASE_CLASS_NAME_RE,
        /::/,
        /class/
      ],
      scope: {
        1: "title.class",
        3: "variable.language"
      }
    }
  ] };
  const NAMED_ARGUMENT = {
    scope: "attr",
    match: regex2.concat(IDENT_RE2, regex2.lookahead(":"), regex2.lookahead(/(?!::)/))
  };
  const PARAMS_MODE = {
    relevance: 0,
    begin: /\(/,
    end: /\)/,
    keywords: KEYWORDS2,
    contains: [
      NAMED_ARGUMENT,
      VARIABLE,
      LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
      hljs.C_BLOCK_COMMENT_MODE,
      STRING,
      NUMBER,
      CONSTRUCTOR_CALL
    ]
  };
  const FUNCTION_INVOKE = {
    relevance: 0,
    match: [
      /\b/,
      regex2.concat("(?!fn\\b|function\\b|", normalizeKeywords(KWS).join("\\b|"), "|", normalizeKeywords(BUILT_INS2).join("\\b|"), "\\b)"),
      IDENT_RE2,
      regex2.concat(WHITESPACE2, "*"),
      regex2.lookahead(/(?=\()/)
    ],
    scope: { 3: "title.function.invoke" },
    contains: [PARAMS_MODE]
  };
  PARAMS_MODE.contains.push(FUNCTION_INVOKE);
  const ATTRIBUTE_CONTAINS = [
    NAMED_ARGUMENT,
    LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
    hljs.C_BLOCK_COMMENT_MODE,
    STRING,
    NUMBER,
    CONSTRUCTOR_CALL
  ];
  const ATTRIBUTES2 = {
    begin: regex2.concat(/#\[\s*/, PASCAL_CASE_CLASS_NAME_RE),
    beginScope: "meta",
    end: /]/,
    endScope: "meta",
    keywords: {
      literal: LITERALS2,
      keyword: [
        "new",
        "array"
      ]
    },
    contains: [
      {
        begin: /\[/,
        end: /]/,
        keywords: {
          literal: LITERALS2,
          keyword: [
            "new",
            "array"
          ]
        },
        contains: [
          "self",
          ...ATTRIBUTE_CONTAINS
        ]
      },
      ...ATTRIBUTE_CONTAINS,
      {
        scope: "meta",
        match: PASCAL_CASE_CLASS_NAME_RE
      }
    ]
  };
  return {
    case_insensitive: false,
    keywords: KEYWORDS2,
    contains: [
      ATTRIBUTES2,
      hljs.HASH_COMMENT_MODE,
      hljs.COMMENT("//", "$"),
      hljs.COMMENT(
        "/\\*",
        "\\*/",
        { contains: [
          {
            scope: "doctag",
            match: "@[A-Za-z]+"
          }
        ] }
      ),
      {
        match: /__halt_compiler\(\);/,
        keywords: "__halt_compiler",
        starts: {
          scope: "comment",
          end: hljs.MATCH_NOTHING_RE,
          contains: [
            {
              match: /\?>/,
              scope: "meta",
              endsParent: true
            }
          ]
        }
      },
      PREPROCESSOR,
      {
        scope: "variable.language",
        match: /\$this\b/
      },
      VARIABLE,
      FUNCTION_INVOKE,
      LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
      {
        match: [
          /const/,
          /\s/,
          IDENT_RE2
        ],
        scope: {
          1: "keyword",
          3: "variable.constant"
        }
      },
      CONSTRUCTOR_CALL,
      {
        scope: "function",
        relevance: 0,
        beginKeywords: "fn function",
        end: /[;{]/,
        excludeEnd: true,
        illegal: "[$%\\[]",
        contains: [
          { beginKeywords: "use" },
          hljs.UNDERSCORE_TITLE_MODE,
          {
            begin: "=>",
            endsParent: true
          },
          {
            scope: "params",
            begin: "\\(",
            end: "\\)",
            excludeBegin: true,
            excludeEnd: true,
            keywords: KEYWORDS2,
            contains: [
              "self",
              VARIABLE,
              LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
              hljs.C_BLOCK_COMMENT_MODE,
              STRING,
              NUMBER
            ]
          }
        ]
      },
      {
        scope: "class",
        variants: [
          {
            beginKeywords: "enum",
            illegal: /[($"]/
          },
          {
            beginKeywords: "class interface trait",
            illegal: /[:($"]/
          }
        ],
        relevance: 0,
        end: /\{/,
        excludeEnd: true,
        contains: [
          { beginKeywords: "extends implements" },
          hljs.UNDERSCORE_TITLE_MODE
        ]
      },
      {
        beginKeywords: "namespace",
        relevance: 0,
        end: ";",
        illegal: /[.']/,
        contains: [hljs.inherit(hljs.UNDERSCORE_TITLE_MODE, { scope: "title.class" })]
      },
      {
        beginKeywords: "use",
        relevance: 0,
        end: ";",
        contains: [
          {
            match: /\b(as|const|function)\b/,
            scope: "keyword"
          },
          hljs.UNDERSCORE_TITLE_MODE
        ]
      },
      STRING,
      NUMBER
    ]
  };
}
function xml(hljs) {
  const regex2 = hljs.regex;
  const TAG_NAME_RE = regex2.concat(/[\p{L}_]/u, regex2.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u);
  const XML_IDENT_RE = /[\p{L}0-9._:-]+/u;
  const XML_ENTITIES = {
    className: "symbol",
    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
  };
  const XML_META_KEYWORDS = {
    begin: /\s/,
    contains: [
      {
        className: "keyword",
        begin: /#?[a-z_][a-z1-9_-]+/,
        illegal: /\n/
      }
    ]
  };
  const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {
    begin: /\(/,
    end: /\)/
  });
  const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, { className: "string" });
  const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, { className: "string" });
  const TAG_INTERNALS = {
    endsWithParent: true,
    illegal: /</,
    relevance: 0,
    contains: [
      {
        className: "attr",
        begin: XML_IDENT_RE,
        relevance: 0
      },
      {
        begin: /=\s*/,
        relevance: 0,
        contains: [
          {
            className: "string",
            endsParent: true,
            variants: [
              {
                begin: /"/,
                end: /"/,
                contains: [XML_ENTITIES]
              },
              {
                begin: /'/,
                end: /'/,
                contains: [XML_ENTITIES]
              },
              { begin: /[^\s"'=<>`]+/ }
            ]
          }
        ]
      }
    ]
  };
  return {
    name: "HTML, XML",
    aliases: [
      "html",
      "xhtml",
      "rss",
      "atom",
      "xjb",
      "xsd",
      "xsl",
      "plist",
      "wsf",
      "svg"
    ],
    case_insensitive: true,
    unicodeRegex: true,
    contains: [
      {
        className: "meta",
        begin: /<![a-z]/,
        end: />/,
        relevance: 10,
        contains: [
          XML_META_KEYWORDS,
          QUOTE_META_STRING_MODE,
          APOS_META_STRING_MODE,
          XML_META_PAR_KEYWORDS,
          {
            begin: /\[/,
            end: /\]/,
            contains: [
              {
                className: "meta",
                begin: /<![a-z]/,
                end: />/,
                contains: [
                  XML_META_KEYWORDS,
                  XML_META_PAR_KEYWORDS,
                  QUOTE_META_STRING_MODE,
                  APOS_META_STRING_MODE
                ]
              }
            ]
          }
        ]
      },
      hljs.COMMENT(
        /<!--/,
        /-->/,
        { relevance: 10 }
      ),
      {
        begin: /<!\[CDATA\[/,
        end: /\]\]>/,
        relevance: 10
      },
      XML_ENTITIES,
      {
        className: "meta",
        end: /\?>/,
        variants: [
          {
            begin: /<\?xml/,
            relevance: 10,
            contains: [
              QUOTE_META_STRING_MODE
            ]
          },
          {
            begin: /<\?[a-z][a-z0-9]+/
          }
        ]
      },
      {
        className: "tag",
        begin: /<style(?=\s|>)/,
        end: />/,
        keywords: { name: "style" },
        contains: [TAG_INTERNALS],
        starts: {
          end: /<\/style>/,
          returnEnd: true,
          subLanguage: [
            "css",
            "xml"
          ]
        }
      },
      {
        className: "tag",
        begin: /<script(?=\s|>)/,
        end: />/,
        keywords: { name: "script" },
        contains: [TAG_INTERNALS],
        starts: {
          end: /<\/script>/,
          returnEnd: true,
          subLanguage: [
            "javascript",
            "handlebars",
            "xml"
          ]
        }
      },
      {
        className: "tag",
        begin: /<>|<\/>/
      },
      {
        className: "tag",
        begin: regex2.concat(
          /</,
          regex2.lookahead(regex2.concat(
            TAG_NAME_RE,
            regex2.either(/\/>/, />/, /\s/)
          ))
        ),
        end: /\/?>/,
        contains: [
          {
            className: "name",
            begin: TAG_NAME_RE,
            relevance: 0,
            starts: TAG_INTERNALS
          }
        ]
      },
      {
        className: "tag",
        begin: regex2.concat(
          /<\//,
          regex2.lookahead(regex2.concat(
            TAG_NAME_RE,
            />/
          ))
        ),
        contains: [
          {
            className: "name",
            begin: TAG_NAME_RE,
            relevance: 0
          },
          {
            begin: />/,
            relevance: 0,
            endsParent: true
          }
        ]
      }
    ]
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const decorateProperty = ({ finisher, descriptor: descriptor2 }) => (protoOrDescriptor, name2) => {
  var _a3;
  if (name2 !== void 0) {
    const ctor = protoOrDescriptor.constructor;
    if (descriptor2 !== void 0) {
      Object.defineProperty(protoOrDescriptor, name2, descriptor2(name2));
    }
    finisher === null || finisher === void 0 ? void 0 : finisher(ctor, name2);
  } else {
    const key = (_a3 = protoOrDescriptor.originalKey) !== null && _a3 !== void 0 ? _a3 : protoOrDescriptor.key;
    const info = descriptor2 != void 0 ? {
      kind: "method",
      placement: "prototype",
      key,
      descriptor: descriptor2(protoOrDescriptor.key)
    } : { ...protoOrDescriptor, key };
    if (finisher != void 0) {
      info.finisher = function(ctor) {
        finisher(ctor, key);
      };
    }
    return info;
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function query(selector, cache2) {
  return decorateProperty({
    descriptor: (name2) => {
      const descriptor2 = {
        get() {
          var _a3, _b2;
          return (_b2 = (_a3 = this.renderRoot) === null || _a3 === void 0 ? void 0 : _a3.querySelector(selector)) !== null && _b2 !== void 0 ? _b2 : null;
        },
        enumerable: true,
        configurable: true
      };
      if (cache2) {
        const key = typeof name2 === "symbol" ? Symbol() : `__${name2}`;
        descriptor2.get = function() {
          var _a3, _b2;
          if (this[key] === void 0) {
            this[key] = (_b2 = (_a3 = this.renderRoot) === null || _a3 === void 0 ? void 0 : _a3.querySelector(selector)) !== null && _b2 !== void 0 ? _b2 : null;
          }
          return this[key];
        };
      }
      return descriptor2;
    }
  });
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var _a$2;
((_a$2 = window.HTMLSlotElement) === null || _a$2 === void 0 ? void 0 : _a$2.prototype.assignedElements) != null ? (slot, opts) => slot.assignedElements(opts) : (slot, opts) => slot.assignedNodes(opts).filter((node) => node.nodeType === Node.ELEMENT_NODE);
class SCodeExampleComponentInterface extends SInterface {
  static get _definition() {
    return {
      active: {
        description: 'Specify which "tab" is active in case of multiple languages examples',
        type: "String"
      },
      toolbar: {
        description: 'Specify what you want in the toolbar. Currently available item is "copy"',
        type: "Array<String>",
        values: ["copy"],
        default: ["copy"]
      },
      toolbarPosition: {
        description: 'Specify the toolbar position. Can be "content" or "nav"',
        type: "String",
        values: ["content", "nav"],
        default: "nav"
      },
      languages: {
        description: 'Specify some languages that you want to support. Must be "[key]: language" object syntax. See [highlight.js doc](https://github.com/highlightjs/highlight.js/blob/main/SUPPORTED_LANGUAGES.md) for supported languages',
        type: "Object",
        default: {}
      },
      items: {
        description: "Specify the items to put in your code example",
        type: "Object[]",
        default: []
      },
      lines: {
        description: "Specify how many lines to display at max",
        type: "Number",
        default: 15,
        physical: true
      },
      moreLabel: {
        description: 'Specify the "show more" button label',
        type: "String",
        default: "Show more"
      },
      lessLabel: {
        description: 'Specigy the "show less" button label',
        type: "String",
        default: "Show less"
      },
      moreAction: {
        description: 'Specify the action to execute when click on the "more" button. Currently available action is "toggle"',
        values: ["toggle"],
        type: "String",
        default: "toggle"
      },
      more: {
        description: "Specify if you want to expand the more feature at start or not",
        type: "Boolean",
        default: false
      },
      scrollOnMore: {
        description: 'Specify if you want to scroll to the code when clicking on the "show more/less" button',
        type: "Boolean",
        default: true
      },
      scrollToSettings: {
        description: "Specify some scrollTo settings",
        type: "Object",
        default: {}
      }
    };
  }
}
var _e$1 = (e, n) => () => (n || e((n = { exports: {} }).exports, n), n.exports);
var Ye$1 = _e$1((Eg, Zn2) => {
  var er2 = function(e) {
    return e && e.Math == Math && e;
  };
  Zn2.exports = er2(typeof globalThis == "object" && globalThis) || er2(typeof window == "object" && window) || er2(typeof self == "object" && self) || er2(typeof global == "object" && global) || function() {
    return this;
  }() || Function("return this")();
});
var Dt = _e$1((Fg, eu2) => {
  eu2.exports = function(e) {
    try {
      return !!e();
    } catch {
      return true;
    }
  };
});
var Ct = _e$1((Ag, tu) => {
  var go2 = Dt();
  tu.exports = !go2(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] != 7;
  });
});
var tr$1 = _e$1((Sg, ru) => {
  var yo2 = Dt();
  ru.exports = !yo2(function() {
    var e = function() {
    }.bind();
    return typeof e != "function" || e.hasOwnProperty("prototype");
  });
});
var Et$1 = _e$1((xg, nu) => {
  var ho2 = tr$1(), rr2 = Function.prototype.call;
  nu.exports = ho2 ? rr2.bind(rr2) : function() {
    return rr2.apply(rr2, arguments);
  };
});
var au = _e$1((iu) => {
  var uu = {}.propertyIsEnumerable, su2 = Object.getOwnPropertyDescriptor, vo2 = su2 && !uu.call({ 1: 2 }, 1);
  iu.f = vo2 ? function(n) {
    var t = su2(this, n);
    return !!t && t.enumerable;
  } : uu;
});
var nr$1 = _e$1((Tg, ou) => {
  ou.exports = function(e, n) {
    return { enumerable: !(e & 1), configurable: !(e & 2), writable: !(e & 4), value: n };
  };
});
var at$2 = _e$1((Bg, pu) => {
  var lu = tr$1(), cu = Function.prototype, Co2 = cu.bind, Lr2 = cu.call, Eo2 = lu && Co2.bind(Lr2, Lr2);
  pu.exports = lu ? function(e) {
    return e && Eo2(e);
  } : function(e) {
    return e && function() {
      return Lr2.apply(e, arguments);
    };
  };
});
var ur$1 = _e$1((Ng, Du) => {
  var fu2 = at$2(), Fo2 = fu2({}.toString), Ao2 = fu2("".slice);
  Du.exports = function(e) {
    return Ao2(Fo2(e), 8, -1);
  };
});
var du = _e$1((wg, mu) => {
  var So2 = Ye$1(), xo2 = at$2(), bo2 = Dt(), To2 = ur$1(), jr2 = So2.Object, Bo2 = xo2("".split);
  mu.exports = bo2(function() {
    return !jr2("z").propertyIsEnumerable(0);
  }) ? function(e) {
    return To2(e) == "String" ? Bo2(e, "") : jr2(e);
  } : jr2;
});
var Or = _e$1((_g, gu) => {
  var No2 = Ye$1(), wo2 = No2.TypeError;
  gu.exports = function(e) {
    if (e == null)
      throw wo2("Can't call method on " + e);
    return e;
  };
});
var sr$2 = _e$1((Pg, yu) => {
  var _o2 = du(), Po2 = Or();
  yu.exports = function(e) {
    return _o2(Po2(e));
  };
});
var ot$1 = _e$1((kg, hu) => {
  hu.exports = function(e) {
    return typeof e == "function";
  };
});
var Ft$2 = _e$1((Ig, vu) => {
  var ko2 = ot$1();
  vu.exports = function(e) {
    return typeof e == "object" ? e !== null : ko2(e);
  };
});
var qt$2 = _e$1((Lg, Cu2) => {
  var qr2 = Ye$1(), Io2 = ot$1(), Lo2 = function(e) {
    return Io2(e) ? e : void 0;
  };
  Cu2.exports = function(e, n) {
    return arguments.length < 2 ? Lo2(qr2[e]) : qr2[e] && qr2[e][n];
  };
});
var Mr$1 = _e$1((jg, Eu) => {
  var jo2 = at$2();
  Eu.exports = jo2({}.isPrototypeOf);
});
var Au = _e$1((Og, Fu) => {
  var Oo2 = qt$2();
  Fu.exports = Oo2("navigator", "userAgent") || "";
});
var wu = _e$1((qg, Nu) => {
  var Bu2 = Ye$1(), Rr = Au(), Su2 = Bu2.process, xu2 = Bu2.Deno, bu = Su2 && Su2.versions || xu2 && xu2.version, Tu = bu && bu.v8, ft2, ir2;
  Tu && (ft2 = Tu.split("."), ir2 = ft2[0] > 0 && ft2[0] < 4 ? 1 : +(ft2[0] + ft2[1]));
  !ir2 && Rr && (ft2 = Rr.match(/Edge\/(\d+)/), (!ft2 || ft2[1] >= 74) && (ft2 = Rr.match(/Chrome\/(\d+)/), ft2 && (ir2 = +ft2[1])));
  Nu.exports = ir2;
});
var Vr = _e$1((Mg, Pu) => {
  var _u = wu(), qo2 = Dt();
  Pu.exports = !!Object.getOwnPropertySymbols && !qo2(function() {
    var e = Symbol();
    return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && _u && _u < 41;
  });
});
var Wr = _e$1((Rg, ku2) => {
  var Mo2 = Vr();
  ku2.exports = Mo2 && !Symbol.sham && typeof Symbol.iterator == "symbol";
});
var $r$2 = _e$1((Vg, Iu) => {
  var Ro2 = Ye$1(), Vo2 = qt$2(), Wo2 = ot$1(), $o2 = Mr$1(), Ho2 = Wr(), Go2 = Ro2.Object;
  Iu.exports = Ho2 ? function(e) {
    return typeof e == "symbol";
  } : function(e) {
    var n = Vo2("Symbol");
    return Wo2(n) && $o2(n.prototype, Go2(e));
  };
});
var ar$1 = _e$1((Wg, Lu) => {
  var Jo2 = Ye$1(), Uo2 = Jo2.String;
  Lu.exports = function(e) {
    try {
      return Uo2(e);
    } catch {
      return "Object";
    }
  };
});
var Mt$1 = _e$1(($g, ju) => {
  var zo2 = Ye$1(), Xo = ot$1(), Ko = ar$1(), Yo = zo2.TypeError;
  ju.exports = function(e) {
    if (Xo(e))
      return e;
    throw Yo(Ko(e) + " is not a function");
  };
});
var or$2 = _e$1((Hg, Ou) => {
  var Qo = Mt$1();
  Ou.exports = function(e, n) {
    var t = e[n];
    return t == null ? void 0 : Qo(t);
  };
});
var Mu = _e$1((Gg, qu2) => {
  var Zo = Ye$1(), Hr2 = Et$1(), Gr2 = ot$1(), Jr2 = Ft$2(), el2 = Zo.TypeError;
  qu2.exports = function(e, n) {
    var t, s2;
    if (n === "string" && Gr2(t = e.toString) && !Jr2(s2 = Hr2(t, e)) || Gr2(t = e.valueOf) && !Jr2(s2 = Hr2(t, e)) || n !== "string" && Gr2(t = e.toString) && !Jr2(s2 = Hr2(t, e)))
      return s2;
    throw el2("Can't convert object to primitive value");
  };
});
var Vu$1 = _e$1((Jg, Ru) => {
  Ru.exports = false;
});
var lr$1 = _e$1((Ug, $u2) => {
  var Wu2 = Ye$1(), tl2 = Object.defineProperty;
  $u2.exports = function(e, n) {
    try {
      tl2(Wu2, e, { value: n, configurable: true, writable: true });
    } catch {
      Wu2[e] = n;
    }
    return n;
  };
});
var cr$2 = _e$1((zg, Gu) => {
  var rl2 = Ye$1(), nl2 = lr$1(), Hu2 = "__core-js_shared__", ul2 = rl2[Hu2] || nl2(Hu2, {});
  Gu.exports = ul2;
});
var Ur$1 = _e$1((Xg, Uu) => {
  var sl2 = Vu$1(), Ju2 = cr$2();
  (Uu.exports = function(e, n) {
    return Ju2[e] || (Ju2[e] = n !== void 0 ? n : {});
  })("versions", []).push({ version: "3.22.2", mode: sl2 ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.22.2/LICENSE", source: "https://github.com/zloirock/core-js" });
});
var pr$2 = _e$1((Kg, zu) => {
  var il2 = Ye$1(), al2 = Or(), ol2 = il2.Object;
  zu.exports = function(e) {
    return ol2(al2(e));
  };
});
var gt$1 = _e$1((Yg, Xu) => {
  var ll2 = at$2(), cl2 = pr$2(), pl2 = ll2({}.hasOwnProperty);
  Xu.exports = Object.hasOwn || function(n, t) {
    return pl2(cl2(n), t);
  };
});
var zr$1 = _e$1((Qg, Ku) => {
  var fl2 = at$2(), Dl2 = 0, ml2 = Math.random(), dl2 = fl2(1 .toString);
  Ku.exports = function(e) {
    return "Symbol(" + (e === void 0 ? "" : e) + ")_" + dl2(++Dl2 + ml2, 36);
  };
});
var St$2 = _e$1((Zg, ts2) => {
  var gl2 = Ye$1(), yl2 = Ur$1(), Yu = gt$1(), hl2 = zr$1(), Qu2 = Vr(), es2 = Wr(), Bt = yl2("wks"), At2 = gl2.Symbol, Zu = At2 && At2.for, vl2 = es2 ? At2 : At2 && At2.withoutSetter || hl2;
  ts2.exports = function(e) {
    if (!Yu(Bt, e) || !(Qu2 || typeof Bt[e] == "string")) {
      var n = "Symbol." + e;
      Qu2 && Yu(At2, e) ? Bt[e] = At2[e] : es2 && Zu ? Bt[e] = Zu(n) : Bt[e] = vl2(n);
    }
    return Bt[e];
  };
});
var ss$2 = _e$1((e0, us2) => {
  var Cl2 = Ye$1(), El2 = Et$1(), rs2 = Ft$2(), ns2 = $r$2(), Fl2 = or$2(), Al2 = Mu(), Sl2 = St$2(), xl2 = Cl2.TypeError, bl2 = Sl2("toPrimitive");
  us2.exports = function(e, n) {
    if (!rs2(e) || ns2(e))
      return e;
    var t = Fl2(e, bl2), s2;
    if (t) {
      if (n === void 0 && (n = "default"), s2 = El2(t, e, n), !rs2(s2) || ns2(s2))
        return s2;
      throw xl2("Can't convert object to primitive value");
    }
    return n === void 0 && (n = "number"), Al2(e, n);
  };
});
var fr$2 = _e$1((t0, is2) => {
  var Tl2 = ss$2(), Bl2 = $r$2();
  is2.exports = function(e) {
    var n = Tl2(e, "string");
    return Bl2(n) ? n : n + "";
  };
});
var ls$2 = _e$1((r0, os2) => {
  var Nl2 = Ye$1(), as2 = Ft$2(), Xr = Nl2.document, wl2 = as2(Xr) && as2(Xr.createElement);
  os2.exports = function(e) {
    return wl2 ? Xr.createElement(e) : {};
  };
});
var Kr = _e$1((n0, cs2) => {
  var _l2 = Ct(), Pl2 = Dt(), kl2 = ls$2();
  cs2.exports = !_l2 && !Pl2(function() {
    return Object.defineProperty(kl2("div"), "a", { get: function() {
      return 7;
    } }).a != 7;
  });
});
var Yr = _e$1((fs2) => {
  var Il2 = Ct(), Ll2 = Et$1(), jl2 = au(), Ol2 = nr$1(), ql2 = sr$2(), Ml2 = fr$2(), Rl2 = gt$1(), Vl2 = Kr(), ps2 = Object.getOwnPropertyDescriptor;
  fs2.f = Il2 ? ps2 : function(n, t) {
    if (n = ql2(n), t = Ml2(t), Vl2)
      try {
        return ps2(n, t);
      } catch {
      }
    if (Rl2(n, t))
      return Ol2(!Ll2(jl2.f, n, t), n[t]);
  };
});
var ms$1 = _e$1((s0, Ds2) => {
  var Wl2 = Ct(), $l2 = Dt();
  Ds2.exports = Wl2 && $l2(function() {
    return Object.defineProperty(function() {
    }, "prototype", { value: 42, writable: false }).prototype != 42;
  });
});
var Nt$2 = _e$1((i0, gs2) => {
  var ds2 = Ye$1(), Hl2 = Ft$2(), Gl2 = ds2.String, Jl2 = ds2.TypeError;
  gs2.exports = function(e) {
    if (Hl2(e))
      return e;
    throw Jl2(Gl2(e) + " is not an object");
  };
});
var mr$2 = _e$1((hs2) => {
  var Ul2 = Ye$1(), zl2 = Ct(), Xl2 = Kr(), Kl2 = ms$1(), Dr2 = Nt$2(), ys2 = fr$2(), Yl2 = Ul2.TypeError, Qr = Object.defineProperty, Ql2 = Object.getOwnPropertyDescriptor, Zr = "enumerable", en2 = "configurable", tn = "writable";
  hs2.f = zl2 ? Kl2 ? function(n, t, s2) {
    if (Dr2(n), t = ys2(t), Dr2(s2), typeof n == "function" && t === "prototype" && "value" in s2 && tn in s2 && !s2[tn]) {
      var a3 = Ql2(n, t);
      a3 && a3[tn] && (n[t] = s2.value, s2 = { configurable: en2 in s2 ? s2[en2] : a3[en2], enumerable: Zr in s2 ? s2[Zr] : a3[Zr], writable: false });
    }
    return Qr(n, t, s2);
  } : Qr : function(n, t, s2) {
    if (Dr2(n), t = ys2(t), Dr2(s2), Xl2)
      try {
        return Qr(n, t, s2);
      } catch {
      }
    if ("get" in s2 || "set" in s2)
      throw Yl2("Accessors not supported");
    return "value" in s2 && (n[t] = s2.value), n;
  };
});
var dr$2 = _e$1((o0, vs2) => {
  var Zl2 = Ct(), ec2 = mr$2(), tc2 = nr$1();
  vs2.exports = Zl2 ? function(e, n, t) {
    return ec2.f(e, n, tc2(1, t));
  } : function(e, n, t) {
    return e[n] = t, e;
  };
});
var gr$1 = _e$1((l0, Cs2) => {
  var rc2 = at$2(), nc2 = ot$1(), rn2 = cr$2(), uc2 = rc2(Function.toString);
  nc2(rn2.inspectSource) || (rn2.inspectSource = function(e) {
    return uc2(e);
  });
  Cs2.exports = rn2.inspectSource;
});
var As$1 = _e$1((c0, Fs2) => {
  var sc2 = Ye$1(), ic = ot$1(), ac = gr$1(), Es2 = sc2.WeakMap;
  Fs2.exports = ic(Es2) && /native code/.test(ac(Es2));
});
var bs$1 = _e$1((p0, xs2) => {
  var oc = Ur$1(), lc = zr$1(), Ss2 = oc("keys");
  xs2.exports = function(e) {
    return Ss2[e] || (Ss2[e] = lc(e));
  };
});
var nn$1 = _e$1((f0, Ts2) => {
  Ts2.exports = {};
});
var ks$1 = _e$1((D0, Ps2) => {
  var cc = As$1(), _s2 = Ye$1(), un2 = at$2(), pc = Ft$2(), fc = dr$2(), sn2 = gt$1(), an2 = cr$2(), Dc = bs$1(), mc = nn$1(), Bs2 = "Object already initialized", ln = _s2.TypeError, dc = _s2.WeakMap, yr2, Rt2, hr2, gc = function(e) {
    return hr2(e) ? Rt2(e) : yr2(e, {});
  }, yc = function(e) {
    return function(n) {
      var t;
      if (!pc(n) || (t = Rt2(n)).type !== e)
        throw ln("Incompatible receiver, " + e + " required");
      return t;
    };
  };
  cc || an2.state ? (yt2 = an2.state || (an2.state = new dc()), Ns2 = un2(yt2.get), on2 = un2(yt2.has), ws2 = un2(yt2.set), yr2 = function(e, n) {
    if (on2(yt2, e))
      throw new ln(Bs2);
    return n.facade = e, ws2(yt2, e, n), n;
  }, Rt2 = function(e) {
    return Ns2(yt2, e) || {};
  }, hr2 = function(e) {
    return on2(yt2, e);
  }) : (xt2 = Dc("state"), mc[xt2] = true, yr2 = function(e, n) {
    if (sn2(e, xt2))
      throw new ln(Bs2);
    return n.facade = e, fc(e, xt2, n), n;
  }, Rt2 = function(e) {
    return sn2(e, xt2) ? e[xt2] : {};
  }, hr2 = function(e) {
    return sn2(e, xt2);
  });
  var yt2, Ns2, on2, ws2, xt2;
  Ps2.exports = { set: yr2, get: Rt2, has: hr2, enforce: gc, getterFor: yc };
});
var js$2 = _e$1((m0, Ls2) => {
  var cn = Ct(), hc = gt$1(), Is2 = Function.prototype, vc = cn && Object.getOwnPropertyDescriptor, pn2 = hc(Is2, "name"), Cc = pn2 && function() {
  }.name === "something", Ec = pn2 && (!cn || cn && vc(Is2, "name").configurable);
  Ls2.exports = { EXISTS: pn2, PROPER: Cc, CONFIGURABLE: Ec };
});
var Vs$1 = _e$1((d0, Rs2) => {
  var Fc = Ye$1(), Os2 = ot$1(), Ac = gt$1(), qs2 = dr$2(), Sc = lr$1(), xc = gr$1(), Ms2 = ks$1(), bc = js$2().CONFIGURABLE, Tc = Ms2.get, Bc = Ms2.enforce, Nc = String(String).split("String");
  (Rs2.exports = function(e, n, t, s2) {
    var a3 = s2 ? !!s2.unsafe : false, r = s2 ? !!s2.enumerable : false, u = s2 ? !!s2.noTargetGet : false, i2 = s2 && s2.name !== void 0 ? s2.name : n, o;
    if (Os2(t) && (String(i2).slice(0, 7) === "Symbol(" && (i2 = "[" + String(i2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!Ac(t, "name") || bc && t.name !== i2) && qs2(t, "name", i2), o = Bc(t), o.source || (o.source = Nc.join(typeof i2 == "string" ? i2 : ""))), e === Fc) {
      r ? e[n] = t : Sc(n, t);
      return;
    } else
      a3 ? !u && e[n] && (r = true) : delete e[n];
    r ? e[n] = t : qs2(e, n, t);
  })(Function.prototype, "toString", function() {
    return Os2(this) && Tc(this).source || xc(this);
  });
});
var vr$1 = _e$1((g0, Ws2) => {
  var wc = Math.ceil, _c2 = Math.floor;
  Ws2.exports = function(e) {
    var n = +e;
    return n !== n || n === 0 ? 0 : (n > 0 ? _c2 : wc)(n);
  };
});
var Hs$1 = _e$1((y0, $s2) => {
  var Pc2 = vr$1(), kc2 = Math.max, Ic = Math.min;
  $s2.exports = function(e, n) {
    var t = Pc2(e);
    return t < 0 ? kc2(t + n, 0) : Ic(t, n);
  };
});
var Js$1 = _e$1((h0, Gs2) => {
  var Lc2 = vr$1(), jc2 = Math.min;
  Gs2.exports = function(e) {
    return e > 0 ? jc2(Lc2(e), 9007199254740991) : 0;
  };
});
var wt$1 = _e$1((v0, Us2) => {
  var Oc = Js$1();
  Us2.exports = function(e) {
    return Oc(e.length);
  };
});
var Ks$1 = _e$1((C0, Xs2) => {
  var qc = sr$2(), Mc2 = Hs$1(), Rc = wt$1(), zs2 = function(e) {
    return function(n, t, s2) {
      var a3 = qc(n), r = Rc(a3), u = Mc2(s2, r), i2;
      if (e && t != t) {
        for (; r > u; )
          if (i2 = a3[u++], i2 != i2)
            return true;
      } else
        for (; r > u; u++)
          if ((e || u in a3) && a3[u] === t)
            return e || u || 0;
      return !e && -1;
    };
  };
  Xs2.exports = { includes: zs2(true), indexOf: zs2(false) };
});
var Zs$1 = _e$1((E0, Qs2) => {
  var Vc2 = at$2(), fn2 = gt$1(), Wc2 = sr$2(), $c2 = Ks$1().indexOf, Hc2 = nn$1(), Ys2 = Vc2([].push);
  Qs2.exports = function(e, n) {
    var t = Wc2(e), s2 = 0, a3 = [], r;
    for (r in t)
      !fn2(Hc2, r) && fn2(t, r) && Ys2(a3, r);
    for (; n.length > s2; )
      fn2(t, r = n[s2++]) && (~$c2(a3, r) || Ys2(a3, r));
    return a3;
  };
});
var ti$2 = _e$1((F0, ei) => {
  ei.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
});
var ni = _e$1((ri) => {
  var Gc2 = Zs$1(), Jc2 = ti$2(), Uc2 = Jc2.concat("length", "prototype");
  ri.f = Object.getOwnPropertyNames || function(n) {
    return Gc2(n, Uc2);
  };
});
var si = _e$1((ui) => {
  ui.f = Object.getOwnPropertySymbols;
});
var ai = _e$1((x0, ii) => {
  var zc2 = qt$2(), Xc2 = at$2(), Kc2 = ni(), Yc2 = si(), Qc2 = Nt$2(), Zc2 = Xc2([].concat);
  ii.exports = zc2("Reflect", "ownKeys") || function(n) {
    var t = Kc2.f(Qc2(n)), s2 = Yc2.f;
    return s2 ? Zc2(t, s2(n)) : t;
  };
});
var ci = _e$1((b0, li2) => {
  var oi = gt$1(), ep = ai(), tp = Yr(), rp = mr$2();
  li2.exports = function(e, n, t) {
    for (var s2 = ep(n), a3 = rp.f, r = tp.f, u = 0; u < s2.length; u++) {
      var i2 = s2[u];
      !oi(e, i2) && !(t && oi(t, i2)) && a3(e, i2, r(n, i2));
    }
  };
});
var fi$1 = _e$1((T0, pi) => {
  var np = Dt(), up = ot$1(), sp = /#|\.prototype\./, Vt = function(e, n) {
    var t = ap[ip(e)];
    return t == lp ? true : t == op ? false : up(n) ? np(n) : !!n;
  }, ip = Vt.normalize = function(e) {
    return String(e).replace(sp, ".").toLowerCase();
  }, ap = Vt.data = {}, op = Vt.NATIVE = "N", lp = Vt.POLYFILL = "P";
  pi.exports = Vt;
});
var Wt = _e$1((B0, Di2) => {
  var Dn = Ye$1(), cp = Yr().f, pp = dr$2(), fp = Vs$1(), Dp2 = lr$1(), mp = ci(), dp = fi$1();
  Di2.exports = function(e, n) {
    var t = e.target, s2 = e.global, a3 = e.stat, r, u, i2, o, c, y;
    if (s2 ? u = Dn : a3 ? u = Dn[t] || Dp2(t, {}) : u = (Dn[t] || {}).prototype, u)
      for (i2 in n) {
        if (c = n[i2], e.noTargetGet ? (y = cp(u, i2), o = y && y.value) : o = u[i2], r = dp(s2 ? i2 : t + (a3 ? "." : "#") + i2, e.forced), !r && o !== void 0) {
          if (typeof c == typeof o)
            continue;
          mp(c, o);
        }
        (e.sham || o && o.sham) && pp(c, "sham", true), fp(u, i2, c, e);
      }
  };
});
var mn = _e$1((N0, mi) => {
  var gp = ur$1();
  mi.exports = Array.isArray || function(n) {
    return gp(n) == "Array";
  };
});
var dn$1 = _e$1((w0, gi2) => {
  var di2 = at$2(), yp = Mt$1(), hp = tr$1(), vp = di2(di2.bind);
  gi2.exports = function(e, n) {
    return yp(e), n === void 0 ? e : hp ? vp(e, n) : function() {
      return e.apply(n, arguments);
    };
  };
});
var gn = _e$1((_0, hi) => {
  var Cp = Ye$1(), Ep = mn(), Fp2 = wt$1(), Ap = dn$1(), Sp = Cp.TypeError, yi2 = function(e, n, t, s2, a3, r, u, i2) {
    for (var o = a3, c = 0, y = u ? Ap(u, i2) : false, m2, d4; c < s2; ) {
      if (c in t) {
        if (m2 = y ? y(t[c], c, n) : t[c], r > 0 && Ep(m2))
          d4 = Fp2(m2), o = yi2(e, n, m2, d4, o, r - 1) - 1;
        else {
          if (o >= 9007199254740991)
            throw Sp("Exceed the acceptable array length");
          e[o] = m2;
        }
        o++;
      }
      c++;
    }
    return o;
  };
  hi.exports = yi2;
});
var Ei = _e$1((P0, Ci) => {
  var xp = St$2(), bp = xp("toStringTag"), vi2 = {};
  vi2[bp] = "z";
  Ci.exports = String(vi2) === "[object z]";
});
var yn$1 = _e$1((k0, Fi) => {
  var Tp = Ye$1(), Bp2 = Ei(), Np = ot$1(), Cr2 = ur$1(), wp = St$2(), _p2 = wp("toStringTag"), Pp = Tp.Object, kp = Cr2(function() {
    return arguments;
  }()) == "Arguments", Ip = function(e, n) {
    try {
      return e[n];
    } catch {
    }
  };
  Fi.exports = Bp2 ? Cr2 : function(e) {
    var n, t, s2;
    return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (t = Ip(n = Pp(e), _p2)) == "string" ? t : kp ? Cr2(n) : (s2 = Cr2(n)) == "Object" && Np(n.callee) ? "Arguments" : s2;
  };
});
var Bi = _e$1((I0, Ti) => {
  var Lp2 = at$2(), jp2 = Dt(), Ai2 = ot$1(), Op2 = yn$1(), qp2 = qt$2(), Mp2 = gr$1(), Si2 = function() {
  }, Rp2 = [], xi = qp2("Reflect", "construct"), hn2 = /^\s*(?:class|function)\b/, Vp2 = Lp2(hn2.exec), Wp2 = !hn2.exec(Si2), $t = function(n) {
    if (!Ai2(n))
      return false;
    try {
      return xi(Si2, Rp2, n), true;
    } catch {
      return false;
    }
  }, bi2 = function(n) {
    if (!Ai2(n))
      return false;
    switch (Op2(n)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return false;
    }
    try {
      return Wp2 || !!Vp2(hn2, Mp2(n));
    } catch {
      return true;
    }
  };
  bi2.sham = true;
  Ti.exports = !xi || jp2(function() {
    var e;
    return $t($t.call) || !$t(Object) || !$t(function() {
      e = true;
    }) || e;
  }) ? bi2 : $t;
});
var Pi = _e$1((L0, _i) => {
  var $p2 = Ye$1(), Ni2 = mn(), Hp2 = Bi(), Gp2 = Ft$2(), Jp2 = St$2(), Up2 = Jp2("species"), wi = $p2.Array;
  _i.exports = function(e) {
    var n;
    return Ni2(e) && (n = e.constructor, Hp2(n) && (n === wi || Ni2(n.prototype)) ? n = void 0 : Gp2(n) && (n = n[Up2], n === null && (n = void 0))), n === void 0 ? wi : n;
  };
});
var vn$1 = _e$1((j0, ki) => {
  var zp2 = Pi();
  ki.exports = function(e, n) {
    return new (zp2(e))(n === 0 ? 0 : n);
  };
});
var Cn$1 = _e$1((O0, Ii2) => {
  Ii2.exports = {};
});
var ji$1 = _e$1((q0, Li) => {
  var tf2 = St$2(), rf2 = Cn$1(), nf2 = tf2("iterator"), uf2 = Array.prototype;
  Li.exports = function(e) {
    return e !== void 0 && (rf2.Array === e || uf2[nf2] === e);
  };
});
var En$2 = _e$1((M0, qi) => {
  var sf2 = yn$1(), Oi2 = or$2(), af2 = Cn$1(), of2 = St$2(), lf2 = of2("iterator");
  qi.exports = function(e) {
    if (e != null)
      return Oi2(e, lf2) || Oi2(e, "@@iterator") || af2[sf2(e)];
  };
});
var Ri = _e$1((R0, Mi2) => {
  var cf2 = Ye$1(), pf2 = Et$1(), ff2 = Mt$1(), Df = Nt$2(), mf2 = ar$1(), df2 = En$2(), gf2 = cf2.TypeError;
  Mi2.exports = function(e, n) {
    var t = arguments.length < 2 ? df2(e) : n;
    if (ff2(t))
      return Df(pf2(t, e));
    throw gf2(mf2(e) + " is not iterable");
  };
});
var $i$1 = _e$1((V0, Wi) => {
  var yf2 = Et$1(), Vi = Nt$2(), hf2 = or$2();
  Wi.exports = function(e, n, t) {
    var s2, a3;
    Vi(e);
    try {
      if (s2 = hf2(e, "return"), !s2) {
        if (n === "throw")
          throw t;
        return t;
      }
      s2 = yf2(s2, e);
    } catch (r) {
      a3 = true, s2 = r;
    }
    if (n === "throw")
      throw t;
    if (a3)
      throw s2;
    return Vi(s2), t;
  };
});
var zi$1 = _e$1((W0, Ui2) => {
  var vf2 = Ye$1(), Cf = dn$1(), Ef2 = Et$1(), Ff = Nt$2(), Af2 = ar$1(), Sf2 = ji$1(), xf2 = wt$1(), Hi = Mr$1(), bf2 = Ri(), Tf2 = En$2(), Gi2 = $i$1(), Bf = vf2.TypeError, Er2 = function(e, n) {
    this.stopped = e, this.result = n;
  }, Ji2 = Er2.prototype;
  Ui2.exports = function(e, n, t) {
    var s2 = t && t.that, a3 = !!(t && t.AS_ENTRIES), r = !!(t && t.IS_ITERATOR), u = !!(t && t.INTERRUPTED), i2 = Cf(n, s2), o, c, y, m2, d4, p, f, h2 = function(T2) {
      return o && Gi2(o, "normal", T2), new Er2(true, T2);
    }, w2 = function(T2) {
      return a3 ? (Ff(T2), u ? i2(T2[0], T2[1], h2) : i2(T2[0], T2[1])) : u ? i2(T2, h2) : i2(T2);
    };
    if (r)
      o = e;
    else {
      if (c = Tf2(e), !c)
        throw Bf(Af2(e) + " is not iterable");
      if (Sf2(c)) {
        for (y = 0, m2 = xf2(e); m2 > y; y++)
          if (d4 = w2(e[y]), d4 && Hi(Ji2, d4))
            return d4;
        return new Er2(false);
      }
      o = bf2(e, c);
    }
    for (p = o.next; !(f = Ef2(p, o)).done; ) {
      try {
        d4 = w2(f.value);
      } catch (T2) {
        Gi2(o, "throw", T2);
      }
      if (typeof d4 == "object" && d4 && Hi(Ji2, d4))
        return d4;
    }
    return new Er2(false);
  };
});
var Ki = _e$1(($0, Xi) => {
  var Nf = fr$2(), wf2 = mr$2(), _f2 = nr$1();
  Xi.exports = function(e, n, t) {
    var s2 = Nf(n);
    s2 in e ? wf2.f(e, s2, _f2(0, t)) : e[s2] = t;
  };
});
var Yi = _e$1(() => {
  var Lf = Wt(), jf = Ye$1();
  Lf({ global: true }, { globalThis: jf });
});
var Xp$1 = Wt(), Kp$1 = gn(), Yp$1 = Mt$1(), Qp$1 = pr$2(), Zp$1 = wt$1(), ef$2 = vn$1();
Xp$1({ target: "Array", proto: true }, { flatMap: function(n) {
  var t = Qp$1(this), s2 = Zp$1(t), a3;
  return Yp$1(n), a3 = ef$2(t, 0), a3.length = Kp$1(a3, t, t, s2, 0, 1, n, arguments.length > 1 ? arguments[1] : void 0), a3;
} });
var Pf = Wt(), kf$1 = zi$1(), If = Ki();
Pf({ target: "Object", stat: true }, { fromEntries: function(n) {
  var t = {};
  return kf$1(n, function(s2, a3) {
    If(t, s2, a3);
  }, { AS_ENTRIES: true }), t;
} });
Yi();
var Of$1 = Wt(), qf$1 = gn(), Mf = pr$2(), Rf = wt$1(), Vf = vr$1(), Wf = vn$1();
Of$1({ target: "Array", proto: true }, { flat: function() {
  var n = arguments.length ? arguments[0] : void 0, t = Mf(this), s2 = Rf(t), a3 = Wf(t, 0);
  return a3.length = qf$1(a3, t, t, s2, 0, n === void 0 ? 1 : Vf(n)), a3;
} });
var $f = ["cliName", "cliCategory", "cliDescription"], Hf = ["_"], Gf = ["languageId"], Qi$1, Zi$1, ea, ta, ra, na$1;
function wn$1(e, n) {
  if (e == null)
    return {};
  var t = Jf(e, n), s2, a3;
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    for (a3 = 0; a3 < r.length; a3++)
      s2 = r[a3], !(n.indexOf(s2) >= 0) && (!Object.prototype.propertyIsEnumerable.call(e, s2) || (t[s2] = e[s2]));
  }
  return t;
}
function Jf(e, n) {
  if (e == null)
    return {};
  var t = {}, s2 = Object.keys(e), a3, r;
  for (r = 0; r < s2.length; r++)
    a3 = s2[r], !(n.indexOf(a3) >= 0) && (t[a3] = e[a3]);
  return t;
}
function _t$1(e, n) {
  return n || (n = e.slice(0)), Object.freeze(Object.defineProperties(e, { raw: { value: Object.freeze(n) } }));
}
var Uf = Object.create, br$1 = Object.defineProperty, zf = Object.getOwnPropertyDescriptor, _n$1 = Object.getOwnPropertyNames, Xf = Object.getPrototypeOf, Kf = Object.prototype.hasOwnProperty, mt$1 = (e, n) => function() {
  return e && (n = (0, e[_n$1(e)[0]])(e = 0)), n;
}, Z = (e, n) => function() {
  return n || (0, e[_n$1(e)[0]])((n = { exports: {} }).exports, n), n.exports;
}, Gt = (e, n) => {
  for (var t in n)
    br$1(e, t, { get: n[t], enumerable: true });
}, la = (e, n, t, s2) => {
  if (n && typeof n == "object" || typeof n == "function")
    for (let a3 of _n$1(n))
      !Kf.call(e, a3) && a3 !== t && br$1(e, a3, { get: () => n[a3], enumerable: !(s2 = zf(n, a3)) || s2.enumerable });
  return e;
}, Yf = (e, n, t) => (t = e != null ? Uf(Xf(e)) : {}, la(n || !e || !e.__esModule ? br$1(t, "default", { value: e, enumerable: true }) : t, e)), lt$1 = (e) => la(br$1({}, "__esModule", { value: true }), e), ua, sa$1, bt$1, re = mt$1({ "<define:process>"() {
  ua = {}, sa$1 = [], bt$1 = { env: ua, argv: sa$1 };
} }), ca$1 = Z({ "package.json"(e, n) {
  n.exports = { version: "2.7.1" };
} }), Qf = Z({ "node_modules/diff/lib/diff/base.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true }), e.default = n;
  function n() {
  }
  n.prototype = { diff: function(r, u) {
    var i2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = i2.callback;
    typeof i2 == "function" && (o = i2, i2 = {}), this.options = i2;
    var c = this;
    function y(S2) {
      return o ? (setTimeout(function() {
        o(void 0, S2);
      }, 0), true) : S2;
    }
    r = this.castInput(r), u = this.castInput(u), r = this.removeEmpty(this.tokenize(r)), u = this.removeEmpty(this.tokenize(u));
    var m2 = u.length, d4 = r.length, p = 1, f = m2 + d4, h2 = [{ newPos: -1, components: [] }], w2 = this.extractCommon(h2[0], u, r, 0);
    if (h2[0].newPos + 1 >= m2 && w2 + 1 >= d4)
      return y([{ value: this.join(u), count: u.length }]);
    function T2() {
      for (var S2 = -1 * p; S2 <= p; S2 += 2) {
        var B = void 0, I2 = h2[S2 - 1], k2 = h2[S2 + 1], P = (k2 ? k2.newPos : 0) - S2;
        I2 && (h2[S2 - 1] = void 0);
        var C2 = I2 && I2.newPos + 1 < m2, D2 = k2 && 0 <= P && P < d4;
        if (!C2 && !D2) {
          h2[S2] = void 0;
          continue;
        }
        if (!C2 || D2 && I2.newPos < k2.newPos ? (B = s2(k2), c.pushComponent(B.components, void 0, true)) : (B = I2, B.newPos++, c.pushComponent(B.components, true, void 0)), P = c.extractCommon(B, u, r, S2), B.newPos + 1 >= m2 && P + 1 >= d4)
          return y(t(c, B.components, u, r, c.useLongestToken));
        h2[S2] = B;
      }
      p++;
    }
    if (o)
      (function S2() {
        setTimeout(function() {
          if (p > f)
            return o();
          T2() || S2();
        }, 0);
      })();
    else
      for (; p <= f; ) {
        var A2 = T2();
        if (A2)
          return A2;
      }
  }, pushComponent: function(r, u, i2) {
    var o = r[r.length - 1];
    o && o.added === u && o.removed === i2 ? r[r.length - 1] = { count: o.count + 1, added: u, removed: i2 } : r.push({ count: 1, added: u, removed: i2 });
  }, extractCommon: function(r, u, i2, o) {
    for (var c = u.length, y = i2.length, m2 = r.newPos, d4 = m2 - o, p = 0; m2 + 1 < c && d4 + 1 < y && this.equals(u[m2 + 1], i2[d4 + 1]); )
      m2++, d4++, p++;
    return p && r.components.push({ count: p }), r.newPos = m2, d4;
  }, equals: function(r, u) {
    return this.options.comparator ? this.options.comparator(r, u) : r === u || this.options.ignoreCase && r.toLowerCase() === u.toLowerCase();
  }, removeEmpty: function(r) {
    for (var u = [], i2 = 0; i2 < r.length; i2++)
      r[i2] && u.push(r[i2]);
    return u;
  }, castInput: function(r) {
    return r;
  }, tokenize: function(r) {
    return r.split("");
  }, join: function(r) {
    return r.join("");
  } };
  function t(a3, r, u, i2, o) {
    for (var c = 0, y = r.length, m2 = 0, d4 = 0; c < y; c++) {
      var p = r[c];
      if (p.removed) {
        if (p.value = a3.join(i2.slice(d4, d4 + p.count)), d4 += p.count, c && r[c - 1].added) {
          var h2 = r[c - 1];
          r[c - 1] = r[c], r[c] = h2;
        }
      } else {
        if (!p.added && o) {
          var f = u.slice(m2, m2 + p.count);
          f = f.map(function(T2, A2) {
            var S2 = i2[d4 + A2];
            return S2.length > T2.length ? S2 : T2;
          }), p.value = a3.join(f);
        } else
          p.value = a3.join(u.slice(m2, m2 + p.count));
        m2 += p.count, p.added || (d4 += p.count);
      }
    }
    var w2 = r[y - 1];
    return y > 1 && typeof w2.value == "string" && (w2.added || w2.removed) && a3.equals("", w2.value) && (r[y - 2].value += w2.value, r.pop()), r;
  }
  function s2(a3) {
    return { newPos: a3.newPos, components: a3.components.slice(0) };
  }
} }), Zf = Z({ "node_modules/diff/lib/diff/array.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true }), e.diffArrays = a3, e.arrayDiff = void 0;
  var n = t(Qf());
  function t(r) {
    return r && r.__esModule ? r : { default: r };
  }
  var s2 = new n.default();
  e.arrayDiff = s2, s2.tokenize = function(r) {
    return r.slice();
  }, s2.join = s2.removeEmpty = function(r) {
    return r;
  };
  function a3(r, u, i2) {
    return s2.diff(r, u, i2);
  }
} }), Pn = Z({ "src/document/doc-builders.js"(e, n) {
  re();
  function t(F) {
    return { type: "concat", parts: F };
  }
  function s2(F) {
    return { type: "indent", contents: F };
  }
  function a3(F, l) {
    return { type: "align", contents: l, n: F };
  }
  function r(F) {
    let l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return { type: "group", id: l.id, contents: F, break: Boolean(l.shouldBreak), expandedStates: l.expandedStates };
  }
  function u(F) {
    return a3(Number.NEGATIVE_INFINITY, F);
  }
  function i2(F) {
    return a3({ type: "root" }, F);
  }
  function o(F) {
    return a3(-1, F);
  }
  function c(F, l) {
    return r(F[0], Object.assign(Object.assign({}, l), {}, { expandedStates: F }));
  }
  function y(F) {
    return { type: "fill", parts: F };
  }
  function m2(F, l) {
    let E = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return { type: "if-break", breakContents: F, flatContents: l, groupId: E.groupId };
  }
  function d4(F, l) {
    return { type: "indent-if-break", contents: F, groupId: l.groupId, negate: l.negate };
  }
  function p(F) {
    return { type: "line-suffix", contents: F };
  }
  var f = { type: "line-suffix-boundary" }, h2 = { type: "break-parent" }, w2 = { type: "trim" }, T2 = { type: "line", hard: true }, A2 = { type: "line", hard: true, literal: true }, S2 = { type: "line" }, B = { type: "line", soft: true }, I2 = t([T2, h2]), k2 = t([A2, h2]), P = { type: "cursor", placeholder: Symbol("cursor") };
  function C2(F, l) {
    let E = [];
    for (let v = 0; v < l.length; v++)
      v !== 0 && E.push(F), E.push(l[v]);
    return t(E);
  }
  function D2(F, l, E) {
    let v = F;
    if (l > 0) {
      for (let N = 0; N < Math.floor(l / E); ++N)
        v = s2(v);
      v = a3(l % E, v), v = a3(Number.NEGATIVE_INFINITY, v);
    }
    return v;
  }
  function g2(F, l) {
    return { type: "label", label: F, contents: l };
  }
  n.exports = { concat: t, join: C2, line: S2, softline: B, hardline: I2, literalline: k2, group: r, conditionalGroup: c, fill: y, lineSuffix: p, lineSuffixBoundary: f, cursor: P, breakParent: h2, ifBreak: m2, trim: w2, indent: s2, indentIfBreak: d4, align: a3, addAlignmentToDoc: D2, markAsRoot: i2, dedentToRoot: u, dedent: o, hardlineWithoutBreakParent: T2, literallineWithoutBreakParent: A2, label: g2 };
} }), kn$2 = Z({ "src/common/end-of-line.js"(e, n) {
  re();
  function t(u) {
    let i2 = u.indexOf("\r");
    return i2 >= 0 ? u.charAt(i2 + 1) === `
` ? "crlf" : "cr" : "lf";
  }
  function s2(u) {
    switch (u) {
      case "cr":
        return "\r";
      case "crlf":
        return `\r
`;
      default:
        return `
`;
    }
  }
  function a3(u, i2) {
    let o;
    switch (i2) {
      case `
`:
        o = /\n/g;
        break;
      case "\r":
        o = /\r/g;
        break;
      case `\r
`:
        o = /\r\n/g;
        break;
      default:
        throw new Error('Unexpected "eol" '.concat(JSON.stringify(i2), "."));
    }
    let c = u.match(o);
    return c ? c.length : 0;
  }
  function r(u) {
    return u.replace(/\r\n?/g, `
`);
  }
  n.exports = { guessEndOfLine: t, convertEndOfLineToChars: s2, countEndOfLineChars: a3, normalizeEndOfLine: r };
} }), it$2 = Z({ "src/utils/get-last.js"(e, n) {
  re();
  var t = (s2) => s2[s2.length - 1];
  n.exports = t;
} });
function eD$1() {
  let { onlyFirst: e = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
  return new RegExp(n, e ? void 0 : "g");
}
var tD$1 = mt$1({ "node_modules/strip-ansi/node_modules/ansi-regex/index.js"() {
  re();
} });
function rD$1(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a `string`, got `".concat(typeof e, "`"));
  return e.replace(eD$1(), "");
}
var nD$1 = mt$1({ "node_modules/strip-ansi/index.js"() {
  re(), tD$1();
} });
function uD$1(e) {
  return Number.isInteger(e) ? e >= 4352 && (e <= 4447 || e === 9001 || e === 9002 || 11904 <= e && e <= 12871 && e !== 12351 || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141) : false;
}
var sD$1 = mt$1({ "node_modules/is-fullwidth-code-point/index.js"() {
  re();
} }), iD$1 = Z({ "node_modules/emoji-regex/index.js"(e, n) {
  re(), n.exports = function() {
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
  };
} }), pa = {};
Gt(pa, { default: () => aD$1 });
function aD$1(e) {
  if (typeof e != "string" || e.length === 0 || (e = rD$1(e), e.length === 0))
    return 0;
  e = e.replace((0, fa.default)(), "  ");
  let n = 0;
  for (let t = 0; t < e.length; t++) {
    let s2 = e.codePointAt(t);
    s2 <= 31 || s2 >= 127 && s2 <= 159 || s2 >= 768 && s2 <= 879 || (s2 > 65535 && t++, n += uD$1(s2) ? 2 : 1);
  }
  return n;
}
var fa, oD$1 = mt$1({ "node_modules/string-width/index.js"() {
  re(), nD$1(), sD$1(), fa = Yf(iD$1());
} }), Da = Z({ "src/utils/get-string-width.js"(e, n) {
  re();
  var t = (oD$1(), lt$1(pa)).default, s2 = /[^\x20-\x7F]/;
  function a3(r) {
    return r ? s2.test(r) ? t(r) : r.length : 0;
  }
  n.exports = a3;
} }), In = Z({ "src/document/doc-utils.js"(e, n) {
  re();
  var t = it$2(), { literalline: s2, join: a3 } = Pn(), r = (l) => Array.isArray(l) || l && l.type === "concat", u = (l) => {
    if (Array.isArray(l))
      return l;
    if (l.type !== "concat" && l.type !== "fill")
      throw new Error("Expect doc type to be `concat` or `fill`.");
    return l.parts;
  }, i2 = {};
  function o(l, E, v, N) {
    let x2 = [l];
    for (; x2.length > 0; ) {
      let b2 = x2.pop();
      if (b2 === i2) {
        v(x2.pop());
        continue;
      }
      if (v && x2.push(b2, i2), !E || E(b2) !== false)
        if (r(b2) || b2.type === "fill") {
          let L = u(b2);
          for (let M2 = L.length, j = M2 - 1; j >= 0; --j)
            x2.push(L[j]);
        } else if (b2.type === "if-break")
          b2.flatContents && x2.push(b2.flatContents), b2.breakContents && x2.push(b2.breakContents);
        else if (b2.type === "group" && b2.expandedStates)
          if (N)
            for (let L = b2.expandedStates.length, M2 = L - 1; M2 >= 0; --M2)
              x2.push(b2.expandedStates[M2]);
          else
            x2.push(b2.contents);
        else
          b2.contents && x2.push(b2.contents);
    }
  }
  function c(l, E) {
    let v = /* @__PURE__ */ new Map();
    return N(l);
    function N(b2) {
      if (v.has(b2))
        return v.get(b2);
      let L = x2(b2);
      return v.set(b2, L), L;
    }
    function x2(b2) {
      if (Array.isArray(b2))
        return E(b2.map(N));
      if (b2.type === "concat" || b2.type === "fill") {
        let L = b2.parts.map(N);
        return E(Object.assign(Object.assign({}, b2), {}, { parts: L }));
      }
      if (b2.type === "if-break") {
        let L = b2.breakContents && N(b2.breakContents), M2 = b2.flatContents && N(b2.flatContents);
        return E(Object.assign(Object.assign({}, b2), {}, { breakContents: L, flatContents: M2 }));
      }
      if (b2.type === "group" && b2.expandedStates) {
        let L = b2.expandedStates.map(N), M2 = L[0];
        return E(Object.assign(Object.assign({}, b2), {}, { contents: M2, expandedStates: L }));
      }
      if (b2.contents) {
        let L = N(b2.contents);
        return E(Object.assign(Object.assign({}, b2), {}, { contents: L }));
      }
      return E(b2);
    }
  }
  function y(l, E, v) {
    let N = v, x2 = false;
    function b2(L) {
      let M2 = E(L);
      if (M2 !== void 0 && (x2 = true, N = M2), x2)
        return false;
    }
    return o(l, b2), N;
  }
  function m2(l) {
    if (l.type === "group" && l.break || l.type === "line" && l.hard || l.type === "break-parent")
      return true;
  }
  function d4(l) {
    return y(l, m2, false);
  }
  function p(l) {
    if (l.length > 0) {
      let E = t(l);
      !E.expandedStates && !E.break && (E.break = "propagated");
    }
    return null;
  }
  function f(l) {
    let E = /* @__PURE__ */ new Set(), v = [];
    function N(b2) {
      if (b2.type === "break-parent" && p(v), b2.type === "group") {
        if (v.push(b2), E.has(b2))
          return false;
        E.add(b2);
      }
    }
    function x2(b2) {
      b2.type === "group" && v.pop().break && p(v);
    }
    o(l, N, x2, true);
  }
  function h2(l) {
    return l.type === "line" && !l.hard ? l.soft ? "" : " " : l.type === "if-break" ? l.flatContents || "" : l;
  }
  function w2(l) {
    return c(l, h2);
  }
  var T2 = (l, E) => l && l.type === "line" && l.hard && E && E.type === "break-parent";
  function A2(l) {
    if (!l)
      return l;
    if (r(l) || l.type === "fill") {
      let E = u(l);
      for (; E.length > 1 && T2(...E.slice(-2)); )
        E.length -= 2;
      if (E.length > 0) {
        let v = A2(t(E));
        E[E.length - 1] = v;
      }
      return Array.isArray(l) ? E : Object.assign(Object.assign({}, l), {}, { parts: E });
    }
    switch (l.type) {
      case "align":
      case "indent":
      case "indent-if-break":
      case "group":
      case "line-suffix":
      case "label": {
        let E = A2(l.contents);
        return Object.assign(Object.assign({}, l), {}, { contents: E });
      }
      case "if-break": {
        let E = A2(l.breakContents), v = A2(l.flatContents);
        return Object.assign(Object.assign({}, l), {}, { breakContents: E, flatContents: v });
      }
    }
    return l;
  }
  function S2(l) {
    return A2(I2(l));
  }
  function B(l) {
    switch (l.type) {
      case "fill":
        if (l.parts.every((v) => v === ""))
          return "";
        break;
      case "group":
        if (!l.contents && !l.id && !l.break && !l.expandedStates)
          return "";
        if (l.contents.type === "group" && l.contents.id === l.id && l.contents.break === l.break && l.contents.expandedStates === l.expandedStates)
          return l.contents;
        break;
      case "align":
      case "indent":
      case "indent-if-break":
      case "line-suffix":
        if (!l.contents)
          return "";
        break;
      case "if-break":
        if (!l.flatContents && !l.breakContents)
          return "";
        break;
    }
    if (!r(l))
      return l;
    let E = [];
    for (let v of u(l)) {
      if (!v)
        continue;
      let [N, ...x2] = r(v) ? u(v) : [v];
      typeof N == "string" && typeof t(E) == "string" ? E[E.length - 1] += N : E.push(N), E.push(...x2);
    }
    return E.length === 0 ? "" : E.length === 1 ? E[0] : Array.isArray(l) ? E : Object.assign(Object.assign({}, l), {}, { parts: E });
  }
  function I2(l) {
    return c(l, (E) => B(E));
  }
  function k2(l) {
    let E = [], v = l.filter(Boolean);
    for (; v.length > 0; ) {
      let N = v.shift();
      if (!!N) {
        if (r(N)) {
          v.unshift(...u(N));
          continue;
        }
        if (E.length > 0 && typeof t(E) == "string" && typeof N == "string") {
          E[E.length - 1] += N;
          continue;
        }
        E.push(N);
      }
    }
    return E;
  }
  function P(l) {
    return c(l, (E) => Array.isArray(E) ? k2(E) : E.parts ? Object.assign(Object.assign({}, E), {}, { parts: k2(E.parts) }) : E);
  }
  function C2(l) {
    return c(l, (E) => typeof E == "string" && E.includes(`
`) ? D2(E) : E);
  }
  function D2(l) {
    let E = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s2;
    return a3(E, l.split(`
`)).parts;
  }
  function g2(l) {
    if (l.type === "line")
      return true;
  }
  function F(l) {
    return y(l, g2, false);
  }
  n.exports = { isConcat: r, getDocParts: u, willBreak: d4, traverseDoc: o, findInDoc: y, mapDoc: c, propagateBreaks: f, removeLines: w2, stripTrailingHardline: S2, normalizeParts: k2, normalizeDoc: P, cleanDoc: I2, replaceTextEndOfLine: D2, replaceEndOfLine: C2, canBreak: F };
} }), lD$1 = Z({ "src/document/doc-printer.js"(e, n) {
  re();
  var { convertEndOfLineToChars: t } = kn$2(), s2 = it$2(), a3 = Da(), { fill: r, cursor: u, indent: i2 } = Pn(), { isConcat: o, getDocParts: c } = In(), y, m2 = 1, d4 = 2;
  function p() {
    return { value: "", length: 0, queue: [] };
  }
  function f(B, I2) {
    return w2(B, { type: "indent" }, I2);
  }
  function h2(B, I2, k2) {
    return I2 === Number.NEGATIVE_INFINITY ? B.root || p() : I2 < 0 ? w2(B, { type: "dedent" }, k2) : I2 ? I2.type === "root" ? Object.assign(Object.assign({}, B), {}, { root: B }) : w2(B, { type: typeof I2 == "string" ? "stringAlign" : "numberAlign", n: I2 }, k2) : B;
  }
  function w2(B, I2, k2) {
    let P = I2.type === "dedent" ? B.queue.slice(0, -1) : [...B.queue, I2], C2 = "", D2 = 0, g2 = 0, F = 0;
    for (let L of P)
      switch (L.type) {
        case "indent":
          v(), k2.useTabs ? l(1) : E(k2.tabWidth);
          break;
        case "stringAlign":
          v(), C2 += L.n, D2 += L.n.length;
          break;
        case "numberAlign":
          g2 += 1, F += L.n;
          break;
        default:
          throw new Error("Unexpected type '".concat(L.type, "'"));
      }
    return x2(), Object.assign(Object.assign({}, B), {}, { value: C2, length: D2, queue: P });
    function l(L) {
      C2 += "	".repeat(L), D2 += k2.tabWidth * L;
    }
    function E(L) {
      C2 += " ".repeat(L), D2 += L;
    }
    function v() {
      k2.useTabs ? N() : x2();
    }
    function N() {
      g2 > 0 && l(g2), b2();
    }
    function x2() {
      F > 0 && E(F), b2();
    }
    function b2() {
      g2 = 0, F = 0;
    }
  }
  function T2(B) {
    if (B.length === 0)
      return 0;
    let I2 = 0;
    for (; B.length > 0 && typeof s2(B) == "string" && /^[\t ]*$/.test(s2(B)); )
      I2 += B.pop().length;
    if (B.length > 0 && typeof s2(B) == "string") {
      let k2 = s2(B).replace(/[\t ]*$/, "");
      I2 += s2(B).length - k2.length, B[B.length - 1] = k2;
    }
    return I2;
  }
  function A2(B, I2, k2, P, C2, D2) {
    let g2 = I2.length, F = [B], l = [];
    for (; k2 >= 0; ) {
      if (F.length === 0) {
        if (g2 === 0)
          return true;
        F.push(I2[g2 - 1]), g2--;
        continue;
      }
      let [E, v, N] = F.pop();
      if (typeof N == "string")
        l.push(N), k2 -= a3(N);
      else if (o(N)) {
        let x2 = c(N);
        for (let b2 = x2.length - 1; b2 >= 0; b2--)
          F.push([E, v, x2[b2]]);
      } else
        switch (N.type) {
          case "indent":
            F.push([f(E, P), v, N.contents]);
            break;
          case "align":
            F.push([h2(E, N.n, P), v, N.contents]);
            break;
          case "trim":
            k2 += T2(l);
            break;
          case "group": {
            if (D2 && N.break)
              return false;
            let x2 = N.break ? m2 : v;
            F.push([E, x2, N.expandedStates && x2 === m2 ? s2(N.expandedStates) : N.contents]), N.id && (y[N.id] = x2);
            break;
          }
          case "fill":
            for (let x2 = N.parts.length - 1; x2 >= 0; x2--)
              F.push([E, v, N.parts[x2]]);
            break;
          case "if-break":
          case "indent-if-break": {
            let x2 = N.groupId ? y[N.groupId] : v;
            if (x2 === m2) {
              let b2 = N.type === "if-break" ? N.breakContents : N.negate ? N.contents : i2(N.contents);
              b2 && F.push([E, v, b2]);
            }
            if (x2 === d4) {
              let b2 = N.type === "if-break" ? N.flatContents : N.negate ? i2(N.contents) : N.contents;
              b2 && F.push([E, v, b2]);
            }
            break;
          }
          case "line":
            switch (v) {
              case d4:
                if (!N.hard) {
                  N.soft || (l.push(" "), k2 -= 1);
                  break;
                }
                return true;
              case m2:
                return true;
            }
            break;
          case "line-suffix":
            C2 = true;
            break;
          case "line-suffix-boundary":
            if (C2)
              return false;
            break;
          case "label":
            F.push([E, v, N.contents]);
            break;
        }
    }
    return false;
  }
  function S2(B, I2) {
    y = {};
    let k2 = I2.printWidth, P = t(I2.endOfLine), C2 = 0, D2 = [[p(), m2, B]], g2 = [], F = false, l = [];
    for (; D2.length > 0; ) {
      let [v, N, x2] = D2.pop();
      if (typeof x2 == "string") {
        let b2 = P !== `
` ? x2.replace(/\n/g, P) : x2;
        g2.push(b2), C2 += a3(b2);
      } else if (o(x2)) {
        let b2 = c(x2);
        for (let L = b2.length - 1; L >= 0; L--)
          D2.push([v, N, b2[L]]);
      } else
        switch (x2.type) {
          case "cursor":
            g2.push(u.placeholder);
            break;
          case "indent":
            D2.push([f(v, I2), N, x2.contents]);
            break;
          case "align":
            D2.push([h2(v, x2.n, I2), N, x2.contents]);
            break;
          case "trim":
            C2 -= T2(g2);
            break;
          case "group":
            switch (N) {
              case d4:
                if (!F) {
                  D2.push([v, x2.break ? m2 : d4, x2.contents]);
                  break;
                }
              case m2: {
                F = false;
                let b2 = [v, d4, x2.contents], L = k2 - C2, M2 = l.length > 0;
                if (!x2.break && A2(b2, D2, L, I2, M2))
                  D2.push(b2);
                else if (x2.expandedStates) {
                  let j = s2(x2.expandedStates);
                  if (x2.break) {
                    D2.push([v, m2, j]);
                    break;
                  } else
                    for (let $ = 1; $ < x2.expandedStates.length + 1; $++)
                      if ($ >= x2.expandedStates.length) {
                        D2.push([v, m2, j]);
                        break;
                      } else {
                        let V = x2.expandedStates[$], q = [v, d4, V];
                        if (A2(q, D2, L, I2, M2)) {
                          D2.push(q);
                          break;
                        }
                      }
                } else
                  D2.push([v, m2, x2.contents]);
                break;
              }
            }
            x2.id && (y[x2.id] = s2(D2)[1]);
            break;
          case "fill": {
            let b2 = k2 - C2, { parts: L } = x2;
            if (L.length === 0)
              break;
            let [M2, j] = L, $ = [v, d4, M2], V = [v, m2, M2], q = A2($, [], b2, I2, l.length > 0, true);
            if (L.length === 1) {
              q ? D2.push($) : D2.push(V);
              break;
            }
            let Y3 = [v, d4, j], H3 = [v, m2, j];
            if (L.length === 2) {
              q ? D2.push(Y3, $) : D2.push(H3, V);
              break;
            }
            L.splice(0, 2);
            let R = [v, N, r(L)], Q = L[0];
            A2([v, d4, [M2, j, Q]], [], b2, I2, l.length > 0, true) ? D2.push(R, Y3, $) : q ? D2.push(R, H3, $) : D2.push(R, H3, V);
            break;
          }
          case "if-break":
          case "indent-if-break": {
            let b2 = x2.groupId ? y[x2.groupId] : N;
            if (b2 === m2) {
              let L = x2.type === "if-break" ? x2.breakContents : x2.negate ? x2.contents : i2(x2.contents);
              L && D2.push([v, N, L]);
            }
            if (b2 === d4) {
              let L = x2.type === "if-break" ? x2.flatContents : x2.negate ? i2(x2.contents) : x2.contents;
              L && D2.push([v, N, L]);
            }
            break;
          }
          case "line-suffix":
            l.push([v, N, x2.contents]);
            break;
          case "line-suffix-boundary":
            l.length > 0 && D2.push([v, N, { type: "line", hard: true }]);
            break;
          case "line":
            switch (N) {
              case d4:
                if (x2.hard)
                  F = true;
                else {
                  x2.soft || (g2.push(" "), C2 += 1);
                  break;
                }
              case m2:
                if (l.length > 0) {
                  D2.push([v, N, x2], ...l.reverse()), l = [];
                  break;
                }
                x2.literal ? v.root ? (g2.push(P, v.root.value), C2 = v.root.length) : (g2.push(P), C2 = 0) : (C2 -= T2(g2), g2.push(P + v.value), C2 = v.length);
                break;
            }
            break;
          case "label":
            D2.push([v, N, x2.contents]);
            break;
        }
      D2.length === 0 && l.length > 0 && (D2.push(...l.reverse()), l = []);
    }
    let E = g2.indexOf(u.placeholder);
    if (E !== -1) {
      let v = g2.indexOf(u.placeholder, E + 1), N = g2.slice(0, E).join(""), x2 = g2.slice(E + 1, v).join(""), b2 = g2.slice(v + 1).join("");
      return { formatted: N + x2 + b2, cursorNodeStart: N.length, cursorNodeText: x2 };
    }
    return { formatted: g2.join("") };
  }
  n.exports = { printDocToString: S2 };
} }), cD$1 = Z({ "src/document/doc-debug.js"(e, n) {
  re();
  var { isConcat: t, getDocParts: s2 } = In();
  function a3(u) {
    if (!u)
      return "";
    if (t(u)) {
      let i2 = [];
      for (let o of s2(u))
        if (t(o))
          i2.push(...a3(o).parts);
        else {
          let c = a3(o);
          c !== "" && i2.push(c);
        }
      return { type: "concat", parts: i2 };
    }
    return u.type === "if-break" ? Object.assign(Object.assign({}, u), {}, { breakContents: a3(u.breakContents), flatContents: a3(u.flatContents) }) : u.type === "group" ? Object.assign(Object.assign({}, u), {}, { contents: a3(u.contents), expandedStates: u.expandedStates && u.expandedStates.map(a3) }) : u.type === "fill" ? { type: "fill", parts: u.parts.map(a3) } : u.contents ? Object.assign(Object.assign({}, u), {}, { contents: a3(u.contents) }) : u;
  }
  function r(u) {
    let i2 = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Set();
    return c(a3(u));
    function c(m2, d4, p) {
      if (typeof m2 == "string")
        return JSON.stringify(m2);
      if (t(m2)) {
        let f = s2(m2).map(c).filter(Boolean);
        return f.length === 1 ? f[0] : "[".concat(f.join(", "), "]");
      }
      if (m2.type === "line") {
        let f = Array.isArray(p) && p[d4 + 1] && p[d4 + 1].type === "break-parent";
        return m2.literal ? f ? "literalline" : "literallineWithoutBreakParent" : m2.hard ? f ? "hardline" : "hardlineWithoutBreakParent" : m2.soft ? "softline" : "line";
      }
      if (m2.type === "break-parent")
        return Array.isArray(p) && p[d4 - 1] && p[d4 - 1].type === "line" && p[d4 - 1].hard ? void 0 : "breakParent";
      if (m2.type === "trim")
        return "trim";
      if (m2.type === "indent")
        return "indent(" + c(m2.contents) + ")";
      if (m2.type === "align")
        return m2.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + c(m2.contents) + ")" : m2.n < 0 ? "dedent(" + c(m2.contents) + ")" : m2.n.type === "root" ? "markAsRoot(" + c(m2.contents) + ")" : "align(" + JSON.stringify(m2.n) + ", " + c(m2.contents) + ")";
      if (m2.type === "if-break")
        return "ifBreak(" + c(m2.breakContents) + (m2.flatContents ? ", " + c(m2.flatContents) : "") + (m2.groupId ? (m2.flatContents ? "" : ', ""') + ", { groupId: ".concat(y(m2.groupId), " }") : "") + ")";
      if (m2.type === "indent-if-break") {
        let f = [];
        m2.negate && f.push("negate: true"), m2.groupId && f.push("groupId: ".concat(y(m2.groupId)));
        let h2 = f.length > 0 ? ", { ".concat(f.join(", "), " }") : "";
        return "indentIfBreak(".concat(c(m2.contents)).concat(h2, ")");
      }
      if (m2.type === "group") {
        let f = [];
        m2.break && m2.break !== "propagated" && f.push("shouldBreak: true"), m2.id && f.push("id: ".concat(y(m2.id)));
        let h2 = f.length > 0 ? ", { ".concat(f.join(", "), " }") : "";
        return m2.expandedStates ? "conditionalGroup([".concat(m2.expandedStates.map((w2) => c(w2)).join(","), "]").concat(h2, ")") : "group(".concat(c(m2.contents)).concat(h2, ")");
      }
      if (m2.type === "fill")
        return "fill([".concat(m2.parts.map((f) => c(f)).join(", "), "])");
      if (m2.type === "line-suffix")
        return "lineSuffix(" + c(m2.contents) + ")";
      if (m2.type === "line-suffix-boundary")
        return "lineSuffixBoundary";
      if (m2.type === "label")
        return "label(".concat(JSON.stringify(m2.label), ", ").concat(c(m2.contents), ")");
      throw new Error("Unknown doc type " + m2.type);
    }
    function y(m2) {
      if (typeof m2 != "symbol")
        return JSON.stringify(String(m2));
      if (m2 in i2)
        return i2[m2];
      let d4 = String(m2).slice(7, -1) || "symbol";
      for (let p = 0; ; p++) {
        let f = d4 + (p > 0 ? " #".concat(p) : "");
        if (!o.has(f))
          return o.add(f), i2[m2] = "Symbol.for(".concat(JSON.stringify(f), ")");
      }
    }
  }
  n.exports = { printDocToDebug: r };
} }), Oe = Z({ "src/document/index.js"(e, n) {
  re(), n.exports = { builders: Pn(), printer: lD$1(), utils: In(), debug: cD$1() };
} }), ma = {};
Gt(ma, { default: () => pD$1 });
function pD$1(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
var fD$1 = mt$1({ "node_modules/escape-string-regexp/index.js"() {
  re();
} }), da = Z({ "node_modules/semver/internal/debug.js"(e, n) {
  re();
  var t = typeof bt$1 == "object" && bt$1.env && bt$1.env.NODE_DEBUG && /\bsemver\b/i.test(bt$1.env.NODE_DEBUG) ? function() {
    for (var s2 = arguments.length, a3 = new Array(s2), r = 0; r < s2; r++)
      a3[r] = arguments[r];
    return console.error("SEMVER", ...a3);
  } : () => {
  };
  n.exports = t;
} }), ga = Z({ "node_modules/semver/internal/constants.js"(e, n) {
  re();
  var t = "2.0.0", s2 = 256, a3 = Number.MAX_SAFE_INTEGER || 9007199254740991, r = 16;
  n.exports = { SEMVER_SPEC_VERSION: t, MAX_LENGTH: s2, MAX_SAFE_INTEGER: a3, MAX_SAFE_COMPONENT_LENGTH: r };
} }), DD$1 = Z({ "node_modules/semver/internal/re.js"(e, n) {
  re();
  var { MAX_SAFE_COMPONENT_LENGTH: t } = ga(), s2 = da();
  e = n.exports = {};
  var a3 = e.re = [], r = e.src = [], u = e.t = {}, i2 = 0, o = (c, y, m2) => {
    let d4 = i2++;
    s2(c, d4, y), u[c] = d4, r[d4] = y, a3[d4] = new RegExp(y, m2 ? "g" : void 0);
  };
  o("NUMERICIDENTIFIER", "0|[1-9]\\d*"), o("NUMERICIDENTIFIERLOOSE", "[0-9]+"), o("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), o("MAINVERSION", "(".concat(r[u.NUMERICIDENTIFIER], ")\\.(").concat(r[u.NUMERICIDENTIFIER], ")\\.(").concat(r[u.NUMERICIDENTIFIER], ")")), o("MAINVERSIONLOOSE", "(".concat(r[u.NUMERICIDENTIFIERLOOSE], ")\\.(").concat(r[u.NUMERICIDENTIFIERLOOSE], ")\\.(").concat(r[u.NUMERICIDENTIFIERLOOSE], ")")), o("PRERELEASEIDENTIFIER", "(?:".concat(r[u.NUMERICIDENTIFIER], "|").concat(r[u.NONNUMERICIDENTIFIER], ")")), o("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(r[u.NUMERICIDENTIFIERLOOSE], "|").concat(r[u.NONNUMERICIDENTIFIER], ")")), o("PRERELEASE", "(?:-(".concat(r[u.PRERELEASEIDENTIFIER], "(?:\\.").concat(r[u.PRERELEASEIDENTIFIER], ")*))")), o("PRERELEASELOOSE", "(?:-?(".concat(r[u.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(r[u.PRERELEASEIDENTIFIERLOOSE], ")*))")), o("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), o("BUILD", "(?:\\+(".concat(r[u.BUILDIDENTIFIER], "(?:\\.").concat(r[u.BUILDIDENTIFIER], ")*))")), o("FULLPLAIN", "v?".concat(r[u.MAINVERSION]).concat(r[u.PRERELEASE], "?").concat(r[u.BUILD], "?")), o("FULL", "^".concat(r[u.FULLPLAIN], "$")), o("LOOSEPLAIN", "[v=\\s]*".concat(r[u.MAINVERSIONLOOSE]).concat(r[u.PRERELEASELOOSE], "?").concat(r[u.BUILD], "?")), o("LOOSE", "^".concat(r[u.LOOSEPLAIN], "$")), o("GTLT", "((?:<|>)?=?)"), o("XRANGEIDENTIFIERLOOSE", "".concat(r[u.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), o("XRANGEIDENTIFIER", "".concat(r[u.NUMERICIDENTIFIER], "|x|X|\\*")), o("XRANGEPLAIN", "[v=\\s]*(".concat(r[u.XRANGEIDENTIFIER], ")(?:\\.(").concat(r[u.XRANGEIDENTIFIER], ")(?:\\.(").concat(r[u.XRANGEIDENTIFIER], ")(?:").concat(r[u.PRERELEASE], ")?").concat(r[u.BUILD], "?)?)?")), o("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(r[u.XRANGEIDENTIFIERLOOSE], ")(?:\\.(").concat(r[u.XRANGEIDENTIFIERLOOSE], ")(?:\\.(").concat(r[u.XRANGEIDENTIFIERLOOSE], ")(?:").concat(r[u.PRERELEASELOOSE], ")?").concat(r[u.BUILD], "?)?)?")), o("XRANGE", "^".concat(r[u.GTLT], "\\s*").concat(r[u.XRANGEPLAIN], "$")), o("XRANGELOOSE", "^".concat(r[u.GTLT], "\\s*").concat(r[u.XRANGEPLAINLOOSE], "$")), o("COERCE", "(^|[^\\d])(\\d{1,".concat(t, "})(?:\\.(\\d{1,").concat(t, "}))?(?:\\.(\\d{1,").concat(t, "}))?(?:$|[^\\d])")), o("COERCERTL", r[u.COERCE], true), o("LONETILDE", "(?:~>?)"), o("TILDETRIM", "(\\s*)".concat(r[u.LONETILDE], "\\s+"), true), e.tildeTrimReplace = "$1~", o("TILDE", "^".concat(r[u.LONETILDE]).concat(r[u.XRANGEPLAIN], "$")), o("TILDELOOSE", "^".concat(r[u.LONETILDE]).concat(r[u.XRANGEPLAINLOOSE], "$")), o("LONECARET", "(?:\\^)"), o("CARETTRIM", "(\\s*)".concat(r[u.LONECARET], "\\s+"), true), e.caretTrimReplace = "$1^", o("CARET", "^".concat(r[u.LONECARET]).concat(r[u.XRANGEPLAIN], "$")), o("CARETLOOSE", "^".concat(r[u.LONECARET]).concat(r[u.XRANGEPLAINLOOSE], "$")), o("COMPARATORLOOSE", "^".concat(r[u.GTLT], "\\s*(").concat(r[u.LOOSEPLAIN], ")$|^$")), o("COMPARATOR", "^".concat(r[u.GTLT], "\\s*(").concat(r[u.FULLPLAIN], ")$|^$")), o("COMPARATORTRIM", "(\\s*)".concat(r[u.GTLT], "\\s*(").concat(r[u.LOOSEPLAIN], "|").concat(r[u.XRANGEPLAIN], ")"), true), e.comparatorTrimReplace = "$1$2$3", o("HYPHENRANGE", "^\\s*(".concat(r[u.XRANGEPLAIN], ")\\s+-\\s+(").concat(r[u.XRANGEPLAIN], ")\\s*$")), o("HYPHENRANGELOOSE", "^\\s*(".concat(r[u.XRANGEPLAINLOOSE], ")\\s+-\\s+(").concat(r[u.XRANGEPLAINLOOSE], ")\\s*$")), o("STAR", "(<|>)?=?\\s*\\*"), o("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), o("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
} }), mD$1 = Z({ "node_modules/semver/internal/parse-options.js"(e, n) {
  re();
  var t = ["includePrerelease", "loose", "rtl"], s2 = (a3) => a3 ? typeof a3 != "object" ? { loose: true } : t.filter((r) => a3[r]).reduce((r, u) => (r[u] = true, r), {}) : {};
  n.exports = s2;
} }), dD$1 = Z({ "node_modules/semver/internal/identifiers.js"(e, n) {
  re();
  var t = /^[0-9]+$/, s2 = (r, u) => {
    let i2 = t.test(r), o = t.test(u);
    return i2 && o && (r = +r, u = +u), r === u ? 0 : i2 && !o ? -1 : o && !i2 ? 1 : r < u ? -1 : 1;
  }, a3 = (r, u) => s2(u, r);
  n.exports = { compareIdentifiers: s2, rcompareIdentifiers: a3 };
} }), gD$1 = Z({ "node_modules/semver/classes/semver.js"(e, n) {
  re();
  var t = da(), { MAX_LENGTH: s2, MAX_SAFE_INTEGER: a3 } = ga(), { re: r, t: u } = DD$1(), i2 = mD$1(), { compareIdentifiers: o } = dD$1(), c = class {
    constructor(y, m2) {
      if (m2 = i2(m2), y instanceof c) {
        if (y.loose === !!m2.loose && y.includePrerelease === !!m2.includePrerelease)
          return y;
        y = y.version;
      } else if (typeof y != "string")
        throw new TypeError("Invalid Version: ".concat(y));
      if (y.length > s2)
        throw new TypeError("version is longer than ".concat(s2, " characters"));
      t("SemVer", y, m2), this.options = m2, this.loose = !!m2.loose, this.includePrerelease = !!m2.includePrerelease;
      let d4 = y.trim().match(m2.loose ? r[u.LOOSE] : r[u.FULL]);
      if (!d4)
        throw new TypeError("Invalid Version: ".concat(y));
      if (this.raw = y, this.major = +d4[1], this.minor = +d4[2], this.patch = +d4[3], this.major > a3 || this.major < 0)
        throw new TypeError("Invalid major version");
      if (this.minor > a3 || this.minor < 0)
        throw new TypeError("Invalid minor version");
      if (this.patch > a3 || this.patch < 0)
        throw new TypeError("Invalid patch version");
      d4[4] ? this.prerelease = d4[4].split(".").map((p) => {
        if (/^[0-9]+$/.test(p)) {
          let f = +p;
          if (f >= 0 && f < a3)
            return f;
        }
        return p;
      }) : this.prerelease = [], this.build = d4[5] ? d4[5].split(".") : [], this.format();
    }
    format() {
      return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version;
    }
    toString() {
      return this.version;
    }
    compare(y) {
      if (t("SemVer.compare", this.version, this.options, y), !(y instanceof c)) {
        if (typeof y == "string" && y === this.version)
          return 0;
        y = new c(y, this.options);
      }
      return y.version === this.version ? 0 : this.compareMain(y) || this.comparePre(y);
    }
    compareMain(y) {
      return y instanceof c || (y = new c(y, this.options)), o(this.major, y.major) || o(this.minor, y.minor) || o(this.patch, y.patch);
    }
    comparePre(y) {
      if (y instanceof c || (y = new c(y, this.options)), this.prerelease.length && !y.prerelease.length)
        return -1;
      if (!this.prerelease.length && y.prerelease.length)
        return 1;
      if (!this.prerelease.length && !y.prerelease.length)
        return 0;
      let m2 = 0;
      do {
        let d4 = this.prerelease[m2], p = y.prerelease[m2];
        if (t("prerelease compare", m2, d4, p), d4 === void 0 && p === void 0)
          return 0;
        if (p === void 0)
          return 1;
        if (d4 === void 0)
          return -1;
        if (d4 === p)
          continue;
        return o(d4, p);
      } while (++m2);
    }
    compareBuild(y) {
      y instanceof c || (y = new c(y, this.options));
      let m2 = 0;
      do {
        let d4 = this.build[m2], p = y.build[m2];
        if (t("prerelease compare", m2, d4, p), d4 === void 0 && p === void 0)
          return 0;
        if (p === void 0)
          return 1;
        if (d4 === void 0)
          return -1;
        if (d4 === p)
          continue;
        return o(d4, p);
      } while (++m2);
    }
    inc(y, m2) {
      switch (y) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", m2);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", m2);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", m2), this.inc("pre", m2);
          break;
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", m2), this.inc("pre", m2);
          break;
        case "major":
          (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0)
            this.prerelease = [0];
          else {
            let d4 = this.prerelease.length;
            for (; --d4 >= 0; )
              typeof this.prerelease[d4] == "number" && (this.prerelease[d4]++, d4 = -2);
            d4 === -1 && this.prerelease.push(0);
          }
          m2 && (o(this.prerelease[0], m2) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [m2, 0]) : this.prerelease = [m2, 0]);
          break;
        default:
          throw new Error("invalid increment argument: ".concat(y));
      }
      return this.format(), this.raw = this.version, this;
    }
  };
  n.exports = c;
} }), Ln$1 = Z({ "node_modules/semver/functions/compare.js"(e, n) {
  re();
  var t = gD$1(), s2 = (a3, r, u) => new t(a3, u).compare(new t(r, u));
  n.exports = s2;
} }), yD$1 = Z({ "node_modules/semver/functions/lt.js"(e, n) {
  re();
  var t = Ln$1(), s2 = (a3, r, u) => t(a3, r, u) < 0;
  n.exports = s2;
} }), hD$1 = Z({ "node_modules/semver/functions/gte.js"(e, n) {
  re();
  var t = Ln$1(), s2 = (a3, r, u) => t(a3, r, u) >= 0;
  n.exports = s2;
} }), vD$1 = Z({ "src/utils/arrayify.js"(e, n) {
  re(), n.exports = (t, s2) => Object.entries(t).map((a3) => {
    let [r, u] = a3;
    return Object.assign({ [s2]: r }, u);
  });
} }), CD$1 = Z({ "node_modules/outdent/lib/index.js"(e, n) {
  re(), Object.defineProperty(e, "__esModule", { value: true }), e.outdent = void 0;
  function t() {
    for (var A2 = [], S2 = 0; S2 < arguments.length; S2++)
      A2[S2] = arguments[S2];
  }
  function s2() {
    return typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : a3();
  }
  function a3() {
    return { add: t, delete: t, get: t, set: t, has: function(A2) {
      return false;
    } };
  }
  var r = Object.prototype.hasOwnProperty, u = function(A2, S2) {
    return r.call(A2, S2);
  };
  function i2(A2, S2) {
    for (var B in S2)
      u(S2, B) && (A2[B] = S2[B]);
    return A2;
  }
  var o = /^[ \t]*(?:\r\n|\r|\n)/, c = /(?:\r\n|\r|\n)[ \t]*$/, y = /^(?:[\r\n]|$)/, m2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, d4 = /^[ \t]*[\r\n][ \t\r\n]*$/;
  function p(A2, S2, B) {
    var I2 = 0, k2 = A2[0].match(m2);
    k2 && (I2 = k2[1].length);
    var P = "(\\r\\n|\\r|\\n).{0," + I2 + "}", C2 = new RegExp(P, "g");
    S2 && (A2 = A2.slice(1));
    var D2 = B.newline, g2 = B.trimLeadingNewline, F = B.trimTrailingNewline, l = typeof D2 == "string", E = A2.length, v = A2.map(function(N, x2) {
      return N = N.replace(C2, "$1"), x2 === 0 && g2 && (N = N.replace(o, "")), x2 === E - 1 && F && (N = N.replace(c, "")), l && (N = N.replace(/\r\n|\n|\r/g, function(b2) {
        return D2;
      })), N;
    });
    return v;
  }
  function f(A2, S2) {
    for (var B = "", I2 = 0, k2 = A2.length; I2 < k2; I2++)
      B += A2[I2], I2 < k2 - 1 && (B += S2[I2]);
    return B;
  }
  function h2(A2) {
    return u(A2, "raw") && u(A2, "length");
  }
  function w2(A2) {
    var S2 = s2(), B = s2();
    function I2(P) {
      for (var C2 = [], D2 = 1; D2 < arguments.length; D2++)
        C2[D2 - 1] = arguments[D2];
      if (h2(P)) {
        var g2 = P, F = (C2[0] === I2 || C2[0] === T2) && d4.test(g2[0]) && y.test(g2[1]), l = F ? B : S2, E = l.get(g2);
        if (E || (E = p(g2, F, A2), l.set(g2, E)), C2.length === 0)
          return E[0];
        var v = f(E, F ? C2.slice(1) : C2);
        return v;
      } else
        return w2(i2(i2({}, A2), P || {}));
    }
    var k2 = i2(I2, { string: function(P) {
      return p([P], false, A2)[0];
    } });
    return k2;
  }
  var T2 = w2({ trimLeadingNewline: true, trimTrailingNewline: true });
  if (e.outdent = T2, e.default = T2, typeof n < "u")
    try {
      n.exports = T2, Object.defineProperty(T2, "__esModule", { value: true }), T2.default = T2, T2.outdent = T2;
    } catch {
    }
} }), ED$1 = Z({ "src/main/core-options.js"(e, n) {
  re();
  var { outdent: t } = CD$1(), s2 = "Config", a3 = "Editor", r = "Format", u = "Other", i2 = "Output", o = "Global", c = "Special", y = { cursorOffset: { since: "1.4.0", category: c, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: t(Qi$1 || (Qi$1 = _t$1([`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `]))), cliCategory: a3 }, endOfLine: { since: "1.15.0", category: o, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: t(Zi$1 || (Zi$1 = _t$1([`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `]))) }] }, filepath: { since: "1.4.0", category: c, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: u, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: c, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: u }, parser: { since: "0.0.10", category: o, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (m2) => typeof m2 == "string" || typeof m2 == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "acorn", since: "2.6.0", description: "JavaScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: o, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (m2) => typeof m2 == "string" || typeof m2 == "object", cliName: "plugin", cliCategory: s2 }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: o, description: t(ea || (ea = _t$1([`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `]))), exception: (m2) => typeof m2 == "string" || typeof m2 == "object", cliName: "plugin-search-dir", cliCategory: s2 }, printWidth: { since: "0.0.0", category: o, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: c, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t(ta || (ta = _t$1([`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `]))), cliCategory: a3 }, rangeStart: { since: "1.4.0", category: c, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t(ra || (ra = _t$1([`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `]))), cliCategory: a3 }, requirePragma: { since: "1.7.0", category: c, type: "boolean", default: false, description: t(na$1 || (na$1 = _t$1([`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `]))), cliCategory: u }, tabWidth: { type: "int", category: o, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: o, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: o, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
  n.exports = { CATEGORY_CONFIG: s2, CATEGORY_EDITOR: a3, CATEGORY_FORMAT: r, CATEGORY_OTHER: u, CATEGORY_OUTPUT: i2, CATEGORY_GLOBAL: o, CATEGORY_SPECIAL: c, options: y };
} }), jn$2 = Z({ "src/main/support.js"(e, n) {
  re();
  var t = { compare: Ln$1(), lt: yD$1(), gte: hD$1() }, s2 = vD$1(), a3 = ca$1().version, r = ED$1().options;
  function u() {
    let { plugins: o = [], showUnreleased: c = false, showDeprecated: y = false, showInternal: m2 = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, d4 = a3.split("-", 1)[0], p = o.flatMap((A2) => A2.languages || []).filter(h2), f = s2(Object.assign({}, ...o.map((A2) => {
      let { options: S2 } = A2;
      return S2;
    }), r), "name").filter((A2) => h2(A2) && w2(A2)).sort((A2, S2) => A2.name === S2.name ? 0 : A2.name < S2.name ? -1 : 1).map(T2).map((A2) => {
      A2 = Object.assign({}, A2), Array.isArray(A2.default) && (A2.default = A2.default.length === 1 ? A2.default[0].value : A2.default.filter(h2).sort((B, I2) => t.compare(I2.since, B.since))[0].value), Array.isArray(A2.choices) && (A2.choices = A2.choices.filter((B) => h2(B) && w2(B)), A2.name === "parser" && i2(A2, p, o));
      let S2 = Object.fromEntries(o.filter((B) => B.defaultOptions && B.defaultOptions[A2.name] !== void 0).map((B) => [B.name, B.defaultOptions[A2.name]]));
      return Object.assign(Object.assign({}, A2), {}, { pluginDefaults: S2 });
    });
    return { languages: p, options: f };
    function h2(A2) {
      return c || !("since" in A2) || A2.since && t.gte(d4, A2.since);
    }
    function w2(A2) {
      return y || !("deprecated" in A2) || A2.deprecated && t.lt(d4, A2.deprecated);
    }
    function T2(A2) {
      if (m2)
        return A2;
      return wn$1(A2, $f);
    }
  }
  function i2(o, c, y) {
    let m2 = new Set(o.choices.map((d4) => d4.value));
    for (let d4 of c)
      if (d4.parsers) {
        for (let p of d4.parsers)
          if (!m2.has(p)) {
            m2.add(p);
            let f = y.find((w2) => w2.parsers && w2.parsers[p]), h2 = d4.name;
            f && f.name && (h2 += " (plugin: ".concat(f.name, ")")), o.choices.push({ value: p, description: h2 });
          }
      }
  }
  n.exports = { getSupportInfo: u };
} }), On$3 = Z({ "src/utils/is-non-empty-array.js"(e, n) {
  re();
  function t(s2) {
    return Array.isArray(s2) && s2.length > 0;
  }
  n.exports = t;
} }), Tr = Z({ "src/utils/text/skip.js"(e, n) {
  re();
  function t(i2) {
    return (o, c, y) => {
      let m2 = y && y.backwards;
      if (c === false)
        return false;
      let { length: d4 } = o, p = c;
      for (; p >= 0 && p < d4; ) {
        let f = o.charAt(p);
        if (i2 instanceof RegExp) {
          if (!i2.test(f))
            return p;
        } else if (!i2.includes(f))
          return p;
        m2 ? p-- : p++;
      }
      return p === -1 || p === d4 ? p : false;
    };
  }
  var s2 = t(/\s/), a3 = t(" 	"), r = t(",; 	"), u = t(/[^\n\r]/);
  n.exports = { skipWhitespace: s2, skipSpaces: a3, skipToLineEnd: r, skipEverythingButNewLine: u };
} }), ya = Z({ "src/utils/text/skip-inline-comment.js"(e, n) {
  re();
  function t(s2, a3) {
    if (a3 === false)
      return false;
    if (s2.charAt(a3) === "/" && s2.charAt(a3 + 1) === "*") {
      for (let r = a3 + 2; r < s2.length; ++r)
        if (s2.charAt(r) === "*" && s2.charAt(r + 1) === "/")
          return r + 2;
    }
    return a3;
  }
  n.exports = t;
} }), ha = Z({ "src/utils/text/skip-trailing-comment.js"(e, n) {
  re();
  var { skipEverythingButNewLine: t } = Tr();
  function s2(a3, r) {
    return r === false ? false : a3.charAt(r) === "/" && a3.charAt(r + 1) === "/" ? t(a3, r) : r;
  }
  n.exports = s2;
} }), va = Z({ "src/utils/text/skip-newline.js"(e, n) {
  re();
  function t(s2, a3, r) {
    let u = r && r.backwards;
    if (a3 === false)
      return false;
    let i2 = s2.charAt(a3);
    if (u) {
      if (s2.charAt(a3 - 1) === "\r" && i2 === `
`)
        return a3 - 2;
      if (i2 === `
` || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
        return a3 - 1;
    } else {
      if (i2 === "\r" && s2.charAt(a3 + 1) === `
`)
        return a3 + 2;
      if (i2 === `
` || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
        return a3 + 1;
    }
    return a3;
  }
  n.exports = t;
} }), FD$1 = Z({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e, n) {
  re();
  var t = ya(), s2 = va(), a3 = ha(), { skipSpaces: r } = Tr();
  function u(i2, o) {
    let c = null, y = o;
    for (; y !== c; )
      c = y, y = r(i2, y), y = t(i2, y), y = a3(i2, y), y = s2(i2, y);
    return y;
  }
  n.exports = u;
} }), Ue$2 = Z({ "src/common/util.js"(e, n) {
  re();
  var { default: t } = (fD$1(), lt$1(ma)), s2 = it$2(), { getSupportInfo: a3 } = jn$2(), r = On$3(), u = Da(), { skipWhitespace: i2, skipSpaces: o, skipToLineEnd: c, skipEverythingButNewLine: y } = Tr(), m2 = ya(), d4 = ha(), p = va(), f = FD$1(), h2 = (H3) => H3[H3.length - 2];
  function w2(H3) {
    return (R, Q, ee2) => {
      let te2 = ee2 && ee2.backwards;
      if (Q === false)
        return false;
      let { length: oe2 } = R, W2 = Q;
      for (; W2 >= 0 && W2 < oe2; ) {
        let X3 = R.charAt(W2);
        if (H3 instanceof RegExp) {
          if (!H3.test(X3))
            return W2;
        } else if (!H3.includes(X3))
          return W2;
        te2 ? W2-- : W2++;
      }
      return W2 === -1 || W2 === oe2 ? W2 : false;
    };
  }
  function T2(H3, R) {
    let Q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, ee2 = o(H3, Q.backwards ? R - 1 : R, Q), te2 = p(H3, ee2, Q);
    return ee2 !== te2;
  }
  function A2(H3, R, Q) {
    for (let ee2 = R; ee2 < Q; ++ee2)
      if (H3.charAt(ee2) === `
`)
        return true;
    return false;
  }
  function S2(H3, R, Q) {
    let ee2 = Q(R) - 1;
    ee2 = o(H3, ee2, { backwards: true }), ee2 = p(H3, ee2, { backwards: true }), ee2 = o(H3, ee2, { backwards: true });
    let te2 = p(H3, ee2, { backwards: true });
    return ee2 !== te2;
  }
  function B(H3, R) {
    let Q = null, ee2 = R;
    for (; ee2 !== Q; )
      Q = ee2, ee2 = c(H3, ee2), ee2 = m2(H3, ee2), ee2 = o(H3, ee2);
    return ee2 = d4(H3, ee2), ee2 = p(H3, ee2), ee2 !== false && T2(H3, ee2);
  }
  function I2(H3, R, Q) {
    return B(H3, Q(R));
  }
  function k2(H3, R, Q) {
    return f(H3, Q(R));
  }
  function P(H3, R, Q) {
    return H3.charAt(k2(H3, R, Q));
  }
  function C2(H3, R) {
    let Q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return o(H3, Q.backwards ? R - 1 : R, Q) !== R;
  }
  function D2(H3, R) {
    let Q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, ee2 = 0;
    for (let te2 = Q; te2 < H3.length; ++te2)
      H3[te2] === "	" ? ee2 = ee2 + R - ee2 % R : ee2++;
    return ee2;
  }
  function g2(H3, R) {
    let Q = H3.lastIndexOf(`
`);
    return Q === -1 ? 0 : D2(H3.slice(Q + 1).match(/^[\t ]*/)[0], R);
  }
  function F(H3, R) {
    let Q = { quote: '"', regex: /"/g, escaped: "&quot;" }, ee2 = { quote: "'", regex: /'/g, escaped: "&apos;" }, te2 = R === "'" ? ee2 : Q, oe2 = te2 === ee2 ? Q : ee2, W2 = te2;
    if (H3.includes(te2.quote) || H3.includes(oe2.quote)) {
      let X3 = (H3.match(te2.regex) || []).length, ue2 = (H3.match(oe2.regex) || []).length;
      W2 = X3 > ue2 ? oe2 : te2;
    }
    return W2;
  }
  function l(H3, R) {
    let Q = H3.slice(1, -1), ee2 = R.parser === "json" || R.parser === "json5" && R.quoteProps === "preserve" && !R.singleQuote ? '"' : R.__isInHtmlAttribute ? "'" : F(Q, R.singleQuote ? "'" : '"').quote;
    return E(Q, ee2, !(R.parser === "css" || R.parser === "less" || R.parser === "scss" || R.__embeddedInHtml));
  }
  function E(H3, R, Q) {
    let ee2 = R === '"' ? "'" : '"', te2 = /\\(.)|(["'])/gs, oe2 = H3.replace(te2, (W2, X3, ue2) => X3 === ee2 ? X3 : ue2 === R ? "\\" + ue2 : ue2 || (Q && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(X3) ? X3 : "\\" + X3));
    return R + oe2 + R;
  }
  function v(H3) {
    return H3.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
  }
  function N(H3, R) {
    let Q = H3.match(new RegExp("(".concat(t(R), ")+"), "g"));
    return Q === null ? 0 : Q.reduce((ee2, te2) => Math.max(ee2, te2.length / R.length), 0);
  }
  function x2(H3, R) {
    let Q = H3.match(new RegExp("(".concat(t(R), ")+"), "g"));
    if (Q === null)
      return 0;
    let ee2 = /* @__PURE__ */ new Map(), te2 = 0;
    for (let oe2 of Q) {
      let W2 = oe2.length / R.length;
      ee2.set(W2, true), W2 > te2 && (te2 = W2);
    }
    for (let oe2 = 1; oe2 < te2; oe2++)
      if (!ee2.get(oe2))
        return oe2;
    return te2 + 1;
  }
  function b2(H3, R) {
    (H3.comments || (H3.comments = [])).push(R), R.printed = false, R.nodeDescription = Y3(H3);
  }
  function L(H3, R) {
    R.leading = true, R.trailing = false, b2(H3, R);
  }
  function M2(H3, R, Q) {
    R.leading = false, R.trailing = false, Q && (R.marker = Q), b2(H3, R);
  }
  function j(H3, R) {
    R.leading = false, R.trailing = true, b2(H3, R);
  }
  function $(H3, R) {
    let { languages: Q } = a3({ plugins: R.plugins }), ee2 = Q.find((te2) => {
      let { name: oe2 } = te2;
      return oe2.toLowerCase() === H3;
    }) || Q.find((te2) => {
      let { aliases: oe2 } = te2;
      return Array.isArray(oe2) && oe2.includes(H3);
    }) || Q.find((te2) => {
      let { extensions: oe2 } = te2;
      return Array.isArray(oe2) && oe2.includes(".".concat(H3));
    });
    return ee2 && ee2.parsers[0];
  }
  function V(H3) {
    return H3 && H3.type === "front-matter";
  }
  function q(H3) {
    let R = /* @__PURE__ */ new WeakMap();
    return function(Q) {
      return R.has(Q) || R.set(Q, Symbol(H3)), R.get(Q);
    };
  }
  function Y3(H3) {
    let R = H3.type || H3.kind || "(unknown type)", Q = String(H3.name || H3.id && (typeof H3.id == "object" ? H3.id.name : H3.id) || H3.key && (typeof H3.key == "object" ? H3.key.name : H3.key) || H3.value && (typeof H3.value == "object" ? "" : String(H3.value)) || H3.operator || "");
    return Q.length > 20 && (Q = Q.slice(0, 19) + "\u2026"), R + (Q ? " " + Q : "");
  }
  n.exports = { inferParserByLanguage: $, getStringWidth: u, getMaxContinuousCount: N, getMinNotPresentContinuousCount: x2, getPenultimate: h2, getLast: s2, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: f, getNextNonSpaceNonCommentCharacterIndex: k2, getNextNonSpaceNonCommentCharacter: P, skip: w2, skipWhitespace: i2, skipSpaces: o, skipToLineEnd: c, skipEverythingButNewLine: y, skipInlineComment: m2, skipTrailingComment: d4, skipNewline: p, isNextLineEmptyAfterIndex: B, isNextLineEmpty: I2, isPreviousLineEmpty: S2, hasNewline: T2, hasNewlineInRange: A2, hasSpaces: C2, getAlignmentSize: D2, getIndentSize: g2, getPreferredQuote: F, printString: l, printNumber: v, makeString: E, addLeadingComment: L, addDanglingComment: M2, addTrailingComment: j, isFrontMatterNode: V, isNonEmptyArray: r, createGroupIdMapper: q };
} }), Ca = {};
Gt(Ca, { basename: () => xa, default: () => Ta, delimiter: () => xn$1, dirname: () => Sa, extname: () => ba$1, isAbsolute: () => Mn$1, join: () => Fa, normalize: () => qn$1, relative: () => Aa, resolve: () => xr$1, sep: () => Sn });
function Ea(e, n) {
  for (var t = 0, s2 = e.length - 1; s2 >= 0; s2--) {
    var a3 = e[s2];
    a3 === "." ? e.splice(s2, 1) : a3 === ".." ? (e.splice(s2, 1), t++) : t && (e.splice(s2, 1), t--);
  }
  if (n)
    for (; t--; t)
      e.unshift("..");
  return e;
}
function xr$1() {
  for (var e = "", n = false, t = arguments.length - 1; t >= -1 && !n; t--) {
    var s2 = t >= 0 ? arguments[t] : "/";
    if (typeof s2 != "string")
      throw new TypeError("Arguments to path.resolve must be strings");
    if (!s2)
      continue;
    e = s2 + "/" + e, n = s2.charAt(0) === "/";
  }
  return e = Ea(Rn$1(e.split("/"), function(a3) {
    return !!a3;
  }), !n).join("/"), (n ? "/" : "") + e || ".";
}
function qn$1(e) {
  var n = Mn$1(e), t = Ba(e, -1) === "/";
  return e = Ea(Rn$1(e.split("/"), function(s2) {
    return !!s2;
  }), !n).join("/"), !e && !n && (e = "."), e && t && (e += "/"), (n ? "/" : "") + e;
}
function Mn$1(e) {
  return e.charAt(0) === "/";
}
function Fa() {
  var e = Array.prototype.slice.call(arguments, 0);
  return qn$1(Rn$1(e, function(n, t) {
    if (typeof n != "string")
      throw new TypeError("Arguments to path.join must be strings");
    return n;
  }).join("/"));
}
function Aa(e, n) {
  e = xr$1(e).substr(1), n = xr$1(n).substr(1);
  function t(c) {
    for (var y = 0; y < c.length && c[y] === ""; y++)
      ;
    for (var m2 = c.length - 1; m2 >= 0 && c[m2] === ""; m2--)
      ;
    return y > m2 ? [] : c.slice(y, m2 - y + 1);
  }
  for (var s2 = t(e.split("/")), a3 = t(n.split("/")), r = Math.min(s2.length, a3.length), u = r, i2 = 0; i2 < r; i2++)
    if (s2[i2] !== a3[i2]) {
      u = i2;
      break;
    }
  for (var o = [], i2 = u; i2 < s2.length; i2++)
    o.push("..");
  return o = o.concat(a3.slice(u)), o.join("/");
}
function Sa(e) {
  var n = Br(e), t = n[0], s2 = n[1];
  return !t && !s2 ? "." : (s2 && (s2 = s2.substr(0, s2.length - 1)), t + s2);
}
function xa(e, n) {
  var t = Br(e)[2];
  return n && t.substr(-1 * n.length) === n && (t = t.substr(0, t.length - n.length)), t;
}
function ba$1(e) {
  return Br(e)[3];
}
function Rn$1(e, n) {
  if (e.filter)
    return e.filter(n);
  for (var t = [], s2 = 0; s2 < e.length; s2++)
    n(e[s2], s2, e) && t.push(e[s2]);
  return t;
}
var ia, Br, Sn, xn$1, Ta, Ba, AD$1 = mt$1({ "node-modules-polyfills:path"() {
  re(), ia = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, Br = function(e) {
    return ia.exec(e).slice(1);
  }, Sn = "/", xn$1 = ":", Ta = { extname: ba$1, basename: xa, dirname: Sa, sep: Sn, delimiter: xn$1, relative: Aa, join: Fa, isAbsolute: Mn$1, normalize: qn$1, resolve: xr$1 }, Ba = "ab".substr(-1) === "b" ? function(e, n, t) {
    return e.substr(n, t);
  } : function(e, n, t) {
    return n < 0 && (n = e.length + n), e.substr(n, t);
  };
} }), SD$1 = Z({ "node-modules-polyfills-commonjs:path"(e, n) {
  re();
  var t = (AD$1(), lt$1(Ca));
  if (t && t.default) {
    n.exports = t.default;
    for (let s2 in t)
      n.exports[s2] = t[s2];
  } else
    t && (n.exports = t);
} }), Jt$1 = Z({ "src/common/errors.js"(e, n) {
  re();
  var t = class extends Error {
  }, s2 = class extends Error {
  }, a3 = class extends Error {
  }, r = class extends Error {
  };
  n.exports = { ConfigError: t, DebugError: s2, UndefinedParserError: a3, ArgExpansionBailout: r };
} }), dt$1 = {};
Gt(dt$1, { __assign: () => Sr$2, __asyncDelegator: () => OD$1, __asyncGenerator: () => jD, __asyncValues: () => qD$1, __await: () => Ht, __awaiter: () => wD$1, __classPrivateFieldGet: () => WD, __classPrivateFieldSet: () => $D, __createBinding: () => PD$1, __decorate: () => TD$1, __exportStar: () => kD$1, __extends: () => xD$1, __generator: () => _D$1, __importDefault: () => VD, __importStar: () => RD$1, __makeTemplateObject: () => MD$1, __metadata: () => ND$1, __param: () => BD$1, __read: () => Na, __rest: () => bD$1, __spread: () => ID$1, __spreadArrays: () => LD$1, __values: () => bn$2 });
function xD$1(e, n) {
  Ar$1(e, n);
  function t() {
    this.constructor = e;
  }
  e.prototype = n === null ? Object.create(n) : (t.prototype = n.prototype, new t());
}
function bD$1(e, n) {
  var t = {};
  for (var s2 in e)
    Object.prototype.hasOwnProperty.call(e, s2) && n.indexOf(s2) < 0 && (t[s2] = e[s2]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a3 = 0, s2 = Object.getOwnPropertySymbols(e); a3 < s2.length; a3++)
      n.indexOf(s2[a3]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s2[a3]) && (t[s2[a3]] = e[s2[a3]]);
  return t;
}
function TD$1(e, n, t, s2) {
  var a3 = arguments.length, r = a3 < 3 ? n : s2 === null ? s2 = Object.getOwnPropertyDescriptor(n, t) : s2, u;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(e, n, t, s2);
  else
    for (var i2 = e.length - 1; i2 >= 0; i2--)
      (u = e[i2]) && (r = (a3 < 3 ? u(r) : a3 > 3 ? u(n, t, r) : u(n, t)) || r);
  return a3 > 3 && r && Object.defineProperty(n, t, r), r;
}
function BD$1(e, n) {
  return function(t, s2) {
    n(t, s2, e);
  };
}
function ND$1(e, n) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(e, n);
}
function wD$1(e, n, t, s2) {
  function a3(r) {
    return r instanceof t ? r : new t(function(u) {
      u(r);
    });
  }
  return new (t || (t = Promise))(function(r, u) {
    function i2(y) {
      try {
        c(s2.next(y));
      } catch (m2) {
        u(m2);
      }
    }
    function o(y) {
      try {
        c(s2.throw(y));
      } catch (m2) {
        u(m2);
      }
    }
    function c(y) {
      y.done ? r(y.value) : a3(y.value).then(i2, o);
    }
    c((s2 = s2.apply(e, n || [])).next());
  });
}
function _D$1(e, n) {
  var t = { label: 0, sent: function() {
    if (r[0] & 1)
      throw r[1];
    return r[1];
  }, trys: [], ops: [] }, s2, a3, r, u;
  return u = { next: i2(0), throw: i2(1), return: i2(2) }, typeof Symbol == "function" && (u[Symbol.iterator] = function() {
    return this;
  }), u;
  function i2(c) {
    return function(y) {
      return o([c, y]);
    };
  }
  function o(c) {
    if (s2)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (s2 = 1, a3 && (r = c[0] & 2 ? a3.return : c[0] ? a3.throw || ((r = a3.return) && r.call(a3), 0) : a3.next) && !(r = r.call(a3, c[1])).done)
          return r;
        switch (a3 = 0, r && (c = [c[0] & 2, r.value]), c[0]) {
          case 0:
          case 1:
            r = c;
            break;
          case 4:
            return t.label++, { value: c[1], done: false };
          case 5:
            t.label++, a3 = c[1], c = [0];
            continue;
          case 7:
            c = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (r = t.trys, !(r = r.length > 0 && r[r.length - 1]) && (c[0] === 6 || c[0] === 2)) {
              t = 0;
              continue;
            }
            if (c[0] === 3 && (!r || c[1] > r[0] && c[1] < r[3])) {
              t.label = c[1];
              break;
            }
            if (c[0] === 6 && t.label < r[1]) {
              t.label = r[1], r = c;
              break;
            }
            if (r && t.label < r[2]) {
              t.label = r[2], t.ops.push(c);
              break;
            }
            r[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        c = n.call(e, t);
      } catch (y) {
        c = [6, y], a3 = 0;
      } finally {
        s2 = r = 0;
      }
    if (c[0] & 5)
      throw c[1];
    return { value: c[0] ? c[1] : void 0, done: true };
  }
}
function PD$1(e, n, t, s2) {
  s2 === void 0 && (s2 = t), e[s2] = n[t];
}
function kD$1(e, n) {
  for (var t in e)
    t !== "default" && !n.hasOwnProperty(t) && (n[t] = e[t]);
}
function bn$2(e) {
  var n = typeof Symbol == "function" && Symbol.iterator, t = n && e[n], s2 = 0;
  if (t)
    return t.call(e);
  if (e && typeof e.length == "number")
    return { next: function() {
      return e && s2 >= e.length && (e = void 0), { value: e && e[s2++], done: !e };
    } };
  throw new TypeError(n ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Na(e, n) {
  var t = typeof Symbol == "function" && e[Symbol.iterator];
  if (!t)
    return e;
  var s2 = t.call(e), a3, r = [], u;
  try {
    for (; (n === void 0 || n-- > 0) && !(a3 = s2.next()).done; )
      r.push(a3.value);
  } catch (i2) {
    u = { error: i2 };
  } finally {
    try {
      a3 && !a3.done && (t = s2.return) && t.call(s2);
    } finally {
      if (u)
        throw u.error;
    }
  }
  return r;
}
function ID$1() {
  for (var e = [], n = 0; n < arguments.length; n++)
    e = e.concat(Na(arguments[n]));
  return e;
}
function LD$1() {
  for (var e = 0, n = 0, t = arguments.length; n < t; n++)
    e += arguments[n].length;
  for (var s2 = Array(e), a3 = 0, n = 0; n < t; n++)
    for (var r = arguments[n], u = 0, i2 = r.length; u < i2; u++, a3++)
      s2[a3] = r[u];
  return s2;
}
function Ht(e) {
  return this instanceof Ht ? (this.v = e, this) : new Ht(e);
}
function jD(e, n, t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var s2 = t.apply(e, n || []), a3, r = [];
  return a3 = {}, u("next"), u("throw"), u("return"), a3[Symbol.asyncIterator] = function() {
    return this;
  }, a3;
  function u(d4) {
    s2[d4] && (a3[d4] = function(p) {
      return new Promise(function(f, h2) {
        r.push([d4, p, f, h2]) > 1 || i2(d4, p);
      });
    });
  }
  function i2(d4, p) {
    try {
      o(s2[d4](p));
    } catch (f) {
      m2(r[0][3], f);
    }
  }
  function o(d4) {
    d4.value instanceof Ht ? Promise.resolve(d4.value.v).then(c, y) : m2(r[0][2], d4);
  }
  function c(d4) {
    i2("next", d4);
  }
  function y(d4) {
    i2("throw", d4);
  }
  function m2(d4, p) {
    d4(p), r.shift(), r.length && i2(r[0][0], r[0][1]);
  }
}
function OD$1(e) {
  var n, t;
  return n = {}, s2("next"), s2("throw", function(a3) {
    throw a3;
  }), s2("return"), n[Symbol.iterator] = function() {
    return this;
  }, n;
  function s2(a3, r) {
    n[a3] = e[a3] ? function(u) {
      return (t = !t) ? { value: Ht(e[a3](u)), done: a3 === "return" } : r ? r(u) : u;
    } : r;
  }
}
function qD$1(e) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = e[Symbol.asyncIterator], t;
  return n ? n.call(e) : (e = typeof bn$2 == "function" ? bn$2(e) : e[Symbol.iterator](), t = {}, s2("next"), s2("throw"), s2("return"), t[Symbol.asyncIterator] = function() {
    return this;
  }, t);
  function s2(r) {
    t[r] = e[r] && function(u) {
      return new Promise(function(i2, o) {
        u = e[r](u), a3(i2, o, u.done, u.value);
      });
    };
  }
  function a3(r, u, i2, o) {
    Promise.resolve(o).then(function(c) {
      r({ value: c, done: i2 });
    }, u);
  }
}
function MD$1(e, n) {
  return Object.defineProperty ? Object.defineProperty(e, "raw", { value: n }) : e.raw = n, e;
}
function RD$1(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var t in e)
      Object.hasOwnProperty.call(e, t) && (n[t] = e[t]);
  return n.default = e, n;
}
function VD(e) {
  return e && e.__esModule ? e : { default: e };
}
function WD(e, n) {
  if (!n.has(e))
    throw new TypeError("attempted to get private field on non-instance");
  return n.get(e);
}
function $D(e, n, t) {
  if (!n.has(e))
    throw new TypeError("attempted to set private field on non-instance");
  return n.set(e, t), t;
}
var Ar$1, Sr$2, ht$2 = mt$1({ "node_modules/tslib/tslib.es6.js"() {
  re(), Ar$1 = function(e, n) {
    return Ar$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, s2) {
      t.__proto__ = s2;
    } || function(t, s2) {
      for (var a3 in s2)
        s2.hasOwnProperty(a3) && (t[a3] = s2[a3]);
    }, Ar$1(e, n);
  }, Sr$2 = function() {
    return Sr$2 = Object.assign || function(n) {
      for (var t, s2 = 1, a3 = arguments.length; s2 < a3; s2++) {
        t = arguments[s2];
        for (var r in t)
          Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n;
    }, Sr$2.apply(this, arguments);
  };
} }), wa = Z({ "node_modules/vnopts/lib/descriptors/api.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true }), e.apiDescriptor = { key: (n) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(n) ? n : JSON.stringify(n), value(n) {
    if (n === null || typeof n != "object")
      return JSON.stringify(n);
    if (Array.isArray(n))
      return "[".concat(n.map((s2) => e.apiDescriptor.value(s2)).join(", "), "]");
    let t = Object.keys(n);
    return t.length === 0 ? "{}" : "{ ".concat(t.map((s2) => "".concat(e.apiDescriptor.key(s2), ": ").concat(e.apiDescriptor.value(n[s2]))).join(", "), " }");
  }, pair: (n) => {
    let { key: t, value: s2 } = n;
    return e.apiDescriptor.value({ [t]: s2 });
  } };
} }), HD = Z({ "node_modules/vnopts/lib/descriptors/index.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true });
  var n = (ht$2(), lt$1(dt$1));
  n.__exportStar(wa(), e);
} }), Nr$1 = Z({ "scripts/build/shims/chalk.cjs"(e, n) {
  re();
  var t = (s2) => s2;
  t.grey = t, t.red = t, t.bold = t, t.yellow = t, t.blue = t, t.default = t, n.exports = t;
} }), _a$1 = Z({ "node_modules/vnopts/lib/handlers/deprecated/common.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true });
  var n = Nr$1();
  e.commonDeprecatedHandler = (t, s2, a3) => {
    let { descriptor: r } = a3, u = ["".concat(n.default.yellow(typeof t == "string" ? r.key(t) : r.pair(t)), " is deprecated")];
    return s2 && u.push("we now treat it as ".concat(n.default.blue(typeof s2 == "string" ? r.key(s2) : r.pair(s2)))), u.join("; ") + ".";
  };
} }), GD = Z({ "node_modules/vnopts/lib/handlers/deprecated/index.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true });
  var n = (ht$2(), lt$1(dt$1));
  n.__exportStar(_a$1(), e);
} }), JD = Z({ "node_modules/vnopts/lib/handlers/invalid/common.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true });
  var n = Nr$1();
  e.commonInvalidHandler = (t, s2, a3) => ["Invalid ".concat(n.default.red(a3.descriptor.key(t)), " value."), "Expected ".concat(n.default.blue(a3.schemas[t].expected(a3)), ","), "but received ".concat(n.default.red(a3.descriptor.value(s2)), ".")].join(" ");
} }), Pa$1 = Z({ "node_modules/vnopts/lib/handlers/invalid/index.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true });
  var n = (ht$2(), lt$1(dt$1));
  n.__exportStar(JD(), e);
} }), UD = Z({ "node_modules/vnopts/node_modules/leven/index.js"(e, n) {
  re();
  var t = [], s2 = [];
  n.exports = function(a3, r) {
    if (a3 === r)
      return 0;
    var u = a3;
    a3.length > r.length && (a3 = r, r = u);
    var i2 = a3.length, o = r.length;
    if (i2 === 0)
      return o;
    if (o === 0)
      return i2;
    for (; i2 > 0 && a3.charCodeAt(~-i2) === r.charCodeAt(~-o); )
      i2--, o--;
    if (i2 === 0)
      return o;
    for (var c = 0; c < i2 && a3.charCodeAt(c) === r.charCodeAt(c); )
      c++;
    if (i2 -= c, o -= c, i2 === 0)
      return o;
    for (var y, m2, d4, p, f = 0, h2 = 0; f < i2; )
      s2[c + f] = a3.charCodeAt(c + f), t[f] = ++f;
    for (; h2 < o; )
      for (y = r.charCodeAt(c + h2), d4 = h2++, m2 = h2, f = 0; f < i2; f++)
        p = y === s2[c + f] ? d4 : d4 + 1, d4 = t[f], m2 = t[f] = d4 > m2 ? p > m2 ? m2 + 1 : p : p > d4 ? d4 + 1 : p;
    return m2;
  };
} }), ka$1 = Z({ "node_modules/vnopts/lib/handlers/unknown/leven.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true });
  var n = Nr$1(), t = UD();
  e.levenUnknownHandler = (s2, a3, r) => {
    let { descriptor: u, logger: i2, schemas: o } = r, c = ["Ignored unknown option ".concat(n.default.yellow(u.pair({ key: s2, value: a3 })), ".")], y = Object.keys(o).sort().find((m2) => t(s2, m2) < 3);
    y && c.push("Did you mean ".concat(n.default.blue(u.key(y)), "?")), i2.warn(c.join(" "));
  };
} }), zD = Z({ "node_modules/vnopts/lib/handlers/unknown/index.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true });
  var n = (ht$2(), lt$1(dt$1));
  n.__exportStar(ka$1(), e);
} }), XD = Z({ "node_modules/vnopts/lib/handlers/index.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true });
  var n = (ht$2(), lt$1(dt$1));
  n.__exportStar(GD(), e), n.__exportStar(Pa$1(), e), n.__exportStar(zD(), e);
} }), vt$1 = Z({ "node_modules/vnopts/lib/schema.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true });
  var n = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
  function t(r, u) {
    let i2 = new r(u), o = Object.create(i2);
    for (let c of n)
      c in u && (o[c] = a3(u[c], i2, s2.prototype[c].length));
    return o;
  }
  e.createSchema = t;
  var s2 = class {
    constructor(r) {
      this.name = r.name;
    }
    static create(r) {
      return t(this, r);
    }
    default(r) {
    }
    expected(r) {
      return "nothing";
    }
    validate(r, u) {
      return false;
    }
    deprecated(r, u) {
      return false;
    }
    forward(r, u) {
    }
    redirect(r, u) {
    }
    overlap(r, u, i2) {
      return r;
    }
    preprocess(r, u) {
      return r;
    }
    postprocess(r, u) {
      return r;
    }
  };
  e.Schema = s2;
  function a3(r, u, i2) {
    return typeof r == "function" ? function() {
      for (var o = arguments.length, c = new Array(o), y = 0; y < o; y++)
        c[y] = arguments[y];
      return r(...c.slice(0, i2 - 1), u, ...c.slice(i2 - 1));
    } : () => r;
  }
} }), KD = Z({ "node_modules/vnopts/lib/schemas/alias.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true });
  var n = vt$1(), t = class extends n.Schema {
    constructor(s2) {
      super(s2), this._sourceName = s2.sourceName;
    }
    expected(s2) {
      return s2.schemas[this._sourceName].expected(s2);
    }
    validate(s2, a3) {
      return a3.schemas[this._sourceName].validate(s2, a3);
    }
    redirect(s2, a3) {
      return this._sourceName;
    }
  };
  e.AliasSchema = t;
} }), YD = Z({ "node_modules/vnopts/lib/schemas/any.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true });
  var n = vt$1(), t = class extends n.Schema {
    expected() {
      return "anything";
    }
    validate() {
      return true;
    }
  };
  e.AnySchema = t;
} }), QD = Z({ "node_modules/vnopts/lib/schemas/array.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true });
  var n = (ht$2(), lt$1(dt$1)), t = vt$1(), s2 = class extends t.Schema {
    constructor(r) {
      var { valueSchema: u, name: i2 = u.name } = r, o = n.__rest(r, ["valueSchema", "name"]);
      super(Object.assign({}, o, { name: i2 })), this._valueSchema = u;
    }
    expected(r) {
      return "an array of ".concat(this._valueSchema.expected(r));
    }
    validate(r, u) {
      if (!Array.isArray(r))
        return false;
      let i2 = [];
      for (let o of r) {
        let c = u.normalizeValidateResult(this._valueSchema.validate(o, u), o);
        c !== true && i2.push(c.value);
      }
      return i2.length === 0 ? true : { value: i2 };
    }
    deprecated(r, u) {
      let i2 = [];
      for (let o of r) {
        let c = u.normalizeDeprecatedResult(this._valueSchema.deprecated(o, u), o);
        c !== false && i2.push(...c.map((y) => {
          let { value: m2 } = y;
          return { value: [m2] };
        }));
      }
      return i2;
    }
    forward(r, u) {
      let i2 = [];
      for (let o of r) {
        let c = u.normalizeForwardResult(this._valueSchema.forward(o, u), o);
        i2.push(...c.map(a3));
      }
      return i2;
    }
    redirect(r, u) {
      let i2 = [], o = [];
      for (let c of r) {
        let y = u.normalizeRedirectResult(this._valueSchema.redirect(c, u), c);
        "remain" in y && i2.push(y.remain), o.push(...y.redirect.map(a3));
      }
      return i2.length === 0 ? { redirect: o } : { redirect: o, remain: i2 };
    }
    overlap(r, u) {
      return r.concat(u);
    }
  };
  e.ArraySchema = s2;
  function a3(r) {
    let { from: u, to: i2 } = r;
    return { from: [u], to: i2 };
  }
} }), ZD = Z({ "node_modules/vnopts/lib/schemas/boolean.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true });
  var n = vt$1(), t = class extends n.Schema {
    expected() {
      return "true or false";
    }
    validate(s2) {
      return typeof s2 == "boolean";
    }
  };
  e.BooleanSchema = t;
} }), Vn$1 = Z({ "node_modules/vnopts/lib/utils.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true });
  function n(p, f) {
    let h2 = /* @__PURE__ */ Object.create(null);
    for (let w2 of p) {
      let T2 = w2[f];
      if (h2[T2])
        throw new Error("Duplicate ".concat(f, " ").concat(JSON.stringify(T2)));
      h2[T2] = w2;
    }
    return h2;
  }
  e.recordFromArray = n;
  function t(p, f) {
    let h2 = /* @__PURE__ */ new Map();
    for (let w2 of p) {
      let T2 = w2[f];
      if (h2.has(T2))
        throw new Error("Duplicate ".concat(f, " ").concat(JSON.stringify(T2)));
      h2.set(T2, w2);
    }
    return h2;
  }
  e.mapFromArray = t;
  function s2() {
    let p = /* @__PURE__ */ Object.create(null);
    return (f) => {
      let h2 = JSON.stringify(f);
      return p[h2] ? true : (p[h2] = true, false);
    };
  }
  e.createAutoChecklist = s2;
  function a3(p, f) {
    let h2 = [], w2 = [];
    for (let T2 of p)
      f(T2) ? h2.push(T2) : w2.push(T2);
    return [h2, w2];
  }
  e.partition = a3;
  function r(p) {
    return p === Math.floor(p);
  }
  e.isInt = r;
  function u(p, f) {
    if (p === f)
      return 0;
    let h2 = typeof p, w2 = typeof f, T2 = ["undefined", "object", "boolean", "number", "string"];
    return h2 !== w2 ? T2.indexOf(h2) - T2.indexOf(w2) : h2 !== "string" ? Number(p) - Number(f) : p.localeCompare(f);
  }
  e.comparePrimitive = u;
  function i2(p) {
    return p === void 0 ? {} : p;
  }
  e.normalizeDefaultResult = i2;
  function o(p, f) {
    return p === true ? true : p === false ? { value: f } : p;
  }
  e.normalizeValidateResult = o;
  function c(p, f) {
    let h2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    return p === false ? false : p === true ? h2 ? true : [{ value: f }] : "value" in p ? [p] : p.length === 0 ? false : p;
  }
  e.normalizeDeprecatedResult = c;
  function y(p, f) {
    return typeof p == "string" || "key" in p ? { from: f, to: p } : "from" in p ? { from: p.from, to: p.to } : { from: f, to: p.to };
  }
  e.normalizeTransferResult = y;
  function m2(p, f) {
    return p === void 0 ? [] : Array.isArray(p) ? p.map((h2) => y(h2, f)) : [y(p, f)];
  }
  e.normalizeForwardResult = m2;
  function d4(p, f) {
    let h2 = m2(typeof p == "object" && "redirect" in p ? p.redirect : p, f);
    return h2.length === 0 ? { remain: f, redirect: h2 } : typeof p == "object" && "remain" in p ? { remain: p.remain, redirect: h2 } : { redirect: h2 };
  }
  e.normalizeRedirectResult = d4;
} }), em = Z({ "node_modules/vnopts/lib/schemas/choice.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true });
  var n = vt$1(), t = Vn$1(), s2 = class extends n.Schema {
    constructor(a3) {
      super(a3), this._choices = t.mapFromArray(a3.choices.map((r) => r && typeof r == "object" ? r : { value: r }), "value");
    }
    expected(a3) {
      let { descriptor: r } = a3, u = Array.from(this._choices.keys()).map((c) => this._choices.get(c)).filter((c) => !c.deprecated).map((c) => c.value).sort(t.comparePrimitive).map(r.value), i2 = u.slice(0, -2), o = u.slice(-2);
      return i2.concat(o.join(" or ")).join(", ");
    }
    validate(a3) {
      return this._choices.has(a3);
    }
    deprecated(a3) {
      let r = this._choices.get(a3);
      return r && r.deprecated ? { value: a3 } : false;
    }
    forward(a3) {
      let r = this._choices.get(a3);
      return r ? r.forward : void 0;
    }
    redirect(a3) {
      let r = this._choices.get(a3);
      return r ? r.redirect : void 0;
    }
  };
  e.ChoiceSchema = s2;
} }), Ia = Z({ "node_modules/vnopts/lib/schemas/number.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true });
  var n = vt$1(), t = class extends n.Schema {
    expected() {
      return "a number";
    }
    validate(s2, a3) {
      return typeof s2 == "number";
    }
  };
  e.NumberSchema = t;
} }), tm = Z({ "node_modules/vnopts/lib/schemas/integer.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true });
  var n = Vn$1(), t = Ia(), s2 = class extends t.NumberSchema {
    expected() {
      return "an integer";
    }
    validate(a3, r) {
      return r.normalizeValidateResult(super.validate(a3, r), a3) === true && n.isInt(a3);
    }
  };
  e.IntegerSchema = s2;
} }), rm = Z({ "node_modules/vnopts/lib/schemas/string.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true });
  var n = vt$1(), t = class extends n.Schema {
    expected() {
      return "a string";
    }
    validate(s2) {
      return typeof s2 == "string";
    }
  };
  e.StringSchema = t;
} }), nm = Z({ "node_modules/vnopts/lib/schemas/index.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true });
  var n = (ht$2(), lt$1(dt$1));
  n.__exportStar(KD(), e), n.__exportStar(YD(), e), n.__exportStar(QD(), e), n.__exportStar(ZD(), e), n.__exportStar(em(), e), n.__exportStar(tm(), e), n.__exportStar(Ia(), e), n.__exportStar(rm(), e);
} }), um = Z({ "node_modules/vnopts/lib/defaults.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true });
  var n = wa(), t = _a$1(), s2 = Pa$1(), a3 = ka$1();
  e.defaultDescriptor = n.apiDescriptor, e.defaultUnknownHandler = a3.levenUnknownHandler, e.defaultInvalidHandler = s2.commonInvalidHandler, e.defaultDeprecatedHandler = t.commonDeprecatedHandler;
} }), sm = Z({ "node_modules/vnopts/lib/normalize.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true });
  var n = um(), t = Vn$1();
  e.normalize = (a3, r, u) => new s2(r, u).normalize(a3);
  var s2 = class {
    constructor(a3, r) {
      let { logger: u = console, descriptor: i2 = n.defaultDescriptor, unknown: o = n.defaultUnknownHandler, invalid: c = n.defaultInvalidHandler, deprecated: y = n.defaultDeprecatedHandler } = r || {};
      this._utils = { descriptor: i2, logger: u || { warn: () => {
      } }, schemas: t.recordFromArray(a3, "name"), normalizeDefaultResult: t.normalizeDefaultResult, normalizeDeprecatedResult: t.normalizeDeprecatedResult, normalizeForwardResult: t.normalizeForwardResult, normalizeRedirectResult: t.normalizeRedirectResult, normalizeValidateResult: t.normalizeValidateResult }, this._unknownHandler = o, this._invalidHandler = c, this._deprecatedHandler = y, this.cleanHistory();
    }
    cleanHistory() {
      this._hasDeprecationWarned = t.createAutoChecklist();
    }
    normalize(a3) {
      let r = {}, u = [a3], i2 = () => {
        for (; u.length !== 0; ) {
          let o = u.shift(), c = this._applyNormalization(o, r);
          u.push(...c);
        }
      };
      i2();
      for (let o of Object.keys(this._utils.schemas)) {
        let c = this._utils.schemas[o];
        if (!(o in r)) {
          let y = t.normalizeDefaultResult(c.default(this._utils));
          "value" in y && u.push({ [o]: y.value });
        }
      }
      i2();
      for (let o of Object.keys(this._utils.schemas)) {
        let c = this._utils.schemas[o];
        o in r && (r[o] = c.postprocess(r[o], this._utils));
      }
      return r;
    }
    _applyNormalization(a3, r) {
      let u = [], [i2, o] = t.partition(Object.keys(a3), (c) => c in this._utils.schemas);
      for (let c of i2) {
        let y = this._utils.schemas[c], m2 = y.preprocess(a3[c], this._utils), d4 = t.normalizeValidateResult(y.validate(m2, this._utils), m2);
        if (d4 !== true) {
          let { value: T2 } = d4, A2 = this._invalidHandler(c, T2, this._utils);
          throw typeof A2 == "string" ? new Error(A2) : A2;
        }
        let p = (T2) => {
          let { from: A2, to: S2 } = T2;
          u.push(typeof S2 == "string" ? { [S2]: A2 } : { [S2.key]: S2.value });
        }, f = (T2) => {
          let { value: A2, redirectTo: S2 } = T2, B = t.normalizeDeprecatedResult(y.deprecated(A2, this._utils), m2, true);
          if (B !== false)
            if (B === true)
              this._hasDeprecationWarned(c) || this._utils.logger.warn(this._deprecatedHandler(c, S2, this._utils));
            else
              for (let { value: I2 } of B) {
                let k2 = { key: c, value: I2 };
                if (!this._hasDeprecationWarned(k2)) {
                  let P = typeof S2 == "string" ? { key: S2, value: I2 } : S2;
                  this._utils.logger.warn(this._deprecatedHandler(k2, P, this._utils));
                }
              }
        };
        t.normalizeForwardResult(y.forward(m2, this._utils), m2).forEach(p);
        let w2 = t.normalizeRedirectResult(y.redirect(m2, this._utils), m2);
        if (w2.redirect.forEach(p), "remain" in w2) {
          let T2 = w2.remain;
          r[c] = c in r ? y.overlap(r[c], T2, this._utils) : T2, f({ value: T2 });
        }
        for (let { from: T2, to: A2 } of w2.redirect)
          f({ value: T2, redirectTo: A2 });
      }
      for (let c of o) {
        let y = a3[c], m2 = this._unknownHandler(c, y, this._utils);
        if (m2)
          for (let d4 of Object.keys(m2)) {
            let p = { [d4]: m2[d4] };
            d4 in this._utils.schemas ? u.push(p) : Object.assign(r, p);
          }
      }
      return u;
    }
  };
  e.Normalizer = s2;
} }), im = Z({ "node_modules/vnopts/lib/index.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true });
  var n = (ht$2(), lt$1(dt$1));
  n.__exportStar(HD(), e), n.__exportStar(XD(), e), n.__exportStar(nm(), e), n.__exportStar(sm(), e), n.__exportStar(vt$1(), e);
} }), am = Z({ "src/main/options-normalizer.js"(e, n) {
  re();
  var t = im(), s2 = it$2(), a3 = { key: (d4) => d4.length === 1 ? "-".concat(d4) : "--".concat(d4), value: (d4) => t.apiDescriptor.value(d4), pair: (d4) => {
    let { key: p, value: f } = d4;
    return f === false ? "--no-".concat(p) : f === true ? a3.key(p) : f === "" ? "".concat(a3.key(p), " without an argument") : "".concat(a3.key(p), "=").concat(f);
  } }, r = (d4) => {
    let { colorsModule: p, levenshteinDistance: f } = d4;
    return class extends t.ChoiceSchema {
      constructor(w2) {
        let { name: T2, flags: A2 } = w2;
        super({ name: T2, choices: A2 }), this._flags = [...A2].sort();
      }
      preprocess(w2, T2) {
        if (typeof w2 == "string" && w2.length > 0 && !this._flags.includes(w2)) {
          let A2 = this._flags.find((S2) => f(S2, w2) < 3);
          if (A2)
            return T2.logger.warn(["Unknown flag ".concat(p.yellow(T2.descriptor.value(w2)), ","), "did you mean ".concat(p.blue(T2.descriptor.value(A2)), "?")].join(" ")), A2;
        }
        return w2;
      }
      expected() {
        return "a flag";
      }
    };
  }, u;
  function i2(d4, p) {
    let { logger: f = false, isCLI: h2 = false, passThrough: w2 = false, colorsModule: T2 = null, levenshteinDistance: A2 = null } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, S2 = w2 ? Array.isArray(w2) ? (D2, g2) => w2.includes(D2) ? { [D2]: g2 } : void 0 : (D2, g2) => ({ [D2]: g2 }) : (D2, g2, F) => {
      let l = F.schemas, v = wn$1(l, Hf);
      return t.levenUnknownHandler(D2, g2, Object.assign(Object.assign({}, F), {}, { schemas: v }));
    }, B = h2 ? a3 : t.apiDescriptor, I2 = o(p, { isCLI: h2, colorsModule: T2, levenshteinDistance: A2 }), k2 = new t.Normalizer(I2, { logger: f, unknown: S2, descriptor: B }), P = f !== false;
    P && u && (k2._hasDeprecationWarned = u);
    let C2 = k2.normalize(d4);
    return P && (u = k2._hasDeprecationWarned), h2 && C2["plugin-search"] === false && (C2["plugin-search-dir"] = false), C2;
  }
  function o(d4, p) {
    let { isCLI: f, colorsModule: h2, levenshteinDistance: w2 } = p, T2 = [];
    f && T2.push(t.AnySchema.create({ name: "_" }));
    for (let A2 of d4)
      T2.push(c(A2, { isCLI: f, optionInfos: d4, colorsModule: h2, levenshteinDistance: w2 })), A2.alias && f && T2.push(t.AliasSchema.create({ name: A2.alias, sourceName: A2.name }));
    return T2;
  }
  function c(d4, p) {
    let { isCLI: f, optionInfos: h2, colorsModule: w2, levenshteinDistance: T2 } = p, { name: A2 } = d4;
    if (A2 === "plugin-search-dir" || A2 === "pluginSearchDirs")
      return t.AnySchema.create({ name: A2, preprocess(k2) {
        return k2 === false || (k2 = Array.isArray(k2) ? k2 : [k2]), k2;
      }, validate(k2) {
        return k2 === false ? true : k2.every((P) => typeof P == "string");
      }, expected() {
        return "false or paths to plugin search dir";
      } });
    let S2 = { name: A2 }, B, I2 = {};
    switch (d4.type) {
      case "int":
        B = t.IntegerSchema, f && (S2.preprocess = Number);
        break;
      case "string":
        B = t.StringSchema;
        break;
      case "choice":
        B = t.ChoiceSchema, S2.choices = d4.choices.map((k2) => typeof k2 == "object" && k2.redirect ? Object.assign(Object.assign({}, k2), {}, { redirect: { to: { key: d4.name, value: k2.redirect } } }) : k2);
        break;
      case "boolean":
        B = t.BooleanSchema;
        break;
      case "flag":
        B = r({ colorsModule: w2, levenshteinDistance: T2 }), S2.flags = h2.flatMap((k2) => [k2.alias, k2.description && k2.name, k2.oppositeDescription && "no-".concat(k2.name)].filter(Boolean));
        break;
      case "path":
        B = t.StringSchema;
        break;
      default:
        throw new Error("Unexpected type ".concat(d4.type));
    }
    if (d4.exception ? S2.validate = (k2, P, C2) => d4.exception(k2) || P.validate(k2, C2) : S2.validate = (k2, P, C2) => k2 === void 0 || P.validate(k2, C2), d4.redirect && (I2.redirect = (k2) => k2 ? { to: { key: d4.redirect.option, value: d4.redirect.value } } : void 0), d4.deprecated && (I2.deprecated = true), f && !d4.array) {
      let k2 = S2.preprocess || ((P) => P);
      S2.preprocess = (P, C2, D2) => C2.preprocess(k2(Array.isArray(P) ? s2(P) : P), D2);
    }
    return d4.array ? t.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, f ? { preprocess: (k2) => Array.isArray(k2) ? k2 : [k2] } : {}), I2), {}, { valueSchema: B.create(S2) })) : B.create(Object.assign(Object.assign({}, S2), I2));
  }
  function y(d4, p, f) {
    return i2(d4, p, f);
  }
  function m2(d4, p, f) {
    return i2(d4, p, Object.assign({ isCLI: true }, f));
  }
  n.exports = { normalizeApiOptions: y, normalizeCliOptions: m2 };
} }), st$1 = Z({ "src/language-js/loc.js"(e, n) {
  re();
  var t = On$3();
  function s2(o, c) {
    let { ignoreDecorators: y } = c || {};
    if (!y) {
      let m2 = o.declaration && o.declaration.decorators || o.decorators;
      if (t(m2))
        return s2(m2[0]);
    }
    return o.range ? o.range[0] : o.start;
  }
  function a3(o) {
    return o.range ? o.range[1] : o.end;
  }
  function r(o, c) {
    let y = s2(o);
    return Number.isInteger(y) && y === s2(c);
  }
  function u(o, c) {
    let y = a3(o);
    return Number.isInteger(y) && y === a3(c);
  }
  function i2(o, c) {
    return r(o, c) && u(o, c);
  }
  n.exports = { locStart: s2, locEnd: a3, hasSameLocStart: r, hasSameLoc: i2 };
} }), om = Z({ "src/main/load-parser.js"(e, n) {
  re(), n.exports = () => {
  };
} }), lm = Z({ "scripts/build/shims/babel-highlight.cjs"(e, n) {
  re();
  var t = Nr$1(), s2 = { shouldHighlight: () => false, getChalk: () => t };
  n.exports = s2;
} }), cm = Z({ "node_modules/@babel/code-frame/lib/index.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true }), e.codeFrameColumns = u, e.default = i2;
  var n = lm(), t = false;
  function s2(o) {
    return { gutter: o.grey, marker: o.red.bold, message: o.red.bold };
  }
  var a3 = /\r\n|[\n\r\u2028\u2029]/;
  function r(o, c, y) {
    let m2 = Object.assign({ column: 0, line: -1 }, o.start), d4 = Object.assign({}, m2, o.end), { linesAbove: p = 2, linesBelow: f = 3 } = y || {}, h2 = m2.line, w2 = m2.column, T2 = d4.line, A2 = d4.column, S2 = Math.max(h2 - (p + 1), 0), B = Math.min(c.length, T2 + f);
    h2 === -1 && (S2 = 0), T2 === -1 && (B = c.length);
    let I2 = T2 - h2, k2 = {};
    if (I2)
      for (let P = 0; P <= I2; P++) {
        let C2 = P + h2;
        if (!w2)
          k2[C2] = true;
        else if (P === 0) {
          let D2 = c[C2 - 1].length;
          k2[C2] = [w2, D2 - w2 + 1];
        } else if (P === I2)
          k2[C2] = [0, A2];
        else {
          let D2 = c[C2 - P].length;
          k2[C2] = [0, D2];
        }
      }
    else
      w2 === A2 ? w2 ? k2[h2] = [w2, 0] : k2[h2] = true : k2[h2] = [w2, A2 - w2];
    return { start: S2, end: B, markerLines: k2 };
  }
  function u(o, c) {
    let y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, m2 = (y.highlightCode || y.forceColor) && (0, n.shouldHighlight)(y), d4 = (0, n.getChalk)(y), p = s2(d4), f = (P, C2) => m2 ? P(C2) : C2, h2 = o.split(a3), { start: w2, end: T2, markerLines: A2 } = r(c, h2, y), S2 = c.start && typeof c.start.column == "number", B = String(T2).length, k2 = (m2 ? (0, n.default)(o, y) : o).split(a3, T2).slice(w2, T2).map((P, C2) => {
      let D2 = w2 + 1 + C2, g2 = " ".concat(D2).slice(-B), F = " ".concat(g2, " |"), l = A2[D2], E = !A2[D2 + 1];
      if (l) {
        let v = "";
        if (Array.isArray(l)) {
          let N = P.slice(0, Math.max(l[0] - 1, 0)).replace(/[^\t]/g, " "), x2 = l[1] || 1;
          v = [`
 `, f(p.gutter, F.replace(/\d/g, " ")), " ", N, f(p.marker, "^").repeat(x2)].join(""), E && y.message && (v += " " + f(p.message, y.message));
        }
        return [f(p.marker, ">"), f(p.gutter, F), P.length > 0 ? " ".concat(P) : "", v].join("");
      } else
        return " ".concat(f(p.gutter, F)).concat(P.length > 0 ? " ".concat(P) : "");
    }).join(`
`);
    return y.message && !S2 && (k2 = "".concat(" ".repeat(B + 1)).concat(y.message, `
`).concat(k2)), m2 ? d4.reset(k2) : k2;
  }
  function i2(o, c, y) {
    let m2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (!t) {
      t = true;
      let p = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (bt$1.emitWarning)
        bt$1.emitWarning(p, "DeprecationWarning");
      else {
        let f = new Error(p);
        f.name = "DeprecationWarning", console.warn(new Error(p));
      }
    }
    return y = Math.max(y, 0), u(o, { start: { column: y, line: c } }, m2);
  }
} }), Wn$3 = Z({ "src/main/parser.js"(e, n) {
  re();
  var { ConfigError: t } = Jt$1(), s2 = st$1();
  om();
  var { locStart: r, locEnd: u } = s2, i2 = Object.getOwnPropertyNames, o = Object.getOwnPropertyDescriptor;
  function c(d4) {
    let p = {};
    for (let f of d4.plugins)
      if (!!f.parsers)
        for (let h2 of i2(f.parsers))
          Object.defineProperty(p, h2, o(f.parsers, h2));
    return p;
  }
  function y(d4) {
    let p = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : c(d4);
    if (typeof d4.parser == "function")
      return { parse: d4.parser, astFormat: "estree", locStart: r, locEnd: u };
    if (typeof d4.parser == "string") {
      if (Object.prototype.hasOwnProperty.call(p, d4.parser))
        return p[d4.parser];
      throw new t(`Couldn't resolve parser "`.concat(d4.parser, '". Parsers must be explicitly added to the standalone bundle.'));
    }
  }
  function m2(d4, p) {
    let f = c(p), h2 = Object.defineProperties({}, Object.fromEntries(Object.keys(f).map((T2) => [T2, { enumerable: true, get() {
      return f[T2].parse;
    } }]))), w2 = y(p, f);
    try {
      return w2.preprocess && (d4 = w2.preprocess(d4, p)), { text: d4, ast: w2.parse(d4, h2, p) };
    } catch (T2) {
      let { loc: A2 } = T2;
      if (A2) {
        let { codeFrameColumns: S2 } = cm();
        throw T2.codeFrame = S2(d4, A2, { highlightCode: true }), T2.message += `
` + T2.codeFrame, T2;
      }
      throw T2.stack;
    }
  }
  n.exports = { parse: m2, resolveParser: y };
} }), La$1 = Z({ "src/main/options.js"(e, n) {
  re();
  var t = SD$1(), { UndefinedParserError: s2 } = Jt$1(), { getSupportInfo: a3 } = jn$2(), r = am(), { resolveParser: u } = Wn$3(), i2 = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
  function o(m2) {
    let d4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, p = Object.assign({}, m2), f = a3({ plugins: m2.plugins, showUnreleased: true, showDeprecated: true }).options, h2 = Object.assign(Object.assign({}, i2), Object.fromEntries(f.filter((B) => B.default !== void 0).map((B) => [B.name, B.default])));
    if (!p.parser) {
      if (!p.filepath)
        (d4.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), p.parser = "babel";
      else if (p.parser = y(p.filepath, p.plugins), !p.parser)
        throw new s2("No parser could be inferred for file: ".concat(p.filepath));
    }
    let w2 = u(r.normalizeApiOptions(p, [f.find((B) => B.name === "parser")], { passThrough: true, logger: false }));
    p.astFormat = w2.astFormat, p.locEnd = w2.locEnd, p.locStart = w2.locStart;
    let T2 = c(p);
    p.printer = T2.printers[p.astFormat];
    let A2 = Object.fromEntries(f.filter((B) => B.pluginDefaults && B.pluginDefaults[T2.name] !== void 0).map((B) => [B.name, B.pluginDefaults[T2.name]])), S2 = Object.assign(Object.assign({}, h2), A2);
    for (let [B, I2] of Object.entries(S2))
      (p[B] === null || p[B] === void 0) && (p[B] = I2);
    return p.parser === "json" && (p.trailingComma = "none"), r.normalizeApiOptions(p, f, Object.assign({ passThrough: Object.keys(i2) }, d4));
  }
  function c(m2) {
    let { astFormat: d4 } = m2;
    if (!d4)
      throw new Error("getPlugin() requires astFormat to be set");
    let p = m2.plugins.find((f) => f.printers && f.printers[d4]);
    if (!p)
      throw new Error(`Couldn't find plugin for AST format "`.concat(d4, '"'));
    return p;
  }
  function y(m2, d4) {
    let p = t.basename(m2).toLowerCase(), h2 = a3({ plugins: d4 }).languages.filter((w2) => w2.since !== null).find((w2) => w2.extensions && w2.extensions.some((T2) => p.endsWith(T2)) || w2.filenames && w2.filenames.some((T2) => T2.toLowerCase() === p));
    return h2 && h2.parsers[0];
  }
  n.exports = { normalize: o, hiddenDefaults: i2, inferParser: y };
} }), pm = Z({ "src/main/massage-ast.js"(e, n) {
  re();
  function t(s2, a3, r) {
    if (Array.isArray(s2))
      return s2.map((c) => t(c, a3, r)).filter(Boolean);
    if (!s2 || typeof s2 != "object")
      return s2;
    let u = a3.printer.massageAstNode, i2;
    u && u.ignoredProperties ? i2 = u.ignoredProperties : i2 = /* @__PURE__ */ new Set();
    let o = {};
    for (let [c, y] of Object.entries(s2))
      !i2.has(c) && typeof y != "function" && (o[c] = t(y, a3, s2));
    if (u) {
      let c = u(s2, o, r);
      if (c === null)
        return;
      if (c)
        return c;
    }
    return o;
  }
  n.exports = t;
} }), Ut$1 = Z({ "scripts/build/shims/assert.cjs"(e, n) {
  re();
  var t = () => {
  };
  t.ok = t, t.strictEqual = t, n.exports = t;
} }), et = Z({ "src/main/comments.js"(e, n) {
  re();
  var t = Ut$1(), { builders: { line: s2, hardline: a3, breakParent: r, indent: u, lineSuffix: i2, join: o, cursor: c } } = Oe(), { hasNewline: y, skipNewline: m2, skipSpaces: d4, isPreviousLineEmpty: p, addLeadingComment: f, addDanglingComment: h2, addTrailingComment: w2 } = Ue$2(), T2 = /* @__PURE__ */ new WeakMap();
  function A2(L, M2, j) {
    if (!L)
      return;
    let { printer: $, locStart: V, locEnd: q } = M2;
    if (j) {
      if ($.canAttachComment && $.canAttachComment(L)) {
        let H3;
        for (H3 = j.length - 1; H3 >= 0 && !(V(j[H3]) <= V(L) && q(j[H3]) <= q(L)); --H3)
          ;
        j.splice(H3 + 1, 0, L);
        return;
      }
    } else if (T2.has(L))
      return T2.get(L);
    let Y3 = $.getCommentChildNodes && $.getCommentChildNodes(L, M2) || typeof L == "object" && Object.entries(L).filter((H3) => {
      let [R] = H3;
      return R !== "enclosingNode" && R !== "precedingNode" && R !== "followingNode" && R !== "tokens" && R !== "comments" && R !== "parent";
    }).map((H3) => {
      let [, R] = H3;
      return R;
    });
    if (!!Y3) {
      j || (j = [], T2.set(L, j));
      for (let H3 of Y3)
        A2(H3, M2, j);
      return j;
    }
  }
  function S2(L, M2, j, $) {
    let { locStart: V, locEnd: q } = j, Y3 = V(M2), H3 = q(M2), R = A2(L, j), Q, ee2, te2 = 0, oe2 = R.length;
    for (; te2 < oe2; ) {
      let W2 = te2 + oe2 >> 1, X3 = R[W2], ue2 = V(X3), De2 = q(X3);
      if (ue2 <= Y3 && H3 <= De2)
        return S2(X3, M2, j, X3);
      if (De2 <= Y3) {
        Q = X3, te2 = W2 + 1;
        continue;
      }
      if (H3 <= ue2) {
        ee2 = X3, oe2 = W2;
        continue;
      }
      throw new Error("Comment location overlaps with node location");
    }
    if ($ && $.type === "TemplateLiteral") {
      let { quasis: W2 } = $, X3 = F(W2, M2, j);
      Q && F(W2, Q, j) !== X3 && (Q = null), ee2 && F(W2, ee2, j) !== X3 && (ee2 = null);
    }
    return { enclosingNode: $, precedingNode: Q, followingNode: ee2 };
  }
  var B = () => false;
  function I2(L, M2, j, $) {
    if (!Array.isArray(L))
      return;
    let V = [], { locStart: q, locEnd: Y3, printer: { handleComments: H3 = {} } } = $, { avoidAstMutation: R, ownLine: Q = B, endOfLine: ee2 = B, remaining: te2 = B } = H3, oe2 = L.map((W2, X3) => Object.assign(Object.assign({}, S2(M2, W2, $)), {}, { comment: W2, text: j, options: $, ast: M2, isLastComment: L.length - 1 === X3 }));
    for (let [W2, X3] of oe2.entries()) {
      let { comment: ue2, precedingNode: De2, enclosingNode: ie, followingNode: G, text: z, options: U, ast: le2, isLastComment: ge2 } = X3;
      if (U.parser === "json" || U.parser === "json5" || U.parser === "__js_expression" || U.parser === "__vue_expression" || U.parser === "__vue_ts_expression") {
        if (q(ue2) - q(le2) <= 0) {
          f(le2, ue2);
          continue;
        }
        if (Y3(ue2) - Y3(le2) >= 0) {
          w2(le2, ue2);
          continue;
        }
      }
      let Ae2;
      if (R ? Ae2 = [X3] : (ue2.enclosingNode = ie, ue2.precedingNode = De2, ue2.followingNode = G, Ae2 = [ue2, z, U, le2, ge2]), P(z, U, oe2, W2))
        ue2.placement = "ownLine", Q(...Ae2) || (G ? f(G, ue2) : De2 ? w2(De2, ue2) : h2(ie || le2, ue2));
      else if (C2(z, U, oe2, W2))
        ue2.placement = "endOfLine", ee2(...Ae2) || (De2 ? w2(De2, ue2) : G ? f(G, ue2) : h2(ie || le2, ue2));
      else if (ue2.placement = "remaining", !te2(...Ae2))
        if (De2 && G) {
          let Ne2 = V.length;
          Ne2 > 0 && V[Ne2 - 1].followingNode !== G && D2(V, z, U), V.push(X3);
        } else
          De2 ? w2(De2, ue2) : G ? f(G, ue2) : h2(ie || le2, ue2);
    }
    if (D2(V, j, $), !R)
      for (let W2 of L)
        delete W2.precedingNode, delete W2.enclosingNode, delete W2.followingNode;
  }
  var k2 = (L) => !/[\S\n\u2028\u2029]/.test(L);
  function P(L, M2, j, $) {
    let { comment: V, precedingNode: q } = j[$], { locStart: Y3, locEnd: H3 } = M2, R = Y3(V);
    if (q)
      for (let Q = $ - 1; Q >= 0; Q--) {
        let { comment: ee2, precedingNode: te2 } = j[Q];
        if (te2 !== q || !k2(L.slice(H3(ee2), R)))
          break;
        R = Y3(ee2);
      }
    return y(L, R, { backwards: true });
  }
  function C2(L, M2, j, $) {
    let { comment: V, followingNode: q } = j[$], { locStart: Y3, locEnd: H3 } = M2, R = H3(V);
    if (q)
      for (let Q = $ + 1; Q < j.length; Q++) {
        let { comment: ee2, followingNode: te2 } = j[Q];
        if (te2 !== q || !k2(L.slice(R, Y3(ee2))))
          break;
        R = H3(ee2);
      }
    return y(L, R);
  }
  function D2(L, M2, j) {
    let $ = L.length;
    if ($ === 0)
      return;
    let { precedingNode: V, followingNode: q, enclosingNode: Y3 } = L[0], H3 = j.printer.getGapRegex && j.printer.getGapRegex(Y3) || /^[\s(]*$/, R = j.locStart(q), Q;
    for (Q = $; Q > 0; --Q) {
      let { comment: ee2, precedingNode: te2, followingNode: oe2 } = L[Q - 1];
      t.strictEqual(te2, V), t.strictEqual(oe2, q);
      let W2 = M2.slice(j.locEnd(ee2), R);
      if (H3.test(W2))
        R = j.locStart(ee2);
      else
        break;
    }
    for (let [ee2, { comment: te2 }] of L.entries())
      ee2 < Q ? w2(V, te2) : f(q, te2);
    for (let ee2 of [V, q])
      ee2.comments && ee2.comments.length > 1 && ee2.comments.sort((te2, oe2) => j.locStart(te2) - j.locStart(oe2));
    L.length = 0;
  }
  function g2(L, M2) {
    let j = L.getValue();
    return j.printed = true, M2.printer.printComment(L, M2);
  }
  function F(L, M2, j) {
    let $ = j.locStart(M2) - 1;
    for (let V = 1; V < L.length; ++V)
      if ($ < j.locStart(L[V]))
        return V - 1;
    return 0;
  }
  function l(L, M2) {
    let j = L.getValue(), $ = [g2(L, M2)], { printer: V, originalText: q, locStart: Y3, locEnd: H3 } = M2;
    if (V.isBlockComment && V.isBlockComment(j)) {
      let ee2 = y(q, H3(j)) ? y(q, Y3(j), { backwards: true }) ? a3 : s2 : " ";
      $.push(ee2);
    } else
      $.push(a3);
    let Q = m2(q, d4(q, H3(j)));
    return Q !== false && y(q, Q) && $.push(a3), $;
  }
  function E(L, M2) {
    let j = L.getValue(), $ = g2(L, M2), { printer: V, originalText: q, locStart: Y3 } = M2, H3 = V.isBlockComment && V.isBlockComment(j);
    if (y(q, Y3(j), { backwards: true })) {
      let Q = p(q, j, Y3);
      return i2([a3, Q ? a3 : "", $]);
    }
    let R = [" ", $];
    return H3 || (R = [i2(R), r]), R;
  }
  function v(L, M2, j, $) {
    let V = [], q = L.getValue();
    return !q || !q.comments || (L.each(() => {
      let Y3 = L.getValue();
      !Y3.leading && !Y3.trailing && (!$ || $(Y3)) && V.push(g2(L, M2));
    }, "comments"), V.length === 0) ? "" : j ? o(a3, V) : u([a3, o(a3, V)]);
  }
  function N(L, M2, j) {
    let $ = L.getValue();
    if (!$)
      return {};
    let V = $.comments || [];
    j && (V = V.filter((R) => !j.has(R)));
    let q = $ === M2.cursorNode;
    if (V.length === 0) {
      let R = q ? c : "";
      return { leading: R, trailing: R };
    }
    let Y3 = [], H3 = [];
    return L.each(() => {
      let R = L.getValue();
      if (j && j.has(R))
        return;
      let { leading: Q, trailing: ee2 } = R;
      Q ? Y3.push(l(L, M2)) : ee2 && H3.push(E(L, M2));
    }, "comments"), q && (Y3.unshift(c), H3.push(c)), { leading: Y3, trailing: H3 };
  }
  function x2(L, M2, j, $) {
    let { leading: V, trailing: q } = N(L, j, $);
    return !V && !q ? M2 : [V, M2, q];
  }
  function b2(L) {
    if (!!L)
      for (let M2 of L) {
        if (!M2.printed)
          throw new Error('Comment "' + M2.value.trim() + '" was not printed. Please report this error!');
        delete M2.printed;
      }
  }
  n.exports = { attach: I2, printComments: x2, printCommentsSeparately: N, printDanglingComments: v, getSortedChildNodes: A2, ensureAllCommentsPrinted: b2 };
} }), fm = Z({ "src/common/ast-path.js"(e, n) {
  re();
  var t = it$2();
  function s2(u, i2) {
    let o = a3(u.stack, i2);
    return o === -1 ? null : u.stack[o];
  }
  function a3(u, i2) {
    for (let o = u.length - 1; o >= 0; o -= 2) {
      let c = u[o];
      if (c && !Array.isArray(c) && --i2 < 0)
        return o;
    }
    return -1;
  }
  var r = class {
    constructor(u) {
      this.stack = [u];
    }
    getName() {
      let { stack: u } = this, { length: i2 } = u;
      return i2 > 1 ? u[i2 - 2] : null;
    }
    getValue() {
      return t(this.stack);
    }
    getNode() {
      let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return s2(this, u);
    }
    getParentNode() {
      let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return s2(this, u + 1);
    }
    call(u) {
      let { stack: i2 } = this, { length: o } = i2, c = t(i2);
      for (var y = arguments.length, m2 = new Array(y > 1 ? y - 1 : 0), d4 = 1; d4 < y; d4++)
        m2[d4 - 1] = arguments[d4];
      for (let f of m2)
        c = c[f], i2.push(f, c);
      let p = u(this);
      return i2.length = o, p;
    }
    callParent(u) {
      let i2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, o = a3(this.stack, i2 + 1), c = this.stack.splice(o + 1), y = u(this);
      return this.stack.push(...c), y;
    }
    each(u) {
      let { stack: i2 } = this, { length: o } = i2, c = t(i2);
      for (var y = arguments.length, m2 = new Array(y > 1 ? y - 1 : 0), d4 = 1; d4 < y; d4++)
        m2[d4 - 1] = arguments[d4];
      for (let p of m2)
        c = c[p], i2.push(p, c);
      for (let p = 0; p < c.length; ++p)
        i2.push(p, c[p]), u(this, p, c), i2.length -= 2;
      i2.length = o;
    }
    map(u) {
      let i2 = [];
      for (var o = arguments.length, c = new Array(o > 1 ? o - 1 : 0), y = 1; y < o; y++)
        c[y - 1] = arguments[y];
      return this.each((m2, d4, p) => {
        i2[d4] = u(m2, d4, p);
      }, ...c), i2;
    }
    try(u) {
      let { stack: i2 } = this, o = [...i2];
      try {
        return u();
      } finally {
        i2.length = 0, i2.push(...o);
      }
    }
    match() {
      let u = this.stack.length - 1, i2 = null, o = this.stack[u--];
      for (var c = arguments.length, y = new Array(c), m2 = 0; m2 < c; m2++)
        y[m2] = arguments[m2];
      for (let d4 of y) {
        if (o === void 0)
          return false;
        let p = null;
        if (typeof i2 == "number" && (p = i2, i2 = this.stack[u--], o = this.stack[u--]), d4 && !d4(o, i2, p))
          return false;
        i2 = this.stack[u--], o = this.stack[u--];
      }
      return true;
    }
    findAncestor(u) {
      let i2 = this.stack.length - 1, o = null, c = this.stack[i2--];
      for (; c; ) {
        let y = null;
        if (typeof o == "number" && (y = o, o = this.stack[i2--], c = this.stack[i2--]), o !== null && u(c, o, y))
          return c;
        o = this.stack[i2--], c = this.stack[i2--];
      }
    }
  };
  n.exports = r;
} }), Dm = Z({ "src/main/multiparser.js"(e, n) {
  re();
  var { utils: { stripTrailingHardline: t } } = Oe(), { normalize: s2 } = La$1(), a3 = et();
  function r(i2, o, c, y) {
    if (c.printer.embed && c.embeddedLanguageFormatting === "auto")
      return c.printer.embed(i2, o, (m2, d4, p) => u(m2, d4, c, y, p), c);
  }
  function u(i2, o, c, y) {
    let { stripTrailingHardline: m2 = false } = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {}, d4 = s2(Object.assign(Object.assign(Object.assign({}, c), o), {}, { parentParser: c.parser, originalText: i2 }), { passThrough: true }), p = Wn$3().parse(i2, d4), { ast: f } = p;
    i2 = p.text;
    let h2 = f.comments;
    delete f.comments, a3.attach(h2, f, i2, d4), d4[Symbol.for("comments")] = h2 || [], d4[Symbol.for("tokens")] = f.tokens || [];
    let w2 = y(f, d4);
    return a3.ensureAllCommentsPrinted(h2), m2 ? typeof w2 == "string" ? w2.replace(/(?:\r?\n)*$/, "") : t(w2) : w2;
  }
  n.exports = { printSubtree: r };
} }), mm = Z({ "src/main/ast-to-doc.js"(e, n) {
  re();
  var t = fm(), { builders: { hardline: s2, addAlignmentToDoc: a3 }, utils: { propagateBreaks: r } } = Oe(), { printComments: u } = et(), i2 = Dm();
  function o(m2, d4) {
    let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, { printer: f } = d4;
    f.preprocess && (m2 = f.preprocess(m2, d4));
    let h2 = /* @__PURE__ */ new Map(), w2 = new t(m2), T2 = A2();
    return p > 0 && (T2 = a3([s2, T2], p, d4.tabWidth)), r(T2), T2;
    function A2(B, I2) {
      return B === void 0 || B === w2 ? S2(I2) : Array.isArray(B) ? w2.call(() => S2(I2), ...B) : w2.call(() => S2(I2), B);
    }
    function S2(B) {
      let I2 = w2.getValue(), k2 = I2 && typeof I2 == "object" && B === void 0;
      if (k2 && h2.has(I2))
        return h2.get(I2);
      let P = y(w2, d4, A2, B);
      return k2 && h2.set(I2, P), P;
    }
  }
  function c(m2, d4) {
    let { originalText: p, [Symbol.for("comments")]: f, locStart: h2, locEnd: w2 } = d4, T2 = h2(m2), A2 = w2(m2), S2 = /* @__PURE__ */ new Set();
    for (let B of f)
      h2(B) >= T2 && w2(B) <= A2 && (B.printed = true, S2.add(B));
    return { doc: p.slice(T2, A2), printedComments: S2 };
  }
  function y(m2, d4, p, f) {
    let h2 = m2.getValue(), { printer: w2 } = d4, T2, A2;
    if (w2.hasPrettierIgnore && w2.hasPrettierIgnore(m2))
      ({ doc: T2, printedComments: A2 } = c(h2, d4));
    else {
      if (h2)
        try {
          T2 = i2.printSubtree(m2, p, d4, o);
        } catch (S2) {
          if (globalThis.PRETTIER_DEBUG)
            throw S2;
        }
      T2 || (T2 = w2.print(m2, d4, p, f));
    }
    return (!w2.willPrintOwnComments || !w2.willPrintOwnComments(m2, d4)) && (T2 = u(m2, T2, d4, A2)), T2;
  }
  n.exports = o;
} }), dm = Z({ "src/main/range-util.js"(e, n) {
  re();
  var t = Ut$1(), s2 = et(), a3 = (f) => {
    let { parser: h2 } = f;
    return h2 === "json" || h2 === "json5" || h2 === "json-stringify";
  };
  function r(f, h2) {
    let w2 = [f.node, ...f.parentNodes], T2 = /* @__PURE__ */ new Set([h2.node, ...h2.parentNodes]);
    return w2.find((A2) => y.has(A2.type) && T2.has(A2));
  }
  function u(f) {
    let h2 = f.length - 1;
    for (; ; ) {
      let w2 = f[h2];
      if (w2 && (w2.type === "Program" || w2.type === "File"))
        h2--;
      else
        break;
    }
    return f.slice(0, h2 + 1);
  }
  function i2(f, h2, w2) {
    let { locStart: T2, locEnd: A2 } = w2, S2 = f.node, B = h2.node;
    if (S2 === B)
      return { startNode: S2, endNode: B };
    let I2 = T2(f.node);
    for (let P of u(h2.parentNodes))
      if (T2(P) >= I2)
        B = P;
      else
        break;
    let k2 = A2(h2.node);
    for (let P of u(f.parentNodes))
      if (A2(P) <= k2)
        S2 = P;
      else
        break;
    return { startNode: S2, endNode: B };
  }
  function o(f, h2, w2, T2) {
    let A2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], S2 = arguments.length > 5 ? arguments[5] : void 0, { locStart: B, locEnd: I2 } = w2, k2 = B(f), P = I2(f);
    if (!(h2 > P || h2 < k2 || S2 === "rangeEnd" && h2 === k2 || S2 === "rangeStart" && h2 === P)) {
      for (let C2 of s2.getSortedChildNodes(f, w2)) {
        let D2 = o(C2, h2, w2, T2, [f, ...A2], S2);
        if (D2)
          return D2;
      }
      if (!T2 || T2(f, A2[0]))
        return { node: f, parentNodes: A2 };
    }
  }
  function c(f, h2) {
    return h2 !== "DeclareExportDeclaration" && f !== "TypeParameterDeclaration" && (f === "Directive" || f === "TypeAlias" || f === "TSExportAssignment" || f.startsWith("Declare") || f.startsWith("TSDeclare") || f.endsWith("Statement") || f.endsWith("Declaration"));
  }
  var y = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), m2 = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
  function d4(f, h2, w2) {
    if (!h2)
      return false;
    switch (f.parser) {
      case "flow":
      case "babel":
      case "babel-flow":
      case "babel-ts":
      case "typescript":
      case "acorn":
      case "espree":
      case "meriyah":
      case "__babel_estree":
        return c(h2.type, w2 && w2.type);
      case "json":
      case "json5":
      case "json-stringify":
        return y.has(h2.type);
      case "graphql":
        return m2.has(h2.kind);
      case "vue":
        return h2.tag !== "root";
    }
    return false;
  }
  function p(f, h2, w2) {
    let { rangeStart: T2, rangeEnd: A2, locStart: S2, locEnd: B } = h2;
    t.ok(A2 > T2);
    let I2 = f.slice(T2, A2).search(/\S/), k2 = I2 === -1;
    if (!k2)
      for (T2 += I2; A2 > T2 && !/\S/.test(f[A2 - 1]); --A2)
        ;
    let P = o(w2, T2, h2, (F, l) => d4(h2, F, l), [], "rangeStart"), C2 = k2 ? P : o(w2, A2, h2, (F) => d4(h2, F), [], "rangeEnd");
    if (!P || !C2)
      return { rangeStart: 0, rangeEnd: 0 };
    let D2, g2;
    if (a3(h2)) {
      let F = r(P, C2);
      D2 = F, g2 = F;
    } else
      ({ startNode: D2, endNode: g2 } = i2(P, C2, h2));
    return { rangeStart: Math.min(S2(D2), S2(g2)), rangeEnd: Math.max(B(D2), B(g2)) };
  }
  n.exports = { calculateRange: p, findNodeAtOffset: o };
} }), gm = Z({ "src/main/core.js"(e, n) {
  re();
  var { diffArrays: t } = Zf(), { printer: { printDocToString: s2 }, debug: { printDocToDebug: a3 } } = Oe(), { getAlignmentSize: r } = Ue$2(), { guessEndOfLine: u, convertEndOfLineToChars: i2, countEndOfLineChars: o, normalizeEndOfLine: c } = kn$2(), y = La$1().normalize, m2 = pm(), d4 = et(), p = Wn$3(), f = mm(), h2 = dm(), w2 = "\uFEFF", T2 = Symbol("cursor");
  function A2(g2, F, l) {
    let E = F.comments;
    return E && (delete F.comments, d4.attach(E, F, g2, l)), l[Symbol.for("comments")] = E || [], l[Symbol.for("tokens")] = F.tokens || [], l.originalText = g2, E;
  }
  function S2(g2, F) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    if (!g2 || g2.trim().length === 0)
      return { formatted: "", cursorOffset: -1, comments: [] };
    let { ast: E, text: v } = p.parse(g2, F);
    if (F.cursorOffset >= 0) {
      let L = h2.findNodeAtOffset(E, F.cursorOffset, F);
      L && L.node && (F.cursorNode = L.node);
    }
    let N = A2(v, E, F), x2 = f(E, F, l), b2 = s2(x2, F);
    if (d4.ensureAllCommentsPrinted(N), l > 0) {
      let L = b2.formatted.trim();
      b2.cursorNodeStart !== void 0 && (b2.cursorNodeStart -= b2.formatted.indexOf(L)), b2.formatted = L + i2(F.endOfLine);
    }
    if (F.cursorOffset >= 0) {
      let L, M2, j, $, V;
      if (F.cursorNode && b2.cursorNodeText ? (L = F.locStart(F.cursorNode), M2 = v.slice(L, F.locEnd(F.cursorNode)), j = F.cursorOffset - L, $ = b2.cursorNodeStart, V = b2.cursorNodeText) : (L = 0, M2 = v, j = F.cursorOffset, $ = 0, V = b2.formatted), M2 === V)
        return { formatted: b2.formatted, cursorOffset: $ + j, comments: N };
      let q = [...M2];
      q.splice(j, 0, T2);
      let Y3 = [...V], H3 = t(q, Y3), R = $;
      for (let Q of H3)
        if (Q.removed) {
          if (Q.value.includes(T2))
            break;
        } else
          R += Q.count;
      return { formatted: b2.formatted, cursorOffset: R, comments: N };
    }
    return { formatted: b2.formatted, cursorOffset: -1, comments: N };
  }
  function B(g2, F) {
    let { ast: l, text: E } = p.parse(g2, F), { rangeStart: v, rangeEnd: N } = h2.calculateRange(E, F, l), x2 = E.slice(v, N), b2 = Math.min(v, E.lastIndexOf(`
`, v) + 1), L = E.slice(b2, v).match(/^\s*/)[0], M2 = r(L, F.tabWidth), j = S2(x2, Object.assign(Object.assign({}, F), {}, { rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: F.cursorOffset > v && F.cursorOffset <= N ? F.cursorOffset - v : -1, endOfLine: "lf" }), M2), $ = j.formatted.trimEnd(), { cursorOffset: V } = F;
    V > N ? V += $.length - x2.length : j.cursorOffset >= 0 && (V = j.cursorOffset + v);
    let q = E.slice(0, v) + $ + E.slice(N);
    if (F.endOfLine !== "lf") {
      let Y3 = i2(F.endOfLine);
      V >= 0 && Y3 === `\r
` && (V += o(q.slice(0, V), `
`)), q = q.replace(/\n/g, Y3);
    }
    return { formatted: q, cursorOffset: V, comments: j.comments };
  }
  function I2(g2, F, l) {
    return typeof F != "number" || Number.isNaN(F) || F < 0 || F > g2.length ? l : F;
  }
  function k2(g2, F) {
    let { cursorOffset: l, rangeStart: E, rangeEnd: v } = F;
    return l = I2(g2, l, -1), E = I2(g2, E, 0), v = I2(g2, v, g2.length), Object.assign(Object.assign({}, F), {}, { cursorOffset: l, rangeStart: E, rangeEnd: v });
  }
  function P(g2, F) {
    let { cursorOffset: l, rangeStart: E, rangeEnd: v, endOfLine: N } = k2(g2, F), x2 = g2.charAt(0) === w2;
    if (x2 && (g2 = g2.slice(1), l--, E--, v--), N === "auto" && (N = u(g2)), g2.includes("\r")) {
      let b2 = (L) => o(g2.slice(0, Math.max(L, 0)), `\r
`);
      l -= b2(l), E -= b2(E), v -= b2(v), g2 = c(g2);
    }
    return { hasBOM: x2, text: g2, options: k2(g2, Object.assign(Object.assign({}, F), {}, { cursorOffset: l, rangeStart: E, rangeEnd: v, endOfLine: N })) };
  }
  function C2(g2, F) {
    let l = p.resolveParser(F);
    return !l.hasPragma || l.hasPragma(g2);
  }
  function D2(g2, F) {
    let { hasBOM: l, text: E, options: v } = P(g2, y(F));
    if (v.rangeStart >= v.rangeEnd && E !== "" || v.requirePragma && !C2(E, v))
      return { formatted: g2, cursorOffset: F.cursorOffset, comments: [] };
    let N;
    return v.rangeStart > 0 || v.rangeEnd < E.length ? N = B(E, v) : (!v.requirePragma && v.insertPragma && v.printer.insertPragma && !C2(E, v) && (E = v.printer.insertPragma(E)), N = S2(E, v)), l && (N.formatted = w2 + N.formatted, N.cursorOffset >= 0 && N.cursorOffset++), N;
  }
  n.exports = { formatWithCursor: D2, parse(g2, F, l) {
    let { text: E, options: v } = P(g2, y(F)), N = p.parse(E, v);
    return l && (N.ast = m2(N.ast, v)), N;
  }, formatAST(g2, F) {
    F = y(F);
    let l = f(g2, F);
    return s2(l, F);
  }, formatDoc(g2, F) {
    return D2(a3(g2), Object.assign(Object.assign({}, F), {}, { parser: "__js_expression" })).formatted;
  }, printToDoc(g2, F) {
    F = y(F);
    let { ast: l, text: E } = p.parse(g2, F);
    return A2(E, l, F), f(l, F);
  }, printDocToString(g2, F) {
    return s2(g2, y(F));
  } };
} }), ym = Z({ "src/common/util-shared.js"(e, n) {
  re();
  var { getMaxContinuousCount: t, getStringWidth: s2, getAlignmentSize: a3, getIndentSize: r, skip: u, skipWhitespace: i2, skipSpaces: o, skipNewline: c, skipToLineEnd: y, skipEverythingButNewLine: m2, skipInlineComment: d4, skipTrailingComment: p, hasNewline: f, hasNewlineInRange: h2, hasSpaces: w2, isNextLineEmpty: T2, isNextLineEmptyAfterIndex: A2, isPreviousLineEmpty: S2, getNextNonSpaceNonCommentCharacterIndex: B, makeString: I2, addLeadingComment: k2, addDanglingComment: P, addTrailingComment: C2 } = Ue$2();
  n.exports = { getMaxContinuousCount: t, getStringWidth: s2, getAlignmentSize: a3, getIndentSize: r, skip: u, skipWhitespace: i2, skipSpaces: o, skipNewline: c, skipToLineEnd: y, skipEverythingButNewLine: m2, skipInlineComment: d4, skipTrailingComment: p, hasNewline: f, hasNewlineInRange: h2, hasSpaces: w2, isNextLineEmpty: T2, isNextLineEmptyAfterIndex: A2, isPreviousLineEmpty: S2, getNextNonSpaceNonCommentCharacterIndex: B, makeString: I2, addLeadingComment: k2, addDanglingComment: P, addTrailingComment: C2 };
} }), Tt$1 = Z({ "src/utils/create-language.js"(e, n) {
  re(), n.exports = function(t, s2) {
    let { languageId: a3 } = t, r = wn$1(t, Gf);
    return Object.assign(Object.assign({ linguistLanguageId: a3 }, r), s2(t));
  };
} }), hm = Z({ "node_modules/esutils/lib/ast.js"(e, n) {
  re(), function() {
    function t(o) {
      if (o == null)
        return false;
      switch (o.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "CallExpression":
        case "ConditionalExpression":
        case "FunctionExpression":
        case "Identifier":
        case "Literal":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "ObjectExpression":
        case "SequenceExpression":
        case "ThisExpression":
        case "UnaryExpression":
        case "UpdateExpression":
          return true;
      }
      return false;
    }
    function s2(o) {
      if (o == null)
        return false;
      switch (o.type) {
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "WhileStatement":
          return true;
      }
      return false;
    }
    function a3(o) {
      if (o == null)
        return false;
      switch (o.type) {
        case "BlockStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "ForInStatement":
        case "ForStatement":
        case "IfStatement":
        case "LabeledStatement":
        case "ReturnStatement":
        case "SwitchStatement":
        case "ThrowStatement":
        case "TryStatement":
        case "VariableDeclaration":
        case "WhileStatement":
        case "WithStatement":
          return true;
      }
      return false;
    }
    function r(o) {
      return a3(o) || o != null && o.type === "FunctionDeclaration";
    }
    function u(o) {
      switch (o.type) {
        case "IfStatement":
          return o.alternate != null ? o.alternate : o.consequent;
        case "LabeledStatement":
        case "ForStatement":
        case "ForInStatement":
        case "WhileStatement":
        case "WithStatement":
          return o.body;
      }
      return null;
    }
    function i2(o) {
      var c;
      if (o.type !== "IfStatement" || o.alternate == null)
        return false;
      c = o.consequent;
      do {
        if (c.type === "IfStatement" && c.alternate == null)
          return true;
        c = u(c);
      } while (c);
      return false;
    }
    n.exports = { isExpression: t, isStatement: a3, isIterationStatement: s2, isSourceElement: r, isProblematicIfStatement: i2, trailingStatement: u };
  }();
} }), ja$1 = Z({ "node_modules/esutils/lib/code.js"(e, n) {
  re(), function() {
    var t, s2, a3, r, u, i2;
    s2 = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, t = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ };
    function o(A2) {
      return 48 <= A2 && A2 <= 57;
    }
    function c(A2) {
      return 48 <= A2 && A2 <= 57 || 97 <= A2 && A2 <= 102 || 65 <= A2 && A2 <= 70;
    }
    function y(A2) {
      return A2 >= 48 && A2 <= 55;
    }
    a3 = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279];
    function m2(A2) {
      return A2 === 32 || A2 === 9 || A2 === 11 || A2 === 12 || A2 === 160 || A2 >= 5760 && a3.indexOf(A2) >= 0;
    }
    function d4(A2) {
      return A2 === 10 || A2 === 13 || A2 === 8232 || A2 === 8233;
    }
    function p(A2) {
      if (A2 <= 65535)
        return String.fromCharCode(A2);
      var S2 = String.fromCharCode(Math.floor((A2 - 65536) / 1024) + 55296), B = String.fromCharCode((A2 - 65536) % 1024 + 56320);
      return S2 + B;
    }
    for (r = new Array(128), i2 = 0; i2 < 128; ++i2)
      r[i2] = i2 >= 97 && i2 <= 122 || i2 >= 65 && i2 <= 90 || i2 === 36 || i2 === 95;
    for (u = new Array(128), i2 = 0; i2 < 128; ++i2)
      u[i2] = i2 >= 97 && i2 <= 122 || i2 >= 65 && i2 <= 90 || i2 >= 48 && i2 <= 57 || i2 === 36 || i2 === 95;
    function f(A2) {
      return A2 < 128 ? r[A2] : s2.NonAsciiIdentifierStart.test(p(A2));
    }
    function h2(A2) {
      return A2 < 128 ? u[A2] : s2.NonAsciiIdentifierPart.test(p(A2));
    }
    function w2(A2) {
      return A2 < 128 ? r[A2] : t.NonAsciiIdentifierStart.test(p(A2));
    }
    function T2(A2) {
      return A2 < 128 ? u[A2] : t.NonAsciiIdentifierPart.test(p(A2));
    }
    n.exports = { isDecimalDigit: o, isHexDigit: c, isOctalDigit: y, isWhiteSpace: m2, isLineTerminator: d4, isIdentifierStartES5: f, isIdentifierPartES5: h2, isIdentifierStartES6: w2, isIdentifierPartES6: T2 };
  }();
} }), vm = Z({ "node_modules/esutils/lib/keyword.js"(e, n) {
  re(), function() {
    var t = ja$1();
    function s2(f) {
      switch (f) {
        case "implements":
        case "interface":
        case "package":
        case "private":
        case "protected":
        case "public":
        case "static":
        case "let":
          return true;
        default:
          return false;
      }
    }
    function a3(f, h2) {
      return !h2 && f === "yield" ? false : r(f, h2);
    }
    function r(f, h2) {
      if (h2 && s2(f))
        return true;
      switch (f.length) {
        case 2:
          return f === "if" || f === "in" || f === "do";
        case 3:
          return f === "var" || f === "for" || f === "new" || f === "try";
        case 4:
          return f === "this" || f === "else" || f === "case" || f === "void" || f === "with" || f === "enum";
        case 5:
          return f === "while" || f === "break" || f === "catch" || f === "throw" || f === "const" || f === "yield" || f === "class" || f === "super";
        case 6:
          return f === "return" || f === "typeof" || f === "delete" || f === "switch" || f === "export" || f === "import";
        case 7:
          return f === "default" || f === "finally" || f === "extends";
        case 8:
          return f === "function" || f === "continue" || f === "debugger";
        case 10:
          return f === "instanceof";
        default:
          return false;
      }
    }
    function u(f, h2) {
      return f === "null" || f === "true" || f === "false" || a3(f, h2);
    }
    function i2(f, h2) {
      return f === "null" || f === "true" || f === "false" || r(f, h2);
    }
    function o(f) {
      return f === "eval" || f === "arguments";
    }
    function c(f) {
      var h2, w2, T2;
      if (f.length === 0 || (T2 = f.charCodeAt(0), !t.isIdentifierStartES5(T2)))
        return false;
      for (h2 = 1, w2 = f.length; h2 < w2; ++h2)
        if (T2 = f.charCodeAt(h2), !t.isIdentifierPartES5(T2))
          return false;
      return true;
    }
    function y(f, h2) {
      return (f - 55296) * 1024 + (h2 - 56320) + 65536;
    }
    function m2(f) {
      var h2, w2, T2, A2, S2;
      if (f.length === 0)
        return false;
      for (S2 = t.isIdentifierStartES6, h2 = 0, w2 = f.length; h2 < w2; ++h2) {
        if (T2 = f.charCodeAt(h2), 55296 <= T2 && T2 <= 56319) {
          if (++h2, h2 >= w2 || (A2 = f.charCodeAt(h2), !(56320 <= A2 && A2 <= 57343)))
            return false;
          T2 = y(T2, A2);
        }
        if (!S2(T2))
          return false;
        S2 = t.isIdentifierPartES6;
      }
      return true;
    }
    function d4(f, h2) {
      return c(f) && !u(f, h2);
    }
    function p(f, h2) {
      return m2(f) && !i2(f, h2);
    }
    n.exports = { isKeywordES5: a3, isKeywordES6: r, isReservedWordES5: u, isReservedWordES6: i2, isRestrictedWord: o, isIdentifierNameES5: c, isIdentifierNameES6: m2, isIdentifierES5: d4, isIdentifierES6: p };
  }();
} }), Cm = Z({ "node_modules/esutils/lib/utils.js"(e) {
  re(), function() {
    e.ast = hm(), e.code = ja$1(), e.keyword = vm();
  }();
} }), Pt$1 = Z({ "src/language-js/utils/is-block-comment.js"(e, n) {
  re();
  var t = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]), s2 = (a3) => t.has(a3 == null ? void 0 : a3.type);
  n.exports = s2;
} }), Em = Z({ "src/language-js/utils/is-node-matches.js"(e, n) {
  re();
  function t(a3, r) {
    let u = r.split(".");
    for (let i2 = u.length - 1; i2 >= 0; i2--) {
      let o = u[i2];
      if (i2 === 0)
        return a3.type === "Identifier" && a3.name === o;
      if (a3.type !== "MemberExpression" || a3.optional || a3.computed || a3.property.type !== "Identifier" || a3.property.name !== o)
        return false;
      a3 = a3.object;
    }
  }
  function s2(a3, r) {
    return r.some((u) => t(a3, u));
  }
  n.exports = s2;
} }), Ke$1 = Z({ "src/language-js/utils/index.js"(e, n) {
  re();
  var t = Cm().keyword.isIdentifierNameES5, { getLast: s2, hasNewline: a3, skipWhitespace: r, isNonEmptyArray: u, isNextLineEmptyAfterIndex: i2, getStringWidth: o } = Ue$2(), { locStart: c, locEnd: y, hasSameLocStart: m2 } = st$1(), d4 = Pt$1(), p = Em(), f = "(?:(?=.)\\s)", h2 = new RegExp("^".concat(f, "*:")), w2 = new RegExp("^".concat(f, "*::"));
  function T2(O2) {
    var fe2, Te2;
    return ((fe2 = O2.extra) === null || fe2 === void 0 ? void 0 : fe2.parenthesized) && d4((Te2 = O2.trailingComments) === null || Te2 === void 0 ? void 0 : Te2[0]) && h2.test(O2.trailingComments[0].value);
  }
  function A2(O2) {
    let fe2 = O2 == null ? void 0 : O2[0];
    return d4(fe2) && w2.test(fe2.value);
  }
  function S2(O2, fe2) {
    if (!O2 || typeof O2 != "object")
      return false;
    if (Array.isArray(O2))
      return O2.some(($e2) => S2($e2, fe2));
    let Te2 = fe2(O2);
    return typeof Te2 == "boolean" ? Te2 : Object.values(O2).some(($e2) => S2($e2, fe2));
  }
  function B(O2) {
    return O2.type === "AssignmentExpression" || O2.type === "BinaryExpression" || O2.type === "LogicalExpression" || O2.type === "NGPipeExpression" || O2.type === "ConditionalExpression" || ue2(O2) || De2(O2) || O2.type === "SequenceExpression" || O2.type === "TaggedTemplateExpression" || O2.type === "BindExpression" || O2.type === "UpdateExpression" && !O2.prefix || O2.type === "TSAsExpression" || O2.type === "TSNonNullExpression";
  }
  function I2(O2) {
    var fe2, Te2, $e2, Je2, Ze2, ut2;
    return O2.expressions ? O2.expressions[0] : (fe2 = (Te2 = ($e2 = (Je2 = (Ze2 = (ut2 = O2.left) !== null && ut2 !== void 0 ? ut2 : O2.test) !== null && Ze2 !== void 0 ? Ze2 : O2.callee) !== null && Je2 !== void 0 ? Je2 : O2.object) !== null && $e2 !== void 0 ? $e2 : O2.tag) !== null && Te2 !== void 0 ? Te2 : O2.argument) !== null && fe2 !== void 0 ? fe2 : O2.expression;
  }
  function k2(O2, fe2) {
    if (fe2.expressions)
      return ["expressions", 0];
    if (fe2.left)
      return ["left"];
    if (fe2.test)
      return ["test"];
    if (fe2.object)
      return ["object"];
    if (fe2.callee)
      return ["callee"];
    if (fe2.tag)
      return ["tag"];
    if (fe2.argument)
      return ["argument"];
    if (fe2.expression)
      return ["expression"];
    throw new Error("Unexpected node has no left side.");
  }
  function P(O2) {
    return O2 = new Set(O2), (fe2) => O2.has(fe2 == null ? void 0 : fe2.type);
  }
  var C2 = P(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose"]), D2 = P(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
  function g2(O2) {
    let fe2 = O2.getParentNode();
    return O2.getName() === "declaration" && D2(fe2) ? fe2 : null;
  }
  var F = P(["BooleanLiteral", "DirectiveLiteral", "Literal", "NullLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "RegExpLiteral", "StringLiteral", "TemplateLiteral", "TSTypeLiteral", "JSXText"]);
  function l(O2) {
    return O2.type === "NumericLiteral" || O2.type === "Literal" && typeof O2.value == "number";
  }
  function E(O2) {
    return O2.type === "UnaryExpression" && (O2.operator === "+" || O2.operator === "-") && l(O2.argument);
  }
  function v(O2) {
    return O2.type === "StringLiteral" || O2.type === "Literal" && typeof O2.value == "string";
  }
  var N = P(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]), x2 = P(["FunctionExpression", "ArrowFunctionExpression"]);
  function b2(O2) {
    return O2.type === "FunctionExpression" || O2.type === "ArrowFunctionExpression" && O2.body.type === "BlockStatement";
  }
  function L(O2) {
    return ue2(O2) && O2.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(O2.callee.name);
  }
  var M2 = P(["JSXElement", "JSXFragment"]);
  function j(O2, fe2) {
    if (O2.parentParser !== "markdown" && O2.parentParser !== "mdx")
      return false;
    let Te2 = fe2.getNode();
    if (!Te2.expression || !M2(Te2.expression))
      return false;
    let $e2 = fe2.getParentNode();
    return $e2.type === "Program" && $e2.body.length === 1;
  }
  function $(O2) {
    return O2.kind === "get" || O2.kind === "set";
  }
  function V(O2) {
    return $(O2) || m2(O2, O2.value);
  }
  function q(O2) {
    return (O2.type === "ObjectTypeProperty" || O2.type === "ObjectTypeInternalSlot") && O2.value.type === "FunctionTypeAnnotation" && !O2.static && !V(O2);
  }
  function Y3(O2) {
    return (O2.type === "TypeAnnotation" || O2.type === "TSTypeAnnotation") && O2.typeAnnotation.type === "FunctionTypeAnnotation" && !O2.static && !m2(O2, O2.typeAnnotation);
  }
  var H3 = P(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
  function R(O2) {
    return De2(O2) || O2.type === "BindExpression" && Boolean(O2.object);
  }
  var Q = /* @__PURE__ */ new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
  function ee2(O2) {
    return O2 ? !!((O2.type === "GenericTypeAnnotation" || O2.type === "TSTypeReference") && !O2.typeParameters || Q.has(O2.type)) : false;
  }
  function te2(O2) {
    let fe2 = /^(?:before|after)(?:Each|All)$/;
    return O2.callee.type === "Identifier" && fe2.test(O2.callee.name) && O2.arguments.length === 1;
  }
  var oe2 = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
  function W2(O2) {
    return p(O2, oe2);
  }
  function X3(O2, fe2) {
    if (O2.type !== "CallExpression")
      return false;
    if (O2.arguments.length === 1) {
      if (L(O2) && fe2 && X3(fe2))
        return x2(O2.arguments[0]);
      if (te2(O2))
        return L(O2.arguments[0]);
    } else if ((O2.arguments.length === 2 || O2.arguments.length === 3) && (O2.arguments[0].type === "TemplateLiteral" || v(O2.arguments[0])) && W2(O2.callee))
      return O2.arguments[2] && !l(O2.arguments[2]) ? false : (O2.arguments.length === 2 ? x2(O2.arguments[1]) : b2(O2.arguments[1]) && Se2(O2.arguments[1]).length <= 1) || L(O2.arguments[1]);
    return false;
  }
  var ue2 = P(["CallExpression", "OptionalCallExpression"]), De2 = P(["MemberExpression", "OptionalMemberExpression"]);
  function ie(O2) {
    let fe2 = "expressions";
    O2.type === "TSTemplateLiteralType" && (fe2 = "types");
    let Te2 = O2[fe2];
    return Te2.length === 0 ? false : Te2.every(($e2) => {
      if (se($e2))
        return false;
      if ($e2.type === "Identifier" || $e2.type === "ThisExpression")
        return true;
      if (De2($e2)) {
        let Je2 = $e2;
        for (; De2(Je2); )
          if (Je2.property.type !== "Identifier" && Je2.property.type !== "Literal" && Je2.property.type !== "StringLiteral" && Je2.property.type !== "NumericLiteral" || (Je2 = Je2.object, se(Je2)))
            return false;
        return Je2.type === "Identifier" || Je2.type === "ThisExpression";
      }
      return false;
    });
  }
  function G(O2, fe2) {
    return O2 === "+" || O2 === "-" ? O2 + fe2 : fe2;
  }
  function z(O2, fe2) {
    let Te2 = c(fe2), $e2 = r(O2, y(fe2));
    return $e2 !== false && O2.slice(Te2, Te2 + 2) === "/*" && O2.slice($e2, $e2 + 2) === "*/";
  }
  function U(O2, fe2) {
    return M2(fe2) ? Re2(fe2) : se(fe2, Le2.Leading, (Te2) => a3(O2, y(Te2)));
  }
  function le2(O2, fe2) {
    return fe2.parser !== "json" && v(O2.key) && ve2(O2.key).slice(1, -1) === O2.key.value && (t(O2.key.value) && !(fe2.parser === "babel-ts" && O2.type === "ClassProperty" || fe2.parser === "typescript" && O2.type === "PropertyDefinition") || ge2(O2.key.value) && String(Number(O2.key.value)) === O2.key.value && (fe2.parser === "babel" || fe2.parser === "acorn" || fe2.parser === "espree" || fe2.parser === "meriyah" || fe2.parser === "__babel_estree"));
  }
  function ge2(O2) {
    return /^(?:\d+|\d+\.\d+)$/.test(O2);
  }
  function Ae2(O2, fe2) {
    let Te2 = /^[fx]?(?:describe|it|test)$/;
    return fe2.type === "TaggedTemplateExpression" && fe2.quasi === O2 && fe2.tag.type === "MemberExpression" && fe2.tag.property.type === "Identifier" && fe2.tag.property.name === "each" && (fe2.tag.object.type === "Identifier" && Te2.test(fe2.tag.object.name) || fe2.tag.object.type === "MemberExpression" && fe2.tag.object.property.type === "Identifier" && (fe2.tag.object.property.name === "only" || fe2.tag.object.property.name === "skip") && fe2.tag.object.object.type === "Identifier" && Te2.test(fe2.tag.object.object.name));
  }
  function Ne2(O2) {
    return O2.quasis.some((fe2) => fe2.value.raw.includes(`
`));
  }
  function ke2(O2, fe2) {
    return (O2.type === "TemplateLiteral" && Ne2(O2) || O2.type === "TaggedTemplateExpression" && Ne2(O2.quasi)) && !a3(fe2, c(O2), { backwards: true });
  }
  function ce(O2) {
    if (!se(O2))
      return false;
    let fe2 = s2(He2(O2, Le2.Dangling));
    return fe2 && !d4(fe2);
  }
  function pe(O2) {
    if (O2.length <= 1)
      return false;
    let fe2 = 0;
    for (let Te2 of O2)
      if (x2(Te2)) {
        if (fe2 += 1, fe2 > 1)
          return true;
      } else if (ue2(Te2)) {
        for (let $e2 of Te2.arguments)
          if (x2($e2))
            return true;
      }
    return false;
  }
  function de2(O2) {
    let fe2 = O2.getValue(), Te2 = O2.getParentNode();
    return ue2(fe2) && ue2(Te2) && Te2.callee === fe2 && fe2.arguments.length > Te2.arguments.length && Te2.arguments.length > 0;
  }
  function ae2(O2, fe2) {
    if (fe2 >= 2)
      return false;
    let Te2 = (Je2) => ae2(Je2, fe2 + 1), $e2 = O2.type === "Literal" && "regex" in O2 && O2.regex.pattern || O2.type === "RegExpLiteral" && O2.pattern;
    return $e2 && o($e2) > 5 ? false : O2.type === "Literal" || O2.type === "BigIntLiteral" || O2.type === "DecimalLiteral" || O2.type === "BooleanLiteral" || O2.type === "NullLiteral" || O2.type === "NumericLiteral" || O2.type === "RegExpLiteral" || O2.type === "StringLiteral" || O2.type === "Identifier" || O2.type === "ThisExpression" || O2.type === "Super" || O2.type === "PrivateName" || O2.type === "PrivateIdentifier" || O2.type === "ArgumentPlaceholder" || O2.type === "Import" ? true : O2.type === "TemplateLiteral" ? O2.quasis.every((Je2) => !Je2.value.raw.includes(`
`)) && O2.expressions.every(Te2) : O2.type === "ObjectExpression" ? O2.properties.every((Je2) => !Je2.computed && (Je2.shorthand || Je2.value && Te2(Je2.value))) : O2.type === "ArrayExpression" ? O2.elements.every((Je2) => Je2 === null || Te2(Je2)) : ze(O2) ? (O2.type === "ImportExpression" || ae2(O2.callee, fe2)) && Xe2(O2).every(Te2) : De2(O2) ? ae2(O2.object, fe2) && ae2(O2.property, fe2) : O2.type === "UnaryExpression" && (O2.operator === "!" || O2.operator === "-") ? ae2(O2.argument, fe2) : O2.type === "TSNonNullExpression" ? ae2(O2.expression, fe2) : false;
  }
  function ve2(O2) {
    var fe2, Te2;
    return (fe2 = (Te2 = O2.extra) === null || Te2 === void 0 ? void 0 : Te2.raw) !== null && fe2 !== void 0 ? fe2 : O2.raw;
  }
  function K(O2) {
    return O2;
  }
  function he2(O2) {
    return O2.filepath && /\.tsx$/i.test(O2.filepath);
  }
  function ye2(O2) {
    let fe2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "es5";
    return O2.trailingComma === "es5" && fe2 === "es5" || O2.trailingComma === "all" && (fe2 === "all" || fe2 === "es5");
  }
  function Ce2(O2, fe2) {
    switch (O2 = Ee(O2), O2.type) {
      case "FunctionExpression":
      case "ClassExpression":
      case "DoExpression":
        return fe2;
      case "ObjectExpression":
        return true;
      case "MemberExpression":
      case "OptionalMemberExpression":
        return Ce2(O2.object, fe2);
      case "TaggedTemplateExpression":
        return O2.tag.type === "FunctionExpression" ? false : Ce2(O2.tag, fe2);
      case "CallExpression":
      case "OptionalCallExpression":
        return O2.callee.type === "FunctionExpression" ? false : Ce2(O2.callee, fe2);
      case "ConditionalExpression":
        return Ce2(O2.test, fe2);
      case "UpdateExpression":
        return !O2.prefix && Ce2(O2.argument, fe2);
      case "BindExpression":
        return O2.object && Ce2(O2.object, fe2);
      case "SequenceExpression":
        return Ce2(O2.expressions[0], fe2);
      case "TSAsExpression":
      case "TSNonNullExpression":
        return Ce2(O2.expression, fe2);
      default:
        return false;
    }
  }
  var Ie2 = { "==": true, "!=": true, "===": true, "!==": true }, Fe2 = { "*": true, "/": true, "%": true }, me2 = { ">>": true, ">>>": true, "<<": true };
  function _(O2, fe2) {
    return !(ne(fe2) !== ne(O2) || O2 === "**" || Ie2[O2] && Ie2[fe2] || fe2 === "%" && Fe2[O2] || O2 === "%" && Fe2[fe2] || fe2 !== O2 && Fe2[fe2] && Fe2[O2] || me2[O2] && me2[fe2]);
  }
  var J2 = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((O2, fe2) => O2.map((Te2) => [Te2, fe2])));
  function ne(O2) {
    return J2.get(O2);
  }
  function Ee(O2) {
    for (; O2.left; )
      O2 = O2.left;
    return O2;
  }
  function We2(O2) {
    return Boolean(me2[O2]) || O2 === "|" || O2 === "^" || O2 === "&";
  }
  function Be(O2) {
    var fe2;
    if (O2.rest)
      return true;
    let Te2 = Se2(O2);
    return ((fe2 = s2(Te2)) === null || fe2 === void 0 ? void 0 : fe2.type) === "RestElement";
  }
  var Pe2 = /* @__PURE__ */ new WeakMap();
  function Se2(O2) {
    if (Pe2.has(O2))
      return Pe2.get(O2);
    let fe2 = [];
    return O2.this && fe2.push(O2.this), Array.isArray(O2.parameters) ? fe2.push(...O2.parameters) : Array.isArray(O2.params) && fe2.push(...O2.params), O2.rest && fe2.push(O2.rest), Pe2.set(O2, fe2), fe2;
  }
  function Qe(O2, fe2) {
    let Te2 = O2.getValue(), $e2 = 0, Je2 = (Ze2) => fe2(Ze2, $e2++);
    Te2.this && O2.call(Je2, "this"), Array.isArray(Te2.parameters) ? O2.each(Je2, "parameters") : Array.isArray(Te2.params) && O2.each(Je2, "params"), Te2.rest && O2.call(Je2, "rest");
  }
  var xe2 = /* @__PURE__ */ new WeakMap();
  function Xe2(O2) {
    if (xe2.has(O2))
      return xe2.get(O2);
    let fe2 = O2.arguments;
    return O2.type === "ImportExpression" && (fe2 = [O2.source], O2.attributes && fe2.push(O2.attributes)), xe2.set(O2, fe2), fe2;
  }
  function we2(O2, fe2) {
    let Te2 = O2.getValue();
    Te2.type === "ImportExpression" ? (O2.call(($e2) => fe2($e2, 0), "source"), Te2.attributes && O2.call(($e2) => fe2($e2, 1), "attributes")) : O2.each(fe2, "arguments");
  }
  function je2(O2) {
    return O2.value.trim() === "prettier-ignore" && !O2.unignore;
  }
  function Re2(O2) {
    return O2 && (O2.prettierIgnore || se(O2, Le2.PrettierIgnore));
  }
  function be2(O2) {
    let fe2 = O2.getValue();
    return Re2(fe2);
  }
  var Le2 = { Leading: 1 << 1, Trailing: 1 << 2, Dangling: 1 << 3, Block: 1 << 4, Line: 1 << 5, PrettierIgnore: 1 << 6, First: 1 << 7, Last: 1 << 8 }, qe2 = (O2, fe2) => {
    if (typeof O2 == "function" && (fe2 = O2, O2 = 0), O2 || fe2)
      return (Te2, $e2, Je2) => !(O2 & Le2.Leading && !Te2.leading || O2 & Le2.Trailing && !Te2.trailing || O2 & Le2.Dangling && (Te2.leading || Te2.trailing) || O2 & Le2.Block && !d4(Te2) || O2 & Le2.Line && !C2(Te2) || O2 & Le2.First && $e2 !== 0 || O2 & Le2.Last && $e2 !== Je2.length - 1 || O2 & Le2.PrettierIgnore && !je2(Te2) || fe2 && !fe2(Te2));
  };
  function se(O2, fe2, Te2) {
    if (!u(O2 == null ? void 0 : O2.comments))
      return false;
    let $e2 = qe2(fe2, Te2);
    return $e2 ? O2.comments.some($e2) : true;
  }
  function He2(O2, fe2, Te2) {
    if (!Array.isArray(O2 == null ? void 0 : O2.comments))
      return [];
    let $e2 = qe2(fe2, Te2);
    return $e2 ? O2.comments.filter($e2) : O2.comments;
  }
  var Me2 = (O2, fe2) => {
    let { originalText: Te2 } = fe2;
    return i2(Te2, y(O2));
  };
  function ze(O2) {
    return ue2(O2) || O2.type === "NewExpression" || O2.type === "ImportExpression";
  }
  function nt(O2) {
    return O2 && (O2.type === "ObjectProperty" || O2.type === "Property" && !O2.method && O2.kind === "init");
  }
  function tt(O2) {
    return Boolean(O2.__isUsingHackPipeline);
  }
  var pt2 = Symbol("ifWithoutBlockAndSameLineComment");
  n.exports = { getFunctionParameters: Se2, iterateFunctionParametersPath: Qe, getCallArguments: Xe2, iterateCallArgumentsPath: we2, hasRestParameter: Be, getLeftSide: I2, getLeftSidePathName: k2, getParentExportDeclaration: g2, getTypeScriptMappedTypeModifier: G, hasFlowAnnotationComment: A2, hasFlowShorthandAnnotationComment: T2, hasLeadingOwnLineComment: U, hasNakedLeftSide: B, hasNode: S2, hasIgnoreComment: be2, hasNodeIgnoreComment: Re2, identity: K, isBinaryish: H3, isCallLikeExpression: ze, isEnabledHackPipeline: tt, isLineComment: C2, isPrettierIgnoreComment: je2, isCallExpression: ue2, isMemberExpression: De2, isExportDeclaration: D2, isFlowAnnotationComment: z, isFunctionCompositionArgs: pe, isFunctionNotation: V, isFunctionOrArrowExpression: x2, isGetterOrSetter: $, isJestEachTemplateLiteral: Ae2, isJsxNode: M2, isLiteral: F, isLongCurriedCallExpression: de2, isSimpleCallArgument: ae2, isMemberish: R, isNumericLiteral: l, isSignedNumericLiteral: E, isObjectProperty: nt, isObjectType: N, isObjectTypePropertyAFunction: q, isSimpleType: ee2, isSimpleNumber: ge2, isSimpleTemplateLiteral: ie, isStringLiteral: v, isStringPropSafeToUnquote: le2, isTemplateOnItsOwnLine: ke2, isTestCall: X3, isTheOnlyJsxElementInMarkdown: j, isTSXFile: he2, isTypeAnnotationAFunction: Y3, isNextLineEmpty: Me2, needsHardlineAfterDanglingComment: ce, rawText: ve2, shouldPrintComma: ye2, isBitwiseOperator: We2, shouldFlatten: _, startsWithNoLookaheadToken: Ce2, getPrecedence: ne, hasComment: se, getComments: He2, CommentCheckFlags: Le2, markerForIfWithoutBlockAndSameLineComment: pt2 };
} }), kt$2 = Z({ "src/language-js/print/template-literal.js"(e, n) {
  re();
  var t = it$2(), { getStringWidth: s2, getIndentSize: a3 } = Ue$2(), { builders: { join: r, hardline: u, softline: i2, group: o, indent: c, align: y, lineSuffixBoundary: m2, addAlignmentToDoc: d4 }, printer: { printDocToString: p }, utils: { mapDoc: f } } = Oe(), { isBinaryish: h2, isJestEachTemplateLiteral: w2, isSimpleTemplateLiteral: T2, hasComment: A2, isMemberExpression: S2 } = Ke$1();
  function B(g2, F, l) {
    let E = g2.getValue();
    if (E.type === "TemplateLiteral" && w2(E, g2.getParentNode())) {
      let M2 = I2(g2, l, F);
      if (M2)
        return M2;
    }
    let N = "expressions";
    E.type === "TSTemplateLiteralType" && (N = "types");
    let x2 = [], b2 = g2.map(F, N), L = T2(E);
    return L && (b2 = b2.map((M2) => p(M2, Object.assign(Object.assign({}, l), {}, { printWidth: Number.POSITIVE_INFINITY })).formatted)), x2.push(m2, "`"), g2.each((M2) => {
      let j = M2.getName();
      if (x2.push(F()), j < b2.length) {
        let { tabWidth: $ } = l, V = M2.getValue(), q = a3(V.value.raw, $), Y3 = b2[j];
        if (!L) {
          let R = E[N][j];
          (A2(R) || S2(R) || R.type === "ConditionalExpression" || R.type === "SequenceExpression" || R.type === "TSAsExpression" || h2(R)) && (Y3 = [c([i2, Y3]), i2]);
        }
        let H3 = q === 0 && V.value.raw.endsWith(`
`) ? y(Number.NEGATIVE_INFINITY, Y3) : d4(Y3, q, $);
        x2.push(o(["${", H3, m2, "}"]));
      }
    }, "quasis"), x2.push("`"), x2;
  }
  function I2(g2, F, l) {
    let E = g2.getNode(), v = E.quasis[0].value.raw.trim().split(/\s*\|\s*/);
    if (v.length > 1 || v.some((N) => N.length > 0)) {
      F.__inJestEach = true;
      let N = g2.map(l, "expressions");
      F.__inJestEach = false;
      let x2 = [], b2 = N.map((V) => "${" + p(V, Object.assign(Object.assign({}, F), {}, { printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" })).formatted + "}"), L = [{ hasLineBreak: false, cells: [] }];
      for (let V = 1; V < E.quasis.length; V++) {
        let q = t(L), Y3 = b2[V - 1];
        q.cells.push(Y3), Y3.includes(`
`) && (q.hasLineBreak = true), E.quasis[V].value.raw.includes(`
`) && L.push({ hasLineBreak: false, cells: [] });
      }
      let M2 = Math.max(v.length, ...L.map((V) => V.cells.length)), j = Array.from({ length: M2 }).fill(0), $ = [{ cells: v }, ...L.filter((V) => V.cells.length > 0)];
      for (let { cells: V } of $.filter((q) => !q.hasLineBreak))
        for (let [q, Y3] of V.entries())
          j[q] = Math.max(j[q], s2(Y3));
      return x2.push(m2, "`", c([u, r(u, $.map((V) => r(" | ", V.cells.map((q, Y3) => V.hasLineBreak ? q : q + " ".repeat(j[Y3] - s2(q))))))]), u, "`"), x2;
    }
  }
  function k2(g2, F) {
    let l = g2.getValue(), E = F();
    return A2(l) && (E = o([c([i2, E]), i2])), ["${", E, m2, "}"];
  }
  function P(g2, F) {
    return g2.map((l) => k2(l, F), "expressions");
  }
  function C2(g2, F) {
    return f(g2, (l) => typeof l == "string" ? F ? l.replace(/(\\*)`/g, "$1$1\\`") : D2(l) : l);
  }
  function D2(g2) {
    return g2.replace(/([\\`]|\${)/g, "\\$1");
  }
  n.exports = { printTemplateLiteral: B, printTemplateExpressions: P, escapeTemplateCharacters: C2, uncookTemplateElementValue: D2 };
} }), Fm = Z({ "src/language-js/embed/markdown.js"(e, n) {
  re();
  var { builders: { indent: t, softline: s2, literalline: a3, dedentToRoot: r } } = Oe(), { escapeTemplateCharacters: u } = kt$2();
  function i2(c, y, m2) {
    let p = c.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (T2, A2) => "\\".repeat(A2.length / 2) + "`"), f = o(p), h2 = f !== "";
    h2 && (p = p.replace(new RegExp("^".concat(f), "gm"), ""));
    let w2 = u(m2(p, { parser: "markdown", __inJsTemplate: true }, { stripTrailingHardline: true }), true);
    return ["`", h2 ? t([s2, w2]) : [a3, r(w2)], s2, "`"];
  }
  function o(c) {
    let y = c.match(/^([^\S\n]*)\S/m);
    return y === null ? "" : y[1];
  }
  n.exports = i2;
} }), Am = Z({ "src/language-js/embed/css.js"(e, n) {
  re();
  var { isNonEmptyArray: t } = Ue$2(), { builders: { indent: s2, hardline: a3, softline: r }, utils: { mapDoc: u, replaceEndOfLine: i2, cleanDoc: o } } = Oe(), { printTemplateExpressions: c } = kt$2();
  function y(p, f, h2) {
    let w2 = p.getValue(), T2 = w2.quasis.map((k2) => k2.value.raw), A2 = 0, S2 = T2.reduce((k2, P, C2) => C2 === 0 ? P : k2 + "@prettier-placeholder-" + A2++ + "-id" + P, ""), B = h2(S2, { parser: "scss" }, { stripTrailingHardline: true }), I2 = c(p, f);
    return m2(B, w2, I2);
  }
  function m2(p, f, h2) {
    if (f.quasis.length === 1 && !f.quasis[0].value.raw.trim())
      return "``";
    let T2 = d4(p, h2);
    if (!T2)
      throw new Error("Couldn't insert all the expressions");
    return ["`", s2([a3, T2]), r, "`"];
  }
  function d4(p, f) {
    if (!t(f))
      return p;
    let h2 = 0, w2 = u(o(p), (T2) => typeof T2 != "string" || !T2.includes("@prettier-placeholder") ? T2 : T2.split(/@prettier-placeholder-(\d+)-id/).map((A2, S2) => S2 % 2 === 0 ? i2(A2) : (h2++, f[A2])));
    return f.length === h2 ? w2 : null;
  }
  n.exports = y;
} }), Sm = Z({ "src/language-js/embed/graphql.js"(e, n) {
  re();
  var { builders: { indent: t, join: s2, hardline: a3 } } = Oe(), { escapeTemplateCharacters: r, printTemplateExpressions: u } = kt$2();
  function i2(c, y, m2) {
    let d4 = c.getValue(), p = d4.quasis.length;
    if (p === 1 && d4.quasis[0].value.raw.trim() === "")
      return "``";
    let f = u(c, y), h2 = [];
    for (let w2 = 0; w2 < p; w2++) {
      let T2 = d4.quasis[w2], A2 = w2 === 0, S2 = w2 === p - 1, B = T2.value.cooked, I2 = B.split(`
`), k2 = I2.length, P = f[w2], C2 = k2 > 2 && I2[0].trim() === "" && I2[1].trim() === "", D2 = k2 > 2 && I2[k2 - 1].trim() === "" && I2[k2 - 2].trim() === "", g2 = I2.every((l) => /^\s*(?:#[^\n\r]*)?$/.test(l));
      if (!S2 && /#[^\n\r]*$/.test(I2[k2 - 1]))
        return null;
      let F = null;
      g2 ? F = o(I2) : F = m2(B, { parser: "graphql" }, { stripTrailingHardline: true }), F ? (F = r(F, false), !A2 && C2 && h2.push(""), h2.push(F), !S2 && D2 && h2.push("")) : !A2 && !S2 && C2 && h2.push(""), P && h2.push(P);
    }
    return ["`", t([a3, s2(a3, h2)]), a3, "`"];
  }
  function o(c) {
    let y = [], m2 = false, d4 = c.map((p) => p.trim());
    for (let [p, f] of d4.entries())
      f !== "" && (d4[p - 1] === "" && m2 ? y.push([a3, f]) : y.push(f), m2 = true);
    return y.length === 0 ? null : s2(a3, y);
  }
  n.exports = i2;
} }), xm = Z({ "src/language-js/embed/html.js"(e, n) {
  re();
  var { builders: { indent: t, line: s2, hardline: a3, group: r }, utils: { mapDoc: u } } = Oe(), { printTemplateExpressions: i2, uncookTemplateElementValue: o } = kt$2(), c = 0;
  function y(m2, d4, p, f, h2) {
    let { parser: w2 } = h2, T2 = m2.getValue(), A2 = c;
    c = c + 1 >>> 0;
    let S2 = (E) => "PRETTIER_HTML_PLACEHOLDER_".concat(E, "_").concat(A2, "_IN_JS"), B = T2.quasis.map((E, v, N) => v === N.length - 1 ? E.value.cooked : E.value.cooked + S2(v)).join(""), I2 = i2(m2, d4);
    if (I2.length === 0 && B.trim().length === 0)
      return "``";
    let k2 = new RegExp(S2("(\\d+)"), "g"), P = 0, C2 = p(B, { parser: w2, __onHtmlRoot(E) {
      P = E.children.length;
    } }, { stripTrailingHardline: true }), D2 = u(C2, (E) => {
      if (typeof E != "string")
        return E;
      let v = [], N = E.split(k2);
      for (let x2 = 0; x2 < N.length; x2++) {
        let b2 = N[x2];
        if (x2 % 2 === 0) {
          b2 && (b2 = o(b2), f.__embeddedInHtml && (b2 = b2.replace(/<\/(script)\b/gi, "<\\/$1")), v.push(b2));
          continue;
        }
        let L = Number(b2);
        v.push(I2[L]);
      }
      return v;
    }), g2 = /^\s/.test(B) ? " " : "", F = /\s$/.test(B) ? " " : "", l = f.htmlWhitespaceSensitivity === "ignore" ? a3 : g2 && F ? s2 : null;
    return r(l ? ["`", t([l, r(D2)]), l, "`"] : ["`", g2, P > 1 ? t(r(D2)) : r(D2), F, "`"]);
  }
  n.exports = y;
} }), bm = Z({ "src/language-js/embed.js"(e, n) {
  re();
  var { hasComment: t, CommentCheckFlags: s2, isObjectProperty: a3 } = Ke$1(), r = Fm(), u = Am(), i2 = Sm(), o = xm();
  function c(C2) {
    if (d4(C2) || w2(C2) || T2(C2) || p(C2))
      return "css";
    if (B(C2))
      return "graphql";
    if (k2(C2))
      return "html";
    if (f(C2))
      return "angular";
    if (m2(C2))
      return "markdown";
  }
  function y(C2, D2, g2, F) {
    let l = C2.getValue();
    if (l.type !== "TemplateLiteral" || P(l))
      return;
    let E = c(C2);
    if (!!E) {
      if (E === "markdown")
        return r(C2, D2, g2);
      if (E === "css")
        return u(C2, D2, g2);
      if (E === "graphql")
        return i2(C2, D2, g2);
      if (E === "html" || E === "angular")
        return o(C2, D2, g2, F, { parser: E });
    }
  }
  function m2(C2) {
    let D2 = C2.getValue(), g2 = C2.getParentNode();
    return g2 && g2.type === "TaggedTemplateExpression" && D2.quasis.length === 1 && g2.tag.type === "Identifier" && (g2.tag.name === "md" || g2.tag.name === "markdown");
  }
  function d4(C2) {
    let D2 = C2.getValue(), g2 = C2.getParentNode(), F = C2.getParentNode(1);
    return F && D2.quasis && g2.type === "JSXExpressionContainer" && F.type === "JSXElement" && F.openingElement.name.name === "style" && F.openingElement.attributes.some((l) => l.name.name === "jsx") || g2 && g2.type === "TaggedTemplateExpression" && g2.tag.type === "Identifier" && g2.tag.name === "css" || g2 && g2.type === "TaggedTemplateExpression" && g2.tag.type === "MemberExpression" && g2.tag.object.name === "css" && (g2.tag.property.name === "global" || g2.tag.property.name === "resolve");
  }
  function p(C2) {
    return C2.match((D2) => D2.type === "TemplateLiteral", (D2, g2) => D2.type === "ArrayExpression" && g2 === "elements", (D2, g2) => a3(D2) && D2.key.type === "Identifier" && D2.key.name === "styles" && g2 === "value", ...h2);
  }
  function f(C2) {
    return C2.match((D2) => D2.type === "TemplateLiteral", (D2, g2) => a3(D2) && D2.key.type === "Identifier" && D2.key.name === "template" && g2 === "value", ...h2);
  }
  var h2 = [(C2, D2) => C2.type === "ObjectExpression" && D2 === "properties", (C2, D2) => C2.type === "CallExpression" && C2.callee.type === "Identifier" && C2.callee.name === "Component" && D2 === "arguments", (C2, D2) => C2.type === "Decorator" && D2 === "expression"];
  function w2(C2) {
    let D2 = C2.getParentNode();
    if (!D2 || D2.type !== "TaggedTemplateExpression")
      return false;
    let g2 = D2.tag.type === "ParenthesizedExpression" ? D2.tag.expression : D2.tag;
    switch (g2.type) {
      case "MemberExpression":
        return A2(g2.object) || S2(g2);
      case "CallExpression":
        return A2(g2.callee) || g2.callee.type === "MemberExpression" && (g2.callee.object.type === "MemberExpression" && (A2(g2.callee.object.object) || S2(g2.callee.object)) || g2.callee.object.type === "CallExpression" && A2(g2.callee.object.callee));
      case "Identifier":
        return g2.name === "css";
      default:
        return false;
    }
  }
  function T2(C2) {
    let D2 = C2.getParentNode(), g2 = C2.getParentNode(1);
    return g2 && D2.type === "JSXExpressionContainer" && g2.type === "JSXAttribute" && g2.name.type === "JSXIdentifier" && g2.name.name === "css";
  }
  function A2(C2) {
    return C2.type === "Identifier" && C2.name === "styled";
  }
  function S2(C2) {
    return /^[A-Z]/.test(C2.object.name) && C2.property.name === "extend";
  }
  function B(C2) {
    let D2 = C2.getValue(), g2 = C2.getParentNode();
    return I2(D2, "GraphQL") || g2 && (g2.type === "TaggedTemplateExpression" && (g2.tag.type === "MemberExpression" && g2.tag.object.name === "graphql" && g2.tag.property.name === "experimental" || g2.tag.type === "Identifier" && (g2.tag.name === "gql" || g2.tag.name === "graphql")) || g2.type === "CallExpression" && g2.callee.type === "Identifier" && g2.callee.name === "graphql");
  }
  function I2(C2, D2) {
    return t(C2, s2.Block | s2.Leading, (g2) => {
      let { value: F } = g2;
      return F === " ".concat(D2, " ");
    });
  }
  function k2(C2) {
    return I2(C2.getValue(), "HTML") || C2.match((D2) => D2.type === "TemplateLiteral", (D2, g2) => D2.type === "TaggedTemplateExpression" && D2.tag.type === "Identifier" && D2.tag.name === "html" && g2 === "quasi");
  }
  function P(C2) {
    let { quasis: D2 } = C2;
    return D2.some((g2) => {
      let { value: { cooked: F } } = g2;
      return F === null;
    });
  }
  n.exports = y;
} }), Tm = Z({ "src/language-js/clean.js"(e, n) {
  re();
  var t = Pt$1(), s2 = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), a3 = (u) => {
    for (let i2 of u.quasis)
      delete i2.value;
  };
  function r(u, i2, o) {
    if (u.type === "Program" && delete i2.sourceType, (u.type === "BigIntLiteral" || u.type === "BigIntLiteralTypeAnnotation") && i2.value && (i2.value = i2.value.toLowerCase()), (u.type === "BigIntLiteral" || u.type === "Literal") && i2.bigint && (i2.bigint = i2.bigint.toLowerCase()), u.type === "DecimalLiteral" && (i2.value = Number(i2.value)), u.type === "Literal" && i2.decimal && (i2.decimal = Number(i2.decimal)), u.type === "EmptyStatement" || u.type === "JSXText" || u.type === "JSXExpressionContainer" && (u.expression.type === "Literal" || u.expression.type === "StringLiteral") && u.expression.value === " ")
      return null;
    if ((u.type === "Property" || u.type === "ObjectProperty" || u.type === "MethodDefinition" || u.type === "ClassProperty" || u.type === "ClassMethod" || u.type === "PropertyDefinition" || u.type === "TSDeclareMethod" || u.type === "TSPropertySignature" || u.type === "ObjectTypeProperty") && typeof u.key == "object" && u.key && (u.key.type === "Literal" || u.key.type === "NumericLiteral" || u.key.type === "StringLiteral" || u.key.type === "Identifier") && delete i2.key, u.type === "JSXElement" && u.openingElement.name.name === "style" && u.openingElement.attributes.some((m2) => m2.name.name === "jsx"))
      for (let { type: m2, expression: d4 } of i2.children)
        m2 === "JSXExpressionContainer" && d4.type === "TemplateLiteral" && a3(d4);
    u.type === "JSXAttribute" && u.name.name === "css" && u.value.type === "JSXExpressionContainer" && u.value.expression.type === "TemplateLiteral" && a3(i2.value.expression), u.type === "JSXAttribute" && u.value && u.value.type === "Literal" && /["']|&quot;|&apos;/.test(u.value.value) && (i2.value.value = i2.value.value.replace(/["']|&quot;|&apos;/g, '"'));
    let c = u.expression || u.callee;
    if (u.type === "Decorator" && c.type === "CallExpression" && c.callee.name === "Component" && c.arguments.length === 1) {
      let m2 = u.expression.arguments[0].properties;
      for (let [d4, p] of i2.expression.arguments[0].properties.entries())
        switch (m2[d4].key.name) {
          case "styles":
            p.value.type === "ArrayExpression" && a3(p.value.elements[0]);
            break;
          case "template":
            p.value.type === "TemplateLiteral" && a3(p.value);
            break;
        }
    }
    if (u.type === "TaggedTemplateExpression" && (u.tag.type === "MemberExpression" || u.tag.type === "Identifier" && (u.tag.name === "gql" || u.tag.name === "graphql" || u.tag.name === "css" || u.tag.name === "md" || u.tag.name === "markdown" || u.tag.name === "html") || u.tag.type === "CallExpression") && a3(i2.quasi), u.type === "TemplateLiteral") {
      var y;
      (((y = u.leadingComments) === null || y === void 0 ? void 0 : y.some((d4) => t(d4) && ["GraphQL", "HTML"].some((p) => d4.value === " ".concat(p, " ")))) || o.type === "CallExpression" && o.callee.name === "graphql" || !u.leadingComments) && a3(i2);
    }
    if (u.type === "InterpreterDirective" && (i2.value = i2.value.trimEnd()), (u.type === "TSIntersectionType" || u.type === "TSUnionType") && u.types.length === 1)
      return i2.types[0];
  }
  r.ignoredProperties = s2, n.exports = r;
} }), Oa = {};
Gt(Oa, { EOL: () => Nn, arch: () => Bm, cpus: () => Ha, default: () => Xa, endianness: () => qa, freemem: () => Wa, getNetworkInterfaces: () => za, hostname: () => Ma, loadavg: () => Ra, networkInterfaces: () => Ua, platform: () => Nm, release: () => Ja, tmpDir: () => Tn$1, tmpdir: () => Bn, totalmem: () => $a, type: () => Ga$1, uptime: () => Va });
function qa() {
  if (typeof Fr > "u") {
    var e = new ArrayBuffer(2), n = new Uint8Array(e), t = new Uint16Array(e);
    if (n[0] = 1, n[1] = 2, t[0] === 258)
      Fr = "BE";
    else if (t[0] === 513)
      Fr = "LE";
    else
      throw new Error("unable to figure out endianess");
  }
  return Fr;
}
function Ma() {
  return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
}
function Ra() {
  return [];
}
function Va() {
  return 0;
}
function Wa() {
  return Number.MAX_VALUE;
}
function $a() {
  return Number.MAX_VALUE;
}
function Ha() {
  return [];
}
function Ga$1() {
  return "Browser";
}
function Ja() {
  return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
}
function Ua() {
}
function za() {
}
function Bm() {
  return "javascript";
}
function Nm() {
  return "browser";
}
function Tn$1() {
  return "/tmp";
}
var Fr, Bn, Nn, Xa, wm = mt$1({ "node-modules-polyfills:os"() {
  re(), Bn = Tn$1, Nn = `
`, Xa = { EOL: Nn, tmpdir: Bn, tmpDir: Tn$1, networkInterfaces: Ua, getNetworkInterfaces: za, release: Ja, type: Ga$1, cpus: Ha, totalmem: $a, freemem: Wa, uptime: Va, loadavg: Ra, hostname: Ma, endianness: qa };
} }), _m = Z({ "node-modules-polyfills-commonjs:os"(e, n) {
  re();
  var t = (wm(), lt$1(Oa));
  if (t && t.default) {
    n.exports = t.default;
    for (let s2 in t)
      n.exports[s2] = t[s2];
  } else
    t && (n.exports = t);
} }), Pm = Z({ "node_modules/detect-newline/index.js"(e, n) {
  re();
  var t = (s2) => {
    if (typeof s2 != "string")
      throw new TypeError("Expected a string");
    let a3 = s2.match(/(?:\r?\n)/g) || [];
    if (a3.length === 0)
      return;
    let r = a3.filter((i2) => i2 === `\r
`).length, u = a3.length - r;
    return r > u ? `\r
` : `
`;
  };
  n.exports = t, n.exports.graceful = (s2) => typeof s2 == "string" && t(s2) || `
`;
} }), km = Z({ "node_modules/jest-docblock/build/index.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true }), e.extract = p, e.parse = h2, e.parseWithComments = w2, e.print = T2, e.strip = f;
  function n() {
    let S2 = _m();
    return n = function() {
      return S2;
    }, S2;
  }
  function t() {
    let S2 = s2(Pm());
    return t = function() {
      return S2;
    }, S2;
  }
  function s2(S2) {
    return S2 && S2.__esModule ? S2 : { default: S2 };
  }
  var a3 = /\*\/$/, r = /^\/\*\*/, u = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, i2 = /(^|\s+)\/\/([^\r\n]*)/g, o = /^(\r?\n)+/, c = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, y = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, m2 = /(\r?\n|^) *\* ?/g, d4 = [];
  function p(S2) {
    let B = S2.match(u);
    return B ? B[0].trimLeft() : "";
  }
  function f(S2) {
    let B = S2.match(u);
    return B && B[0] ? S2.substring(B[0].length) : S2;
  }
  function h2(S2) {
    return w2(S2).pragmas;
  }
  function w2(S2) {
    let B = (0, t().default)(S2) || n().EOL;
    S2 = S2.replace(r, "").replace(a3, "").replace(m2, "$1");
    let I2 = "";
    for (; I2 !== S2; )
      I2 = S2, S2 = S2.replace(c, "".concat(B, "$1 $2").concat(B));
    S2 = S2.replace(o, "").trimRight();
    let k2 = /* @__PURE__ */ Object.create(null), P = S2.replace(y, "").replace(o, "").trimRight(), C2;
    for (; C2 = y.exec(S2); ) {
      let D2 = C2[2].replace(i2, "");
      typeof k2[C2[1]] == "string" || Array.isArray(k2[C2[1]]) ? k2[C2[1]] = d4.concat(k2[C2[1]], D2) : k2[C2[1]] = D2;
    }
    return { comments: P, pragmas: k2 };
  }
  function T2(S2) {
    let { comments: B = "", pragmas: I2 = {} } = S2, k2 = (0, t().default)(B) || n().EOL, P = "/**", C2 = " *", D2 = " */", g2 = Object.keys(I2), F = g2.map((E) => A2(E, I2[E])).reduce((E, v) => E.concat(v), []).map((E) => C2 + " " + E + k2).join("");
    if (!B) {
      if (g2.length === 0)
        return "";
      if (g2.length === 1 && !Array.isArray(I2[g2[0]])) {
        let E = I2[g2[0]];
        return "".concat(P, " ").concat(A2(g2[0], E)[0]).concat(D2);
      }
    }
    let l = B.split(k2).map((E) => "".concat(C2, " ").concat(E)).join(k2) + k2;
    return P + k2 + (B ? l : "") + (B && g2.length ? C2 + k2 : "") + F + D2;
  }
  function A2(S2, B) {
    return d4.concat(B).map((I2) => "@".concat(S2, " ").concat(I2).trim());
  }
} }), Im = Z({ "src/language-js/utils/get-shebang.js"(e, n) {
  re();
  function t(s2) {
    if (!s2.startsWith("#!"))
      return "";
    let a3 = s2.indexOf(`
`);
    return a3 === -1 ? s2 : s2.slice(0, a3);
  }
  n.exports = t;
} }), Ka$1 = Z({ "src/language-js/pragma.js"(e, n) {
  re();
  var { parseWithComments: t, strip: s2, extract: a3, print: r } = km(), { normalizeEndOfLine: u } = kn$2(), i2 = Im();
  function o(m2) {
    let d4 = i2(m2);
    d4 && (m2 = m2.slice(d4.length + 1));
    let p = a3(m2), { pragmas: f, comments: h2 } = t(p);
    return { shebang: d4, text: m2, pragmas: f, comments: h2 };
  }
  function c(m2) {
    let d4 = Object.keys(o(m2).pragmas);
    return d4.includes("prettier") || d4.includes("format");
  }
  function y(m2) {
    let { shebang: d4, text: p, pragmas: f, comments: h2 } = o(m2), w2 = s2(p), T2 = r({ pragmas: Object.assign({ format: "" }, f), comments: h2.trimStart() });
    return (d4 ? "".concat(d4, `
`) : "") + u(T2) + (w2.startsWith(`
`) ? `
` : `

`) + w2;
  }
  n.exports = { hasPragma: c, insertPragma: y };
} }), Ya$1 = Z({ "src/language-js/comments.js"(e, n) {
  re();
  var { getLast: t, hasNewline: s2, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: a3, getNextNonSpaceNonCommentCharacter: r, hasNewlineInRange: u, addLeadingComment: i2, addTrailingComment: o, addDanglingComment: c, getNextNonSpaceNonCommentCharacterIndex: y, isNonEmptyArray: m2 } = Ue$2(), { getFunctionParameters: d4, isPrettierIgnoreComment: p, isJsxNode: f, hasFlowShorthandAnnotationComment: h2, hasFlowAnnotationComment: w2, hasIgnoreComment: T2, isCallLikeExpression: A2, getCallArguments: S2, isCallExpression: B, isMemberExpression: I2, isObjectProperty: k2, isLineComment: P, getComments: C2, CommentCheckFlags: D2, markerForIfWithoutBlockAndSameLineComment: g2 } = Ke$1(), { locStart: F, locEnd: l } = st$1(), E = Pt$1();
  function v(me2) {
    return [ve2, De2, q, j, $, V, Q, Ae2, U, ge2, Ne2, ke2, te2, ie, G].some((_) => _(me2));
  }
  function N(me2) {
    return [M2, De2, Y3, Ne2, j, $, V, Q, ie, z, le2, ge2, de2, G, he2].some((_) => _(me2));
  }
  function x2(me2) {
    return [ve2, j, $, H3, ue2, te2, ge2, X3, W2, K, G, ae2].some((_) => _(me2));
  }
  function b2(me2, _) {
    let J2 = (me2.body || me2.properties).find((ne) => {
      let { type: Ee } = ne;
      return Ee !== "EmptyStatement";
    });
    J2 ? i2(J2, _) : c(me2, _);
  }
  function L(me2, _) {
    me2.type === "BlockStatement" ? b2(me2, _) : i2(me2, _);
  }
  function M2(me2) {
    let { comment: _, followingNode: J2 } = me2;
    return J2 && Ie2(_) ? (i2(J2, _), true) : false;
  }
  function j(me2) {
    let { comment: _, precedingNode: J2, enclosingNode: ne, followingNode: Ee, text: We2 } = me2;
    if ((ne == null ? void 0 : ne.type) !== "IfStatement" || !Ee)
      return false;
    if (r(We2, _, l) === ")")
      return o(J2, _), true;
    if (J2 === ne.consequent && Ee === ne.alternate) {
      if (J2.type === "BlockStatement")
        o(J2, _);
      else {
        let Pe2 = _.type === "SingleLine" || _.loc.start.line === _.loc.end.line, Se2 = _.loc.start.line === J2.loc.start.line;
        Pe2 && Se2 ? c(J2, _, g2) : c(ne, _);
      }
      return true;
    }
    return Ee.type === "BlockStatement" ? (b2(Ee, _), true) : Ee.type === "IfStatement" ? (L(Ee.consequent, _), true) : ne.consequent === Ee ? (i2(Ee, _), true) : false;
  }
  function $(me2) {
    let { comment: _, precedingNode: J2, enclosingNode: ne, followingNode: Ee, text: We2 } = me2;
    return (ne == null ? void 0 : ne.type) !== "WhileStatement" || !Ee ? false : r(We2, _, l) === ")" ? (o(J2, _), true) : Ee.type === "BlockStatement" ? (b2(Ee, _), true) : ne.body === Ee ? (i2(Ee, _), true) : false;
  }
  function V(me2) {
    let { comment: _, precedingNode: J2, enclosingNode: ne, followingNode: Ee } = me2;
    return (ne == null ? void 0 : ne.type) !== "TryStatement" && (ne == null ? void 0 : ne.type) !== "CatchClause" || !Ee ? false : ne.type === "CatchClause" && J2 ? (o(J2, _), true) : Ee.type === "BlockStatement" ? (b2(Ee, _), true) : Ee.type === "TryStatement" ? (L(Ee.finalizer, _), true) : Ee.type === "CatchClause" ? (L(Ee.body, _), true) : false;
  }
  function q(me2) {
    let { comment: _, enclosingNode: J2, followingNode: ne } = me2;
    return I2(J2) && (ne == null ? void 0 : ne.type) === "Identifier" ? (i2(J2, _), true) : false;
  }
  function Y3(me2) {
    let { comment: _, precedingNode: J2, enclosingNode: ne, followingNode: Ee, text: We2 } = me2, Be = J2 && !u(We2, l(J2), F(_));
    return (!J2 || !Be) && ((ne == null ? void 0 : ne.type) === "ConditionalExpression" || (ne == null ? void 0 : ne.type) === "TSConditionalType") && Ee ? (i2(Ee, _), true) : false;
  }
  function H3(me2) {
    let { comment: _, precedingNode: J2, enclosingNode: ne } = me2;
    return k2(ne) && ne.shorthand && ne.key === J2 && ne.value.type === "AssignmentPattern" ? (o(ne.value.left, _), true) : false;
  }
  var R = /* @__PURE__ */ new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
  function Q(me2) {
    let { comment: _, precedingNode: J2, enclosingNode: ne, followingNode: Ee } = me2;
    if (R.has(ne == null ? void 0 : ne.type)) {
      if (m2(ne.decorators) && !(Ee && Ee.type === "Decorator"))
        return o(t(ne.decorators), _), true;
      if (ne.body && Ee === ne.body)
        return b2(ne.body, _), true;
      if (Ee) {
        if (ne.superClass && Ee === ne.superClass && J2 && (J2 === ne.id || J2 === ne.typeParameters))
          return o(J2, _), true;
        for (let We2 of ["implements", "extends", "mixins"])
          if (ne[We2] && Ee === ne[We2][0])
            return J2 && (J2 === ne.id || J2 === ne.typeParameters || J2 === ne.superClass) ? o(J2, _) : c(ne, _, We2), true;
      }
    }
    return false;
  }
  var ee2 = /* @__PURE__ */ new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition"]);
  function te2(me2) {
    let { comment: _, precedingNode: J2, enclosingNode: ne, text: Ee } = me2;
    return ne && J2 && r(Ee, _, l) === "(" && (ne.type === "Property" || ne.type === "TSDeclareMethod" || ne.type === "TSAbstractMethodDefinition") && J2.type === "Identifier" && ne.key === J2 && r(Ee, J2, l) !== ":" || (J2 == null ? void 0 : J2.type) === "Decorator" && ee2.has(ne == null ? void 0 : ne.type) ? (o(J2, _), true) : false;
  }
  var oe2 = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
  function W2(me2) {
    let { comment: _, precedingNode: J2, enclosingNode: ne, text: Ee } = me2;
    return r(Ee, _, l) !== "(" ? false : J2 && oe2.has(ne == null ? void 0 : ne.type) ? (o(J2, _), true) : false;
  }
  function X3(me2) {
    let { comment: _, enclosingNode: J2, text: ne } = me2;
    if ((J2 == null ? void 0 : J2.type) !== "ArrowFunctionExpression")
      return false;
    let Ee = y(ne, _, l);
    return Ee !== false && ne.slice(Ee, Ee + 2) === "=>" ? (c(J2, _), true) : false;
  }
  function ue2(me2) {
    let { comment: _, enclosingNode: J2, text: ne } = me2;
    return r(ne, _, l) !== ")" ? false : J2 && (ye2(J2) && d4(J2).length === 0 || A2(J2) && S2(J2).length === 0) ? (c(J2, _), true) : ((J2 == null ? void 0 : J2.type) === "MethodDefinition" || (J2 == null ? void 0 : J2.type) === "TSAbstractMethodDefinition") && d4(J2.value).length === 0 ? (c(J2.value, _), true) : false;
  }
  function De2(me2) {
    let { comment: _, precedingNode: J2, enclosingNode: ne, followingNode: Ee, text: We2 } = me2;
    if ((J2 == null ? void 0 : J2.type) === "FunctionTypeParam" && (ne == null ? void 0 : ne.type) === "FunctionTypeAnnotation" && (Ee == null ? void 0 : Ee.type) !== "FunctionTypeParam" || ((J2 == null ? void 0 : J2.type) === "Identifier" || (J2 == null ? void 0 : J2.type) === "AssignmentPattern") && ne && ye2(ne) && r(We2, _, l) === ")")
      return o(J2, _), true;
    if ((ne == null ? void 0 : ne.type) === "FunctionDeclaration" && (Ee == null ? void 0 : Ee.type) === "BlockStatement") {
      let Be = (() => {
        let Pe2 = d4(ne);
        if (Pe2.length > 0)
          return a3(We2, l(t(Pe2)));
        let Se2 = a3(We2, l(ne.id));
        return Se2 !== false && a3(We2, Se2 + 1);
      })();
      if (F(_) > Be)
        return b2(Ee, _), true;
    }
    return false;
  }
  function ie(me2) {
    let { comment: _, enclosingNode: J2 } = me2;
    return (J2 == null ? void 0 : J2.type) === "LabeledStatement" ? (i2(J2, _), true) : false;
  }
  function G(me2) {
    let { comment: _, enclosingNode: J2 } = me2;
    return ((J2 == null ? void 0 : J2.type) === "ContinueStatement" || (J2 == null ? void 0 : J2.type) === "BreakStatement") && !J2.label ? (o(J2, _), true) : false;
  }
  function z(me2) {
    let { comment: _, precedingNode: J2, enclosingNode: ne } = me2;
    return B(ne) && J2 && ne.callee === J2 && ne.arguments.length > 0 ? (i2(ne.arguments[0], _), true) : false;
  }
  function U(me2) {
    let { comment: _, precedingNode: J2, enclosingNode: ne, followingNode: Ee } = me2;
    return (ne == null ? void 0 : ne.type) === "UnionTypeAnnotation" || (ne == null ? void 0 : ne.type) === "TSUnionType" ? (p(_) && (Ee.prettierIgnore = true, _.unignore = true), J2 ? (o(J2, _), true) : false) : (((Ee == null ? void 0 : Ee.type) === "UnionTypeAnnotation" || (Ee == null ? void 0 : Ee.type) === "TSUnionType") && p(_) && (Ee.types[0].prettierIgnore = true, _.unignore = true), false);
  }
  function le2(me2) {
    let { comment: _, enclosingNode: J2 } = me2;
    return k2(J2) ? (i2(J2, _), true) : false;
  }
  function ge2(me2) {
    let { comment: _, enclosingNode: J2, followingNode: ne, ast: Ee, isLastComment: We2 } = me2;
    return Ee && Ee.body && Ee.body.length === 0 ? (We2 ? c(Ee, _) : i2(Ee, _), true) : (J2 == null ? void 0 : J2.type) === "Program" && (J2 == null ? void 0 : J2.body.length) === 0 && !m2(J2.directives) ? (We2 ? c(J2, _) : i2(J2, _), true) : (ne == null ? void 0 : ne.type) === "Program" && (ne == null ? void 0 : ne.body.length) === 0 && (J2 == null ? void 0 : J2.type) === "ModuleExpression" ? (c(ne, _), true) : false;
  }
  function Ae2(me2) {
    let { comment: _, enclosingNode: J2 } = me2;
    return (J2 == null ? void 0 : J2.type) === "ForInStatement" || (J2 == null ? void 0 : J2.type) === "ForOfStatement" ? (i2(J2, _), true) : false;
  }
  function Ne2(me2) {
    let { comment: _, precedingNode: J2, enclosingNode: ne, text: Ee } = me2;
    if ((ne == null ? void 0 : ne.type) === "ImportSpecifier" || (ne == null ? void 0 : ne.type) === "ExportSpecifier")
      return i2(ne, _), true;
    let We2 = (J2 == null ? void 0 : J2.type) === "ImportSpecifier" && (ne == null ? void 0 : ne.type) === "ImportDeclaration", Be = (J2 == null ? void 0 : J2.type) === "ExportSpecifier" && (ne == null ? void 0 : ne.type) === "ExportNamedDeclaration";
    return (We2 || Be) && s2(Ee, l(_)) ? (o(J2, _), true) : false;
  }
  function ke2(me2) {
    let { comment: _, enclosingNode: J2 } = me2;
    return (J2 == null ? void 0 : J2.type) === "AssignmentPattern" ? (i2(J2, _), true) : false;
  }
  var ce = /* @__PURE__ */ new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]), pe = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
  function de2(me2) {
    let { comment: _, enclosingNode: J2, followingNode: ne } = me2;
    return ce.has(J2 == null ? void 0 : J2.type) && ne && (pe.has(ne.type) || E(_)) ? (i2(ne, _), true) : false;
  }
  function ae2(me2) {
    let { comment: _, enclosingNode: J2, followingNode: ne, text: Ee } = me2;
    return !ne && ((J2 == null ? void 0 : J2.type) === "TSMethodSignature" || (J2 == null ? void 0 : J2.type) === "TSDeclareFunction" || (J2 == null ? void 0 : J2.type) === "TSAbstractMethodDefinition") && r(Ee, _, l) === ";" ? (o(J2, _), true) : false;
  }
  function ve2(me2) {
    let { comment: _, enclosingNode: J2, followingNode: ne } = me2;
    if (p(_) && (J2 == null ? void 0 : J2.type) === "TSMappedType" && (ne == null ? void 0 : ne.type) === "TSTypeParameter" && ne.constraint)
      return J2.prettierIgnore = true, _.unignore = true, true;
  }
  function K(me2) {
    let { comment: _, precedingNode: J2, enclosingNode: ne, followingNode: Ee } = me2;
    return (ne == null ? void 0 : ne.type) !== "TSMappedType" ? false : (Ee == null ? void 0 : Ee.type) === "TSTypeParameter" && Ee.name ? (i2(Ee.name, _), true) : (J2 == null ? void 0 : J2.type) === "TSTypeParameter" && J2.constraint ? (o(J2.constraint, _), true) : false;
  }
  function he2(me2) {
    let { comment: _, enclosingNode: J2, followingNode: ne } = me2;
    return !J2 || J2.type !== "SwitchCase" || J2.test ? false : (ne.type === "BlockStatement" && P(_) ? b2(ne, _) : c(J2, _), true);
  }
  function ye2(me2) {
    return me2.type === "ArrowFunctionExpression" || me2.type === "FunctionExpression" || me2.type === "FunctionDeclaration" || me2.type === "ObjectMethod" || me2.type === "ClassMethod" || me2.type === "TSDeclareFunction" || me2.type === "TSCallSignatureDeclaration" || me2.type === "TSConstructSignatureDeclaration" || me2.type === "TSMethodSignature" || me2.type === "TSConstructorType" || me2.type === "TSFunctionType" || me2.type === "TSDeclareMethod";
  }
  function Ce2(me2, _) {
    if ((_.parser === "typescript" || _.parser === "flow" || _.parser === "acorn" || _.parser === "espree" || _.parser === "meriyah" || _.parser === "__babel_estree") && me2.type === "MethodDefinition" && me2.value && me2.value.type === "FunctionExpression" && d4(me2.value).length === 0 && !me2.value.returnType && !m2(me2.value.typeParameters) && me2.value.body)
      return [...me2.decorators || [], me2.key, me2.value.body];
  }
  function Ie2(me2) {
    return E(me2) && me2.value[0] === "*" && /@type\b/.test(me2.value);
  }
  function Fe2(me2) {
    let _ = me2.getValue(), J2 = me2.getParentNode(), ne = (Ee) => w2(C2(Ee, D2.Leading)) || w2(C2(Ee, D2.Trailing));
    return (_ && (f(_) || h2(_) || B(J2) && ne(_)) || J2 && (J2.type === "JSXSpreadAttribute" || J2.type === "JSXSpreadChild" || J2.type === "UnionTypeAnnotation" || J2.type === "TSUnionType" || (J2.type === "ClassDeclaration" || J2.type === "ClassExpression") && J2.superClass === _)) && (!T2(me2) || J2.type === "UnionTypeAnnotation" || J2.type === "TSUnionType");
  }
  n.exports = { handleOwnLineComment: v, handleEndOfLineComment: N, handleRemainingComment: x2, isTypeCastComment: Ie2, getCommentChildNodes: Ce2, willPrintOwnComments: Fe2 };
} }), It$1 = Z({ "src/language-js/needs-parens.js"(e, n) {
  re();
  var t = it$2(), s2 = On$3(), { getFunctionParameters: a3, getLeftSidePathName: r, hasFlowShorthandAnnotationComment: u, hasNakedLeftSide: i2, hasNode: o, isBitwiseOperator: c, startsWithNoLookaheadToken: y, shouldFlatten: m2, getPrecedence: d4, isCallExpression: p, isMemberExpression: f, isObjectProperty: h2 } = Ke$1();
  function w2(P, C2) {
    let D2 = P.getParentNode();
    if (!D2)
      return false;
    let g2 = P.getName(), F = P.getNode();
    if (C2.__isInHtmlInterpolation && !C2.bracketSpacing && B(F) && I2(P))
      return true;
    if (T2(F))
      return false;
    if (C2.parser !== "flow" && u(P.getValue()))
      return true;
    if (F.type === "Identifier")
      return !!(F.extra && F.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(F.name) || g2 === "left" && F.name === "async" && D2.type === "ForOfStatement" && !D2.await);
    switch (D2.type) {
      case "ParenthesizedExpression":
        return false;
      case "ClassDeclaration":
      case "ClassExpression": {
        if (g2 === "superClass" && (F.type === "ArrowFunctionExpression" || F.type === "AssignmentExpression" || F.type === "AwaitExpression" || F.type === "BinaryExpression" || F.type === "ConditionalExpression" || F.type === "LogicalExpression" || F.type === "NewExpression" || F.type === "ObjectExpression" || F.type === "SequenceExpression" || F.type === "TaggedTemplateExpression" || F.type === "UnaryExpression" || F.type === "UpdateExpression" || F.type === "YieldExpression" || F.type === "TSNonNullExpression"))
          return true;
        break;
      }
      case "ExportDefaultDeclaration":
        return k2(P, C2) || F.type === "SequenceExpression";
      case "Decorator": {
        if (g2 === "expression") {
          let l = false, E = false, v = F;
          for (; v; )
            switch (v.type) {
              case "MemberExpression":
                E = true, v = v.object;
                break;
              case "CallExpression":
                if (E || l)
                  return C2.parser !== "typescript";
                l = true, v = v.callee;
                break;
              case "Identifier":
                return false;
              case "TaggedTemplateExpression":
                return C2.parser !== "typescript";
              default:
                return true;
            }
          return true;
        }
        break;
      }
      case "ExpressionStatement": {
        if (y(F, true))
          return true;
        break;
      }
      case "ArrowFunctionExpression": {
        if (g2 === "body" && F.type !== "SequenceExpression" && y(F, false))
          return true;
        break;
      }
    }
    switch (F.type) {
      case "UpdateExpression":
        if (D2.type === "UnaryExpression")
          return F.prefix && (F.operator === "++" && D2.operator === "+" || F.operator === "--" && D2.operator === "-");
      case "UnaryExpression":
        switch (D2.type) {
          case "UnaryExpression":
            return F.operator === D2.operator && (F.operator === "+" || F.operator === "-");
          case "BindExpression":
            return true;
          case "MemberExpression":
          case "OptionalMemberExpression":
            return g2 === "object";
          case "TaggedTemplateExpression":
            return true;
          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return g2 === "callee";
          case "BinaryExpression":
            return g2 === "left" && D2.operator === "**";
          case "TSNonNullExpression":
            return true;
          default:
            return false;
        }
      case "BinaryExpression": {
        if (D2.type === "UpdateExpression" || F.operator === "in" && A2(P))
          return true;
        if (F.operator === "|>" && F.extra && F.extra.parenthesized) {
          let l = P.getParentNode(1);
          if (l.type === "BinaryExpression" && l.operator === "|>")
            return true;
        }
      }
      case "TSTypeAssertion":
      case "TSAsExpression":
      case "LogicalExpression":
        switch (D2.type) {
          case "TSAsExpression":
            return F.type !== "TSAsExpression";
          case "ConditionalExpression":
            return F.type === "TSAsExpression";
          case "CallExpression":
          case "NewExpression":
          case "OptionalCallExpression":
            return g2 === "callee";
          case "ClassExpression":
          case "ClassDeclaration":
            return g2 === "superClass";
          case "TSTypeAssertion":
          case "TaggedTemplateExpression":
          case "UnaryExpression":
          case "JSXSpreadAttribute":
          case "SpreadElement":
          case "SpreadProperty":
          case "BindExpression":
          case "AwaitExpression":
          case "TSNonNullExpression":
          case "UpdateExpression":
            return true;
          case "MemberExpression":
          case "OptionalMemberExpression":
            return g2 === "object";
          case "AssignmentExpression":
          case "AssignmentPattern":
            return g2 === "left" && (F.type === "TSTypeAssertion" || F.type === "TSAsExpression");
          case "LogicalExpression":
            if (F.type === "LogicalExpression")
              return D2.operator !== F.operator;
          case "BinaryExpression": {
            let { operator: l, type: E } = F;
            if (!l && E !== "TSTypeAssertion")
              return true;
            let v = d4(l), N = D2.operator, x2 = d4(N);
            return x2 > v || g2 === "right" && x2 === v || x2 === v && !m2(N, l) ? true : x2 < v && l === "%" ? N === "+" || N === "-" : !!c(N);
          }
          default:
            return false;
        }
      case "SequenceExpression":
        switch (D2.type) {
          case "ReturnStatement":
            return false;
          case "ForStatement":
            return false;
          case "ExpressionStatement":
            return g2 !== "expression";
          case "ArrowFunctionExpression":
            return g2 !== "body";
          default:
            return true;
        }
      case "YieldExpression":
        if (D2.type === "UnaryExpression" || D2.type === "AwaitExpression" || D2.type === "TSAsExpression" || D2.type === "TSNonNullExpression")
          return true;
      case "AwaitExpression":
        switch (D2.type) {
          case "TaggedTemplateExpression":
          case "UnaryExpression":
          case "LogicalExpression":
          case "SpreadElement":
          case "SpreadProperty":
          case "TSAsExpression":
          case "TSNonNullExpression":
          case "BindExpression":
            return true;
          case "MemberExpression":
          case "OptionalMemberExpression":
            return g2 === "object";
          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return g2 === "callee";
          case "ConditionalExpression":
            return g2 === "test";
          case "BinaryExpression":
            return !(!F.argument && D2.operator === "|>");
          default:
            return false;
        }
      case "TSConditionalType":
        if (g2 === "extendsType" && D2.type === "TSConditionalType")
          return true;
      case "TSFunctionType":
      case "TSConstructorType":
        if (g2 === "checkType" && D2.type === "TSConditionalType")
          return true;
      case "TSUnionType":
      case "TSIntersectionType":
        if ((D2.type === "TSUnionType" || D2.type === "TSIntersectionType") && D2.types.length > 1 && (!F.types || F.types.length > 1))
          return true;
      case "TSInferType":
        if (F.type === "TSInferType" && D2.type === "TSRestType")
          return false;
      case "TSTypeOperator":
        return D2.type === "TSArrayType" || D2.type === "TSOptionalType" || D2.type === "TSRestType" || g2 === "objectType" && D2.type === "TSIndexedAccessType" || D2.type === "TSTypeOperator" || D2.type === "TSTypeAnnotation" && P.getParentNode(1).type.startsWith("TSJSDoc");
      case "ArrayTypeAnnotation":
        return D2.type === "NullableTypeAnnotation";
      case "IntersectionTypeAnnotation":
      case "UnionTypeAnnotation":
        return D2.type === "ArrayTypeAnnotation" || D2.type === "NullableTypeAnnotation" || D2.type === "IntersectionTypeAnnotation" || D2.type === "UnionTypeAnnotation" || g2 === "objectType" && (D2.type === "IndexedAccessType" || D2.type === "OptionalIndexedAccessType");
      case "NullableTypeAnnotation":
        return D2.type === "ArrayTypeAnnotation" || g2 === "objectType" && (D2.type === "IndexedAccessType" || D2.type === "OptionalIndexedAccessType");
      case "FunctionTypeAnnotation": {
        let l = D2.type === "NullableTypeAnnotation" ? P.getParentNode(1) : D2;
        return l.type === "UnionTypeAnnotation" || l.type === "IntersectionTypeAnnotation" || l.type === "ArrayTypeAnnotation" || g2 === "objectType" && (l.type === "IndexedAccessType" || l.type === "OptionalIndexedAccessType") || l.type === "NullableTypeAnnotation" || D2.type === "FunctionTypeParam" && D2.name === null && a3(F).some((E) => E.typeAnnotation && E.typeAnnotation.type === "NullableTypeAnnotation");
      }
      case "OptionalIndexedAccessType":
        return g2 === "objectType" && D2.type === "IndexedAccessType";
      case "TypeofTypeAnnotation":
        return g2 === "objectType" && (D2.type === "IndexedAccessType" || D2.type === "OptionalIndexedAccessType");
      case "StringLiteral":
      case "NumericLiteral":
      case "Literal":
        if (typeof F.value == "string" && D2.type === "ExpressionStatement" && !D2.directive) {
          let l = P.getParentNode(1);
          return l.type === "Program" || l.type === "BlockStatement";
        }
        return g2 === "object" && D2.type === "MemberExpression" && typeof F.value == "number";
      case "AssignmentExpression": {
        let l = P.getParentNode(1);
        return g2 === "body" && D2.type === "ArrowFunctionExpression" ? true : g2 === "key" && (D2.type === "ClassProperty" || D2.type === "PropertyDefinition") && D2.computed || (g2 === "init" || g2 === "update") && D2.type === "ForStatement" ? false : D2.type === "ExpressionStatement" ? F.left.type === "ObjectPattern" : !(g2 === "key" && D2.type === "TSPropertySignature" || D2.type === "AssignmentExpression" || D2.type === "SequenceExpression" && l && l.type === "ForStatement" && (l.init === D2 || l.update === D2) || g2 === "value" && D2.type === "Property" && l && l.type === "ObjectPattern" && l.properties.includes(D2) || D2.type === "NGChainedExpression");
      }
      case "ConditionalExpression":
        switch (D2.type) {
          case "TaggedTemplateExpression":
          case "UnaryExpression":
          case "SpreadElement":
          case "SpreadProperty":
          case "BinaryExpression":
          case "LogicalExpression":
          case "NGPipeExpression":
          case "ExportDefaultDeclaration":
          case "AwaitExpression":
          case "JSXSpreadAttribute":
          case "TSTypeAssertion":
          case "TypeCastExpression":
          case "TSAsExpression":
          case "TSNonNullExpression":
            return true;
          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return g2 === "callee";
          case "ConditionalExpression":
            return g2 === "test";
          case "MemberExpression":
          case "OptionalMemberExpression":
            return g2 === "object";
          default:
            return false;
        }
      case "FunctionExpression":
        switch (D2.type) {
          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return g2 === "callee";
          case "TaggedTemplateExpression":
            return true;
          default:
            return false;
        }
      case "ArrowFunctionExpression":
        switch (D2.type) {
          case "BinaryExpression":
            return D2.operator !== "|>" || F.extra && F.extra.parenthesized;
          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return g2 === "callee";
          case "MemberExpression":
          case "OptionalMemberExpression":
            return g2 === "object";
          case "TSAsExpression":
          case "TSNonNullExpression":
          case "BindExpression":
          case "TaggedTemplateExpression":
          case "UnaryExpression":
          case "LogicalExpression":
          case "AwaitExpression":
          case "TSTypeAssertion":
            return true;
          case "ConditionalExpression":
            return g2 === "test";
          default:
            return false;
        }
      case "ClassExpression":
        if (s2(F.decorators))
          return true;
        switch (D2.type) {
          case "NewExpression":
            return g2 === "callee";
          default:
            return false;
        }
      case "OptionalMemberExpression":
      case "OptionalCallExpression": {
        let l = P.getParentNode(1);
        if (g2 === "object" && D2.type === "MemberExpression" || g2 === "callee" && (D2.type === "CallExpression" || D2.type === "NewExpression") || D2.type === "TSNonNullExpression" && l.type === "MemberExpression" && l.object === D2)
          return true;
      }
      case "CallExpression":
      case "MemberExpression":
      case "TaggedTemplateExpression":
      case "TSNonNullExpression":
        if (g2 === "callee" && (D2.type === "BindExpression" || D2.type === "NewExpression")) {
          let l = F;
          for (; l; )
            switch (l.type) {
              case "CallExpression":
              case "OptionalCallExpression":
                return true;
              case "MemberExpression":
              case "OptionalMemberExpression":
              case "BindExpression":
                l = l.object;
                break;
              case "TaggedTemplateExpression":
                l = l.tag;
                break;
              case "TSNonNullExpression":
                l = l.expression;
                break;
              default:
                return false;
            }
        }
        return false;
      case "BindExpression":
        return g2 === "callee" && (D2.type === "BindExpression" || D2.type === "NewExpression") || g2 === "object" && f(D2);
      case "NGPipeExpression":
        return !(D2.type === "NGRoot" || D2.type === "NGMicrosyntaxExpression" || D2.type === "ObjectProperty" && !(F.extra && F.extra.parenthesized) || D2.type === "ArrayExpression" || p(D2) && D2.arguments[g2] === F || g2 === "right" && D2.type === "NGPipeExpression" || g2 === "property" && D2.type === "MemberExpression" || D2.type === "AssignmentExpression");
      case "JSXFragment":
      case "JSXElement":
        return g2 === "callee" || g2 === "left" && D2.type === "BinaryExpression" && D2.operator === "<" || D2.type !== "ArrayExpression" && D2.type !== "ArrowFunctionExpression" && D2.type !== "AssignmentExpression" && D2.type !== "AssignmentPattern" && D2.type !== "BinaryExpression" && D2.type !== "NewExpression" && D2.type !== "ConditionalExpression" && D2.type !== "ExpressionStatement" && D2.type !== "JsExpressionRoot" && D2.type !== "JSXAttribute" && D2.type !== "JSXElement" && D2.type !== "JSXExpressionContainer" && D2.type !== "JSXFragment" && D2.type !== "LogicalExpression" && !p(D2) && !h2(D2) && D2.type !== "ReturnStatement" && D2.type !== "ThrowStatement" && D2.type !== "TypeCastExpression" && D2.type !== "VariableDeclarator" && D2.type !== "YieldExpression";
      case "TypeAnnotation":
        return g2 === "returnType" && D2.type === "ArrowFunctionExpression" && S2(F);
    }
    return false;
  }
  function T2(P) {
    return P.type === "BlockStatement" || P.type === "BreakStatement" || P.type === "ClassBody" || P.type === "ClassDeclaration" || P.type === "ClassMethod" || P.type === "ClassProperty" || P.type === "PropertyDefinition" || P.type === "ClassPrivateProperty" || P.type === "ContinueStatement" || P.type === "DebuggerStatement" || P.type === "DeclareClass" || P.type === "DeclareExportAllDeclaration" || P.type === "DeclareExportDeclaration" || P.type === "DeclareFunction" || P.type === "DeclareInterface" || P.type === "DeclareModule" || P.type === "DeclareModuleExports" || P.type === "DeclareVariable" || P.type === "DoWhileStatement" || P.type === "EnumDeclaration" || P.type === "ExportAllDeclaration" || P.type === "ExportDefaultDeclaration" || P.type === "ExportNamedDeclaration" || P.type === "ExpressionStatement" || P.type === "ForInStatement" || P.type === "ForOfStatement" || P.type === "ForStatement" || P.type === "FunctionDeclaration" || P.type === "IfStatement" || P.type === "ImportDeclaration" || P.type === "InterfaceDeclaration" || P.type === "LabeledStatement" || P.type === "MethodDefinition" || P.type === "ReturnStatement" || P.type === "SwitchStatement" || P.type === "ThrowStatement" || P.type === "TryStatement" || P.type === "TSDeclareFunction" || P.type === "TSEnumDeclaration" || P.type === "TSImportEqualsDeclaration" || P.type === "TSInterfaceDeclaration" || P.type === "TSModuleDeclaration" || P.type === "TSNamespaceExportDeclaration" || P.type === "TypeAlias" || P.type === "VariableDeclaration" || P.type === "WhileStatement" || P.type === "WithStatement";
  }
  function A2(P) {
    let C2 = 0, D2 = P.getValue();
    for (; D2; ) {
      let g2 = P.getParentNode(C2++);
      if (g2 && g2.type === "ForStatement" && g2.init === D2)
        return true;
      D2 = g2;
    }
    return false;
  }
  function S2(P) {
    return o(P, (C2) => C2.type === "ObjectTypeAnnotation" && o(C2, (D2) => D2.type === "FunctionTypeAnnotation" || void 0) || void 0);
  }
  function B(P) {
    switch (P.type) {
      case "ObjectExpression":
        return true;
      default:
        return false;
    }
  }
  function I2(P) {
    let C2 = P.getValue(), D2 = P.getParentNode(), g2 = P.getName();
    switch (D2.type) {
      case "NGPipeExpression":
        if (typeof g2 == "number" && D2.arguments[g2] === C2 && D2.arguments.length - 1 === g2)
          return P.callParent(I2);
        break;
      case "ObjectProperty":
        if (g2 === "value") {
          let F = P.getParentNode(1);
          return t(F.properties) === D2;
        }
        break;
      case "BinaryExpression":
      case "LogicalExpression":
        if (g2 === "right")
          return P.callParent(I2);
        break;
      case "ConditionalExpression":
        if (g2 === "alternate")
          return P.callParent(I2);
        break;
      case "UnaryExpression":
        if (D2.prefix)
          return P.callParent(I2);
        break;
    }
    return false;
  }
  function k2(P, C2) {
    let D2 = P.getValue(), g2 = P.getParentNode();
    return D2.type === "FunctionExpression" || D2.type === "ClassExpression" ? g2.type === "ExportDefaultDeclaration" || !w2(P, C2) : !i2(D2) || g2.type !== "ExportDefaultDeclaration" && w2(P, C2) ? false : P.call((F) => k2(F, C2), ...r(P, D2));
  }
  n.exports = w2;
} }), Qa$1 = Z({ "src/language-js/print-preprocess.js"(e, n) {
  re();
  function t(s2, a3) {
    switch (a3.parser) {
      case "json":
      case "json5":
      case "json-stringify":
      case "__js_expression":
      case "__vue_expression":
      case "__vue_ts_expression":
        return Object.assign(Object.assign({}, s2), {}, { type: a3.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: s2, comments: [], rootMarker: a3.rootMarker });
      default:
        return s2;
    }
  }
  n.exports = t;
} }), Lm = Z({ "src/language-js/print/html-binding.js"(e, n) {
  re();
  var { builders: { join: t, line: s2, group: a3, softline: r, indent: u } } = Oe();
  function i2(c, y, m2) {
    let d4 = c.getValue();
    if (y.__onHtmlBindingRoot && c.getName() === null && y.__onHtmlBindingRoot(d4, y), d4.type === "File") {
      if (y.__isVueForBindingLeft)
        return c.call((p) => {
          let f = t([",", s2], p.map(m2, "params")), { params: h2 } = p.getValue();
          return h2.length === 1 ? f : ["(", u([r, a3(f)]), r, ")"];
        }, "program", "body", 0);
      if (y.__isVueBindings)
        return c.call((p) => t([",", s2], p.map(m2, "params")), "program", "body", 0);
    }
  }
  function o(c) {
    switch (c.type) {
      case "MemberExpression":
        switch (c.property.type) {
          case "Identifier":
          case "NumericLiteral":
          case "StringLiteral":
            return o(c.object);
        }
        return false;
      case "Identifier":
        return true;
      default:
        return false;
    }
  }
  n.exports = { isVueEventBindingExpression: o, printHtmlBinding: i2 };
} }), $n$1 = Z({ "src/language-js/print/binaryish.js"(e, n) {
  re();
  var { printComments: t } = et(), { getLast: s2 } = Ue$2(), { builders: { join: a3, line: r, softline: u, group: i2, indent: o, align: c, ifBreak: y, indentIfBreak: m2 }, utils: { cleanDoc: d4, getDocParts: p, isConcat: f } } = Oe(), { hasLeadingOwnLineComment: h2, isBinaryish: w2, isJsxNode: T2, shouldFlatten: A2, hasComment: S2, CommentCheckFlags: B, isCallExpression: I2, isMemberExpression: k2, isObjectProperty: P, isEnabledHackPipeline: C2 } = Ke$1(), D2 = 0;
  function g2(E, v, N) {
    let x2 = E.getValue(), b2 = E.getParentNode(), L = E.getParentNode(1), M2 = x2 !== b2.body && (b2.type === "IfStatement" || b2.type === "WhileStatement" || b2.type === "SwitchStatement" || b2.type === "DoWhileStatement"), j = C2(v) && x2.operator === "|>", $ = F(E, N, v, false, M2);
    if (M2)
      return $;
    if (j)
      return i2($);
    if (I2(b2) && b2.callee === x2 || b2.type === "UnaryExpression" || k2(b2) && !b2.computed)
      return i2([o([u, ...$]), u]);
    let V = b2.type === "ReturnStatement" || b2.type === "ThrowStatement" || b2.type === "JSXExpressionContainer" && L.type === "JSXAttribute" || x2.operator !== "|" && b2.type === "JsExpressionRoot" || x2.type !== "NGPipeExpression" && (b2.type === "NGRoot" && v.parser === "__ng_binding" || b2.type === "NGMicrosyntaxExpression" && L.type === "NGMicrosyntax" && L.body.length === 1) || x2 === b2.body && b2.type === "ArrowFunctionExpression" || x2 !== b2.body && b2.type === "ForStatement" || b2.type === "ConditionalExpression" && L.type !== "ReturnStatement" && L.type !== "ThrowStatement" && !I2(L) || b2.type === "TemplateLiteral", q = b2.type === "AssignmentExpression" || b2.type === "VariableDeclarator" || b2.type === "ClassProperty" || b2.type === "PropertyDefinition" || b2.type === "TSAbstractPropertyDefinition" || b2.type === "ClassPrivateProperty" || P(b2), Y3 = w2(x2.left) && A2(x2.operator, x2.left.operator);
    if (V || l(x2) && !Y3 || !l(x2) && q)
      return i2($);
    if ($.length === 0)
      return "";
    let H3 = T2(x2.right), R = $.findIndex((X3) => typeof X3 != "string" && !Array.isArray(X3) && X3.type === "group"), Q = $.slice(0, R === -1 ? 1 : R + 1), ee2 = $.slice(Q.length, H3 ? -1 : void 0), te2 = Symbol("logicalChain-" + ++D2), oe2 = i2([...Q, o(ee2)], { id: te2 });
    if (!H3)
      return oe2;
    let W2 = s2($);
    return i2([oe2, m2(W2, { groupId: te2 })]);
  }
  function F(E, v, N, x2, b2) {
    let L = E.getValue();
    if (!w2(L))
      return [i2(v())];
    let M2 = [];
    A2(L.operator, L.left.operator) ? M2 = E.call((ee2) => F(ee2, v, N, true, b2), "left") : M2.push(i2(v("left")));
    let j = l(L), $ = (L.operator === "|>" || L.type === "NGPipeExpression" || L.operator === "|" && N.parser === "__vue_expression") && !h2(N.originalText, L.right), V = L.type === "NGPipeExpression" ? "|" : L.operator, q = L.type === "NGPipeExpression" && L.arguments.length > 0 ? i2(o([u, ": ", a3([u, ":", y(" ")], E.map(v, "arguments").map((ee2) => c(2, i2(ee2))))])) : "", Y3;
    if (j)
      Y3 = [V, " ", v("right"), q];
    else {
      let te2 = C2(N) && V === "|>" ? E.call((oe2) => F(oe2, v, N, true, b2), "right") : v("right");
      Y3 = [$ ? r : "", V, $ ? " " : r, te2, q];
    }
    let H3 = E.getParentNode(), R = S2(L.left, B.Trailing | B.Line), Q = R || !(b2 && L.type === "LogicalExpression") && H3.type !== L.type && L.left.type !== L.type && L.right.type !== L.type;
    if (M2.push($ ? "" : " ", Q ? i2(Y3, { shouldBreak: R }) : Y3), x2 && S2(L)) {
      let ee2 = d4(t(E, M2, N));
      return f(ee2) || ee2.type === "fill" ? p(ee2) : [ee2];
    }
    return M2;
  }
  function l(E) {
    return E.type !== "LogicalExpression" ? false : !!(E.right.type === "ObjectExpression" && E.right.properties.length > 0 || E.right.type === "ArrayExpression" && E.right.elements.length > 0 || T2(E.right));
  }
  n.exports = { printBinaryishExpression: g2, shouldInlineLogicalExpression: l };
} }), jm = Z({ "src/language-js/print/angular.js"(e, n) {
  re();
  var { builders: { join: t, line: s2, group: a3 } } = Oe(), { hasNode: r, hasComment: u, getComments: i2 } = Ke$1(), { printBinaryishExpression: o } = $n$1();
  function c(d4, p, f) {
    let h2 = d4.getValue();
    if (!!h2.type.startsWith("NG"))
      switch (h2.type) {
        case "NGRoot":
          return [f("node"), u(h2.node) ? " //" + i2(h2.node)[0].value.trimEnd() : ""];
        case "NGPipeExpression":
          return o(d4, p, f);
        case "NGChainedExpression":
          return a3(t([";", s2], d4.map((w2) => m2(w2) ? f() : ["(", f(), ")"], "expressions")));
        case "NGEmptyExpression":
          return "";
        case "NGQuotedExpression":
          return [h2.prefix, ": ", h2.value.trim()];
        case "NGMicrosyntax":
          return d4.map((w2, T2) => [T2 === 0 ? "" : y(w2.getValue(), T2, h2) ? " " : [";", s2], f()], "body");
        case "NGMicrosyntaxKey":
          return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(h2.name) ? h2.name : JSON.stringify(h2.name);
        case "NGMicrosyntaxExpression":
          return [f("expression"), h2.alias === null ? "" : [" as ", f("alias")]];
        case "NGMicrosyntaxKeyedExpression": {
          let w2 = d4.getName(), T2 = d4.getParentNode(), A2 = y(h2, w2, T2) || (w2 === 1 && (h2.key.name === "then" || h2.key.name === "else") || w2 === 2 && h2.key.name === "else" && T2.body[w2 - 1].type === "NGMicrosyntaxKeyedExpression" && T2.body[w2 - 1].key.name === "then") && T2.body[0].type === "NGMicrosyntaxExpression";
          return [f("key"), A2 ? " " : ": ", f("expression")];
        }
        case "NGMicrosyntaxLet":
          return ["let ", f("key"), h2.value === null ? "" : [" = ", f("value")]];
        case "NGMicrosyntaxAs":
          return [f("key"), " as ", f("alias")];
        default:
          throw new Error("Unknown Angular node type: ".concat(JSON.stringify(h2.type), "."));
      }
  }
  function y(d4, p, f) {
    return d4.type === "NGMicrosyntaxKeyedExpression" && d4.key.name === "of" && p === 1 && f.body[0].type === "NGMicrosyntaxLet" && f.body[0].value === null;
  }
  function m2(d4) {
    return r(d4.getValue(), (p) => {
      switch (p.type) {
        case void 0:
          return false;
        case "CallExpression":
        case "OptionalCallExpression":
        case "AssignmentExpression":
          return true;
      }
    });
  }
  n.exports = { printAngular: c };
} }), Om = Z({ "src/language-js/print/jsx.js"(e, n) {
  re();
  var { printComments: t, printDanglingComments: s2 } = et(), { builders: { line: a3, hardline: r, softline: u, group: i2, indent: o, conditionalGroup: c, fill: y, ifBreak: m2, lineSuffixBoundary: d4, join: p }, utils: { willBreak: f } } = Oe(), { getLast: h2, getPreferredQuote: w2 } = Ue$2(), { isJsxNode: T2, rawText: A2, isLiteral: S2, isCallExpression: B, isStringLiteral: I2, isBinaryish: k2, hasComment: P, CommentCheckFlags: C2, hasNodeIgnoreComment: D2 } = Ke$1(), g2 = It$1(), { willPrintOwnComments: F } = Ya$1(), l = (ie) => ie === "" || ie === a3 || ie === r || ie === u;
  function E(ie, G, z) {
    let U = ie.getValue();
    if (U.type === "JSXElement" && W2(U))
      return [z("openingElement"), z("closingElement")];
    let le2 = U.type === "JSXElement" ? z("openingElement") : z("openingFragment"), ge2 = U.type === "JSXElement" ? z("closingElement") : z("closingFragment");
    if (U.children.length === 1 && U.children[0].type === "JSXExpressionContainer" && (U.children[0].expression.type === "TemplateLiteral" || U.children[0].expression.type === "TaggedTemplateExpression"))
      return [le2, ...ie.map(z, "children"), ge2];
    U.children = U.children.map((Fe2) => ue2(Fe2) ? { type: "JSXText", value: " ", raw: " " } : Fe2);
    let Ae2 = U.children.some(T2), Ne2 = U.children.filter((Fe2) => Fe2.type === "JSXExpressionContainer").length > 1, ke2 = U.type === "JSXElement" && U.openingElement.attributes.length > 1, ce = f(le2) || Ae2 || ke2 || Ne2, pe = ie.getParentNode().rootMarker === "mdx", de2 = G.singleQuote ? "{' '}" : '{" "}', ae2 = pe ? " " : m2([de2, u], " "), ve2 = U.openingElement && U.openingElement.name && U.openingElement.name.name === "fbt", K = v(ie, G, z, ae2, ve2), he2 = U.children.some((Fe2) => X3(Fe2));
    for (let Fe2 = K.length - 2; Fe2 >= 0; Fe2--) {
      let me2 = K[Fe2] === "" && K[Fe2 + 1] === "", _ = K[Fe2] === r && K[Fe2 + 1] === "" && K[Fe2 + 2] === r, J2 = (K[Fe2] === u || K[Fe2] === r) && K[Fe2 + 1] === "" && K[Fe2 + 2] === ae2, ne = K[Fe2] === ae2 && K[Fe2 + 1] === "" && (K[Fe2 + 2] === u || K[Fe2 + 2] === r), Ee = K[Fe2] === ae2 && K[Fe2 + 1] === "" && K[Fe2 + 2] === ae2, We2 = K[Fe2] === u && K[Fe2 + 1] === "" && K[Fe2 + 2] === r || K[Fe2] === r && K[Fe2 + 1] === "" && K[Fe2 + 2] === u;
      _ && he2 || me2 || J2 || Ee || We2 ? K.splice(Fe2, 2) : ne && K.splice(Fe2 + 1, 2);
    }
    for (; K.length > 0 && l(h2(K)); )
      K.pop();
    for (; K.length > 1 && l(K[0]) && l(K[1]); )
      K.shift(), K.shift();
    let ye2 = [];
    for (let [Fe2, me2] of K.entries()) {
      if (me2 === ae2) {
        if (Fe2 === 1 && K[Fe2 - 1] === "") {
          if (K.length === 2) {
            ye2.push(de2);
            continue;
          }
          ye2.push([de2, r]);
          continue;
        } else if (Fe2 === K.length - 1) {
          ye2.push(de2);
          continue;
        } else if (K[Fe2 - 1] === "" && K[Fe2 - 2] === r) {
          ye2.push(de2);
          continue;
        }
      }
      ye2.push(me2), f(me2) && (ce = true);
    }
    let Ce2 = he2 ? y(ye2) : i2(ye2, { shouldBreak: true });
    if (pe)
      return Ce2;
    let Ie2 = i2([le2, o([r, Ce2]), r, ge2]);
    return ce ? Ie2 : c([i2([le2, ...K, ge2]), Ie2]);
  }
  function v(ie, G, z, U, le2) {
    let ge2 = [];
    return ie.each((Ae2, Ne2, ke2) => {
      let ce = Ae2.getValue();
      if (S2(ce)) {
        let pe = A2(ce);
        if (X3(ce)) {
          let de2 = pe.split(ee2);
          if (de2[0] === "") {
            if (ge2.push(""), de2.shift(), /\n/.test(de2[0])) {
              let ve2 = ke2[Ne2 + 1];
              ge2.push(x2(le2, de2[1], ce, ve2));
            } else
              ge2.push(U);
            de2.shift();
          }
          let ae2;
          if (h2(de2) === "" && (de2.pop(), ae2 = de2.pop()), de2.length === 0)
            return;
          for (let [ve2, K] of de2.entries())
            ve2 % 2 === 1 ? ge2.push(a3) : ge2.push(K);
          if (ae2 !== void 0)
            if (/\n/.test(ae2)) {
              let ve2 = ke2[Ne2 + 1];
              ge2.push(x2(le2, h2(ge2), ce, ve2));
            } else
              ge2.push(U);
          else {
            let ve2 = ke2[Ne2 + 1];
            ge2.push(N(le2, h2(ge2), ce, ve2));
          }
        } else
          /\n/.test(pe) ? pe.match(/\n/g).length > 1 && ge2.push("", r) : ge2.push("", U);
      } else {
        let pe = z();
        ge2.push(pe);
        let de2 = ke2[Ne2 + 1];
        if (de2 && X3(de2)) {
          let ve2 = oe2(A2(de2)).split(ee2)[0];
          ge2.push(N(le2, ve2, ce, de2));
        } else
          ge2.push(r);
      }
    }, "children"), ge2;
  }
  function N(ie, G, z, U) {
    return ie ? "" : z.type === "JSXElement" && !z.closingElement || U && U.type === "JSXElement" && !U.closingElement ? G.length === 1 ? u : r : u;
  }
  function x2(ie, G, z, U) {
    return ie ? r : G.length === 1 ? z.type === "JSXElement" && !z.closingElement || U && U.type === "JSXElement" && !U.closingElement ? r : u : r;
  }
  function b2(ie, G, z) {
    let U = ie.getParentNode();
    if (!U || { ArrayExpression: true, JSXAttribute: true, JSXElement: true, JSXExpressionContainer: true, JSXFragment: true, ExpressionStatement: true, CallExpression: true, OptionalCallExpression: true, ConditionalExpression: true, JsExpressionRoot: true }[U.type])
      return G;
    let ge2 = ie.match(void 0, (Ne2) => Ne2.type === "ArrowFunctionExpression", B, (Ne2) => Ne2.type === "JSXExpressionContainer"), Ae2 = g2(ie, z);
    return i2([Ae2 ? "" : m2("("), o([u, G]), u, Ae2 ? "" : m2(")")], { shouldBreak: ge2 });
  }
  function L(ie, G, z) {
    let U = ie.getValue(), le2 = [];
    if (le2.push(z("name")), U.value) {
      let ge2;
      if (I2(U.value)) {
        let Ne2 = A2(U.value).slice(1, -1).replace(/&apos;/g, "'").replace(/&quot;/g, '"'), { escaped: ke2, quote: ce, regex: pe } = w2(Ne2, G.jsxSingleQuote ? "'" : '"');
        Ne2 = Ne2.replace(pe, ke2), ge2 = [ce, Ne2, ce];
      } else
        ge2 = z("value");
      le2.push("=", ge2);
    }
    return le2;
  }
  function M2(ie, G, z) {
    let U = ie.getValue(), le2 = (ge2, Ae2) => ge2.type === "JSXEmptyExpression" || !P(ge2) && (ge2.type === "ArrayExpression" || ge2.type === "ObjectExpression" || ge2.type === "ArrowFunctionExpression" || ge2.type === "AwaitExpression" && (le2(ge2.argument, ge2) || ge2.argument.type === "JSXElement") || B(ge2) || ge2.type === "FunctionExpression" || ge2.type === "TemplateLiteral" || ge2.type === "TaggedTemplateExpression" || ge2.type === "DoExpression" || T2(Ae2) && (ge2.type === "ConditionalExpression" || k2(ge2)));
    return le2(U.expression, ie.getParentNode(0)) ? i2(["{", z("expression"), d4, "}"]) : i2(["{", o([u, z("expression")]), u, d4, "}"]);
  }
  function j(ie, G, z) {
    let U = ie.getValue(), le2 = U.name && P(U.name) || U.typeParameters && P(U.typeParameters);
    if (U.selfClosing && U.attributes.length === 0 && !le2)
      return ["<", z("name"), z("typeParameters"), " />"];
    if (U.attributes && U.attributes.length === 1 && U.attributes[0].value && I2(U.attributes[0].value) && !U.attributes[0].value.value.includes(`
`) && !le2 && !P(U.attributes[0]))
      return i2(["<", z("name"), z("typeParameters"), " ", ...ie.map(z, "attributes"), U.selfClosing ? " />" : ">"]);
    let ge2 = U.attributes.length > 0 && P(h2(U.attributes), C2.Trailing), Ae2 = U.attributes.length === 0 && !le2 || (G.bracketSameLine || G.jsxBracketSameLine) && (!le2 || U.attributes.length > 0) && !ge2, Ne2 = U.attributes && U.attributes.some((ce) => ce.value && I2(ce.value) && ce.value.value.includes(`
`)), ke2 = G.singleAttributePerLine && U.attributes.length > 1 ? r : a3;
    return i2(["<", z("name"), z("typeParameters"), o(ie.map(() => [ke2, z()], "attributes")), U.selfClosing ? a3 : Ae2 ? ">" : u, U.selfClosing ? "/>" : Ae2 ? "" : ">"], { shouldBreak: Ne2 });
  }
  function $(ie, G, z) {
    let U = ie.getValue(), le2 = [];
    le2.push("</");
    let ge2 = z("name");
    return P(U.name, C2.Leading | C2.Line) ? le2.push(o([r, ge2]), r) : P(U.name, C2.Leading | C2.Block) ? le2.push(" ", ge2) : le2.push(ge2), le2.push(">"), le2;
  }
  function V(ie, G) {
    let z = ie.getValue(), U = P(z), le2 = P(z, C2.Line), ge2 = z.type === "JSXOpeningFragment";
    return [ge2 ? "<" : "</", o([le2 ? r : U && !ge2 ? " " : "", s2(ie, G, true)]), le2 ? r : "", ">"];
  }
  function q(ie, G, z) {
    let U = t(ie, E(ie, G, z), G);
    return b2(ie, U, G);
  }
  function Y3(ie, G) {
    let z = ie.getValue(), U = P(z, C2.Line);
    return [s2(ie, G, !U), U ? r : ""];
  }
  function H3(ie, G, z) {
    let U = ie.getValue();
    return ["{", ie.call((le2) => {
      let ge2 = ["...", z()], Ae2 = le2.getValue();
      return !P(Ae2) || !F(le2) ? ge2 : [o([u, t(le2, ge2, G)]), u];
    }, U.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
  }
  function R(ie, G, z) {
    let U = ie.getValue();
    if (!!U.type.startsWith("JSX"))
      switch (U.type) {
        case "JSXAttribute":
          return L(ie, G, z);
        case "JSXIdentifier":
          return String(U.name);
        case "JSXNamespacedName":
          return p(":", [z("namespace"), z("name")]);
        case "JSXMemberExpression":
          return p(".", [z("object"), z("property")]);
        case "JSXSpreadAttribute":
          return H3(ie, G, z);
        case "JSXSpreadChild":
          return H3(ie, G, z);
        case "JSXExpressionContainer":
          return M2(ie, G, z);
        case "JSXFragment":
        case "JSXElement":
          return q(ie, G, z);
        case "JSXOpeningElement":
          return j(ie, G, z);
        case "JSXClosingElement":
          return $(ie, G, z);
        case "JSXOpeningFragment":
        case "JSXClosingFragment":
          return V(ie, G);
        case "JSXEmptyExpression":
          return Y3(ie, G);
        case "JSXText":
          throw new Error("JSXTest should be handled by JSXElement");
        default:
          throw new Error("Unknown JSX node type: ".concat(JSON.stringify(U.type), "."));
      }
  }
  var Q = ` 
\r	`, ee2 = new RegExp("([" + Q + "]+)"), te2 = new RegExp("[^" + Q + "]"), oe2 = (ie) => ie.replace(new RegExp("(?:^" + ee2.source + "|" + ee2.source + "$)"), "");
  function W2(ie) {
    if (ie.children.length === 0)
      return true;
    if (ie.children.length > 1)
      return false;
    let G = ie.children[0];
    return S2(G) && !X3(G);
  }
  function X3(ie) {
    return S2(ie) && (te2.test(A2(ie)) || !/\n/.test(A2(ie)));
  }
  function ue2(ie) {
    return ie.type === "JSXExpressionContainer" && S2(ie.expression) && ie.expression.value === " " && !P(ie.expression);
  }
  function De2(ie) {
    let G = ie.getValue(), z = ie.getParentNode();
    if (!z || !G || !T2(G) || !T2(z))
      return false;
    let U = z.children.indexOf(G), le2 = null;
    for (let ge2 = U; ge2 > 0; ge2--) {
      let Ae2 = z.children[ge2 - 1];
      if (!(Ae2.type === "JSXText" && !X3(Ae2))) {
        le2 = Ae2;
        break;
      }
    }
    return le2 && le2.type === "JSXExpressionContainer" && le2.expression.type === "JSXEmptyExpression" && D2(le2.expression);
  }
  n.exports = { hasJsxIgnoreComment: De2, printJsx: R };
} }), ct$1 = Z({ "src/language-js/print/misc.js"(e, n) {
  re();
  var { isNonEmptyArray: t } = Ue$2(), { builders: { indent: s2, join: a3, line: r } } = Oe(), { isFlowAnnotationComment: u } = Ke$1();
  function i2(h2) {
    let w2 = h2.getValue();
    return !w2.optional || w2.type === "Identifier" && w2 === h2.getParentNode().key ? "" : w2.type === "OptionalCallExpression" || w2.type === "OptionalMemberExpression" && w2.computed ? "?." : "?";
  }
  function o(h2) {
    return h2.getValue().definite || h2.match(void 0, (w2, T2) => T2 === "id" && w2.type === "VariableDeclarator" && w2.definite) ? "!" : "";
  }
  function c(h2, w2, T2) {
    let A2 = h2.getValue();
    return A2.typeArguments ? T2("typeArguments") : A2.typeParameters ? T2("typeParameters") : "";
  }
  function y(h2, w2, T2) {
    let A2 = h2.getValue();
    if (!A2.typeAnnotation)
      return "";
    let S2 = h2.getParentNode(), B = S2.type === "DeclareFunction" && S2.id === A2;
    return u(w2.originalText, A2.typeAnnotation) ? [" /*: ", T2("typeAnnotation"), " */"] : [B ? "" : ": ", T2("typeAnnotation")];
  }
  function m2(h2, w2, T2) {
    return ["::", T2("callee")];
  }
  function d4(h2, w2, T2) {
    let A2 = h2.getValue();
    return t(A2.modifiers) ? [a3(" ", h2.map(T2, "modifiers")), " "] : "";
  }
  function p(h2, w2, T2) {
    return h2.type === "EmptyStatement" ? ";" : h2.type === "BlockStatement" || T2 ? [" ", w2] : s2([r, w2]);
  }
  function f(h2, w2, T2) {
    return ["...", T2("argument"), y(h2, w2, T2)];
  }
  n.exports = { printOptionalToken: i2, printDefiniteToken: o, printFunctionTypeParameters: c, printBindExpressionCallee: m2, printTypeScriptModifiers: d4, printTypeAnnotation: y, printRestSpread: f, adjustClause: p };
} }), zt$1 = Z({ "src/language-js/print/array.js"(e, n) {
  re();
  var { printDanglingComments: t } = et(), { builders: { line: s2, softline: a3, hardline: r, group: u, indent: i2, ifBreak: o, fill: c } } = Oe(), { getLast: y, hasNewline: m2 } = Ue$2(), { shouldPrintComma: d4, hasComment: p, CommentCheckFlags: f, isNextLineEmpty: h2, isNumericLiteral: w2, isSignedNumericLiteral: T2 } = Ke$1(), { locStart: A2 } = st$1(), { printOptionalToken: S2, printTypeAnnotation: B } = ct$1();
  function I2(D2, g2, F) {
    let l = D2.getValue(), E = [], v = l.type === "TupleExpression" ? "#[" : "[", N = "]";
    if (l.elements.length === 0)
      p(l, f.Dangling) ? E.push(u([v, t(D2, g2), a3, N])) : E.push(v, N);
    else {
      let x2 = y(l.elements), b2 = !(x2 && x2.type === "RestElement"), L = x2 === null, M2 = Symbol("array"), j = !g2.__inJestEach && l.elements.length > 1 && l.elements.every((q, Y3, H3) => {
        let R = q && q.type;
        if (R !== "ArrayExpression" && R !== "ObjectExpression")
          return false;
        let Q = H3[Y3 + 1];
        if (Q && R !== Q.type)
          return false;
        let ee2 = R === "ArrayExpression" ? "elements" : "properties";
        return q[ee2] && q[ee2].length > 1;
      }), $ = k2(l, g2), V = b2 ? L ? "," : d4(g2) ? $ ? o(",", "", { groupId: M2 }) : o(",") : "" : "";
      E.push(u([v, i2([a3, $ ? C2(D2, g2, F, V) : [P(D2, g2, "elements", F), V], t(D2, g2, true)]), a3, N], { shouldBreak: j, id: M2 }));
    }
    return E.push(S2(D2), B(D2, g2, F)), E;
  }
  function k2(D2, g2) {
    return D2.elements.length > 1 && D2.elements.every((F) => F && (w2(F) || T2(F) && !p(F.argument)) && !p(F, f.Trailing | f.Line, (l) => !m2(g2.originalText, A2(l), { backwards: true })));
  }
  function P(D2, g2, F, l) {
    let E = [], v = [];
    return D2.each((N) => {
      E.push(v, u(l())), v = [",", s2], N.getValue() && h2(N.getValue(), g2) && v.push(a3);
    }, F), E;
  }
  function C2(D2, g2, F, l) {
    let E = [];
    return D2.each((v, N, x2) => {
      let b2 = N === x2.length - 1;
      E.push([F(), b2 ? l : ","]), b2 || E.push(h2(v.getValue(), g2) ? [r, r] : p(x2[N + 1], f.Leading | f.Line) ? r : s2);
    }, "elements"), c(E);
  }
  n.exports = { printArray: I2, printArrayItems: P, isConciselyPrintedArray: k2 };
} }), Za = Z({ "src/language-js/print/call-arguments.js"(e, n) {
  re();
  var { printDanglingComments: t } = et(), { getLast: s2, getPenultimate: a3 } = Ue$2(), { getFunctionParameters: r, hasComment: u, CommentCheckFlags: i2, isFunctionCompositionArgs: o, isJsxNode: c, isLongCurriedCallExpression: y, shouldPrintComma: m2, getCallArguments: d4, iterateCallArgumentsPath: p, isNextLineEmpty: f, isCallExpression: h2, isStringLiteral: w2, isObjectProperty: T2 } = Ke$1(), { builders: { line: A2, hardline: S2, softline: B, group: I2, indent: k2, conditionalGroup: P, ifBreak: C2, breakParent: D2 }, utils: { willBreak: g2 } } = Oe(), { ArgExpansionBailout: F } = Jt$1(), { isConciselyPrintedArray: l } = zt$1();
  function E(j, $, V) {
    let q = j.getValue(), Y3 = q.type === "ImportExpression", H3 = d4(q);
    if (H3.length === 0)
      return ["(", t(j, $, true), ")"];
    if (b2(H3))
      return ["(", V(["arguments", 0]), ", ", V(["arguments", 1]), ")"];
    let R = false, Q = false, ee2 = H3.length - 1, te2 = [];
    p(j, (ie, G) => {
      let z = ie.getNode(), U = [V()];
      G === ee2 || (f(z, $) ? (G === 0 && (Q = true), R = true, U.push(",", S2, S2)) : U.push(",", A2)), te2.push(U);
    });
    let oe2 = !(Y3 || q.callee && q.callee.type === "Import") && m2($, "all") ? "," : "";
    function W2() {
      return I2(["(", k2([A2, ...te2]), oe2, A2, ")"], { shouldBreak: true });
    }
    if (R || j.getParentNode().type !== "Decorator" && o(H3))
      return W2();
    let X3 = x2(H3), ue2 = N(H3, $);
    if (X3 || ue2) {
      if (X3 ? te2.slice(1).some(g2) : te2.slice(0, -1).some(g2))
        return W2();
      let ie = [];
      try {
        j.try(() => {
          p(j, (G, z) => {
            X3 && z === 0 && (ie = [[V([], { expandFirstArg: true }), te2.length > 1 ? "," : "", Q ? S2 : A2, Q ? S2 : ""], ...te2.slice(1)]), ue2 && z === ee2 && (ie = [...te2.slice(0, -1), V([], { expandLastArg: true })]);
          });
        });
      } catch (G) {
        if (G instanceof F)
          return W2();
        throw G;
      }
      return [te2.some(g2) ? D2 : "", P([["(", ...ie, ")"], X3 ? ["(", I2(ie[0], { shouldBreak: true }), ...ie.slice(1), ")"] : ["(", ...te2.slice(0, -1), I2(s2(ie), { shouldBreak: true }), ")"], W2()])];
    }
    let De2 = ["(", k2([B, ...te2]), C2(oe2), B, ")"];
    return y(j) ? De2 : I2(De2, { shouldBreak: te2.some(g2) || R });
  }
  function v(j) {
    let $ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    return j.type === "ObjectExpression" && (j.properties.length > 0 || u(j)) || j.type === "ArrayExpression" && (j.elements.length > 0 || u(j)) || j.type === "TSTypeAssertion" && v(j.expression) || j.type === "TSAsExpression" && v(j.expression) || j.type === "FunctionExpression" || j.type === "ArrowFunctionExpression" && (!j.returnType || !j.returnType.typeAnnotation || j.returnType.typeAnnotation.type !== "TSTypeReference" || L(j.body)) && (j.body.type === "BlockStatement" || j.body.type === "ArrowFunctionExpression" && v(j.body, true) || j.body.type === "ObjectExpression" || j.body.type === "ArrayExpression" || !$ && (h2(j.body) || j.body.type === "ConditionalExpression") || c(j.body)) || j.type === "DoExpression" || j.type === "ModuleExpression";
  }
  function N(j, $) {
    let V = s2(j), q = a3(j);
    return !u(V, i2.Leading) && !u(V, i2.Trailing) && v(V) && (!q || q.type !== V.type) && (j.length !== 2 || q.type !== "ArrowFunctionExpression" || V.type !== "ArrayExpression") && !(j.length > 1 && V.type === "ArrayExpression" && l(V, $));
  }
  function x2(j) {
    if (j.length !== 2)
      return false;
    let [$, V] = j;
    return $.type === "ModuleExpression" && M2(V) ? true : !u($) && ($.type === "FunctionExpression" || $.type === "ArrowFunctionExpression" && $.body.type === "BlockStatement") && V.type !== "FunctionExpression" && V.type !== "ArrowFunctionExpression" && V.type !== "ConditionalExpression" && !v(V);
  }
  function b2(j) {
    return j.length === 2 && j[0].type === "ArrowFunctionExpression" && r(j[0]).length === 0 && j[0].body.type === "BlockStatement" && j[1].type === "ArrayExpression" && !j.some(($) => u($));
  }
  function L(j) {
    return j.type === "BlockStatement" && (j.body.some(($) => $.type !== "EmptyStatement") || u(j, i2.Dangling));
  }
  function M2(j) {
    return j.type === "ObjectExpression" && j.properties.length === 1 && T2(j.properties[0]) && j.properties[0].key.type === "Identifier" && j.properties[0].key.name === "type" && w2(j.properties[0].value) && j.properties[0].value.value === "module";
  }
  n.exports = E;
} }), eo$2 = Z({ "src/language-js/print/member.js"(e, n) {
  re();
  var { builders: { softline: t, group: s2, indent: a3, label: r } } = Oe(), { isNumericLiteral: u, isMemberExpression: i2, isCallExpression: o } = Ke$1(), { printOptionalToken: c } = ct$1();
  function y(d4, p, f) {
    let h2 = d4.getValue(), w2 = d4.getParentNode(), T2, A2 = 0;
    do
      T2 = d4.getParentNode(A2), A2++;
    while (T2 && (i2(T2) || T2.type === "TSNonNullExpression"));
    let S2 = f("object"), B = m2(d4, p, f), I2 = T2 && (T2.type === "NewExpression" || T2.type === "BindExpression" || T2.type === "AssignmentExpression" && T2.left.type !== "Identifier") || h2.computed || h2.object.type === "Identifier" && h2.property.type === "Identifier" && !i2(w2) || (w2.type === "AssignmentExpression" || w2.type === "VariableDeclarator") && (o(h2.object) && h2.object.arguments.length > 0 || h2.object.type === "TSNonNullExpression" && o(h2.object.expression) && h2.object.expression.arguments.length > 0 || S2.label === "member-chain");
    return r(S2.label === "member-chain" ? "member-chain" : "member", [S2, I2 ? B : s2(a3([t, B]))]);
  }
  function m2(d4, p, f) {
    let h2 = f("property"), w2 = d4.getValue(), T2 = c(d4);
    return w2.computed ? !w2.property || u(w2.property) ? [T2, "[", h2, "]"] : s2([T2, "[", a3([t, h2]), t, "]"]) : [T2, ".", h2];
  }
  n.exports = { printMemberExpression: y, printMemberLookup: m2 };
} }), qm = Z({ "src/language-js/print/member-chain.js"(e, n) {
  re();
  var { printComments: t } = et(), { getLast: s2, isNextLineEmptyAfterIndex: a3, getNextNonSpaceNonCommentCharacterIndex: r } = Ue$2(), u = It$1(), { isCallExpression: i2, isMemberExpression: o, isFunctionOrArrowExpression: c, isLongCurriedCallExpression: y, isMemberish: m2, isNumericLiteral: d4, isSimpleCallArgument: p, hasComment: f, CommentCheckFlags: h2, isNextLineEmpty: w2 } = Ke$1(), { locEnd: T2 } = st$1(), { builders: { join: A2, hardline: S2, group: B, indent: I2, conditionalGroup: k2, breakParent: P, label: C2 }, utils: { willBreak: D2 } } = Oe(), g2 = Za(), { printMemberLookup: F } = eo$2(), { printOptionalToken: l, printFunctionTypeParameters: E, printBindExpressionCallee: v } = ct$1();
  function N(x2, b2, L) {
    let M2 = x2.getParentNode(), j = !M2 || M2.type === "ExpressionStatement", $ = [];
    function V(de2) {
      let { originalText: ae2 } = b2, ve2 = r(ae2, de2, T2);
      return ae2.charAt(ve2) === ")" ? ve2 !== false && a3(ae2, ve2 + 1) : w2(de2, b2);
    }
    function q(de2) {
      let ae2 = de2.getValue();
      i2(ae2) && (m2(ae2.callee) || i2(ae2.callee)) ? ($.unshift({ node: ae2, printed: [t(de2, [l(de2), E(de2, b2, L), g2(de2, b2, L)], b2), V(ae2) ? S2 : ""] }), de2.call((ve2) => q(ve2), "callee")) : m2(ae2) ? ($.unshift({ node: ae2, needsParens: u(de2, b2), printed: t(de2, o(ae2) ? F(de2, b2, L) : v(de2, b2, L), b2) }), de2.call((ve2) => q(ve2), "object")) : ae2.type === "TSNonNullExpression" ? ($.unshift({ node: ae2, printed: t(de2, "!", b2) }), de2.call((ve2) => q(ve2), "expression")) : $.unshift({ node: ae2, printed: L() });
    }
    let Y3 = x2.getValue();
    $.unshift({ node: Y3, printed: [l(x2), E(x2, b2, L), g2(x2, b2, L)] }), Y3.callee && x2.call((de2) => q(de2), "callee");
    let H3 = [], R = [$[0]], Q = 1;
    for (; Q < $.length && ($[Q].node.type === "TSNonNullExpression" || i2($[Q].node) || o($[Q].node) && $[Q].node.computed && d4($[Q].node.property)); ++Q)
      R.push($[Q]);
    if (!i2($[0].node))
      for (; Q + 1 < $.length && (m2($[Q].node) && m2($[Q + 1].node)); ++Q)
        R.push($[Q]);
    H3.push(R), R = [];
    let ee2 = false;
    for (; Q < $.length; ++Q) {
      if (ee2 && m2($[Q].node)) {
        if ($[Q].node.computed && d4($[Q].node.property)) {
          R.push($[Q]);
          continue;
        }
        H3.push(R), R = [], ee2 = false;
      }
      (i2($[Q].node) || $[Q].node.type === "ImportExpression") && (ee2 = true), R.push($[Q]), f($[Q].node, h2.Trailing) && (H3.push(R), R = [], ee2 = false);
    }
    R.length > 0 && H3.push(R);
    function te2(de2) {
      return /^[A-Z]|^[$_]+$/.test(de2);
    }
    function oe2(de2) {
      return de2.length <= b2.tabWidth;
    }
    function W2(de2) {
      let ae2 = de2[1].length > 0 && de2[1][0].node.computed;
      if (de2[0].length === 1) {
        let K = de2[0][0].node;
        return K.type === "ThisExpression" || K.type === "Identifier" && (te2(K.name) || j && oe2(K.name) || ae2);
      }
      let ve2 = s2(de2[0]).node;
      return o(ve2) && ve2.property.type === "Identifier" && (te2(ve2.property.name) || ae2);
    }
    let X3 = H3.length >= 2 && !f(H3[1][0].node) && W2(H3);
    function ue2(de2) {
      let ae2 = de2.map((ve2) => ve2.printed);
      return de2.length > 0 && s2(de2).needsParens ? ["(", ...ae2, ")"] : ae2;
    }
    function De2(de2) {
      return de2.length === 0 ? "" : I2(B([S2, A2(S2, de2.map(ue2))]));
    }
    let ie = H3.map(ue2), G = ie, z = X3 ? 3 : 2, U = H3.flat(), le2 = U.slice(1, -1).some((de2) => f(de2.node, h2.Leading)) || U.slice(0, -1).some((de2) => f(de2.node, h2.Trailing)) || H3[z] && f(H3[z][0].node, h2.Leading);
    if (H3.length <= z && !le2)
      return y(x2) ? G : B(G);
    let ge2 = s2(H3[X3 ? 1 : 0]).node, Ae2 = !i2(ge2) && V(ge2), Ne2 = [ue2(H3[0]), X3 ? H3.slice(1, 2).map(ue2) : "", Ae2 ? S2 : "", De2(H3.slice(X3 ? 2 : 1))], ke2 = $.map((de2) => {
      let { node: ae2 } = de2;
      return ae2;
    }).filter(i2);
    function ce() {
      let de2 = s2(s2(H3)).node, ae2 = s2(ie);
      return i2(de2) && D2(ae2) && ke2.slice(0, -1).some((ve2) => ve2.arguments.some(c));
    }
    let pe;
    return le2 || ke2.length > 2 && ke2.some((de2) => !de2.arguments.every((ae2) => p(ae2, 0))) || ie.slice(0, -1).some(D2) || ce() ? pe = B(Ne2) : pe = [D2(G) || Ae2 ? P : "", k2([G, Ne2])], C2("member-chain", pe);
  }
  n.exports = N;
} }), to$2 = Z({ "src/language-js/print/call-expression.js"(e, n) {
  re();
  var { builders: { join: t, group: s2 } } = Oe(), a3 = It$1(), { getCallArguments: r, hasFlowAnnotationComment: u, isCallExpression: i2, isMemberish: o, isStringLiteral: c, isTemplateOnItsOwnLine: y, isTestCall: m2, iterateCallArgumentsPath: d4 } = Ke$1(), p = qm(), f = Za(), { printOptionalToken: h2, printFunctionTypeParameters: w2 } = ct$1();
  function T2(S2, B, I2) {
    let k2 = S2.getValue(), P = S2.getParentNode(), C2 = k2.type === "NewExpression", D2 = k2.type === "ImportExpression", g2 = h2(S2), F = r(k2);
    if (F.length > 0 && (!D2 && !C2 && A2(k2, P) || F.length === 1 && y(F[0], B.originalText) || !C2 && m2(k2, P))) {
      let v = [];
      return d4(S2, () => {
        v.push(I2());
      }), [C2 ? "new " : "", I2("callee"), g2, w2(S2, B, I2), "(", t(", ", v), ")"];
    }
    let l = (B.parser === "babel" || B.parser === "babel-flow") && k2.callee && k2.callee.type === "Identifier" && u(k2.callee.trailingComments);
    if (l && (k2.callee.trailingComments[0].printed = true), !D2 && !C2 && o(k2.callee) && !S2.call((v) => a3(v, B), "callee"))
      return p(S2, B, I2);
    let E = [C2 ? "new " : "", D2 ? "import" : I2("callee"), g2, l ? "/*:: ".concat(k2.callee.trailingComments[0].value.slice(2).trim(), " */") : "", w2(S2, B, I2), f(S2, B, I2)];
    return D2 || i2(k2.callee) ? s2(E) : E;
  }
  function A2(S2, B) {
    if (S2.callee.type !== "Identifier")
      return false;
    if (S2.callee.name === "require")
      return true;
    if (S2.callee.name === "define") {
      let I2 = r(S2);
      return B.type === "ExpressionStatement" && (I2.length === 1 || I2.length === 2 && I2[0].type === "ArrayExpression" || I2.length === 3 && c(I2[0]) && I2[1].type === "ArrayExpression");
    }
    return false;
  }
  n.exports = { printCallExpression: T2 };
} }), Xt = Z({ "src/language-js/print/assignment.js"(e, n) {
  re();
  var { isNonEmptyArray: t, getStringWidth: s2 } = Ue$2(), { builders: { line: a3, group: r, indent: u, indentIfBreak: i2, lineSuffixBoundary: o }, utils: { cleanDoc: c, willBreak: y, canBreak: m2 } } = Oe(), { hasLeadingOwnLineComment: d4, isBinaryish: p, isStringLiteral: f, isLiteral: h2, isNumericLiteral: w2, isCallExpression: T2, isMemberExpression: A2, getCallArguments: S2, rawText: B, hasComment: I2, isSignedNumericLiteral: k2, isObjectProperty: P } = Ke$1(), { shouldInlineLogicalExpression: C2 } = $n$1(), { printCallExpression: D2 } = to$2();
  function g2(W2, X3, ue2, De2, ie, G) {
    let z = E(W2, X3, ue2, De2, G), U = ue2(G, { assignmentLayout: z });
    switch (z) {
      case "break-after-operator":
        return r([r(De2), ie, r(u([a3, U]))]);
      case "never-break-after-operator":
        return r([r(De2), ie, " ", U]);
      case "fluid": {
        let le2 = Symbol("assignment");
        return r([r(De2), ie, r(u(a3), { id: le2 }), o, i2(U, { groupId: le2 })]);
      }
      case "break-lhs":
        return r([De2, ie, " ", r(U)]);
      case "chain":
        return [r(De2), ie, a3, U];
      case "chain-tail":
        return [r(De2), ie, u([a3, U])];
      case "chain-tail-arrow-chain":
        return [r(De2), ie, U];
      case "only-left":
        return De2;
    }
  }
  function F(W2, X3, ue2) {
    let De2 = W2.getValue();
    return g2(W2, X3, ue2, ue2("left"), [" ", De2.operator], "right");
  }
  function l(W2, X3, ue2) {
    return g2(W2, X3, ue2, ue2("id"), " =", "init");
  }
  function E(W2, X3, ue2, De2, ie) {
    let G = W2.getValue(), z = G[ie];
    if (!z)
      return "only-left";
    let U = !x2(z);
    if (W2.match(x2, b2, (Ne2) => !U || Ne2.type !== "ExpressionStatement" && Ne2.type !== "VariableDeclaration"))
      return U ? z.type === "ArrowFunctionExpression" && z.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
    if (!U && x2(z.right) || d4(X3.originalText, z))
      return "break-after-operator";
    if (z.type === "CallExpression" && z.callee.name === "require" || X3.parser === "json5" || X3.parser === "json")
      return "never-break-after-operator";
    if (N(G) || L(G) || $(G) || V(G) && m2(De2))
      return "break-lhs";
    let Ae2 = ee2(G, De2, X3);
    return W2.call(() => v(W2, X3, ue2, Ae2), ie) ? "break-after-operator" : Ae2 || z.type === "TemplateLiteral" || z.type === "TaggedTemplateExpression" || z.type === "BooleanLiteral" || w2(z) || z.type === "ClassExpression" ? "never-break-after-operator" : "fluid";
  }
  function v(W2, X3, ue2, De2) {
    let ie = W2.getValue();
    if (p(ie) && !C2(ie))
      return true;
    switch (ie.type) {
      case "StringLiteralTypeAnnotation":
      case "SequenceExpression":
        return true;
      case "ConditionalExpression": {
        let { test: U } = ie;
        return p(U) && !C2(U);
      }
      case "ClassExpression":
        return t(ie.decorators);
    }
    if (De2)
      return false;
    let G = ie, z = [];
    for (; ; )
      if (G.type === "UnaryExpression")
        G = G.argument, z.push("argument");
      else if (G.type === "TSNonNullExpression")
        G = G.expression, z.push("expression");
      else
        break;
    return !!(f(G) || W2.call(() => H3(W2, X3, ue2), ...z));
  }
  function N(W2) {
    if (b2(W2)) {
      let X3 = W2.left || W2.id;
      return X3.type === "ObjectPattern" && X3.properties.length > 2 && X3.properties.some((ue2) => P(ue2) && (!ue2.shorthand || ue2.value && ue2.value.type === "AssignmentPattern"));
    }
    return false;
  }
  function x2(W2) {
    return W2.type === "AssignmentExpression";
  }
  function b2(W2) {
    return x2(W2) || W2.type === "VariableDeclarator";
  }
  function L(W2) {
    let X3 = M2(W2);
    if (t(X3)) {
      let ue2 = W2.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
      if (X3.length > 1 && X3.some((De2) => De2[ue2] || De2.default))
        return true;
    }
    return false;
  }
  function M2(W2) {
    return j(W2) && W2.typeParameters && W2.typeParameters.params ? W2.typeParameters.params : null;
  }
  function j(W2) {
    return W2.type === "TSTypeAliasDeclaration" || W2.type === "TypeAlias";
  }
  function $(W2) {
    if (W2.type !== "VariableDeclarator")
      return false;
    let { typeAnnotation: X3 } = W2.id;
    if (!X3 || !X3.typeAnnotation)
      return false;
    let ue2 = q(X3.typeAnnotation);
    return t(ue2) && ue2.length > 1 && ue2.some((De2) => t(q(De2)) || De2.type === "TSConditionalType");
  }
  function V(W2) {
    return W2.type === "VariableDeclarator" && W2.init && W2.init.type === "ArrowFunctionExpression";
  }
  function q(W2) {
    return Y3(W2) && W2.typeParameters && W2.typeParameters.params ? W2.typeParameters.params : null;
  }
  function Y3(W2) {
    return W2.type === "TSTypeReference" || W2.type === "GenericTypeAnnotation";
  }
  function H3(W2, X3, ue2) {
    let De2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, ie = W2.getValue(), G = () => H3(W2, X3, ue2, true);
    if (ie.type === "TSNonNullExpression")
      return W2.call(G, "expression");
    if (T2(ie)) {
      if (D2(W2, X3, ue2).label === "member-chain")
        return false;
      let U = S2(ie);
      return !(U.length === 0 || U.length === 1 && Q(U[0], X3)) || te2(ie, ue2) ? false : W2.call(G, "callee");
    }
    return A2(ie) ? W2.call(G, "object") : De2 && (ie.type === "Identifier" || ie.type === "ThisExpression");
  }
  var R = 0.25;
  function Q(W2, X3) {
    let { printWidth: ue2 } = X3;
    if (I2(W2))
      return false;
    let De2 = ue2 * R;
    if (W2.type === "ThisExpression" || W2.type === "Identifier" && W2.name.length <= De2 || k2(W2) && !I2(W2.argument))
      return true;
    let ie = W2.type === "Literal" && "regex" in W2 && W2.regex.pattern || W2.type === "RegExpLiteral" && W2.pattern;
    return ie ? ie.length <= De2 : f(W2) ? B(W2).length <= De2 : W2.type === "TemplateLiteral" ? W2.expressions.length === 0 && W2.quasis[0].value.raw.length <= De2 && !W2.quasis[0].value.raw.includes(`
`) : h2(W2);
  }
  function ee2(W2, X3, ue2) {
    if (!P(W2))
      return false;
    X3 = c(X3);
    let De2 = 3;
    return typeof X3 == "string" && s2(X3) < ue2.tabWidth + De2;
  }
  function te2(W2, X3) {
    let ue2 = oe2(W2);
    if (t(ue2)) {
      if (ue2.length > 1)
        return true;
      if (ue2.length === 1) {
        let ie = ue2[0];
        if (ie.type === "TSUnionType" || ie.type === "UnionTypeAnnotation" || ie.type === "TSIntersectionType" || ie.type === "IntersectionTypeAnnotation" || ie.type === "TSTypeLiteral" || ie.type === "ObjectTypeAnnotation")
          return true;
      }
      let De2 = W2.typeParameters ? "typeParameters" : "typeArguments";
      if (y(X3(De2)))
        return true;
    }
    return false;
  }
  function oe2(W2) {
    return W2.typeParameters && W2.typeParameters.params || W2.typeArguments && W2.typeArguments.params;
  }
  n.exports = { printVariableDeclarator: l, printAssignmentExpression: F, printAssignment: g2, isArrowFunctionVariableDeclarator: V };
} }), wr$1 = Z({ "src/language-js/print/function-parameters.js"(e, n) {
  re();
  var { getNextNonSpaceNonCommentCharacter: t } = Ue$2(), { printDanglingComments: s2 } = et(), { builders: { line: a3, hardline: r, softline: u, group: i2, indent: o, ifBreak: c }, utils: { removeLines: y, willBreak: m2 } } = Oe(), { getFunctionParameters: d4, iterateFunctionParametersPath: p, isSimpleType: f, isTestCall: h2, isTypeAnnotationAFunction: w2, isObjectType: T2, isObjectTypePropertyAFunction: A2, hasRestParameter: S2, shouldPrintComma: B, hasComment: I2, isNextLineEmpty: k2 } = Ke$1(), { locEnd: P } = st$1(), { ArgExpansionBailout: C2 } = Jt$1(), { printFunctionTypeParameters: D2 } = ct$1();
  function g2(v, N, x2, b2, L) {
    let M2 = v.getValue(), j = d4(M2), $ = L ? D2(v, x2, N) : "";
    if (j.length === 0)
      return [$, "(", s2(v, x2, true, (ee2) => t(x2.originalText, ee2, P) === ")"), ")"];
    let V = v.getParentNode(), q = h2(V), Y3 = F(M2), H3 = [];
    if (p(v, (ee2, te2) => {
      let oe2 = te2 === j.length - 1;
      oe2 && M2.rest && H3.push("..."), H3.push(N()), !oe2 && (H3.push(","), q || Y3 ? H3.push(" ") : k2(j[te2], x2) ? H3.push(r, r) : H3.push(a3));
    }), b2) {
      if (m2($) || m2(H3))
        throw new C2();
      return i2([y($), "(", y(H3), ")"]);
    }
    let R = j.every((ee2) => !ee2.decorators);
    return Y3 && R ? [$, "(", ...H3, ")"] : q ? [$, "(", ...H3, ")"] : (A2(V) || w2(V) || V.type === "TypeAlias" || V.type === "UnionTypeAnnotation" || V.type === "TSUnionType" || V.type === "IntersectionTypeAnnotation" || V.type === "FunctionTypeAnnotation" && V.returnType === M2) && j.length === 1 && j[0].name === null && M2.this !== j[0] && j[0].typeAnnotation && M2.typeParameters === null && f(j[0].typeAnnotation) && !M2.rest ? x2.arrowParens === "always" ? ["(", ...H3, ")"] : H3 : [$, "(", o([u, ...H3]), c(!S2(M2) && B(x2, "all") ? "," : ""), u, ")"];
  }
  function F(v) {
    if (!v)
      return false;
    let N = d4(v);
    if (N.length !== 1)
      return false;
    let [x2] = N;
    return !I2(x2) && (x2.type === "ObjectPattern" || x2.type === "ArrayPattern" || x2.type === "Identifier" && x2.typeAnnotation && (x2.typeAnnotation.type === "TypeAnnotation" || x2.typeAnnotation.type === "TSTypeAnnotation") && T2(x2.typeAnnotation.typeAnnotation) || x2.type === "FunctionTypeParam" && T2(x2.typeAnnotation) || x2.type === "AssignmentPattern" && (x2.left.type === "ObjectPattern" || x2.left.type === "ArrayPattern") && (x2.right.type === "Identifier" || x2.right.type === "ObjectExpression" && x2.right.properties.length === 0 || x2.right.type === "ArrayExpression" && x2.right.elements.length === 0));
  }
  function l(v) {
    let N;
    return v.returnType ? (N = v.returnType, N.typeAnnotation && (N = N.typeAnnotation)) : v.typeAnnotation && (N = v.typeAnnotation), N;
  }
  function E(v, N) {
    let x2 = l(v);
    if (!x2)
      return false;
    let b2 = v.typeParameters && v.typeParameters.params;
    if (b2) {
      if (b2.length > 1)
        return false;
      if (b2.length === 1) {
        let L = b2[0];
        if (L.constraint || L.default)
          return false;
      }
    }
    return d4(v).length === 1 && (T2(x2) || m2(N));
  }
  n.exports = { printFunctionParameters: g2, shouldHugFunctionParameters: F, shouldGroupFunctionParameters: E };
} }), _r$1 = Z({ "src/language-js/print/type-annotation.js"(e, n) {
  re();
  var { printComments: t, printDanglingComments: s2 } = et(), { isNonEmptyArray: a3 } = Ue$2(), { builders: { group: r, join: u, line: i2, softline: o, indent: c, align: y, ifBreak: m2 } } = Oe(), d4 = It$1(), { locStart: p } = st$1(), { isSimpleType: f, isObjectType: h2, hasLeadingOwnLineComment: w2, isObjectTypePropertyAFunction: T2, shouldPrintComma: A2 } = Ke$1(), { printAssignment: S2 } = Xt(), { printFunctionParameters: B, shouldGroupFunctionParameters: I2 } = wr$1(), { printArrayItems: k2 } = zt$1();
  function P(x2) {
    if (f(x2) || h2(x2))
      return true;
    if (x2.type === "UnionTypeAnnotation" || x2.type === "TSUnionType") {
      let b2 = x2.types.filter((M2) => M2.type === "VoidTypeAnnotation" || M2.type === "TSVoidKeyword" || M2.type === "NullLiteralTypeAnnotation" || M2.type === "TSNullKeyword").length, L = x2.types.some((M2) => M2.type === "ObjectTypeAnnotation" || M2.type === "TSTypeLiteral" || M2.type === "GenericTypeAnnotation" || M2.type === "TSTypeReference");
      if (x2.types.length - 1 === b2 && L)
        return true;
    }
    return false;
  }
  function C2(x2, b2, L) {
    let M2 = b2.semi ? ";" : "", j = x2.getValue(), $ = [];
    return $.push("opaque type ", L("id"), L("typeParameters")), j.supertype && $.push(": ", L("supertype")), j.impltype && $.push(" = ", L("impltype")), $.push(M2), $;
  }
  function D2(x2, b2, L) {
    let M2 = b2.semi ? ";" : "", j = x2.getValue(), $ = [];
    j.declare && $.push("declare "), $.push("type ", L("id"), L("typeParameters"));
    let V = j.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
    return [S2(x2, b2, L, $, " =", V), M2];
  }
  function g2(x2, b2, L) {
    let M2 = x2.getValue(), j = x2.map(L, "types"), $ = [], V = false;
    for (let q = 0; q < j.length; ++q)
      q === 0 ? $.push(j[q]) : h2(M2.types[q - 1]) && h2(M2.types[q]) ? $.push([" & ", V ? c(j[q]) : j[q]]) : !h2(M2.types[q - 1]) && !h2(M2.types[q]) ? $.push(c([" &", i2, j[q]])) : (q > 1 && (V = true), $.push(" & ", q > 1 ? c(j[q]) : j[q]));
    return r($);
  }
  function F(x2, b2, L) {
    let M2 = x2.getValue(), j = x2.getParentNode(), $ = j.type !== "TypeParameterInstantiation" && j.type !== "TSTypeParameterInstantiation" && j.type !== "GenericTypeAnnotation" && j.type !== "TSTypeReference" && j.type !== "TSTypeAssertion" && j.type !== "TupleTypeAnnotation" && j.type !== "TSTupleType" && !(j.type === "FunctionTypeParam" && !j.name && x2.getParentNode(1).this !== j) && !((j.type === "TypeAlias" || j.type === "VariableDeclarator" || j.type === "TSTypeAliasDeclaration") && w2(b2.originalText, M2)), V = P(M2), q = x2.map((R) => {
      let Q = L();
      return V || (Q = y(2, Q)), t(R, Q, b2);
    }, "types");
    if (V)
      return u(" | ", q);
    let Y3 = $ && !w2(b2.originalText, M2), H3 = [m2([Y3 ? i2 : "", "| "]), u([i2, "| "], q)];
    return d4(x2, b2) ? r([c(H3), o]) : j.type === "TupleTypeAnnotation" && j.types.length > 1 || j.type === "TSTupleType" && j.elementTypes.length > 1 ? r([c([m2(["(", o]), H3]), o, m2(")")]) : r($ ? c(H3) : H3);
  }
  function l(x2, b2, L) {
    let M2 = x2.getValue(), j = [], $ = x2.getParentNode(0), V = x2.getParentNode(1), q = x2.getParentNode(2), Y3 = M2.type === "TSFunctionType" || !(($.type === "ObjectTypeProperty" || $.type === "ObjectTypeInternalSlot") && !$.variance && !$.optional && p($) === p(M2) || $.type === "ObjectTypeCallProperty" || q && q.type === "DeclareFunction"), H3 = Y3 && ($.type === "TypeAnnotation" || $.type === "TSTypeAnnotation"), R = H3 && Y3 && ($.type === "TypeAnnotation" || $.type === "TSTypeAnnotation") && V.type === "ArrowFunctionExpression";
    T2($) && (Y3 = true, H3 = true), R && j.push("(");
    let Q = B(x2, L, b2, false, true), ee2 = M2.returnType || M2.predicate || M2.typeAnnotation ? [Y3 ? " => " : ": ", L("returnType"), L("predicate"), L("typeAnnotation")] : "", te2 = I2(M2, ee2);
    return j.push(te2 ? r(Q) : Q), ee2 && j.push(ee2), R && j.push(")"), r(j);
  }
  function E(x2, b2, L) {
    let M2 = x2.getValue(), j = M2.type === "TSTupleType" ? "elementTypes" : "types", $ = M2[j], V = a3($), q = V ? o : "";
    return r(["[", c([q, k2(x2, b2, j, L)]), m2(V && A2(b2, "all") ? "," : ""), s2(x2, b2, true), q, "]"]);
  }
  function v(x2, b2, L) {
    let M2 = x2.getValue(), j = M2.type === "OptionalIndexedAccessType" && M2.optional ? "?.[" : "[";
    return [L("objectType"), j, L("indexType"), "]"];
  }
  function N(x2, b2, L) {
    let M2 = x2.getValue();
    return [M2.postfix ? "" : L, b2("typeAnnotation"), M2.postfix ? L : ""];
  }
  n.exports = { printOpaqueType: C2, printTypeAlias: D2, printIntersectionType: g2, printUnionType: F, printFunctionType: l, printTupleType: E, printIndexedAccessType: v, shouldHugType: P, printJSDocType: N };
} }), Pr$1 = Z({ "src/language-js/print/type-parameters.js"(e, n) {
  re();
  var { printDanglingComments: t } = et(), { builders: { join: s2, line: a3, hardline: r, softline: u, group: i2, indent: o, ifBreak: c } } = Oe(), { isTestCall: y, hasComment: m2, CommentCheckFlags: d4, isTSXFile: p, shouldPrintComma: f, getFunctionParameters: h2, isObjectType: w2 } = Ke$1(), { createGroupIdMapper: T2 } = Ue$2(), { shouldHugType: A2 } = _r$1(), { isArrowFunctionVariableDeclarator: S2 } = Xt(), B = T2("typeParameters");
  function I2(C2, D2, g2, F) {
    let l = C2.getValue();
    if (!l[F])
      return "";
    if (!Array.isArray(l[F]))
      return g2(F);
    let E = C2.getNode(2), v = E && y(E);
    if (!C2.match((L) => !(L[F].length === 1 && w2(L[F][0])), void 0, (L, M2) => M2 === "typeAnnotation", (L) => L.type === "Identifier", S2) && (v || l[F].length === 0 || l[F].length === 1 && (l[F][0].type === "NullableTypeAnnotation" || A2(l[F][0]))))
      return ["<", s2(", ", C2.map(g2, F)), k2(C2, D2), ">"];
    let b2 = l.type === "TSTypeParameterInstantiation" ? "" : h2(l).length === 1 && p(D2) && !l[F][0].constraint && C2.getParentNode().type === "ArrowFunctionExpression" ? "," : f(D2, "all") ? c(",") : "";
    return i2(["<", o([u, s2([",", a3], C2.map(g2, F))]), b2, u, ">"], { id: B(l) });
  }
  function k2(C2, D2) {
    let g2 = C2.getValue();
    if (!m2(g2, d4.Dangling))
      return "";
    let F = !m2(g2, d4.Line), l = t(C2, D2, F);
    return F ? l : [l, r];
  }
  function P(C2, D2, g2) {
    let F = C2.getValue(), l = [], E = C2.getParentNode();
    return E.type === "TSMappedType" ? (l.push("[", g2("name")), F.constraint && l.push(" in ", g2("constraint")), E.nameType && l.push(" as ", C2.callParent(() => g2("nameType"))), l.push("]"), l) : (F.variance && l.push(g2("variance")), F.in && l.push("in "), F.out && l.push("out "), l.push(g2("name")), F.bound && l.push(": ", g2("bound")), F.constraint && l.push(" extends ", g2("constraint")), F.default && l.push(" = ", g2("default")), l);
  }
  n.exports = { printTypeParameter: P, printTypeParameters: I2, getTypeParametersGroupId: B };
} }), Kt = Z({ "src/language-js/print/property.js"(e, n) {
  re();
  var { printComments: t } = et(), { printString: s2, printNumber: a3 } = Ue$2(), { isNumericLiteral: r, isSimpleNumber: u, isStringLiteral: i2, isStringPropSafeToUnquote: o, rawText: c } = Ke$1(), { printAssignment: y } = Xt(), m2 = /* @__PURE__ */ new WeakMap();
  function d4(f, h2, w2) {
    let T2 = f.getNode();
    if (T2.computed)
      return ["[", w2("key"), "]"];
    let A2 = f.getParentNode(), { key: S2 } = T2;
    if (T2.type === "ClassPrivateProperty" && S2.type === "Identifier")
      return ["#", w2("key")];
    if (h2.quoteProps === "consistent" && !m2.has(A2)) {
      let B = (A2.properties || A2.body || A2.members).some((I2) => !I2.computed && I2.key && i2(I2.key) && !o(I2, h2));
      m2.set(A2, B);
    }
    if ((S2.type === "Identifier" || r(S2) && u(a3(c(S2))) && String(S2.value) === a3(c(S2)) && !(h2.parser === "typescript" || h2.parser === "babel-ts")) && (h2.parser === "json" || h2.quoteProps === "consistent" && m2.get(A2))) {
      let B = s2(JSON.stringify(S2.type === "Identifier" ? S2.name : S2.value.toString()), h2);
      return f.call((I2) => t(I2, B, h2), "key");
    }
    return o(T2, h2) && (h2.quoteProps === "as-needed" || h2.quoteProps === "consistent" && !m2.get(A2)) ? f.call((B) => t(B, /^\d/.test(S2.value) ? a3(S2.value) : S2.value, h2), "key") : w2("key");
  }
  function p(f, h2, w2) {
    return f.getValue().shorthand ? w2("value") : y(f, h2, w2, d4(f, h2, w2), ":", "value");
  }
  n.exports = { printProperty: p, printPropertyKey: d4 };
} }), kr$1 = Z({ "src/language-js/print/function.js"(e, n) {
  re();
  var t = Ut$1(), { printDanglingComments: s2, printCommentsSeparately: a3 } = et(), r = it$2(), { getNextNonSpaceNonCommentCharacterIndex: u } = Ue$2(), { builders: { line: i2, softline: o, group: c, indent: y, ifBreak: m2, hardline: d4, join: p, indentIfBreak: f }, utils: { removeLines: h2, willBreak: w2 } } = Oe(), { ArgExpansionBailout: T2 } = Jt$1(), { getFunctionParameters: A2, hasLeadingOwnLineComment: S2, isFlowAnnotationComment: B, isJsxNode: I2, isTemplateOnItsOwnLine: k2, shouldPrintComma: P, startsWithNoLookaheadToken: C2, isBinaryish: D2, isLineComment: g2, hasComment: F, getComments: l, CommentCheckFlags: E, isCallLikeExpression: v, isCallExpression: N, getCallArguments: x2, hasNakedLeftSide: b2, getLeftSide: L } = Ke$1(), { locEnd: M2 } = st$1(), { printFunctionParameters: j, shouldGroupFunctionParameters: $ } = wr$1(), { printPropertyKey: V } = Kt(), { printFunctionTypeParameters: q } = ct$1();
  function Y3(z, U, le2, ge2) {
    let Ae2 = z.getValue(), Ne2 = false;
    if ((Ae2.type === "FunctionDeclaration" || Ae2.type === "FunctionExpression") && ge2 && ge2.expandLastArg) {
      let ae2 = z.getParentNode();
      N(ae2) && x2(ae2).length > 1 && (Ne2 = true);
    }
    let ke2 = [];
    Ae2.type === "TSDeclareFunction" && Ae2.declare && ke2.push("declare "), Ae2.async && ke2.push("async "), Ae2.generator ? ke2.push("function* ") : ke2.push("function "), Ae2.id && ke2.push(U("id"));
    let ce = j(z, U, le2, Ne2), pe = X3(z, U, le2), de2 = $(Ae2, pe);
    return ke2.push(q(z, le2, U), c([de2 ? c(ce) : ce, pe]), Ae2.body ? " " : "", U("body")), le2.semi && (Ae2.declare || !Ae2.body) && ke2.push(";"), ke2;
  }
  function H3(z, U, le2) {
    let ge2 = z.getNode(), { kind: Ae2 } = ge2, Ne2 = ge2.value || ge2, ke2 = [];
    return !Ae2 || Ae2 === "init" || Ae2 === "method" || Ae2 === "constructor" ? Ne2.async && ke2.push("async ") : (t.ok(Ae2 === "get" || Ae2 === "set"), ke2.push(Ae2, " ")), Ne2.generator && ke2.push("*"), ke2.push(V(z, U, le2), ge2.optional || ge2.key.optional ? "?" : ""), ge2 === Ne2 ? ke2.push(R(z, U, le2)) : Ne2.type === "FunctionExpression" ? ke2.push(z.call((ce) => R(ce, U, le2), "value")) : ke2.push(le2("value")), ke2;
  }
  function R(z, U, le2) {
    let ge2 = z.getNode(), Ae2 = j(z, le2, U), Ne2 = X3(z, le2, U), ke2 = $(ge2, Ne2), ce = [q(z, U, le2), c([ke2 ? c(Ae2) : Ae2, Ne2])];
    return ge2.body ? ce.push(" ", le2("body")) : ce.push(U.semi ? ";" : ""), ce;
  }
  function Q(z, U, le2, ge2) {
    let Ae2 = z.getValue(), Ne2 = [];
    if (Ae2.async && Ne2.push("async "), W2(z, U))
      Ne2.push(le2(["params", 0]));
    else {
      let ce = ge2 && (ge2.expandLastArg || ge2.expandFirstArg), pe = X3(z, le2, U);
      if (ce) {
        if (w2(pe))
          throw new T2();
        pe = c(h2(pe));
      }
      Ne2.push(c([j(z, le2, U, ce, true), pe]));
    }
    let ke2 = s2(z, U, true, (ce) => {
      let pe = u(U.originalText, ce, M2);
      return pe !== false && U.originalText.slice(pe, pe + 2) === "=>";
    });
    return ke2 && Ne2.push(" ", ke2), Ne2;
  }
  function ee2(z, U, le2, ge2, Ae2, Ne2) {
    let ke2 = z.getName(), ce = z.getParentNode(), pe = v(ce) && ke2 === "callee", de2 = Boolean(U && U.assignmentLayout), ae2 = Ne2.body.type !== "BlockStatement" && Ne2.body.type !== "ObjectExpression" && Ne2.body.type !== "SequenceExpression", ve2 = pe && ae2 || U && U.assignmentLayout === "chain-tail-arrow-chain", K = Symbol("arrow-chain");
    return Ne2.body.type === "SequenceExpression" && (Ae2 = c(["(", y([o, Ae2]), o, ")"])), c([c(y([pe || de2 ? o : "", c(p([" =>", i2], le2), { shouldBreak: ge2 })]), { id: K, shouldBreak: ve2 }), " =>", f(ae2 ? y([i2, Ae2]) : [" ", Ae2], { groupId: K }), pe ? m2(o, "", { groupId: K }) : ""]);
  }
  function te2(z, U, le2, ge2) {
    let Ae2 = z.getValue(), Ne2 = [], ke2 = [], ce = false;
    if (function K() {
      let he2 = Q(z, U, le2, ge2);
      if (Ne2.length === 0)
        Ne2.push(he2);
      else {
        let { leading: ye2, trailing: Ce2 } = a3(z, U);
        Ne2.push([ye2, he2]), ke2.unshift(Ce2);
      }
      ce = ce || Ae2.returnType && A2(Ae2).length > 0 || Ae2.typeParameters || A2(Ae2).some((ye2) => ye2.type !== "Identifier"), Ae2.body.type !== "ArrowFunctionExpression" || ge2 && ge2.expandLastArg ? ke2.unshift(le2("body", ge2)) : (Ae2 = Ae2.body, z.call(K, "body"));
    }(), Ne2.length > 1)
      return ee2(z, ge2, Ne2, ce, ke2, Ae2);
    let pe = Ne2;
    if (pe.push(" =>"), !S2(U.originalText, Ae2.body) && (Ae2.body.type === "ArrayExpression" || Ae2.body.type === "ObjectExpression" || Ae2.body.type === "BlockStatement" || I2(Ae2.body) || k2(Ae2.body, U.originalText) || Ae2.body.type === "ArrowFunctionExpression" || Ae2.body.type === "DoExpression"))
      return c([...pe, " ", ke2]);
    if (Ae2.body.type === "SequenceExpression")
      return c([...pe, c([" (", y([o, ke2]), o, ")"])]);
    let de2 = (ge2 && ge2.expandLastArg || z.getParentNode().type === "JSXExpressionContainer") && !F(Ae2), ae2 = ge2 && ge2.expandLastArg && P(U, "all"), ve2 = Ae2.body.type === "ConditionalExpression" && !C2(Ae2.body, false);
    return c([...pe, c([y([i2, ve2 ? m2("", "(") : "", ke2, ve2 ? m2("", ")") : ""]), de2 ? [m2(ae2 ? "," : ""), o] : ""])]);
  }
  function oe2(z) {
    let U = A2(z);
    return U.length === 1 && !z.typeParameters && !F(z, E.Dangling) && U[0].type === "Identifier" && !U[0].typeAnnotation && !F(U[0]) && !U[0].optional && !z.predicate && !z.returnType;
  }
  function W2(z, U) {
    if (U.arrowParens === "always")
      return false;
    if (U.arrowParens === "avoid") {
      let le2 = z.getValue();
      return oe2(le2);
    }
    return false;
  }
  function X3(z, U, le2) {
    let ge2 = z.getValue(), Ae2 = U("returnType");
    if (ge2.returnType && B(le2.originalText, ge2.returnType))
      return [" /*: ", Ae2, " */"];
    let Ne2 = [Ae2];
    return ge2.returnType && ge2.returnType.typeAnnotation && Ne2.unshift(": "), ge2.predicate && Ne2.push(ge2.returnType ? " " : ": ", U("predicate")), Ne2;
  }
  function ue2(z, U, le2) {
    let ge2 = z.getValue(), Ae2 = U.semi ? ";" : "", Ne2 = [];
    ge2.argument && (G(U, ge2.argument) ? Ne2.push([" (", y([d4, le2("argument")]), d4, ")"]) : D2(ge2.argument) || ge2.argument.type === "SequenceExpression" ? Ne2.push(c([m2(" (", " "), y([o, le2("argument")]), o, m2(")")])) : Ne2.push(" ", le2("argument")));
    let ke2 = l(ge2), ce = r(ke2), pe = ce && g2(ce);
    return pe && Ne2.push(Ae2), F(ge2, E.Dangling) && Ne2.push(" ", s2(z, U, true)), pe || Ne2.push(Ae2), Ne2;
  }
  function De2(z, U, le2) {
    return ["return", ue2(z, U, le2)];
  }
  function ie(z, U, le2) {
    return ["throw", ue2(z, U, le2)];
  }
  function G(z, U) {
    if (S2(z.originalText, U))
      return true;
    if (b2(U)) {
      let le2 = U, ge2;
      for (; ge2 = L(le2); )
        if (le2 = ge2, S2(z.originalText, le2))
          return true;
    }
    return false;
  }
  n.exports = { printFunction: Y3, printArrowFunction: te2, printMethod: H3, printReturnStatement: De2, printThrowStatement: ie, printMethodInternal: R, shouldPrintParamsWithoutParens: W2 };
} }), Hn$3 = Z({ "src/language-js/print/decorators.js"(e, n) {
  re();
  var { isNonEmptyArray: t, hasNewline: s2 } = Ue$2(), { builders: { line: a3, hardline: r, join: u, breakParent: i2, group: o } } = Oe(), { locStart: c, locEnd: y } = st$1(), { getParentExportDeclaration: m2 } = Ke$1();
  function d4(T2, A2, S2) {
    let B = T2.getValue();
    return o([u(a3, T2.map(S2, "decorators")), h2(B, A2) ? r : a3]);
  }
  function p(T2, A2, S2) {
    return [u(r, T2.map(S2, "declaration", "decorators")), r];
  }
  function f(T2, A2, S2) {
    let B = T2.getValue(), { decorators: I2 } = B;
    if (!t(I2) || w2(T2.getParentNode()))
      return;
    let k2 = B.type === "ClassExpression" || B.type === "ClassDeclaration" || h2(B, A2);
    return [m2(T2) ? r : k2 ? i2 : "", u(a3, T2.map(S2, "decorators")), a3];
  }
  function h2(T2, A2) {
    return T2.decorators.some((S2) => s2(A2.originalText, y(S2)));
  }
  function w2(T2) {
    if (T2.type !== "ExportDefaultDeclaration" && T2.type !== "ExportNamedDeclaration" && T2.type !== "DeclareExportDeclaration")
      return false;
    let A2 = T2.declaration && T2.declaration.decorators;
    return t(A2) && c(T2, { ignoreDecorators: true }) > c(A2[0]);
  }
  n.exports = { printDecorators: f, printClassMemberDecorators: d4, printDecoratorsBeforeExport: p, hasDecoratorsBeforeExport: w2 };
} }), Yt = Z({ "src/language-js/print/class.js"(e, n) {
  re();
  var { isNonEmptyArray: t, createGroupIdMapper: s2 } = Ue$2(), { printComments: a3, printDanglingComments: r } = et(), { builders: { join: u, line: i2, hardline: o, softline: c, group: y, indent: m2, ifBreak: d4 } } = Oe(), { hasComment: p, CommentCheckFlags: f } = Ke$1(), { getTypeParametersGroupId: h2 } = Pr$1(), { printMethod: w2 } = kr$1(), { printOptionalToken: T2, printTypeAnnotation: A2, printDefiniteToken: S2 } = ct$1(), { printPropertyKey: B } = Kt(), { printAssignment: I2 } = Xt(), { printClassMemberDecorators: k2 } = Hn$3();
  function P(x2, b2, L) {
    let M2 = x2.getValue(), j = [];
    M2.declare && j.push("declare "), M2.abstract && j.push("abstract "), j.push("class");
    let $ = M2.id && p(M2.id, f.Trailing) || M2.typeParameters && p(M2.typeParameters, f.Trailing) || M2.superClass && p(M2.superClass) || t(M2.extends) || t(M2.mixins) || t(M2.implements), V = [], q = [];
    if (M2.id && V.push(" ", L("id")), V.push(L("typeParameters")), M2.superClass) {
      let Y3 = [E(x2, b2, L), L("superTypeParameters")], H3 = x2.call((R) => ["extends ", a3(R, Y3, b2)], "superClass");
      $ ? q.push(i2, y(H3)) : q.push(" ", H3);
    } else
      q.push(l(x2, b2, L, "extends"));
    if (q.push(l(x2, b2, L, "mixins"), l(x2, b2, L, "implements")), $) {
      let Y3;
      F(M2) ? Y3 = [...V, m2(q)] : Y3 = m2([...V, q]), j.push(y(Y3, { id: C2(M2) }));
    } else
      j.push(...V, ...q);
    return j.push(" ", L("body")), j;
  }
  var C2 = s2("heritageGroup");
  function D2(x2) {
    return d4(o, "", { groupId: C2(x2) });
  }
  function g2(x2) {
    return ["superClass", "extends", "mixins", "implements"].filter((b2) => Boolean(x2[b2])).length > 1;
  }
  function F(x2) {
    return x2.typeParameters && !p(x2.typeParameters, f.Trailing | f.Line) && !g2(x2);
  }
  function l(x2, b2, L, M2) {
    let j = x2.getValue();
    if (!t(j[M2]))
      return "";
    let $ = r(x2, b2, true, (V) => {
      let { marker: q } = V;
      return q === M2;
    });
    return [F(j) ? d4(" ", i2, { groupId: h2(j.typeParameters) }) : i2, $, $ && o, M2, y(m2([i2, u([",", i2], x2.map(L, M2))]))];
  }
  function E(x2, b2, L) {
    let M2 = L("superClass");
    return x2.getParentNode().type === "AssignmentExpression" ? y(d4(["(", m2([c, M2]), c, ")"], M2)) : M2;
  }
  function v(x2, b2, L) {
    let M2 = x2.getValue(), j = [];
    return t(M2.decorators) && j.push(k2(x2, b2, L)), M2.accessibility && j.push(M2.accessibility + " "), M2.readonly && j.push("readonly "), M2.declare && j.push("declare "), M2.static && j.push("static "), (M2.type === "TSAbstractMethodDefinition" || M2.abstract) && j.push("abstract "), M2.override && j.push("override "), j.push(w2(x2, b2, L)), j;
  }
  function N(x2, b2, L) {
    let M2 = x2.getValue(), j = [], $ = b2.semi ? ";" : "";
    return t(M2.decorators) && j.push(k2(x2, b2, L)), M2.accessibility && j.push(M2.accessibility + " "), M2.declare && j.push("declare "), M2.static && j.push("static "), (M2.type === "TSAbstractPropertyDefinition" || M2.abstract) && j.push("abstract "), M2.override && j.push("override "), M2.readonly && j.push("readonly "), M2.variance && j.push(L("variance")), M2.type === "ClassAccessorProperty" && j.push("accessor "), j.push(B(x2, b2, L), T2(x2), S2(x2), A2(x2, b2, L)), [I2(x2, b2, L, j, " =", "value"), $];
  }
  n.exports = { printClass: P, printClassMethod: v, printClassProperty: N, printHardlineAfterHeritage: D2 };
} }), ro$2 = Z({ "src/language-js/print/interface.js"(e, n) {
  re();
  var { isNonEmptyArray: t } = Ue$2(), { builders: { join: s2, line: a3, group: r, indent: u, ifBreak: i2 } } = Oe(), { hasComment: o, identity: c, CommentCheckFlags: y } = Ke$1(), { getTypeParametersGroupId: m2 } = Pr$1(), { printTypeScriptModifiers: d4 } = ct$1();
  function p(f, h2, w2) {
    let T2 = f.getValue(), A2 = [];
    T2.declare && A2.push("declare "), T2.type === "TSInterfaceDeclaration" && A2.push(T2.abstract ? "abstract " : "", d4(f, h2, w2)), A2.push("interface");
    let S2 = [], B = [];
    T2.type !== "InterfaceTypeAnnotation" && S2.push(" ", w2("id"), w2("typeParameters"));
    let I2 = T2.typeParameters && !o(T2.typeParameters, y.Trailing | y.Line);
    return t(T2.extends) && B.push(I2 ? i2(" ", a3, { groupId: m2(T2.typeParameters) }) : a3, "extends ", (T2.extends.length === 1 ? c : u)(s2([",", a3], f.map(w2, "extends")))), T2.id && o(T2.id, y.Trailing) || t(T2.extends) ? I2 ? A2.push(r([...S2, u(B)])) : A2.push(r(u([...S2, ...B]))) : A2.push(...S2, ...B), A2.push(" ", w2("body")), r(A2);
  }
  n.exports = { printInterface: p };
} }), no$2 = Z({ "src/language-js/print/module.js"(e, n) {
  re();
  var { isNonEmptyArray: t } = Ue$2(), { builders: { softline: s2, group: a3, indent: r, join: u, line: i2, ifBreak: o, hardline: c } } = Oe(), { printDanglingComments: y } = et(), { hasComment: m2, CommentCheckFlags: d4, shouldPrintComma: p, needsHardlineAfterDanglingComment: f, isStringLiteral: h2, rawText: w2 } = Ke$1(), { locStart: T2, hasSameLoc: A2 } = st$1(), { hasDecoratorsBeforeExport: S2, printDecoratorsBeforeExport: B } = Hn$3();
  function I2(N, x2, b2) {
    let L = N.getValue(), M2 = x2.semi ? ";" : "", j = [], { importKind: $ } = L;
    return j.push("import"), $ && $ !== "value" && j.push(" ", $), j.push(g2(N, x2, b2), D2(N, x2, b2), l(N, x2, b2), M2), j;
  }
  function k2(N, x2, b2) {
    let L = N.getValue(), M2 = [];
    S2(L) && M2.push(B(N, x2, b2));
    let { type: j, exportKind: $, declaration: V } = L;
    return M2.push("export"), (L.default || j === "ExportDefaultDeclaration") && M2.push(" default"), m2(L, d4.Dangling) && (M2.push(" ", y(N, x2, true)), f(L) && M2.push(c)), V ? M2.push(" ", b2("declaration")) : M2.push($ === "type" ? " type" : "", g2(N, x2, b2), D2(N, x2, b2), l(N, x2, b2)), C2(L, x2) && M2.push(";"), M2;
  }
  function P(N, x2, b2) {
    let L = N.getValue(), M2 = x2.semi ? ";" : "", j = [], { exportKind: $, exported: V } = L;
    return j.push("export"), $ === "type" && j.push(" type"), j.push(" *"), V && j.push(" as ", b2("exported")), j.push(D2(N, x2, b2), l(N, x2, b2), M2), j;
  }
  function C2(N, x2) {
    if (!x2.semi)
      return false;
    let { type: b2, declaration: L } = N, M2 = N.default || b2 === "ExportDefaultDeclaration";
    if (!L)
      return true;
    let { type: j } = L;
    return !!(M2 && j !== "ClassDeclaration" && j !== "FunctionDeclaration" && j !== "TSInterfaceDeclaration" && j !== "DeclareClass" && j !== "DeclareFunction" && j !== "TSDeclareFunction" && j !== "EnumDeclaration");
  }
  function D2(N, x2, b2) {
    let L = N.getValue();
    if (!L.source)
      return "";
    let M2 = [];
    return F(L, x2) || M2.push(" from"), M2.push(" ", b2("source")), M2;
  }
  function g2(N, x2, b2) {
    let L = N.getValue();
    if (F(L, x2))
      return "";
    let M2 = [" "];
    if (t(L.specifiers)) {
      let j = [], $ = [];
      N.each(() => {
        let V = N.getValue().type;
        if (V === "ExportNamespaceSpecifier" || V === "ExportDefaultSpecifier" || V === "ImportNamespaceSpecifier" || V === "ImportDefaultSpecifier")
          j.push(b2());
        else if (V === "ExportSpecifier" || V === "ImportSpecifier")
          $.push(b2());
        else
          throw new Error("Unknown specifier type ".concat(JSON.stringify(V)));
      }, "specifiers"), M2.push(u(", ", j)), $.length > 0 && (j.length > 0 && M2.push(", "), $.length > 1 || j.length > 0 || L.specifiers.some((q) => m2(q)) ? M2.push(a3(["{", r([x2.bracketSpacing ? i2 : s2, u([",", i2], $)]), o(p(x2) ? "," : ""), x2.bracketSpacing ? i2 : s2, "}"])) : M2.push(["{", x2.bracketSpacing ? " " : "", ...$, x2.bracketSpacing ? " " : "", "}"]));
    } else
      M2.push("{}");
    return M2;
  }
  function F(N, x2) {
    let { type: b2, importKind: L, source: M2, specifiers: j } = N;
    return b2 !== "ImportDeclaration" || t(j) || L === "type" ? false : !/{\s*}/.test(x2.originalText.slice(T2(N), T2(M2)));
  }
  function l(N, x2, b2) {
    let L = N.getNode();
    return t(L.assertions) ? [" assert {", x2.bracketSpacing ? " " : "", u(", ", N.map(b2, "assertions")), x2.bracketSpacing ? " " : "", "}"] : "";
  }
  function E(N, x2, b2) {
    let L = N.getNode(), { type: M2 } = L, j = [], $ = M2 === "ImportSpecifier" ? L.importKind : L.exportKind;
    $ && $ !== "value" && j.push($, " ");
    let V = M2.startsWith("Import"), q = V ? "imported" : "local", Y3 = V ? "local" : "exported", H3 = L[q], R = L[Y3], Q = "", ee2 = "";
    return M2 === "ExportNamespaceSpecifier" || M2 === "ImportNamespaceSpecifier" ? Q = "*" : H3 && (Q = b2(q)), R && !v(L) && (ee2 = b2(Y3)), j.push(Q, Q && ee2 ? " as " : "", ee2), j;
  }
  function v(N) {
    if (N.type !== "ImportSpecifier" && N.type !== "ExportSpecifier")
      return false;
    let { local: x2, [N.type === "ImportSpecifier" ? "imported" : "exported"]: b2 } = N;
    if (x2.type !== b2.type || !A2(x2, b2))
      return false;
    if (h2(x2))
      return x2.value === b2.value && w2(x2) === w2(b2);
    switch (x2.type) {
      case "Identifier":
        return x2.name === b2.name;
      default:
        return false;
    }
  }
  n.exports = { printImportDeclaration: I2, printExportDeclaration: k2, printExportAllDeclaration: P, printModuleSpecifier: E };
} }), Gn$2 = Z({ "src/language-js/print/object.js"(e, n) {
  re();
  var { printDanglingComments: t } = et(), { builders: { line: s2, softline: a3, group: r, indent: u, ifBreak: i2, hardline: o } } = Oe(), { getLast: c, hasNewlineInRange: y, hasNewline: m2, isNonEmptyArray: d4 } = Ue$2(), { shouldPrintComma: p, hasComment: f, getComments: h2, CommentCheckFlags: w2, isNextLineEmpty: T2 } = Ke$1(), { locStart: A2, locEnd: S2 } = st$1(), { printOptionalToken: B, printTypeAnnotation: I2 } = ct$1(), { shouldHugFunctionParameters: k2 } = wr$1(), { shouldHugType: P } = _r$1(), { printHardlineAfterHeritage: C2 } = Yt();
  function D2(g2, F, l) {
    let E = F.semi ? ";" : "", v = g2.getValue(), N;
    v.type === "TSTypeLiteral" ? N = "members" : v.type === "TSInterfaceBody" ? N = "body" : N = "properties";
    let x2 = v.type === "ObjectTypeAnnotation", b2 = [N];
    x2 && b2.push("indexers", "callProperties", "internalSlots");
    let L = b2.map((W2) => v[W2][0]).sort((W2, X3) => A2(W2) - A2(X3))[0], M2 = g2.getParentNode(0), j = x2 && M2 && (M2.type === "InterfaceDeclaration" || M2.type === "DeclareInterface" || M2.type === "DeclareClass") && g2.getName() === "body", $ = v.type === "TSInterfaceBody" || j || v.type === "ObjectPattern" && M2.type !== "FunctionDeclaration" && M2.type !== "FunctionExpression" && M2.type !== "ArrowFunctionExpression" && M2.type !== "ObjectMethod" && M2.type !== "ClassMethod" && M2.type !== "ClassPrivateMethod" && M2.type !== "AssignmentPattern" && M2.type !== "CatchClause" && v.properties.some((W2) => W2.value && (W2.value.type === "ObjectPattern" || W2.value.type === "ArrayPattern")) || v.type !== "ObjectPattern" && L && y(F.originalText, A2(v), A2(L)), V = j ? ";" : v.type === "TSInterfaceBody" || v.type === "TSTypeLiteral" ? i2(E, ";") : ",", q = v.type === "RecordExpression" ? "#{" : v.exact ? "{|" : "{", Y3 = v.exact ? "|}" : "}", H3 = [];
    for (let W2 of b2)
      g2.each((X3) => {
        let ue2 = X3.getValue();
        H3.push({ node: ue2, printed: l(), loc: A2(ue2) });
      }, W2);
    b2.length > 1 && H3.sort((W2, X3) => W2.loc - X3.loc);
    let R = [], Q = H3.map((W2) => {
      let X3 = [...R, r(W2.printed)];
      return R = [V, s2], (W2.node.type === "TSPropertySignature" || W2.node.type === "TSMethodSignature" || W2.node.type === "TSConstructSignatureDeclaration") && f(W2.node, w2.PrettierIgnore) && R.shift(), T2(W2.node, F) && R.push(o), X3;
    });
    if (v.inexact) {
      let W2;
      if (f(v, w2.Dangling)) {
        let X3 = f(v, w2.Line);
        W2 = [t(g2, F, true), X3 || m2(F.originalText, S2(c(h2(v)))) ? o : s2, "..."];
      } else
        W2 = ["..."];
      Q.push([...R, ...W2]);
    }
    let ee2 = c(v[N]), te2 = !(v.inexact || ee2 && ee2.type === "RestElement" || ee2 && (ee2.type === "TSPropertySignature" || ee2.type === "TSCallSignatureDeclaration" || ee2.type === "TSMethodSignature" || ee2.type === "TSConstructSignatureDeclaration") && f(ee2, w2.PrettierIgnore)), oe2;
    if (Q.length === 0) {
      if (!f(v, w2.Dangling))
        return [q, Y3, I2(g2, F, l)];
      oe2 = r([q, t(g2, F), a3, Y3, B(g2), I2(g2, F, l)]);
    } else
      oe2 = [j && d4(v.properties) ? C2(M2) : "", q, u([F.bracketSpacing ? s2 : a3, ...Q]), i2(te2 && (V !== "," || p(F)) ? V : ""), F.bracketSpacing ? s2 : a3, Y3, B(g2), I2(g2, F, l)];
    return g2.match((W2) => W2.type === "ObjectPattern" && !W2.decorators, (W2, X3, ue2) => k2(W2) && (X3 === "params" || X3 === "parameters" || X3 === "this" || X3 === "rest") && ue2 === 0) || g2.match(P, (W2, X3) => X3 === "typeAnnotation", (W2, X3) => X3 === "typeAnnotation", (W2, X3, ue2) => k2(W2) && (X3 === "params" || X3 === "parameters" || X3 === "this" || X3 === "rest") && ue2 === 0) || !$ && g2.match((W2) => W2.type === "ObjectPattern", (W2) => W2.type === "AssignmentExpression" || W2.type === "VariableDeclarator") ? oe2 : r(oe2, { shouldBreak: $ });
  }
  n.exports = { printObject: D2 };
} }), Mm = Z({ "src/language-js/print/flow.js"(e, n) {
  re();
  var t = Ut$1(), { printDanglingComments: s2 } = et(), { printString: a3, printNumber: r } = Ue$2(), { builders: { hardline: u, softline: i2, group: o, indent: c } } = Oe(), { getParentExportDeclaration: y, isFunctionNotation: m2, isGetterOrSetter: d4, rawText: p, shouldPrintComma: f } = Ke$1(), { locStart: h2, locEnd: w2 } = st$1(), { printClass: T2 } = Yt(), { printOpaqueType: A2, printTypeAlias: S2, printIntersectionType: B, printUnionType: I2, printFunctionType: k2, printTupleType: P, printIndexedAccessType: C2 } = _r$1(), { printInterface: D2 } = ro$2(), { printTypeParameter: g2, printTypeParameters: F } = Pr$1(), { printExportDeclaration: l, printExportAllDeclaration: E } = no$2(), { printArrayItems: v } = zt$1(), { printObject: N } = Gn$2(), { printPropertyKey: x2 } = Kt(), { printOptionalToken: b2, printTypeAnnotation: L, printRestSpread: M2 } = ct$1();
  function j(V, q, Y3) {
    let H3 = V.getValue(), R = q.semi ? ";" : "", Q = [];
    switch (H3.type) {
      case "DeclareClass":
        return $(V, T2(V, q, Y3));
      case "DeclareFunction":
        return $(V, ["function ", Y3("id"), H3.predicate ? " " : "", Y3("predicate"), R]);
      case "DeclareModule":
        return $(V, ["module ", Y3("id"), " ", Y3("body")]);
      case "DeclareModuleExports":
        return $(V, ["module.exports", ": ", Y3("typeAnnotation"), R]);
      case "DeclareVariable":
        return $(V, ["var ", Y3("id"), R]);
      case "DeclareOpaqueType":
        return $(V, A2(V, q, Y3));
      case "DeclareInterface":
        return $(V, D2(V, q, Y3));
      case "DeclareTypeAlias":
        return $(V, S2(V, q, Y3));
      case "DeclareExportDeclaration":
        return $(V, l(V, q, Y3));
      case "DeclareExportAllDeclaration":
        return $(V, E(V, q, Y3));
      case "OpaqueType":
        return A2(V, q, Y3);
      case "TypeAlias":
        return S2(V, q, Y3);
      case "IntersectionTypeAnnotation":
        return B(V, q, Y3);
      case "UnionTypeAnnotation":
        return I2(V, q, Y3);
      case "FunctionTypeAnnotation":
        return k2(V, q, Y3);
      case "TupleTypeAnnotation":
        return P(V, q, Y3);
      case "GenericTypeAnnotation":
        return [Y3("id"), F(V, q, Y3, "typeParameters")];
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        return C2(V, q, Y3);
      case "TypeAnnotation":
        return Y3("typeAnnotation");
      case "TypeParameter":
        return g2(V, q, Y3);
      case "TypeofTypeAnnotation":
        return ["typeof ", Y3("argument")];
      case "ExistsTypeAnnotation":
        return "*";
      case "EmptyTypeAnnotation":
        return "empty";
      case "MixedTypeAnnotation":
        return "mixed";
      case "ArrayTypeAnnotation":
        return [Y3("elementType"), "[]"];
      case "BooleanLiteralTypeAnnotation":
        return String(H3.value);
      case "EnumDeclaration":
        return ["enum ", Y3("id"), " ", Y3("body")];
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody": {
        if (H3.type === "EnumSymbolBody" || H3.explicitType) {
          let ee2 = null;
          switch (H3.type) {
            case "EnumBooleanBody":
              ee2 = "boolean";
              break;
            case "EnumNumberBody":
              ee2 = "number";
              break;
            case "EnumStringBody":
              ee2 = "string";
              break;
            case "EnumSymbolBody":
              ee2 = "symbol";
              break;
          }
          Q.push("of ", ee2, " ");
        }
        if (H3.members.length === 0 && !H3.hasUnknownMembers)
          Q.push(o(["{", s2(V, q), i2, "}"]));
        else {
          let ee2 = H3.members.length > 0 ? [u, v(V, q, "members", Y3), H3.hasUnknownMembers || f(q) ? "," : ""] : [];
          Q.push(o(["{", c([...ee2, ...H3.hasUnknownMembers ? [u, "..."] : []]), s2(V, q, true), u, "}"]));
        }
        return Q;
      }
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
        return [Y3("id"), " = ", typeof H3.init == "object" ? Y3("init") : String(H3.init)];
      case "EnumDefaultedMember":
        return Y3("id");
      case "FunctionTypeParam": {
        let ee2 = H3.name ? Y3("name") : V.getParentNode().this === H3 ? "this" : "";
        return [ee2, b2(V), ee2 ? ": " : "", Y3("typeAnnotation")];
      }
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
        return D2(V, q, Y3);
      case "ClassImplements":
      case "InterfaceExtends":
        return [Y3("id"), Y3("typeParameters")];
      case "NullableTypeAnnotation":
        return ["?", Y3("typeAnnotation")];
      case "Variance": {
        let { kind: ee2 } = H3;
        return t.ok(ee2 === "plus" || ee2 === "minus"), ee2 === "plus" ? "+" : "-";
      }
      case "ObjectTypeCallProperty":
        return H3.static && Q.push("static "), Q.push(Y3("value")), Q;
      case "ObjectTypeIndexer":
        return [H3.static ? "static " : "", H3.variance ? Y3("variance") : "", "[", Y3("id"), H3.id ? ": " : "", Y3("key"), "]: ", Y3("value")];
      case "ObjectTypeProperty": {
        let ee2 = "";
        return H3.proto ? ee2 = "proto " : H3.static && (ee2 = "static "), [ee2, d4(H3) ? H3.kind + " " : "", H3.variance ? Y3("variance") : "", x2(V, q, Y3), b2(V), m2(H3) ? "" : ": ", Y3("value")];
      }
      case "ObjectTypeAnnotation":
        return N(V, q, Y3);
      case "ObjectTypeInternalSlot":
        return [H3.static ? "static " : "", "[[", Y3("id"), "]]", b2(V), H3.method ? "" : ": ", Y3("value")];
      case "ObjectTypeSpreadProperty":
        return M2(V, q, Y3);
      case "QualifiedTypeofIdentifier":
      case "QualifiedTypeIdentifier":
        return [Y3("qualification"), ".", Y3("id")];
      case "StringLiteralTypeAnnotation":
        return a3(p(H3), q);
      case "NumberLiteralTypeAnnotation":
        t.strictEqual(typeof H3.value, "number");
      case "BigIntLiteralTypeAnnotation":
        return H3.extra ? r(H3.extra.raw) : r(H3.raw);
      case "TypeCastExpression":
        return ["(", Y3("expression"), L(V, q, Y3), ")"];
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation": {
        let ee2 = F(V, q, Y3, "params");
        if (q.parser === "flow") {
          let te2 = h2(H3), oe2 = w2(H3), W2 = q.originalText.lastIndexOf("/*", te2), X3 = q.originalText.indexOf("*/", oe2);
          if (W2 !== -1 && X3 !== -1) {
            let ue2 = q.originalText.slice(W2 + 2, X3).trim();
            if (ue2.startsWith("::") && !ue2.includes("/*") && !ue2.includes("*/"))
              return ["/*:: ", ee2, " */"];
          }
        }
        return ee2;
      }
      case "InferredPredicate":
        return "%checks";
      case "DeclaredPredicate":
        return ["%checks(", Y3("value"), ")"];
      case "AnyTypeAnnotation":
        return "any";
      case "BooleanTypeAnnotation":
        return "boolean";
      case "BigIntTypeAnnotation":
        return "bigint";
      case "NullLiteralTypeAnnotation":
        return "null";
      case "NumberTypeAnnotation":
        return "number";
      case "SymbolTypeAnnotation":
        return "symbol";
      case "StringTypeAnnotation":
        return "string";
      case "VoidTypeAnnotation":
        return "void";
      case "ThisTypeAnnotation":
        return "this";
      case "Node":
      case "Printable":
      case "SourceLocation":
      case "Position":
      case "Statement":
      case "Function":
      case "Pattern":
      case "Expression":
      case "Declaration":
      case "Specifier":
      case "NamedSpecifier":
      case "Comment":
      case "MemberTypeAnnotation":
      case "Type":
        throw new Error("unprintable type: " + JSON.stringify(H3.type));
    }
  }
  function $(V, q) {
    let Y3 = y(V);
    return Y3 ? (t.strictEqual(Y3.type, "DeclareExportDeclaration"), q) : ["declare ", q];
  }
  n.exports = { printFlow: j };
} }), Rm = Z({ "src/language-js/utils/is-ts-keyword-type.js"(e, n) {
  re();
  function t(s2) {
    let { type: a3 } = s2;
    return a3.startsWith("TS") && a3.endsWith("Keyword");
  }
  n.exports = t;
} }), uo$2 = Z({ "src/language-js/print/ternary.js"(e, n) {
  re();
  var { hasNewlineInRange: t } = Ue$2(), { isJsxNode: s2, getComments: a3, isCallExpression: r, isMemberExpression: u } = Ke$1(), { locStart: i2, locEnd: o } = st$1(), c = Pt$1(), { builders: { line: y, softline: m2, group: d4, indent: p, align: f, ifBreak: h2, dedent: w2, breakParent: T2 } } = Oe();
  function A2(P) {
    let C2 = [P];
    for (let D2 = 0; D2 < C2.length; D2++) {
      let g2 = C2[D2];
      for (let F of ["test", "consequent", "alternate"]) {
        let l = g2[F];
        if (s2(l))
          return true;
        l.type === "ConditionalExpression" && C2.push(l);
      }
    }
    return false;
  }
  function S2(P, C2, D2) {
    let g2 = P.getValue(), F = g2.type === "ConditionalExpression", l = F ? "alternate" : "falseType", E = P.getParentNode(), v = F ? D2("test") : [D2("checkType"), " ", "extends", " ", D2("extendsType")];
    return E.type === g2.type && E[l] === g2 ? f(2, v) : v;
  }
  var B = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
  function I2(P) {
    let C2 = P.getValue();
    if (C2.type !== "ConditionalExpression")
      return false;
    let D2, g2 = C2;
    for (let F = 0; !D2; F++) {
      let l = P.getParentNode(F);
      if (r(l) && l.callee === g2 || u(l) && l.object === g2 || l.type === "TSNonNullExpression" && l.expression === g2) {
        g2 = l;
        continue;
      }
      l.type === "NewExpression" && l.callee === g2 || l.type === "TSAsExpression" && l.expression === g2 ? (D2 = P.getParentNode(F + 1), g2 = l) : D2 = l;
    }
    return g2 === C2 ? false : D2[B.get(D2.type)] === g2;
  }
  function k2(P, C2, D2) {
    let g2 = P.getValue(), F = g2.type === "ConditionalExpression", l = F ? "consequent" : "trueType", E = F ? "alternate" : "falseType", v = F ? ["test"] : ["checkType", "extendsType"], N = g2[l], x2 = g2[E], b2 = [], L = false, M2 = P.getParentNode(), j = M2.type === g2.type && v.some((ue2) => M2[ue2] === g2), $ = M2.type === g2.type && !j, V, q, Y3 = 0;
    do
      q = V || g2, V = P.getParentNode(Y3), Y3++;
    while (V && V.type === g2.type && v.every((ue2) => V[ue2] !== q));
    let H3 = V || M2, R = q;
    if (F && (s2(g2[v[0]]) || s2(N) || s2(x2) || A2(R))) {
      L = true, $ = true;
      let ue2 = (ie) => [h2("("), p([m2, ie]), m2, h2(")")], De2 = (ie) => ie.type === "NullLiteral" || ie.type === "Literal" && ie.value === null || ie.type === "Identifier" && ie.name === "undefined";
      b2.push(" ? ", De2(N) ? D2(l) : ue2(D2(l)), " : ", x2.type === g2.type || De2(x2) ? D2(E) : ue2(D2(E)));
    } else {
      let ue2 = [y, "? ", N.type === g2.type ? h2("", "(") : "", f(2, D2(l)), N.type === g2.type ? h2("", ")") : "", y, ": ", x2.type === g2.type ? D2(E) : f(2, D2(E))];
      b2.push(M2.type !== g2.type || M2[E] === g2 || j ? ue2 : C2.useTabs ? w2(p(ue2)) : f(Math.max(0, C2.tabWidth - 2), ue2));
    }
    let ee2 = [...v.map((ue2) => a3(g2[ue2])), a3(N), a3(x2)].flat().some((ue2) => c(ue2) && t(C2.originalText, i2(ue2), o(ue2))), te2 = (ue2) => M2 === H3 ? d4(ue2, { shouldBreak: ee2 }) : ee2 ? [ue2, T2] : ue2, oe2 = !L && (u(M2) || M2.type === "NGPipeExpression" && M2.left === g2) && !M2.computed, W2 = I2(P), X3 = te2([S2(P, C2, D2), $ ? b2 : p(b2), F && oe2 && !W2 ? m2 : ""]);
    return j || W2 ? d4([p([m2, X3]), m2]) : X3;
  }
  n.exports = { printTernary: k2 };
} }), so$2 = Z({ "src/language-js/print/statement.js"(e, n) {
  re();
  var { builders: { hardline: t } } = Oe(), s2 = It$1(), { getLeftSidePathName: a3, hasNakedLeftSide: r, isJsxNode: u, isTheOnlyJsxElementInMarkdown: i2, hasComment: o, CommentCheckFlags: c, isNextLineEmpty: y } = Ke$1(), { shouldPrintParamsWithoutParens: m2 } = kr$1();
  function d4(B, I2, k2, P) {
    let C2 = B.getValue(), D2 = [], g2 = C2.type === "ClassBody", F = p(C2[P]);
    return B.each((l, E, v) => {
      let N = l.getValue();
      if (N.type === "EmptyStatement")
        return;
      let x2 = k2();
      !I2.semi && !g2 && !i2(I2, l) && f(l, I2) ? o(N, c.Leading) ? D2.push(k2([], { needsSemi: true })) : D2.push(";", x2) : D2.push(x2), !I2.semi && g2 && A2(N) && S2(N, v[E + 1]) && D2.push(";"), N !== F && (D2.push(t), y(N, I2) && D2.push(t));
    }, P), D2;
  }
  function p(B) {
    for (let I2 = B.length - 1; I2 >= 0; I2--) {
      let k2 = B[I2];
      if (k2.type !== "EmptyStatement")
        return k2;
    }
  }
  function f(B, I2) {
    return B.getNode().type !== "ExpressionStatement" ? false : B.call((P) => h2(P, I2), "expression");
  }
  function h2(B, I2) {
    let k2 = B.getValue();
    switch (k2.type) {
      case "ParenthesizedExpression":
      case "TypeCastExpression":
      case "ArrayExpression":
      case "ArrayPattern":
      case "TemplateLiteral":
      case "TemplateElement":
      case "RegExpLiteral":
        return true;
      case "ArrowFunctionExpression": {
        if (!m2(B, I2))
          return true;
        break;
      }
      case "UnaryExpression": {
        let { prefix: P, operator: C2 } = k2;
        if (P && (C2 === "+" || C2 === "-"))
          return true;
        break;
      }
      case "BindExpression": {
        if (!k2.object)
          return true;
        break;
      }
      case "Literal": {
        if (k2.regex)
          return true;
        break;
      }
      default:
        if (u(k2))
          return true;
    }
    return s2(B, I2) ? true : r(k2) ? B.call((P) => h2(P, I2), ...a3(B, k2)) : false;
  }
  function w2(B, I2, k2) {
    return d4(B, I2, k2, "body");
  }
  function T2(B, I2, k2) {
    return d4(B, I2, k2, "consequent");
  }
  var A2 = (B) => {
    let { type: I2 } = B;
    return I2 === "ClassProperty" || I2 === "PropertyDefinition" || I2 === "ClassPrivateProperty" || I2 === "ClassAccessorProperty";
  };
  function S2(B, I2) {
    let k2 = B.key && B.key.name;
    if ((k2 === "static" || k2 === "get" || k2 === "set") && !B.value && !B.typeAnnotation)
      return true;
    if (!I2 || I2.static || I2.accessibility)
      return false;
    if (!I2.computed) {
      let P = I2.key && I2.key.name;
      if (P === "in" || P === "instanceof")
        return true;
    }
    if (A2(I2) && I2.variance && !I2.static && !I2.declare)
      return true;
    switch (I2.type) {
      case "ClassProperty":
      case "PropertyDefinition":
      case "TSAbstractPropertyDefinition":
        return I2.computed;
      case "MethodDefinition":
      case "TSAbstractMethodDefinition":
      case "ClassMethod":
      case "ClassPrivateMethod": {
        if ((I2.value ? I2.value.async : I2.async) || I2.kind === "get" || I2.kind === "set")
          return false;
        let C2 = I2.value ? I2.value.generator : I2.generator;
        return !!(I2.computed || C2);
      }
      case "TSIndexSignature":
        return true;
    }
    return false;
  }
  n.exports = { printBody: w2, printSwitchCaseConsequent: T2 };
} }), io$2 = Z({ "src/language-js/print/block.js"(e, n) {
  re();
  var { printDanglingComments: t } = et(), { isNonEmptyArray: s2 } = Ue$2(), { builders: { hardline: a3, indent: r } } = Oe(), { hasComment: u, CommentCheckFlags: i2, isNextLineEmpty: o } = Ke$1(), { printHardlineAfterHeritage: c } = Yt(), { printBody: y } = so$2();
  function m2(p, f, h2) {
    let w2 = p.getValue(), T2 = [];
    if (w2.type === "StaticBlock" && T2.push("static "), w2.type === "ClassBody" && s2(w2.body)) {
      let S2 = p.getParentNode();
      T2.push(c(S2));
    }
    T2.push("{");
    let A2 = d4(p, f, h2);
    if (A2)
      T2.push(r([a3, A2]), a3);
    else {
      let S2 = p.getParentNode(), B = p.getParentNode(1);
      S2.type === "ArrowFunctionExpression" || S2.type === "FunctionExpression" || S2.type === "FunctionDeclaration" || S2.type === "ObjectMethod" || S2.type === "ClassMethod" || S2.type === "ClassPrivateMethod" || S2.type === "ForStatement" || S2.type === "WhileStatement" || S2.type === "DoWhileStatement" || S2.type === "DoExpression" || S2.type === "CatchClause" && !B.finalizer || S2.type === "TSModuleDeclaration" || S2.type === "TSDeclareFunction" || w2.type === "StaticBlock" || w2.type === "ClassBody" || T2.push(a3);
    }
    return T2.push("}"), T2;
  }
  function d4(p, f, h2) {
    let w2 = p.getValue(), T2 = s2(w2.directives), A2 = w2.body.some((I2) => I2.type !== "EmptyStatement"), S2 = u(w2, i2.Dangling);
    if (!T2 && !A2 && !S2)
      return "";
    let B = [];
    if (T2 && p.each((I2, k2, P) => {
      B.push(h2()), (k2 < P.length - 1 || A2 || S2) && (B.push(a3), o(I2.getValue(), f) && B.push(a3));
    }, "directives"), A2 && B.push(y(p, f, h2)), S2 && B.push(t(p, f, true)), w2.type === "Program") {
      let I2 = p.getParentNode();
      (!I2 || I2.type !== "ModuleExpression") && B.push(a3);
    }
    return B;
  }
  n.exports = { printBlock: m2, printBlockBody: d4 };
} }), Vm = Z({ "src/language-js/print/typescript.js"(e, n) {
  re();
  var { printDanglingComments: t } = et(), { hasNewlineInRange: s2 } = Ue$2(), { builders: { join: a3, line: r, hardline: u, softline: i2, group: o, indent: c, conditionalGroup: y, ifBreak: m2 } } = Oe(), { isLiteral: d4, getTypeScriptMappedTypeModifier: p, shouldPrintComma: f, isCallExpression: h2, isMemberExpression: w2 } = Ke$1(), T2 = Rm(), { locStart: A2, locEnd: S2 } = st$1(), { printOptionalToken: B, printTypeScriptModifiers: I2 } = ct$1(), { printTernary: k2 } = uo$2(), { printFunctionParameters: P, shouldGroupFunctionParameters: C2 } = wr$1(), { printTemplateLiteral: D2 } = kt$2(), { printArrayItems: g2 } = zt$1(), { printObject: F } = Gn$2(), { printClassProperty: l, printClassMethod: E } = Yt(), { printTypeParameter: v, printTypeParameters: N } = Pr$1(), { printPropertyKey: x2 } = Kt(), { printFunction: b2, printMethodInternal: L } = kr$1(), { printInterface: M2 } = ro$2(), { printBlock: j } = io$2(), { printTypeAlias: $, printIntersectionType: V, printUnionType: q, printFunctionType: Y3, printTupleType: H3, printIndexedAccessType: R, printJSDocType: Q } = _r$1();
  function ee2(te2, oe2, W2) {
    let X3 = te2.getValue();
    if (!X3.type.startsWith("TS"))
      return;
    if (T2(X3))
      return X3.type.slice(2, -7).toLowerCase();
    let ue2 = oe2.semi ? ";" : "", De2 = [];
    switch (X3.type) {
      case "TSThisType":
        return "this";
      case "TSTypeAssertion": {
        let ie = !(X3.expression.type === "ArrayExpression" || X3.expression.type === "ObjectExpression"), G = o(["<", c([i2, W2("typeAnnotation")]), i2, ">"]), z = [m2("("), c([i2, W2("expression")]), i2, m2(")")];
        return ie ? y([[G, W2("expression")], [G, o(z, { shouldBreak: true })], [G, W2("expression")]]) : o([G, W2("expression")]);
      }
      case "TSDeclareFunction":
        return b2(te2, W2, oe2);
      case "TSExportAssignment":
        return ["export = ", W2("expression"), ue2];
      case "TSModuleBlock":
        return j(te2, oe2, W2);
      case "TSInterfaceBody":
      case "TSTypeLiteral":
        return F(te2, oe2, W2);
      case "TSTypeAliasDeclaration":
        return $(te2, oe2, W2);
      case "TSQualifiedName":
        return a3(".", [W2("left"), W2("right")]);
      case "TSAbstractMethodDefinition":
      case "TSDeclareMethod":
        return E(te2, oe2, W2);
      case "TSAbstractPropertyDefinition":
        return l(te2, oe2, W2);
      case "TSInterfaceHeritage":
      case "TSExpressionWithTypeArguments":
        return De2.push(W2("expression")), X3.typeParameters && De2.push(W2("typeParameters")), De2;
      case "TSTemplateLiteralType":
        return D2(te2, W2, oe2);
      case "TSNamedTupleMember":
        return [W2("label"), X3.optional ? "?" : "", ": ", W2("elementType")];
      case "TSRestType":
        return ["...", W2("typeAnnotation")];
      case "TSOptionalType":
        return [W2("typeAnnotation"), "?"];
      case "TSInterfaceDeclaration":
        return M2(te2, oe2, W2);
      case "TSClassImplements":
        return [W2("expression"), W2("typeParameters")];
      case "TSTypeParameterDeclaration":
      case "TSTypeParameterInstantiation":
        return N(te2, oe2, W2, "params");
      case "TSTypeParameter":
        return v(te2, oe2, W2);
      case "TSAsExpression": {
        De2.push(W2("expression"), " as ", W2("typeAnnotation"));
        let ie = te2.getParentNode();
        return h2(ie) && ie.callee === X3 || w2(ie) && ie.object === X3 ? o([c([i2, ...De2]), i2]) : De2;
      }
      case "TSArrayType":
        return [W2("elementType"), "[]"];
      case "TSPropertySignature":
        return X3.readonly && De2.push("readonly "), De2.push(x2(te2, oe2, W2), B(te2)), X3.typeAnnotation && De2.push(": ", W2("typeAnnotation")), X3.initializer && De2.push(" = ", W2("initializer")), De2;
      case "TSParameterProperty":
        return X3.accessibility && De2.push(X3.accessibility + " "), X3.export && De2.push("export "), X3.static && De2.push("static "), X3.override && De2.push("override "), X3.readonly && De2.push("readonly "), De2.push(W2("parameter")), De2;
      case "TSTypeQuery":
        return ["typeof ", W2("exprName"), W2("typeParameters")];
      case "TSIndexSignature": {
        let ie = te2.getParentNode(), G = X3.parameters.length > 1 ? m2(f(oe2) ? "," : "") : "", z = o([c([i2, a3([", ", i2], te2.map(W2, "parameters"))]), G, i2]);
        return [X3.export ? "export " : "", X3.accessibility ? [X3.accessibility, " "] : "", X3.static ? "static " : "", X3.readonly ? "readonly " : "", X3.declare ? "declare " : "", "[", X3.parameters ? z : "", X3.typeAnnotation ? "]: " : "]", X3.typeAnnotation ? W2("typeAnnotation") : "", ie.type === "ClassBody" ? ue2 : ""];
      }
      case "TSTypePredicate":
        return [X3.asserts ? "asserts " : "", W2("parameterName"), X3.typeAnnotation ? [" is ", W2("typeAnnotation")] : ""];
      case "TSNonNullExpression":
        return [W2("expression"), "!"];
      case "TSImportType":
        return [X3.isTypeOf ? "typeof " : "", "import(", W2(X3.parameter ? "parameter" : "argument"), ")", X3.qualifier ? [".", W2("qualifier")] : "", N(te2, oe2, W2, "typeParameters")];
      case "TSLiteralType":
        return W2("literal");
      case "TSIndexedAccessType":
        return R(te2, oe2, W2);
      case "TSConstructSignatureDeclaration":
      case "TSCallSignatureDeclaration":
      case "TSConstructorType": {
        if (X3.type === "TSConstructorType" && X3.abstract && De2.push("abstract "), X3.type !== "TSCallSignatureDeclaration" && De2.push("new "), De2.push(o(P(te2, W2, oe2, false, true))), X3.returnType || X3.typeAnnotation) {
          let ie = X3.type === "TSConstructorType";
          De2.push(ie ? " => " : ": ", W2("returnType"), W2("typeAnnotation"));
        }
        return De2;
      }
      case "TSTypeOperator":
        return [X3.operator, " ", W2("typeAnnotation")];
      case "TSMappedType": {
        let ie = s2(oe2.originalText, A2(X3), S2(X3));
        return o(["{", c([oe2.bracketSpacing ? r : i2, X3.readonly ? [p(X3.readonly, "readonly"), " "] : "", I2(te2, oe2, W2), W2("typeParameter"), X3.optional ? p(X3.optional, "?") : "", X3.typeAnnotation ? ": " : "", W2("typeAnnotation"), m2(ue2)]), t(te2, oe2, true), oe2.bracketSpacing ? r : i2, "}"], { shouldBreak: ie });
      }
      case "TSMethodSignature": {
        let ie = X3.kind && X3.kind !== "method" ? "".concat(X3.kind, " ") : "";
        De2.push(X3.accessibility ? [X3.accessibility, " "] : "", ie, X3.export ? "export " : "", X3.static ? "static " : "", X3.readonly ? "readonly " : "", X3.abstract ? "abstract " : "", X3.declare ? "declare " : "", X3.computed ? "[" : "", W2("key"), X3.computed ? "]" : "", B(te2));
        let G = P(te2, W2, oe2, false, true), z = X3.returnType ? "returnType" : "typeAnnotation", U = X3[z], le2 = U ? W2(z) : "", ge2 = C2(X3, le2);
        return De2.push(ge2 ? o(G) : G), U && De2.push(": ", o(le2)), o(De2);
      }
      case "TSNamespaceExportDeclaration":
        return De2.push("export as namespace ", W2("id")), oe2.semi && De2.push(";"), o(De2);
      case "TSEnumDeclaration":
        return X3.declare && De2.push("declare "), X3.modifiers && De2.push(I2(te2, oe2, W2)), X3.const && De2.push("const "), De2.push("enum ", W2("id"), " "), X3.members.length === 0 ? De2.push(o(["{", t(te2, oe2), i2, "}"])) : De2.push(o(["{", c([u, g2(te2, oe2, "members", W2), f(oe2, "es5") ? "," : ""]), t(te2, oe2, true), u, "}"])), De2;
      case "TSEnumMember":
        return X3.computed ? De2.push("[", W2("id"), "]") : De2.push(W2("id")), X3.initializer && De2.push(" = ", W2("initializer")), De2;
      case "TSImportEqualsDeclaration":
        return X3.isExport && De2.push("export "), De2.push("import "), X3.importKind && X3.importKind !== "value" && De2.push(X3.importKind, " "), De2.push(W2("id"), " = ", W2("moduleReference")), oe2.semi && De2.push(";"), o(De2);
      case "TSExternalModuleReference":
        return ["require(", W2("expression"), ")"];
      case "TSModuleDeclaration": {
        let ie = te2.getParentNode(), G = d4(X3.id), z = ie.type === "TSModuleDeclaration", U = X3.body && X3.body.type === "TSModuleDeclaration";
        if (z)
          De2.push(".");
        else {
          X3.declare && De2.push("declare "), De2.push(I2(te2, oe2, W2));
          let le2 = oe2.originalText.slice(A2(X3), A2(X3.id));
          X3.id.type === "Identifier" && X3.id.name === "global" && !/namespace|module/.test(le2) || De2.push(G || /(?:^|\s)module(?:\s|$)/.test(le2) ? "module " : "namespace ");
        }
        return De2.push(W2("id")), U ? De2.push(W2("body")) : X3.body ? De2.push(" ", o(W2("body"))) : De2.push(ue2), De2;
      }
      case "TSConditionalType":
        return k2(te2, oe2, W2);
      case "TSInferType":
        return ["infer", " ", W2("typeParameter")];
      case "TSIntersectionType":
        return V(te2, oe2, W2);
      case "TSUnionType":
        return q(te2, oe2, W2);
      case "TSFunctionType":
        return Y3(te2, oe2, W2);
      case "TSTupleType":
        return H3(te2, oe2, W2);
      case "TSTypeReference":
        return [W2("typeName"), N(te2, oe2, W2, "typeParameters")];
      case "TSTypeAnnotation":
        return W2("typeAnnotation");
      case "TSEmptyBodyFunctionExpression":
        return L(te2, oe2, W2);
      case "TSJSDocAllType":
        return "*";
      case "TSJSDocUnknownType":
        return "?";
      case "TSJSDocNullableType":
        return Q(te2, W2, "?");
      case "TSJSDocNonNullableType":
        return Q(te2, W2, "!");
      case "TSInstantiationExpression":
        return [W2("expression"), W2("typeParameters")];
      default:
        throw new Error("Unknown TypeScript node type: ".concat(JSON.stringify(X3.type), "."));
    }
  }
  n.exports = { printTypescript: ee2 };
} }), Wm = Z({ "src/language-js/print/comment.js"(e, n) {
  re();
  var { hasNewline: t } = Ue$2(), { builders: { join: s2, hardline: a3 }, utils: { replaceTextEndOfLine: r } } = Oe(), { isLineComment: u } = Ke$1(), { locStart: i2, locEnd: o } = st$1(), c = Pt$1();
  function y(p, f) {
    let h2 = p.getValue();
    if (u(h2))
      return f.originalText.slice(i2(h2), o(h2)).trimEnd();
    if (c(h2)) {
      if (m2(h2)) {
        let A2 = d4(h2);
        return h2.trailing && !t(f.originalText, i2(h2), { backwards: true }) ? [a3, A2] : A2;
      }
      let w2 = o(h2), T2 = f.originalText.slice(w2 - 3, w2) === "*-/";
      return ["/*", r(h2.value), T2 ? "*-/" : "*/"];
    }
    throw new Error("Not a comment: " + JSON.stringify(h2));
  }
  function m2(p) {
    let f = "*".concat(p.value, "*").split(`
`);
    return f.length > 1 && f.every((h2) => h2.trim()[0] === "*");
  }
  function d4(p) {
    let f = p.value.split(`
`);
    return ["/*", s2(a3, f.map((h2, w2) => w2 === 0 ? h2.trimEnd() : " " + (w2 < f.length - 1 ? h2.trim() : h2.trimStart()))), "*/"];
  }
  n.exports = { printComment: y };
} }), $m = Z({ "src/language-js/print/literal.js"(e, n) {
  re();
  var { printString: t, printNumber: s2 } = Ue$2();
  function a3(i2, o) {
    let c = i2.getNode();
    switch (c.type) {
      case "RegExpLiteral":
        return u(c);
      case "BigIntLiteral":
        return r(c.bigint || c.extra.raw);
      case "NumericLiteral":
        return s2(c.extra.raw);
      case "StringLiteral":
        return t(c.extra.raw, o);
      case "NullLiteral":
        return "null";
      case "BooleanLiteral":
        return String(c.value);
      case "DecimalLiteral":
        return s2(c.value) + "m";
      case "Literal": {
        if (c.regex)
          return u(c.regex);
        if (c.bigint)
          return r(c.raw);
        if (c.decimal)
          return s2(c.decimal) + "m";
        let { value: y } = c;
        return typeof y == "number" ? s2(c.raw) : typeof y == "string" ? t(c.raw, o) : String(y);
      }
    }
  }
  function r(i2) {
    return i2.toLowerCase();
  }
  function u(i2) {
    let { pattern: o, flags: c } = i2;
    return c = [...c].sort().join(""), "/".concat(o, "/").concat(c);
  }
  n.exports = { printLiteral: a3 };
} }), Hm = Z({ "src/language-js/printer-estree.js"(e, n) {
  re();
  var { printDanglingComments: t } = et(), { hasNewline: s2 } = Ue$2(), { builders: { join: a3, line: r, hardline: u, softline: i2, group: o, indent: c }, utils: { replaceTextEndOfLine: y } } = Oe(), m2 = bm(), d4 = Tm(), { insertPragma: p } = Ka$1(), f = Ya$1(), h2 = It$1(), w2 = Qa$1(), { hasFlowShorthandAnnotationComment: T2, hasComment: A2, CommentCheckFlags: S2, isTheOnlyJsxElementInMarkdown: B, isLineComment: I2, isNextLineEmpty: k2, needsHardlineAfterDanglingComment: P, rawText: C2, hasIgnoreComment: D2, isCallExpression: g2, isMemberExpression: F, markerForIfWithoutBlockAndSameLineComment: l } = Ke$1(), { locStart: E, locEnd: v } = st$1(), N = Pt$1(), { printHtmlBinding: x2, isVueEventBindingExpression: b2 } = Lm(), { printAngular: L } = jm(), { printJsx: M2, hasJsxIgnoreComment: j } = Om(), { printFlow: $ } = Mm(), { printTypescript: V } = Vm(), { printOptionalToken: q, printBindExpressionCallee: Y3, printTypeAnnotation: H3, adjustClause: R, printRestSpread: Q, printDefiniteToken: ee2 } = ct$1(), { printImportDeclaration: te2, printExportDeclaration: oe2, printExportAllDeclaration: W2, printModuleSpecifier: X3 } = no$2(), { printTernary: ue2 } = uo$2(), { printTemplateLiteral: De2 } = kt$2(), { printArray: ie } = zt$1(), { printObject: G } = Gn$2(), { printClass: z, printClassMethod: U, printClassProperty: le2 } = Yt(), { printProperty: ge2 } = Kt(), { printFunction: Ae2, printArrowFunction: Ne2, printMethod: ke2, printReturnStatement: ce, printThrowStatement: pe } = kr$1(), { printCallExpression: de2 } = to$2(), { printVariableDeclarator: ae2, printAssignmentExpression: ve2 } = Xt(), { printBinaryishExpression: K } = $n$1(), { printSwitchCaseConsequent: he2 } = so$2(), { printMemberExpression: ye2 } = eo$2(), { printBlock: Ce2, printBlockBody: Ie2 } = io$2(), { printComment: Fe2 } = Wm(), { printLiteral: me2 } = $m(), { printDecorators: _ } = Hn$3();
  function J2(Be, Pe2, Se2, Qe) {
    let xe2 = ne(Be, Pe2, Se2, Qe);
    if (!xe2)
      return "";
    let Xe2 = Be.getValue(), { type: we2 } = Xe2;
    if (we2 === "ClassMethod" || we2 === "ClassPrivateMethod" || we2 === "ClassProperty" || we2 === "ClassAccessorProperty" || we2 === "PropertyDefinition" || we2 === "TSAbstractPropertyDefinition" || we2 === "ClassPrivateProperty" || we2 === "MethodDefinition" || we2 === "TSAbstractMethodDefinition" || we2 === "TSDeclareMethod")
      return xe2;
    let je2 = [xe2], Re2 = _(Be, Pe2, Se2), be2 = Xe2.type === "ClassExpression" && Re2;
    if (Re2 && (je2 = [...Re2, xe2], !be2))
      return o(je2);
    if (!h2(Be, Pe2))
      return Qe && Qe.needsSemi && je2.unshift(";"), je2.length === 1 && je2[0] === xe2 ? xe2 : je2;
    if (be2 && (je2 = [c([r, ...je2])]), je2.unshift("("), Qe && Qe.needsSemi && je2.unshift(";"), T2(Xe2)) {
      let [qe2] = Xe2.trailingComments;
      je2.push(" /*", qe2.value.trimStart(), "*/"), qe2.printed = true;
    }
    return be2 && je2.push(r), je2.push(")"), je2;
  }
  function ne(Be, Pe2, Se2, Qe) {
    let xe2 = Be.getValue(), Xe2 = Pe2.semi ? ";" : "";
    if (!xe2)
      return "";
    if (typeof xe2 == "string")
      return xe2;
    for (let je2 of [me2, x2, L, M2, $, V]) {
      let Re2 = je2(Be, Pe2, Se2);
      if (typeof Re2 < "u")
        return Re2;
    }
    let we2 = [];
    switch (xe2.type) {
      case "JsExpressionRoot":
        return Se2("node");
      case "JsonRoot":
        return [Se2("node"), u];
      case "File":
        return xe2.program && xe2.program.interpreter && we2.push(Se2(["program", "interpreter"])), we2.push(Se2("program")), we2;
      case "Program":
        return Ie2(Be, Pe2, Se2);
      case "EmptyStatement":
        return "";
      case "ExpressionStatement": {
        if (xe2.directive)
          return [Ee(xe2.expression, Pe2), Xe2];
        if (Pe2.parser === "__vue_event_binding" || Pe2.parser === "__vue_ts_event_binding") {
          let Re2 = Be.getParentNode();
          if (Re2.type === "Program" && Re2.body.length === 1 && Re2.body[0] === xe2)
            return [Se2("expression"), b2(xe2.expression) ? ";" : ""];
        }
        let je2 = t(Be, Pe2, true, (Re2) => {
          let { marker: be2 } = Re2;
          return be2 === l;
        });
        return [Se2("expression"), B(Pe2, Be) ? "" : Xe2, je2 ? [" ", je2] : ""];
      }
      case "ParenthesizedExpression":
        return !A2(xe2.expression) && (xe2.expression.type === "ObjectExpression" || xe2.expression.type === "ArrayExpression") ? ["(", Se2("expression"), ")"] : o(["(", c([i2, Se2("expression")]), i2, ")"]);
      case "AssignmentExpression":
        return ve2(Be, Pe2, Se2);
      case "VariableDeclarator":
        return ae2(Be, Pe2, Se2);
      case "BinaryExpression":
      case "LogicalExpression":
        return K(Be, Pe2, Se2);
      case "AssignmentPattern":
        return [Se2("left"), " = ", Se2("right")];
      case "OptionalMemberExpression":
      case "MemberExpression":
        return ye2(Be, Pe2, Se2);
      case "MetaProperty":
        return [Se2("meta"), ".", Se2("property")];
      case "BindExpression":
        return xe2.object && we2.push(Se2("object")), we2.push(o(c([i2, Y3(Be, Pe2, Se2)]))), we2;
      case "Identifier":
        return [xe2.name, q(Be), ee2(Be), H3(Be, Pe2, Se2)];
      case "V8IntrinsicIdentifier":
        return ["%", xe2.name];
      case "SpreadElement":
      case "SpreadElementPattern":
      case "SpreadProperty":
      case "SpreadPropertyPattern":
      case "RestElement":
        return Q(Be, Pe2, Se2);
      case "FunctionDeclaration":
      case "FunctionExpression":
        return Ae2(Be, Se2, Pe2, Qe);
      case "ArrowFunctionExpression":
        return Ne2(Be, Pe2, Se2, Qe);
      case "YieldExpression":
        return we2.push("yield"), xe2.delegate && we2.push("*"), xe2.argument && we2.push(" ", Se2("argument")), we2;
      case "AwaitExpression": {
        if (we2.push("await"), xe2.argument) {
          we2.push(" ", Se2("argument"));
          let je2 = Be.getParentNode();
          if (g2(je2) && je2.callee === xe2 || F(je2) && je2.object === xe2) {
            we2 = [c([i2, ...we2]), i2];
            let Re2 = Be.findAncestor((be2) => be2.type === "AwaitExpression" || be2.type === "BlockStatement");
            if (!Re2 || Re2.type !== "AwaitExpression")
              return o(we2);
          }
        }
        return we2;
      }
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        return oe2(Be, Pe2, Se2);
      case "ExportAllDeclaration":
        return W2(Be, Pe2, Se2);
      case "ImportDeclaration":
        return te2(Be, Pe2, Se2);
      case "ImportSpecifier":
      case "ExportSpecifier":
      case "ImportNamespaceSpecifier":
      case "ExportNamespaceSpecifier":
      case "ImportDefaultSpecifier":
      case "ExportDefaultSpecifier":
        return X3(Be, Pe2, Se2);
      case "ImportAttribute":
        return [Se2("key"), ": ", Se2("value")];
      case "Import":
        return "import";
      case "BlockStatement":
      case "StaticBlock":
      case "ClassBody":
        return Ce2(Be, Pe2, Se2);
      case "ThrowStatement":
        return pe(Be, Pe2, Se2);
      case "ReturnStatement":
        return ce(Be, Pe2, Se2);
      case "NewExpression":
      case "ImportExpression":
      case "OptionalCallExpression":
      case "CallExpression":
        return de2(Be, Pe2, Se2);
      case "ObjectExpression":
      case "ObjectPattern":
      case "RecordExpression":
        return G(Be, Pe2, Se2);
      case "ObjectProperty":
      case "Property":
        return xe2.method || xe2.kind === "get" || xe2.kind === "set" ? ke2(Be, Pe2, Se2) : ge2(Be, Pe2, Se2);
      case "ObjectMethod":
        return ke2(Be, Pe2, Se2);
      case "Decorator":
        return ["@", Se2("expression")];
      case "ArrayExpression":
      case "ArrayPattern":
      case "TupleExpression":
        return ie(Be, Pe2, Se2);
      case "SequenceExpression": {
        let je2 = Be.getParentNode(0);
        if (je2.type === "ExpressionStatement" || je2.type === "ForStatement") {
          let Re2 = [];
          return Be.each((be2, Le2) => {
            Le2 === 0 ? Re2.push(Se2()) : Re2.push(",", c([r, Se2()]));
          }, "expressions"), o(Re2);
        }
        return o(a3([",", r], Be.map(Se2, "expressions")));
      }
      case "ThisExpression":
        return "this";
      case "Super":
        return "super";
      case "Directive":
        return [Se2("value"), Xe2];
      case "DirectiveLiteral":
        return Ee(xe2, Pe2);
      case "UnaryExpression":
        return we2.push(xe2.operator), /[a-z]$/.test(xe2.operator) && we2.push(" "), A2(xe2.argument) ? we2.push(o(["(", c([i2, Se2("argument")]), i2, ")"])) : we2.push(Se2("argument")), we2;
      case "UpdateExpression":
        return we2.push(Se2("argument"), xe2.operator), xe2.prefix && we2.reverse(), we2;
      case "ConditionalExpression":
        return ue2(Be, Pe2, Se2);
      case "VariableDeclaration": {
        let je2 = Be.map(Se2, "declarations"), Re2 = Be.getParentNode(), be2 = Re2.type === "ForStatement" || Re2.type === "ForInStatement" || Re2.type === "ForOfStatement", Le2 = xe2.declarations.some((se) => se.init), qe2;
        return je2.length === 1 && !A2(xe2.declarations[0]) ? qe2 = je2[0] : je2.length > 0 && (qe2 = c(je2[0])), we2 = [xe2.declare ? "declare " : "", xe2.kind, qe2 ? [" ", qe2] : "", c(je2.slice(1).map((se) => [",", Le2 && !be2 ? u : r, se]))], be2 && Re2.body !== xe2 || we2.push(Xe2), o(we2);
      }
      case "WithStatement":
        return o(["with (", Se2("object"), ")", R(xe2.body, Se2("body"))]);
      case "IfStatement": {
        let je2 = R(xe2.consequent, Se2("consequent")), Re2 = o(["if (", o([c([i2, Se2("test")]), i2]), ")", je2]);
        if (we2.push(Re2), xe2.alternate) {
          let be2 = A2(xe2.consequent, S2.Trailing | S2.Line) || P(xe2), Le2 = xe2.consequent.type === "BlockStatement" && !be2;
          we2.push(Le2 ? " " : u), A2(xe2, S2.Dangling) && we2.push(t(Be, Pe2, true), be2 ? u : " "), we2.push("else", o(R(xe2.alternate, Se2("alternate"), xe2.alternate.type === "IfStatement")));
        }
        return we2;
      }
      case "ForStatement": {
        let je2 = R(xe2.body, Se2("body")), Re2 = t(Be, Pe2, true), be2 = Re2 ? [Re2, i2] : "";
        return !xe2.init && !xe2.test && !xe2.update ? [be2, o(["for (;;)", je2])] : [be2, o(["for (", o([c([i2, Se2("init"), ";", r, Se2("test"), ";", r, Se2("update")]), i2]), ")", je2])];
      }
      case "WhileStatement":
        return o(["while (", o([c([i2, Se2("test")]), i2]), ")", R(xe2.body, Se2("body"))]);
      case "ForInStatement":
        return o(["for (", Se2("left"), " in ", Se2("right"), ")", R(xe2.body, Se2("body"))]);
      case "ForOfStatement":
        return o(["for", xe2.await ? " await" : "", " (", Se2("left"), " of ", Se2("right"), ")", R(xe2.body, Se2("body"))]);
      case "DoWhileStatement": {
        let je2 = R(xe2.body, Se2("body"));
        return we2 = [o(["do", je2])], xe2.body.type === "BlockStatement" ? we2.push(" ") : we2.push(u), we2.push("while (", o([c([i2, Se2("test")]), i2]), ")", Xe2), we2;
      }
      case "DoExpression":
        return [xe2.async ? "async " : "", "do ", Se2("body")];
      case "BreakStatement":
        return we2.push("break"), xe2.label && we2.push(" ", Se2("label")), we2.push(Xe2), we2;
      case "ContinueStatement":
        return we2.push("continue"), xe2.label && we2.push(" ", Se2("label")), we2.push(Xe2), we2;
      case "LabeledStatement":
        return xe2.body.type === "EmptyStatement" ? [Se2("label"), ":;"] : [Se2("label"), ": ", Se2("body")];
      case "TryStatement":
        return ["try ", Se2("block"), xe2.handler ? [" ", Se2("handler")] : "", xe2.finalizer ? [" finally ", Se2("finalizer")] : ""];
      case "CatchClause":
        if (xe2.param) {
          let je2 = A2(xe2.param, (be2) => !N(be2) || be2.leading && s2(Pe2.originalText, v(be2)) || be2.trailing && s2(Pe2.originalText, E(be2), { backwards: true })), Re2 = Se2("param");
          return ["catch ", je2 ? ["(", c([i2, Re2]), i2, ") "] : ["(", Re2, ") "], Se2("body")];
        }
        return ["catch ", Se2("body")];
      case "SwitchStatement":
        return [o(["switch (", c([i2, Se2("discriminant")]), i2, ")"]), " {", xe2.cases.length > 0 ? c([u, a3(u, Be.map((je2, Re2, be2) => {
          let Le2 = je2.getValue();
          return [Se2(), Re2 !== be2.length - 1 && k2(Le2, Pe2) ? u : ""];
        }, "cases"))]) : "", u, "}"];
      case "SwitchCase": {
        xe2.test ? we2.push("case ", Se2("test"), ":") : we2.push("default:"), A2(xe2, S2.Dangling) && we2.push(" ", t(Be, Pe2, true));
        let je2 = xe2.consequent.filter((Re2) => Re2.type !== "EmptyStatement");
        if (je2.length > 0) {
          let Re2 = he2(Be, Pe2, Se2);
          we2.push(je2.length === 1 && je2[0].type === "BlockStatement" ? [" ", Re2] : c([u, Re2]));
        }
        return we2;
      }
      case "DebuggerStatement":
        return ["debugger", Xe2];
      case "ClassDeclaration":
      case "ClassExpression":
        return z(Be, Pe2, Se2);
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "MethodDefinition":
        return U(Be, Pe2, Se2);
      case "ClassProperty":
      case "PropertyDefinition":
      case "ClassPrivateProperty":
      case "ClassAccessorProperty":
        return le2(Be, Pe2, Se2);
      case "TemplateElement":
        return y(xe2.value.raw);
      case "TemplateLiteral":
        return De2(Be, Se2, Pe2);
      case "TaggedTemplateExpression":
        return [Se2("tag"), Se2("typeParameters"), Se2("quasi")];
      case "PrivateIdentifier":
        return ["#", Se2("name")];
      case "PrivateName":
        return ["#", Se2("id")];
      case "InterpreterDirective":
        return we2.push("#!", xe2.value, u), k2(xe2, Pe2) && we2.push(u), we2;
      case "TopicReference":
        return "%";
      case "ArgumentPlaceholder":
        return "?";
      case "ModuleExpression": {
        we2.push("module {");
        let je2 = Se2("body");
        return je2 && we2.push(c([u, je2]), u), we2.push("}"), we2;
      }
      default:
        throw new Error("unknown type: " + JSON.stringify(xe2.type));
    }
  }
  function Ee(Be, Pe2) {
    let Se2 = C2(Be), Qe = Se2.slice(1, -1);
    if (Qe.includes('"') || Qe.includes("'"))
      return Se2;
    let xe2 = Pe2.singleQuote ? "'" : '"';
    return xe2 + Qe + xe2;
  }
  function We2(Be) {
    return Be.type && !N(Be) && !I2(Be) && Be.type !== "EmptyStatement" && Be.type !== "TemplateElement" && Be.type !== "Import" && Be.type !== "TSEmptyBodyFunctionExpression";
  }
  n.exports = { preprocess: w2, print: J2, embed: m2, insertPragma: p, massageAstNode: d4, hasPrettierIgnore(Be) {
    return D2(Be) || j(Be);
  }, willPrintOwnComments: f.willPrintOwnComments, canAttachComment: We2, printComment: Fe2, isBlockComment: N, handleComments: { avoidAstMutation: true, ownLine: f.handleOwnLineComment, endOfLine: f.handleEndOfLineComment, remaining: f.handleRemainingComment }, getCommentChildNodes: f.getCommentChildNodes };
} }), Gm = Z({ "src/language-js/printer-estree-json.js"(e, n) {
  re();
  var { builders: { hardline: t, indent: s2, join: a3 } } = Oe(), r = Qa$1();
  function u(c, y, m2) {
    let d4 = c.getValue();
    switch (d4.type) {
      case "JsonRoot":
        return [m2("node"), t];
      case "ArrayExpression": {
        if (d4.elements.length === 0)
          return "[]";
        let p = c.map(() => c.getValue() === null ? "null" : m2(), "elements");
        return ["[", s2([t, a3([",", t], p)]), t, "]"];
      }
      case "ObjectExpression":
        return d4.properties.length === 0 ? "{}" : ["{", s2([t, a3([",", t], c.map(m2, "properties"))]), t, "}"];
      case "ObjectProperty":
        return [m2("key"), ": ", m2("value")];
      case "UnaryExpression":
        return [d4.operator === "+" ? "" : d4.operator, m2("argument")];
      case "NullLiteral":
        return "null";
      case "BooleanLiteral":
        return d4.value ? "true" : "false";
      case "StringLiteral":
      case "NumericLiteral":
        return JSON.stringify(d4.value);
      case "Identifier": {
        let p = c.getParentNode();
        return p && p.type === "ObjectProperty" && p.key === d4 ? JSON.stringify(d4.name) : d4.name;
      }
      case "TemplateLiteral":
        return m2(["quasis", 0]);
      case "TemplateElement":
        return JSON.stringify(d4.value.cooked);
      default:
        throw new Error("unknown type: " + JSON.stringify(d4.type));
    }
  }
  var i2 = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
  function o(c, y) {
    let { type: m2 } = c;
    if (m2 === "ObjectProperty" && c.key.type === "Identifier") {
      y.key = { type: "StringLiteral", value: c.key.name };
      return;
    }
    if (m2 === "UnaryExpression" && c.operator === "+")
      return y.argument;
    if (m2 === "ArrayExpression") {
      for (let [d4, p] of c.elements.entries())
        p === null && y.elements.splice(d4, 0, { type: "NullLiteral" });
      return;
    }
    if (m2 === "TemplateLiteral")
      return { type: "StringLiteral", value: c.quasis[0].value.cooked };
  }
  o.ignoredProperties = i2, n.exports = { preprocess: r, print: u, massageAstNode: o };
} }), Lt$1 = Z({ "src/common/common-options.js"(e, n) {
  re();
  var t = "Common";
  n.exports = { bracketSpacing: { since: "0.0.0", category: t, type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: t, type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { since: "1.8.2", category: t, type: "choice", default: [{ since: "1.8.2", value: true }, { since: "1.9.0", value: "preserve" }], description: "How to wrap prose.", choices: [{ since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width." }, { since: "1.9.0", value: "never", description: "Do not wrap prose." }, { since: "1.9.0", value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { since: "2.4.0", category: t, type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { since: "2.6.0", category: t, type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
} }), Jm = Z({ "src/language-js/options.js"(e, n) {
  re();
  var t = Lt$1(), s2 = "JavaScript";
  n.exports = { arrowParens: { since: "1.9.0", category: s2, type: "choice", default: [{ since: "1.9.0", value: "avoid" }, { since: "2.0.0", value: "always" }], description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: t.bracketSameLine, bracketSpacing: t.bracketSpacing, jsxBracketSameLine: { since: "0.17.0", category: s2, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { since: "1.0.0", category: s2, type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, singleQuote: t.singleQuote, jsxSingleQuote: { since: "1.15.0", category: s2, type: "boolean", default: false, description: "Use single quotes in JSX." }, quoteProps: { since: "1.17.0", category: s2, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { since: "0.0.0", category: s2, type: "choice", default: [{ since: "0.0.0", value: false }, { since: "0.19.0", value: "none" }, { since: "2.0.0", value: "es5" }], description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }, { value: "all", description: "Trailing commas wherever possible (including function arguments)." }] }, singleAttributePerLine: t.singleAttributePerLine };
} }), Um = Z({ "src/language-js/parse/parsers.js"() {
  re();
} }), Fn = Z({ "node_modules/linguist-languages/data/JavaScript.json"(e, n) {
  n.exports = { name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], languageId: 183 };
} }), zm = Z({ "node_modules/linguist-languages/data/TypeScript.json"(e, n) {
  n.exports = { name: "TypeScript", type: "programming", color: "#3178c6", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts", ".cts", ".mts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378 };
} }), Xm = Z({ "node_modules/linguist-languages/data/TSX.json"(e, n) {
  n.exports = { name: "TSX", type: "programming", color: "#3178c6", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924 };
} }), aa = Z({ "node_modules/linguist-languages/data/JSON.json"(e, n) {
  n.exports = { name: "JSON", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"], languageId: 174 };
} }), Km = Z({ "node_modules/linguist-languages/data/JSON with Comments.json"(e, n) {
  n.exports = { name: "JSON with Comments", type: "data", color: "#292929", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".code-snippets", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [".babelrc", ".devcontainer.json", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"], languageId: 423 };
} }), Ym = Z({ "node_modules/linguist-languages/data/JSON5.json"(e, n) {
  n.exports = { name: "JSON5", type: "data", color: "#267CB9", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175 };
} }), Qm = Z({ "src/language-js/index.js"(e, n) {
  re();
  var t = Tt$1(), s2 = Hm(), a3 = Gm(), r = Jm(), u = Um(), i2 = [t(Fn(), (c) => ({ since: "0.0.0", parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: [...c.interpreters, "zx"], extensions: [...c.extensions.filter((y) => y !== ".jsx"), ".wxs"] })), t(Fn(), () => ({ name: "Flow", since: "0.0.0", parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"] })), t(Fn(), () => ({ name: "JSX", since: "0.0.0", parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], aliases: void 0, filenames: void 0, extensions: [".jsx"], group: "JavaScript", interpreters: void 0, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0 })), t(zm(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] })), t(Xm(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] })), t(aa(), () => ({ name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [".importmap"], filenames: ["package.json", "package-lock.json", "composer.json"] })), t(aa(), (c) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], extensions: c.extensions.filter((y) => y !== ".jsonl") })), t(Km(), (c) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: [...c.filenames, ".eslintrc", ".swcrc"] })), t(Ym(), () => ({ since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"] }))], o = { estree: s2, "estree-json": a3 };
  n.exports = { languages: i2, options: r, printers: o, parsers: u };
} }), Zm = Z({ "src/language-css/clean.js"(e, n) {
  re();
  var { isFrontMatterNode: t } = Ue$2(), s2 = it$2(), a3 = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
  function r(i2, o, c) {
    if (t(i2) && i2.lang === "yaml" && delete o.value, i2.type === "css-comment" && c.type === "css-root" && c.nodes.length > 0 && ((c.nodes[0] === i2 || t(c.nodes[0]) && c.nodes[1] === i2) && (delete o.text, /^\*\s*@(?:format|prettier)\s*$/.test(i2.text)) || c.type === "css-root" && s2(c.nodes) === i2))
      return null;
    if (i2.type === "value-root" && delete o.text, (i2.type === "media-query" || i2.type === "media-query-list" || i2.type === "media-feature-expression") && delete o.value, i2.type === "css-rule" && delete o.params, i2.type === "selector-combinator" && (o.value = o.value.replace(/\s+/g, " ")), i2.type === "media-feature" && (o.value = o.value.replace(/ /g, "")), (i2.type === "value-word" && (i2.isColor && i2.isHex || ["initial", "inherit", "unset", "revert"].includes(o.value.replace().toLowerCase())) || i2.type === "media-feature" || i2.type === "selector-root-invalid" || i2.type === "selector-pseudo") && (o.value = o.value.toLowerCase()), i2.type === "css-decl" && (o.prop = o.prop.toLowerCase()), (i2.type === "css-atrule" || i2.type === "css-import") && (o.name = o.name.toLowerCase()), i2.type === "value-number" && (o.unit = o.unit.toLowerCase()), (i2.type === "media-feature" || i2.type === "media-keyword" || i2.type === "media-type" || i2.type === "media-unknown" || i2.type === "media-url" || i2.type === "media-value" || i2.type === "selector-attribute" || i2.type === "selector-string" || i2.type === "selector-class" || i2.type === "selector-combinator" || i2.type === "value-string") && o.value && (o.value = u(o.value)), i2.type === "selector-attribute" && (o.attribute = o.attribute.trim(), o.namespace && typeof o.namespace == "string" && (o.namespace = o.namespace.trim(), o.namespace.length === 0 && (o.namespace = true)), o.value && (o.value = o.value.trim().replace(/^["']|["']$/g, ""), delete o.quoted)), (i2.type === "media-value" || i2.type === "media-type" || i2.type === "value-number" || i2.type === "selector-root-invalid" || i2.type === "selector-class" || i2.type === "selector-combinator" || i2.type === "selector-tag") && o.value && (o.value = o.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (y, m2, d4) => {
      let p = Number(m2);
      return Number.isNaN(p) ? y : p + d4.toLowerCase();
    })), i2.type === "selector-tag") {
      let y = i2.value.toLowerCase();
      ["from", "to"].includes(y) && (o.value = y);
    }
    if (i2.type === "css-atrule" && i2.name.toLowerCase() === "supports" && delete o.value, i2.type === "selector-unknown" && delete o.value, i2.type === "value-comma_group") {
      let y = i2.groups.findIndex((m2) => m2.type === "value-number" && m2.unit === "...");
      y !== -1 && (o.groups[y].unit = "", o.groups.splice(y + 1, 0, { type: "value-word", value: "...", isColor: false, isHex: false }));
    }
  }
  r.ignoredProperties = a3;
  function u(i2) {
    return i2.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1");
  }
  n.exports = r;
} }), Jn$2 = Z({ "src/utils/front-matter/print.js"(e, n) {
  re();
  var { builders: { hardline: t, markAsRoot: s2 } } = Oe();
  function a3(r, u) {
    if (r.lang === "yaml") {
      let i2 = r.value.trim(), o = i2 ? u(i2, { parser: "yaml" }, { stripTrailingHardline: true }) : "";
      return s2([r.startDelimiter, t, o, o ? t : "", r.endDelimiter]);
    }
  }
  n.exports = a3;
} }), ed = Z({ "src/language-css/embed.js"(e, n) {
  re();
  var { builders: { hardline: t } } = Oe(), s2 = Jn$2();
  function a3(r, u, i2) {
    let o = r.getValue();
    if (o.type === "front-matter") {
      let c = s2(o, i2);
      return c ? [c, t] : "";
    }
  }
  n.exports = a3;
} }), ao$2 = Z({ "src/utils/front-matter/parse.js"(e, n) {
  re();
  var t = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
  function s2(a3) {
    let r = a3.match(t);
    if (!r)
      return { content: a3 };
    let { startDelimiter: u, language: i2, value: o = "", endDelimiter: c } = r.groups, y = i2.trim() || "yaml";
    if (u === "+++" && (y = "toml"), y !== "yaml" && u !== c)
      return { content: a3 };
    let [m2] = r;
    return { frontMatter: { type: "front-matter", lang: y, value: o, startDelimiter: u, endDelimiter: c, raw: m2.replace(/\n$/, "") }, content: m2.replace(/[^\n]/g, " ") + a3.slice(m2.length) };
  }
  n.exports = s2;
} }), td = Z({ "src/language-css/pragma.js"(e, n) {
  re();
  var t = Ka$1(), s2 = ao$2();
  function a3(u) {
    return t.hasPragma(s2(u).content);
  }
  function r(u) {
    let { frontMatter: i2, content: o } = s2(u);
    return (i2 ? i2.raw + `

` : "") + t.insertPragma(o);
  }
  n.exports = { hasPragma: a3, insertPragma: r };
} }), rd = Z({ "src/language-css/utils/index.js"(e, n) {
  re();
  var t = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
  function s2(G, z) {
    let U = Array.isArray(z) ? z : [z], le2 = -1, ge2;
    for (; ge2 = G.getParentNode(++le2); )
      if (U.includes(ge2.type))
        return le2;
    return -1;
  }
  function a3(G, z) {
    let U = s2(G, z);
    return U === -1 ? null : G.getParentNode(U);
  }
  function r(G) {
    var z;
    let U = a3(G, "css-decl");
    return U == null || (z = U.prop) === null || z === void 0 ? void 0 : z.toLowerCase();
  }
  var u = /* @__PURE__ */ new Set(["initial", "inherit", "unset", "revert"]);
  function i2(G) {
    return u.has(G.toLowerCase());
  }
  function o(G, z) {
    let U = a3(G, "css-atrule");
    return (U == null ? void 0 : U.name) && U.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(z.toLowerCase());
  }
  function c(G) {
    return G.includes("$") || G.includes("@") || G.includes("#") || G.startsWith("%") || G.startsWith("--") || G.startsWith(":--") || G.includes("(") && G.includes(")") ? G : G.toLowerCase();
  }
  function y(G, z) {
    var U;
    let le2 = a3(G, "value-func");
    return (le2 == null || (U = le2.value) === null || U === void 0 ? void 0 : U.toLowerCase()) === z;
  }
  function m2(G) {
    var z;
    let U = a3(G, "css-rule"), le2 = U == null || (z = U.raws) === null || z === void 0 ? void 0 : z.selector;
    return le2 && (le2.startsWith(":import") || le2.startsWith(":export"));
  }
  function d4(G, z) {
    let U = Array.isArray(z) ? z : [z], le2 = a3(G, "css-atrule");
    return le2 && U.includes(le2.name.toLowerCase());
  }
  function p(G) {
    let z = G.getValue(), U = a3(G, "css-atrule");
    return (U == null ? void 0 : U.name) === "import" && z.groups[0].value === "url" && z.groups.length === 2;
  }
  function f(G) {
    return G.type === "value-func" && G.value.toLowerCase() === "url";
  }
  function h2(G, z) {
    var U;
    let le2 = (U = G.getParentNode()) === null || U === void 0 ? void 0 : U.nodes;
    return le2 && le2.indexOf(z) === le2.length - 1;
  }
  function w2(G) {
    let { selector: z } = G;
    return z ? typeof z == "string" && /^@.+:.*$/.test(z) || z.value && /^@.+:.*$/.test(z.value) : false;
  }
  function T2(G) {
    return G.type === "value-word" && ["from", "through", "end"].includes(G.value);
  }
  function A2(G) {
    return G.type === "value-word" && ["and", "or", "not"].includes(G.value);
  }
  function S2(G) {
    return G.type === "value-word" && G.value === "in";
  }
  function B(G) {
    return G.type === "value-operator" && G.value === "*";
  }
  function I2(G) {
    return G.type === "value-operator" && G.value === "/";
  }
  function k2(G) {
    return G.type === "value-operator" && G.value === "+";
  }
  function P(G) {
    return G.type === "value-operator" && G.value === "-";
  }
  function C2(G) {
    return G.type === "value-operator" && G.value === "%";
  }
  function D2(G) {
    return B(G) || I2(G) || k2(G) || P(G) || C2(G);
  }
  function g2(G) {
    return G.type === "value-word" && ["==", "!="].includes(G.value);
  }
  function F(G) {
    return G.type === "value-word" && ["<", ">", "<=", ">="].includes(G.value);
  }
  function l(G) {
    return G.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(G.name);
  }
  function E(G) {
    var z;
    return ((z = G.raws) === null || z === void 0 ? void 0 : z.params) && /^\(\s*\)$/.test(G.raws.params);
  }
  function v(G) {
    return G.name.startsWith("prettier-placeholder");
  }
  function N(G) {
    return G.prop.startsWith("@prettier-placeholder");
  }
  function x2(G, z) {
    return G.value === "$$" && G.type === "value-func" && (z == null ? void 0 : z.type) === "value-word" && !z.raws.before;
  }
  function b2(G) {
    var z, U;
    return ((z = G.value) === null || z === void 0 ? void 0 : z.type) === "value-root" && ((U = G.value.group) === null || U === void 0 ? void 0 : U.type) === "value-value" && G.prop.toLowerCase() === "composes";
  }
  function L(G) {
    var z, U, le2;
    return ((z = G.value) === null || z === void 0 || (U = z.group) === null || U === void 0 || (le2 = U.group) === null || le2 === void 0 ? void 0 : le2.type) === "value-paren_group" && G.value.group.group.open !== null && G.value.group.group.close !== null;
  }
  function M2(G) {
    var z;
    return ((z = G.raws) === null || z === void 0 ? void 0 : z.before) === "";
  }
  function j(G) {
    var z, U;
    return G.type === "value-comma_group" && ((z = G.groups) === null || z === void 0 || (U = z[1]) === null || U === void 0 ? void 0 : U.type) === "value-colon";
  }
  function $(G) {
    var z;
    return G.type === "value-paren_group" && ((z = G.groups) === null || z === void 0 ? void 0 : z[0]) && j(G.groups[0]);
  }
  function V(G) {
    var z;
    let U = G.getValue();
    if (U.groups.length === 0)
      return false;
    let le2 = G.getParentNode(1);
    if (!$(U) && !(le2 && $(le2)))
      return false;
    let ge2 = a3(G, "css-decl");
    return !!(ge2 != null && (z = ge2.prop) !== null && z !== void 0 && z.startsWith("$") || $(le2) || le2.type === "value-func");
  }
  function q(G) {
    return G.type === "value-comment" && G.inline;
  }
  function Y3(G) {
    return G.type === "value-word" && G.value === "#";
  }
  function H3(G) {
    return G.type === "value-word" && G.value === "{";
  }
  function R(G) {
    return G.type === "value-word" && G.value === "}";
  }
  function Q(G) {
    return ["value-word", "value-atword"].includes(G.type);
  }
  function ee2(G) {
    return (G == null ? void 0 : G.type) === "value-colon";
  }
  function te2(G, z) {
    if (!j(z))
      return false;
    let { groups: U } = z, le2 = U.indexOf(G);
    return le2 === -1 ? false : ee2(U[le2 + 1]);
  }
  function oe2(G) {
    return G.value && ["not", "and", "or"].includes(G.value.toLowerCase());
  }
  function W2(G) {
    return G.type !== "value-func" ? false : t.has(G.value.toLowerCase());
  }
  function X3(G) {
    return /\/\//.test(G.split(/[\n\r]/).pop());
  }
  function ue2(G) {
    return (G == null ? void 0 : G.type) === "value-atword" && G.value.startsWith("prettier-placeholder-");
  }
  function De2(G, z) {
    var U, le2;
    if (((U = G.open) === null || U === void 0 ? void 0 : U.value) !== "(" || ((le2 = G.close) === null || le2 === void 0 ? void 0 : le2.value) !== ")" || G.groups.some((ge2) => ge2.type !== "value-comma_group"))
      return false;
    if (z.type === "value-comma_group") {
      let ge2 = z.groups.indexOf(G) - 1, Ae2 = z.groups[ge2];
      if ((Ae2 == null ? void 0 : Ae2.type) === "value-word" && Ae2.value === "with")
        return true;
    }
    return false;
  }
  function ie(G) {
    var z, U;
    return G.type === "value-paren_group" && ((z = G.open) === null || z === void 0 ? void 0 : z.value) === "(" && ((U = G.close) === null || U === void 0 ? void 0 : U.value) === ")";
  }
  n.exports = { getAncestorCounter: s2, getAncestorNode: a3, getPropOfDeclNode: r, maybeToLowerCase: c, insideValueFunctionNode: y, insideICSSRuleNode: m2, insideAtRuleNode: d4, insideURLFunctionInImportAtRuleNode: p, isKeyframeAtRuleKeywords: o, isWideKeywords: i2, isLastNode: h2, isSCSSControlDirectiveNode: l, isDetachedRulesetDeclarationNode: w2, isRelationalOperatorNode: F, isEqualityOperatorNode: g2, isMultiplicationNode: B, isDivisionNode: I2, isAdditionNode: k2, isSubtractionNode: P, isModuloNode: C2, isMathOperatorNode: D2, isEachKeywordNode: S2, isForKeywordNode: T2, isURLFunctionNode: f, isIfElseKeywordNode: A2, hasComposesNode: b2, hasParensAroundNode: L, hasEmptyRawBefore: M2, isDetachedRulesetCallNode: E, isTemplatePlaceholderNode: v, isTemplatePropNode: N, isPostcssSimpleVarNode: x2, isKeyValuePairNode: j, isKeyValuePairInParenGroupNode: $, isKeyInValuePairNode: te2, isSCSSMapItemNode: V, isInlineValueCommentNode: q, isHashNode: Y3, isLeftCurlyBraceNode: H3, isRightCurlyBraceNode: R, isWordNode: Q, isColonNode: ee2, isMediaAndSupportsKeywords: oe2, isColorAdjusterFuncNode: W2, lastLineHasInlineComment: X3, isAtWordPlaceholderNode: ue2, isConfigurationNode: De2, isParenGroupNode: ie };
} }), nd = Z({ "src/utils/line-column-to-index.js"(e, n) {
  re(), n.exports = function(t, s2) {
    let a3 = 0;
    for (let r = 0; r < t.line - 1; ++r)
      a3 = s2.indexOf(`
`, a3) + 1;
    return a3 + t.column;
  };
} }), ud = Z({ "src/language-css/loc.js"(e, n) {
  re();
  var { skipEverythingButNewLine: t } = Tr(), s2 = it$2(), a3 = nd();
  function r(p, f) {
    return typeof p.sourceIndex == "number" ? p.sourceIndex : p.source ? a3(p.source.start, f) - 1 : null;
  }
  function u(p, f) {
    if (p.type === "css-comment" && p.inline)
      return t(f, p.source.startOffset);
    let h2 = p.nodes && s2(p.nodes);
    return h2 && p.source && !p.source.end && (p = h2), p.source && p.source.end ? a3(p.source.end, f) : null;
  }
  function i2(p, f) {
    p.source && (p.source.startOffset = r(p, f), p.source.endOffset = u(p, f));
    for (let h2 in p) {
      let w2 = p[h2];
      h2 === "source" || !w2 || typeof w2 != "object" || (w2.type === "value-root" || w2.type === "value-unknown" ? o(w2, c(p), w2.text || w2.value) : i2(w2, f));
    }
  }
  function o(p, f, h2) {
    p.source && (p.source.startOffset = r(p, h2) + f, p.source.endOffset = u(p, h2) + f);
    for (let w2 in p) {
      let T2 = p[w2];
      w2 === "source" || !T2 || typeof T2 != "object" || o(T2, f, h2);
    }
  }
  function c(p) {
    let f = p.source.startOffset;
    return typeof p.prop == "string" && (f += p.prop.length), p.type === "css-atrule" && typeof p.name == "string" && (f += 1 + p.name.length + p.raws.afterName.match(/^\s*:?\s*/)[0].length), p.type !== "css-atrule" && p.raws && typeof p.raws.between == "string" && (f += p.raws.between.length), f;
  }
  function y(p) {
    let f = "initial", h2 = "initial", w2, T2 = false, A2 = [];
    for (let S2 = 0; S2 < p.length; S2++) {
      let B = p[S2];
      switch (f) {
        case "initial":
          if (B === "'") {
            f = "single-quotes";
            continue;
          }
          if (B === '"') {
            f = "double-quotes";
            continue;
          }
          if ((B === "u" || B === "U") && p.slice(S2, S2 + 4).toLowerCase() === "url(") {
            f = "url", S2 += 3;
            continue;
          }
          if (B === "*" && p[S2 - 1] === "/") {
            f = "comment-block";
            continue;
          }
          if (B === "/" && p[S2 - 1] === "/") {
            f = "comment-inline", w2 = S2 - 1;
            continue;
          }
          continue;
        case "single-quotes":
          if (B === "'" && p[S2 - 1] !== "\\" && (f = h2, h2 = "initial"), B === `
` || B === "\r")
            return p;
          continue;
        case "double-quotes":
          if (B === '"' && p[S2 - 1] !== "\\" && (f = h2, h2 = "initial"), B === `
` || B === "\r")
            return p;
          continue;
        case "url":
          if (B === ")" && (f = "initial"), B === `
` || B === "\r")
            return p;
          if (B === "'") {
            f = "single-quotes", h2 = "url";
            continue;
          }
          if (B === '"') {
            f = "double-quotes", h2 = "url";
            continue;
          }
          continue;
        case "comment-block":
          B === "/" && p[S2 - 1] === "*" && (f = "initial");
          continue;
        case "comment-inline":
          (B === '"' || B === "'" || B === "*") && (T2 = true), (B === `
` || B === "\r") && (T2 && A2.push([w2, S2]), f = "initial", T2 = false);
          continue;
      }
    }
    for (let [S2, B] of A2)
      p = p.slice(0, S2) + p.slice(S2, B).replace(/["'*]/g, " ") + p.slice(B);
    return p;
  }
  function m2(p) {
    return p.source.startOffset;
  }
  function d4(p) {
    return p.source.endOffset;
  }
  n.exports = { locStart: m2, locEnd: d4, calculateLoc: i2, replaceQuotesInInlineComments: y };
} }), sd = Z({ "src/language-css/utils/is-less-parser.js"(e, n) {
  re();
  function t(s2) {
    return s2.parser === "css" || s2.parser === "less";
  }
  n.exports = t;
} }), id = Z({ "src/language-css/utils/is-scss.js"(e, n) {
  re();
  function t(s2, a3) {
    return s2 === "less" || s2 === "scss" ? s2 === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(a3);
  }
  n.exports = t;
} }), ad = Z({ "src/language-css/utils/css-units.evaluate.js"(e, n) {
  n.exports = { em: "em", rem: "rem", ex: "ex", rex: "rex", cap: "cap", rcap: "rcap", ch: "ch", rch: "rch", ic: "ic", ric: "ric", lh: "lh", rlh: "rlh", vw: "vw", svw: "svw", lvw: "lvw", dvw: "dvw", vh: "vh", svh: "svh", lvh: "lvh", dvh: "dvh", vi: "vi", svi: "svi", lvi: "lvi", dvi: "dvi", vb: "vb", svb: "svb", lvb: "lvb", dvb: "dvb", vmin: "vmin", svmin: "svmin", lvmin: "lvmin", dvmin: "dvmin", vmax: "vmax", svmax: "svmax", lvmax: "lvmax", dvmax: "dvmax", cm: "cm", mm: "mm", q: "Q", in: "in", pt: "pt", pc: "pc", px: "px", deg: "deg", grad: "grad", rad: "rad", turn: "turn", s: "s", ms: "ms", hz: "Hz", khz: "kHz", dpi: "dpi", dpcm: "dpcm", dppx: "dppx", x: "x" };
} }), od = Z({ "src/language-css/utils/print-unit.js"(e, n) {
  re();
  var t = ad();
  function s2(a3) {
    let r = a3.toLowerCase();
    return Object.prototype.hasOwnProperty.call(t, r) ? t[r] : a3;
  }
  n.exports = s2;
} }), ld = Z({ "src/language-css/printer-postcss.js"(e, n) {
  re();
  var t = it$2(), { printNumber: s2, printString: a3, hasNewline: r, isFrontMatterNode: u, isNextLineEmpty: i2, isNonEmptyArray: o } = Ue$2(), { builders: { join: c, line: y, hardline: m2, softline: d4, group: p, fill: f, indent: h2, dedent: w2, ifBreak: T2, breakParent: A2 }, utils: { removeLines: S2, getDocParts: B } } = Oe(), I2 = Zm(), k2 = ed(), { insertPragma: P } = td(), { getAncestorNode: C2, getPropOfDeclNode: D2, maybeToLowerCase: g2, insideValueFunctionNode: F, insideICSSRuleNode: l, insideAtRuleNode: E, insideURLFunctionInImportAtRuleNode: v, isKeyframeAtRuleKeywords: N, isWideKeywords: x2, isLastNode: b2, isSCSSControlDirectiveNode: L, isDetachedRulesetDeclarationNode: M2, isRelationalOperatorNode: j, isEqualityOperatorNode: $, isMultiplicationNode: V, isDivisionNode: q, isAdditionNode: Y3, isSubtractionNode: H3, isMathOperatorNode: R, isEachKeywordNode: Q, isForKeywordNode: ee2, isURLFunctionNode: te2, isIfElseKeywordNode: oe2, hasComposesNode: W2, hasParensAroundNode: X3, hasEmptyRawBefore: ue2, isKeyValuePairNode: De2, isKeyInValuePairNode: ie, isDetachedRulesetCallNode: G, isTemplatePlaceholderNode: z, isTemplatePropNode: U, isPostcssSimpleVarNode: le2, isSCSSMapItemNode: ge2, isInlineValueCommentNode: Ae2, isHashNode: Ne2, isLeftCurlyBraceNode: ke2, isRightCurlyBraceNode: ce, isWordNode: pe, isColonNode: de2, isMediaAndSupportsKeywords: ae2, isColorAdjusterFuncNode: ve2, lastLineHasInlineComment: K, isAtWordPlaceholderNode: he2, isConfigurationNode: ye2, isParenGroupNode: Ce2 } = rd(), { locStart: Ie2, locEnd: Fe2 } = ud(), me2 = sd(), _ = id(), J2 = od();
  function ne(be2) {
    return be2.trailingComma === "es5" || be2.trailingComma === "all";
  }
  function Ee(be2, Le2, qe2) {
    let se = be2.getValue();
    if (!se)
      return "";
    if (typeof se == "string")
      return se;
    switch (se.type) {
      case "front-matter":
        return [se.raw, m2];
      case "css-root": {
        let He2 = We2(be2, Le2, qe2), Me2 = se.raws.after.trim();
        return [He2, Me2 ? " ".concat(Me2) : "", B(He2).length > 0 ? m2 : ""];
      }
      case "css-comment": {
        let He2 = se.inline || se.raws.inline, Me2 = Le2.originalText.slice(Ie2(se), Fe2(se));
        return He2 ? Me2.trimEnd() : Me2;
      }
      case "css-rule":
        return [qe2("selector"), se.important ? " !important" : "", se.nodes ? [se.selector && se.selector.type === "selector-unknown" && K(se.selector.value) ? y : " ", "{", se.nodes.length > 0 ? h2([m2, We2(be2, Le2, qe2)]) : "", m2, "}", M2(se) ? ";" : ""] : ";"];
      case "css-decl": {
        let He2 = be2.getParentNode(), { between: Me2 } = se.raws, ze = Me2.trim(), nt = ze === ":", tt = W2(se) ? S2(qe2("value")) : qe2("value");
        return !nt && K(ze) && (tt = h2([m2, w2(tt)])), [se.raws.before.replace(/[\s;]/g, ""), l(be2) ? se.prop : g2(se.prop), ze.startsWith("//") ? " " : "", ze, se.extend ? "" : " ", me2(Le2) && se.extend && se.selector ? ["extend(", qe2("selector"), ")"] : "", tt, se.raws.important ? se.raws.important.replace(/\s*!\s*important/i, " !important") : se.important ? " !important" : "", se.raws.scssDefault ? se.raws.scssDefault.replace(/\s*!default/i, " !default") : se.scssDefault ? " !default" : "", se.raws.scssGlobal ? se.raws.scssGlobal.replace(/\s*!global/i, " !global") : se.scssGlobal ? " !global" : "", se.nodes ? [" {", h2([d4, We2(be2, Le2, qe2)]), d4, "}"] : U(se) && !He2.raws.semicolon && Le2.originalText[Fe2(se) - 1] !== ";" ? "" : Le2.__isHTMLStyleAttribute && b2(be2, se) ? T2(";") : ";"];
      }
      case "css-atrule": {
        let He2 = be2.getParentNode(), Me2 = z(se) && !He2.raws.semicolon && Le2.originalText[Fe2(se) - 1] !== ";";
        if (me2(Le2)) {
          if (se.mixin)
            return [qe2("selector"), se.important ? " !important" : "", Me2 ? "" : ";"];
          if (se.function)
            return [se.name, qe2("params"), Me2 ? "" : ";"];
          if (se.variable)
            return ["@", se.name, ": ", se.value ? qe2("value") : "", se.raws.between.trim() ? se.raws.between.trim() + " " : "", se.nodes ? ["{", h2([se.nodes.length > 0 ? d4 : "", We2(be2, Le2, qe2)]), d4, "}"] : "", Me2 ? "" : ";"];
        }
        return ["@", G(se) || se.name.endsWith(":") ? se.name : g2(se.name), se.params ? [G(se) ? "" : z(se) ? se.raws.afterName === "" ? "" : se.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(se.raws.afterName) ? [m2, m2] : /^\s*\n/.test(se.raws.afterName) ? m2 : " " : " ", qe2("params")] : "", se.selector ? h2([" ", qe2("selector")]) : "", se.value ? p([" ", qe2("value"), L(se) ? X3(se) ? " " : y : ""]) : se.name === "else" ? " " : "", se.nodes ? [L(se) ? "" : se.selector && !se.selector.nodes && typeof se.selector.value == "string" && K(se.selector.value) || !se.selector && typeof se.params == "string" && K(se.params) ? y : " ", "{", h2([se.nodes.length > 0 ? d4 : "", We2(be2, Le2, qe2)]), d4, "}"] : Me2 ? "" : ";"];
      }
      case "media-query-list": {
        let He2 = [];
        return be2.each((Me2) => {
          let ze = Me2.getValue();
          ze.type === "media-query" && ze.value === "" || He2.push(qe2());
        }, "nodes"), p(h2(c(y, He2)));
      }
      case "media-query":
        return [c(" ", be2.map(qe2, "nodes")), b2(be2, se) ? "" : ","];
      case "media-type":
        return je2(Xe2(se.value, Le2));
      case "media-feature-expression":
        return se.nodes ? ["(", ...be2.map(qe2, "nodes"), ")"] : se.value;
      case "media-feature":
        return g2(Xe2(se.value.replace(/ +/g, " "), Le2));
      case "media-colon":
        return [se.value, " "];
      case "media-value":
        return je2(Xe2(se.value, Le2));
      case "media-keyword":
        return Xe2(se.value, Le2);
      case "media-url":
        return Xe2(se.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), Le2);
      case "media-unknown":
        return se.value;
      case "selector-root":
        return p([E(be2, "custom-selector") ? [C2(be2, "css-atrule").customSelector, y] : "", c([",", E(be2, ["extend", "custom-selector", "nest"]) ? y : m2], be2.map(qe2, "nodes"))]);
      case "selector-selector":
        return p(h2(be2.map(qe2, "nodes")));
      case "selector-comment":
        return se.value;
      case "selector-string":
        return Xe2(se.value, Le2);
      case "selector-tag": {
        let He2 = be2.getParentNode(), Me2 = He2 && He2.nodes.indexOf(se), ze = Me2 && He2.nodes[Me2 - 1];
        return [se.namespace ? [se.namespace === true ? "" : se.namespace.trim(), "|"] : "", ze.type === "selector-nesting" ? se.value : je2(N(be2, se.value) ? se.value.toLowerCase() : se.value)];
      }
      case "selector-id":
        return ["#", se.value];
      case "selector-class":
        return [".", je2(Xe2(se.value, Le2))];
      case "selector-attribute":
        return ["[", se.namespace ? [se.namespace === true ? "" : se.namespace.trim(), "|"] : "", se.attribute.trim(), se.operator ? se.operator : "", se.value ? we2(Xe2(se.value.trim(), Le2), Le2) : "", se.insensitive ? " i" : "", "]"];
      case "selector-combinator": {
        if (se.value === "+" || se.value === ">" || se.value === "~" || se.value === ">>>") {
          let ze = be2.getParentNode();
          return [ze.type === "selector-selector" && ze.nodes[0] === se ? "" : y, se.value, b2(be2, se) ? "" : " "];
        }
        let He2 = se.value.trim().startsWith("(") ? y : "", Me2 = je2(Xe2(se.value.trim(), Le2)) || y;
        return [He2, Me2];
      }
      case "selector-universal":
        return [se.namespace ? [se.namespace === true ? "" : se.namespace.trim(), "|"] : "", se.value];
      case "selector-pseudo":
        return [g2(se.value), o(se.nodes) ? ["(", c(", ", be2.map(qe2, "nodes")), ")"] : ""];
      case "selector-nesting":
        return se.value;
      case "selector-unknown": {
        let He2 = C2(be2, "css-rule");
        if (He2 && He2.isSCSSNesterProperty)
          return je2(Xe2(g2(se.value), Le2));
        let Me2 = be2.getParentNode();
        if (Me2.raws && Me2.raws.selector) {
          let nt = Ie2(Me2), tt = nt + Me2.raws.selector.length;
          return Le2.originalText.slice(nt, tt).trim();
        }
        let ze = be2.getParentNode(1);
        if (Me2.type === "value-paren_group" && ze && ze.type === "value-func" && ze.value === "selector") {
          let nt = Fe2(Me2.open) + 1, tt = Ie2(Me2.close), pt2 = Le2.originalText.slice(nt, tt).trim();
          return K(pt2) ? [A2, pt2] : pt2;
        }
        return se.value;
      }
      case "value-value":
      case "value-root":
        return qe2("group");
      case "value-comment":
        return Le2.originalText.slice(Ie2(se), Fe2(se));
      case "value-comma_group": {
        let He2 = be2.getParentNode(), Me2 = be2.getParentNode(1), ze = D2(be2), nt = ze && He2.type === "value-value" && (ze === "grid" || ze.startsWith("grid-template")), tt = C2(be2, "css-atrule"), pt2 = tt && L(tt), O2 = se.groups.some((ut2) => Ae2(ut2)), fe2 = be2.map(qe2, "groups"), Te2 = [], $e2 = F(be2, "url"), Je2 = false, Ze2 = false;
        for (let ut2 = 0; ut2 < se.groups.length; ++ut2) {
          Te2.push(fe2[ut2]);
          let rt2 = se.groups[ut2 - 1], Ve2 = se.groups[ut2], Ge2 = se.groups[ut2 + 1], Zt = se.groups[ut2 + 2];
          if ($e2) {
            (Ge2 && Y3(Ge2) || Y3(Ve2)) && Te2.push(" ");
            continue;
          }
          if (E(be2, "forward") && Ve2.type === "value-word" && Ve2.value && rt2 !== void 0 && rt2.type === "value-word" && rt2.value === "as" && Ge2.type === "value-operator" && Ge2.value === "*" || !Ge2 || Ve2.type === "value-word" && Ve2.value.endsWith("-") && he2(Ge2))
            continue;
          let fo2 = Ve2.type === "value-string" && Ve2.value.startsWith("#{"), Do2 = Je2 && Ge2.type === "value-string" && Ge2.value.endsWith("}");
          if (fo2 || Do2) {
            Je2 = !Je2;
            continue;
          }
          if (Je2 || de2(Ve2) || de2(Ge2) || Ve2.type === "value-atword" && Ve2.value === "" || Ve2.value === "~" || Ve2.value && Ve2.value.includes("\\") && Ge2 && Ge2.type !== "value-comment" || rt2 && rt2.value && rt2.value.indexOf("\\") === rt2.value.length - 1 && Ve2.type === "value-operator" && Ve2.value === "/" || Ve2.value === "\\" || le2(Ve2, Ge2) || Ne2(Ve2) || ke2(Ve2) || ce(Ge2) || ke2(Ge2) && ue2(Ge2) || ce(Ve2) && ue2(Ge2) || Ve2.value === "--" && Ne2(Ge2))
            continue;
          let Xn2 = R(Ve2), Kn2 = R(Ge2);
          if ((Xn2 && Ne2(Ge2) || Kn2 && ce(Ve2)) && ue2(Ge2) || !rt2 && q(Ve2) || F(be2, "calc") && (Y3(Ve2) || Y3(Ge2) || H3(Ve2) || H3(Ge2)) && ue2(Ge2))
            continue;
          let mo2 = (Y3(Ve2) || H3(Ve2)) && ut2 === 0 && (Ge2.type === "value-number" || Ge2.isHex) && Me2 && ve2(Me2) && !ue2(Ge2), Yn2 = Zt && Zt.type === "value-func" || Zt && pe(Zt) || Ve2.type === "value-func" || pe(Ve2), Qn2 = Ge2.type === "value-func" || pe(Ge2) || rt2 && rt2.type === "value-func" || rt2 && pe(rt2);
          if (!(!(V(Ge2) || V(Ve2)) && !F(be2, "calc") && !mo2 && (q(Ge2) && !Yn2 || q(Ve2) && !Qn2 || Y3(Ge2) && !Yn2 || Y3(Ve2) && !Qn2 || H3(Ge2) || H3(Ve2)) && (ue2(Ge2) || Xn2 && (!rt2 || rt2 && R(rt2))))) {
            if (Ae2(Ve2)) {
              if (He2.type === "value-paren_group") {
                Te2.push(w2(m2));
                continue;
              }
              Te2.push(m2);
              continue;
            }
            if (pt2 && ($(Ge2) || j(Ge2) || oe2(Ge2) || Q(Ve2) || ee2(Ve2))) {
              Te2.push(" ");
              continue;
            }
            if (tt && tt.name.toLowerCase() === "namespace") {
              Te2.push(" ");
              continue;
            }
            if (nt) {
              Ve2.source && Ge2.source && Ve2.source.start.line !== Ge2.source.start.line ? (Te2.push(m2), Ze2 = true) : Te2.push(" ");
              continue;
            }
            if (Kn2) {
              Te2.push(" ");
              continue;
            }
            if (!(Ge2 && Ge2.value === "...") && !(he2(Ve2) && he2(Ge2) && Fe2(Ve2) === Ie2(Ge2))) {
              if (he2(Ve2) && Ce2(Ge2) && Fe2(Ve2) === Ie2(Ge2.open)) {
                Te2.push(d4);
                continue;
              }
              if (Ve2.value === "with" && Ce2(Ge2)) {
                Te2.push(" ");
                continue;
              }
              Te2.push(y);
            }
          }
        }
        return O2 && Te2.push(A2), Ze2 && Te2.unshift(m2), pt2 ? p(h2(Te2)) : v(be2) ? p(f(Te2)) : p(h2(f(Te2)));
      }
      case "value-paren_group": {
        let He2 = be2.getParentNode();
        if (He2 && te2(He2) && (se.groups.length === 1 || se.groups.length > 0 && se.groups[0].type === "value-comma_group" && se.groups[0].groups.length > 0 && se.groups[0].groups[0].type === "value-word" && se.groups[0].groups[0].value.startsWith("data:")))
          return [se.open ? qe2("open") : "", c(",", be2.map(qe2, "groups")), se.close ? qe2("close") : ""];
        if (!se.open) {
          let $e2 = be2.map(qe2, "groups"), Je2 = [];
          for (let Ze2 = 0; Ze2 < $e2.length; Ze2++)
            Ze2 !== 0 && Je2.push([",", y]), Je2.push($e2[Ze2]);
          return p(h2(f(Je2)));
        }
        let Me2 = ge2(be2), ze = t(se.groups), nt = ze && ze.type === "value-comment", tt = ie(se, He2), pt2 = ye2(se, He2), O2 = pt2 || Me2 && !tt, fe2 = pt2 || tt, Te2 = p([se.open ? qe2("open") : "", h2([d4, c([y], be2.map(($e2, Je2) => {
          let Ze2 = $e2.getValue(), ut2 = Je2 === se.groups.length - 1, rt2 = [qe2(), ut2 ? "" : ","];
          if (De2(Ze2) && Ze2.type === "value-comma_group" && Ze2.groups && Ze2.groups[0].type !== "value-paren_group" && Ze2.groups[2] && Ze2.groups[2].type === "value-paren_group") {
            let Ve2 = B(rt2[0].contents.contents);
            return Ve2[1] = p(Ve2[1]), p(w2(rt2));
          }
          if (!ut2 && Ze2.type === "value-comma_group" && o(Ze2.groups)) {
            let Ve2 = t(Ze2.groups);
            Ve2.source && i2(Le2.originalText, Ve2, Fe2) && rt2.push(m2);
          }
          return rt2;
        }, "groups"))]), T2(!nt && _(Le2.parser, Le2.originalText) && Me2 && ne(Le2) ? "," : ""), d4, se.close ? qe2("close") : ""], { shouldBreak: O2 });
        return fe2 ? w2(Te2) : Te2;
      }
      case "value-func":
        return [se.value, E(be2, "supports") && ae2(se) ? " " : "", qe2("group")];
      case "value-paren":
        return se.value;
      case "value-number":
        return [Re2(se.value), J2(se.unit)];
      case "value-operator":
        return se.value;
      case "value-word":
        return se.isColor && se.isHex || x2(se.value) ? se.value.toLowerCase() : se.value;
      case "value-colon": {
        let He2 = be2.getParentNode(), Me2 = He2 && He2.groups.indexOf(se), ze = Me2 && He2.groups[Me2 - 1];
        return [se.value, ze && typeof ze.value == "string" && t(ze.value) === "\\" || F(be2, "url") ? "" : y];
      }
      case "value-comma":
        return [se.value, " "];
      case "value-string":
        return a3(se.raws.quote + se.value + se.raws.quote, Le2);
      case "value-atword":
        return ["@", se.value];
      case "value-unicode-range":
        return se.value;
      case "value-unknown":
        return se.value;
      default:
        throw new Error("Unknown postcss type ".concat(JSON.stringify(se.type)));
    }
  }
  function We2(be2, Le2, qe2) {
    let se = [];
    return be2.each((He2, Me2, ze) => {
      let nt = ze[Me2 - 1];
      if (nt && nt.type === "css-comment" && nt.text.trim() === "prettier-ignore") {
        let tt = He2.getValue();
        se.push(Le2.originalText.slice(Ie2(tt), Fe2(tt)));
      } else
        se.push(qe2());
      Me2 !== ze.length - 1 && (ze[Me2 + 1].type === "css-comment" && !r(Le2.originalText, Ie2(ze[Me2 + 1]), { backwards: true }) && !u(ze[Me2]) || ze[Me2 + 1].type === "css-atrule" && ze[Me2 + 1].name === "else" && ze[Me2].type !== "css-comment" ? se.push(" ") : (se.push(Le2.__isHTMLStyleAttribute ? y : m2), i2(Le2.originalText, He2.getValue(), Fe2) && !u(ze[Me2]) && se.push(m2)));
    }, "nodes"), se;
  }
  var Be = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, Pe2 = /(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g, Se2 = /[A-Za-z]+/g, Qe = /[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g, xe2 = new RegExp(Be.source + "|(".concat(Qe.source, ")?(").concat(Pe2.source, ")(").concat(Se2.source, ")?"), "g");
  function Xe2(be2, Le2) {
    return be2.replace(Be, (qe2) => a3(qe2, Le2));
  }
  function we2(be2, Le2) {
    let qe2 = Le2.singleQuote ? "'" : '"';
    return be2.includes('"') || be2.includes("'") ? be2 : qe2 + be2 + qe2;
  }
  function je2(be2) {
    return be2.replace(xe2, (Le2, qe2, se, He2, Me2) => !se && He2 ? Re2(He2) + g2(Me2 || "") : Le2);
  }
  function Re2(be2) {
    return s2(be2).replace(/\.0(?=$|e)/, "");
  }
  n.exports = { print: Ee, embed: k2, insertPragma: P, massageAstNode: I2 };
} }), cd = Z({ "src/language-css/options.js"(e, n) {
  re();
  var t = Lt$1();
  n.exports = { singleQuote: t.singleQuote };
} }), pd = Z({ "src/language-css/parsers.js"() {
  re();
} }), fd = Z({ "node_modules/linguist-languages/data/CSS.json"(e, n) {
  n.exports = { name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css"], languageId: 50 };
} }), Dd = Z({ "node_modules/linguist-languages/data/PostCSS.json"(e, n) {
  n.exports = { name: "PostCSS", type: "markup", color: "#dc3a0c", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", languageId: 262764437 };
} }), md = Z({ "node_modules/linguist-languages/data/Less.json"(e, n) {
  n.exports = { name: "Less", type: "markup", color: "#1d365d", aliases: ["less-css"], extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198 };
} }), dd = Z({ "node_modules/linguist-languages/data/SCSS.json"(e, n) {
  n.exports = { name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], languageId: 329 };
} }), gd = Z({ "src/language-css/index.js"(e, n) {
  re();
  var t = Tt$1(), s2 = ld(), a3 = cd(), r = pd(), u = [t(fd(), (o) => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"], extensions: [...o.extensions, ".wxss"] })), t(Dd(), () => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"] })), t(md(), () => ({ since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"] })), t(dd(), () => ({ since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"] }))], i2 = { postcss: s2 };
  n.exports = { languages: u, options: a3, printers: i2, parsers: r };
} }), yd = Z({ "src/language-handlebars/loc.js"(e, n) {
  re();
  function t(a3) {
    return a3.loc.start.offset;
  }
  function s2(a3) {
    return a3.loc.end.offset;
  }
  n.exports = { locStart: t, locEnd: s2 };
} }), hd = Z({ "src/language-handlebars/clean.js"(e, n) {
  re();
  function t(s2, a3) {
    if (s2.type === "TextNode") {
      let r = s2.chars.trim();
      if (!r)
        return null;
      a3.chars = r.replace(/[\t\n\f\r ]+/g, " ");
    }
    s2.type === "AttrNode" && s2.name.toLowerCase() === "class" && delete a3.value;
  }
  t.ignoredProperties = /* @__PURE__ */ new Set(["loc", "selfClosing"]), n.exports = t;
} }), vd = Z({ "vendors/html-void-elements.json"(e, n) {
  n.exports = { htmlVoidElements: ["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "isindex", "keygen", "link", "menuitem", "meta", "nextid", "param", "source", "track", "wbr"] };
} }), Cd = Z({ "src/language-handlebars/utils.js"(e, n) {
  re();
  var { htmlVoidElements: t } = vd(), s2 = it$2();
  function a3(S2) {
    let B = S2.getValue(), I2 = S2.getParentNode(0);
    return !!(m2(S2, ["ElementNode"]) && s2(I2.children) === B || m2(S2, ["Block"]) && s2(I2.body) === B);
  }
  function r(S2) {
    return S2.toUpperCase() === S2;
  }
  function u(S2) {
    return y(S2, ["ElementNode"]) && typeof S2.tag == "string" && !S2.tag.startsWith(":") && (r(S2.tag[0]) || S2.tag.includes("."));
  }
  var i2 = new Set(t);
  function o(S2) {
    return i2.has(S2.tag) || u(S2) && S2.children.every((B) => c(B));
  }
  function c(S2) {
    return y(S2, ["TextNode"]) && !/\S/.test(S2.chars);
  }
  function y(S2, B) {
    return S2 && B.includes(S2.type);
  }
  function m2(S2, B) {
    let I2 = S2.getParentNode(0);
    return y(I2, B);
  }
  function d4(S2, B) {
    let I2 = h2(S2);
    return y(I2, B);
  }
  function p(S2, B) {
    let I2 = w2(S2);
    return y(I2, B);
  }
  function f(S2, B) {
    var I2, k2, P, C2;
    let D2 = S2.getValue(), g2 = (I2 = S2.getParentNode(0)) !== null && I2 !== void 0 ? I2 : {}, F = (k2 = (P = (C2 = g2.children) !== null && C2 !== void 0 ? C2 : g2.body) !== null && P !== void 0 ? P : g2.parts) !== null && k2 !== void 0 ? k2 : [], l = F.indexOf(D2);
    return l !== -1 && F[l + B];
  }
  function h2(S2) {
    let B = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    return f(S2, -B);
  }
  function w2(S2) {
    return f(S2, 1);
  }
  function T2(S2) {
    return y(S2, ["MustacheCommentStatement"]) && typeof S2.value == "string" && S2.value.trim() === "prettier-ignore";
  }
  function A2(S2) {
    let B = S2.getValue(), I2 = h2(S2, 2);
    return T2(B) || T2(I2);
  }
  n.exports = { getNextNode: w2, getPreviousNode: h2, hasPrettierIgnore: A2, isLastNodeOfSiblings: a3, isNextNodeOfSomeType: p, isNodeOfSomeType: y, isParentOfSomeType: m2, isPreviousNodeOfSomeType: d4, isVoid: o, isWhitespaceNode: c };
} }), Ed = Z({ "src/language-handlebars/printer-glimmer.js"(e, n) {
  re();
  var { builders: { dedent: t, fill: s2, group: a3, hardline: r, ifBreak: u, indent: i2, join: o, line: c, softline: y }, utils: { getDocParts: m2, replaceTextEndOfLine: d4 } } = Oe(), { getPreferredQuote: p, isNonEmptyArray: f } = Ue$2(), { locStart: h2, locEnd: w2 } = yd(), T2 = hd(), { getNextNode: A2, getPreviousNode: S2, hasPrettierIgnore: B, isLastNodeOfSiblings: I2, isNextNodeOfSomeType: k2, isNodeOfSomeType: P, isParentOfSomeType: C2, isPreviousNodeOfSomeType: D2, isVoid: g2, isWhitespaceNode: F } = Cd(), l = 2;
  function E(K, he2, ye2) {
    let Ce2 = K.getValue();
    if (!Ce2)
      return "";
    if (B(K))
      return he2.originalText.slice(h2(Ce2), w2(Ce2));
    let Ie2 = he2.singleQuote ? "'" : '"';
    switch (Ce2.type) {
      case "Block":
      case "Program":
      case "Template":
        return a3(K.map(ye2, "body"));
      case "ElementNode": {
        let Fe2 = a3(N(K, ye2)), me2 = he2.htmlWhitespaceSensitivity === "ignore" && k2(K, ["ElementNode"]) ? y : "";
        if (g2(Ce2))
          return [Fe2, me2];
        let _ = ["</", Ce2.tag, ">"];
        return Ce2.children.length === 0 ? [Fe2, i2(_), me2] : he2.htmlWhitespaceSensitivity === "ignore" ? [Fe2, i2(x2(K, he2, ye2)), r, i2(_), me2] : [Fe2, i2(a3(x2(K, he2, ye2))), i2(_), me2];
      }
      case "BlockStatement": {
        let Fe2 = K.getParentNode(1);
        return Fe2 && Fe2.inverse && Fe2.inverse.body.length === 1 && Fe2.inverse.body[0] === Ce2 && Fe2.inverse.body[0].path.parts[0] === "if" ? [ee2(K, ye2), ue2(K, ye2, he2), De2(K, ye2, he2)] : [R(K, ye2), a3([ue2(K, ye2, he2), De2(K, ye2, he2), te2(K, ye2, he2)])];
      }
      case "ElementModifierStatement":
        return a3(["{{", pe(K, ye2), "}}"]);
      case "MustacheStatement":
        return a3([L(Ce2), pe(K, ye2), M2(Ce2)]);
      case "SubExpression":
        return a3(["(", ce(K, ye2), y, ")"]);
      case "AttrNode": {
        let Fe2 = Ce2.value.type === "TextNode";
        if (Fe2 && Ce2.value.chars === "" && h2(Ce2.value) === w2(Ce2.value))
          return Ce2.name;
        let _ = Fe2 ? p(Ce2.value.chars, Ie2).quote : Ce2.value.type === "ConcatStatement" ? p(Ce2.value.parts.filter((ne) => ne.type === "TextNode").map((ne) => ne.chars).join(""), Ie2).quote : "", J2 = ye2("value");
        return [Ce2.name, "=", _, Ce2.name === "class" && _ ? a3(i2(J2)) : J2, _];
      }
      case "ConcatStatement":
        return K.map(ye2, "parts");
      case "Hash":
        return o(c, K.map(ye2, "pairs"));
      case "HashPair":
        return [Ce2.key, "=", ye2("value")];
      case "TextNode": {
        let Fe2 = Ce2.chars.replace(/{{/g, "\\{{"), me2 = z(K);
        if (me2) {
          if (me2 === "class") {
            let xe2 = Fe2.trim().split(/\s+/).join(" "), Xe2 = false, we2 = false;
            return C2(K, ["ConcatStatement"]) && (D2(K, ["MustacheStatement"]) && /^\s/.test(Fe2) && (Xe2 = true), k2(K, ["MustacheStatement"]) && /\s$/.test(Fe2) && xe2 !== "" && (we2 = true)), [Xe2 ? c : "", xe2, we2 ? c : ""];
          }
          return d4(Fe2);
        }
        let J2 = /^[\t\n\f\r ]*$/.test(Fe2), ne = !S2(K), Ee = !A2(K);
        if (he2.htmlWhitespaceSensitivity !== "ignore") {
          let xe2 = /^[\t\n\f\r ]*/, Xe2 = /[\t\n\f\r ]*$/, we2 = Ee && C2(K, ["Template"]), je2 = ne && C2(K, ["Template"]);
          if (J2) {
            if (je2 || we2)
              return "";
            let se = [c], He2 = U(Fe2);
            return He2 && (se = Ae2(He2)), I2(K) && (se = se.map((Me2) => t(Me2))), se;
          }
          let [Re2] = Fe2.match(xe2), [be2] = Fe2.match(Xe2), Le2 = [];
          if (Re2) {
            Le2 = [c];
            let se = U(Re2);
            se && (Le2 = Ae2(se)), Fe2 = Fe2.replace(xe2, "");
          }
          let qe2 = [];
          if (be2) {
            if (!we2) {
              qe2 = [c];
              let se = U(be2);
              se && (qe2 = Ae2(se)), I2(K) && (qe2 = qe2.map((He2) => t(He2)));
            }
            Fe2 = Fe2.replace(Xe2, "");
          }
          return [...Le2, s2(ie(Fe2)), ...qe2];
        }
        let We2 = U(Fe2), Be = le2(Fe2), Pe2 = ge2(Fe2);
        if ((ne || Ee) && J2 && C2(K, ["Block", "ElementNode", "Template"]))
          return "";
        J2 && We2 ? (Be = Math.min(We2, l), Pe2 = 0) : (k2(K, ["BlockStatement", "ElementNode"]) && (Pe2 = Math.max(Pe2, 1)), D2(K, ["BlockStatement", "ElementNode"]) && (Be = Math.max(Be, 1)));
        let Se2 = "", Qe = "";
        return Pe2 === 0 && k2(K, ["MustacheStatement"]) && (Qe = " "), Be === 0 && D2(K, ["MustacheStatement"]) && (Se2 = " "), ne && (Be = 0, Se2 = ""), Ee && (Pe2 = 0, Qe = ""), Fe2 = Fe2.replace(/^[\t\n\f\r ]+/g, Se2).replace(/[\t\n\f\r ]+$/, Qe), [...Ae2(Be), s2(ie(Fe2)), ...Ae2(Pe2)];
      }
      case "MustacheCommentStatement": {
        let Fe2 = h2(Ce2), me2 = w2(Ce2), _ = he2.originalText.charAt(Fe2 + 2) === "~", J2 = he2.originalText.charAt(me2 - 3) === "~", ne = Ce2.value.includes("}}") ? "--" : "";
        return ["{{", _ ? "~" : "", "!", ne, Ce2.value, ne, J2 ? "~" : "", "}}"];
      }
      case "PathExpression":
        return Ce2.original;
      case "BooleanLiteral":
        return String(Ce2.value);
      case "CommentStatement":
        return ["<!--", Ce2.value, "-->"];
      case "StringLiteral": {
        if (ke2(K)) {
          let Fe2 = he2.singleQuote ? '"' : "'";
          return Ne2(Ce2.value, Fe2);
        }
        return Ne2(Ce2.value, Ie2);
      }
      case "NumberLiteral":
        return String(Ce2.value);
      case "UndefinedLiteral":
        return "undefined";
      case "NullLiteral":
        return "null";
      default:
        throw new Error("unknown glimmer type: " + JSON.stringify(Ce2.type));
    }
  }
  function v(K, he2) {
    return h2(K) - h2(he2);
  }
  function N(K, he2) {
    let ye2 = K.getValue(), Ce2 = ["attributes", "modifiers", "comments"].filter((Fe2) => f(ye2[Fe2])), Ie2 = Ce2.flatMap((Fe2) => ye2[Fe2]).sort(v);
    for (let Fe2 of Ce2)
      K.each((me2) => {
        let _ = Ie2.indexOf(me2.getValue());
        Ie2.splice(_, 1, [c, he2()]);
      }, Fe2);
    return f(ye2.blockParams) && Ie2.push(c, ve2(ye2)), ["<", ye2.tag, i2(Ie2), b2(ye2)];
  }
  function x2(K, he2, ye2) {
    let Ie2 = K.getValue().children.every((Fe2) => F(Fe2));
    return he2.htmlWhitespaceSensitivity === "ignore" && Ie2 ? "" : K.map((Fe2, me2) => {
      let _ = ye2();
      return me2 === 0 && he2.htmlWhitespaceSensitivity === "ignore" ? [y, _] : _;
    }, "children");
  }
  function b2(K) {
    return g2(K) ? u([y, "/>"], [" />", y]) : u([y, ">"], ">");
  }
  function L(K) {
    let he2 = K.escaped === false ? "{{{" : "{{", ye2 = K.strip && K.strip.open ? "~" : "";
    return [he2, ye2];
  }
  function M2(K) {
    let he2 = K.escaped === false ? "}}}" : "}}";
    return [K.strip && K.strip.close ? "~" : "", he2];
  }
  function j(K) {
    let he2 = L(K), ye2 = K.openStrip.open ? "~" : "";
    return [he2, ye2, "#"];
  }
  function $(K) {
    let he2 = M2(K);
    return [K.openStrip.close ? "~" : "", he2];
  }
  function V(K) {
    let he2 = L(K), ye2 = K.closeStrip.open ? "~" : "";
    return [he2, ye2, "/"];
  }
  function q(K) {
    let he2 = M2(K);
    return [K.closeStrip.close ? "~" : "", he2];
  }
  function Y3(K) {
    let he2 = L(K), ye2 = K.inverseStrip.open ? "~" : "";
    return [he2, ye2];
  }
  function H3(K) {
    let he2 = M2(K);
    return [K.inverseStrip.close ? "~" : "", he2];
  }
  function R(K, he2) {
    let ye2 = K.getValue(), Ce2 = j(ye2), Ie2 = $(ye2), Fe2 = [de2(K, he2)], me2 = ae2(K, he2);
    if (me2 && Fe2.push(c, me2), f(ye2.program.blockParams)) {
      let _ = ve2(ye2.program);
      Fe2.push(c, _);
    }
    return a3([Ce2, i2(Fe2), y, Ie2]);
  }
  function Q(K, he2) {
    return [he2.htmlWhitespaceSensitivity === "ignore" ? r : "", Y3(K), "else", H3(K)];
  }
  function ee2(K, he2) {
    let ye2 = K.getParentNode(1);
    return [Y3(ye2), "else if ", ae2(K, he2), H3(ye2)];
  }
  function te2(K, he2, ye2) {
    let Ce2 = K.getValue();
    return ye2.htmlWhitespaceSensitivity === "ignore" ? [oe2(Ce2) ? y : r, V(Ce2), he2("path"), q(Ce2)] : [V(Ce2), he2("path"), q(Ce2)];
  }
  function oe2(K) {
    return P(K, ["BlockStatement"]) && K.program.body.every((he2) => F(he2));
  }
  function W2(K) {
    return X3(K) && K.inverse.body.length === 1 && P(K.inverse.body[0], ["BlockStatement"]) && K.inverse.body[0].path.parts[0] === "if";
  }
  function X3(K) {
    return P(K, ["BlockStatement"]) && K.inverse;
  }
  function ue2(K, he2, ye2) {
    let Ce2 = K.getValue();
    if (oe2(Ce2))
      return "";
    let Ie2 = he2("program");
    return ye2.htmlWhitespaceSensitivity === "ignore" ? i2([r, Ie2]) : i2(Ie2);
  }
  function De2(K, he2, ye2) {
    let Ce2 = K.getValue(), Ie2 = he2("inverse"), Fe2 = ye2.htmlWhitespaceSensitivity === "ignore" ? [r, Ie2] : Ie2;
    return W2(Ce2) ? Fe2 : X3(Ce2) ? [Q(Ce2, ye2), i2(Fe2)] : "";
  }
  function ie(K) {
    return m2(o(c, G(K)));
  }
  function G(K) {
    return K.split(/[\t\n\f\r ]+/);
  }
  function z(K) {
    for (let he2 = 0; he2 < 2; he2++) {
      let ye2 = K.getParentNode(he2);
      if (ye2 && ye2.type === "AttrNode")
        return ye2.name.toLowerCase();
    }
  }
  function U(K) {
    return K = typeof K == "string" ? K : "", K.split(`
`).length - 1;
  }
  function le2(K) {
    K = typeof K == "string" ? K : "";
    let he2 = (K.match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "";
    return U(he2);
  }
  function ge2(K) {
    K = typeof K == "string" ? K : "";
    let he2 = (K.match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "";
    return U(he2);
  }
  function Ae2() {
    let K = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return Array.from({ length: Math.min(K, l) }).fill(r);
  }
  function Ne2(K, he2) {
    let { quote: ye2, regex: Ce2 } = p(K, he2);
    return [ye2, K.replace(Ce2, "\\".concat(ye2)), ye2];
  }
  function ke2(K) {
    let he2 = 0, ye2 = K.getParentNode(he2);
    for (; ye2 && P(ye2, ["SubExpression"]); )
      he2++, ye2 = K.getParentNode(he2);
    return !!(ye2 && P(K.getParentNode(he2 + 1), ["ConcatStatement"]) && P(K.getParentNode(he2 + 2), ["AttrNode"]));
  }
  function ce(K, he2) {
    let ye2 = de2(K, he2), Ce2 = ae2(K, he2);
    return Ce2 ? i2([ye2, c, a3(Ce2)]) : ye2;
  }
  function pe(K, he2) {
    let ye2 = de2(K, he2), Ce2 = ae2(K, he2);
    return Ce2 ? [i2([ye2, c, Ce2]), y] : ye2;
  }
  function de2(K, he2) {
    return he2("path");
  }
  function ae2(K, he2) {
    let ye2 = K.getValue(), Ce2 = [];
    if (ye2.params.length > 0) {
      let Ie2 = K.map(he2, "params");
      Ce2.push(...Ie2);
    }
    if (ye2.hash && ye2.hash.pairs.length > 0) {
      let Ie2 = he2("hash");
      Ce2.push(Ie2);
    }
    return Ce2.length === 0 ? "" : o(c, Ce2);
  }
  function ve2(K) {
    return ["as |", K.blockParams.join(" "), "|"];
  }
  n.exports = { print: E, massageAstNode: T2 };
} }), Fd$1 = Z({ "src/language-handlebars/parsers.js"() {
  re();
} }), Ad = Z({ "node_modules/linguist-languages/data/Handlebars.json"(e, n) {
  n.exports = { name: "Handlebars", type: "markup", color: "#f7931e", aliases: ["hbs", "htmlbars"], extensions: [".handlebars", ".hbs"], tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155 };
} }), Sd = Z({ "src/language-handlebars/index.js"(e, n) {
  re();
  var t = Tt$1(), s2 = Ed(), a3 = Fd$1(), r = [t(Ad(), () => ({ since: "2.3.0", parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"] }))], u = { glimmer: s2 };
  n.exports = { languages: r, printers: u, parsers: a3 };
} }), xd = Z({ "src/language-graphql/pragma.js"(e, n) {
  re();
  function t(a3) {
    return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(a3);
  }
  function s2(a3) {
    return `# @format

` + a3;
  }
  n.exports = { hasPragma: t, insertPragma: s2 };
} }), bd = Z({ "src/language-graphql/loc.js"(e, n) {
  re();
  function t(a3) {
    return typeof a3.start == "number" ? a3.start : a3.loc && a3.loc.start;
  }
  function s2(a3) {
    return typeof a3.end == "number" ? a3.end : a3.loc && a3.loc.end;
  }
  n.exports = { locStart: t, locEnd: s2 };
} }), Td = Z({ "src/language-graphql/printer-graphql.js"(e, n) {
  re();
  var { builders: { join: t, hardline: s2, line: a3, softline: r, group: u, indent: i2, ifBreak: o } } = Oe(), { isNextLineEmpty: c, isNonEmptyArray: y } = Ue$2(), { insertPragma: m2 } = xd(), { locStart: d4, locEnd: p } = bd();
  function f(k2, P, C2) {
    let D2 = k2.getValue();
    if (!D2)
      return "";
    if (typeof D2 == "string")
      return D2;
    switch (D2.kind) {
      case "Document": {
        let g2 = [];
        return k2.each((F, l, E) => {
          g2.push(C2()), l !== E.length - 1 && (g2.push(s2), c(P.originalText, F.getValue(), p) && g2.push(s2));
        }, "definitions"), [...g2, s2];
      }
      case "OperationDefinition": {
        let g2 = P.originalText[d4(D2)] !== "{", F = Boolean(D2.name);
        return [g2 ? D2.operation : "", g2 && F ? [" ", C2("name")] : "", g2 && !F && y(D2.variableDefinitions) ? " " : "", y(D2.variableDefinitions) ? u(["(", i2([r, t([o("", ", "), r], k2.map(C2, "variableDefinitions"))]), r, ")"]) : "", h2(k2, C2, D2), D2.selectionSet ? !g2 && !F ? "" : " " : "", C2("selectionSet")];
      }
      case "FragmentDefinition":
        return ["fragment ", C2("name"), y(D2.variableDefinitions) ? u(["(", i2([r, t([o("", ", "), r], k2.map(C2, "variableDefinitions"))]), r, ")"]) : "", " on ", C2("typeCondition"), h2(k2, C2, D2), " ", C2("selectionSet")];
      case "SelectionSet":
        return ["{", i2([s2, t(s2, w2(k2, P, C2, "selections"))]), s2, "}"];
      case "Field":
        return u([D2.alias ? [C2("alias"), ": "] : "", C2("name"), D2.arguments.length > 0 ? u(["(", i2([r, t([o("", ", "), r], w2(k2, P, C2, "arguments"))]), r, ")"]) : "", h2(k2, C2, D2), D2.selectionSet ? " " : "", C2("selectionSet")]);
      case "Name":
        return D2.value;
      case "StringValue": {
        if (D2.block) {
          let g2 = D2.value.replace(/"""/g, "\\$&").split(`
`);
          return g2.length === 1 && (g2[0] = g2[0].trim()), g2.every((F) => F === "") && (g2.length = 0), t(s2, ['"""', ...g2, '"""']);
        }
        return ['"', D2.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
      }
      case "IntValue":
      case "FloatValue":
      case "EnumValue":
        return D2.value;
      case "BooleanValue":
        return D2.value ? "true" : "false";
      case "NullValue":
        return "null";
      case "Variable":
        return ["$", C2("name")];
      case "ListValue":
        return u(["[", i2([r, t([o("", ", "), r], k2.map(C2, "values"))]), r, "]"]);
      case "ObjectValue":
        return u(["{", P.bracketSpacing && D2.fields.length > 0 ? " " : "", i2([r, t([o("", ", "), r], k2.map(C2, "fields"))]), r, o("", P.bracketSpacing && D2.fields.length > 0 ? " " : ""), "}"]);
      case "ObjectField":
      case "Argument":
        return [C2("name"), ": ", C2("value")];
      case "Directive":
        return ["@", C2("name"), D2.arguments.length > 0 ? u(["(", i2([r, t([o("", ", "), r], w2(k2, P, C2, "arguments"))]), r, ")"]) : ""];
      case "NamedType":
        return C2("name");
      case "VariableDefinition":
        return [C2("variable"), ": ", C2("type"), D2.defaultValue ? [" = ", C2("defaultValue")] : "", h2(k2, C2, D2)];
      case "ObjectTypeExtension":
      case "ObjectTypeDefinition":
        return [C2("description"), D2.description ? s2 : "", D2.kind === "ObjectTypeExtension" ? "extend " : "", "type ", C2("name"), D2.interfaces.length > 0 ? [" implements ", ...S2(k2, P, C2)] : "", h2(k2, C2, D2), D2.fields.length > 0 ? [" {", i2([s2, t(s2, w2(k2, P, C2, "fields"))]), s2, "}"] : ""];
      case "FieldDefinition":
        return [C2("description"), D2.description ? s2 : "", C2("name"), D2.arguments.length > 0 ? u(["(", i2([r, t([o("", ", "), r], w2(k2, P, C2, "arguments"))]), r, ")"]) : "", ": ", C2("type"), h2(k2, C2, D2)];
      case "DirectiveDefinition":
        return [C2("description"), D2.description ? s2 : "", "directive ", "@", C2("name"), D2.arguments.length > 0 ? u(["(", i2([r, t([o("", ", "), r], w2(k2, P, C2, "arguments"))]), r, ")"]) : "", D2.repeatable ? " repeatable" : "", " on ", t(" | ", k2.map(C2, "locations"))];
      case "EnumTypeExtension":
      case "EnumTypeDefinition":
        return [C2("description"), D2.description ? s2 : "", D2.kind === "EnumTypeExtension" ? "extend " : "", "enum ", C2("name"), h2(k2, C2, D2), D2.values.length > 0 ? [" {", i2([s2, t(s2, w2(k2, P, C2, "values"))]), s2, "}"] : ""];
      case "EnumValueDefinition":
        return [C2("description"), D2.description ? s2 : "", C2("name"), h2(k2, C2, D2)];
      case "InputValueDefinition":
        return [C2("description"), D2.description ? D2.description.block ? s2 : a3 : "", C2("name"), ": ", C2("type"), D2.defaultValue ? [" = ", C2("defaultValue")] : "", h2(k2, C2, D2)];
      case "InputObjectTypeExtension":
      case "InputObjectTypeDefinition":
        return [C2("description"), D2.description ? s2 : "", D2.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", C2("name"), h2(k2, C2, D2), D2.fields.length > 0 ? [" {", i2([s2, t(s2, w2(k2, P, C2, "fields"))]), s2, "}"] : ""];
      case "SchemaExtension":
        return ["extend schema", h2(k2, C2, D2), ...D2.operationTypes.length > 0 ? [" {", i2([s2, t(s2, w2(k2, P, C2, "operationTypes"))]), s2, "}"] : []];
      case "SchemaDefinition":
        return [C2("description"), D2.description ? s2 : "", "schema", h2(k2, C2, D2), " {", D2.operationTypes.length > 0 ? i2([s2, t(s2, w2(k2, P, C2, "operationTypes"))]) : "", s2, "}"];
      case "OperationTypeDefinition":
        return [C2("operation"), ": ", C2("type")];
      case "InterfaceTypeExtension":
      case "InterfaceTypeDefinition":
        return [C2("description"), D2.description ? s2 : "", D2.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", C2("name"), D2.interfaces.length > 0 ? [" implements ", ...S2(k2, P, C2)] : "", h2(k2, C2, D2), D2.fields.length > 0 ? [" {", i2([s2, t(s2, w2(k2, P, C2, "fields"))]), s2, "}"] : ""];
      case "FragmentSpread":
        return ["...", C2("name"), h2(k2, C2, D2)];
      case "InlineFragment":
        return ["...", D2.typeCondition ? [" on ", C2("typeCondition")] : "", h2(k2, C2, D2), " ", C2("selectionSet")];
      case "UnionTypeExtension":
      case "UnionTypeDefinition":
        return u([C2("description"), D2.description ? s2 : "", u([D2.kind === "UnionTypeExtension" ? "extend " : "", "union ", C2("name"), h2(k2, C2, D2), D2.types.length > 0 ? [" =", o("", " "), i2([o([a3, "  "]), t([a3, "| "], k2.map(C2, "types"))])] : ""])]);
      case "ScalarTypeExtension":
      case "ScalarTypeDefinition":
        return [C2("description"), D2.description ? s2 : "", D2.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", C2("name"), h2(k2, C2, D2)];
      case "NonNullType":
        return [C2("type"), "!"];
      case "ListType":
        return ["[", C2("type"), "]"];
      default:
        throw new Error("unknown graphql type: " + JSON.stringify(D2.kind));
    }
  }
  function h2(k2, P, C2) {
    if (C2.directives.length === 0)
      return "";
    let D2 = t(a3, k2.map(P, "directives"));
    return C2.kind === "FragmentDefinition" || C2.kind === "OperationDefinition" ? u([a3, D2]) : [" ", u(i2([r, D2]))];
  }
  function w2(k2, P, C2, D2) {
    return k2.map((g2, F, l) => {
      let E = C2();
      return F < l.length - 1 && c(P.originalText, g2.getValue(), p) ? [E, s2] : E;
    }, D2);
  }
  function T2(k2) {
    return k2.kind && k2.kind !== "Comment";
  }
  function A2(k2) {
    let P = k2.getValue();
    if (P.kind === "Comment")
      return "#" + P.value.trimEnd();
    throw new Error("Not a comment: " + JSON.stringify(P));
  }
  function S2(k2, P, C2) {
    let D2 = k2.getNode(), g2 = [], { interfaces: F } = D2, l = k2.map((E) => C2(E), "interfaces");
    for (let E = 0; E < F.length; E++) {
      let v = F[E];
      g2.push(l[E]);
      let N = F[E + 1];
      if (N) {
        let x2 = P.originalText.slice(v.loc.end, N.loc.start), b2 = x2.includes("#"), L = x2.replace(/#.*/g, "").trim();
        g2.push(L === "," ? "," : " &", b2 ? a3 : " ");
      }
    }
    return g2;
  }
  function B(k2, P) {
    k2.kind === "StringValue" && k2.block && !k2.value.includes(`
`) && (P.value = P.value.trim());
  }
  B.ignoredProperties = /* @__PURE__ */ new Set(["loc", "comments"]);
  function I2(k2) {
    var P;
    let C2 = k2.getValue();
    return C2 == null || (P = C2.comments) === null || P === void 0 ? void 0 : P.some((D2) => D2.value.trim() === "prettier-ignore");
  }
  n.exports = { print: f, massageAstNode: B, hasPrettierIgnore: I2, insertPragma: m2, printComment: A2, canAttachComment: T2 };
} }), Bd = Z({ "src/language-graphql/options.js"(e, n) {
  re();
  var t = Lt$1();
  n.exports = { bracketSpacing: t.bracketSpacing };
} }), Nd = Z({ "src/language-graphql/parsers.js"() {
  re();
} }), wd = Z({ "node_modules/linguist-languages/data/GraphQL.json"(e, n) {
  n.exports = { name: "GraphQL", type: "data", color: "#e10098", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", aceMode: "text", languageId: 139 };
} }), _d = Z({ "src/language-graphql/index.js"(e, n) {
  re();
  var t = Tt$1(), s2 = Td(), a3 = Bd(), r = Nd(), u = [t(wd(), () => ({ since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"] }))], i2 = { graphql: s2 };
  n.exports = { languages: u, options: a3, printers: i2, parsers: r };
} }), oo$2 = Z({ "src/language-markdown/loc.js"(e, n) {
  re();
  function t(a3) {
    return a3.position.start.offset;
  }
  function s2(a3) {
    return a3.position.end.offset;
  }
  n.exports = { locStart: t, locEnd: s2 };
} }), Pd = Z({ "src/language-markdown/constants.evaluate.js"(e, n) {
  n.exports = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" };
} }), Un$1 = Z({ "src/language-markdown/utils.js"(e, n) {
  re();
  var { getLast: t } = Ue$2(), { locStart: s2, locEnd: a3 } = oo$2(), { cjkPattern: r, kPattern: u, punctuationPattern: i2 } = Pd(), o = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], c = [...o, "tableCell", "paragraph", "heading"], y = new RegExp(u), m2 = new RegExp(i2);
  function d4(A2, S2) {
    let B = "non-cjk", I2 = "cj-letter", k2 = "k-letter", P = "cjk-punctuation", C2 = [], D2 = (S2.proseWrap === "preserve" ? A2 : A2.replace(new RegExp("(".concat(r, `)
(`).concat(r, ")"), "g"), "$1$2")).split(/([\t\n ]+)/);
    for (let [F, l] of D2.entries()) {
      if (F % 2 === 1) {
        C2.push({ type: "whitespace", value: /\n/.test(l) ? `
` : " " });
        continue;
      }
      if ((F === 0 || F === D2.length - 1) && l === "")
        continue;
      let E = l.split(new RegExp("(".concat(r, ")")));
      for (let [v, N] of E.entries())
        if (!((v === 0 || v === E.length - 1) && N === "")) {
          if (v % 2 === 0) {
            N !== "" && g2({ type: "word", value: N, kind: B, hasLeadingPunctuation: m2.test(N[0]), hasTrailingPunctuation: m2.test(t(N)) });
            continue;
          }
          g2(m2.test(N) ? { type: "word", value: N, kind: P, hasLeadingPunctuation: true, hasTrailingPunctuation: true } : { type: "word", value: N, kind: y.test(N) ? k2 : I2, hasLeadingPunctuation: false, hasTrailingPunctuation: false });
        }
    }
    return C2;
    function g2(F) {
      let l = t(C2);
      l && l.type === "word" && (l.kind === B && F.kind === I2 && !l.hasTrailingPunctuation || l.kind === I2 && F.kind === B && !F.hasLeadingPunctuation ? C2.push({ type: "whitespace", value: " " }) : !E(B, P) && ![l.value, F.value].some((v) => /\u3000/.test(v)) && C2.push({ type: "whitespace", value: "" })), C2.push(F);
      function E(v, N) {
        return l.kind === v && F.kind === N || l.kind === N && F.kind === v;
      }
    }
  }
  function p(A2, S2) {
    let [, B, I2, k2] = S2.slice(A2.position.start.offset, A2.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
    return { numberText: B, marker: I2, leadingSpaces: k2 };
  }
  function f(A2, S2) {
    if (!A2.ordered || A2.children.length < 2)
      return false;
    let B = Number(p(A2.children[0], S2.originalText).numberText), I2 = Number(p(A2.children[1], S2.originalText).numberText);
    if (B === 0 && A2.children.length > 2) {
      let k2 = Number(p(A2.children[2], S2.originalText).numberText);
      return I2 === 1 && k2 === 1;
    }
    return I2 === 1;
  }
  function h2(A2, S2) {
    let { value: B } = A2;
    return A2.position.end.offset === S2.length && B.endsWith(`
`) && S2.endsWith(`
`) ? B.slice(0, -1) : B;
  }
  function w2(A2, S2) {
    return function B(I2, k2, P) {
      let C2 = Object.assign({}, S2(I2, k2, P));
      return C2.children && (C2.children = C2.children.map((D2, g2) => B(D2, g2, [C2, ...P]))), C2;
    }(A2, null, []);
  }
  function T2(A2) {
    if ((A2 == null ? void 0 : A2.type) !== "link" || A2.children.length !== 1)
      return false;
    let [S2] = A2.children;
    return s2(A2) === s2(S2) && a3(A2) === a3(S2);
  }
  n.exports = { mapAst: w2, splitText: d4, punctuationPattern: i2, getFencedCodeBlockValue: h2, getOrderedListItemInfo: p, hasGitDiffFriendlyOrderedList: f, INLINE_NODE_TYPES: o, INLINE_NODE_WRAPPER_TYPES: c, isAutolink: T2 };
} }), kd = Z({ "src/language-markdown/embed.js"(e, n) {
  re();
  var { inferParserByLanguage: t, getMaxContinuousCount: s2 } = Ue$2(), { builders: { hardline: a3, markAsRoot: r }, utils: { replaceEndOfLine: u } } = Oe(), i2 = Jn$2(), { getFencedCodeBlockValue: o } = Un$1();
  function c(y, m2, d4, p) {
    let f = y.getValue();
    if (f.type === "code" && f.lang !== null) {
      let h2 = t(f.lang, p);
      if (h2) {
        let w2 = p.__inJsTemplate ? "~" : "`", T2 = w2.repeat(Math.max(3, s2(f.value, w2) + 1)), A2 = { parser: h2 };
        f.lang === "tsx" && (A2.filepath = "dummy.tsx");
        let S2 = d4(o(f, p.originalText), A2, { stripTrailingHardline: true });
        return r([T2, f.lang, f.meta ? " " + f.meta : "", a3, u(S2), a3, T2]);
      }
    }
    switch (f.type) {
      case "front-matter":
        return i2(f, d4);
      case "importExport":
        return [d4(f.value, { parser: "babel" }, { stripTrailingHardline: true }), a3];
      case "jsx":
        return d4("<$>".concat(f.value, "</$>"), { parser: "__js_expression", rootMarker: "mdx" }, { stripTrailingHardline: true });
    }
    return null;
  }
  n.exports = c;
} }), lo$2 = Z({ "src/language-markdown/pragma.js"(e, n) {
  re();
  var t = ao$2(), s2 = ["format", "prettier"];
  function a3(r) {
    let u = "@(".concat(s2.join("|"), ")"), i2 = new RegExp(["<!--\\s*".concat(u, "\\s*-->"), "{\\s*\\/\\*\\s*".concat(u, "\\s*\\*\\/\\s*}"), `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*`.concat(u, `[^\\S
]*($|
)[\\s\\S]*
.*-->`)].join("|"), "m"), o = r.match(i2);
    return (o == null ? void 0 : o.index) === 0;
  }
  n.exports = { startWithPragma: a3, hasPragma: (r) => a3(t(r).content.trimStart()), insertPragma: (r) => {
    let u = t(r), i2 = "<!-- @".concat(s2[0], " -->");
    return u.frontMatter ? "".concat(u.frontMatter.raw, `

`).concat(i2, `

`).concat(u.content) : "".concat(i2, `

`).concat(u.content);
  } };
} }), Id = Z({ "src/language-markdown/print-preprocess.js"(e, n) {
  re();
  var t = it$2(), { getOrderedListItemInfo: s2, mapAst: a3, splitText: r } = Un$1(), u = /^.$/su;
  function i2(T2, A2) {
    return T2 = y(T2, A2), T2 = p(T2), T2 = c(T2), T2 = h2(T2, A2), T2 = w2(T2, A2), T2 = f(T2, A2), T2 = o(T2), T2 = m2(T2), T2;
  }
  function o(T2) {
    return a3(T2, (A2) => A2.type !== "import" && A2.type !== "export" ? A2 : Object.assign(Object.assign({}, A2), {}, { type: "importExport" }));
  }
  function c(T2) {
    return a3(T2, (A2) => A2.type !== "inlineCode" ? A2 : Object.assign(Object.assign({}, A2), {}, { value: A2.value.replace(/\s+/g, " ") }));
  }
  function y(T2, A2) {
    return a3(T2, (S2) => S2.type !== "text" || S2.value === "*" || S2.value === "_" || !u.test(S2.value) || S2.position.end.offset - S2.position.start.offset === S2.value.length ? S2 : Object.assign(Object.assign({}, S2), {}, { value: A2.originalText.slice(S2.position.start.offset, S2.position.end.offset) }));
  }
  function m2(T2) {
    return d4(T2, (A2, S2) => A2.type === "importExport" && S2.type === "importExport", (A2, S2) => ({ type: "importExport", value: A2.value + `

` + S2.value, position: { start: A2.position.start, end: S2.position.end } }));
  }
  function d4(T2, A2, S2) {
    return a3(T2, (B) => {
      if (!B.children)
        return B;
      let I2 = B.children.reduce((k2, P) => {
        let C2 = t(k2);
        return C2 && A2(C2, P) ? k2.splice(-1, 1, S2(C2, P)) : k2.push(P), k2;
      }, []);
      return Object.assign(Object.assign({}, B), {}, { children: I2 });
    });
  }
  function p(T2) {
    return d4(T2, (A2, S2) => A2.type === "text" && S2.type === "text", (A2, S2) => ({ type: "text", value: A2.value + S2.value, position: { start: A2.position.start, end: S2.position.end } }));
  }
  function f(T2, A2) {
    return a3(T2, (S2, B, I2) => {
      let [k2] = I2;
      if (S2.type !== "text")
        return S2;
      let { value: P } = S2;
      return k2.type === "paragraph" && (B === 0 && (P = P.trimStart()), B === k2.children.length - 1 && (P = P.trimEnd())), { type: "sentence", position: S2.position, children: r(P, A2) };
    });
  }
  function h2(T2, A2) {
    return a3(T2, (S2, B, I2) => {
      if (S2.type === "code") {
        let k2 = /^\n?(?: {4,}|\t)/.test(A2.originalText.slice(S2.position.start.offset, S2.position.end.offset));
        if (S2.isIndented = k2, k2)
          for (let P = 0; P < I2.length; P++) {
            let C2 = I2[P];
            if (C2.hasIndentedCodeblock)
              break;
            C2.type === "list" && (C2.hasIndentedCodeblock = true);
          }
      }
      return S2;
    });
  }
  function w2(T2, A2) {
    return a3(T2, (I2, k2, P) => {
      if (I2.type === "list" && I2.children.length > 0) {
        for (let C2 = 0; C2 < P.length; C2++) {
          let D2 = P[C2];
          if (D2.type === "list" && !D2.isAligned)
            return I2.isAligned = false, I2;
        }
        I2.isAligned = B(I2);
      }
      return I2;
    });
    function S2(I2) {
      return I2.children.length === 0 ? -1 : I2.children[0].position.start.column - 1;
    }
    function B(I2) {
      if (!I2.ordered)
        return true;
      let [k2, P] = I2.children;
      if (s2(k2, A2.originalText).leadingSpaces.length > 1)
        return true;
      let D2 = S2(k2);
      if (D2 === -1)
        return false;
      if (I2.children.length === 1)
        return D2 % A2.tabWidth === 0;
      let g2 = S2(P);
      return D2 !== g2 ? false : D2 % A2.tabWidth === 0 ? true : s2(P, A2.originalText).leadingSpaces.length > 1;
    }
  }
  n.exports = i2;
} }), Ld = Z({ "src/language-markdown/clean.js"(e, n) {
  re();
  var { isFrontMatterNode: t } = Ue$2(), { startWithPragma: s2 } = lo$2(), a3 = /* @__PURE__ */ new Set(["position", "raw"]);
  function r(u, i2, o) {
    if ((u.type === "front-matter" || u.type === "code" || u.type === "yaml" || u.type === "import" || u.type === "export" || u.type === "jsx") && delete i2.value, u.type === "list" && delete i2.isAligned, (u.type === "list" || u.type === "listItem") && (delete i2.spread, delete i2.loose), u.type === "text" || (u.type === "inlineCode" && (i2.value = u.value.replace(/[\t\n ]+/g, " ")), u.type === "wikiLink" && (i2.value = u.value.trim().replace(/[\t\n]+/g, " ")), (u.type === "definition" || u.type === "linkReference") && (i2.label = u.label.trim().replace(/[\t\n ]+/g, " ").toLowerCase()), (u.type === "definition" || u.type === "link" || u.type === "image") && u.title && (i2.title = u.title.replace(/\\(["')])/g, "$1")), o && o.type === "root" && o.children.length > 0 && (o.children[0] === u || t(o.children[0]) && o.children[1] === u) && u.type === "html" && s2(u.value)))
      return null;
  }
  r.ignoredProperties = a3, n.exports = r;
} }), jd = Z({ "src/language-markdown/printer-markdown.js"(e, n) {
  re();
  var { getLast: t, getMinNotPresentContinuousCount: s2, getMaxContinuousCount: a3, getStringWidth: r, isNonEmptyArray: u } = Ue$2(), { builders: { breakParent: i2, join: o, line: c, literalline: y, markAsRoot: m2, hardline: d4, softline: p, ifBreak: f, fill: h2, align: w2, indent: T2, group: A2, hardlineWithoutBreakParent: S2 }, utils: { normalizeDoc: B, replaceTextEndOfLine: I2 }, printer: { printDocToString: k2 } } = Oe(), P = kd(), { insertPragma: C2 } = lo$2(), { locStart: D2, locEnd: g2 } = oo$2(), F = Id(), l = Ld(), { getFencedCodeBlockValue: E, hasGitDiffFriendlyOrderedList: v, splitText: N, punctuationPattern: x2, INLINE_NODE_TYPES: b2, INLINE_NODE_WRAPPER_TYPES: L, isAutolink: M2 } = Un$1(), j = /* @__PURE__ */ new Set(["importExport"]), $ = ["heading", "tableCell", "link", "wikiLink"], V = /* @__PURE__ */ new Set(["listItem", "definition", "footnoteDefinition"]);
  function q(ce, pe, de2) {
    let ae2 = ce.getValue();
    if (le2(ce))
      return N(pe.originalText.slice(ae2.position.start.offset, ae2.position.end.offset), pe).map((ve2) => ve2.type === "word" ? ve2.value : ve2.value === "" ? "" : oe2(ce, ve2.value, pe));
    switch (ae2.type) {
      case "front-matter":
        return pe.originalText.slice(ae2.position.start.offset, ae2.position.end.offset);
      case "root":
        return ae2.children.length === 0 ? "" : [B(X3(ce, pe, de2)), j.has(De2(ae2).type) ? "" : d4];
      case "paragraph":
        return ue2(ce, pe, de2, { postprocessor: h2 });
      case "sentence":
        return ue2(ce, pe, de2);
      case "word": {
        let ve2 = ae2.value.replace(/\*/g, "\\$&").replace(new RegExp(["(^|".concat(x2, ")(_+)"), "(_+)(".concat(x2, "|$)")].join("|"), "g"), (ye2, Ce2, Ie2, Fe2, me2) => (Ie2 ? "".concat(Ce2).concat(Ie2) : "".concat(Fe2).concat(me2)).replace(/_/g, "\\_")), K = (ye2, Ce2, Ie2) => ye2.type === "sentence" && Ie2 === 0, he2 = (ye2, Ce2, Ie2) => M2(ye2.children[Ie2 - 1]);
        return ve2 !== ae2.value && (ce.match(void 0, K, he2) || ce.match(void 0, K, (ye2, Ce2, Ie2) => ye2.type === "emphasis" && Ie2 === 0, he2)) && (ve2 = ve2.replace(/^(\\?[*_])+/, (ye2) => ye2.replace(/\\/g, ""))), ve2;
      }
      case "whitespace": {
        let ve2 = ce.getParentNode(), K = ve2.children.indexOf(ae2), he2 = ve2.children[K + 1], ye2 = he2 && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(he2.value) ? "never" : pe.proseWrap;
        return oe2(ce, ae2.value, { proseWrap: ye2 });
      }
      case "emphasis": {
        let ve2;
        if (M2(ae2.children[0]))
          ve2 = pe.originalText[ae2.position.start.offset];
        else {
          let K = ce.getParentNode(), he2 = K.children.indexOf(ae2), ye2 = K.children[he2 - 1], Ce2 = K.children[he2 + 1];
          ve2 = ye2 && ye2.type === "sentence" && ye2.children.length > 0 && t(ye2.children).type === "word" && !t(ye2.children).hasTrailingPunctuation || Ce2 && Ce2.type === "sentence" && Ce2.children.length > 0 && Ce2.children[0].type === "word" && !Ce2.children[0].hasLeadingPunctuation || te2(ce, "emphasis") ? "*" : "_";
        }
        return [ve2, ue2(ce, pe, de2), ve2];
      }
      case "strong":
        return ["**", ue2(ce, pe, de2), "**"];
      case "delete":
        return ["~~", ue2(ce, pe, de2), "~~"];
      case "inlineCode": {
        let ve2 = s2(ae2.value, "`"), K = "`".repeat(ve2 || 1), he2 = ve2 && !/^\s/.test(ae2.value) ? " " : "";
        return [K, he2, ae2.value, he2, K];
      }
      case "wikiLink": {
        let ve2 = "";
        return pe.proseWrap === "preserve" ? ve2 = ae2.value : ve2 = ae2.value.replace(/[\t\n]+/g, " "), ["[[", ve2, "]]"];
      }
      case "link":
        switch (pe.originalText[ae2.position.start.offset]) {
          case "<": {
            let ve2 = "mailto:", K = ae2.url.startsWith(ve2) && pe.originalText.slice(ae2.position.start.offset + 1, ae2.position.start.offset + 1 + ve2.length) !== ve2 ? ae2.url.slice(ve2.length) : ae2.url;
            return ["<", K, ">"];
          }
          case "[":
            return ["[", ue2(ce, pe, de2), "](", ge2(ae2.url, ")"), Ae2(ae2.title, pe), ")"];
          default:
            return pe.originalText.slice(ae2.position.start.offset, ae2.position.end.offset);
        }
      case "image":
        return ["![", ae2.alt || "", "](", ge2(ae2.url, ")"), Ae2(ae2.title, pe), ")"];
      case "blockquote":
        return ["> ", w2("> ", ue2(ce, pe, de2))];
      case "heading":
        return ["#".repeat(ae2.depth) + " ", ue2(ce, pe, de2)];
      case "code": {
        if (ae2.isIndented) {
          let he2 = " ".repeat(4);
          return w2(he2, [he2, ...I2(ae2.value, d4)]);
        }
        let ve2 = pe.__inJsTemplate ? "~" : "`", K = ve2.repeat(Math.max(3, a3(ae2.value, ve2) + 1));
        return [K, ae2.lang || "", ae2.meta ? " " + ae2.meta : "", d4, ...I2(E(ae2, pe.originalText), d4), d4, K];
      }
      case "html": {
        let ve2 = ce.getParentNode(), K = ve2.type === "root" && t(ve2.children) === ae2 ? ae2.value.trimEnd() : ae2.value, he2 = /^<!--.*-->$/s.test(K);
        return I2(K, he2 ? d4 : m2(y));
      }
      case "list": {
        let ve2 = R(ae2, ce.getParentNode()), K = v(ae2, pe);
        return ue2(ce, pe, de2, { processor: (he2, ye2) => {
          let Ce2 = Fe2(), Ie2 = he2.getValue();
          if (Ie2.children.length === 2 && Ie2.children[1].type === "html" && Ie2.children[0].position.start.column !== Ie2.children[1].position.start.column)
            return [Ce2, Y3(he2, pe, de2, Ce2)];
          return [Ce2, w2(" ".repeat(Ce2.length), Y3(he2, pe, de2, Ce2))];
          function Fe2() {
            let me2 = ae2.ordered ? (ye2 === 0 ? ae2.start : K ? 1 : ae2.start + ye2) + (ve2 % 2 === 0 ? ". " : ") ") : ve2 % 2 === 0 ? "- " : "* ";
            return ae2.isAligned || ae2.hasIndentedCodeblock ? H3(me2, pe) : me2;
          }
        } });
      }
      case "thematicBreak": {
        let ve2 = ee2(ce, "list");
        return ve2 === -1 ? "---" : R(ce.getParentNode(ve2), ce.getParentNode(ve2 + 1)) % 2 === 0 ? "***" : "---";
      }
      case "linkReference":
        return ["[", ue2(ce, pe, de2), "]", ae2.referenceType === "full" ? ["[", ae2.identifier, "]"] : ae2.referenceType === "collapsed" ? "[]" : ""];
      case "imageReference":
        switch (ae2.referenceType) {
          case "full":
            return ["![", ae2.alt || "", "][", ae2.identifier, "]"];
          default:
            return ["![", ae2.alt, "]", ae2.referenceType === "collapsed" ? "[]" : ""];
        }
      case "definition": {
        let ve2 = pe.proseWrap === "always" ? c : " ";
        return A2(["[", ae2.identifier, "]:", T2([ve2, ge2(ae2.url), ae2.title === null ? "" : [ve2, Ae2(ae2.title, pe, false)]])]);
      }
      case "footnote":
        return ["[^", ue2(ce, pe, de2), "]"];
      case "footnoteReference":
        return ["[^", ae2.identifier, "]"];
      case "footnoteDefinition": {
        let ve2 = ce.getParentNode().children[ce.getName() + 1], K = ae2.children.length === 1 && ae2.children[0].type === "paragraph" && (pe.proseWrap === "never" || pe.proseWrap === "preserve" && ae2.children[0].position.start.line === ae2.children[0].position.end.line);
        return ["[^", ae2.identifier, "]: ", K ? ue2(ce, pe, de2) : A2([w2(" ".repeat(4), ue2(ce, pe, de2, { processor: (he2, ye2) => ye2 === 0 ? A2([p, de2()]) : de2() })), ve2 && ve2.type === "footnoteDefinition" ? p : ""])];
      }
      case "table":
        return W2(ce, pe, de2);
      case "tableCell":
        return ue2(ce, pe, de2);
      case "break":
        return /\s/.test(pe.originalText[ae2.position.start.offset]) ? ["  ", m2(y)] : ["\\", d4];
      case "liquidNode":
        return I2(ae2.value, d4);
      case "importExport":
        return [ae2.value, d4];
      case "esComment":
        return ["{/* ", ae2.value, " */}"];
      case "jsx":
        return ae2.value;
      case "math":
        return ["$$", d4, ae2.value ? [...I2(ae2.value, d4), d4] : "", "$$"];
      case "inlineMath":
        return pe.originalText.slice(D2(ae2), g2(ae2));
      case "tableRow":
      case "listItem":
      default:
        throw new Error("Unknown markdown type ".concat(JSON.stringify(ae2.type)));
    }
  }
  function Y3(ce, pe, de2, ae2) {
    let ve2 = ce.getValue(), K = ve2.checked === null ? "" : ve2.checked ? "[x] " : "[ ] ";
    return [K, ue2(ce, pe, de2, { processor: (he2, ye2) => {
      if (ye2 === 0 && he2.getValue().type !== "list")
        return w2(" ".repeat(K.length), de2());
      let Ce2 = " ".repeat(Ne2(pe.tabWidth - ae2.length, 0, 3));
      return [Ce2, w2(Ce2, de2())];
    } })];
  }
  function H3(ce, pe) {
    let de2 = ae2();
    return ce + " ".repeat(de2 >= 4 ? 0 : de2);
    function ae2() {
      let ve2 = ce.length % pe.tabWidth;
      return ve2 === 0 ? 0 : pe.tabWidth - ve2;
    }
  }
  function R(ce, pe) {
    return Q(ce, pe, (de2) => de2.ordered === ce.ordered);
  }
  function Q(ce, pe, de2) {
    let ae2 = -1;
    for (let ve2 of pe.children)
      if (ve2.type === ce.type && de2(ve2) ? ae2++ : ae2 = -1, ve2 === ce)
        return ae2;
  }
  function ee2(ce, pe) {
    let de2 = Array.isArray(pe) ? pe : [pe], ae2 = -1, ve2;
    for (; ve2 = ce.getParentNode(++ae2); )
      if (de2.includes(ve2.type))
        return ae2;
    return -1;
  }
  function te2(ce, pe) {
    let de2 = ee2(ce, pe);
    return de2 === -1 ? null : ce.getParentNode(de2);
  }
  function oe2(ce, pe, de2) {
    if (de2.proseWrap === "preserve" && pe === `
`)
      return d4;
    let ae2 = de2.proseWrap === "always" && !te2(ce, $);
    return pe !== "" ? ae2 ? c : " " : ae2 ? p : "";
  }
  function W2(ce, pe, de2) {
    let ae2 = ce.getValue(), ve2 = [], K = ce.map((me2) => me2.map((_, J2) => {
      let ne = k2(de2(), pe).formatted, Ee = r(ne);
      return ve2[J2] = Math.max(ve2[J2] || 3, Ee), { text: ne, width: Ee };
    }, "children"), "children"), he2 = Ce2(false);
    if (pe.proseWrap !== "never")
      return [i2, he2];
    let ye2 = Ce2(true);
    return [i2, A2(f(ye2, he2))];
    function Ce2(me2) {
      let _ = [Fe2(K[0], me2), Ie2(me2)];
      return K.length > 1 && _.push(o(S2, K.slice(1).map((J2) => Fe2(J2, me2)))), o(S2, _);
    }
    function Ie2(me2) {
      let _ = ve2.map((J2, ne) => {
        let Ee = ae2.align[ne], We2 = Ee === "center" || Ee === "left" ? ":" : "-", Be = Ee === "center" || Ee === "right" ? ":" : "-", Pe2 = me2 ? "-" : "-".repeat(J2 - 2);
        return "".concat(We2).concat(Pe2).concat(Be);
      });
      return "| ".concat(_.join(" | "), " |");
    }
    function Fe2(me2, _) {
      let J2 = me2.map((ne, Ee) => {
        let { text: We2, width: Be } = ne;
        if (_)
          return We2;
        let Pe2 = ve2[Ee] - Be, Se2 = ae2.align[Ee], Qe = 0;
        Se2 === "right" ? Qe = Pe2 : Se2 === "center" && (Qe = Math.floor(Pe2 / 2));
        let xe2 = Pe2 - Qe;
        return "".concat(" ".repeat(Qe)).concat(We2).concat(" ".repeat(xe2));
      });
      return "| ".concat(J2.join(" | "), " |");
    }
  }
  function X3(ce, pe, de2) {
    let ae2 = [], ve2 = null, { children: K } = ce.getValue();
    for (let [he2, ye2] of K.entries())
      switch (ie(ye2)) {
        case "start":
          ve2 === null && (ve2 = { index: he2, offset: ye2.position.end.offset });
          break;
        case "end":
          ve2 !== null && (ae2.push({ start: ve2, end: { index: he2, offset: ye2.position.start.offset } }), ve2 = null);
          break;
      }
    return ue2(ce, pe, de2, { processor: (he2, ye2) => {
      if (ae2.length > 0) {
        let Ce2 = ae2[0];
        if (ye2 === Ce2.start.index)
          return [K[Ce2.start.index].value, pe.originalText.slice(Ce2.start.offset, Ce2.end.offset), K[Ce2.end.index].value];
        if (Ce2.start.index < ye2 && ye2 < Ce2.end.index)
          return false;
        if (ye2 === Ce2.end.index)
          return ae2.shift(), false;
      }
      return de2();
    } });
  }
  function ue2(ce, pe, de2) {
    let ae2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, { postprocessor: ve2 } = ae2, K = ae2.processor || (() => de2()), he2 = ce.getValue(), ye2 = [], Ce2;
    return ce.each((Ie2, Fe2) => {
      let me2 = Ie2.getValue(), _ = K(Ie2, Fe2);
      if (_ !== false) {
        let J2 = { parts: ye2, prevNode: Ce2, parentNode: he2, options: pe };
        G(me2, J2) && (ye2.push(d4), Ce2 && j.has(Ce2.type) || (z(me2, J2) || U(me2, J2)) && ye2.push(d4), U(me2, J2) && ye2.push(d4)), ye2.push(_), Ce2 = me2;
      }
    }, "children"), ve2 ? ve2(ye2) : ye2;
  }
  function De2(ce) {
    let pe = ce;
    for (; u(pe.children); )
      pe = t(pe.children);
    return pe;
  }
  function ie(ce) {
    let pe;
    if (ce.type === "html")
      pe = ce.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
    else {
      let de2;
      ce.type === "esComment" ? de2 = ce : ce.type === "paragraph" && ce.children.length === 1 && ce.children[0].type === "esComment" && (de2 = ce.children[0]), de2 && (pe = de2.value.match(/^prettier-ignore(?:-(start|end))?$/));
    }
    return pe ? pe[1] || "next" : false;
  }
  function G(ce, pe) {
    let de2 = pe.parts.length === 0, ae2 = b2.includes(ce.type), ve2 = ce.type === "html" && L.includes(pe.parentNode.type);
    return !de2 && !ae2 && !ve2;
  }
  function z(ce, pe) {
    var de2, ae2, ve2;
    let he2 = (pe.prevNode && pe.prevNode.type) === ce.type && V.has(ce.type), ye2 = pe.parentNode.type === "listItem" && !pe.parentNode.loose, Ce2 = ((de2 = pe.prevNode) === null || de2 === void 0 ? void 0 : de2.type) === "listItem" && pe.prevNode.loose, Ie2 = ie(pe.prevNode) === "next", Fe2 = ce.type === "html" && ((ae2 = pe.prevNode) === null || ae2 === void 0 ? void 0 : ae2.type) === "html" && pe.prevNode.position.end.line + 1 === ce.position.start.line, me2 = ce.type === "html" && pe.parentNode.type === "listItem" && ((ve2 = pe.prevNode) === null || ve2 === void 0 ? void 0 : ve2.type) === "paragraph" && pe.prevNode.position.end.line + 1 === ce.position.start.line;
    return Ce2 || !(he2 || ye2 || Ie2 || Fe2 || me2);
  }
  function U(ce, pe) {
    let de2 = pe.prevNode && pe.prevNode.type === "list", ae2 = ce.type === "code" && ce.isIndented;
    return de2 && ae2;
  }
  function le2(ce) {
    let pe = te2(ce, ["linkReference", "imageReference"]);
    return pe && (pe.type !== "linkReference" || pe.referenceType !== "full");
  }
  function ge2(ce) {
    let pe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], de2 = [" ", ...Array.isArray(pe) ? pe : [pe]];
    return new RegExp(de2.map((ae2) => "\\".concat(ae2)).join("|")).test(ce) ? "<".concat(ce, ">") : ce;
  }
  function Ae2(ce, pe) {
    let de2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    if (!ce)
      return "";
    if (de2)
      return " " + Ae2(ce, pe, false);
    if (ce = ce.replace(/\\(["')])/g, "$1"), ce.includes('"') && ce.includes("'") && !ce.includes(")"))
      return "(".concat(ce, ")");
    let ae2 = ce.split("'").length - 1, ve2 = ce.split('"').length - 1, K = ae2 > ve2 ? '"' : ve2 > ae2 || pe.singleQuote ? "'" : '"';
    return ce = ce.replace(/\\/, "\\\\"), ce = ce.replace(new RegExp("(".concat(K, ")"), "g"), "\\$1"), "".concat(K).concat(ce).concat(K);
  }
  function Ne2(ce, pe, de2) {
    return ce < pe ? pe : ce > de2 ? de2 : ce;
  }
  function ke2(ce) {
    let pe = Number(ce.getName());
    if (pe === 0)
      return false;
    let de2 = ce.getParentNode().children[pe - 1];
    return ie(de2) === "next";
  }
  n.exports = { preprocess: F, print: q, embed: P, massageAstNode: l, hasPrettierIgnore: ke2, insertPragma: C2 };
} }), Od = Z({ "src/language-markdown/options.js"(e, n) {
  re();
  var t = Lt$1();
  n.exports = { proseWrap: t.proseWrap, singleQuote: t.singleQuote };
} }), qd = Z({ "src/language-markdown/parsers.js"() {
  re();
} }), oa = Z({ "node_modules/linguist-languages/data/Markdown.json"(e, n) {
  n.exports = { name: "Markdown", type: "prose", color: "#083fa1", aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: [".md", ".livemd", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"], filenames: ["contents.lr"], tmScope: "source.gfm", languageId: 222 };
} }), Md = Z({ "src/language-markdown/index.js"(e, n) {
  re();
  var t = Tt$1(), s2 = jd(), a3 = Od(), r = qd(), u = [t(oa(), (o) => ({ since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: [...o.filenames, "README"], extensions: o.extensions.filter((c) => c !== ".mdx") })), t(oa(), () => ({ name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"] }))], i2 = { mdast: s2 };
  n.exports = { languages: u, options: a3, printers: i2, parsers: r };
} }), Rd = Z({ "src/language-html/clean.js"(e, n) {
  re();
  var { isFrontMatterNode: t } = Ue$2(), s2 = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]);
  function a3(r, u) {
    if (r.type === "text" || r.type === "comment" || t(r) || r.type === "yaml" || r.type === "toml")
      return null;
    r.type === "attribute" && delete u.value, r.type === "docType" && delete u.value;
  }
  a3.ignoredProperties = s2, n.exports = a3;
} }), Vd = Z({ "src/language-html/constants.evaluate.js"(e, n) {
  n.exports = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" };
} }), Wd = Z({ "src/language-html/utils/is-unknown-namespace.js"(e, n) {
  re();
  function t(s2) {
    return s2.type === "element" && !s2.hasExplicitNamespace && !["html", "svg"].includes(s2.namespace);
  }
  n.exports = t;
} }), jt = Z({ "src/language-html/utils/index.js"(e, n) {
  re();
  var { inferParserByLanguage: t, isFrontMatterNode: s2 } = Ue$2(), { builders: { line: a3, hardline: r, join: u }, utils: { getDocParts: i2, replaceTextEndOfLine: o } } = Oe(), { CSS_DISPLAY_TAGS: c, CSS_DISPLAY_DEFAULT: y, CSS_WHITE_SPACE_TAGS: m2, CSS_WHITE_SPACE_DEFAULT: d4 } = Vd(), p = Wd(), f = /* @__PURE__ */ new Set(["	", `
`, "\f", "\r", " "]), h2 = (_) => _.replace(/^[\t\n\f\r ]+/, ""), w2 = (_) => _.replace(/[\t\n\f\r ]+$/, ""), T2 = (_) => h2(w2(_)), A2 = (_) => _.replace(/^[\t\f\r ]*\n/g, ""), S2 = (_) => A2(w2(_)), B = (_) => _.split(/[\t\n\f\r ]+/), I2 = (_) => _.match(/^[\t\n\f\r ]*/)[0], k2 = (_) => {
    let [, J2, ne, Ee] = _.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
    return { leadingWhitespace: J2, trailingWhitespace: Ee, text: ne };
  }, P = (_) => /[\t\n\f\r ]/.test(_);
  function C2(_, J2) {
    return !!(_.type === "ieConditionalComment" && _.lastChild && !_.lastChild.isSelfClosing && !_.lastChild.endSourceSpan || _.type === "ieConditionalComment" && !_.complete || le2(_) && _.children.some((ne) => ne.type !== "text" && ne.type !== "interpolation") || ye2(_, J2) && !l(_) && _.type !== "interpolation");
  }
  function D2(_) {
    return _.type === "attribute" || !_.parent || !_.prev ? false : g2(_.prev);
  }
  function g2(_) {
    return _.type === "comment" && _.value.trim() === "prettier-ignore";
  }
  function F(_) {
    return _.type === "text" || _.type === "comment";
  }
  function l(_) {
    return _.type === "element" && (_.fullName === "script" || _.fullName === "style" || _.fullName === "svg:style" || p(_) && (_.name === "script" || _.name === "style"));
  }
  function E(_) {
    return _.children && !l(_);
  }
  function v(_) {
    return l(_) || _.type === "interpolation" || N(_);
  }
  function N(_) {
    return ke2(_).startsWith("pre");
  }
  function x2(_, J2) {
    let ne = Ee();
    if (ne && !_.prev && _.parent && _.parent.tagDefinition && _.parent.tagDefinition.ignoreFirstLf)
      return _.type === "interpolation";
    return ne;
    function Ee() {
      return s2(_) ? false : (_.type === "text" || _.type === "interpolation") && _.prev && (_.prev.type === "text" || _.prev.type === "interpolation") ? true : !_.parent || _.parent.cssDisplay === "none" ? false : le2(_.parent) ? true : !(!_.prev && (_.parent.type === "root" || le2(_) && _.parent || l(_.parent) || K(_.parent, J2) || !De2(_.parent.cssDisplay)) || _.prev && !z(_.prev.cssDisplay));
    }
  }
  function b2(_, J2) {
    return s2(_) ? false : (_.type === "text" || _.type === "interpolation") && _.next && (_.next.type === "text" || _.next.type === "interpolation") ? true : !_.parent || _.parent.cssDisplay === "none" ? false : le2(_.parent) ? true : !(!_.next && (_.parent.type === "root" || le2(_) && _.parent || l(_.parent) || K(_.parent, J2) || !ie(_.parent.cssDisplay)) || _.next && !G(_.next.cssDisplay));
  }
  function L(_) {
    return U(_.cssDisplay) && !l(_);
  }
  function M2(_) {
    return s2(_) || _.next && _.sourceSpan.end && _.sourceSpan.end.line + 1 < _.next.sourceSpan.start.line;
  }
  function j(_) {
    return $(_) || _.type === "element" && _.children.length > 0 && (["body", "script", "style"].includes(_.name) || _.children.some((J2) => te2(J2))) || _.firstChild && _.firstChild === _.lastChild && _.firstChild.type !== "text" && H3(_.firstChild) && (!_.lastChild.isTrailingSpaceSensitive || R(_.lastChild));
  }
  function $(_) {
    return _.type === "element" && _.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(_.name) || _.cssDisplay.startsWith("table") && _.cssDisplay !== "table-cell");
  }
  function V(_) {
    return Q(_) || _.prev && q(_.prev) || Y3(_);
  }
  function q(_) {
    return Q(_) || _.type === "element" && _.fullName === "br" || Y3(_);
  }
  function Y3(_) {
    return H3(_) && R(_);
  }
  function H3(_) {
    return _.hasLeadingSpaces && (_.prev ? _.prev.sourceSpan.end.line < _.sourceSpan.start.line : _.parent.type === "root" || _.parent.startSourceSpan.end.line < _.sourceSpan.start.line);
  }
  function R(_) {
    return _.hasTrailingSpaces && (_.next ? _.next.sourceSpan.start.line > _.sourceSpan.end.line : _.parent.type === "root" || _.parent.endSourceSpan && _.parent.endSourceSpan.start.line > _.sourceSpan.end.line);
  }
  function Q(_) {
    switch (_.type) {
      case "ieConditionalComment":
      case "comment":
      case "directive":
        return true;
      case "element":
        return ["script", "select"].includes(_.name);
    }
    return false;
  }
  function ee2(_) {
    return _.lastChild ? ee2(_.lastChild) : _;
  }
  function te2(_) {
    return _.children && _.children.some((J2) => J2.type !== "text");
  }
  function oe2(_) {
    let { type: J2, lang: ne } = _.attrMap;
    if (J2 === "module" || J2 === "text/javascript" || J2 === "text/babel" || J2 === "application/javascript" || ne === "jsx")
      return "babel";
    if (J2 === "application/x-typescript" || ne === "ts" || ne === "tsx")
      return "typescript";
    if (J2 === "text/markdown")
      return "markdown";
    if (J2 === "text/html")
      return "html";
    if (J2 && (J2.endsWith("json") || J2.endsWith("importmap")) || J2 === "speculationrules")
      return "json";
    if (J2 === "text/x-handlebars-template")
      return "glimmer";
  }
  function W2(_, J2) {
    let { lang: ne } = _.attrMap;
    if (!ne || ne === "postcss" || ne === "css")
      return "css";
    if (ne === "scss")
      return "scss";
    if (ne === "less")
      return "less";
    if (ne === "stylus")
      return t("stylus", J2);
  }
  function X3(_, J2) {
    if (_.name === "script" && !_.attrMap.src)
      return !_.attrMap.lang && !_.attrMap.type ? "babel" : oe2(_);
    if (_.name === "style")
      return W2(_, J2);
    if (J2 && ye2(_, J2))
      return oe2(_) || !("src" in _.attrMap) && t(_.attrMap.lang, J2);
  }
  function ue2(_) {
    return _ === "block" || _ === "list-item" || _.startsWith("table");
  }
  function De2(_) {
    return !ue2(_) && _ !== "inline-block";
  }
  function ie(_) {
    return !ue2(_) && _ !== "inline-block";
  }
  function G(_) {
    return !ue2(_);
  }
  function z(_) {
    return !ue2(_);
  }
  function U(_) {
    return !ue2(_) && _ !== "inline-block";
  }
  function le2(_) {
    return ke2(_).startsWith("pre");
  }
  function ge2(_, J2) {
    let ne = 0;
    for (let Ee = _.stack.length - 1; Ee >= 0; Ee--) {
      let We2 = _.stack[Ee];
      We2 && typeof We2 == "object" && !Array.isArray(We2) && J2(We2) && ne++;
    }
    return ne;
  }
  function Ae2(_, J2) {
    let ne = _;
    for (; ne; ) {
      if (J2(ne))
        return true;
      ne = ne.parent;
    }
    return false;
  }
  function Ne2(_, J2) {
    if (_.prev && _.prev.type === "comment") {
      let Ee = _.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
      if (Ee)
        return Ee[1];
    }
    let ne = false;
    if (_.type === "element" && _.namespace === "svg")
      if (Ae2(_, (Ee) => Ee.fullName === "svg:foreignObject"))
        ne = true;
      else
        return _.name === "svg" ? "inline-block" : "block";
    switch (J2.htmlWhitespaceSensitivity) {
      case "strict":
        return "inline";
      case "ignore":
        return "block";
      default:
        return J2.parser === "vue" && _.parent && _.parent.type === "root" ? "block" : _.type === "element" && (!_.namespace || ne || p(_)) && c[_.name] || y;
    }
  }
  function ke2(_) {
    return _.type === "element" && (!_.namespace || p(_)) && m2[_.name] || d4;
  }
  function ce(_) {
    let J2 = Number.POSITIVE_INFINITY;
    for (let ne of _.split(`
`)) {
      if (ne.length === 0)
        continue;
      if (!f.has(ne[0]))
        return 0;
      let Ee = I2(ne).length;
      ne.length !== Ee && Ee < J2 && (J2 = Ee);
    }
    return J2 === Number.POSITIVE_INFINITY ? 0 : J2;
  }
  function pe(_) {
    let J2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ce(_);
    return J2 === 0 ? _ : _.split(`
`).map((ne) => ne.slice(J2)).join(`
`);
  }
  function de2(_, J2) {
    let ne = 0;
    for (let Ee = 0; Ee < _.length; Ee++)
      _[Ee] === J2 && ne++;
    return ne;
  }
  function ae2(_) {
    return _.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
  }
  var ve2 = /* @__PURE__ */ new Set(["template", "style", "script"]);
  function K(_, J2) {
    return he2(_, J2) && !ve2.has(_.fullName);
  }
  function he2(_, J2) {
    return J2.parser === "vue" && _.type === "element" && _.parent.type === "root" && _.fullName.toLowerCase() !== "html";
  }
  function ye2(_, J2) {
    return he2(_, J2) && (K(_, J2) || _.attrMap.lang && _.attrMap.lang !== "html");
  }
  function Ce2(_) {
    let J2 = _.fullName;
    return J2.charAt(0) === "#" || J2 === "slot-scope" || J2 === "v-slot" || J2.startsWith("v-slot:");
  }
  function Ie2(_, J2) {
    let ne = _.parent;
    if (!he2(ne, J2))
      return false;
    let Ee = ne.fullName, We2 = _.fullName;
    return Ee === "script" && We2 === "setup" || Ee === "style" && We2 === "vars";
  }
  function Fe2(_) {
    let J2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _.value;
    return _.parent.isWhitespaceSensitive ? _.parent.isIndentationSensitive ? o(J2) : o(pe(S2(J2)), r) : i2(u(a3, B(J2)));
  }
  function me2(_, J2) {
    return he2(_, J2) && _.name === "script";
  }
  n.exports = { htmlTrim: T2, htmlTrimPreserveIndentation: S2, hasHtmlWhitespace: P, getLeadingAndTrailingHtmlWhitespace: k2, canHaveInterpolation: E, countChars: de2, countParents: ge2, dedentString: pe, forceBreakChildren: $, forceBreakContent: j, forceNextEmptyLine: M2, getLastDescendant: ee2, getNodeCssStyleDisplay: Ne2, getNodeCssStyleWhiteSpace: ke2, hasPrettierIgnore: D2, inferScriptParser: X3, isVueCustomBlock: K, isVueNonHtmlBlock: ye2, isVueScriptTag: me2, isVueSlotAttribute: Ce2, isVueSfcBindingsAttribute: Ie2, isVueSfcBlock: he2, isDanglingSpaceSensitiveNode: L, isIndentationSensitiveNode: N, isLeadingSpaceSensitiveNode: x2, isPreLikeNode: le2, isScriptLikeTag: l, isTextLikeNode: F, isTrailingSpaceSensitiveNode: b2, isWhitespaceSensitiveNode: v, isUnknownNamespace: p, preferHardlineAsLeadingSpaces: V, preferHardlineAsTrailingSpaces: q, shouldPreserveContent: C2, unescapeQuoteEntities: ae2, getTextValueParts: Fe2 };
} }), $d = Z({ "node_modules/angular-html-parser/lib/compiler/src/chars.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true }), e.$EOF = 0, e.$BSPACE = 8, e.$TAB = 9, e.$LF = 10, e.$VTAB = 11, e.$FF = 12, e.$CR = 13, e.$SPACE = 32, e.$BANG = 33, e.$DQ = 34, e.$HASH = 35, e.$$ = 36, e.$PERCENT = 37, e.$AMPERSAND = 38, e.$SQ = 39, e.$LPAREN = 40, e.$RPAREN = 41, e.$STAR = 42, e.$PLUS = 43, e.$COMMA = 44, e.$MINUS = 45, e.$PERIOD = 46, e.$SLASH = 47, e.$COLON = 58, e.$SEMICOLON = 59, e.$LT = 60, e.$EQ = 61, e.$GT = 62, e.$QUESTION = 63, e.$0 = 48, e.$7 = 55, e.$9 = 57, e.$A = 65, e.$E = 69, e.$F = 70, e.$X = 88, e.$Z = 90, e.$LBRACKET = 91, e.$BACKSLASH = 92, e.$RBRACKET = 93, e.$CARET = 94, e.$_ = 95, e.$a = 97, e.$b = 98, e.$e = 101, e.$f = 102, e.$n = 110, e.$r = 114, e.$t = 116, e.$u = 117, e.$v = 118, e.$x = 120, e.$z = 122, e.$LBRACE = 123, e.$BAR = 124, e.$RBRACE = 125, e.$NBSP = 160, e.$PIPE = 124, e.$TILDA = 126, e.$AT = 64, e.$BT = 96;
  function n(i2) {
    return i2 >= e.$TAB && i2 <= e.$SPACE || i2 == e.$NBSP;
  }
  e.isWhitespace = n;
  function t(i2) {
    return e.$0 <= i2 && i2 <= e.$9;
  }
  e.isDigit = t;
  function s2(i2) {
    return i2 >= e.$a && i2 <= e.$z || i2 >= e.$A && i2 <= e.$Z;
  }
  e.isAsciiLetter = s2;
  function a3(i2) {
    return i2 >= e.$a && i2 <= e.$f || i2 >= e.$A && i2 <= e.$F || t(i2);
  }
  e.isAsciiHexDigit = a3;
  function r(i2) {
    return i2 === e.$LF || i2 === e.$CR;
  }
  e.isNewLine = r;
  function u(i2) {
    return e.$0 <= i2 && i2 <= e.$7;
  }
  e.isOctalDigit = u;
} }), Hd = Z({ "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true });
  var n = class {
    constructor(s2, a3, r) {
      this.filePath = s2, this.name = a3, this.members = r;
    }
    assertNoMembers() {
      if (this.members.length)
        throw new Error("Illegal state: symbol without members expected, but got ".concat(JSON.stringify(this), "."));
    }
  };
  e.StaticSymbol = n;
  var t = class {
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
    }
    get(s2, a3, r) {
      r = r || [];
      let u = r.length ? ".".concat(r.join(".")) : "", i2 = '"'.concat(s2, '".').concat(a3).concat(u), o = this.cache.get(i2);
      return o || (o = new n(s2, a3, r), this.cache.set(i2, o)), o;
    }
  };
  e.StaticSymbolCache = t;
} }), Gd = Z({ "node_modules/angular-html-parser/lib/compiler/src/util.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true });
  var n = /-+([a-z0-9])/g;
  function t(l) {
    return l.replace(n, function() {
      for (var E = arguments.length, v = new Array(E), N = 0; N < E; N++)
        v[N] = arguments[N];
      return v[1].toUpperCase();
    });
  }
  e.dashCaseToCamelCase = t;
  function s2(l, E) {
    return r(l, ":", E);
  }
  e.splitAtColon = s2;
  function a3(l, E) {
    return r(l, ".", E);
  }
  e.splitAtPeriod = a3;
  function r(l, E, v) {
    let N = l.indexOf(E);
    return N == -1 ? v : [l.slice(0, N).trim(), l.slice(N + 1).trim()];
  }
  function u(l, E, v) {
    return Array.isArray(l) ? E.visitArray(l, v) : A2(l) ? E.visitStringMap(l, v) : l == null || typeof l == "string" || typeof l == "number" || typeof l == "boolean" ? E.visitPrimitive(l, v) : E.visitOther(l, v);
  }
  e.visitValue = u;
  function i2(l) {
    return l != null;
  }
  e.isDefined = i2;
  function o(l) {
    return l === void 0 ? null : l;
  }
  e.noUndefined = o;
  var c = class {
    visitArray(l, E) {
      return l.map((v) => u(v, this, E));
    }
    visitStringMap(l, E) {
      let v = {};
      return Object.keys(l).forEach((N) => {
        v[N] = u(l[N], this, E);
      }), v;
    }
    visitPrimitive(l, E) {
      return l;
    }
    visitOther(l, E) {
      return l;
    }
  };
  e.ValueTransformer = c, e.SyncAsync = { assertSync: (l) => {
    if (k2(l))
      throw new Error("Illegal state: value cannot be a promise");
    return l;
  }, then: (l, E) => k2(l) ? l.then(E) : E(l), all: (l) => l.some(k2) ? Promise.all(l) : l };
  function y(l) {
    throw new Error("Internal Error: ".concat(l));
  }
  e.error = y;
  function m2(l, E) {
    let v = Error(l);
    return v[d4] = true, E && (v[p] = E), v;
  }
  e.syntaxError = m2;
  var d4 = "ngSyntaxError", p = "ngParseErrors";
  function f(l) {
    return l[d4];
  }
  e.isSyntaxError = f;
  function h2(l) {
    return l[p] || [];
  }
  e.getParseErrors = h2;
  function w2(l) {
    return l.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
  }
  e.escapeRegExp = w2;
  var T2 = Object.getPrototypeOf({});
  function A2(l) {
    return typeof l == "object" && l !== null && Object.getPrototypeOf(l) === T2;
  }
  function S2(l) {
    let E = "";
    for (let v = 0; v < l.length; v++) {
      let N = l.charCodeAt(v);
      if (N >= 55296 && N <= 56319 && l.length > v + 1) {
        let x2 = l.charCodeAt(v + 1);
        x2 >= 56320 && x2 <= 57343 && (v++, N = (N - 55296 << 10) + x2 - 56320 + 65536);
      }
      N <= 127 ? E += String.fromCharCode(N) : N <= 2047 ? E += String.fromCharCode(N >> 6 & 31 | 192, N & 63 | 128) : N <= 65535 ? E += String.fromCharCode(N >> 12 | 224, N >> 6 & 63 | 128, N & 63 | 128) : N <= 2097151 && (E += String.fromCharCode(N >> 18 & 7 | 240, N >> 12 & 63 | 128, N >> 6 & 63 | 128, N & 63 | 128));
    }
    return E;
  }
  e.utf8Encode = S2;
  function B(l) {
    if (typeof l == "string")
      return l;
    if (l instanceof Array)
      return "[" + l.map(B).join(", ") + "]";
    if (l == null)
      return "" + l;
    if (l.overriddenName)
      return "".concat(l.overriddenName);
    if (l.name)
      return "".concat(l.name);
    if (!l.toString)
      return "object";
    let E = l.toString();
    if (E == null)
      return "" + E;
    let v = E.indexOf(`
`);
    return v === -1 ? E : E.substring(0, v);
  }
  e.stringify = B;
  function I2(l) {
    return typeof l == "function" && l.hasOwnProperty("__forward_ref__") ? l() : l;
  }
  e.resolveForwardRef = I2;
  function k2(l) {
    return !!l && typeof l.then == "function";
  }
  e.isPromise = k2;
  var P = class {
    constructor(l) {
      this.full = l;
      let E = l.split(".");
      this.major = E[0], this.minor = E[1], this.patch = E.slice(2).join(".");
    }
  };
  e.Version = P;
  var C2 = typeof window < "u" && window, D2 = typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self, g2 = typeof globalThis < "u" && globalThis, F = g2 || C2 || D2;
  e.global = F;
} }), Jd = Z({ "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true });
  var n = Hd(), t = Gd(), s2 = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
  function a3(v) {
    return v.replace(/\W/g, "_");
  }
  e.sanitizeIdentifier = a3;
  var r = 0;
  function u(v) {
    if (!v || !v.reference)
      return null;
    let N = v.reference;
    if (N instanceof n.StaticSymbol)
      return N.name;
    if (N.__anonymousType)
      return N.__anonymousType;
    let x2 = t.stringify(N);
    return x2.indexOf("(") >= 0 ? (x2 = "anonymous_".concat(r++), N.__anonymousType = x2) : x2 = a3(x2), x2;
  }
  e.identifierName = u;
  function i2(v) {
    let N = v.reference;
    return N instanceof n.StaticSymbol ? N.filePath : "./".concat(t.stringify(N));
  }
  e.identifierModuleUrl = i2;
  function o(v, N) {
    return "View_".concat(u({ reference: v }), "_").concat(N);
  }
  e.viewClassName = o;
  function c(v) {
    return "RenderType_".concat(u({ reference: v }));
  }
  e.rendererTypeName = c;
  function y(v) {
    return "HostView_".concat(u({ reference: v }));
  }
  e.hostViewClassName = y;
  function m2(v) {
    return "".concat(u({ reference: v }), "NgFactory");
  }
  e.componentFactoryName = m2;
  var d4;
  (function(v) {
    v[v.Pipe = 0] = "Pipe", v[v.Directive = 1] = "Directive", v[v.NgModule = 2] = "NgModule", v[v.Injectable = 3] = "Injectable";
  })(d4 = e.CompileSummaryKind || (e.CompileSummaryKind = {}));
  function p(v) {
    return v.value != null ? a3(v.value) : u(v.identifier);
  }
  e.tokenName = p;
  function f(v) {
    return v.identifier != null ? v.identifier.reference : v.value;
  }
  e.tokenReference = f;
  var h2 = class {
    constructor() {
      let { moduleUrl: v, styles: N, styleUrls: x2 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.moduleUrl = v || null, this.styles = k2(N), this.styleUrls = k2(x2);
    }
  };
  e.CompileStylesheetMetadata = h2;
  var w2 = class {
    constructor(v) {
      let { encapsulation: N, template: x2, templateUrl: b2, htmlAst: L, styles: M2, styleUrls: j, externalStylesheets: $, animations: V, ngContentSelectors: q, interpolation: Y3, isInline: H3, preserveWhitespaces: R } = v;
      if (this.encapsulation = N, this.template = x2, this.templateUrl = b2, this.htmlAst = L, this.styles = k2(M2), this.styleUrls = k2(j), this.externalStylesheets = k2($), this.animations = V ? C2(V) : [], this.ngContentSelectors = q || [], Y3 && Y3.length != 2)
        throw new Error("'interpolation' should have a start and an end symbol.");
      this.interpolation = Y3, this.isInline = H3, this.preserveWhitespaces = R;
    }
    toSummary() {
      return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
    }
  };
  e.CompileTemplateMetadata = w2;
  var T2 = class {
    static create(v) {
      let { isHost: N, type: x2, isComponent: b2, selector: L, exportAs: M2, changeDetection: j, inputs: $, outputs: V, host: q, providers: Y3, viewProviders: H3, queries: R, guards: Q, viewQueries: ee2, entryComponents: te2, template: oe2, componentViewType: W2, rendererType: X3, componentFactory: ue2 } = v, De2 = {}, ie = {}, G = {};
      q != null && Object.keys(q).forEach((le2) => {
        let ge2 = q[le2], Ae2 = le2.match(s2);
        Ae2 === null ? G[le2] = ge2 : Ae2[1] != null ? ie[Ae2[1]] = ge2 : Ae2[2] != null && (De2[Ae2[2]] = ge2);
      });
      let z = {};
      $ != null && $.forEach((le2) => {
        let ge2 = t.splitAtColon(le2, [le2, le2]);
        z[ge2[0]] = ge2[1];
      });
      let U = {};
      return V != null && V.forEach((le2) => {
        let ge2 = t.splitAtColon(le2, [le2, le2]);
        U[ge2[0]] = ge2[1];
      }), new T2({ isHost: N, type: x2, isComponent: !!b2, selector: L, exportAs: M2, changeDetection: j, inputs: z, outputs: U, hostListeners: De2, hostProperties: ie, hostAttributes: G, providers: Y3, viewProviders: H3, queries: R, guards: Q, viewQueries: ee2, entryComponents: te2, template: oe2, componentViewType: W2, rendererType: X3, componentFactory: ue2 });
    }
    constructor(v) {
      let { isHost: N, type: x2, isComponent: b2, selector: L, exportAs: M2, changeDetection: j, inputs: $, outputs: V, hostListeners: q, hostProperties: Y3, hostAttributes: H3, providers: R, viewProviders: Q, queries: ee2, guards: te2, viewQueries: oe2, entryComponents: W2, template: X3, componentViewType: ue2, rendererType: De2, componentFactory: ie } = v;
      this.isHost = !!N, this.type = x2, this.isComponent = b2, this.selector = L, this.exportAs = M2, this.changeDetection = j, this.inputs = $, this.outputs = V, this.hostListeners = q, this.hostProperties = Y3, this.hostAttributes = H3, this.providers = k2(R), this.viewProviders = k2(Q), this.queries = k2(ee2), this.guards = te2, this.viewQueries = k2(oe2), this.entryComponents = k2(W2), this.template = X3, this.componentViewType = ue2, this.rendererType = De2, this.componentFactory = ie;
    }
    toSummary() {
      return { summaryKind: d4.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
    }
  };
  e.CompileDirectiveMetadata = T2;
  var A2 = class {
    constructor(v) {
      let { type: N, name: x2, pure: b2 } = v;
      this.type = N, this.name = x2, this.pure = !!b2;
    }
    toSummary() {
      return { summaryKind: d4.Pipe, type: this.type, name: this.name, pure: this.pure };
    }
  };
  e.CompilePipeMetadata = A2;
  var S2 = class {
  };
  e.CompileShallowModuleMetadata = S2;
  var B = class {
    constructor(v) {
      let { type: N, providers: x2, declaredDirectives: b2, exportedDirectives: L, declaredPipes: M2, exportedPipes: j, entryComponents: $, bootstrapComponents: V, importedModules: q, exportedModules: Y3, schemas: H3, transitiveModule: R, id: Q } = v;
      this.type = N || null, this.declaredDirectives = k2(b2), this.exportedDirectives = k2(L), this.declaredPipes = k2(M2), this.exportedPipes = k2(j), this.providers = k2(x2), this.entryComponents = k2($), this.bootstrapComponents = k2(V), this.importedModules = k2(q), this.exportedModules = k2(Y3), this.schemas = k2(H3), this.id = Q || null, this.transitiveModule = R || null;
    }
    toSummary() {
      let v = this.transitiveModule;
      return { summaryKind: d4.NgModule, type: this.type, entryComponents: v.entryComponents, providers: v.providers, modules: v.modules, exportedDirectives: v.exportedDirectives, exportedPipes: v.exportedPipes };
    }
  };
  e.CompileNgModuleMetadata = B;
  var I2 = class {
    constructor() {
      this.directivesSet = /* @__PURE__ */ new Set(), this.directives = [], this.exportedDirectivesSet = /* @__PURE__ */ new Set(), this.exportedDirectives = [], this.pipesSet = /* @__PURE__ */ new Set(), this.pipes = [], this.exportedPipesSet = /* @__PURE__ */ new Set(), this.exportedPipes = [], this.modulesSet = /* @__PURE__ */ new Set(), this.modules = [], this.entryComponentsSet = /* @__PURE__ */ new Set(), this.entryComponents = [], this.providers = [];
    }
    addProvider(v, N) {
      this.providers.push({ provider: v, module: N });
    }
    addDirective(v) {
      this.directivesSet.has(v.reference) || (this.directivesSet.add(v.reference), this.directives.push(v));
    }
    addExportedDirective(v) {
      this.exportedDirectivesSet.has(v.reference) || (this.exportedDirectivesSet.add(v.reference), this.exportedDirectives.push(v));
    }
    addPipe(v) {
      this.pipesSet.has(v.reference) || (this.pipesSet.add(v.reference), this.pipes.push(v));
    }
    addExportedPipe(v) {
      this.exportedPipesSet.has(v.reference) || (this.exportedPipesSet.add(v.reference), this.exportedPipes.push(v));
    }
    addModule(v) {
      this.modulesSet.has(v.reference) || (this.modulesSet.add(v.reference), this.modules.push(v));
    }
    addEntryComponent(v) {
      this.entryComponentsSet.has(v.componentType) || (this.entryComponentsSet.add(v.componentType), this.entryComponents.push(v));
    }
  };
  e.TransitiveCompileNgModuleMetadata = I2;
  function k2(v) {
    return v || [];
  }
  var P = class {
    constructor(v, N) {
      let { useClass: x2, useValue: b2, useExisting: L, useFactory: M2, deps: j, multi: $ } = N;
      this.token = v, this.useClass = x2 || null, this.useValue = b2, this.useExisting = L, this.useFactory = M2 || null, this.dependencies = j || null, this.multi = !!$;
    }
  };
  e.ProviderMeta = P;
  function C2(v) {
    return v.reduce((N, x2) => {
      let b2 = Array.isArray(x2) ? C2(x2) : x2;
      return N.concat(b2);
    }, []);
  }
  e.flatten = C2;
  function D2(v) {
    return v.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
  }
  function g2(v, N, x2) {
    let b2;
    return x2.isInline ? N.type.reference instanceof n.StaticSymbol ? b2 = "".concat(N.type.reference.filePath, ".").concat(N.type.reference.name, ".html") : b2 = "".concat(u(v), "/").concat(u(N.type), ".html") : b2 = x2.templateUrl, N.type.reference instanceof n.StaticSymbol ? b2 : D2(b2);
  }
  e.templateSourceUrl = g2;
  function F(v, N) {
    let x2 = v.moduleUrl.split(/\/\\/g), b2 = x2[x2.length - 1];
    return D2("css/".concat(N).concat(b2, ".ngstyle.js"));
  }
  e.sharedStylesheetJitUrl = F;
  function l(v) {
    return D2("".concat(u(v.type), "/module.ngfactory.js"));
  }
  e.ngModuleJitUrl = l;
  function E(v, N) {
    return D2("".concat(u(v), "/").concat(u(N.type), ".ngfactory.js"));
  }
  e.templateJitUrl = E;
} }), Ud = Z({ "node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(e) {
  re(), Object.defineProperty(e, "__esModule", { value: true });
  var n = $d(), t = Jd(), s2 = class {
    constructor(y, m2, d4, p) {
      this.file = y, this.offset = m2, this.line = d4, this.col = p;
    }
    toString() {
      return this.offset != null ? "".concat(this.file.url, "@").concat(this.line, ":").concat(this.col) : this.file.url;
    }
    moveBy(y) {
      let m2 = this.file.content, d4 = m2.length, p = this.offset, f = this.line, h2 = this.col;
      for (; p > 0 && y < 0; )
        if (p--, y++, m2.charCodeAt(p) == n.$LF) {
          f--;
          let T2 = m2.substr(0, p - 1).lastIndexOf(String.fromCharCode(n.$LF));
          h2 = T2 > 0 ? p - T2 : p;
        } else
          h2--;
      for (; p < d4 && y > 0; ) {
        let w2 = m2.charCodeAt(p);
        p++, y--, w2 == n.$LF ? (f++, h2 = 0) : h2++;
      }
      return new s2(this.file, p, f, h2);
    }
    getContext(y, m2) {
      let d4 = this.file.content, p = this.offset;
      if (p != null) {
        p > d4.length - 1 && (p = d4.length - 1);
        let f = p, h2 = 0, w2 = 0;
        for (; h2 < y && p > 0 && (p--, h2++, !(d4[p] == `
` && ++w2 == m2)); )
          ;
        for (h2 = 0, w2 = 0; h2 < y && f < d4.length - 1 && (f++, h2++, !(d4[f] == `
` && ++w2 == m2)); )
          ;
        return { before: d4.substring(p, this.offset), after: d4.substring(this.offset, f + 1) };
      }
      return null;
    }
  };
  e.ParseLocation = s2;
  var a3 = class {
    constructor(y, m2) {
      this.content = y, this.url = m2;
    }
  };
  e.ParseSourceFile = a3;
  var r = class {
    constructor(y, m2) {
      let d4 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      this.start = y, this.end = m2, this.details = d4;
    }
    toString() {
      return this.start.file.content.substring(this.start.offset, this.end.offset);
    }
  };
  e.ParseSourceSpan = r, e.EMPTY_PARSE_LOCATION = new s2(new a3("", ""), 0, 0, 0), e.EMPTY_SOURCE_SPAN = new r(e.EMPTY_PARSE_LOCATION, e.EMPTY_PARSE_LOCATION);
  var u;
  (function(y) {
    y[y.WARNING = 0] = "WARNING", y[y.ERROR = 1] = "ERROR";
  })(u = e.ParseErrorLevel || (e.ParseErrorLevel = {}));
  var i2 = class {
    constructor(y, m2) {
      let d4 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : u.ERROR;
      this.span = y, this.msg = m2, this.level = d4;
    }
    contextualMessage() {
      let y = this.span.start.getContext(100, 3);
      return y ? "".concat(this.msg, ' ("').concat(y.before, "[").concat(u[this.level], " ->]").concat(y.after, '")') : this.msg;
    }
    toString() {
      let y = this.span.details ? ", ".concat(this.span.details) : "";
      return "".concat(this.contextualMessage(), ": ").concat(this.span.start).concat(y);
    }
  };
  e.ParseError = i2;
  function o(y, m2) {
    let d4 = t.identifierModuleUrl(m2), p = d4 != null ? "in ".concat(y, " ").concat(t.identifierName(m2), " in ").concat(d4) : "in ".concat(y, " ").concat(t.identifierName(m2)), f = new a3("", p);
    return new r(new s2(f, -1, -1, -1), new s2(f, -1, -1, -1));
  }
  e.typeSourceSpan = o;
  function c(y, m2, d4) {
    let p = "in ".concat(y, " ").concat(m2, " in ").concat(d4), f = new a3("", p);
    return new r(new s2(f, -1, -1, -1), new s2(f, -1, -1, -1));
  }
  e.r3JitTypeSourceSpan = c;
} }), zd = Z({ "src/language-html/print-preprocess.js"(e, n) {
  re();
  var { ParseSourceSpan: t } = Ud(), { htmlTrim: s2, getLeadingAndTrailingHtmlWhitespace: a3, hasHtmlWhitespace: r, canHaveInterpolation: u, getNodeCssStyleDisplay: i2, isDanglingSpaceSensitiveNode: o, isIndentationSensitiveNode: c, isLeadingSpaceSensitiveNode: y, isTrailingSpaceSensitiveNode: m2, isWhitespaceSensitiveNode: d4, isVueScriptTag: p } = jt(), f = [w2, T2, S2, I2, k2, D2, P, C2, g2, B, F];
  function h2(l, E) {
    for (let v of f)
      v(l, E);
    return l;
  }
  function w2(l) {
    l.walk((E) => {
      if (E.type === "element" && E.tagDefinition.ignoreFirstLf && E.children.length > 0 && E.children[0].type === "text" && E.children[0].value[0] === `
`) {
        let v = E.children[0];
        v.value.length === 1 ? E.removeChild(v) : v.value = v.value.slice(1);
      }
    });
  }
  function T2(l) {
    let E = (v) => v.type === "element" && v.prev && v.prev.type === "ieConditionalStartComment" && v.prev.sourceSpan.end.offset === v.startSourceSpan.start.offset && v.firstChild && v.firstChild.type === "ieConditionalEndComment" && v.firstChild.sourceSpan.start.offset === v.startSourceSpan.end.offset;
    l.walk((v) => {
      if (v.children)
        for (let N = 0; N < v.children.length; N++) {
          let x2 = v.children[N];
          if (!E(x2))
            continue;
          let b2 = x2.prev, L = x2.firstChild;
          v.removeChild(b2), N--;
          let M2 = new t(b2.sourceSpan.start, L.sourceSpan.end), j = new t(M2.start, x2.sourceSpan.end);
          x2.condition = b2.condition, x2.sourceSpan = j, x2.startSourceSpan = M2, x2.removeChild(L);
        }
    });
  }
  function A2(l, E, v) {
    l.walk((N) => {
      if (N.children)
        for (let x2 = 0; x2 < N.children.length; x2++) {
          let b2 = N.children[x2];
          if (b2.type !== "text" && !E(b2))
            continue;
          b2.type !== "text" && (b2.type = "text", b2.value = v(b2));
          let L = b2.prev;
          !L || L.type !== "text" || (L.value += b2.value, L.sourceSpan = new t(L.sourceSpan.start, b2.sourceSpan.end), N.removeChild(b2), x2--);
        }
    });
  }
  function S2(l) {
    return A2(l, (E) => E.type === "cdata", (E) => "<![CDATA[".concat(E.value, "]]>"));
  }
  function B(l) {
    let E = (v) => v.type === "element" && v.attrs.length === 0 && v.children.length === 1 && v.firstChild.type === "text" && !r(v.children[0].value) && !v.firstChild.hasLeadingSpaces && !v.firstChild.hasTrailingSpaces && v.isLeadingSpaceSensitive && !v.hasLeadingSpaces && v.isTrailingSpaceSensitive && !v.hasTrailingSpaces && v.prev && v.prev.type === "text" && v.next && v.next.type === "text";
    l.walk((v) => {
      if (v.children)
        for (let N = 0; N < v.children.length; N++) {
          let x2 = v.children[N];
          if (!E(x2))
            continue;
          let b2 = x2.prev, L = x2.next;
          b2.value += "<".concat(x2.rawName, ">") + x2.firstChild.value + "</".concat(x2.rawName, ">") + L.value, b2.sourceSpan = new t(b2.sourceSpan.start, L.sourceSpan.end), b2.isTrailingSpaceSensitive = L.isTrailingSpaceSensitive, b2.hasTrailingSpaces = L.hasTrailingSpaces, v.removeChild(x2), N--, v.removeChild(L);
        }
    });
  }
  function I2(l, E) {
    if (E.parser === "html")
      return;
    let v = /{{(.+?)}}/s;
    l.walk((N) => {
      if (!!u(N))
        for (let x2 of N.children) {
          if (x2.type !== "text")
            continue;
          let b2 = x2.sourceSpan.start, L = null, M2 = x2.value.split(v);
          for (let j = 0; j < M2.length; j++, b2 = L) {
            let $ = M2[j];
            if (j % 2 === 0) {
              L = b2.moveBy($.length), $.length > 0 && N.insertChildBefore(x2, { type: "text", value: $, sourceSpan: new t(b2, L) });
              continue;
            }
            L = b2.moveBy($.length + 4), N.insertChildBefore(x2, { type: "interpolation", sourceSpan: new t(b2, L), children: $.length === 0 ? [] : [{ type: "text", value: $, sourceSpan: new t(b2.moveBy(2), L.moveBy(-2)) }] });
          }
          N.removeChild(x2);
        }
    });
  }
  function k2(l) {
    l.walk((E) => {
      if (!E.children)
        return;
      if (E.children.length === 0 || E.children.length === 1 && E.children[0].type === "text" && s2(E.children[0].value).length === 0) {
        E.hasDanglingSpaces = E.children.length > 0, E.children = [];
        return;
      }
      let v = d4(E), N = c(E);
      if (!v)
        for (let x2 = 0; x2 < E.children.length; x2++) {
          let b2 = E.children[x2];
          if (b2.type !== "text")
            continue;
          let { leadingWhitespace: L, text: M2, trailingWhitespace: j } = a3(b2.value), $ = b2.prev, V = b2.next;
          M2 ? (b2.value = M2, b2.sourceSpan = new t(b2.sourceSpan.start.moveBy(L.length), b2.sourceSpan.end.moveBy(-j.length)), L && ($ && ($.hasTrailingSpaces = true), b2.hasLeadingSpaces = true), j && (b2.hasTrailingSpaces = true, V && (V.hasLeadingSpaces = true))) : (E.removeChild(b2), x2--, (L || j) && ($ && ($.hasTrailingSpaces = true), V && (V.hasLeadingSpaces = true)));
        }
      E.isWhitespaceSensitive = v, E.isIndentationSensitive = N;
    });
  }
  function P(l) {
    l.walk((E) => {
      E.isSelfClosing = !E.children || E.type === "element" && (E.tagDefinition.isVoid || E.startSourceSpan === E.endSourceSpan);
    });
  }
  function C2(l, E) {
    l.walk((v) => {
      v.type === "element" && (v.hasHtmComponentClosingTag = v.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(E.originalText.slice(v.endSourceSpan.start.offset, v.endSourceSpan.end.offset)));
    });
  }
  function D2(l, E) {
    l.walk((v) => {
      v.cssDisplay = i2(v, E);
    });
  }
  function g2(l, E) {
    l.walk((v) => {
      let { children: N } = v;
      if (!!N) {
        if (N.length === 0) {
          v.isDanglingSpaceSensitive = o(v);
          return;
        }
        for (let x2 of N)
          x2.isLeadingSpaceSensitive = y(x2, E), x2.isTrailingSpaceSensitive = m2(x2, E);
        for (let x2 = 0; x2 < N.length; x2++) {
          let b2 = N[x2];
          b2.isLeadingSpaceSensitive = (x2 === 0 || b2.prev.isTrailingSpaceSensitive) && b2.isLeadingSpaceSensitive, b2.isTrailingSpaceSensitive = (x2 === N.length - 1 || b2.next.isLeadingSpaceSensitive) && b2.isTrailingSpaceSensitive;
        }
      }
    });
  }
  function F(l, E) {
    if (E.parser === "vue") {
      let v = l.children.find((x2) => p(x2, E));
      if (!v)
        return;
      let { lang: N } = v.attrMap;
      (N === "ts" || N === "typescript") && (E.__should_parse_vue_template_with_ts = true);
    }
  }
  n.exports = h2;
} }), Xd = Z({ "src/language-html/pragma.js"(e, n) {
  re();
  function t(a3) {
    return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(a3);
  }
  function s2(a3) {
    return `<!-- @format -->

` + a3.replace(/^\s*\n/, "");
  }
  n.exports = { hasPragma: t, insertPragma: s2 };
} }), zn$2 = Z({ "src/language-html/loc.js"(e, n) {
  re();
  function t(a3) {
    return a3.sourceSpan.start.offset;
  }
  function s2(a3) {
    return a3.sourceSpan.end.offset;
  }
  n.exports = { locStart: t, locEnd: s2 };
} }), Qt$2 = Z({ "src/language-html/print/tag.js"(e, n) {
  re();
  var t = Ut$1(), { isNonEmptyArray: s2 } = Ue$2(), { builders: { indent: a3, join: r, line: u, softline: i2, hardline: o }, utils: { replaceTextEndOfLine: c } } = Oe(), { locStart: y, locEnd: m2 } = zn$2(), { isTextLikeNode: d4, getLastDescendant: p, isPreLikeNode: f, hasPrettierIgnore: h2, shouldPreserveContent: w2, isVueSfcBlock: T2 } = jt();
  function A2(q, Y3) {
    return [q.isSelfClosing ? "" : S2(q, Y3), B(q, Y3)];
  }
  function S2(q, Y3) {
    return q.lastChild && l(q.lastChild) ? "" : [I2(q, Y3), P(q, Y3)];
  }
  function B(q, Y3) {
    return (q.next ? g2(q.next) : F(q.parent)) ? "" : [C2(q, Y3), k2(q, Y3)];
  }
  function I2(q, Y3) {
    return F(q) ? C2(q.lastChild, Y3) : "";
  }
  function k2(q, Y3) {
    return l(q) ? P(q.parent, Y3) : E(q) ? $(q.next) : "";
  }
  function P(q, Y3) {
    if (t(!q.isSelfClosing), D2(q, Y3))
      return "";
    switch (q.type) {
      case "ieConditionalComment":
        return "<!";
      case "element":
        if (q.hasHtmComponentClosingTag)
          return "<//";
      default:
        return "</".concat(q.rawName);
    }
  }
  function C2(q, Y3) {
    if (D2(q, Y3))
      return "";
    switch (q.type) {
      case "ieConditionalComment":
      case "ieConditionalEndComment":
        return "[endif]-->";
      case "ieConditionalStartComment":
        return "]><!-->";
      case "interpolation":
        return "}}";
      case "element":
        if (q.isSelfClosing)
          return "/>";
      default:
        return ">";
    }
  }
  function D2(q, Y3) {
    return !q.isSelfClosing && !q.endSourceSpan && (h2(q) || w2(q.parent, Y3));
  }
  function g2(q) {
    return q.prev && q.prev.type !== "docType" && !d4(q.prev) && q.isLeadingSpaceSensitive && !q.hasLeadingSpaces;
  }
  function F(q) {
    return q.lastChild && q.lastChild.isTrailingSpaceSensitive && !q.lastChild.hasTrailingSpaces && !d4(p(q.lastChild)) && !f(q);
  }
  function l(q) {
    return !q.next && !q.hasTrailingSpaces && q.isTrailingSpaceSensitive && d4(p(q));
  }
  function E(q) {
    return q.next && !d4(q.next) && d4(q) && q.isTrailingSpaceSensitive && !q.hasTrailingSpaces;
  }
  function v(q) {
    let Y3 = q.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
    return Y3 ? Y3[1] ? Y3[1].split(/\s+/) : true : false;
  }
  function N(q) {
    return !q.prev && q.isLeadingSpaceSensitive && !q.hasLeadingSpaces;
  }
  function x2(q, Y3, H3) {
    let R = q.getValue();
    if (!s2(R.attrs))
      return R.isSelfClosing ? " " : "";
    let Q = R.prev && R.prev.type === "comment" && v(R.prev.value), ee2 = typeof Q == "boolean" ? () => Q : Array.isArray(Q) ? (De2) => Q.includes(De2.rawName) : () => false, te2 = q.map((De2) => {
      let ie = De2.getValue();
      return ee2(ie) ? c(Y3.originalText.slice(y(ie), m2(ie))) : H3();
    }, "attrs"), oe2 = R.type === "element" && R.fullName === "script" && R.attrs.length === 1 && R.attrs[0].fullName === "src" && R.children.length === 0, X3 = Y3.singleAttributePerLine && R.attrs.length > 1 && !T2(R, Y3) ? o : u, ue2 = [a3([oe2 ? " " : u, r(X3, te2)])];
    return R.firstChild && N(R.firstChild) || R.isSelfClosing && F(R.parent) || oe2 ? ue2.push(R.isSelfClosing ? " " : "") : ue2.push(Y3.bracketSameLine ? R.isSelfClosing ? " " : "" : R.isSelfClosing ? u : i2), ue2;
  }
  function b2(q) {
    return q.firstChild && N(q.firstChild) ? "" : V(q);
  }
  function L(q, Y3, H3) {
    let R = q.getValue();
    return [M2(R, Y3), x2(q, Y3, H3), R.isSelfClosing ? "" : b2(R)];
  }
  function M2(q, Y3) {
    return q.prev && E(q.prev) ? "" : [j(q, Y3), $(q)];
  }
  function j(q, Y3) {
    return N(q) ? V(q.parent) : g2(q) ? C2(q.prev, Y3) : "";
  }
  function $(q) {
    switch (q.type) {
      case "ieConditionalComment":
      case "ieConditionalStartComment":
        return "<!--[if ".concat(q.condition);
      case "ieConditionalEndComment":
        return "<!--<!";
      case "interpolation":
        return "{{";
      case "docType":
        return "<!DOCTYPE";
      case "element":
        if (q.condition)
          return "<!--[if ".concat(q.condition, "]><!--><").concat(q.rawName);
      default:
        return "<".concat(q.rawName);
    }
  }
  function V(q) {
    switch (t(!q.isSelfClosing), q.type) {
      case "ieConditionalComment":
        return "]>";
      case "element":
        if (q.condition)
          return "><!--<![endif]-->";
      default:
        return ">";
    }
  }
  n.exports = { printClosingTag: A2, printClosingTagStart: S2, printClosingTagStartMarker: P, printClosingTagEndMarker: C2, printClosingTagSuffix: k2, printClosingTagEnd: B, needsToBorrowLastChildClosingTagEndMarker: F, needsToBorrowParentClosingTagStartMarker: l, needsToBorrowPrevClosingTagEndMarker: g2, printOpeningTag: L, printOpeningTagStart: M2, printOpeningTagPrefix: j, printOpeningTagStartMarker: $, printOpeningTagEndMarker: V, needsToBorrowNextOpeningTagStartMarker: E, needsToBorrowParentOpeningTagEndMarker: N };
} }), Kd = Z({ "node_modules/parse-srcset/src/parse-srcset.js"(e, n) {
  re(), function(t, s2) {
    typeof define == "function" && define.amd ? define([], s2) : typeof n == "object" && n.exports ? n.exports = s2() : t.parseSrcset = s2();
  }(e, function() {
    return function(t, s2) {
      var a3 = s2 && s2.logger || console;
      function r(P) {
        return P === " " || P === "	" || P === `
` || P === "\f" || P === "\r";
      }
      function u(P) {
        var C2, D2 = P.exec(t.substring(S2));
        if (D2)
          return C2 = D2[0], S2 += C2.length, C2;
      }
      for (var i2 = t.length, o = /^[ \t\n\r\u000c]+/, c = /^[, \t\n\r\u000c]+/, y = /^[^ \t\n\r\u000c]+/, m2 = /[,]+$/, d4 = /^\d+$/, p = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, f, h2, w2, T2, A2, S2 = 0, B = []; ; ) {
        if (u(c), S2 >= i2)
          return B;
        f = u(y), h2 = [], f.slice(-1) === "," ? (f = f.replace(m2, ""), k2()) : I2();
      }
      function I2() {
        for (u(o), w2 = "", T2 = "in descriptor"; ; ) {
          if (A2 = t.charAt(S2), T2 === "in descriptor")
            if (r(A2))
              w2 && (h2.push(w2), w2 = "", T2 = "after descriptor");
            else if (A2 === ",") {
              S2 += 1, w2 && h2.push(w2), k2();
              return;
            } else if (A2 === "(")
              w2 = w2 + A2, T2 = "in parens";
            else if (A2 === "") {
              w2 && h2.push(w2), k2();
              return;
            } else
              w2 = w2 + A2;
          else if (T2 === "in parens")
            if (A2 === ")")
              w2 = w2 + A2, T2 = "in descriptor";
            else if (A2 === "") {
              h2.push(w2), k2();
              return;
            } else
              w2 = w2 + A2;
          else if (T2 === "after descriptor" && !r(A2))
            if (A2 === "") {
              k2();
              return;
            } else
              T2 = "in descriptor", S2 -= 1;
          S2 += 1;
        }
      }
      function k2() {
        var P = false, C2, D2, g2, F, l = {}, E, v, N, x2, b2;
        for (F = 0; F < h2.length; F++)
          E = h2[F], v = E[E.length - 1], N = E.substring(0, E.length - 1), x2 = parseInt(N, 10), b2 = parseFloat(N), d4.test(N) && v === "w" ? ((C2 || D2) && (P = true), x2 === 0 ? P = true : C2 = x2) : p.test(N) && v === "x" ? ((C2 || D2 || g2) && (P = true), b2 < 0 ? P = true : D2 = b2) : d4.test(N) && v === "h" ? ((g2 || D2) && (P = true), x2 === 0 ? P = true : g2 = x2) : P = true;
        P ? a3 && a3.error && a3.error("Invalid srcset descriptor found in '" + t + "' at '" + E + "'.") : (l.url = f, C2 && (l.w = C2), D2 && (l.d = D2), g2 && (l.h = g2), B.push(l));
      }
    };
  });
} }), Yd = Z({ "src/language-html/syntax-attribute.js"(e, n) {
  re();
  var t = Kd(), { builders: { ifBreak: s2, join: a3, line: r } } = Oe();
  function u(o) {
    let c = t(o, { logger: { error(I2) {
      throw new Error(I2);
    } } }), y = c.some((I2) => {
      let { w: k2 } = I2;
      return k2;
    }), m2 = c.some((I2) => {
      let { h: k2 } = I2;
      return k2;
    }), d4 = c.some((I2) => {
      let { d: k2 } = I2;
      return k2;
    });
    if (y + m2 + d4 > 1)
      throw new Error("Mixed descriptor in srcset is not supported");
    let p = y ? "w" : m2 ? "h" : "d", f = y ? "w" : m2 ? "h" : "x", h2 = (I2) => Math.max(...I2), w2 = c.map((I2) => I2.url), T2 = h2(w2.map((I2) => I2.length)), A2 = c.map((I2) => I2[p]).map((I2) => I2 ? I2.toString() : ""), S2 = A2.map((I2) => {
      let k2 = I2.indexOf(".");
      return k2 === -1 ? I2.length : k2;
    }), B = h2(S2);
    return a3([",", r], w2.map((I2, k2) => {
      let P = [I2], C2 = A2[k2];
      if (C2) {
        let D2 = T2 - I2.length + 1, g2 = B - S2[k2], F = " ".repeat(D2 + g2);
        P.push(s2(F, " "), C2 + f);
      }
      return P;
    }));
  }
  function i2(o) {
    return o.trim().split(/\s+/).join(" ");
  }
  n.exports = { printImgSrcset: u, printClassNames: i2 };
} }), Qd = Z({ "src/language-html/syntax-vue.js"(e, n) {
  re();
  var { builders: { group: t } } = Oe();
  function s2(i2, o) {
    let { left: c, operator: y, right: m2 } = a3(i2);
    return [t(o("function _(".concat(c, ") {}"), { parser: "babel", __isVueForBindingLeft: true })), " ", y, " ", o(m2, { parser: "__js_expression" }, { stripTrailingHardline: true })];
  }
  function a3(i2) {
    let o = /(.*?)\s+(in|of)\s+(.*)/s, c = /,([^,\]}]*)(?:,([^,\]}]*))?$/, y = /^\(|\)$/g, m2 = i2.match(o);
    if (!m2)
      return;
    let d4 = {};
    if (d4.for = m2[3].trim(), !d4.for)
      return;
    let p = m2[1].trim().replace(y, ""), f = p.match(c);
    f ? (d4.alias = p.replace(c, ""), d4.iterator1 = f[1].trim(), f[2] && (d4.iterator2 = f[2].trim())) : d4.alias = p;
    let h2 = [d4.alias, d4.iterator1, d4.iterator2];
    if (!h2.some((w2, T2) => !w2 && (T2 === 0 || h2.slice(T2 + 1).some(Boolean))))
      return { left: h2.filter(Boolean).join(","), operator: m2[2], right: d4.for };
  }
  function r(i2, o) {
    return o("function _(".concat(i2, ") {}"), { parser: "babel", __isVueBindings: true });
  }
  function u(i2) {
    let o = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/, c = /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/, y = i2.trim();
    return o.test(y) || c.test(y);
  }
  n.exports = { isVueEventBindingExpression: u, printVueFor: s2, printVueBindings: r };
} }), co$1 = Z({ "src/language-html/get-node-content.js"(e, n) {
  re();
  var { needsToBorrowParentClosingTagStartMarker: t, printClosingTagStartMarker: s2, needsToBorrowLastChildClosingTagEndMarker: a3, printClosingTagEndMarker: r, needsToBorrowParentOpeningTagEndMarker: u, printOpeningTagEndMarker: i2 } = Qt$2();
  function o(c, y) {
    let m2 = c.startSourceSpan.end.offset;
    c.firstChild && u(c.firstChild) && (m2 -= i2(c).length);
    let d4 = c.endSourceSpan.start.offset;
    return c.lastChild && t(c.lastChild) ? d4 += s2(c, y).length : a3(c) && (d4 -= r(c.lastChild, y).length), y.originalText.slice(m2, d4);
  }
  n.exports = o;
} }), Zd = Z({ "src/language-html/embed.js"(e, n) {
  re();
  var { builders: { breakParent: t, group: s2, hardline: a3, indent: r, line: u, fill: i2, softline: o }, utils: { mapDoc: c, replaceTextEndOfLine: y } } = Oe(), m2 = Jn$2(), { printClosingTag: d4, printClosingTagSuffix: p, needsToBorrowPrevClosingTagEndMarker: f, printOpeningTagPrefix: h2, printOpeningTag: w2 } = Qt$2(), { printImgSrcset: T2, printClassNames: A2 } = Yd(), { printVueFor: S2, printVueBindings: B, isVueEventBindingExpression: I2 } = Qd(), { isScriptLikeTag: k2, isVueNonHtmlBlock: P, inferScriptParser: C2, htmlTrimPreserveIndentation: D2, dedentString: g2, unescapeQuoteEntities: F, isVueSlotAttribute: l, isVueSfcBindingsAttribute: E, getTextValueParts: v } = jt(), N = co$1();
  function x2(L, M2, j) {
    let $ = (te2) => new RegExp(te2.join("|")).test(L.fullName), V = () => F(L.value), q = false, Y3 = (te2, oe2) => {
      let W2 = te2.type === "NGRoot" ? te2.node.type === "NGMicrosyntax" && te2.node.body.length === 1 && te2.node.body[0].type === "NGMicrosyntaxExpression" ? te2.node.body[0].expression : te2.node : te2.type === "JsExpressionRoot" ? te2.node : te2;
      W2 && (W2.type === "ObjectExpression" || W2.type === "ArrayExpression" || oe2.parser === "__vue_expression" && (W2.type === "TemplateLiteral" || W2.type === "StringLiteral")) && (q = true);
    }, H3 = (te2) => s2(te2), R = function(te2) {
      let oe2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      return s2([r([o, te2]), oe2 ? o : ""]);
    }, Q = (te2) => q ? H3(te2) : R(te2), ee2 = (te2, oe2) => M2(te2, Object.assign({ __onHtmlBindingRoot: Y3, __embeddedInHtml: true }, oe2));
    if (L.fullName === "srcset" && (L.parent.fullName === "img" || L.parent.fullName === "source"))
      return R(T2(V()));
    if (L.fullName === "class" && !j.parentParser) {
      let te2 = V();
      if (!te2.includes("{{"))
        return A2(te2);
    }
    if (L.fullName === "style" && !j.parentParser) {
      let te2 = V();
      if (!te2.includes("{{"))
        return R(ee2(te2, { parser: "css", __isHTMLStyleAttribute: true }));
    }
    if (j.parser === "vue") {
      if (L.fullName === "v-for")
        return S2(V(), ee2);
      if (l(L) || E(L, j))
        return B(V(), ee2);
      let te2 = ["^@", "^v-on:"], oe2 = ["^:", "^v-bind:"], W2 = ["^v-"];
      if ($(te2)) {
        let X3 = V(), ue2 = I2(X3) ? "__js_expression" : j.__should_parse_vue_template_with_ts ? "__vue_ts_event_binding" : "__vue_event_binding";
        return Q(ee2(X3, { parser: ue2 }));
      }
      if ($(oe2))
        return Q(ee2(V(), { parser: "__vue_expression" }));
      if ($(W2))
        return Q(ee2(V(), { parser: "__js_expression" }));
    }
    if (j.parser === "angular") {
      let te2 = (G, z) => ee2(G, Object.assign(Object.assign({}, z), {}, { trailingComma: "none" })), oe2 = ["^\\*"], W2 = ["^\\(.+\\)$", "^on-"], X3 = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], ue2 = ["^i18n(-.+)?$"];
      if ($(W2))
        return Q(te2(V(), { parser: "__ng_action" }));
      if ($(X3))
        return Q(te2(V(), { parser: "__ng_binding" }));
      if ($(ue2)) {
        let G = V().trim();
        return R(i2(v(L, G)), !G.includes("@@"));
      }
      if ($(oe2))
        return Q(te2(V(), { parser: "__ng_directive" }));
      let De2 = /{{(.+?)}}/s, ie = V();
      if (De2.test(ie)) {
        let G = [];
        for (let [z, U] of ie.split(De2).entries())
          if (z % 2 === 0)
            G.push(y(U));
          else
            try {
              G.push(s2(["{{", r([u, te2(U, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), u, "}}"]));
            } catch {
              G.push("{{", y(U), "}}");
            }
        return s2(G);
      }
    }
    return null;
  }
  function b2(L, M2, j, $) {
    let V = L.getValue();
    switch (V.type) {
      case "element": {
        if (k2(V) || V.type === "interpolation")
          return;
        if (!V.isSelfClosing && P(V, $)) {
          let q = C2(V, $);
          if (!q)
            return;
          let Y3 = N(V, $), H3 = /^\s*$/.test(Y3), R = "";
          return H3 || (R = j(D2(Y3), { parser: q, __embeddedInHtml: true }, { stripTrailingHardline: true }), H3 = R === ""), [h2(V, $), s2(w2(L, $, M2)), H3 ? "" : a3, R, H3 ? "" : a3, d4(V, $), p(V, $)];
        }
        break;
      }
      case "text": {
        if (k2(V.parent)) {
          let q = C2(V.parent, $);
          if (q) {
            let Y3 = q === "markdown" ? g2(V.value.replace(/^[^\S\n]*\n/, "")) : V.value, H3 = { parser: q, __embeddedInHtml: true };
            if ($.parser === "html" && q === "babel") {
              let R = "script", { attrMap: Q } = V.parent;
              Q && (Q.type === "module" || Q.type === "text/babel" && Q["data-type"] === "module") && (R = "module"), H3.__babelSourceType = R;
            }
            return [t, h2(V, $), j(Y3, H3, { stripTrailingHardline: true }), p(V, $)];
          }
        } else if (V.parent.type === "interpolation") {
          let q = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
          return $.parser === "angular" ? (q.parser = "__ng_interpolation", q.trailingComma = "none") : $.parser === "vue" ? q.parser = $.__should_parse_vue_template_with_ts ? "__vue_ts_expression" : "__vue_expression" : q.parser = "__js_expression", [r([u, j(V.value, q, { stripTrailingHardline: true })]), V.parent.next && f(V.parent.next) ? " " : u];
        }
        break;
      }
      case "attribute": {
        if (!V.value)
          break;
        if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test($.originalText.slice(V.valueSpan.start.offset, V.valueSpan.end.offset)))
          return [V.rawName, "=", V.value];
        if ($.parser === "lwc" && /^{.*}$/s.test($.originalText.slice(V.valueSpan.start.offset, V.valueSpan.end.offset)))
          return [V.rawName, "=", V.value];
        let q = x2(V, (Y3, H3) => j(Y3, Object.assign({ __isInHtmlAttribute: true, __embeddedInHtml: true }, H3), { stripTrailingHardline: true }), $);
        if (q)
          return [V.rawName, '="', s2(c(q, (Y3) => typeof Y3 == "string" ? Y3.replace(/"/g, "&quot;") : Y3)), '"'];
        break;
      }
      case "front-matter":
        return m2(V, j);
    }
  }
  n.exports = b2;
} }), po$1 = Z({ "src/language-html/print/children.js"(e, n) {
  re();
  var { builders: { breakParent: t, group: s2, ifBreak: a3, line: r, softline: u, hardline: i2 }, utils: { replaceTextEndOfLine: o } } = Oe(), { locStart: c, locEnd: y } = zn$2(), { forceBreakChildren: m2, forceNextEmptyLine: d4, isTextLikeNode: p, hasPrettierIgnore: f, preferHardlineAsLeadingSpaces: h2 } = jt(), { printOpeningTagPrefix: w2, needsToBorrowNextOpeningTagStartMarker: T2, printOpeningTagStartMarker: A2, needsToBorrowPrevClosingTagEndMarker: S2, printClosingTagEndMarker: B, printClosingTagSuffix: I2, needsToBorrowParentClosingTagStartMarker: k2 } = Qt$2();
  function P(g2, F, l) {
    let E = g2.getValue();
    return f(E) ? [w2(E, F), ...o(F.originalText.slice(c(E) + (E.prev && T2(E.prev) ? A2(E).length : 0), y(E) - (E.next && S2(E.next) ? B(E, F).length : 0))), I2(E, F)] : l();
  }
  function C2(g2, F) {
    return p(g2) && p(F) ? g2.isTrailingSpaceSensitive ? g2.hasTrailingSpaces ? h2(F) ? i2 : r : "" : h2(F) ? i2 : u : T2(g2) && (f(F) || F.firstChild || F.isSelfClosing || F.type === "element" && F.attrs.length > 0) || g2.type === "element" && g2.isSelfClosing && S2(F) ? "" : !F.isLeadingSpaceSensitive || h2(F) || S2(F) && g2.lastChild && k2(g2.lastChild) && g2.lastChild.lastChild && k2(g2.lastChild.lastChild) ? i2 : F.hasLeadingSpaces ? r : u;
  }
  function D2(g2, F, l) {
    let E = g2.getValue();
    if (m2(E))
      return [t, ...g2.map((N) => {
        let x2 = N.getValue(), b2 = x2.prev ? C2(x2.prev, x2) : "";
        return [b2 ? [b2, d4(x2.prev) ? i2 : ""] : "", P(N, F, l)];
      }, "children")];
    let v = E.children.map(() => Symbol(""));
    return g2.map((N, x2) => {
      let b2 = N.getValue();
      if (p(b2)) {
        if (b2.prev && p(b2.prev)) {
          let Y3 = C2(b2.prev, b2);
          if (Y3)
            return d4(b2.prev) ? [i2, i2, P(N, F, l)] : [Y3, P(N, F, l)];
        }
        return P(N, F, l);
      }
      let L = [], M2 = [], j = [], $ = [], V = b2.prev ? C2(b2.prev, b2) : "", q = b2.next ? C2(b2, b2.next) : "";
      return V && (d4(b2.prev) ? L.push(i2, i2) : V === i2 ? L.push(i2) : p(b2.prev) ? M2.push(V) : M2.push(a3("", u, { groupId: v[x2 - 1] }))), q && (d4(b2) ? p(b2.next) && $.push(i2, i2) : q === i2 ? p(b2.next) && $.push(i2) : j.push(q)), [...L, s2([...M2, s2([P(N, F, l), ...j], { id: v[x2] })]), ...$];
    }, "children");
  }
  n.exports = { printChildren: D2 };
} }), eg = Z({ "src/language-html/print/element.js"(e, n) {
  re();
  var { builders: { breakParent: t, dedentToRoot: s2, group: a3, ifBreak: r, indentIfBreak: u, indent: i2, line: o, softline: c }, utils: { replaceTextEndOfLine: y } } = Oe(), m2 = co$1(), { shouldPreserveContent: d4, isScriptLikeTag: p, isVueCustomBlock: f, countParents: h2, forceBreakContent: w2 } = jt(), { printOpeningTagPrefix: T2, printOpeningTag: A2, printClosingTagSuffix: S2, printClosingTag: B, needsToBorrowPrevClosingTagEndMarker: I2, needsToBorrowLastChildClosingTagEndMarker: k2 } = Qt$2(), { printChildren: P } = po$1();
  function C2(D2, g2, F) {
    let l = D2.getValue();
    if (d4(l, g2))
      return [T2(l, g2), a3(A2(D2, g2, F)), ...y(m2(l, g2)), ...B(l, g2), S2(l, g2)];
    let E = l.children.length === 1 && l.firstChild.type === "interpolation" && l.firstChild.isLeadingSpaceSensitive && !l.firstChild.hasLeadingSpaces && l.lastChild.isTrailingSpaceSensitive && !l.lastChild.hasTrailingSpaces, v = Symbol("element-attr-group-id"), N = (M2) => a3([a3(A2(D2, g2, F), { id: v }), M2, B(l, g2)]), x2 = (M2) => E ? u(M2, { groupId: v }) : (p(l) || f(l, g2)) && l.parent.type === "root" && g2.parser === "vue" && !g2.vueIndentScriptAndStyle ? M2 : i2(M2), b2 = () => E ? r(c, "", { groupId: v }) : l.firstChild.hasLeadingSpaces && l.firstChild.isLeadingSpaceSensitive ? o : l.firstChild.type === "text" && l.isWhitespaceSensitive && l.isIndentationSensitive ? s2(c) : c, L = () => (l.next ? I2(l.next) : k2(l.parent)) ? l.lastChild.hasTrailingSpaces && l.lastChild.isTrailingSpaceSensitive ? " " : "" : E ? r(c, "", { groupId: v }) : l.lastChild.hasTrailingSpaces && l.lastChild.isTrailingSpaceSensitive ? o : (l.lastChild.type === "comment" || l.lastChild.type === "text" && l.isWhitespaceSensitive && l.isIndentationSensitive) && new RegExp("\\n[\\t ]{".concat(g2.tabWidth * h2(D2, (j) => j.parent && j.parent.type !== "root"), "}$")).test(l.lastChild.value) ? "" : c;
    return l.children.length === 0 ? N(l.hasDanglingSpaces && l.isDanglingSpaceSensitive ? o : "") : N([w2(l) ? t : "", x2([b2(), P(D2, g2, F)]), L()]);
  }
  n.exports = { printElement: C2 };
} }), tg = Z({ "src/language-html/printer-html.js"(e, n) {
  re();
  var { builders: { fill: t, group: s2, hardline: a3, literalline: r }, utils: { cleanDoc: u, getDocParts: i2, isConcat: o, replaceTextEndOfLine: c } } = Oe(), y = Rd(), { countChars: m2, unescapeQuoteEntities: d4, getTextValueParts: p } = jt(), f = zd(), { insertPragma: h2 } = Xd(), { locStart: w2, locEnd: T2 } = zn$2(), A2 = Zd(), { printClosingTagSuffix: S2, printClosingTagEnd: B, printOpeningTagPrefix: I2, printOpeningTagStart: k2 } = Qt$2(), { printElement: P } = eg(), { printChildren: C2 } = po$1();
  function D2(g2, F, l) {
    let E = g2.getValue();
    switch (E.type) {
      case "front-matter":
        return c(E.raw);
      case "root":
        return F.__onHtmlRoot && F.__onHtmlRoot(E), [s2(C2(g2, F, l)), a3];
      case "element":
      case "ieConditionalComment":
        return P(g2, F, l);
      case "ieConditionalStartComment":
      case "ieConditionalEndComment":
        return [k2(E), B(E)];
      case "interpolation":
        return [k2(E, F), ...g2.map(l, "children"), B(E, F)];
      case "text": {
        if (E.parent.type === "interpolation") {
          let N = /\n[^\S\n]*$/, x2 = N.test(E.value), b2 = x2 ? E.value.replace(N, "") : E.value;
          return [...c(b2), x2 ? a3 : ""];
        }
        let v = u([I2(E, F), ...p(E), S2(E, F)]);
        return o(v) || v.type === "fill" ? t(i2(v)) : v;
      }
      case "docType":
        return [s2([k2(E, F), " ", E.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), B(E, F)];
      case "comment":
        return [I2(E, F), ...c(F.originalText.slice(w2(E), T2(E)), r), S2(E, F)];
      case "attribute": {
        if (E.value === null)
          return E.rawName;
        let v = d4(E.value), N = m2(v, "'"), x2 = m2(v, '"'), b2 = N < x2 ? "'" : '"';
        return [E.rawName, "=", b2, ...c(b2 === '"' ? v.replace(/"/g, "&quot;") : v.replace(/'/g, "&apos;")), b2];
      }
      default:
        throw new Error("Unexpected node type ".concat(E.type));
    }
  }
  n.exports = { preprocess: f, print: D2, insertPragma: h2, massageAstNode: y, embed: A2 };
} }), rg = Z({ "src/language-html/options.js"(e, n) {
  re();
  var t = Lt$1(), s2 = "HTML";
  n.exports = { bracketSameLine: t.bracketSameLine, htmlWhitespaceSensitivity: { since: "1.15.0", category: s2, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: t.singleAttributePerLine, vueIndentScriptAndStyle: { since: "1.19.0", category: s2, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } };
} }), ng = Z({ "src/language-html/parsers.js"() {
  re();
} }), An$1 = Z({ "node_modules/linguist-languages/data/HTML.json"(e, n) {
  n.exports = { name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], languageId: 146 };
} }), ug = Z({ "node_modules/linguist-languages/data/Vue.json"(e, n) {
  n.exports = { name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", languageId: 391 };
} }), sg = Z({ "src/language-html/index.js"(e, n) {
  re();
  var t = Tt$1(), s2 = tg(), a3 = rg(), r = ng(), u = [t(An$1(), () => ({ name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: [] })), t(An$1(), (o) => ({ since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: [...o.extensions, ".mjml"] })), t(An$1(), () => ({ name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: [] })), t(ug(), () => ({ since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"] }))], i2 = { html: s2 };
  n.exports = { languages: u, printers: i2, options: a3, parsers: r };
} }), ig = Z({ "src/language-yaml/pragma.js"(e, n) {
  re();
  function t(r) {
    return /^\s*@(?:prettier|format)\s*$/.test(r);
  }
  function s2(r) {
    return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(r);
  }
  function a3(r) {
    return `# @format

`.concat(r);
  }
  n.exports = { isPragma: t, hasPragma: s2, insertPragma: a3 };
} }), ag = Z({ "src/language-yaml/loc.js"(e, n) {
  re();
  function t(a3) {
    return a3.position.start.offset;
  }
  function s2(a3) {
    return a3.position.end.offset;
  }
  n.exports = { locStart: t, locEnd: s2 };
} }), og = Z({ "src/language-yaml/embed.js"(e, n) {
  re();
  function t(s2, a3, r, u) {
    if (s2.getValue().type === "root" && u.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint)rc$/.test(u.filepath))
      return r(u.originalText, Object.assign(Object.assign({}, u), {}, { parser: "json" }));
  }
  n.exports = t;
} }), Ot$2 = Z({ "src/language-yaml/utils.js"(e, n) {
  re();
  var { getLast: t, isNonEmptyArray: s2 } = Ue$2();
  function a3(C2, D2) {
    let g2 = 0, F = C2.stack.length - 1;
    for (let l = 0; l < F; l++) {
      let E = C2.stack[l];
      r(E) && D2(E) && g2++;
    }
    return g2;
  }
  function r(C2, D2) {
    return C2 && typeof C2.type == "string" && (!D2 || D2.includes(C2.type));
  }
  function u(C2, D2, g2) {
    return D2("children" in C2 ? Object.assign(Object.assign({}, C2), {}, { children: C2.children.map((F) => u(F, D2, C2)) }) : C2, g2);
  }
  function i2(C2, D2, g2) {
    Object.defineProperty(C2, D2, { get: g2, enumerable: false });
  }
  function o(C2, D2) {
    let g2 = 0, F = D2.length;
    for (let l = C2.position.end.offset - 1; l < F; l++) {
      let E = D2[l];
      if (E === `
` && g2++, g2 === 1 && /\S/.test(E))
        return false;
      if (g2 === 2)
        return true;
    }
    return false;
  }
  function c(C2) {
    switch (C2.getValue().type) {
      case "tag":
      case "anchor":
      case "comment":
        return false;
    }
    let g2 = C2.stack.length;
    for (let F = 1; F < g2; F++) {
      let l = C2.stack[F], E = C2.stack[F - 1];
      if (Array.isArray(E) && typeof l == "number" && l !== E.length - 1)
        return false;
    }
    return true;
  }
  function y(C2) {
    return s2(C2.children) ? y(t(C2.children)) : C2;
  }
  function m2(C2) {
    return C2.value.trim() === "prettier-ignore";
  }
  function d4(C2) {
    let D2 = C2.getValue();
    if (D2.type === "documentBody") {
      let g2 = C2.getParentNode();
      return S2(g2.head) && m2(t(g2.head.endComments));
    }
    return h2(D2) && m2(t(D2.leadingComments));
  }
  function p(C2) {
    return !s2(C2.children) && !f(C2);
  }
  function f(C2) {
    return h2(C2) || w2(C2) || T2(C2) || A2(C2) || S2(C2);
  }
  function h2(C2) {
    return s2(C2 == null ? void 0 : C2.leadingComments);
  }
  function w2(C2) {
    return s2(C2 == null ? void 0 : C2.middleComments);
  }
  function T2(C2) {
    return C2 == null ? void 0 : C2.indicatorComment;
  }
  function A2(C2) {
    return C2 == null ? void 0 : C2.trailingComment;
  }
  function S2(C2) {
    return s2(C2 == null ? void 0 : C2.endComments);
  }
  function B(C2) {
    let D2 = [], g2;
    for (let F of C2.split(/( +)/))
      F !== " " ? g2 === " " ? D2.push(F) : D2.push((D2.pop() || "") + F) : g2 === void 0 && D2.unshift(""), g2 = F;
    return g2 === " " && D2.push((D2.pop() || "") + " "), D2[0] === "" && (D2.shift(), D2.unshift(" " + (D2.shift() || ""))), D2;
  }
  function I2(C2, D2, g2) {
    let F = D2.split(`
`).map((l, E, v) => E === 0 && E === v.length - 1 ? l : E !== 0 && E !== v.length - 1 ? l.trim() : E === 0 ? l.trimEnd() : l.trimStart());
    return g2.proseWrap === "preserve" ? F.map((l) => l.length === 0 ? [] : [l]) : F.map((l) => l.length === 0 ? [] : B(l)).reduce((l, E, v) => v !== 0 && F[v - 1].length > 0 && E.length > 0 && !(C2 === "quoteDouble" && t(t(l)).endsWith("\\")) ? [...l.slice(0, -1), [...t(l), ...E]] : [...l, E], []).map((l) => g2.proseWrap === "never" ? [l.join(" ")] : l);
  }
  function k2(C2, D2) {
    let { parentIndent: g2, isLastDescendant: F, options: l } = D2, E = C2.position.start.line === C2.position.end.line ? "" : l.originalText.slice(C2.position.start.offset, C2.position.end.offset).match(/^[^\n]*\n(.*)$/s)[1], v;
    if (C2.indent === null) {
      let b2 = E.match(/^(?<leadingSpace> *)[^\n\r ]/m);
      v = b2 ? b2.groups.leadingSpace.length : Number.POSITIVE_INFINITY;
    } else
      v = C2.indent - 1 + g2;
    let N = E.split(`
`).map((b2) => b2.slice(v));
    if (l.proseWrap === "preserve" || C2.type === "blockLiteral")
      return x2(N.map((b2) => b2.length === 0 ? [] : [b2]));
    return x2(N.map((b2) => b2.length === 0 ? [] : B(b2)).reduce((b2, L, M2) => M2 !== 0 && N[M2 - 1].length > 0 && L.length > 0 && !/^\s/.test(L[0]) && !/^\s|\s$/.test(t(b2)) ? [...b2.slice(0, -1), [...t(b2), ...L]] : [...b2, L], []).map((b2) => b2.reduce((L, M2) => L.length > 0 && /\s$/.test(t(L)) ? [...L.slice(0, -1), t(L) + " " + M2] : [...L, M2], [])).map((b2) => l.proseWrap === "never" ? [b2.join(" ")] : b2));
    function x2(b2) {
      if (C2.chomping === "keep")
        return t(b2).length === 0 ? b2.slice(0, -1) : b2;
      let L = 0;
      for (let M2 = b2.length - 1; M2 >= 0 && b2[M2].length === 0; M2--)
        L++;
      return L === 0 ? b2 : L >= 2 && !F ? b2.slice(0, -(L - 1)) : b2.slice(0, -L);
    }
  }
  function P(C2) {
    if (!C2)
      return true;
    switch (C2.type) {
      case "plain":
      case "quoteDouble":
      case "quoteSingle":
      case "alias":
      case "flowMapping":
      case "flowSequence":
        return true;
      default:
        return false;
    }
  }
  n.exports = { getLast: t, getAncestorCount: a3, isNode: r, isEmptyNode: p, isInlineNode: P, mapNode: u, defineShortcut: i2, isNextLineEmpty: o, isLastDescendantNode: c, getBlockValueLineContents: k2, getFlowScalarLineContents: I2, getLastDescendantNode: y, hasPrettierIgnore: d4, hasLeadingComments: h2, hasMiddleComments: w2, hasIndicatorComment: T2, hasTrailingComment: A2, hasEndComments: S2 };
} }), lg = Z({ "src/language-yaml/print-preprocess.js"(e, n) {
  re();
  var { defineShortcut: t, mapNode: s2 } = Ot$2();
  function a3(u) {
    return s2(u, r);
  }
  function r(u) {
    switch (u.type) {
      case "document":
        t(u, "head", () => u.children[0]), t(u, "body", () => u.children[1]);
        break;
      case "documentBody":
      case "sequenceItem":
      case "flowSequenceItem":
      case "mappingKey":
      case "mappingValue":
        t(u, "content", () => u.children[0]);
        break;
      case "mappingItem":
      case "flowMappingItem":
        t(u, "key", () => u.children[0]), t(u, "value", () => u.children[1]);
        break;
    }
    return u;
  }
  n.exports = a3;
} }), Ir = Z({ "src/language-yaml/print/misc.js"(e, n) {
  re();
  var { builders: { softline: t, align: s2 } } = Oe(), { hasEndComments: a3, isNextLineEmpty: r, isNode: u } = Ot$2(), i2 = /* @__PURE__ */ new WeakMap();
  function o(m2, d4) {
    let p = m2.getValue(), f = m2.stack[0], h2;
    return i2.has(f) ? h2 = i2.get(f) : (h2 = /* @__PURE__ */ new Set(), i2.set(f, h2)), !h2.has(p.position.end.line) && (h2.add(p.position.end.line), r(p, d4) && !c(m2.getParentNode())) ? t : "";
  }
  function c(m2) {
    return a3(m2) && !u(m2, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
  }
  function y(m2, d4) {
    return s2(" ".repeat(m2), d4);
  }
  n.exports = { alignWithSpaces: y, shouldPrintEndComments: c, printNextEmptyLine: o };
} }), cg = Z({ "src/language-yaml/print/flow-mapping-sequence.js"(e, n) {
  re();
  var { builders: { ifBreak: t, line: s2, softline: a3, hardline: r, join: u } } = Oe(), { isEmptyNode: i2, getLast: o, hasEndComments: c } = Ot$2(), { printNextEmptyLine: y, alignWithSpaces: m2 } = Ir();
  function d4(f, h2, w2) {
    let T2 = f.getValue(), A2 = T2.type === "flowMapping", S2 = A2 ? "{" : "[", B = A2 ? "}" : "]", I2 = a3;
    A2 && T2.children.length > 0 && w2.bracketSpacing && (I2 = s2);
    let k2 = o(T2.children), P = k2 && k2.type === "flowMappingItem" && i2(k2.key) && i2(k2.value);
    return [S2, m2(w2.tabWidth, [I2, p(f, h2, w2), w2.trailingComma === "none" ? "" : t(","), c(T2) ? [r, u(r, f.map(h2, "endComments"))] : ""]), P ? "" : I2, B];
  }
  function p(f, h2, w2) {
    let T2 = f.getValue();
    return f.map((S2, B) => [h2(), B === T2.children.length - 1 ? "" : [",", s2, T2.children[B].position.start.line !== T2.children[B + 1].position.start.line ? y(S2, w2.originalText) : ""]], "children");
  }
  n.exports = { printFlowMapping: d4, printFlowSequence: d4 };
} }), pg = Z({ "src/language-yaml/print/mapping-item.js"(e, n) {
  re();
  var { builders: { conditionalGroup: t, group: s2, hardline: a3, ifBreak: r, join: u, line: i2 } } = Oe(), { hasLeadingComments: o, hasMiddleComments: c, hasTrailingComment: y, hasEndComments: m2, isNode: d4, isEmptyNode: p, isInlineNode: f } = Ot$2(), { alignWithSpaces: h2 } = Ir();
  function w2(B, I2, k2, P, C2) {
    let { key: D2, value: g2 } = B, F = p(D2), l = p(g2);
    if (F && l)
      return ": ";
    let E = P("key"), v = A2(B) ? " " : "";
    if (l)
      return B.type === "flowMappingItem" && I2.type === "flowMapping" ? E : B.type === "mappingItem" && T2(D2.content, C2) && !y(D2.content) && (!I2.tag || I2.tag.value !== "tag:yaml.org,2002:set") ? [E, v, ":"] : ["? ", h2(2, E)];
    let N = P("value");
    if (F)
      return [": ", h2(2, N)];
    if (o(g2) || !f(D2.content))
      return ["? ", h2(2, E), a3, u("", k2.map(P, "value", "leadingComments").map(($) => [$, a3])), ": ", h2(2, N)];
    if (S2(D2.content) && !o(D2.content) && !c(D2.content) && !y(D2.content) && !m2(D2) && !o(g2.content) && !c(g2.content) && !m2(g2) && T2(g2.content, C2))
      return [E, v, ": ", N];
    let x2 = Symbol("mappingKey"), b2 = s2([r("? "), s2(h2(2, E), { id: x2 })]), L = [a3, ": ", h2(2, N)], M2 = [v, ":"];
    o(g2.content) || m2(g2) && g2.content && !d4(g2.content, ["mapping", "sequence"]) || I2.type === "mapping" && y(D2.content) && f(g2.content) || d4(g2.content, ["mapping", "sequence"]) && g2.content.tag === null && g2.content.anchor === null ? M2.push(a3) : g2.content && M2.push(i2), M2.push(N);
    let j = h2(C2.tabWidth, M2);
    return T2(D2.content, C2) && !o(D2.content) && !c(D2.content) && !m2(D2) ? t([[E, j]]) : t([[b2, r(L, j, { groupId: x2 })]]);
  }
  function T2(B, I2) {
    if (!B)
      return true;
    switch (B.type) {
      case "plain":
      case "quoteSingle":
      case "quoteDouble":
        break;
      case "alias":
        return true;
      default:
        return false;
    }
    if (I2.proseWrap === "preserve")
      return B.position.start.line === B.position.end.line;
    if (/\\$/m.test(I2.originalText.slice(B.position.start.offset, B.position.end.offset)))
      return false;
    switch (I2.proseWrap) {
      case "never":
        return !B.value.includes(`
`);
      case "always":
        return !/[\n ]/.test(B.value);
      default:
        return false;
    }
  }
  function A2(B) {
    return B.key.content && B.key.content.type === "alias";
  }
  function S2(B) {
    if (!B)
      return true;
    switch (B.type) {
      case "plain":
      case "quoteDouble":
      case "quoteSingle":
        return B.position.start.line === B.position.end.line;
      case "alias":
        return true;
      default:
        return false;
    }
  }
  n.exports = w2;
} }), fg = Z({ "src/language-yaml/print/block.js"(e, n) {
  re();
  var { builders: { dedent: t, dedentToRoot: s2, fill: a3, hardline: r, join: u, line: i2, literalline: o, markAsRoot: c }, utils: { getDocParts: y } } = Oe(), { getAncestorCount: m2, getBlockValueLineContents: d4, hasIndicatorComment: p, isLastDescendantNode: f, isNode: h2 } = Ot$2(), { alignWithSpaces: w2 } = Ir();
  function T2(A2, S2, B) {
    let I2 = A2.getValue(), k2 = m2(A2, (F) => h2(F, ["sequence", "mapping"])), P = f(A2), C2 = [I2.type === "blockFolded" ? ">" : "|"];
    I2.indent !== null && C2.push(I2.indent.toString()), I2.chomping !== "clip" && C2.push(I2.chomping === "keep" ? "+" : "-"), p(I2) && C2.push(" ", S2("indicatorComment"));
    let D2 = d4(I2, { parentIndent: k2, isLastDescendant: P, options: B }), g2 = [];
    for (let [F, l] of D2.entries())
      F === 0 && g2.push(r), g2.push(a3(y(u(i2, l)))), F !== D2.length - 1 ? g2.push(l.length === 0 ? r : c(o)) : I2.chomping === "keep" && P && g2.push(s2(l.length === 0 ? r : o));
    return I2.indent === null ? C2.push(t(w2(B.tabWidth, g2))) : C2.push(s2(w2(I2.indent - 1 + k2, g2))), C2;
  }
  n.exports = T2;
} }), Dg = Z({ "src/language-yaml/printer-yaml.js"(e, n) {
  re();
  var { builders: { breakParent: t, fill: s2, group: a3, hardline: r, join: u, line: i2, lineSuffix: o, literalline: c }, utils: { getDocParts: y, replaceTextEndOfLine: m2 } } = Oe(), { isPreviousLineEmpty: d4 } = Ue$2(), { insertPragma: p, isPragma: f } = ig(), { locStart: h2 } = ag(), w2 = og(), { getFlowScalarLineContents: T2, getLastDescendantNode: A2, hasLeadingComments: S2, hasMiddleComments: B, hasTrailingComment: I2, hasEndComments: k2, hasPrettierIgnore: P, isLastDescendantNode: C2, isNode: D2, isInlineNode: g2 } = Ot$2(), F = lg(), { alignWithSpaces: l, printNextEmptyLine: E, shouldPrintEndComments: v } = Ir(), { printFlowMapping: N, printFlowSequence: x2 } = cg(), b2 = pg(), L = fg();
  function M2(R, Q, ee2) {
    let te2 = R.getValue(), oe2 = [];
    te2.type !== "mappingValue" && S2(te2) && oe2.push([u(r, R.map(ee2, "leadingComments")), r]);
    let { tag: W2, anchor: X3 } = te2;
    W2 && oe2.push(ee2("tag")), W2 && X3 && oe2.push(" "), X3 && oe2.push(ee2("anchor"));
    let ue2 = "";
    D2(te2, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !C2(R) && (ue2 = E(R, Q.originalText)), (W2 || X3) && (D2(te2, ["sequence", "mapping"]) && !B(te2) ? oe2.push(r) : oe2.push(" ")), B(te2) && oe2.push([te2.middleComments.length === 1 ? "" : r, u(r, R.map(ee2, "middleComments")), r]);
    let De2 = R.getParentNode();
    return P(R) ? oe2.push(m2(Q.originalText.slice(te2.position.start.offset, te2.position.end.offset).trimEnd(), c)) : oe2.push(a3(j(te2, De2, R, Q, ee2))), I2(te2) && !D2(te2, ["document", "documentHead"]) && oe2.push(o([te2.type === "mappingValue" && !te2.content ? "" : " ", De2.type === "mappingKey" && R.getParentNode(2).type === "mapping" && g2(te2) ? "" : t, ee2("trailingComment")])), v(te2) && oe2.push(l(te2.type === "sequenceItem" ? 2 : 0, [r, u(r, R.map((ie) => [d4(Q.originalText, ie.getValue(), h2) ? r : "", ee2()], "endComments"))])), oe2.push(ue2), oe2;
  }
  function j(R, Q, ee2, te2, oe2) {
    switch (R.type) {
      case "root": {
        let { children: W2 } = R, X3 = [];
        ee2.each((De2, ie) => {
          let G = W2[ie], z = W2[ie + 1];
          ie !== 0 && X3.push(r), X3.push(oe2()), V(G, z) ? (X3.push(r, "..."), I2(G) && X3.push(" ", oe2("trailingComment"))) : z && !I2(z.head) && X3.push(r, "---");
        }, "children");
        let ue2 = A2(R);
        return (!D2(ue2, ["blockLiteral", "blockFolded"]) || ue2.chomping !== "keep") && X3.push(r), X3;
      }
      case "document": {
        let W2 = Q.children[ee2.getName() + 1], X3 = [];
        return q(R, W2, Q, te2) === "head" && ((R.head.children.length > 0 || R.head.endComments.length > 0) && X3.push(oe2("head")), I2(R.head) ? X3.push(["---", " ", oe2(["head", "trailingComment"])]) : X3.push("---")), $(R) && X3.push(oe2("body")), u(r, X3);
      }
      case "documentHead":
        return u(r, [...ee2.map(oe2, "children"), ...ee2.map(oe2, "endComments")]);
      case "documentBody": {
        let { children: W2, endComments: X3 } = R, ue2 = "";
        if (W2.length > 0 && X3.length > 0) {
          let De2 = A2(R);
          D2(De2, ["blockFolded", "blockLiteral"]) ? De2.chomping !== "keep" && (ue2 = [r, r]) : ue2 = r;
        }
        return [u(r, ee2.map(oe2, "children")), ue2, u(r, ee2.map(oe2, "endComments"))];
      }
      case "directive":
        return ["%", u(" ", [R.name, ...R.parameters])];
      case "comment":
        return ["#", R.value];
      case "alias":
        return ["*", R.value];
      case "tag":
        return te2.originalText.slice(R.position.start.offset, R.position.end.offset);
      case "anchor":
        return ["&", R.value];
      case "plain":
        return Y3(R.type, te2.originalText.slice(R.position.start.offset, R.position.end.offset), te2);
      case "quoteDouble":
      case "quoteSingle": {
        let W2 = "'", X3 = '"', ue2 = te2.originalText.slice(R.position.start.offset + 1, R.position.end.offset - 1);
        if (R.type === "quoteSingle" && ue2.includes("\\") || R.type === "quoteDouble" && /\\[^"]/.test(ue2)) {
          let ie = R.type === "quoteDouble" ? X3 : W2;
          return [ie, Y3(R.type, ue2, te2), ie];
        }
        if (ue2.includes(X3))
          return [W2, Y3(R.type, R.type === "quoteDouble" ? ue2.replace(/\\"/g, X3).replace(/'/g, W2.repeat(2)) : ue2, te2), W2];
        if (ue2.includes(W2))
          return [X3, Y3(R.type, R.type === "quoteSingle" ? ue2.replace(/''/g, W2) : ue2, te2), X3];
        let De2 = te2.singleQuote ? W2 : X3;
        return [De2, Y3(R.type, ue2, te2), De2];
      }
      case "blockFolded":
      case "blockLiteral":
        return L(ee2, oe2, te2);
      case "mapping":
      case "sequence":
        return u(r, ee2.map(oe2, "children"));
      case "sequenceItem":
        return ["- ", l(2, R.content ? oe2("content") : "")];
      case "mappingKey":
      case "mappingValue":
        return R.content ? oe2("content") : "";
      case "mappingItem":
      case "flowMappingItem":
        return b2(R, Q, ee2, oe2, te2);
      case "flowMapping":
        return N(ee2, oe2, te2);
      case "flowSequence":
        return x2(ee2, oe2, te2);
      case "flowSequenceItem":
        return oe2("content");
      default:
        throw new Error("Unexpected node type ".concat(R.type));
    }
  }
  function $(R) {
    return R.body.children.length > 0 || k2(R.body);
  }
  function V(R, Q) {
    return I2(R) || Q && (Q.head.children.length > 0 || k2(Q.head));
  }
  function q(R, Q, ee2, te2) {
    return ee2.children[0] === R && /---(?:\s|$)/.test(te2.originalText.slice(h2(R), h2(R) + 4)) || R.head.children.length > 0 || k2(R.head) || I2(R.head) ? "head" : V(R, Q) ? false : Q ? "root" : false;
  }
  function Y3(R, Q, ee2) {
    let te2 = T2(R, Q, ee2);
    return u(r, te2.map((oe2) => s2(y(u(i2, oe2)))));
  }
  function H3(R, Q) {
    if (D2(Q))
      switch (delete Q.position, Q.type) {
        case "comment":
          if (f(Q.value))
            return null;
          break;
        case "quoteDouble":
        case "quoteSingle":
          Q.type = "quote";
          break;
      }
  }
  n.exports = { preprocess: F, embed: w2, print: M2, massageAstNode: H3, insertPragma: p };
} }), mg = Z({ "src/language-yaml/options.js"(e, n) {
  re();
  var t = Lt$1();
  n.exports = { bracketSpacing: t.bracketSpacing, singleQuote: t.singleQuote, proseWrap: t.proseWrap };
} }), dg = Z({ "src/language-yaml/parsers.js"() {
  re();
} }), gg = Z({ "node_modules/linguist-languages/data/YAML.json"(e, n) {
  n.exports = { name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "CITATION.cff", "glide.lock", "yarn.lock"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407 };
} }), yg = Z({ "src/language-yaml/index.js"(e, n) {
  re();
  var t = Tt$1(), s2 = Dg(), a3 = mg(), r = dg(), u = [t(gg(), (i2) => ({ since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: [...i2.filenames.filter((o) => o !== "yarn.lock"), ".prettierrc", ".stylelintrc"] }))];
  n.exports = { languages: u, printers: { yaml: s2 }, options: a3, parsers: r };
} }), hg = Z({ "src/languages.js"(e, n) {
  re(), n.exports = [Qm(), gd(), Sd(), _d(), Md(), sg(), yg()];
} }), vg = Z({ "src/standalone.js"(e, n) {
  re();
  var { version: t } = ca$1(), s2 = gm(), { getSupportInfo: a3 } = jn$2(), r = ym(), u = hg(), i2 = Oe();
  function o(y) {
    let m2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    return function() {
      for (var d4 = arguments.length, p = new Array(d4), f = 0; f < d4; f++)
        p[f] = arguments[f];
      let h2 = p[m2] || {}, w2 = h2.plugins || [];
      return p[m2] = Object.assign(Object.assign({}, h2), {}, { plugins: [...u, ...Array.isArray(w2) ? w2 : Object.values(w2)] }), y(...p);
    };
  }
  var c = o(s2.formatWithCursor);
  n.exports = { formatWithCursor: c, format(y, m2) {
    return c(y, m2).formatted;
  }, check(y, m2) {
    let { formatted: d4 } = c(y, m2);
    return d4 === y;
  }, doc: i2, getSupportInfo: o(a3, 0), version: t, util: r, __debug: { parse: o(s2.parse), formatAST: o(s2.formatAST), formatDoc: o(s2.formatDoc), printToDoc: o(s2.printToDoc), printDocToString: o(s2.printDocToString) } };
} }), Y0 = vg();
var b = (h2, u) => () => (u || h2((u = { exports: {} }).exports, u), u.exports);
var J = b((pf2, Gr2) => {
  var vt2 = function(h2) {
    return h2 && h2.Math == Math && h2;
  };
  Gr2.exports = vt2(typeof globalThis == "object" && globalThis) || vt2(typeof window == "object" && window) || vt2(typeof self == "object" && self) || vt2(typeof global == "object" && global) || function() {
    return this;
  }() || Function("return this")();
});
var be$2 = b((ff2, Xr) => {
  Xr.exports = function(h2) {
    try {
      return !!h2();
    } catch {
      return true;
    }
  };
});
var Me$2 = b((df2, Jr2) => {
  var Yh = be$2();
  Jr2.exports = !Yh(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] != 7;
  });
});
var St$1 = b((mf2, Yr2) => {
  var $h = be$2();
  Yr2.exports = !$h(function() {
    var h2 = function() {
    }.bind();
    return typeof h2 != "function" || h2.hasOwnProperty("prototype");
  });
});
var Nt$1 = b((yf2, $r2) => {
  var Qh = St$1(), wt2 = Function.prototype.call;
  $r2.exports = Qh ? wt2.bind(wt2) : function() {
    return wt2.apply(wt2, arguments);
  };
});
var ti$1 = b((ei) => {
  var Qr = {}.propertyIsEnumerable, Zr = Object.getOwnPropertyDescriptor, Zh = Zr && !Qr.call({ 1: 2 }, 1);
  ei.f = Zh ? function(u) {
    var p = Zr(this, u);
    return !!p && p.enumerable;
  } : Qr;
});
var ds$2 = b((gf2, si2) => {
  si2.exports = function(h2, u) {
    return { enumerable: !(h2 & 1), configurable: !(h2 & 2), writable: !(h2 & 4), value: u };
  };
});
var le$1 = b((Af2, ai2) => {
  var ri = St$1(), ii = Function.prototype, el2 = ii.bind, ms2 = ii.call, tl2 = ri && el2.bind(ms2, ms2);
  ai2.exports = ri ? function(h2) {
    return h2 && tl2(h2);
  } : function(h2) {
    return h2 && function() {
      return ms2.apply(h2, arguments);
    };
  };
});
var It = b((Pf2, oi) => {
  var ni2 = le$1(), sl2 = ni2({}.toString), rl2 = ni2("".slice);
  oi.exports = function(h2) {
    return rl2(sl2(h2), 8, -1);
  };
});
var li = b((Tf2, hi) => {
  var il2 = J(), al2 = le$1(), nl2 = be$2(), ol2 = It(), ys2 = il2.Object, hl2 = al2("".split);
  hi.exports = nl2(function() {
    return !ys2("z").propertyIsEnumerable(0);
  }) ? function(h2) {
    return ol2(h2) == "String" ? hl2(h2, "") : ys2(h2);
  } : ys2;
});
var xs$1 = b((Ef2, ui) => {
  var ll2 = J(), ul2 = ll2.TypeError;
  ui.exports = function(h2) {
    if (h2 == null)
      throw ul2("Can't call method on " + h2);
    return h2;
  };
});
var kt$1 = b((bf2, ci2) => {
  var cl2 = li(), pl2 = xs$1();
  ci2.exports = function(h2) {
    return cl2(pl2(h2));
  };
});
var ue$2 = b((Cf, pi) => {
  pi.exports = function(h2) {
    return typeof h2 == "function";
  };
});
var Re$2 = b((vf2, fi2) => {
  var fl2 = ue$2();
  fi2.exports = function(h2) {
    return typeof h2 == "object" ? h2 !== null : fl2(h2);
  };
});
var rt$1 = b((Sf2, di2) => {
  var gs2 = J(), dl2 = ue$2(), ml2 = function(h2) {
    return dl2(h2) ? h2 : void 0;
  };
  di2.exports = function(h2, u) {
    return arguments.length < 2 ? ml2(gs2[h2]) : gs2[h2] && gs2[h2][u];
  };
});
var yi = b((wf2, mi) => {
  var yl2 = le$1();
  mi.exports = yl2({}.isPrototypeOf);
});
var gi = b((Nf, xi) => {
  var xl2 = rt$1();
  xi.exports = xl2("navigator", "userAgent") || "";
});
var vi = b((If2, Ci) => {
  var bi2 = J(), As2 = gi(), Ai2 = bi2.process, Pi2 = bi2.Deno, Ti = Ai2 && Ai2.versions || Pi2 && Pi2.version, Ei2 = Ti && Ti.v8, fe2, Dt2;
  Ei2 && (fe2 = Ei2.split("."), Dt2 = fe2[0] > 0 && fe2[0] < 4 ? 1 : +(fe2[0] + fe2[1]));
  !Dt2 && As2 && (fe2 = As2.match(/Edge\/(\d+)/), (!fe2 || fe2[1] >= 74) && (fe2 = As2.match(/Chrome\/(\d+)/), fe2 && (Dt2 = +fe2[1])));
  Ci.exports = Dt2;
});
var Ps$1 = b((kf2, wi) => {
  var Si2 = vi(), gl2 = be$2();
  wi.exports = !!Object.getOwnPropertySymbols && !gl2(function() {
    var h2 = Symbol();
    return !String(h2) || !(Object(h2) instanceof Symbol) || !Symbol.sham && Si2 && Si2 < 41;
  });
});
var Ts$1 = b((Df, Ni2) => {
  var Al2 = Ps$1();
  Ni2.exports = Al2 && !Symbol.sham && typeof Symbol.iterator == "symbol";
});
var Es$2 = b((Ff, Ii2) => {
  var Pl2 = J(), Tl2 = rt$1(), El2 = ue$2(), bl2 = yi(), Cl2 = Ts$1(), vl2 = Pl2.Object;
  Ii2.exports = Cl2 ? function(h2) {
    return typeof h2 == "symbol";
  } : function(h2) {
    var u = Tl2("Symbol");
    return El2(u) && bl2(u.prototype, vl2(h2));
  };
});
var Di = b((Lf, ki) => {
  var Sl2 = J(), wl2 = Sl2.String;
  ki.exports = function(h2) {
    try {
      return wl2(h2);
    } catch {
      return "Object";
    }
  };
});
var Ft$1 = b((Of2, Fi) => {
  var Nl2 = J(), Il2 = ue$2(), kl2 = Di(), Dl2 = Nl2.TypeError;
  Fi.exports = function(h2) {
    if (Il2(h2))
      return h2;
    throw Dl2(kl2(h2) + " is not a function");
  };
});
var Oi = b((Bf, Li) => {
  var Fl2 = Ft$1();
  Li.exports = function(h2, u) {
    var p = h2[u];
    return p == null ? void 0 : Fl2(p);
  };
});
var Mi$1 = b((Mf2, Bi2) => {
  var Ll2 = J(), bs2 = Nt$1(), Cs2 = ue$2(), vs2 = Re$2(), Ol2 = Ll2.TypeError;
  Bi2.exports = function(h2, u) {
    var p, d4;
    if (u === "string" && Cs2(p = h2.toString) && !vs2(d4 = bs2(p, h2)) || Cs2(p = h2.valueOf) && !vs2(d4 = bs2(p, h2)) || u !== "string" && Cs2(p = h2.toString) && !vs2(d4 = bs2(p, h2)))
      return d4;
    throw Ol2("Can't convert object to primitive value");
  };
});
var ji = b((Rf2, Ri2) => {
  Ri2.exports = false;
});
var Lt = b((jf, Ui2) => {
  var qi = J(), Bl2 = Object.defineProperty;
  Ui2.exports = function(h2, u) {
    try {
      Bl2(qi, h2, { value: u, configurable: true, writable: true });
    } catch {
      qi[h2] = u;
    }
    return u;
  };
});
var Ot$1 = b((qf2, zi2) => {
  var Ml2 = J(), Rl2 = Lt(), _i = "__core-js_shared__", jl2 = Ml2[_i] || Rl2(_i, {});
  zi2.exports = jl2;
});
var Ss$1 = b((Uf2, Vi) => {
  var ql2 = ji(), Ki2 = Ot$1();
  (Vi.exports = function(h2, u) {
    return Ki2[h2] || (Ki2[h2] = u !== void 0 ? u : {});
  })("versions", []).push({ version: "3.22.2", mode: ql2 ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.22.2/LICENSE", source: "https://github.com/zloirock/core-js" });
});
var ws$1 = b((_f2, Hi) => {
  var Ul2 = J(), _l2 = xs$1(), zl2 = Ul2.Object;
  Hi.exports = function(h2) {
    return zl2(_l2(h2));
  };
});
var Ie$1 = b((zf2, Wi) => {
  var Kl2 = le$1(), Vl2 = ws$1(), Hl2 = Kl2({}.hasOwnProperty);
  Wi.exports = Object.hasOwn || function(u, p) {
    return Hl2(Vl2(u), p);
  };
});
var Ns$1 = b((Kf2, Gi2) => {
  var Wl2 = le$1(), Gl2 = 0, Xl2 = Math.random(), Jl2 = Wl2(1 .toString);
  Gi2.exports = function(h2) {
    return "Symbol(" + (h2 === void 0 ? "" : h2) + ")_" + Jl2(++Gl2 + Xl2, 36);
  };
});
var it$1 = b((Vf2, Qi2) => {
  var Yl2 = J(), $l2 = Ss$1(), Xi = Ie$1(), Ql2 = Ns$1(), Ji2 = Ps$1(), $i2 = Ts$1(), Xe2 = $l2("wks"), je2 = Yl2.Symbol, Yi2 = je2 && je2.for, Zl2 = $i2 ? je2 : je2 && je2.withoutSetter || Ql2;
  Qi2.exports = function(h2) {
    if (!Xi(Xe2, h2) || !(Ji2 || typeof Xe2[h2] == "string")) {
      var u = "Symbol." + h2;
      Ji2 && Xi(je2, h2) ? Xe2[h2] = je2[h2] : $i2 && Yi2 ? Xe2[h2] = Yi2(u) : Xe2[h2] = Zl2(u);
    }
    return Xe2[h2];
  };
});
var sa = b((Hf2, ta2) => {
  var eu2 = J(), tu = Nt$1(), Zi2 = Re$2(), ea2 = Es$2(), su2 = Oi(), ru = Mi$1(), iu = it$1(), au2 = eu2.TypeError, nu = iu("toPrimitive");
  ta2.exports = function(h2, u) {
    if (!Zi2(h2) || ea2(h2))
      return h2;
    var p = su2(h2, nu), d4;
    if (p) {
      if (u === void 0 && (u = "default"), d4 = tu(p, h2, u), !Zi2(d4) || ea2(d4))
        return d4;
      throw au2("Can't convert object to primitive value");
    }
    return u === void 0 && (u = "number"), ru(h2, u);
  };
});
var Is$1 = b((Wf2, ra2) => {
  var ou = sa(), hu = Es$2();
  ra2.exports = function(h2) {
    var u = ou(h2, "string");
    return hu(u) ? u : u + "";
  };
});
var na = b((Gf2, aa2) => {
  var lu = J(), ia2 = Re$2(), ks2 = lu.document, uu = ia2(ks2) && ia2(ks2.createElement);
  aa2.exports = function(h2) {
    return uu ? ks2.createElement(h2) : {};
  };
});
var Ds$2 = b((Xf2, oa2) => {
  var cu = Me$2(), pu = be$2(), fu2 = na();
  oa2.exports = !cu && !pu(function() {
    return Object.defineProperty(fu2("div"), "a", { get: function() {
      return 7;
    } }).a != 7;
  });
});
var Fs$1 = b((la2) => {
  var du2 = Me$2(), mu = Nt$1(), yu = ti$1(), xu2 = ds$2(), gu = kt$1(), Au2 = Is$1(), Pu = Ie$1(), Tu = Ds$2(), ha2 = Object.getOwnPropertyDescriptor;
  la2.f = du2 ? ha2 : function(u, p) {
    if (u = gu(u), p = Au2(p), Tu)
      try {
        return ha2(u, p);
      } catch {
      }
    if (Pu(u, p))
      return xu2(!mu(yu.f, u, p), u[p]);
  };
});
var ca = b((Yf2, ua2) => {
  var Eu = Me$2(), bu = be$2();
  ua2.exports = Eu && bu(function() {
    return Object.defineProperty(function() {
    }, "prototype", { value: 42, writable: false }).prototype != 42;
  });
});
var Ls$1 = b(($f2, fa2) => {
  var pa2 = J(), Cu2 = Re$2(), vu = pa2.String, Su2 = pa2.TypeError;
  fa2.exports = function(h2) {
    if (Cu2(h2))
      return h2;
    throw Su2(vu(h2) + " is not an object");
  };
});
var js$1 = b((ma2) => {
  var wu2 = J(), Nu = Me$2(), Iu = Ds$2(), ku2 = ca(), Bt = Ls$1(), da2 = Is$1(), Du = wu2.TypeError, Os2 = Object.defineProperty, Fu = Object.getOwnPropertyDescriptor, Bs2 = "enumerable", Ms2 = "configurable", Rs2 = "writable";
  ma2.f = Nu ? ku2 ? function(u, p, d4) {
    if (Bt(u), p = da2(p), Bt(d4), typeof u == "function" && p === "prototype" && "value" in d4 && Rs2 in d4 && !d4[Rs2]) {
      var m2 = Fu(u, p);
      m2 && m2[Rs2] && (u[p] = d4.value, d4 = { configurable: Ms2 in d4 ? d4[Ms2] : m2[Ms2], enumerable: Bs2 in d4 ? d4[Bs2] : m2[Bs2], writable: false });
    }
    return Os2(u, p, d4);
  } : Os2 : function(u, p, d4) {
    if (Bt(u), p = da2(p), Bt(d4), Iu)
      try {
        return Os2(u, p, d4);
      } catch {
      }
    if ("get" in d4 || "set" in d4)
      throw Du("Accessors not supported");
    return "value" in d4 && (u[p] = d4.value), u;
  };
});
var Mt = b((Zf2, ya2) => {
  var Lu = Me$2(), Ou = js$1(), Bu2 = ds$2();
  ya2.exports = Lu ? function(h2, u, p) {
    return Ou.f(h2, u, Bu2(1, p));
  } : function(h2, u, p) {
    return h2[u] = p, h2;
  };
});
var Rt = b((ed2, xa2) => {
  var Mu2 = le$1(), Ru = ue$2(), qs2 = Ot$1(), ju = Mu2(Function.toString);
  Ru(qs2.inspectSource) || (qs2.inspectSource = function(h2) {
    return ju(h2);
  });
  xa2.exports = qs2.inspectSource;
});
var Pa = b((td2, Aa2) => {
  var qu2 = J(), Uu = ue$2(), _u = Rt(), ga2 = qu2.WeakMap;
  Aa2.exports = Uu(ga2) && /native code/.test(_u(ga2));
});
var ba = b((sd2, Ea2) => {
  var zu = Ss$1(), Ku = Ns$1(), Ta2 = zu("keys");
  Ea2.exports = function(h2) {
    return Ta2[h2] || (Ta2[h2] = Ku(h2));
  };
});
var Us$1 = b((rd2, Ca2) => {
  Ca2.exports = {};
});
var ka = b((id2, Ia2) => {
  var Vu2 = Pa(), Na2 = J(), _s2 = le$1(), Hu2 = Re$2(), Wu2 = Mt(), zs2 = Ie$1(), Ks2 = Ot$1(), Gu = ba(), Xu = Us$1(), va2 = "Object already initialized", Hs2 = Na2.TypeError, Ju2 = Na2.WeakMap, jt2, at2, qt2, Yu = function(h2) {
    return qt2(h2) ? at2(h2) : jt2(h2, {});
  }, $u2 = function(h2) {
    return function(u) {
      var p;
      if (!Hu2(u) || (p = at2(u)).type !== h2)
        throw Hs2("Incompatible receiver, " + h2 + " required");
      return p;
    };
  };
  Vu2 || Ks2.state ? (ke2 = Ks2.state || (Ks2.state = new Ju2()), Sa2 = _s2(ke2.get), Vs2 = _s2(ke2.has), wa2 = _s2(ke2.set), jt2 = function(h2, u) {
    if (Vs2(ke2, h2))
      throw new Hs2(va2);
    return u.facade = h2, wa2(ke2, h2, u), u;
  }, at2 = function(h2) {
    return Sa2(ke2, h2) || {};
  }, qt2 = function(h2) {
    return Vs2(ke2, h2);
  }) : (qe2 = Gu("state"), Xu[qe2] = true, jt2 = function(h2, u) {
    if (zs2(h2, qe2))
      throw new Hs2(va2);
    return u.facade = h2, Wu2(h2, qe2, u), u;
  }, at2 = function(h2) {
    return zs2(h2, qe2) ? h2[qe2] : {};
  }, qt2 = function(h2) {
    return zs2(h2, qe2);
  });
  var ke2, Sa2, Vs2, wa2, qe2;
  Ia2.exports = { set: jt2, get: at2, has: qt2, enforce: Yu, getterFor: $u2 };
});
var La = b((ad2, Fa2) => {
  var Ws2 = Me$2(), Qu2 = Ie$1(), Da2 = Function.prototype, Zu = Ws2 && Object.getOwnPropertyDescriptor, Gs2 = Qu2(Da2, "name"), ec2 = Gs2 && function() {
  }.name === "something", tc2 = Gs2 && (!Ws2 || Ws2 && Zu(Da2, "name").configurable);
  Fa2.exports = { EXISTS: Gs2, PROPER: ec2, CONFIGURABLE: tc2 };
});
var ja = b((nd2, Ra2) => {
  var sc2 = J(), Oa2 = ue$2(), rc2 = Ie$1(), Ba2 = Mt(), ic = Lt(), ac = Rt(), Ma2 = ka(), nc2 = La().CONFIGURABLE, oc = Ma2.get, hc = Ma2.enforce, lc = String(String).split("String");
  (Ra2.exports = function(h2, u, p, d4) {
    var m2 = d4 ? !!d4.unsafe : false, x2 = d4 ? !!d4.enumerable : false, A2 = d4 ? !!d4.noTargetGet : false, g2 = d4 && d4.name !== void 0 ? d4.name : u, E;
    if (Oa2(p) && (String(g2).slice(0, 7) === "Symbol(" && (g2 = "[" + String(g2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!rc2(p, "name") || nc2 && p.name !== g2) && Ba2(p, "name", g2), E = hc(p), E.source || (E.source = lc.join(typeof g2 == "string" ? g2 : ""))), h2 === sc2) {
      x2 ? h2[u] = p : ic(u, p);
      return;
    } else
      m2 ? !A2 && h2[u] && (x2 = true) : delete h2[u];
    x2 ? h2[u] = p : Ba2(h2, u, p);
  })(Function.prototype, "toString", function() {
    return Oa2(this) && oc(this).source || ac(this);
  });
});
var Xs$1 = b((od2, qa2) => {
  var uc2 = Math.ceil, cc = Math.floor;
  qa2.exports = function(h2) {
    var u = +h2;
    return u !== u || u === 0 ? 0 : (u > 0 ? cc : uc2)(u);
  };
});
var _a = b((hd2, Ua2) => {
  var pc = Xs$1(), fc = Math.max, dc = Math.min;
  Ua2.exports = function(h2, u) {
    var p = pc(h2);
    return p < 0 ? fc(p + u, 0) : dc(p, u);
  };
});
var Ka = b((ld2, za2) => {
  var mc = Xs$1(), yc = Math.min;
  za2.exports = function(h2) {
    return h2 > 0 ? yc(mc(h2), 9007199254740991) : 0;
  };
});
var Ut = b((ud2, Va2) => {
  var xc = Ka();
  Va2.exports = function(h2) {
    return xc(h2.length);
  };
});
var Ga = b((cd2, Wa2) => {
  var gc = kt$1(), Ac = _a(), Pc2 = Ut(), Ha2 = function(h2) {
    return function(u, p, d4) {
      var m2 = gc(u), x2 = Pc2(m2), A2 = Ac(d4, x2), g2;
      if (h2 && p != p) {
        for (; x2 > A2; )
          if (g2 = m2[A2++], g2 != g2)
            return true;
      } else
        for (; x2 > A2; A2++)
          if ((h2 || A2 in m2) && m2[A2] === p)
            return h2 || A2 || 0;
      return !h2 && -1;
    };
  };
  Wa2.exports = { includes: Ha2(true), indexOf: Ha2(false) };
});
var Ya = b((pd2, Ja2) => {
  var Tc = le$1(), Js2 = Ie$1(), Ec = kt$1(), bc = Ga().indexOf, Cc = Us$1(), Xa2 = Tc([].push);
  Ja2.exports = function(h2, u) {
    var p = Ec(h2), d4 = 0, m2 = [], x2;
    for (x2 in p)
      !Js2(Cc, x2) && Js2(p, x2) && Xa2(m2, x2);
    for (; u.length > d4; )
      Js2(p, x2 = u[d4++]) && (~bc(m2, x2) || Xa2(m2, x2));
    return m2;
  };
});
var Qa = b((fd2, $a2) => {
  $a2.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
});
var en = b((Za2) => {
  var vc = Ya(), Sc = Qa(), wc = Sc.concat("length", "prototype");
  Za2.f = Object.getOwnPropertyNames || function(u) {
    return vc(u, wc);
  };
});
var sn$1 = b((tn) => {
  tn.f = Object.getOwnPropertySymbols;
});
var an = b((yd2, rn2) => {
  var Nc = rt$1(), Ic = le$1(), kc2 = en(), Dc = sn$1(), Fc = Ls$1(), Lc2 = Ic([].concat);
  rn2.exports = Nc("Reflect", "ownKeys") || function(u) {
    var p = kc2.f(Fc(u)), d4 = Dc.f;
    return d4 ? Lc2(p, d4(u)) : p;
  };
});
var hn$2 = b((xd2, on2) => {
  var nn2 = Ie$1(), Oc = an(), Bc = Fs$1(), Mc2 = js$1();
  on2.exports = function(h2, u, p) {
    for (var d4 = Oc(u), m2 = Mc2.f, x2 = Bc.f, A2 = 0; A2 < d4.length; A2++) {
      var g2 = d4[A2];
      !nn2(h2, g2) && !(p && nn2(p, g2)) && m2(h2, g2, x2(u, g2));
    }
  };
});
var un$1 = b((gd2, ln) => {
  var Rc = be$2(), jc2 = ue$2(), qc = /#|\.prototype\./, nt = function(h2, u) {
    var p = _c2[Uc2(h2)];
    return p == Kc2 ? true : p == zc2 ? false : jc2(u) ? Rc(u) : !!u;
  }, Uc2 = nt.normalize = function(h2) {
    return String(h2).replace(qc, ".").toLowerCase();
  }, _c2 = nt.data = {}, zc2 = nt.NATIVE = "N", Kc2 = nt.POLYFILL = "P";
  ln.exports = nt;
});
var $s$1 = b((Ad2, cn) => {
  var Ys2 = J(), Vc2 = Fs$1().f, Hc2 = Mt(), Wc2 = ja(), Gc2 = Lt(), Xc2 = hn$2(), Jc2 = un$1();
  cn.exports = function(h2, u) {
    var p = h2.target, d4 = h2.global, m2 = h2.stat, x2, A2, g2, E, F, D2;
    if (d4 ? A2 = Ys2 : m2 ? A2 = Ys2[p] || Gc2(p, {}) : A2 = (Ys2[p] || {}).prototype, A2)
      for (g2 in u) {
        if (F = u[g2], h2.noTargetGet ? (D2 = Vc2(A2, g2), E = D2 && D2.value) : E = A2[g2], x2 = Jc2(d4 ? g2 : p + (m2 ? "." : "#") + g2, h2.forced), !x2 && E !== void 0) {
          if (typeof F == typeof E)
            continue;
          Xc2(F, E);
        }
        (h2.sham || E && E.sham) && Hc2(F, "sham", true), Wc2(A2, g2, F, h2);
      }
  };
});
var pn = b(() => {
  var Yc2 = $s$1(), $c2 = J();
  Yc2({ global: true }, { globalThis: $c2 });
});
var Qs$1 = b((Ed2, fn2) => {
  var Qc2 = It();
  fn2.exports = Array.isArray || function(u) {
    return Qc2(u) == "Array";
  };
});
var yn = b((bd2, mn2) => {
  var dn2 = le$1(), Zc2 = Ft$1(), ep = St$1(), tp = dn2(dn2.bind);
  mn2.exports = function(h2, u) {
    return Zc2(h2), u === void 0 ? h2 : ep ? tp(h2, u) : function() {
      return h2.apply(u, arguments);
    };
  };
});
var An = b((Cd2, gn2) => {
  var sp = J(), rp = Qs$1(), ip = Ut(), ap = yn(), np = sp.TypeError, xn2 = function(h2, u, p, d4, m2, x2, A2, g2) {
    for (var E = m2, F = 0, D2 = A2 ? ap(A2, g2) : false, C2, M2; F < d4; ) {
      if (F in p) {
        if (C2 = D2 ? D2(p[F], F, u) : p[F], x2 > 0 && rp(C2))
          M2 = ip(C2), E = xn2(h2, u, C2, M2, E, x2 - 1) - 1;
        else {
          if (E >= 9007199254740991)
            throw np("Exceed the acceptable array length");
          h2[E] = C2;
        }
        E++;
      }
      F++;
    }
    return E;
  };
  gn2.exports = xn2;
});
var En$1 = b((vd2, Tn2) => {
  var op = it$1(), hp = op("toStringTag"), Pn2 = {};
  Pn2[hp] = "z";
  Tn2.exports = String(Pn2) === "[object z]";
});
var Cn = b((Sd2, bn2) => {
  var lp = J(), up = En$1(), cp = ue$2(), _t2 = It(), pp = it$1(), fp = pp("toStringTag"), dp = lp.Object, mp = _t2(function() {
    return arguments;
  }()) == "Arguments", yp = function(h2, u) {
    try {
      return h2[u];
    } catch {
    }
  };
  bn2.exports = up ? _t2 : function(h2) {
    var u, p, d4;
    return h2 === void 0 ? "Undefined" : h2 === null ? "Null" : typeof (p = yp(u = dp(h2), fp)) == "string" ? p : mp ? _t2(u) : (d4 = _t2(u)) == "Object" && cp(u.callee) ? "Arguments" : d4;
  };
});
var kn$1 = b((wd2, In2) => {
  var xp = le$1(), gp = be$2(), vn2 = ue$2(), Ap = Cn(), Pp = rt$1(), Tp = Rt(), Sn2 = function() {
  }, Ep = [], wn2 = Pp("Reflect", "construct"), Zs2 = /^\s*(?:class|function)\b/, bp = xp(Zs2.exec), Cp = !Zs2.exec(Sn2), ot2 = function(u) {
    if (!vn2(u))
      return false;
    try {
      return wn2(Sn2, Ep, u), true;
    } catch {
      return false;
    }
  }, Nn2 = function(u) {
    if (!vn2(u))
      return false;
    switch (Ap(u)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return false;
    }
    try {
      return Cp || !!bp(Zs2, Tp(u));
    } catch {
      return true;
    }
  };
  Nn2.sham = true;
  In2.exports = !wn2 || gp(function() {
    var h2;
    return ot2(ot2.call) || !ot2(Object) || !ot2(function() {
      h2 = true;
    }) || h2;
  }) ? Nn2 : ot2;
});
var On$2 = b((Nd2, Ln2) => {
  var vp = J(), Dn = Qs$1(), Sp = kn$1(), wp = Re$2(), Np = it$1(), Ip = Np("species"), Fn2 = vp.Array;
  Ln2.exports = function(h2) {
    var u;
    return Dn(h2) && (u = h2.constructor, Sp(u) && (u === Fn2 || Dn(u.prototype)) ? u = void 0 : wp(u) && (u = u[Ip], u === null && (u = void 0))), u === void 0 ? Fn2 : u;
  };
});
var Mn = b((Id2, Bn2) => {
  var kp = On$2();
  Bn2.exports = function(h2, u) {
    return new (kp(h2))(u === 0 ? 0 : u);
  };
});
pn();
var Dp = $s$1(), Fp = An(), Lp = Ft$1(), Op = ws$1(), Bp = Ut(), Mp = Mn();
Dp({ target: "Array", proto: true }, { flatMap: function(u) {
  var p = Op(this), d4 = Bp(p), m2;
  return Lp(u), m2 = Mp(p, 0), m2.length = Fp(m2, p, p, d4, 0, 1, u, arguments.length > 1 ? arguments[1] : void 0), m2;
} });
var Rn, jn$1, qn, Un, _n;
function ht$1(h2, u) {
  return u || (u = h2.slice(0)), Object.freeze(Object.defineProperties(h2, { raw: { value: Object.freeze(u) } }));
}
var rr$1 = Object.defineProperty, Rp = Object.getOwnPropertyDescriptor, ir$2 = Object.getOwnPropertyNames, jp = Object.prototype.hasOwnProperty, zn$1 = (h2, u) => function() {
  return h2 && (u = (0, h2[ir$2(h2)[0]])(h2 = 0)), u;
}, W = (h2, u) => function() {
  return u || (0, h2[ir$2(h2)[0]])((u = { exports: {} }).exports, u), u.exports;
}, qp = (h2, u) => {
  for (var p in u)
    rr$1(h2, p, { get: u[p], enumerable: true });
}, Up = (h2, u, p, d4) => {
  if (u && typeof u == "object" || typeof u == "function")
    for (let m2 of ir$2(u))
      !jp.call(h2, m2) && m2 !== p && rr$1(h2, m2, { get: () => u[m2], enumerable: !(d4 = Rp(u, m2)) || d4.enumerable });
  return h2;
}, _p = (h2) => Up(rr$1({}, "__esModule", { value: true }), h2), H = zn$1({ "<define:process>"() {
} }), zp = W({ "src/utils/try-combinations.js"(h2, u) {
  H();
  function p() {
    let d4;
    for (var m2 = arguments.length, x2 = new Array(m2), A2 = 0; A2 < m2; A2++)
      x2[A2] = arguments[A2];
    for (let [g2, E] of x2.entries())
      try {
        return { result: E() };
      } catch (F) {
        g2 === 0 && (d4 = F);
      }
    return { error: d4 };
  }
  u.exports = p;
} }), Kn$1 = W({ "src/language-js/utils/get-shebang.js"(h2, u) {
  H();
  function p(d4) {
    if (!d4.startsWith("#!"))
      return "";
    let m2 = d4.indexOf(`
`);
    return m2 === -1 ? d4 : d4.slice(0, m2);
  }
  u.exports = p;
} }), Kp = W({ "src/utils/text/skip-inline-comment.js"(h2, u) {
  H();
  function p(d4, m2) {
    if (m2 === false)
      return false;
    if (d4.charAt(m2) === "/" && d4.charAt(m2 + 1) === "*") {
      for (let x2 = m2 + 2; x2 < d4.length; ++x2)
        if (d4.charAt(x2) === "*" && d4.charAt(x2 + 1) === "/")
          return x2 + 2;
    }
    return m2;
  }
  u.exports = p;
} }), Vp = W({ "src/utils/text/skip-newline.js"(h2, u) {
  H();
  function p(d4, m2, x2) {
    let A2 = x2 && x2.backwards;
    if (m2 === false)
      return false;
    let g2 = d4.charAt(m2);
    if (A2) {
      if (d4.charAt(m2 - 1) === "\r" && g2 === `
`)
        return m2 - 2;
      if (g2 === `
` || g2 === "\r" || g2 === "\u2028" || g2 === "\u2029")
        return m2 - 1;
    } else {
      if (g2 === "\r" && d4.charAt(m2 + 1) === `
`)
        return m2 + 2;
      if (g2 === `
` || g2 === "\r" || g2 === "\u2028" || g2 === "\u2029")
        return m2 + 1;
    }
    return m2;
  }
  u.exports = p;
} }), Vn = W({ "src/utils/text/skip.js"(h2, u) {
  H();
  function p(g2) {
    return (E, F, D2) => {
      let C2 = D2 && D2.backwards;
      if (F === false)
        return false;
      let { length: M2 } = E, L = F;
      for (; L >= 0 && L < M2; ) {
        let k2 = E.charAt(L);
        if (g2 instanceof RegExp) {
          if (!g2.test(k2))
            return L;
        } else if (!g2.includes(k2))
          return L;
        C2 ? L-- : L++;
      }
      return L === -1 || L === M2 ? L : false;
    };
  }
  var d4 = p(/\s/), m2 = p(" 	"), x2 = p(",; 	"), A2 = p(/[^\n\r]/);
  u.exports = { skipWhitespace: d4, skipSpaces: m2, skipToLineEnd: x2, skipEverythingButNewLine: A2 };
} }), Hp = W({ "src/utils/text/skip-trailing-comment.js"(h2, u) {
  H();
  var { skipEverythingButNewLine: p } = Vn();
  function d4(m2, x2) {
    return x2 === false ? false : m2.charAt(x2) === "/" && m2.charAt(x2 + 1) === "/" ? p(m2, x2) : x2;
  }
  u.exports = d4;
} }), Wp = W({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(h2, u) {
  H();
  var p = Kp(), d4 = Vp(), m2 = Hp(), { skipSpaces: x2 } = Vn();
  function A2(g2, E) {
    let F = null, D2 = E;
    for (; D2 !== F; )
      F = D2, D2 = x2(g2, D2), D2 = p(g2, D2), D2 = m2(g2, D2), D2 = d4(g2, D2);
    return D2;
  }
  u.exports = A2;
} }), Hn$2 = {};
qp(Hn$2, { EOL: () => sr$1, arch: () => Gp, cpus: () => Qn$1, default: () => ro$1, endianness: () => Wn$2, freemem: () => Yn$2, getNetworkInterfaces: () => so$1, hostname: () => Gn$1, loadavg: () => Xn$1, networkInterfaces: () => to$1, platform: () => Xp, release: () => eo$1, tmpDir: () => er$1, tmpdir: () => tr, totalmem: () => $n, type: () => Zn$1, uptime: () => Jn$1 });
function Wn$2() {
  if (typeof zt > "u") {
    var h2 = new ArrayBuffer(2), u = new Uint8Array(h2), p = new Uint16Array(h2);
    if (u[0] = 1, u[1] = 2, p[0] === 258)
      zt = "BE";
    else if (p[0] === 513)
      zt = "LE";
    else
      throw new Error("unable to figure out endianess");
  }
  return zt;
}
function Gn$1() {
  return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
}
function Xn$1() {
  return [];
}
function Jn$1() {
  return 0;
}
function Yn$2() {
  return Number.MAX_VALUE;
}
function $n() {
  return Number.MAX_VALUE;
}
function Qn$1() {
  return [];
}
function Zn$1() {
  return "Browser";
}
function eo$1() {
  return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
}
function to$1() {
}
function so$1() {
}
function Gp() {
  return "javascript";
}
function Xp() {
  return "browser";
}
function er$1() {
  return "/tmp";
}
var zt, tr, sr$1, ro$1, Jp$1 = zn$1({ "node-modules-polyfills:os"() {
  H(), tr = er$1, sr$1 = `
`, ro$1 = { EOL: sr$1, tmpdir: tr, tmpDir: er$1, networkInterfaces: to$1, getNetworkInterfaces: so$1, release: eo$1, type: Zn$1, cpus: Qn$1, totalmem: $n, freemem: Yn$2, uptime: Jn$1, loadavg: Xn$1, hostname: Gn$1, endianness: Wn$2 };
} }), Yp = W({ "node-modules-polyfills-commonjs:os"(h2, u) {
  H();
  var p = (Jp$1(), _p(Hn$2));
  if (p && p.default) {
    u.exports = p.default;
    for (let d4 in p)
      u.exports[d4] = p[d4];
  } else
    p && (u.exports = p);
} }), $p = W({ "node_modules/detect-newline/index.js"(h2, u) {
  H();
  var p = (d4) => {
    if (typeof d4 != "string")
      throw new TypeError("Expected a string");
    let m2 = d4.match(/(?:\r?\n)/g) || [];
    if (m2.length === 0)
      return;
    let x2 = m2.filter((g2) => g2 === `\r
`).length, A2 = m2.length - x2;
    return x2 > A2 ? `\r
` : `
`;
  };
  u.exports = p, u.exports.graceful = (d4) => typeof d4 == "string" && p(d4) || `
`;
} }), Qp = W({ "node_modules/jest-docblock/build/index.js"(h2) {
  H(), Object.defineProperty(h2, "__esModule", { value: true }), h2.extract = L, h2.parse = G, h2.parseWithComments = Z3, h2.print = B, h2.strip = k2;
  function u() {
    let l = Yp();
    return u = function() {
      return l;
    }, l;
  }
  function p() {
    let l = d4($p());
    return p = function() {
      return l;
    }, l;
  }
  function d4(l) {
    return l && l.__esModule ? l : { default: l };
  }
  var m2 = /\*\/$/, x2 = /^\/\*\*/, A2 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, g2 = /(^|\s+)\/\/([^\r\n]*)/g, E = /^(\r?\n)+/, F = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, D2 = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, C2 = /(\r?\n|^) *\* ?/g, M2 = [];
  function L(l) {
    let Y3 = l.match(A2);
    return Y3 ? Y3[0].trimLeft() : "";
  }
  function k2(l) {
    let Y3 = l.match(A2);
    return Y3 && Y3[0] ? l.substring(Y3[0].length) : l;
  }
  function G(l) {
    return Z3(l).pragmas;
  }
  function Z3(l) {
    let Y3 = (0, p().default)(l) || u().EOL;
    l = l.replace(x2, "").replace(m2, "").replace(C2, "$1");
    let ie = "";
    for (; ie !== l; )
      ie = l, l = l.replace(F, "".concat(Y3, "$1 $2").concat(Y3));
    l = l.replace(E, "").trimRight();
    let Q = /* @__PURE__ */ Object.create(null), Ce2 = l.replace(D2, "").replace(E, "").trimRight(), ee2;
    for (; ee2 = D2.exec(l); ) {
      let U = ee2[2].replace(g2, "");
      typeof Q[ee2[1]] == "string" || Array.isArray(Q[ee2[1]]) ? Q[ee2[1]] = M2.concat(Q[ee2[1]], U) : Q[ee2[1]] = U;
    }
    return { comments: Ce2, pragmas: Q };
  }
  function B(l) {
    let { comments: Y3 = "", pragmas: ie = {} } = l, Q = (0, p().default)(Y3) || u().EOL, Ce2 = "/**", ee2 = " *", U = " */", O2 = Object.keys(ie), P = O2.map((V) => j(V, ie[V])).reduce((V, $) => V.concat($), []).map((V) => ee2 + " " + V + Q).join("");
    if (!Y3) {
      if (O2.length === 0)
        return "";
      if (O2.length === 1 && !Array.isArray(ie[O2[0]])) {
        let V = ie[O2[0]];
        return "".concat(Ce2, " ").concat(j(O2[0], V)[0]).concat(U);
      }
    }
    let De2 = Y3.split(Q).map((V) => "".concat(ee2, " ").concat(V)).join(Q) + Q;
    return Ce2 + Q + (Y3 ? De2 : "") + (Y3 && O2.length ? ee2 + Q : "") + P + U;
  }
  function j(l, Y3) {
    return M2.concat(Y3).map((ie) => "@".concat(l, " ").concat(ie).trim());
  }
} }), Zp = W({ "src/common/end-of-line.js"(h2, u) {
  H();
  function p(A2) {
    let g2 = A2.indexOf("\r");
    return g2 >= 0 ? A2.charAt(g2 + 1) === `
` ? "crlf" : "cr" : "lf";
  }
  function d4(A2) {
    switch (A2) {
      case "cr":
        return "\r";
      case "crlf":
        return `\r
`;
      default:
        return `
`;
    }
  }
  function m2(A2, g2) {
    let E;
    switch (g2) {
      case `
`:
        E = /\n/g;
        break;
      case "\r":
        E = /\r/g;
        break;
      case `\r
`:
        E = /\r\n/g;
        break;
      default:
        throw new Error('Unexpected "eol" '.concat(JSON.stringify(g2), "."));
    }
    let F = A2.match(E);
    return F ? F.length : 0;
  }
  function x2(A2) {
    return A2.replace(/\r\n?/g, `
`);
  }
  u.exports = { guessEndOfLine: p, convertEndOfLineToChars: d4, countEndOfLineChars: m2, normalizeEndOfLine: x2 };
} }), ef$1 = W({ "src/language-js/pragma.js"(h2, u) {
  H();
  var { parseWithComments: p, strip: d4, extract: m2, print: x2 } = Qp(), { normalizeEndOfLine: A2 } = Zp(), g2 = Kn$1();
  function E(C2) {
    let M2 = g2(C2);
    M2 && (C2 = C2.slice(M2.length + 1));
    let L = m2(C2), { pragmas: k2, comments: G } = p(L);
    return { shebang: M2, text: C2, pragmas: k2, comments: G };
  }
  function F(C2) {
    let M2 = Object.keys(E(C2).pragmas);
    return M2.includes("prettier") || M2.includes("format");
  }
  function D2(C2) {
    let { shebang: M2, text: L, pragmas: k2, comments: G } = E(C2), Z3 = d4(L), B = x2({ pragmas: Object.assign({ format: "" }, k2), comments: G.trimStart() });
    return (M2 ? "".concat(M2, `
`) : "") + A2(B) + (Z3.startsWith(`
`) ? `
` : `

`) + Z3;
  }
  u.exports = { hasPragma: F, insertPragma: D2 };
} }), io$1 = W({ "src/utils/is-non-empty-array.js"(h2, u) {
  H();
  function p(d4) {
    return Array.isArray(d4) && d4.length > 0;
  }
  u.exports = p;
} }), ao$1 = W({ "src/language-js/loc.js"(h2, u) {
  H();
  var p = io$1();
  function d4(E, F) {
    let { ignoreDecorators: D2 } = F || {};
    if (!D2) {
      let C2 = E.declaration && E.declaration.decorators || E.decorators;
      if (p(C2))
        return d4(C2[0]);
    }
    return E.range ? E.range[0] : E.start;
  }
  function m2(E) {
    return E.range ? E.range[1] : E.end;
  }
  function x2(E, F) {
    let D2 = d4(E);
    return Number.isInteger(D2) && D2 === d4(F);
  }
  function A2(E, F) {
    let D2 = m2(E);
    return Number.isInteger(D2) && D2 === m2(F);
  }
  function g2(E, F) {
    return x2(E, F) && A2(E, F);
  }
  u.exports = { locStart: d4, locEnd: m2, hasSameLocStart: x2, hasSameLoc: g2 };
} }), no$1 = W({ "src/language-js/parse/utils/create-parser.js"(h2, u) {
  H();
  var { hasPragma: p } = ef$1(), { locStart: d4, locEnd: m2 } = ao$1();
  function x2(A2) {
    return A2 = typeof A2 == "function" ? { parse: A2 } : A2, Object.assign({ astFormat: "estree", hasPragma: p, locStart: d4, locEnd: m2 }, A2);
  }
  u.exports = x2;
} }), ar = W({ "src/common/parser-create-error.js"(h2, u) {
  H();
  function p(d4, m2) {
    let x2 = new SyntaxError(d4 + " (" + m2.start.line + ":" + m2.start.column + ")");
    return x2.loc = m2, x2;
  }
  u.exports = p;
} }), oo$1 = W({ "src/language-js/parse/utils/create-babel-parse-error.js"(h2, u) {
  H();
  var p = ar();
  function d4(m2) {
    let { message: x2, loc: A2 } = m2;
    return p(x2.replace(/ \(.*\)/, ""), { start: { line: A2 ? A2.line : 0, column: A2 ? A2.column + 1 : 0 } });
  }
  u.exports = d4;
} }), tf$1 = W({ "src/language-js/utils/is-ts-keyword-type.js"(h2, u) {
  H();
  function p(d4) {
    let { type: m2 } = d4;
    return m2.startsWith("TS") && m2.endsWith("Keyword");
  }
  u.exports = p;
} }), sf$1 = W({ "src/language-js/utils/is-block-comment.js"(h2, u) {
  H();
  var p = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]), d4 = (m2) => p.has(m2 == null ? void 0 : m2.type);
  u.exports = d4;
} }), rf$1 = W({ "src/language-js/utils/is-type-cast-comment.js"(h2, u) {
  H();
  var p = sf$1();
  function d4(m2) {
    return p(m2) && m2.value[0] === "*" && /@type\b/.test(m2.value);
  }
  u.exports = d4;
} }), af$1 = W({ "src/utils/get-last.js"(h2, u) {
  H();
  var p = (d4) => d4[d4.length - 1];
  u.exports = p;
} }), ho$1 = W({ "src/language-js/parse/postprocess/visit-node.js"(h2, u) {
  H();
  function p(d4, m2) {
    if (Array.isArray(d4)) {
      for (let x2 = 0; x2 < d4.length; x2++)
        d4[x2] = p(d4[x2], m2);
      return d4;
    }
    if (d4 && typeof d4 == "object" && typeof d4.type == "string") {
      let x2 = Object.keys(d4);
      for (let A2 = 0; A2 < x2.length; A2++)
        d4[x2[A2]] = p(d4[x2[A2]], m2);
      return m2(d4) || d4;
    }
    return d4;
  }
  u.exports = p;
} }), lo$1 = W({ "src/language-js/parse/postprocess/throw-syntax-error.js"(h2, u) {
  H();
  var p = ar();
  function d4(m2, x2) {
    let { start: A2, end: g2 } = m2.loc;
    throw p(x2, { start: { line: A2.line, column: A2.column + 1 }, end: { line: g2.line, column: g2.column + 1 } });
  }
  u.exports = d4;
} }), nf$1 = W({ "src/language-js/parse/postprocess/typescript.js"(h2, u) {
  H();
  var p = ho$1(), d4 = lo$1();
  function m2(g2, E, F) {
    let D2 = g2.decorators;
    if (!Array.isArray(D2))
      return;
    let C2 = E.decorators;
    (!Array.isArray(C2) || C2.length !== D2.length || D2.some((M2) => {
      let L = F.get(M2);
      return !L || !C2.includes(L);
    })) && d4(E, "Leading decorators must be attached to a class declaration");
  }
  function x2(g2, E) {
    g2.kind !== 167 || g2.modifiers && !g2.modifiers.some((C2) => C2.kind === 126) || g2.initializer && E.value === null && d4(E, "Abstract property cannot have an initializer");
  }
  function A2(g2, E) {
    let { esTreeNodeToTSNodeMap: F, tsNodeToESTreeNodeMap: D2 } = E.tsParseResult;
    p(g2, (C2) => {
      let M2 = F.get(C2);
      if (!M2)
        return;
      let L = D2.get(M2);
      L === C2 && (m2(M2, L, D2), x2(M2, L));
    });
  }
  u.exports = { throwErrorForInvalidNodes: A2 };
} }), of$1 = W({ "src/language-js/parse/postprocess/index.js"(h2, u) {
  H();
  var { locStart: p, locEnd: d4 } = ao$1(), m2 = tf$1(), x2 = rf$1(), A2 = af$1(), g2 = ho$1(), { throwErrorForInvalidNodes: E } = nf$1(), F = lo$1();
  function D2(k2, G) {
    if (G.parser === "typescript" && /@|abstract/.test(G.originalText) && E(k2, G), G.parser !== "typescript" && G.parser !== "flow" && G.parser !== "acorn" && G.parser !== "espree" && G.parser !== "meriyah") {
      let B = /* @__PURE__ */ new Set();
      k2 = g2(k2, (j) => {
        j.leadingComments && j.leadingComments.some(x2) && B.add(p(j));
      }), k2 = g2(k2, (j) => {
        if (j.type === "ParenthesizedExpression") {
          let { expression: l } = j;
          if (l.type === "TypeCastExpression")
            return l.range = j.range, l;
          let Y3 = p(j);
          if (!B.has(Y3))
            return l.extra = Object.assign(Object.assign({}, l.extra), {}, { parenthesized: true }), l;
        }
      });
    }
    return k2 = g2(k2, (B) => {
      switch (B.type) {
        case "ChainExpression":
          return C2(B.expression);
        case "LogicalExpression": {
          if (M2(B))
            return L(B);
          break;
        }
        case "VariableDeclaration": {
          let j = A2(B.declarations);
          j && j.init && Z3(B, j);
          break;
        }
        case "TSParenthesizedType":
          return m2(B.typeAnnotation) || B.typeAnnotation.type === "TSThisType" || (B.typeAnnotation.range = [p(B), d4(B)]), B.typeAnnotation;
        case "TSTypeParameter":
          if (typeof B.name == "string") {
            let j = p(B);
            B.name = { type: "Identifier", name: B.name, range: [j, j + B.name.length] };
          }
          break;
        case "ObjectExpression":
          if (G.parser === "typescript") {
            let j = B.properties.find((l) => l.type === "Property" && l.value.type === "TSEmptyBodyFunctionExpression");
            j && F(j.value, "Unexpected token.");
          }
          break;
        case "SequenceExpression": {
          let j = A2(B.expressions);
          B.range = [p(B), Math.min(d4(j), d4(B))];
          break;
        }
        case "TopicReference":
          G.__isUsingHackPipeline = true;
          break;
        case "ExportAllDeclaration": {
          let { exported: j } = B;
          if (G.parser === "meriyah" && j && j.type === "Identifier") {
            let l = G.originalText.slice(p(j), d4(j));
            (l.startsWith('"') || l.startsWith("'")) && (B.exported = Object.assign(Object.assign({}, B.exported), {}, { type: "Literal", value: B.exported.name, raw: l }));
          }
          break;
        }
      }
    }), k2;
    function Z3(B, j) {
      G.originalText[d4(j)] !== ";" && (B.range = [p(B), d4(j)]);
    }
  }
  function C2(k2) {
    switch (k2.type) {
      case "CallExpression":
        k2.type = "OptionalCallExpression", k2.callee = C2(k2.callee);
        break;
      case "MemberExpression":
        k2.type = "OptionalMemberExpression", k2.object = C2(k2.object);
        break;
      case "TSNonNullExpression":
        k2.expression = C2(k2.expression);
        break;
    }
    return k2;
  }
  function M2(k2) {
    return k2.type === "LogicalExpression" && k2.right.type === "LogicalExpression" && k2.operator === k2.right.operator;
  }
  function L(k2) {
    return M2(k2) ? L({ type: "LogicalExpression", operator: k2.operator, left: L({ type: "LogicalExpression", operator: k2.operator, left: k2.left, right: k2.right.left, range: [p(k2.left), d4(k2.right.left)] }), right: k2.right.right, range: [p(k2), d4(k2)] }) : k2;
  }
  u.exports = D2;
} }), uo$1 = W({ "node_modules/@babel/parser/lib/index.js"(h2) {
  H(), Object.defineProperty(h2, "__esModule", { value: true });
  function u(t, e) {
    if (t == null)
      return {};
    var s2 = {}, r = Object.keys(t), i2, a3;
    for (a3 = 0; a3 < r.length; a3++)
      i2 = r[a3], !(e.indexOf(i2) >= 0) && (s2[i2] = t[i2]);
    return s2;
  }
  var p = class {
    constructor(t, e, s2) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = t, this.column = e, this.index = s2;
    }
  }, d4 = class {
    constructor(t, e) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t, this.end = e;
    }
  };
  function m2(t, e) {
    let { line: s2, column: r, index: i2 } = t;
    return new p(s2, r + e, i2 + e);
  }
  var x2 = Object.freeze({ SyntaxError: "BABEL_PARSER_SYNTAX_ERROR", SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" }), A2 = function(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : t.length - 1;
    return { get() {
      return t.reduce((s2, r) => s2[r], this);
    }, set(s2) {
      t.reduce((r, i2, a3) => a3 === e ? r[i2] = s2 : r[i2], this);
    } };
  }, g2 = (t, e, s2) => Object.keys(s2).map((r) => [r, s2[r]]).filter((r) => {
    let [, i2] = r;
    return !!i2;
  }).map((r) => {
    let [i2, a3] = r;
    return [i2, typeof a3 == "function" ? { value: a3, enumerable: false } : typeof a3.reflect == "string" ? Object.assign({}, a3, A2(a3.reflect.split("."))) : a3];
  }).reduce((r, i2) => {
    let [a3, n] = i2;
    return Object.defineProperty(r, a3, Object.assign({ configurable: true }, n));
  }, Object.assign(new t(), e)), E = (t) => ({ ImportMetaOutsideModule: t(`import.meta may appear only with 'sourceType: "module"'`, { code: x2.SourceTypeModuleError }), ImportOutsideModule: t(`'import' and 'export' may appear only with 'sourceType: "module"'`, { code: x2.SourceTypeModuleError }) }), F = { ArrayPattern: "array destructuring pattern", AssignmentExpression: "assignment expression", AssignmentPattern: "assignment expression", ArrowFunctionExpression: "arrow function expression", ConditionalExpression: "conditional expression", ForOfStatement: "for-of statement", ForInStatement: "for-in statement", ForStatement: "for-loop", FormalParameters: "function parameter list", Identifier: "identifier", ObjectPattern: "object destructuring pattern", ParenthesizedExpression: "parenthesized expression", RestElement: "rest element", UpdateExpression: { true: "prefix operation", false: "postfix operation" }, VariableDeclarator: "variable declaration", YieldExpression: "yield expression" }, D2 = (t) => {
    let { type: e, prefix: s2 } = t;
    return e === "UpdateExpression" ? F.UpdateExpression[String(s2)] : F[e];
  }, C2 = (t) => ({ AccessorIsGenerator: t((e) => {
    let { kind: s2 } = e;
    return "A ".concat(s2, "ter cannot be a generator.");
  }), ArgumentsInClass: t("'arguments' is only allowed in functions and class methods."), AsyncFunctionInSingleStatementContext: t("Async functions can only be declared at the top level or inside a block."), AwaitBindingIdentifier: t("Can not use 'await' as identifier inside an async function."), AwaitBindingIdentifierInStaticBlock: t("Can not use 'await' as identifier inside a static block."), AwaitExpressionFormalParameter: t("'await' is not allowed in async function parameters."), AwaitNotInAsyncContext: t("'await' is only allowed within async functions and at the top levels of modules."), AwaitNotInAsyncFunction: t("'await' is only allowed within async functions."), BadGetterArity: t("A 'get' accesor must not have any formal parameters."), BadSetterArity: t("A 'set' accesor must have exactly one formal parameter."), BadSetterRestParameter: t("A 'set' accesor function argument must not be a rest parameter."), ConstructorClassField: t("Classes may not have a field named 'constructor'."), ConstructorClassPrivateField: t("Classes may not have a private field named '#constructor'."), ConstructorIsAccessor: t("Class constructor may not be an accessor."), ConstructorIsAsync: t("Constructor can't be an async function."), ConstructorIsGenerator: t("Constructor can't be a generator."), DeclarationMissingInitializer: t((e) => {
    let { kind: s2 } = e;
    return "Missing initializer in ".concat(s2, " declaration.");
  }), DecoratorBeforeExport: t("Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax."), DecoratorConstructor: t("Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?"), DecoratorExportClass: t("Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead."), DecoratorSemicolon: t("Decorators must not be followed by a semicolon."), DecoratorStaticBlock: t("Decorators can't be used with a static block."), DeletePrivateField: t("Deleting a private field is not allowed."), DestructureNamedImport: t("ES2015 named imports do not destructure. Use another statement for destructuring after the import."), DuplicateConstructor: t("Duplicate constructor in the same class."), DuplicateDefaultExport: t("Only one default export allowed per module."), DuplicateExport: t((e) => {
    let { exportName: s2 } = e;
    return "`".concat(s2, "` has already been exported. Exported identifiers must be unique.");
  }), DuplicateProto: t("Redefinition of __proto__ property."), DuplicateRegExpFlags: t("Duplicate regular expression flag."), ElementAfterRest: t("Rest element must be last element."), EscapedCharNotAnIdentifier: t("Invalid Unicode escape."), ExportBindingIsString: t((e) => {
    let { localName: s2, exportName: r } = e;
    return "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '".concat(s2, "' as '").concat(r, "' } from 'some-module'`?");
  }), ExportDefaultFromAsIdentifier: t("'from' is not allowed as an identifier after 'export default'."), ForInOfLoopInitializer: t((e) => {
    let { type: s2 } = e;
    return "'".concat(s2 === "ForInStatement" ? "for-in" : "for-of", "' loop variable declaration may not have an initializer.");
  }), ForOfAsync: t("The left-hand side of a for-of loop may not be 'async'."), ForOfLet: t("The left-hand side of a for-of loop may not start with 'let'."), GeneratorInSingleStatementContext: t("Generators can only be declared at the top level or inside a block."), IllegalBreakContinue: t((e) => {
    let { type: s2 } = e;
    return "Unsyntactic ".concat(s2 === "BreakStatement" ? "break" : "continue", ".");
  }), IllegalLanguageModeDirective: t("Illegal 'use strict' directive in function with non-simple parameter list."), IllegalReturn: t("'return' outside of function."), ImportBindingIsString: t((e) => {
    let { importName: s2 } = e;
    return 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "'.concat(s2, '" as foo }`?');
  }), ImportCallArgumentTrailingComma: t("Trailing comma is disallowed inside import(...) arguments."), ImportCallArity: t((e) => {
    let { maxArgumentCount: s2 } = e;
    return "`import()` requires exactly ".concat(s2 === 1 ? "one argument" : "one or two arguments", ".");
  }), ImportCallNotNewExpression: t("Cannot use new with import(...)."), ImportCallSpreadArgument: t("`...` is not allowed in `import()`."), IncompatibleRegExpUVFlags: t("The 'u' and 'v' regular expression flags cannot be enabled at the same time."), InvalidBigIntLiteral: t("Invalid BigIntLiteral."), InvalidCodePoint: t("Code point out of bounds."), InvalidCoverInitializedName: t("Invalid shorthand property initializer."), InvalidDecimal: t("Invalid decimal."), InvalidDigit: t((e) => {
    let { radix: s2 } = e;
    return "Expected number in radix ".concat(s2, ".");
  }), InvalidEscapeSequence: t("Bad character escape sequence."), InvalidEscapeSequenceTemplate: t("Invalid escape sequence in template."), InvalidEscapedReservedWord: t((e) => {
    let { reservedWord: s2 } = e;
    return "Escape sequence in keyword ".concat(s2, ".");
  }), InvalidIdentifier: t((e) => {
    let { identifierName: s2 } = e;
    return "Invalid identifier ".concat(s2, ".");
  }), InvalidLhs: t((e) => {
    let { ancestor: s2 } = e;
    return "Invalid left-hand side in ".concat(D2(s2), ".");
  }), InvalidLhsBinding: t((e) => {
    let { ancestor: s2 } = e;
    return "Binding invalid left-hand side in ".concat(D2(s2), ".");
  }), InvalidNumber: t("Invalid number."), InvalidOrMissingExponent: t("Floating-point numbers require a valid exponent after the 'e'."), InvalidOrUnexpectedToken: t((e) => {
    let { unexpected: s2 } = e;
    return "Unexpected character '".concat(s2, "'.");
  }), InvalidParenthesizedAssignment: t("Invalid parenthesized assignment pattern."), InvalidPrivateFieldResolution: t((e) => {
    let { identifierName: s2 } = e;
    return "Private name #".concat(s2, " is not defined.");
  }), InvalidPropertyBindingPattern: t("Binding member expression."), InvalidRecordProperty: t("Only properties and spread elements are allowed in record definitions."), InvalidRestAssignmentPattern: t("Invalid rest operator's argument."), LabelRedeclaration: t((e) => {
    let { labelName: s2 } = e;
    return "Label '".concat(s2, "' is already declared.");
  }), LetInLexicalBinding: t("'let' is not allowed to be used as a name in 'let' or 'const' declarations."), LineTerminatorBeforeArrow: t("No line break is allowed before '=>'."), MalformedRegExpFlags: t("Invalid regular expression flag."), MissingClassName: t("A class name is required."), MissingEqInAssignment: t("Only '=' operator can be used for specifying default value."), MissingSemicolon: t("Missing semicolon."), MissingPlugin: t((e) => {
    let { missingPlugin: s2 } = e;
    return "This experimental syntax requires enabling the parser plugin: ".concat(s2.map((r) => JSON.stringify(r)).join(", "), ".");
  }), MissingOneOfPlugins: t((e) => {
    let { missingPlugin: s2 } = e;
    return "This experimental syntax requires enabling one of the following parser plugin(s): ".concat(s2.map((r) => JSON.stringify(r)).join(", "), ".");
  }), MissingUnicodeEscape: t("Expecting Unicode escape sequence \\uXXXX."), MixingCoalesceWithLogical: t("Nullish coalescing operator(??) requires parens when mixing with logical operators."), ModuleAttributeDifferentFromType: t("The only accepted module attribute is `type`."), ModuleAttributeInvalidValue: t("Only string literals are allowed as module attribute values."), ModuleAttributesWithDuplicateKeys: t((e) => {
    let { key: s2 } = e;
    return 'Duplicate key "'.concat(s2, '" is not allowed in module attributes.');
  }), ModuleExportNameHasLoneSurrogate: t((e) => {
    let { surrogateCharCode: s2 } = e;
    return "An export name cannot include a lone surrogate, found '\\u".concat(s2.toString(16), "'.");
  }), ModuleExportUndefined: t((e) => {
    let { localName: s2 } = e;
    return "Export '".concat(s2, "' is not defined.");
  }), MultipleDefaultsInSwitch: t("Multiple default clauses."), NewlineAfterThrow: t("Illegal newline after throw."), NoCatchOrFinally: t("Missing catch or finally clause."), NumberIdentifier: t("Identifier directly after number."), NumericSeparatorInEscapeSequence: t("Numeric separators are not allowed inside unicode escape sequences or hex escape sequences."), ObsoleteAwaitStar: t("'await*' has been removed from the async functions proposal. Use Promise.all() instead."), OptionalChainingNoNew: t("Constructors in/after an Optional Chain are not allowed."), OptionalChainingNoTemplate: t("Tagged Template Literals are not allowed in optionalChain."), OverrideOnConstructor: t("'override' modifier cannot appear on a constructor declaration."), ParamDupe: t("Argument name clash."), PatternHasAccessor: t("Object pattern can't contain getter or setter."), PatternHasMethod: t("Object pattern can't contain methods."), PrivateInExpectedIn: t((e) => {
    let { identifierName: s2 } = e;
    return "Private names are only allowed in property accesses (`obj.#".concat(s2, "`) or in `in` expressions (`#").concat(s2, " in obj`).");
  }), PrivateNameRedeclaration: t((e) => {
    let { identifierName: s2 } = e;
    return "Duplicate private name #".concat(s2, ".");
  }), RecordExpressionBarIncorrectEndSyntaxType: t("Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."), RecordExpressionBarIncorrectStartSyntaxType: t("Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."), RecordExpressionHashIncorrectStartSyntaxType: t("Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'."), RecordNoProto: t("'__proto__' is not allowed in Record expressions."), RestTrailingComma: t("Unexpected trailing comma after rest element."), SloppyFunction: t("In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement."), StaticPrototype: t("Classes may not have static property named prototype."), SuperNotAllowed: t("`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?"), SuperPrivateField: t("Private fields can't be accessed on super."), TrailingDecorator: t("Decorators must be attached to a class element."), TupleExpressionBarIncorrectEndSyntaxType: t("Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."), TupleExpressionBarIncorrectStartSyntaxType: t("Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."), TupleExpressionHashIncorrectStartSyntaxType: t("Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'."), UnexpectedArgumentPlaceholder: t("Unexpected argument placeholder."), UnexpectedAwaitAfterPipelineBody: t('Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.'), UnexpectedDigitAfterHash: t("Unexpected digit after hash token."), UnexpectedImportExport: t("'import' and 'export' may only appear at the top level."), UnexpectedKeyword: t((e) => {
    let { keyword: s2 } = e;
    return "Unexpected keyword '".concat(s2, "'.");
  }), UnexpectedLeadingDecorator: t("Leading decorators must be attached to a class declaration."), UnexpectedLexicalDeclaration: t("Lexical declaration cannot appear in a single-statement context."), UnexpectedNewTarget: t("`new.target` can only be used in functions or class properties."), UnexpectedNumericSeparator: t("A numeric separator is only allowed between two digits."), UnexpectedPrivateField: t("Unexpected private name."), UnexpectedReservedWord: t((e) => {
    let { reservedWord: s2 } = e;
    return "Unexpected reserved word '".concat(s2, "'.");
  }), UnexpectedSuper: t("'super' is only allowed in object methods and classes."), UnexpectedToken: t((e) => {
    let { expected: s2, unexpected: r } = e;
    return "Unexpected token".concat(r ? " '".concat(r, "'.") : "").concat(s2 ? ', expected "'.concat(s2, '"') : "");
  }), UnexpectedTokenUnaryExponentiation: t("Illegal expression. Wrap left hand side or entire exponentiation in parentheses."), UnsupportedBind: t("Binding should be performed on object property."), UnsupportedDecoratorExport: t("A decorated export must export a class declaration."), UnsupportedDefaultExport: t("Only expressions, functions or classes are allowed as the `default` export."), UnsupportedImport: t("`import` can only be used in `import()` or `import.meta`."), UnsupportedMetaProperty: t((e) => {
    let { target: s2, onlyValidPropertyName: r } = e;
    return "The only valid meta property for ".concat(s2, " is ").concat(s2, ".").concat(r, ".");
  }), UnsupportedParameterDecorator: t("Decorators cannot be used to decorate parameters."), UnsupportedPropertyDecorator: t("Decorators cannot be used to decorate object literal properties."), UnsupportedSuper: t("'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])."), UnterminatedComment: t("Unterminated comment."), UnterminatedRegExp: t("Unterminated regular expression."), UnterminatedString: t("Unterminated string constant."), UnterminatedTemplate: t("Unterminated template."), VarRedeclaration: t((e) => {
    let { identifierName: s2 } = e;
    return "Identifier '".concat(s2, "' has already been declared.");
  }), YieldBindingIdentifier: t("Can not use 'yield' as identifier inside a generator."), YieldInParameter: t("Yield expression is not allowed in formal parameters."), ZeroDigitNumericSeparator: t("Numeric separator can not be used after leading 0.") }), M2 = (t) => ({ StrictDelete: t("Deleting local variable in strict mode."), StrictEvalArguments: t((e) => {
    let { referenceName: s2 } = e;
    return "Assigning to '".concat(s2, "' in strict mode.");
  }), StrictEvalArgumentsBinding: t((e) => {
    let { bindingName: s2 } = e;
    return "Binding '".concat(s2, "' in strict mode.");
  }), StrictFunction: t("In strict mode code, functions can only be declared at top level or inside a block."), StrictNumericEscape: t("The only valid numeric escape in strict mode is '\\0'."), StrictOctalLiteral: t("Legacy octal literals are not allowed in strict mode."), StrictWith: t("'with' in strict mode.") }), L = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), k2 = (t) => ({ PipeBodyIsTighter: t("Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence."), PipeTopicRequiresHackPipes: t('Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'), PipeTopicUnbound: t("Topic reference is unbound; it must be inside a pipe body."), PipeTopicUnconfiguredToken: t((e) => {
    let { token: s2 } = e;
    return "Invalid topic token ".concat(s2, ". In order to use ").concat(s2, ' as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "').concat(s2, '" }.');
  }), PipeTopicUnused: t("Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once."), PipeUnparenthesizedBody: t((e) => {
    let { type: s2 } = e;
    return "Hack-style pipe body cannot be an unparenthesized ".concat(D2({ type: s2 }), "; please wrap it in parentheses.");
  }), PipelineBodyNoArrow: t('Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.'), PipelineBodySequenceExpression: t("Pipeline body may not be a comma-separated sequence expression."), PipelineHeadSequenceExpression: t("Pipeline head should not be a comma-separated sequence expression."), PipelineTopicUnused: t("Pipeline is in topic style but does not use topic reference."), PrimaryTopicNotAllowed: t("Topic reference was used in a lexical context without topic binding."), PrimaryTopicRequiresSmartPipeline: t('Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.') }), G = ["toMessage"];
  function Z3(t) {
    let { toMessage: e } = t, s2 = u(t, G);
    return function r(i2) {
      let { loc: a3, details: n } = i2;
      return g2(SyntaxError, Object.assign({}, s2, { loc: a3 }), { clone() {
        let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, c = o.loc || {};
        return r({ loc: new p("line" in c ? c.line : this.loc.line, "column" in c ? c.column : this.loc.column, "index" in c ? c.index : this.loc.index), details: Object.assign({}, this.details, o.details) });
      }, details: { value: n, enumerable: false }, message: { get() {
        return "".concat(e(this.details), " (").concat(this.loc.line, ":").concat(this.loc.column, ")");
      }, set(o) {
        Object.defineProperty(this, "message", { value: o });
      } }, pos: { reflect: "loc.index", enumerable: true }, missingPlugin: "missingPlugin" in n && { reflect: "details.missingPlugin", enumerable: true } });
    };
  }
  function B(t, e) {
    return Object.assign({ toMessage: typeof t == "string" ? () => t : t }, e);
  }
  function j(t, e) {
    if (Array.isArray(t))
      return (i2) => j(i2, t[0]);
    let s2 = t(B), r = {};
    for (let i2 of Object.keys(s2))
      r[i2] = Z3(Object.assign({ code: x2.SyntaxError, reasonCode: i2 }, e ? { syntaxPlugin: e } : {}, s2[i2]));
    return r;
  }
  var l = Object.assign({}, j(E), j(C2), j(M2), j(Rn || (Rn = ht$1(["pipelineOperator"])))(k2)), { defineProperty: Y3 } = Object, ie = (t, e) => Y3(t, e, { enumerable: false, value: t[e] });
  function Q(t) {
    return ie(t.loc.start, "index"), ie(t.loc.end, "index"), t;
  }
  var Ce2 = (t) => class extends t {
    parse() {
      let e = Q(super.parse());
      return this.options.tokens && (e.tokens = e.tokens.map(Q)), e;
    }
    parseRegExpLiteral(e) {
      let { pattern: s2, flags: r } = e, i2 = null;
      try {
        i2 = new RegExp(s2, r);
      } catch {
      }
      let a3 = this.estreeParseLiteral(i2);
      return a3.regex = { pattern: s2, flags: r }, a3;
    }
    parseBigIntLiteral(e) {
      let s2;
      try {
        s2 = BigInt(e);
      } catch {
        s2 = null;
      }
      let r = this.estreeParseLiteral(s2);
      return r.bigint = String(r.value || e), r;
    }
    parseDecimalLiteral(e) {
      let r = this.estreeParseLiteral(null);
      return r.decimal = String(r.value || e), r;
    }
    estreeParseLiteral(e) {
      return this.parseLiteral(e, "Literal");
    }
    parseStringLiteral(e) {
      return this.estreeParseLiteral(e);
    }
    parseNumericLiteral(e) {
      return this.estreeParseLiteral(e);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(e) {
      return this.estreeParseLiteral(e);
    }
    directiveToStmt(e) {
      let s2 = e.value, r = this.startNodeAt(e.start, e.loc.start), i2 = this.startNodeAt(s2.start, s2.loc.start);
      return i2.value = s2.extra.expressionValue, i2.raw = s2.extra.raw, r.expression = this.finishNodeAt(i2, "Literal", s2.loc.end), r.directive = s2.extra.raw.slice(1, -1), this.finishNodeAt(r, "ExpressionStatement", e.loc.end);
    }
    initFunction(e, s2) {
      super.initFunction(e, s2), e.expression = false;
    }
    checkDeclaration(e) {
      e != null && this.isObjectProperty(e) ? this.checkDeclaration(e.value) : super.checkDeclaration(e);
    }
    getObjectOrClassMethodParams(e) {
      return e.value.params;
    }
    isValidDirective(e) {
      var s2;
      return e.type === "ExpressionStatement" && e.expression.type === "Literal" && typeof e.expression.value == "string" && !((s2 = e.expression.extra) != null && s2.parenthesized);
    }
    parseBlockBody(e) {
      for (var s2 = arguments.length, r = new Array(s2 > 1 ? s2 - 1 : 0), i2 = 1; i2 < s2; i2++)
        r[i2 - 1] = arguments[i2];
      super.parseBlockBody(e, ...r);
      let a3 = e.directives.map((n) => this.directiveToStmt(n));
      e.body = a3.concat(e.body), delete e.directives;
    }
    pushClassMethod(e, s2, r, i2, a3, n) {
      this.parseMethod(s2, r, i2, a3, n, "ClassMethod", true), s2.typeParameters && (s2.value.typeParameters = s2.typeParameters, delete s2.typeParameters), e.body.push(s2);
    }
    parsePrivateName() {
      let e = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(e) : e;
    }
    convertPrivateNameToPrivateIdentifier(e) {
      let s2 = super.getPrivateNameSV(e);
      return e = e, delete e.id, e.name = s2, e.type = "PrivateIdentifier", e;
    }
    isPrivateName(e) {
      return this.getPluginOption("estree", "classFeatures") ? e.type === "PrivateIdentifier" : super.isPrivateName(e);
    }
    getPrivateNameSV(e) {
      return this.getPluginOption("estree", "classFeatures") ? e.name : super.getPrivateNameSV(e);
    }
    parseLiteral(e, s2) {
      let r = super.parseLiteral(e, s2);
      return r.raw = r.extra.raw, delete r.extra, r;
    }
    parseFunctionBody(e, s2) {
      let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      super.parseFunctionBody(e, s2, r), e.expression = e.body.type !== "BlockStatement";
    }
    parseMethod(e, s2, r, i2, a3, n) {
      let o = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false, c = this.startNode();
      return c.kind = e.kind, c = super.parseMethod(c, s2, r, i2, a3, n, o), c.type = "FunctionExpression", delete c.kind, e.value = c, n === "ClassPrivateMethod" && (e.computed = false), n = "MethodDefinition", this.finishNode(e, n);
    }
    parseClassProperty() {
      let e = super.parseClassProperty(...arguments);
      return this.getPluginOption("estree", "classFeatures") && (e.type = "PropertyDefinition"), e;
    }
    parseClassPrivateProperty() {
      let e = super.parseClassPrivateProperty(...arguments);
      return this.getPluginOption("estree", "classFeatures") && (e.type = "PropertyDefinition", e.computed = false), e;
    }
    parseObjectMethod(e, s2, r, i2, a3) {
      let n = super.parseObjectMethod(e, s2, r, i2, a3);
      return n && (n.type = "Property", n.kind === "method" && (n.kind = "init"), n.shorthand = false), n;
    }
    parseObjectProperty(e, s2, r, i2, a3) {
      let n = super.parseObjectProperty(e, s2, r, i2, a3);
      return n && (n.kind = "init", n.type = "Property"), n;
    }
    isValidLVal(e) {
      for (var s2 = arguments.length, r = new Array(s2 > 1 ? s2 - 1 : 0), i2 = 1; i2 < s2; i2++)
        r[i2 - 1] = arguments[i2];
      return e === "Property" ? "value" : super.isValidLVal(e, ...r);
    }
    isAssignable(e, s2) {
      return e != null && this.isObjectProperty(e) ? this.isAssignable(e.value, s2) : super.isAssignable(e, s2);
    }
    toAssignable(e) {
      let s2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (e != null && this.isObjectProperty(e)) {
        let { key: r, value: i2 } = e;
        this.isPrivateName(r) && this.classScope.usePrivateName(this.getPrivateNameSV(r), r.loc.start), this.toAssignable(i2, s2);
      } else
        super.toAssignable(e, s2);
    }
    toAssignableObjectExpressionProp(e) {
      e.kind === "get" || e.kind === "set" ? this.raise(l.PatternHasAccessor, { at: e.key }) : e.method ? this.raise(l.PatternHasMethod, { at: e.key }) : super.toAssignableObjectExpressionProp(...arguments);
    }
    finishCallExpression(e, s2) {
      if (super.finishCallExpression(e, s2), e.callee.type === "Import") {
        if (e.type = "ImportExpression", e.source = e.arguments[0], this.hasPlugin("importAssertions")) {
          var r;
          e.attributes = (r = e.arguments[1]) != null ? r : null;
        }
        delete e.arguments, delete e.callee;
      }
      return e;
    }
    toReferencedArguments(e) {
      e.type !== "ImportExpression" && super.toReferencedArguments(e);
    }
    parseExport(e) {
      switch (super.parseExport(e), e.type) {
        case "ExportAllDeclaration":
          e.exported = null;
          break;
        case "ExportNamedDeclaration":
          e.specifiers.length === 1 && e.specifiers[0].type === "ExportNamespaceSpecifier" && (e.type = "ExportAllDeclaration", e.exported = e.specifiers[0].exported, delete e.specifiers);
          break;
      }
      return e;
    }
    parseSubscript(e, s2, r, i2, a3) {
      let n = super.parseSubscript(e, s2, r, i2, a3);
      if (a3.optionalChainMember) {
        if ((n.type === "OptionalMemberExpression" || n.type === "OptionalCallExpression") && (n.type = n.type.substring(8)), a3.stop) {
          let o = this.startNodeAtNode(n);
          return o.expression = n, this.finishNode(o, "ChainExpression");
        }
      } else
        (n.type === "MemberExpression" || n.type === "CallExpression") && (n.optional = false);
      return n;
    }
    hasPropertyAsPrivateName(e) {
      return e.type === "ChainExpression" && (e = e.expression), super.hasPropertyAsPrivateName(e);
    }
    isOptionalChain(e) {
      return e.type === "ChainExpression";
    }
    isObjectProperty(e) {
      return e.type === "Property" && e.kind === "init" && !e.method;
    }
    isObjectMethod(e) {
      return e.method || e.kind === "get" || e.kind === "set";
    }
    finishNodeAt(e, s2, r) {
      return Q(super.finishNodeAt(e, s2, r));
    }
    resetEndLocation(e) {
      let s2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.lastTokEndLoc;
      super.resetEndLocation(e, s2), Q(e);
    }
  }, ee2 = class {
    constructor(t, e) {
      this.token = void 0, this.preserveSpace = void 0, this.token = t, this.preserveSpace = !!e;
    }
  }, U = { brace: new ee2("{"), j_oTag: new ee2("<tag"), j_cTag: new ee2("</tag"), j_expr: new ee2("<tag>...</tag>", true) };
  U.template = new ee2("`", true);
  var O2 = true, P = true, De2 = true, V = true, $ = true, me2 = true, ce = class {
    constructor(t) {
      let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = t, this.keyword = e.keyword, this.beforeExpr = !!e.beforeExpr, this.startsExpr = !!e.startsExpr, this.rightAssociative = !!e.rightAssociative, this.isLoop = !!e.isLoop, this.isAssign = !!e.isAssign, this.prefix = !!e.prefix, this.postfix = !!e.postfix, this.binop = e.binop != null ? e.binop : null, this.updateContext = null;
    }
  }, ae2 = /* @__PURE__ */ new Map();
  function q(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    e.keyword = t;
    let s2 = w2(t, e);
    return ae2.set(t, s2), s2;
  }
  function X3(t, e) {
    return w2(t, { beforeExpr: O2, binop: e });
  }
  var re2 = -1, ne = [], Ue2 = [], _e2 = [], oe2 = [], Je2 = [], Ye2 = [];
  function w2(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var s2, r, i2, a3;
    return ++re2, Ue2.push(t), _e2.push((s2 = e.binop) != null ? s2 : -1), oe2.push((r = e.beforeExpr) != null ? r : false), Je2.push((i2 = e.startsExpr) != null ? i2 : false), Ye2.push((a3 = e.prefix) != null ? a3 : false), ne.push(new ce(t, e)), re2;
  }
  function _(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var s2, r, i2, a3;
    return ++re2, ae2.set(t, re2), Ue2.push(t), _e2.push((s2 = e.binop) != null ? s2 : -1), oe2.push((r = e.beforeExpr) != null ? r : false), Je2.push((i2 = e.startsExpr) != null ? i2 : false), Ye2.push((a3 = e.prefix) != null ? a3 : false), ne.push(new ce("name", e)), re2;
  }
  var co2 = { bracketL: w2("[", { beforeExpr: O2, startsExpr: P }), bracketHashL: w2("#[", { beforeExpr: O2, startsExpr: P }), bracketBarL: w2("[|", { beforeExpr: O2, startsExpr: P }), bracketR: w2("]"), bracketBarR: w2("|]"), braceL: w2("{", { beforeExpr: O2, startsExpr: P }), braceBarL: w2("{|", { beforeExpr: O2, startsExpr: P }), braceHashL: w2("#{", { beforeExpr: O2, startsExpr: P }), braceR: w2("}"), braceBarR: w2("|}"), parenL: w2("(", { beforeExpr: O2, startsExpr: P }), parenR: w2(")"), comma: w2(",", { beforeExpr: O2 }), semi: w2(";", { beforeExpr: O2 }), colon: w2(":", { beforeExpr: O2 }), doubleColon: w2("::", { beforeExpr: O2 }), dot: w2("."), question: w2("?", { beforeExpr: O2 }), questionDot: w2("?."), arrow: w2("=>", { beforeExpr: O2 }), template: w2("template"), ellipsis: w2("...", { beforeExpr: O2 }), backQuote: w2("`", { startsExpr: P }), dollarBraceL: w2("${", { beforeExpr: O2, startsExpr: P }), templateTail: w2("...`", { startsExpr: P }), templateNonTail: w2("...${", { beforeExpr: O2, startsExpr: P }), at: w2("@"), hash: w2("#", { startsExpr: P }), interpreterDirective: w2("#!..."), eq: w2("=", { beforeExpr: O2, isAssign: V }), assign: w2("_=", { beforeExpr: O2, isAssign: V }), slashAssign: w2("_=", { beforeExpr: O2, isAssign: V }), xorAssign: w2("_=", { beforeExpr: O2, isAssign: V }), moduloAssign: w2("_=", { beforeExpr: O2, isAssign: V }), incDec: w2("++/--", { prefix: $, postfix: me2, startsExpr: P }), bang: w2("!", { beforeExpr: O2, prefix: $, startsExpr: P }), tilde: w2("~", { beforeExpr: O2, prefix: $, startsExpr: P }), doubleCaret: w2("^^", { startsExpr: P }), doubleAt: w2("@@", { startsExpr: P }), pipeline: X3("|>", 0), nullishCoalescing: X3("??", 1), logicalOR: X3("||", 1), logicalAND: X3("&&", 2), bitwiseOR: X3("|", 3), bitwiseXOR: X3("^", 4), bitwiseAND: X3("&", 5), equality: X3("==/!=/===/!==", 6), lt: X3("</>/<=/>=", 7), gt: X3("</>/<=/>=", 7), relational: X3("</>/<=/>=", 7), bitShift: X3("<</>>/>>>", 8), bitShiftL: X3("<</>>/>>>", 8), bitShiftR: X3("<</>>/>>>", 8), plusMin: w2("+/-", { beforeExpr: O2, binop: 9, prefix: $, startsExpr: P }), modulo: w2("%", { binop: 10, startsExpr: P }), star: w2("*", { binop: 10 }), slash: X3("/", 10), exponent: w2("**", { beforeExpr: O2, binop: 11, rightAssociative: true }), _in: q("in", { beforeExpr: O2, binop: 7 }), _instanceof: q("instanceof", { beforeExpr: O2, binop: 7 }), _break: q("break"), _case: q("case", { beforeExpr: O2 }), _catch: q("catch"), _continue: q("continue"), _debugger: q("debugger"), _default: q("default", { beforeExpr: O2 }), _else: q("else", { beforeExpr: O2 }), _finally: q("finally"), _function: q("function", { startsExpr: P }), _if: q("if"), _return: q("return", { beforeExpr: O2 }), _switch: q("switch"), _throw: q("throw", { beforeExpr: O2, prefix: $, startsExpr: P }), _try: q("try"), _var: q("var"), _const: q("const"), _with: q("with"), _new: q("new", { beforeExpr: O2, startsExpr: P }), _this: q("this", { startsExpr: P }), _super: q("super", { startsExpr: P }), _class: q("class", { startsExpr: P }), _extends: q("extends", { beforeExpr: O2 }), _export: q("export"), _import: q("import", { startsExpr: P }), _null: q("null", { startsExpr: P }), _true: q("true", { startsExpr: P }), _false: q("false", { startsExpr: P }), _typeof: q("typeof", { beforeExpr: O2, prefix: $, startsExpr: P }), _void: q("void", { beforeExpr: O2, prefix: $, startsExpr: P }), _delete: q("delete", { beforeExpr: O2, prefix: $, startsExpr: P }), _do: q("do", { isLoop: De2, beforeExpr: O2 }), _for: q("for", { isLoop: De2 }), _while: q("while", { isLoop: De2 }), _as: _("as", { startsExpr: P }), _assert: _("assert", { startsExpr: P }), _async: _("async", { startsExpr: P }), _await: _("await", { startsExpr: P }), _from: _("from", { startsExpr: P }), _get: _("get", { startsExpr: P }), _let: _("let", { startsExpr: P }), _meta: _("meta", { startsExpr: P }), _of: _("of", { startsExpr: P }), _sent: _("sent", { startsExpr: P }), _set: _("set", { startsExpr: P }), _static: _("static", { startsExpr: P }), _yield: _("yield", { startsExpr: P }), _asserts: _("asserts", { startsExpr: P }), _checks: _("checks", { startsExpr: P }), _exports: _("exports", { startsExpr: P }), _global: _("global", { startsExpr: P }), _implements: _("implements", { startsExpr: P }), _intrinsic: _("intrinsic", { startsExpr: P }), _infer: _("infer", { startsExpr: P }), _is: _("is", { startsExpr: P }), _mixins: _("mixins", { startsExpr: P }), _proto: _("proto", { startsExpr: P }), _require: _("require", { startsExpr: P }), _keyof: _("keyof", { startsExpr: P }), _readonly: _("readonly", { startsExpr: P }), _unique: _("unique", { startsExpr: P }), _abstract: _("abstract", { startsExpr: P }), _declare: _("declare", { startsExpr: P }), _enum: _("enum", { startsExpr: P }), _module: _("module", { startsExpr: P }), _namespace: _("namespace", { startsExpr: P }), _interface: _("interface", { startsExpr: P }), _type: _("type", { startsExpr: P }), _opaque: _("opaque", { startsExpr: P }), name: w2("name", { startsExpr: P }), string: w2("string", { startsExpr: P }), num: w2("num", { startsExpr: P }), bigint: w2("bigint", { startsExpr: P }), decimal: w2("decimal", { startsExpr: P }), regexp: w2("regexp", { startsExpr: P }), privateName: w2("#name", { startsExpr: P }), eof: w2("eof"), jsxName: w2("jsxName"), jsxText: w2("jsxText", { beforeExpr: true }), jsxTagStart: w2("jsxTagStart", { startsExpr: true }), jsxTagEnd: w2("jsxTagEnd"), placeholder: w2("%%", { startsExpr: true }) };
  function K(t) {
    return t >= 93 && t <= 128;
  }
  function po2(t) {
    return t <= 92;
  }
  function ye2(t) {
    return t >= 58 && t <= 128;
  }
  function nr2(t) {
    return t >= 58 && t <= 132;
  }
  function fo2(t) {
    return oe2[t];
  }
  function Kt2(t) {
    return Je2[t];
  }
  function mo2(t) {
    return t >= 29 && t <= 33;
  }
  function or2(t) {
    return t >= 125 && t <= 127;
  }
  function yo2(t) {
    return t >= 90 && t <= 92;
  }
  function Vt(t) {
    return t >= 58 && t <= 92;
  }
  function xo2(t) {
    return t >= 39 && t <= 59;
  }
  function go2(t) {
    return t === 34;
  }
  function Ao2(t) {
    return Ye2[t];
  }
  function Po2(t) {
    return t >= 117 && t <= 119;
  }
  function To2(t) {
    return t >= 120 && t <= 126;
  }
  function ve2(t) {
    return Ue2[t];
  }
  function lt2(t) {
    return _e2[t];
  }
  function Eo2(t) {
    return _e2[t] !== -1;
  }
  function bo2(t) {
    return t === 57;
  }
  function ut2(t) {
    return t >= 24 && t <= 25;
  }
  function xe2(t) {
    return ne[t];
  }
  ne[8].updateContext = (t) => {
    t.pop();
  }, ne[5].updateContext = ne[7].updateContext = ne[23].updateContext = (t) => {
    t.push(U.brace);
  }, ne[22].updateContext = (t) => {
    t[t.length - 1] === U.template ? t.pop() : t.push(U.template);
  }, ne[138].updateContext = (t) => {
    t.push(U.j_expr, U.j_oTag);
  };
  var Ht2 = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", hr2 = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F", Co2 = new RegExp("[" + Ht2 + "]"), vo2 = new RegExp("[" + Ht2 + hr2 + "]");
  Ht2 = hr2 = null;
  var lr2 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], So2 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function Wt2(t, e) {
    let s2 = 65536;
    for (let r = 0, i2 = e.length; r < i2; r += 2) {
      if (s2 += e[r], s2 > t)
        return false;
      if (s2 += e[r + 1], s2 >= t)
        return true;
    }
    return false;
  }
  function ge2(t) {
    return t < 65 ? t === 36 : t <= 90 ? true : t < 97 ? t === 95 : t <= 122 ? true : t <= 65535 ? t >= 170 && Co2.test(String.fromCharCode(t)) : Wt2(t, lr2);
  }
  function ze(t) {
    return t < 48 ? t === 36 : t < 58 ? true : t < 65 ? false : t <= 90 ? true : t < 97 ? t === 95 : t <= 122 ? true : t <= 65535 ? t >= 170 && vo2.test(String.fromCharCode(t)) : Wt2(t, lr2) || Wt2(t, So2);
  }
  var Gt2 = { keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"], strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], strictBind: ["eval", "arguments"] }, wo2 = new Set(Gt2.keyword), No2 = new Set(Gt2.strict), Io2 = new Set(Gt2.strictBind);
  function ur2(t, e) {
    return e && t === "await" || t === "enum";
  }
  function cr2(t, e) {
    return ur2(t, e) || No2.has(t);
  }
  function pr2(t) {
    return Io2.has(t);
  }
  function fr2(t, e) {
    return cr2(t, e) || pr2(t);
  }
  function ko2(t) {
    return wo2.has(t);
  }
  function Do2(t, e, s2) {
    return t === 64 && e === 64 && ge2(s2);
  }
  var Fo2 = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function Lo2(t) {
    return Fo2.has(t);
  }
  var Ke2 = 0, $e2 = 1, Ae2 = 2, Xt2 = 4, dr2 = 8, ct2 = 16, mr2 = 32, Fe2 = 64, Jt2 = 128, pt2 = 256, ft2 = $e2 | Ae2 | pt2, Pe2 = 1, Ve2 = 2, yr2 = 4, Se2 = 8, dt2 = 16, xr2 = 64, mt2 = 128, Yt2 = 256, $t = 512, Qt2 = 1024, Zt = 2048, gr2 = Pe2 | Ve2 | Se2 | mt2, Te2 = Pe2 | 0 | Se2 | 0, yt2 = Pe2 | 0 | yr2 | 0, Ar2 = Pe2 | 0 | dt2 | 0, Oo2 = 0 | Ve2 | 0 | mt2, Bo2 = 0 | Ve2 | 0 | 0, Pr2 = Pe2 | Ve2 | Se2 | Yt2, Tr2 = 0 | Qt2, Le2 = 0 | xr2, Mo2 = Pe2 | 0 | 0 | xr2, Ro2 = Pr2 | $t, jo2 = 0 | Qt2, qo2 = Zt, xt2 = 4, es2 = 2, ts2 = 1, ss3 = es2 | ts2, Uo2 = es2 | xt2, _o2 = ts2 | xt2, zo2 = es2, Ko = ts2, rs2 = 0, Vo2 = class {
    constructor() {
      this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
    }
    hasPlugin(t) {
      if (typeof t == "string")
        return this.plugins.has(t);
      {
        let [e, s2] = t;
        if (!this.hasPlugin(e))
          return false;
        let r = this.plugins.get(e);
        for (let i2 of Object.keys(s2))
          if ((r == null ? void 0 : r[i2]) !== s2[i2])
            return false;
        return true;
      }
    }
    getPluginOption(t, e) {
      var s2;
      return (s2 = this.plugins.get(t)) == null ? void 0 : s2[e];
    }
  };
  function Er2(t, e) {
    t.trailingComments === void 0 ? t.trailingComments = e : t.trailingComments.unshift(...e);
  }
  function Ho2(t, e) {
    t.leadingComments === void 0 ? t.leadingComments = e : t.leadingComments.unshift(...e);
  }
  function Qe(t, e) {
    t.innerComments === void 0 ? t.innerComments = e : t.innerComments.unshift(...e);
  }
  function Ze2(t, e, s2) {
    let r = null, i2 = e.length;
    for (; r === null && i2 > 0; )
      r = e[--i2];
    r === null || r.start > s2.start ? Qe(t, s2.comments) : Er2(r, s2.comments);
  }
  var Wo2 = class extends Vo2 {
    addComment(t) {
      this.filename && (t.loc.filename = this.filename), this.state.comments.push(t);
    }
    processComment(t) {
      let { commentStack: e } = this.state, s2 = e.length;
      if (s2 === 0)
        return;
      let r = s2 - 1, i2 = e[r];
      i2.start === t.end && (i2.leadingNode = t, r--);
      let { start: a3 } = t;
      for (; r >= 0; r--) {
        let n = e[r], o = n.end;
        if (o > a3)
          n.containingNode = t, this.finalizeComment(n), e.splice(r, 1);
        else {
          o === a3 && (n.trailingNode = t);
          break;
        }
      }
    }
    finalizeComment(t) {
      let { comments: e } = t;
      if (t.leadingNode !== null || t.trailingNode !== null)
        t.leadingNode !== null && Er2(t.leadingNode, e), t.trailingNode !== null && Ho2(t.trailingNode, e);
      else {
        let { containingNode: s2, start: r } = t;
        if (this.input.charCodeAt(r - 1) === 44)
          switch (s2.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              Ze2(s2, s2.properties, t);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              Ze2(s2, s2.arguments, t);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              Ze2(s2, s2.params, t);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              Ze2(s2, s2.elements, t);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              Ze2(s2, s2.specifiers, t);
              break;
            default:
              Qe(s2, e);
          }
        else
          Qe(s2, e);
      }
    }
    finalizeRemainingComments() {
      let { commentStack: t } = this.state;
      for (let e = t.length - 1; e >= 0; e--)
        this.finalizeComment(t[e]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(t) {
      let { commentStack: e } = this.state, { length: s2 } = e;
      if (s2 === 0)
        return;
      let r = e[s2 - 1];
      r.leadingNode === t && (r.leadingNode = null);
    }
    takeSurroundingComments(t, e, s2) {
      let { commentStack: r } = this.state, i2 = r.length;
      if (i2 === 0)
        return;
      let a3 = i2 - 1;
      for (; a3 >= 0; a3--) {
        let n = r[a3], o = n.end;
        if (n.start === s2)
          n.leadingNode = t;
        else if (o === e)
          n.trailingNode = t;
        else if (o < e)
          break;
      }
    }
  }, is2 = /\r\n?|[\n\u2028\u2029]/, gt2 = new RegExp(is2.source, "g");
  function Oe2(t) {
    switch (t) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return true;
      default:
        return false;
    }
  }
  var as2 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Go2 = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y, br2 = new RegExp("(?=(" + Go2.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
  function Xo(t) {
    switch (t) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return true;
      default:
        return false;
    }
  }
  var Cr2 = class {
    constructor() {
      this.strict = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = false, this.inType = false, this.noAnonFunctionType = false, this.hasFlowComment = false, this.isAmbientContext = false, this.inAbstractClass = false, this.inDisallowConditionalTypesContext = false, this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.soloAwait = false, this.inFSharpPipelineDirectBody = false, this.labels = [], this.decoratorStack = [[]], this.comments = [], this.commentStack = [], this.pos = 0, this.type = 135, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.context = [U.brace], this.canStartJSXElement = true, this.containsEsc = false, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    init(t) {
      let { strictMode: e, sourceType: s2, startLine: r, startColumn: i2 } = t;
      this.strict = e === false ? false : e === true ? true : s2 === "module", this.curLine = r, this.lineStart = -i2, this.startLoc = this.endLoc = new p(r, i2, 0);
    }
    curPosition() {
      return new p(this.curLine, this.pos - this.lineStart, this.pos);
    }
    clone(t) {
      let e = new Cr2(), s2 = Object.keys(this);
      for (let r = 0, i2 = s2.length; r < i2; r++) {
        let a3 = s2[r], n = this[a3];
        !t && Array.isArray(n) && (n = n.slice()), e[a3] = n;
      }
      return e;
    }
  }, Jo2 = ["at"], Yo = ["at"], $o2 = function(e) {
    return e >= 48 && e <= 57;
  }, Qo = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), vr2 = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, At2 = { bin: (t) => t === 48 || t === 49, oct: (t) => t >= 48 && t <= 55, dec: (t) => t >= 48 && t <= 57, hex: (t) => t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102 }, we2 = class {
    constructor(t) {
      this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, this.loc = new d4(t.startLoc, t.endLoc);
    }
  }, Zo = class extends Wo2 {
    constructor(t, e) {
      super(), this.isLookahead = void 0, this.tokens = [], this.state = new Cr2(), this.state.init(t), this.input = e, this.length = e.length, this.isLookahead = false;
    }
    pushToken(t) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(t), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new we2(this.state)), this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(t) {
      return this.match(t) ? (this.next(), true) : false;
    }
    match(t) {
      return this.state.type === t;
    }
    createLookaheadState(t) {
      return { pos: t.pos, value: null, type: t.type, start: t.start, end: t.end, context: [this.curContext()], inType: t.inType, startLoc: t.startLoc, lastTokEndLoc: t.lastTokEndLoc, curLine: t.curLine, lineStart: t.lineStart, curPosition: t.curPosition };
    }
    lookahead() {
      let t = this.state;
      this.state = this.createLookaheadState(t), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
      let e = this.state;
      return this.state = t, e;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(t) {
      return as2.lastIndex = t, as2.test(this.input) ? as2.lastIndex : t;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    codePointAtPos(t) {
      let e = this.input.charCodeAt(t);
      if ((e & 64512) === 55296 && ++t < this.input.length) {
        let s2 = this.input.charCodeAt(t);
        (s2 & 64512) === 56320 && (e = 65536 + ((e & 1023) << 10) + (s2 & 1023));
      }
      return e;
    }
    setStrict(t) {
      this.state.strict = t, t && (this.state.strictErrors.forEach((e) => {
        let [s2, r] = e;
        return this.raise(s2, { at: r });
      }), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
        this.finishToken(135);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment() {
      let t;
      this.isLookahead || (t = this.state.curPosition());
      let e = this.state.pos, s2 = this.input.indexOf("*/", e + 2);
      if (s2 === -1)
        throw this.raise(l.UnterminatedComment, { at: this.state.curPosition() });
      for (this.state.pos = s2 + 2, gt2.lastIndex = e + 2; gt2.test(this.input) && gt2.lastIndex <= s2; )
        ++this.state.curLine, this.state.lineStart = gt2.lastIndex;
      if (this.isLookahead)
        return;
      let r = { type: "CommentBlock", value: this.input.slice(e + 2, s2), start: e, end: s2 + 2, loc: new d4(t, this.state.curPosition()) };
      return this.options.tokens && this.pushToken(r), r;
    }
    skipLineComment(t) {
      let e = this.state.pos, s2;
      this.isLookahead || (s2 = this.state.curPosition());
      let r = this.input.charCodeAt(this.state.pos += t);
      if (this.state.pos < this.length)
        for (; !Oe2(r) && ++this.state.pos < this.length; )
          r = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead)
        return;
      let i2 = this.state.pos, a3 = this.input.slice(e + t, i2), n = { type: "CommentLine", value: a3, start: e, end: i2, loc: new d4(s2, this.state.curPosition()) };
      return this.options.tokens && this.pushToken(n), n;
    }
    skipSpace() {
      let t = this.state.pos, e = [];
      e:
        for (; this.state.pos < this.length; ) {
          let s2 = this.input.charCodeAt(this.state.pos);
          switch (s2) {
            case 32:
            case 160:
            case 9:
              ++this.state.pos;
              break;
            case 13:
              this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
            case 10:
            case 8232:
            case 8233:
              ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
              break;
            case 47:
              switch (this.input.charCodeAt(this.state.pos + 1)) {
                case 42: {
                  let r = this.skipBlockComment();
                  r !== void 0 && (this.addComment(r), this.options.attachComment && e.push(r));
                  break;
                }
                case 47: {
                  let r = this.skipLineComment(2);
                  r !== void 0 && (this.addComment(r), this.options.attachComment && e.push(r));
                  break;
                }
                default:
                  break e;
              }
              break;
            default:
              if (Xo(s2))
                ++this.state.pos;
              else if (s2 === 45 && !this.inModule) {
                let r = this.state.pos;
                if (this.input.charCodeAt(r + 1) === 45 && this.input.charCodeAt(r + 2) === 62 && (t === 0 || this.state.lineStart > t)) {
                  let i2 = this.skipLineComment(3);
                  i2 !== void 0 && (this.addComment(i2), this.options.attachComment && e.push(i2));
                } else
                  break e;
              } else if (s2 === 60 && !this.inModule) {
                let r = this.state.pos;
                if (this.input.charCodeAt(r + 1) === 33 && this.input.charCodeAt(r + 2) === 45 && this.input.charCodeAt(r + 3) === 45) {
                  let i2 = this.skipLineComment(4);
                  i2 !== void 0 && (this.addComment(i2), this.options.attachComment && e.push(i2));
                } else
                  break e;
              } else
                break e;
          }
        }
      if (e.length > 0) {
        let s2 = this.state.pos, r = { start: t, end: s2, comments: e, leadingNode: null, trailingNode: null, containingNode: null };
        this.state.commentStack.push(r);
      }
    }
    finishToken(t, e) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      let s2 = this.state.type;
      this.state.type = t, this.state.value = e, this.isLookahead || this.updateContext(s2);
    }
    replaceToken(t) {
      this.state.type = t, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      let t = this.state.pos + 1, e = this.codePointAtPos(t);
      if (e >= 48 && e <= 57)
        throw this.raise(l.UnexpectedDigitAfterHash, { at: this.state.curPosition() });
      if (e === 123 || e === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") !== "hash")
          throw this.raise(e === 123 ? l.RecordExpressionHashIncorrectStartSyntaxType : l.TupleExpressionHashIncorrectStartSyntaxType, { at: this.state.curPosition() });
        this.state.pos += 2, e === 123 ? this.finishToken(7) : this.finishToken(1);
      } else
        ge2(e) ? (++this.state.pos, this.finishToken(134, this.readWord1(e))) : e === 92 ? (++this.state.pos, this.finishToken(134, this.readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      let t = this.input.charCodeAt(this.state.pos + 1);
      if (t >= 48 && t <= 57) {
        this.readNumber(true);
        return;
      }
      t === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2)
        return false;
      let t = this.input.charCodeAt(this.state.pos + 1);
      if (t !== 33)
        return false;
      let e = this.state.pos;
      for (this.state.pos += 1; !Oe2(t) && ++this.state.pos < this.length; )
        t = this.input.charCodeAt(this.state.pos);
      let s2 = this.input.slice(e + 2, this.state.pos);
      return this.finishToken(28, s2), true;
    }
    readToken_mult_modulo(t) {
      let e = t === 42 ? 55 : 54, s2 = 1, r = this.input.charCodeAt(this.state.pos + 1);
      t === 42 && r === 42 && (s2++, r = this.input.charCodeAt(this.state.pos + 2), e = 57), r === 61 && !this.state.inType && (s2++, e = t === 37 ? 33 : 30), this.finishOp(e, s2);
    }
    readToken_pipe_amp(t) {
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e === t) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(t === 124 ? 41 : 42, 2);
        return;
      }
      if (t === 124) {
        if (e === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && e === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(l.RecordExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && e === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(l.TupleExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (e === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(t === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      let t = this.input.charCodeAt(this.state.pos + 1);
      if (t === 61 && !this.state.inType)
        this.finishOp(32, 2);
      else if (t === 94 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "^^" }])) {
        if (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94)
          throw this.unexpected();
      } else
        this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "@@" }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(t) {
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e === t) {
        this.finishOp(34, 2);
        return;
      }
      e === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      let { pos: t } = this.state, e = this.input.charCodeAt(t + 1);
      if (e === 60) {
        if (this.input.charCodeAt(t + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (e === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      let { pos: t } = this.state, e = this.input.charCodeAt(t + 1);
      if (e === 62) {
        let s2 = this.input.charCodeAt(t + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(t + s2) === 61) {
          this.finishOp(30, s2 + 1);
          return;
        }
        this.finishOp(52, s2);
        return;
      }
      if (e === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(t) {
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (e === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (t === 61 && e === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(t === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      let t = this.input.charCodeAt(this.state.pos + 1), e = this.input.charCodeAt(this.state.pos + 2);
      t === 63 ? e === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : t === 46 && !(e >= 48 && e <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(t) {
      switch (t) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(l.TupleExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(l.RecordExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          let e = this.input.charCodeAt(this.state.pos + 1);
          if (e === 120 || e === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (e === 111 || e === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (e === 98 || e === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(false);
          return;
        case 34:
        case 39:
          this.readString(t);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(t);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(t);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(t);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(t);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (ge2(t)) {
            this.readWord(t);
            return;
          }
      }
      throw this.raise(l.InvalidOrUnexpectedToken, { at: this.state.curPosition(), unexpected: String.fromCodePoint(t) });
    }
    finishOp(t, e) {
      let s2 = this.input.slice(this.state.pos, this.state.pos + e);
      this.state.pos += e, this.finishToken(t, s2);
    }
    readRegexp() {
      let t = this.state.startLoc, e = this.state.start + 1, s2, r, { pos: i2 } = this.state;
      for (; ; ++i2) {
        if (i2 >= this.length)
          throw this.raise(l.UnterminatedRegExp, { at: m2(t, 1) });
        let c = this.input.charCodeAt(i2);
        if (Oe2(c))
          throw this.raise(l.UnterminatedRegExp, { at: m2(t, 1) });
        if (s2)
          s2 = false;
        else {
          if (c === 91)
            r = true;
          else if (c === 93 && r)
            r = false;
          else if (c === 47 && !r)
            break;
          s2 = c === 92;
        }
      }
      let a3 = this.input.slice(e, i2);
      ++i2;
      let n = "", o = () => m2(t, i2 + 2 - e);
      for (; i2 < this.length; ) {
        let c = this.codePointAtPos(i2), f = String.fromCharCode(c);
        if (Qo.has(c))
          c === 118 ? (this.expectPlugin("regexpUnicodeSets", o()), n.includes("u") && this.raise(l.IncompatibleRegExpUVFlags, { at: o() })) : c === 117 && n.includes("v") && this.raise(l.IncompatibleRegExpUVFlags, { at: o() }), n.includes(f) && this.raise(l.DuplicateRegExpFlags, { at: o() });
        else if (ze(c) || c === 92)
          this.raise(l.MalformedRegExpFlags, { at: o() });
        else
          break;
        ++i2, n += f;
      }
      this.state.pos = i2, this.finishToken(133, { pattern: a3, flags: n });
    }
    readInt(t, e, s2) {
      let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true, i2 = this.state.pos, a3 = t === 16 ? vr2.hex : vr2.decBinOct, n = t === 16 ? At2.hex : t === 10 ? At2.dec : t === 8 ? At2.oct : At2.bin, o = false, c = 0;
      for (let f = 0, y = e == null ? 1 / 0 : e; f < y; ++f) {
        let T2 = this.input.charCodeAt(this.state.pos), v;
        if (T2 === 95 && r !== "bail") {
          let N = this.input.charCodeAt(this.state.pos - 1), R = this.input.charCodeAt(this.state.pos + 1);
          r ? (Number.isNaN(R) || !n(R) || a3.has(N) || a3.has(R)) && this.raise(l.UnexpectedNumericSeparator, { at: this.state.curPosition() }) : this.raise(l.NumericSeparatorInEscapeSequence, { at: this.state.curPosition() }), ++this.state.pos;
          continue;
        }
        if (T2 >= 97 ? v = T2 - 97 + 10 : T2 >= 65 ? v = T2 - 65 + 10 : $o2(T2) ? v = T2 - 48 : v = 1 / 0, v >= t)
          if (this.options.errorRecovery && v <= 9)
            v = 0, this.raise(l.InvalidDigit, { at: this.state.curPosition(), radix: t });
          else if (s2)
            v = 0, o = true;
          else
            break;
        ++this.state.pos, c = c * t + v;
      }
      return this.state.pos === i2 || e != null && this.state.pos - i2 !== e || o ? null : c;
    }
    readRadixNumber(t) {
      let e = this.state.curPosition(), s2 = false;
      this.state.pos += 2;
      let r = this.readInt(t);
      r == null && this.raise(l.InvalidDigit, { at: m2(e, 2), radix: t });
      let i2 = this.input.charCodeAt(this.state.pos);
      if (i2 === 110)
        ++this.state.pos, s2 = true;
      else if (i2 === 109)
        throw this.raise(l.InvalidDecimal, { at: e });
      if (ge2(this.codePointAtPos(this.state.pos)))
        throw this.raise(l.NumberIdentifier, { at: this.state.curPosition() });
      if (s2) {
        let a3 = this.input.slice(e.index, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(131, a3);
        return;
      }
      this.finishToken(130, r);
    }
    readNumber(t) {
      let e = this.state.pos, s2 = this.state.curPosition(), r = false, i2 = false, a3 = false, n = false, o = false;
      !t && this.readInt(10) === null && this.raise(l.InvalidNumber, { at: this.state.curPosition() });
      let c = this.state.pos - e >= 2 && this.input.charCodeAt(e) === 48;
      if (c) {
        let v = this.input.slice(e, this.state.pos);
        if (this.recordStrictModeErrors(l.StrictOctalLiteral, { at: s2 }), !this.state.strict) {
          let N = v.indexOf("_");
          N > 0 && this.raise(l.ZeroDigitNumericSeparator, { at: m2(s2, N) });
        }
        o = c && !/[89]/.test(v);
      }
      let f = this.input.charCodeAt(this.state.pos);
      if (f === 46 && !o && (++this.state.pos, this.readInt(10), r = true, f = this.input.charCodeAt(this.state.pos)), (f === 69 || f === 101) && !o && (f = this.input.charCodeAt(++this.state.pos), (f === 43 || f === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(l.InvalidOrMissingExponent, { at: s2 }), r = true, n = true, f = this.input.charCodeAt(this.state.pos)), f === 110 && ((r || c) && this.raise(l.InvalidBigIntLiteral, { at: s2 }), ++this.state.pos, i2 = true), f === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (n || c) && this.raise(l.InvalidDecimal, { at: s2 }), ++this.state.pos, a3 = true), ge2(this.codePointAtPos(this.state.pos)))
        throw this.raise(l.NumberIdentifier, { at: this.state.curPosition() });
      let y = this.input.slice(e, this.state.pos).replace(/[_mn]/g, "");
      if (i2) {
        this.finishToken(131, y);
        return;
      }
      if (a3) {
        this.finishToken(132, y);
        return;
      }
      let T2 = o ? parseInt(y, 8) : parseFloat(y);
      this.finishToken(130, T2);
    }
    readCodePoint(t) {
      let e = this.input.charCodeAt(this.state.pos), s2;
      if (e === 123) {
        if (++this.state.pos, s2 = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, t), ++this.state.pos, s2 !== null && s2 > 1114111)
          if (t)
            this.raise(l.InvalidCodePoint, { at: this.state.curPosition() });
          else
            return null;
      } else
        s2 = this.readHexChar(4, false, t);
      return s2;
    }
    readString(t) {
      let e = "", s2 = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(l.UnterminatedString, { at: this.state.startLoc });
        let r = this.input.charCodeAt(this.state.pos);
        if (r === t)
          break;
        if (r === 92)
          e += this.input.slice(s2, this.state.pos), e += this.readEscapedChar(false), s2 = this.state.pos;
        else if (r === 8232 || r === 8233)
          ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
        else {
          if (Oe2(r))
            throw this.raise(l.UnterminatedString, { at: this.state.startLoc });
          ++this.state.pos;
        }
      }
      e += this.input.slice(s2, this.state.pos++), this.finishToken(129, e);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let t = "", e = this.state.pos, s2 = false;
      for (++this.state.pos; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(l.UnterminatedTemplate, { at: m2(this.state.startLoc, 1) });
        let r = this.input.charCodeAt(this.state.pos);
        if (r === 96) {
          ++this.state.pos, t += this.input.slice(e, this.state.pos), this.finishToken(24, s2 ? null : t);
          return;
        }
        if (r === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
          this.state.pos += 2, t += this.input.slice(e, this.state.pos), this.finishToken(25, s2 ? null : t);
          return;
        }
        if (r === 92) {
          t += this.input.slice(e, this.state.pos);
          let i2 = this.readEscapedChar(true);
          i2 === null ? s2 = true : t += i2, e = this.state.pos;
        } else if (Oe2(r)) {
          switch (t += this.input.slice(e, this.state.pos), ++this.state.pos, r) {
            case 13:
              this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos;
            case 10:
              t += `
`;
              break;
            default:
              t += String.fromCharCode(r);
              break;
          }
          ++this.state.curLine, this.state.lineStart = this.state.pos, e = this.state.pos;
        } else
          ++this.state.pos;
      }
    }
    recordStrictModeErrors(t, e) {
      let { at: s2 } = e, r = s2.index;
      this.state.strict && !this.state.strictErrors.has(r) ? this.raise(t, { at: s2 }) : this.state.strictErrors.set(r, [t, s2]);
    }
    readEscapedChar(t) {
      let e = !t, s2 = this.input.charCodeAt(++this.state.pos);
      switch (++this.state.pos, s2) {
        case 110:
          return `
`;
        case 114:
          return "\r";
        case 120: {
          let r = this.readHexChar(2, false, e);
          return r === null ? null : String.fromCharCode(r);
        }
        case 117: {
          let r = this.readCodePoint(e);
          return r === null ? null : String.fromCodePoint(r);
        }
        case 116:
          return "	";
        case 98:
          return "\b";
        case 118:
          return "\v";
        case 102:
          return "\f";
        case 13:
          this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos;
        case 10:
          this.state.lineStart = this.state.pos, ++this.state.curLine;
        case 8232:
        case 8233:
          return "";
        case 56:
        case 57:
          if (t)
            return null;
          this.recordStrictModeErrors(l.StrictNumericEscape, { at: m2(this.state.curPosition(), -1) });
        default:
          if (s2 >= 48 && s2 <= 55) {
            let r = m2(this.state.curPosition(), -1), a3 = this.input.slice(this.state.pos - 1, this.state.pos + 2).match(/^[0-7]+/)[0], n = parseInt(a3, 8);
            n > 255 && (a3 = a3.slice(0, -1), n = parseInt(a3, 8)), this.state.pos += a3.length - 1;
            let o = this.input.charCodeAt(this.state.pos);
            if (a3 !== "0" || o === 56 || o === 57) {
              if (t)
                return null;
              this.recordStrictModeErrors(l.StrictNumericEscape, { at: r });
            }
            return String.fromCharCode(n);
          }
          return String.fromCharCode(s2);
      }
    }
    readHexChar(t, e, s2) {
      let r = this.state.curPosition(), i2 = this.readInt(16, t, e, false);
      return i2 === null && (s2 ? this.raise(l.InvalidEscapeSequence, { at: r }) : this.state.pos = r.index - 1), i2;
    }
    readWord1(t) {
      this.state.containsEsc = false;
      let e = "", s2 = this.state.pos, r = this.state.pos;
      for (t !== void 0 && (this.state.pos += t <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        let i2 = this.codePointAtPos(this.state.pos);
        if (ze(i2))
          this.state.pos += i2 <= 65535 ? 1 : 2;
        else if (i2 === 92) {
          this.state.containsEsc = true, e += this.input.slice(r, this.state.pos);
          let a3 = this.state.curPosition(), n = this.state.pos === s2 ? ge2 : ze;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(l.MissingUnicodeEscape, { at: this.state.curPosition() }), r = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          let o = this.readCodePoint(true);
          o !== null && (n(o) || this.raise(l.EscapedCharNotAnIdentifier, { at: a3 }), e += String.fromCodePoint(o)), r = this.state.pos;
        } else
          break;
      }
      return e + this.input.slice(r, this.state.pos);
    }
    readWord(t) {
      let e = this.readWord1(t), s2 = ae2.get(e);
      s2 !== void 0 ? this.finishToken(s2, ve2(s2)) : this.finishToken(128, e);
    }
    checkKeywordEscapes() {
      let { type: t } = this.state;
      Vt(t) && this.state.containsEsc && this.raise(l.InvalidEscapedReservedWord, { at: this.state.startLoc, reservedWord: ve2(t) });
    }
    raise(t, e) {
      let { at: s2 } = e, r = u(e, Jo2), i2 = s2 instanceof p ? s2 : s2.loc.start, a3 = t({ loc: i2, details: r });
      if (!this.options.errorRecovery)
        throw a3;
      return this.isLookahead || this.state.errors.push(a3), a3;
    }
    raiseOverwrite(t, e) {
      let { at: s2 } = e, r = u(e, Yo), i2 = s2 instanceof p ? s2 : s2.loc.start, a3 = i2.index, n = this.state.errors;
      for (let o = n.length - 1; o >= 0; o--) {
        let c = n[o];
        if (c.loc.index === a3)
          return n[o] = t({ loc: i2, details: r });
        if (c.loc.index < a3)
          break;
      }
      return this.raise(t, e);
    }
    updateContext(t) {
    }
    unexpected(t, e) {
      throw this.raise(l.UnexpectedToken, { expected: e ? ve2(e) : null, at: t != null ? t : this.state.startLoc });
    }
    expectPlugin(t, e) {
      if (this.hasPlugin(t))
        return true;
      throw this.raise(l.MissingPlugin, { at: e != null ? e : this.state.startLoc, missingPlugin: [t] });
    }
    expectOnePlugin(t) {
      if (!t.some((e) => this.hasPlugin(e)))
        throw this.raise(l.MissingOneOfPlugins, { at: this.state.startLoc, missingPlugin: t });
    }
  }, ns2 = class {
    constructor(t) {
      this.var = /* @__PURE__ */ new Set(), this.lexical = /* @__PURE__ */ new Set(), this.functions = /* @__PURE__ */ new Set(), this.flags = t;
    }
  }, os2 = class {
    constructor(t, e) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = t, this.inModule = e;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & Ae2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & ct2) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & mr2) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & Fe2) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      let t = this.currentThisScopeFlags();
      return (t & Fe2) > 0 && (t & Ae2) === 0;
    }
    get inStaticBlock() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        let { flags: e } = this.scopeStack[t];
        if (e & Jt2)
          return true;
        if (e & (ft2 | Fe2))
          return false;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & Ae2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(t) {
      return new ns2(t);
    }
    enter(t) {
      this.scopeStack.push(this.createScope(t));
    }
    exit() {
      this.scopeStack.pop();
    }
    treatFunctionsAsVarInScope(t) {
      return !!(t.flags & (Ae2 | Jt2) || !this.parser.inModule && t.flags & $e2);
    }
    declareName(t, e, s2) {
      let r = this.currentScope();
      if (e & Se2 || e & dt2)
        this.checkRedeclarationInScope(r, t, e, s2), e & dt2 ? r.functions.add(t) : r.lexical.add(t), e & Se2 && this.maybeExportDefined(r, t);
      else if (e & yr2)
        for (let i2 = this.scopeStack.length - 1; i2 >= 0 && (r = this.scopeStack[i2], this.checkRedeclarationInScope(r, t, e, s2), r.var.add(t), this.maybeExportDefined(r, t), !(r.flags & ft2)); --i2)
          ;
      this.parser.inModule && r.flags & $e2 && this.undefinedExports.delete(t);
    }
    maybeExportDefined(t, e) {
      this.parser.inModule && t.flags & $e2 && this.undefinedExports.delete(e);
    }
    checkRedeclarationInScope(t, e, s2, r) {
      this.isRedeclaredInScope(t, e, s2) && this.parser.raise(l.VarRedeclaration, { at: r, identifierName: e });
    }
    isRedeclaredInScope(t, e, s2) {
      return s2 & Pe2 ? s2 & Se2 ? t.lexical.has(e) || t.functions.has(e) || t.var.has(e) : s2 & dt2 ? t.lexical.has(e) || !this.treatFunctionsAsVarInScope(t) && t.var.has(e) : t.lexical.has(e) && !(t.flags & dr2 && t.lexical.values().next().value === e) || !this.treatFunctionsAsVarInScope(t) && t.functions.has(e) : false;
    }
    checkLocalExport(t) {
      let { name: e } = t, s2 = this.scopeStack[0];
      !s2.lexical.has(e) && !s2.var.has(e) && !s2.functions.has(e) && this.undefinedExports.set(e, t.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        let { flags: e } = this.scopeStack[t];
        if (e & ft2)
          return e;
      }
    }
    currentThisScopeFlags() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        let { flags: e } = this.scopeStack[t];
        if (e & (ft2 | Fe2) && !(e & Xt2))
          return e;
      }
    }
  }, eh = class extends ns2 {
    constructor() {
      super(...arguments), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }, th = class extends os2 {
    createScope(t) {
      return new eh(t);
    }
    declareName(t, e, s2) {
      let r = this.currentScope();
      if (e & Zt) {
        this.checkRedeclarationInScope(r, t, e, s2), this.maybeExportDefined(r, t), r.declareFunctions.add(t);
        return;
      }
      super.declareName(...arguments);
    }
    isRedeclaredInScope(t, e, s2) {
      return super.isRedeclaredInScope(...arguments) ? true : s2 & Zt ? !t.declareFunctions.has(e) && (t.lexical.has(e) || t.functions.has(e)) : false;
    }
    checkLocalExport(t) {
      this.scopeStack[0].declareFunctions.has(t.name) || super.checkLocalExport(t);
    }
  }, sh = class {
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }, rh = class {
    constructor(t) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = t;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new sh());
    }
    exit() {
      let t = this.stack.pop(), e = this.current();
      for (let [s2, r] of Array.from(t.undefinedPrivateNames))
        e ? e.undefinedPrivateNames.has(s2) || e.undefinedPrivateNames.set(s2, r) : this.parser.raise(l.InvalidPrivateFieldResolution, { at: r, identifierName: s2 });
    }
    declarePrivateName(t, e, s2) {
      let { privateNames: r, loneAccessors: i2, undefinedPrivateNames: a3 } = this.current(), n = r.has(t);
      if (e & ss3) {
        let o = n && i2.get(t);
        if (o) {
          let c = o & xt2, f = e & xt2, y = o & ss3, T2 = e & ss3;
          n = y === T2 || c !== f, n || i2.delete(t);
        } else
          n || i2.set(t, e);
      }
      n && this.parser.raise(l.PrivateNameRedeclaration, { at: s2, identifierName: t }), r.add(t), a3.delete(t);
    }
    usePrivateName(t, e) {
      let s2;
      for (s2 of this.stack)
        if (s2.privateNames.has(t))
          return;
      s2 ? s2.undefinedPrivateNames.set(t, e) : this.parser.raise(l.InvalidPrivateFieldResolution, { at: e, identifierName: t });
    }
  }, ih = 0, Sr2 = 1, hs2 = 2, wr2 = 3, Pt2 = class {
    constructor() {
      let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ih;
      this.type = void 0, this.type = t;
    }
    canBeArrowParameterDeclaration() {
      return this.type === hs2 || this.type === Sr2;
    }
    isCertainlyParameterDeclaration() {
      return this.type === wr2;
    }
  }, Nr2 = class extends Pt2 {
    constructor(t) {
      super(t), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(t, e) {
      let { at: s2 } = e, r = s2.index;
      this.declarationErrors.set(r, [t, s2]);
    }
    clearDeclarationError(t) {
      this.declarationErrors.delete(t);
    }
    iterateErrors(t) {
      this.declarationErrors.forEach(t);
    }
  }, ah = class {
    constructor(t) {
      this.parser = void 0, this.stack = [new Pt2()], this.parser = t;
    }
    enter(t) {
      this.stack.push(t);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(t, e) {
      let { at: s2 } = e, r = { at: s2.loc.start }, { stack: i2 } = this, a3 = i2.length - 1, n = i2[a3];
      for (; !n.isCertainlyParameterDeclaration(); ) {
        if (n.canBeArrowParameterDeclaration())
          n.recordDeclarationError(t, r);
        else
          return;
        n = i2[--a3];
      }
      this.parser.raise(t, r);
    }
    recordArrowParemeterBindingError(t, e) {
      let { at: s2 } = e, { stack: r } = this, i2 = r[r.length - 1], a3 = { at: s2.loc.start };
      if (i2.isCertainlyParameterDeclaration())
        this.parser.raise(t, a3);
      else if (i2.canBeArrowParameterDeclaration())
        i2.recordDeclarationError(t, a3);
      else
        return;
    }
    recordAsyncArrowParametersError(t) {
      let { at: e } = t, { stack: s2 } = this, r = s2.length - 1, i2 = s2[r];
      for (; i2.canBeArrowParameterDeclaration(); )
        i2.type === hs2 && i2.recordDeclarationError(l.AwaitBindingIdentifier, { at: e }), i2 = s2[--r];
    }
    validateAsPattern() {
      let { stack: t } = this, e = t[t.length - 1];
      !e.canBeArrowParameterDeclaration() || e.iterateErrors((s2) => {
        let [r, i2] = s2;
        this.parser.raise(r, { at: i2 });
        let a3 = t.length - 2, n = t[a3];
        for (; n.canBeArrowParameterDeclaration(); )
          n.clearDeclarationError(i2.index), n = t[--a3];
      });
    }
  };
  function nh() {
    return new Pt2(wr2);
  }
  function oh() {
    return new Nr2(Sr2);
  }
  function hh2() {
    return new Nr2(hs2);
  }
  function Ir2() {
    return new Pt2();
  }
  var He2 = 0, kr2 = 1, Tt2 = 2, Dr2 = 4, We2 = 8, lh = class {
    constructor() {
      this.stacks = [];
    }
    enter(t) {
      this.stacks.push(t);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & Tt2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & kr2) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & Dr2) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & We2) > 0;
    }
  };
  function Et2(t, e) {
    return (t ? Tt2 : 0) | (e ? kr2 : 0);
  }
  var uh = class extends Zo {
    addExtra(t, e, s2) {
      let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      if (!t)
        return;
      let i2 = t.extra = t.extra || {};
      r ? i2[e] = s2 : Object.defineProperty(i2, e, { enumerable: r, value: s2 });
    }
    isContextual(t) {
      return this.state.type === t && !this.state.containsEsc;
    }
    isUnparsedContextual(t, e) {
      let s2 = t + e.length;
      if (this.input.slice(t, s2) === e) {
        let r = this.input.charCodeAt(s2);
        return !(ze(r) || (r & 64512) === 55296);
      }
      return false;
    }
    isLookaheadContextual(t) {
      let e = this.nextTokenStart();
      return this.isUnparsedContextual(e, t);
    }
    eatContextual(t) {
      return this.isContextual(t) ? (this.next(), true) : false;
    }
    expectContextual(t, e) {
      if (!this.eatContextual(t))
        throw e != null ? this.raise(e, { at: this.state.startLoc }) : this.unexpected(null, t);
    }
    canInsertSemicolon() {
      return this.match(135) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return is2.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
    }
    hasFollowingLineBreak() {
      return br2.lastIndex = this.state.end, br2.test(this.input);
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon() {
      ((arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true) ? this.isLineTerminator() : this.eat(13)) || this.raise(l.MissingSemicolon, { at: this.state.lastTokEndLoc });
    }
    expect(t, e) {
      this.eat(t) || this.unexpected(e, t);
    }
    tryParse(t) {
      let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.clone(), s2 = { node: null };
      try {
        let r = t(function() {
          let i2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          throw s2.node = i2, s2;
        });
        if (this.state.errors.length > e.errors.length) {
          let i2 = this.state;
          return this.state = e, this.state.tokensLength = i2.tokensLength, { node: r, error: i2.errors[e.errors.length], thrown: false, aborted: false, failState: i2 };
        }
        return { node: r, error: null, thrown: false, aborted: false, failState: null };
      } catch (r) {
        let i2 = this.state;
        if (this.state = e, r instanceof SyntaxError)
          return { node: null, error: r, thrown: true, aborted: false, failState: i2 };
        if (r === s2)
          return { node: s2.node, error: null, thrown: false, aborted: true, failState: i2 };
        throw r;
      }
    }
    checkExpressionErrors(t, e) {
      if (!t)
        return false;
      let { shorthandAssignLoc: s2, doubleProtoLoc: r, privateKeyLoc: i2, optionalParametersLoc: a3 } = t, n = !!s2 || !!r || !!a3 || !!i2;
      if (!e)
        return n;
      s2 != null && this.raise(l.InvalidCoverInitializedName, { at: s2 }), r != null && this.raise(l.DuplicateProto, { at: r }), i2 != null && this.raise(l.UnexpectedPrivateField, { at: i2 }), a3 != null && this.unexpected(a3);
    }
    isLiteralPropertyName() {
      return nr2(this.state.type);
    }
    isPrivateName(t) {
      return t.type === "PrivateName";
    }
    getPrivateNameSV(t) {
      return t.id.name;
    }
    hasPropertyAsPrivateName(t) {
      return (t.type === "MemberExpression" || t.type === "OptionalMemberExpression") && this.isPrivateName(t.property);
    }
    isOptionalChain(t) {
      return t.type === "OptionalMemberExpression" || t.type === "OptionalCallExpression";
    }
    isObjectProperty(t) {
      return t.type === "ObjectProperty";
    }
    isObjectMethod(t) {
      return t.type === "ObjectMethod";
    }
    initializeScopes() {
      let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.sourceType === "module", e = this.state.labels;
      this.state.labels = [];
      let s2 = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      let r = this.inModule;
      this.inModule = t;
      let i2 = this.scope, a3 = this.getScopeHandler();
      this.scope = new a3(this, t);
      let n = this.prodParam;
      this.prodParam = new lh();
      let o = this.classScope;
      this.classScope = new rh(this);
      let c = this.expressionScope;
      return this.expressionScope = new ah(this), () => {
        this.state.labels = e, this.exportedIdentifiers = s2, this.inModule = r, this.scope = i2, this.prodParam = n, this.classScope = o, this.expressionScope = c;
      };
    }
    enterInitialScopes() {
      let t = He2;
      this.inModule && (t |= Tt2), this.scope.enter($e2), this.prodParam.enter(t);
    }
    checkDestructuringPrivate(t) {
      let { privateKeyLoc: e } = t;
      e !== null && this.expectPlugin("destructuringPrivate", e);
    }
  }, bt2 = class {
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }, Ct2 = class {
    constructor(t, e, s2) {
      this.type = "", this.start = e, this.end = 0, this.loc = new d4(s2), t != null && t.options.ranges && (this.range = [e, 0]), t != null && t.filename && (this.loc.filename = t.filename);
    }
  }, ls2 = Ct2.prototype;
  ls2.__clone = function() {
    let t = new Ct2(), e = Object.keys(this);
    for (let s2 = 0, r = e.length; s2 < r; s2++) {
      let i2 = e[s2];
      i2 !== "leadingComments" && i2 !== "trailingComments" && i2 !== "innerComments" && (t[i2] = this[i2]);
    }
    return t;
  };
  function ch(t) {
    return Ee(t);
  }
  function Ee(t) {
    let { type: e, start: s2, end: r, loc: i2, range: a3, extra: n, name: o } = t, c = Object.create(ls2);
    return c.type = e, c.start = s2, c.end = r, c.loc = i2, c.range = a3, c.extra = n, c.name = o, e === "Placeholder" && (c.expectedNode = t.expectedNode), c;
  }
  function ph(t) {
    let { type: e, start: s2, end: r, loc: i2, range: a3, extra: n } = t;
    if (e === "Placeholder")
      return ch(t);
    let o = Object.create(ls2);
    return o.type = e, o.start = s2, o.end = r, o.loc = i2, o.range = a3, t.raw !== void 0 ? o.raw = t.raw : o.extra = n, o.value = t.value, o;
  }
  var fh = class extends uh {
    startNode() {
      return new Ct2(this, this.state.start, this.state.startLoc);
    }
    startNodeAt(t, e) {
      return new Ct2(this, t, e);
    }
    startNodeAtNode(t) {
      return this.startNodeAt(t.start, t.loc.start);
    }
    finishNode(t, e) {
      return this.finishNodeAt(t, e, this.state.lastTokEndLoc);
    }
    finishNodeAt(t, e, s2) {
      return t.type = e, t.end = s2.index, t.loc.end = s2, this.options.ranges && (t.range[1] = s2.index), this.options.attachComment && this.processComment(t), t;
    }
    resetStartLocation(t, e, s2) {
      t.start = e, t.loc.start = s2, this.options.ranges && (t.range[0] = e);
    }
    resetEndLocation(t) {
      let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.lastTokEndLoc;
      t.end = e.index, t.loc.end = e, this.options.ranges && (t.range[1] = e.index);
    }
    resetStartLocationFromNode(t, e) {
      this.resetStartLocation(t, e.start, e.loc.start);
    }
  }, dh = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), I2 = j(jn$1 || (jn$1 = ht$1(["flow"])))((t) => ({ AmbiguousConditionalArrow: t("Ambiguous expression: wrap the arrow functions in parentheses to disambiguate."), AmbiguousDeclareModuleKind: t("Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module."), AssignReservedType: t((e) => {
    let { reservedType: s2 } = e;
    return "Cannot overwrite reserved type ".concat(s2, ".");
  }), DeclareClassElement: t("The `declare` modifier can only appear on class fields."), DeclareClassFieldInitializer: t("Initializers are not allowed in fields with the `declare` modifier."), DuplicateDeclareModuleExports: t("Duplicate `declare module.exports` statement."), EnumBooleanMemberNotInitialized: t((e) => {
    let { memberName: s2, enumName: r } = e;
    return "Boolean enum members need to be initialized. Use either `".concat(s2, " = true,` or `").concat(s2, " = false,` in enum `").concat(r, "`.");
  }), EnumDuplicateMemberName: t((e) => {
    let { memberName: s2, enumName: r } = e;
    return "Enum member names need to be unique, but the name `".concat(s2, "` has already been used before in enum `").concat(r, "`.");
  }), EnumInconsistentMemberValues: t((e) => {
    let { enumName: s2 } = e;
    return "Enum `".concat(s2, "` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.");
  }), EnumInvalidExplicitType: t((e) => {
    let { invalidEnumType: s2, enumName: r } = e;
    return "Enum type `".concat(s2, "` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `").concat(r, "`.");
  }), EnumInvalidExplicitTypeUnknownSupplied: t((e) => {
    let { enumName: s2 } = e;
    return "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `".concat(s2, "`.");
  }), EnumInvalidMemberInitializerPrimaryType: t((e) => {
    let { enumName: s2, memberName: r, explicitType: i2 } = e;
    return "Enum `".concat(s2, "` has type `").concat(i2, "`, so the initializer of `").concat(r, "` needs to be a ").concat(i2, " literal.");
  }), EnumInvalidMemberInitializerSymbolType: t((e) => {
    let { enumName: s2, memberName: r } = e;
    return "Symbol enum members cannot be initialized. Use `".concat(r, ",` in enum `").concat(s2, "`.");
  }), EnumInvalidMemberInitializerUnknownType: t((e) => {
    let { enumName: s2, memberName: r } = e;
    return "The enum member initializer for `".concat(r, "` needs to be a literal (either a boolean, number, or string) in enum `").concat(s2, "`.");
  }), EnumInvalidMemberName: t((e) => {
    let { enumName: s2, memberName: r, suggestion: i2 } = e;
    return "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `".concat(r, "`, consider using `").concat(i2, "`, in enum `").concat(s2, "`.");
  }), EnumNumberMemberNotInitialized: t((e) => {
    let { enumName: s2, memberName: r } = e;
    return "Number enum members need to be initialized, e.g. `".concat(r, " = 1` in enum `").concat(s2, "`.");
  }), EnumStringMemberInconsistentlyInitailized: t((e) => {
    let { enumName: s2 } = e;
    return "String enum members need to consistently either all use initializers, or use no initializers, in enum `".concat(s2, "`.");
  }), GetterMayNotHaveThisParam: t("A getter cannot have a `this` parameter."), ImportTypeShorthandOnlyInPureImport: t("The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements."), InexactInsideExact: t("Explicit inexact syntax cannot appear inside an explicit exact object type."), InexactInsideNonObject: t("Explicit inexact syntax cannot appear in class or interface definitions."), InexactVariance: t("Explicit inexact syntax cannot have variance."), InvalidNonTypeImportInDeclareModule: t("Imports within a `declare module` body must always be `import type` or `import typeof`."), MissingTypeParamDefault: t("Type parameter declaration needs a default, since a preceding type parameter declaration has a default."), NestedDeclareModule: t("`declare module` cannot be used inside another `declare module`."), NestedFlowComment: t("Cannot have a flow comment inside another flow comment."), PatternIsOptional: t("A binding pattern parameter cannot be optional in an implementation signature.", { reasonCode: "OptionalBindingPattern" }), SetterMayNotHaveThisParam: t("A setter cannot have a `this` parameter."), SpreadVariance: t("Spread properties cannot have variance."), ThisParamAnnotationRequired: t("A type annotation is required for the `this` parameter."), ThisParamBannedInConstructor: t("Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions."), ThisParamMayNotBeOptional: t("The `this` parameter cannot be optional."), ThisParamMustBeFirst: t("The `this` parameter must be the first function parameter."), ThisParamNoDefault: t("The `this` parameter may not have a default value."), TypeBeforeInitializer: t("Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`."), TypeCastInPattern: t("The type cast expression is expected to be wrapped with parenthesis."), UnexpectedExplicitInexactInObject: t("Explicit inexact syntax must appear at the end of an inexact object."), UnexpectedReservedType: t((e) => {
    let { reservedType: s2 } = e;
    return "Unexpected reserved type ".concat(s2, ".");
  }), UnexpectedReservedUnderscore: t("`_` is only allowed as a type argument to call or new."), UnexpectedSpaceBetweenModuloChecks: t("Spaces between `%` and `checks` are not allowed here."), UnexpectedSpreadType: t("Spread operator cannot appear in class or interface definitions."), UnexpectedSubtractionOperand: t('Unexpected token, expected "number" or "bigint".'), UnexpectedTokenAfterTypeParameter: t("Expected an arrow function after this type parameter declaration."), UnexpectedTypeParameterBeforeAsyncArrowFunction: t("Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`."), UnsupportedDeclareExportKind: t((e) => {
    let { unsupportedExportKind: s2, suggestion: r } = e;
    return "`declare export ".concat(s2, "` is not supported. Use `").concat(r, "` instead.");
  }), UnsupportedStatementInDeclareModule: t("Only declares and type imports are allowed inside declare module."), UnterminatedFlowComment: t("Unterminated flow-comment.") }));
  function mh(t) {
    return t.type === "DeclareExportAllDeclaration" || t.type === "DeclareExportDeclaration" && (!t.declaration || t.declaration.type !== "TypeAlias" && t.declaration.type !== "InterfaceDeclaration");
  }
  function us2(t) {
    return t.importKind === "type" || t.importKind === "typeof";
  }
  function Fr2(t) {
    return ye2(t) && t !== 97;
  }
  var yh = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" };
  function xh(t, e) {
    let s2 = [], r = [];
    for (let i2 = 0; i2 < t.length; i2++)
      (e(t[i2], i2, t) ? s2 : r).push(t[i2]);
    return [s2, r];
  }
  var gh = /\*?\s*@((?:no)?flow)\b/, Ah = (t) => class extends t {
    constructor() {
      super(...arguments), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return th;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(e, s2) {
      return e !== 129 && e !== 13 && e !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(e, s2);
    }
    addComment(e) {
      if (this.flowPragma === void 0) {
        let s2 = gh.exec(e.value);
        if (s2)
          if (s2[1] === "flow")
            this.flowPragma = "flow";
          else if (s2[1] === "noflow")
            this.flowPragma = "noflow";
          else
            throw new Error("Unexpected flow pragma");
      }
      return super.addComment(e);
    }
    flowParseTypeInitialiser(e) {
      let s2 = this.state.inType;
      this.state.inType = true, this.expect(e || 14);
      let r = this.flowParseType();
      return this.state.inType = s2, r;
    }
    flowParsePredicate() {
      let e = this.startNode(), s2 = this.state.startLoc;
      return this.next(), this.expectContextual(107), this.state.lastTokStart > s2.index + 1 && this.raise(I2.UnexpectedSpaceBetweenModuloChecks, { at: s2 }), this.eat(10) ? (e.value = this.parseExpression(), this.expect(11), this.finishNode(e, "DeclaredPredicate")) : this.finishNode(e, "InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      let e = this.state.inType;
      this.state.inType = true, this.expect(14);
      let s2 = null, r = null;
      return this.match(54) ? (this.state.inType = e, r = this.flowParsePredicate()) : (s2 = this.flowParseType(), this.state.inType = e, this.match(54) && (r = this.flowParsePredicate())), [s2, r];
    }
    flowParseDeclareClass(e) {
      return this.next(), this.flowParseInterfaceish(e, true), this.finishNode(e, "DeclareClass");
    }
    flowParseDeclareFunction(e) {
      this.next();
      let s2 = e.id = this.parseIdentifier(), r = this.startNode(), i2 = this.startNode();
      this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, this.expect(10);
      let a3 = this.flowParseFunctionTypeParams();
      return r.params = a3.params, r.rest = a3.rest, r.this = a3._this, this.expect(11), [r.returnType, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), i2.typeAnnotation = this.finishNode(r, "FunctionTypeAnnotation"), s2.typeAnnotation = this.finishNode(i2, "TypeAnnotation"), this.resetEndLocation(s2), this.semicolon(), this.scope.declareName(e.id.name, qo2, e.id.loc.start), this.finishNode(e, "DeclareFunction");
    }
    flowParseDeclare(e, s2) {
      if (this.match(80))
        return this.flowParseDeclareClass(e);
      if (this.match(68))
        return this.flowParseDeclareFunction(e);
      if (this.match(74))
        return this.flowParseDeclareVariable(e);
      if (this.eatContextual(123))
        return this.match(16) ? this.flowParseDeclareModuleExports(e) : (s2 && this.raise(I2.NestedDeclareModule, { at: this.state.lastTokStartLoc }), this.flowParseDeclareModule(e));
      if (this.isContextual(126))
        return this.flowParseDeclareTypeAlias(e);
      if (this.isContextual(127))
        return this.flowParseDeclareOpaqueType(e);
      if (this.isContextual(125))
        return this.flowParseDeclareInterface(e);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(e, s2);
      throw this.unexpected();
    }
    flowParseDeclareVariable(e) {
      return this.next(), e.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(e.id.name, yt2, e.id.loc.start), this.semicolon(), this.finishNode(e, "DeclareVariable");
    }
    flowParseDeclareModule(e) {
      this.scope.enter(Ke2), this.match(129) ? e.id = this.parseExprAtom() : e.id = this.parseIdentifier();
      let s2 = e.body = this.startNode(), r = s2.body = [];
      for (this.expect(5); !this.match(8); ) {
        let n = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(126) && !this.match(87) && this.raise(I2.InvalidNonTypeImportInDeclareModule, { at: this.state.lastTokStartLoc }), this.parseImport(n)) : (this.expectContextual(121, I2.UnsupportedStatementInDeclareModule), n = this.flowParseDeclare(n, true)), r.push(n);
      }
      this.scope.exit(), this.expect(8), this.finishNode(s2, "BlockStatement");
      let i2 = null, a3 = false;
      return r.forEach((n) => {
        mh(n) ? (i2 === "CommonJS" && this.raise(I2.AmbiguousDeclareModuleKind, { at: n }), i2 = "ES") : n.type === "DeclareModuleExports" && (a3 && this.raise(I2.DuplicateDeclareModuleExports, { at: n }), i2 === "ES" && this.raise(I2.AmbiguousDeclareModuleKind, { at: n }), i2 = "CommonJS", a3 = true);
      }), e.kind = i2 || "CommonJS", this.finishNode(e, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(e, s2) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? e.declaration = this.flowParseDeclare(this.startNode()) : (e.declaration = this.flowParseType(), this.semicolon()), e.default = true, this.finishNode(e, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(126) || this.isContextual(125)) && !s2) {
        let r = this.state.value;
        throw this.raise(I2.UnsupportedDeclareExportKind, { at: this.state.startLoc, unsupportedExportKind: r, suggestion: yh[r] });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(127))
        return e.declaration = this.flowParseDeclare(this.startNode()), e.default = false, this.finishNode(e, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(125) || this.isContextual(126) || this.isContextual(127))
        return e = this.parseExport(e), e.type === "ExportNamedDeclaration" && (e.type = "ExportDeclaration", e.default = false, delete e.exportKind), e.type = "Declare" + e.type, e;
      throw this.unexpected();
    }
    flowParseDeclareModuleExports(e) {
      return this.next(), this.expectContextual(108), e.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(e, "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(e) {
      return this.next(), this.flowParseTypeAlias(e), e.type = "DeclareTypeAlias", e;
    }
    flowParseDeclareOpaqueType(e) {
      return this.next(), this.flowParseOpaqueType(e, true), e.type = "DeclareOpaqueType", e;
    }
    flowParseDeclareInterface(e) {
      return this.next(), this.flowParseInterfaceish(e), this.finishNode(e, "DeclareInterface");
    }
    flowParseInterfaceish(e) {
      let s2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (e.id = this.flowParseRestrictedIdentifier(!s2, true), this.scope.declareName(e.id.name, s2 ? Ar2 : Te2, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.extends = [], e.implements = [], e.mixins = [], this.eat(81))
        do
          e.extends.push(this.flowParseInterfaceExtends());
        while (!s2 && this.eat(12));
      if (this.isContextual(114)) {
        this.next();
        do
          e.mixins.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      }
      if (this.isContextual(110)) {
        this.next();
        do
          e.implements.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      }
      e.body = this.flowParseObjectType({ allowStatic: s2, allowExact: false, allowSpread: false, allowProto: s2, allowInexact: false });
    }
    flowParseInterfaceExtends() {
      let e = this.startNode();
      return e.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? e.typeParameters = this.flowParseTypeParameterInstantiation() : e.typeParameters = null, this.finishNode(e, "InterfaceExtends");
    }
    flowParseInterface(e) {
      return this.flowParseInterfaceish(e), this.finishNode(e, "InterfaceDeclaration");
    }
    checkNotUnderscore(e) {
      e === "_" && this.raise(I2.UnexpectedReservedUnderscore, { at: this.state.startLoc });
    }
    checkReservedType(e, s2, r) {
      !dh.has(e) || this.raise(r ? I2.AssignReservedType : I2.UnexpectedReservedType, { at: s2, reservedType: e });
    }
    flowParseRestrictedIdentifier(e, s2) {
      return this.checkReservedType(this.state.value, this.state.startLoc, s2), this.parseIdentifier(e);
    }
    flowParseTypeAlias(e) {
      return e.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(e.id.name, Te2, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(e, "TypeAlias");
    }
    flowParseOpaqueType(e, s2) {
      return this.expectContextual(126), e.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(e.id.name, Te2, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.supertype = null, this.match(14) && (e.supertype = this.flowParseTypeInitialiser(14)), e.impltype = null, s2 || (e.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e, "OpaqueType");
    }
    flowParseTypeParameter() {
      let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, s2 = this.state.startLoc, r = this.startNode(), i2 = this.flowParseVariance(), a3 = this.flowParseTypeAnnotatableIdentifier();
      return r.name = a3.name, r.variance = i2, r.bound = a3.typeAnnotation, this.match(29) ? (this.eat(29), r.default = this.flowParseType()) : e && this.raise(I2.MissingTypeParamDefault, { at: s2 }), this.finishNode(r, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      let e = this.state.inType, s2 = this.startNode();
      s2.params = [], this.state.inType = true, this.match(47) || this.match(138) ? this.next() : this.unexpected();
      let r = false;
      do {
        let i2 = this.flowParseTypeParameter(r);
        s2.params.push(i2), i2.default && (r = true), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = e, this.finishNode(s2, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      let e = this.startNode(), s2 = this.state.inType;
      e.params = [], this.state.inType = true, this.expect(47);
      let r = this.state.noAnonFunctionType;
      for (this.state.noAnonFunctionType = false; !this.match(48); )
        e.params.push(this.flowParseType()), this.match(48) || this.expect(12);
      return this.state.noAnonFunctionType = r, this.expect(48), this.state.inType = s2, this.finishNode(e, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      let e = this.startNode(), s2 = this.state.inType;
      for (e.params = [], this.state.inType = true, this.expect(47); !this.match(48); )
        e.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = s2, this.finishNode(e, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      let e = this.startNode();
      if (this.expectContextual(125), e.extends = [], this.eat(81))
        do
          e.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return e.body = this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false }), this.finishNode(e, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(130) || this.match(129) ? this.parseExprAtom() : this.parseIdentifier(true);
    }
    flowParseObjectTypeIndexer(e, s2, r) {
      return e.static = s2, this.lookahead().type === 14 ? (e.id = this.flowParseObjectPropertyKey(), e.key = this.flowParseTypeInitialiser()) : (e.id = null, e.key = this.flowParseType()), this.expect(3), e.value = this.flowParseTypeInitialiser(), e.variance = r, this.finishNode(e, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(e, s2) {
      return e.static = s2, e.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (e.method = true, e.optional = false, e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.start, e.loc.start))) : (e.method = false, this.eat(17) && (e.optional = true), e.value = this.flowParseTypeInitialiser()), this.finishNode(e, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(e) {
      for (e.params = [], e.rest = null, e.typeParameters = null, e.this = null, this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (e.this = this.flowParseFunctionTypeParam(true), e.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
        e.params.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
      return this.eat(21) && (e.rest = this.flowParseFunctionTypeParam(false)), this.expect(11), e.returnType = this.flowParseTypeInitialiser(), this.finishNode(e, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(e, s2) {
      let r = this.startNode();
      return e.static = s2, e.value = this.flowParseObjectTypeMethodish(r), this.finishNode(e, "ObjectTypeCallProperty");
    }
    flowParseObjectType(e) {
      let { allowStatic: s2, allowExact: r, allowSpread: i2, allowProto: a3, allowInexact: n } = e, o = this.state.inType;
      this.state.inType = true;
      let c = this.startNode();
      c.callProperties = [], c.properties = [], c.indexers = [], c.internalSlots = [];
      let f, y, T2 = false;
      for (r && this.match(6) ? (this.expect(6), f = 9, y = true) : (this.expect(5), f = 8, y = false), c.exact = y; !this.match(f); ) {
        let N = false, R = null, z = null, te2 = this.startNode();
        if (a3 && this.isContextual(115)) {
          let pe = this.lookahead();
          pe.type !== 14 && pe.type !== 17 && (this.next(), R = this.state.startLoc, s2 = false);
        }
        if (s2 && this.isContextual(104)) {
          let pe = this.lookahead();
          pe.type !== 14 && pe.type !== 17 && (this.next(), N = true);
        }
        let he2 = this.flowParseVariance();
        if (this.eat(0))
          R != null && this.unexpected(R), this.eat(0) ? (he2 && this.unexpected(he2.loc.start), c.internalSlots.push(this.flowParseObjectTypeInternalSlot(te2, N))) : c.indexers.push(this.flowParseObjectTypeIndexer(te2, N, he2));
        else if (this.match(10) || this.match(47))
          R != null && this.unexpected(R), he2 && this.unexpected(he2.loc.start), c.callProperties.push(this.flowParseObjectTypeCallProperty(te2, N));
        else {
          let pe = "init";
          if (this.isContextual(98) || this.isContextual(103)) {
            let de2 = this.lookahead();
            nr2(de2.type) && (pe = this.state.value, this.next());
          }
          let st2 = this.flowParseObjectTypeProperty(te2, N, R, he2, pe, i2, n != null ? n : !y);
          st2 === null ? (T2 = true, z = this.state.lastTokStartLoc) : c.properties.push(st2);
        }
        this.flowObjectTypeSemicolon(), z && !this.match(8) && !this.match(9) && this.raise(I2.UnexpectedExplicitInexactInObject, { at: z });
      }
      this.expect(f), i2 && (c.inexact = T2);
      let v = this.finishNode(c, "ObjectTypeAnnotation");
      return this.state.inType = o, v;
    }
    flowParseObjectTypeProperty(e, s2, r, i2, a3, n, o) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (n ? o || this.raise(I2.InexactInsideExact, { at: this.state.lastTokStartLoc }) : this.raise(I2.InexactInsideNonObject, { at: this.state.lastTokStartLoc }), i2 && this.raise(I2.InexactVariance, { at: i2 }), null) : (n || this.raise(I2.UnexpectedSpreadType, { at: this.state.lastTokStartLoc }), r != null && this.unexpected(r), i2 && this.raise(I2.SpreadVariance, { at: i2 }), e.argument = this.flowParseType(), this.finishNode(e, "ObjectTypeSpreadProperty"));
      {
        e.key = this.flowParseObjectPropertyKey(), e.static = s2, e.proto = r != null, e.kind = a3;
        let c = false;
        return this.match(47) || this.match(10) ? (e.method = true, r != null && this.unexpected(r), i2 && this.unexpected(i2.loc.start), e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.start, e.loc.start)), (a3 === "get" || a3 === "set") && this.flowCheckGetterSetterParams(e), !n && e.key.name === "constructor" && e.value.this && this.raise(I2.ThisParamBannedInConstructor, { at: e.value.this })) : (a3 !== "init" && this.unexpected(), e.method = false, this.eat(17) && (c = true), e.value = this.flowParseTypeInitialiser(), e.variance = i2), e.optional = c, this.finishNode(e, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(e) {
      let s2 = e.kind === "get" ? 0 : 1, r = e.value.params.length + (e.value.rest ? 1 : 0);
      e.value.this && this.raise(e.kind === "get" ? I2.GetterMayNotHaveThisParam : I2.SetterMayNotHaveThisParam, { at: e.value.this }), r !== s2 && this.raise(e.kind === "get" ? l.BadGetterArity : l.BadSetterArity, { at: e }), e.kind === "set" && e.value.rest && this.raise(l.BadSetterRestParameter, { at: e });
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(e, s2, r) {
      e = e || this.state.start, s2 = s2 || this.state.startLoc;
      let i2 = r || this.flowParseRestrictedIdentifier(true);
      for (; this.eat(16); ) {
        let a3 = this.startNodeAt(e, s2);
        a3.qualification = i2, a3.id = this.flowParseRestrictedIdentifier(true), i2 = this.finishNode(a3, "QualifiedTypeIdentifier");
      }
      return i2;
    }
    flowParseGenericType(e, s2, r) {
      let i2 = this.startNodeAt(e, s2);
      return i2.typeParameters = null, i2.id = this.flowParseQualifiedTypeIdentifier(e, s2, r), this.match(47) && (i2.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(i2, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      let e = this.startNode();
      return this.expect(87), e.argument = this.flowParsePrimaryType(), this.finishNode(e, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      let e = this.startNode();
      for (e.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (e.types.push(this.flowParseType()), !this.match(3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(e, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(e) {
      let s2 = null, r = false, i2 = null, a3 = this.startNode(), n = this.lookahead(), o = this.state.type === 78;
      return n.type === 14 || n.type === 17 ? (o && !e && this.raise(I2.ThisParamMustBeFirst, { at: a3 }), s2 = this.parseIdentifier(o), this.eat(17) && (r = true, o && this.raise(I2.ThisParamMayNotBeOptional, { at: a3 })), i2 = this.flowParseTypeInitialiser()) : i2 = this.flowParseType(), a3.name = s2, a3.optional = r, a3.typeAnnotation = i2, this.finishNode(a3, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(e) {
      let s2 = this.startNodeAt(e.start, e.loc.start);
      return s2.name = null, s2.optional = false, s2.typeAnnotation = e, this.finishNode(s2, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams() {
      let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], s2 = null, r = null;
      for (this.match(78) && (r = this.flowParseFunctionTypeParam(true), r.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
        e.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
      return this.eat(21) && (s2 = this.flowParseFunctionTypeParam(false)), { params: e, rest: s2, _this: r };
    }
    flowIdentToTypeAnnotation(e, s2, r, i2) {
      switch (i2.name) {
        case "any":
          return this.finishNode(r, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(r, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(r, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(r, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(r, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(r, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(r, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(i2.name), this.flowParseGenericType(e, s2, i2);
      }
    }
    flowParsePrimaryType() {
      let e = this.state.start, s2 = this.state.startLoc, r = this.startNode(), i2, a3, n = false, o = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true });
        case 6:
          return this.flowParseObjectType({ allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false });
        case 0:
          return this.state.noAnonFunctionType = false, a3 = this.flowParseTupleType(), this.state.noAnonFunctionType = o, a3;
        case 47:
          return r.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), i2 = this.flowParseFunctionTypeParams(), r.params = i2.params, r.rest = i2.rest, r.this = i2._this, this.expect(11), this.expect(19), r.returnType = this.flowParseType(), this.finishNode(r, "FunctionTypeAnnotation");
        case 10:
          if (this.next(), !this.match(11) && !this.match(21))
            if (K(this.state.type) || this.match(78)) {
              let c = this.lookahead().type;
              n = c !== 17 && c !== 14;
            } else
              n = true;
          if (n) {
            if (this.state.noAnonFunctionType = false, a3 = this.flowParseType(), this.state.noAnonFunctionType = o, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), a3;
            this.eat(12);
          }
          return a3 ? i2 = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(a3)]) : i2 = this.flowParseFunctionTypeParams(), r.params = i2.params, r.rest = i2.rest, r.this = i2._this, this.expect(11), this.expect(19), r.returnType = this.flowParseType(), r.typeParameters = null, this.finishNode(r, "FunctionTypeAnnotation");
        case 129:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return r.value = this.match(85), this.next(), this.finishNode(r, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(130))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", r);
            if (this.match(131))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", r);
            throw this.raise(I2.UnexpectedSubtractionOperand, { at: this.state.startLoc });
          }
          throw this.unexpected();
        case 130:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 131:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(r, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(r, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(r, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(r, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (Vt(this.state.type)) {
            let c = ve2(this.state.type);
            return this.next(), super.createIdentifier(r, c);
          } else if (K(this.state.type))
            return this.isContextual(125) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(e, s2, r, this.parseIdentifier());
      }
      throw this.unexpected();
    }
    flowParsePostfixType() {
      let e = this.state.start, s2 = this.state.startLoc, r = this.flowParsePrimaryType(), i2 = false;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        let a3 = this.startNodeAt(e, s2), n = this.eat(18);
        i2 = i2 || n, this.expect(0), !n && this.match(3) ? (a3.elementType = r, this.next(), r = this.finishNode(a3, "ArrayTypeAnnotation")) : (a3.objectType = r, a3.indexType = this.flowParseType(), this.expect(3), i2 ? (a3.optional = n, r = this.finishNode(a3, "OptionalIndexedAccessType")) : r = this.finishNode(a3, "IndexedAccessType"));
      }
      return r;
    }
    flowParsePrefixType() {
      let e = this.startNode();
      return this.eat(17) ? (e.typeAnnotation = this.flowParsePrefixType(), this.finishNode(e, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      let e = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        let s2 = this.startNodeAt(e.start, e.loc.start);
        return s2.params = [this.reinterpretTypeAsFunctionTypeParam(e)], s2.rest = null, s2.this = null, s2.returnType = this.flowParseType(), s2.typeParameters = null, this.finishNode(s2, "FunctionTypeAnnotation");
      }
      return e;
    }
    flowParseIntersectionType() {
      let e = this.startNode();
      this.eat(45);
      let s2 = this.flowParseAnonFunctionWithoutParens();
      for (e.types = [s2]; this.eat(45); )
        e.types.push(this.flowParseAnonFunctionWithoutParens());
      return e.types.length === 1 ? s2 : this.finishNode(e, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      let e = this.startNode();
      this.eat(43);
      let s2 = this.flowParseIntersectionType();
      for (e.types = [s2]; this.eat(43); )
        e.types.push(this.flowParseIntersectionType());
      return e.types.length === 1 ? s2 : this.finishNode(e, "UnionTypeAnnotation");
    }
    flowParseType() {
      let e = this.state.inType;
      this.state.inType = true;
      let s2 = this.flowParseUnionType();
      return this.state.inType = e, s2;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 128 && this.state.value === "_") {
        let e = this.state.start, s2 = this.state.startLoc, r = this.parseIdentifier();
        return this.flowParseGenericType(e, s2, r);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      let e = this.startNode();
      return e.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(e, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(e) {
      let s2 = e ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (s2.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(s2)), s2;
    }
    typeCastToParameter(e) {
      return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
    }
    flowParseVariance() {
      let e = null;
      return this.match(53) && (e = this.startNode(), this.state.value === "+" ? e.kind = "plus" : e.kind = "minus", this.next(), this.finishNode(e, "Variance")), e;
    }
    parseFunctionBody(e, s2) {
      let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      return s2 ? this.forwardNoArrowParamsConversionAt(e, () => super.parseFunctionBody(e, true, r)) : super.parseFunctionBody(e, false, r);
    }
    parseFunctionBodyAndFinish(e, s2) {
      let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      if (this.match(14)) {
        let i2 = this.startNode();
        [i2.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), e.returnType = i2.typeAnnotation ? this.finishNode(i2, "TypeAnnotation") : null;
      }
      super.parseFunctionBodyAndFinish(e, s2, r);
    }
    parseStatement(e, s2) {
      if (this.state.strict && this.isContextual(125)) {
        let i2 = this.lookahead();
        if (ye2(i2.type)) {
          let a3 = this.startNode();
          return this.next(), this.flowParseInterface(a3);
        }
      } else if (this.shouldParseEnums() && this.isContextual(122)) {
        let i2 = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(i2);
      }
      let r = super.parseStatement(e, s2);
      return this.flowPragma === void 0 && !this.isValidDirective(r) && (this.flowPragma = null), r;
    }
    parseExpressionStatement(e, s2) {
      if (s2.type === "Identifier") {
        if (s2.name === "declare") {
          if (this.match(80) || K(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(e);
        } else if (K(this.state.type)) {
          if (s2.name === "interface")
            return this.flowParseInterface(e);
          if (s2.name === "type")
            return this.flowParseTypeAlias(e);
          if (s2.name === "opaque")
            return this.flowParseOpaqueType(e, false);
        }
      }
      return super.parseExpressionStatement(e, s2);
    }
    shouldParseExportDeclaration() {
      let { type: e } = this.state;
      return or2(e) || this.shouldParseEnums() && e === 122 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      let { type: e } = this.state;
      return or2(e) || this.shouldParseEnums() && e === 122 ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual(122)) {
        let e = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(e);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(e, s2, r, i2) {
      if (!this.match(17))
        return e;
      if (this.state.maybeInArrowParameters) {
        let v = this.lookaheadCharCode();
        if (v === 44 || v === 61 || v === 58 || v === 41)
          return this.setOptionalParametersError(i2), e;
      }
      this.expect(17);
      let a3 = this.state.clone(), n = this.state.noArrowAt, o = this.startNodeAt(s2, r), { consequent: c, failed: f } = this.tryParseConditionalConsequent(), [y, T2] = this.getArrowLikeExpressions(c);
      if (f || T2.length > 0) {
        let v = [...n];
        if (T2.length > 0) {
          this.state = a3, this.state.noArrowAt = v;
          for (let N = 0; N < T2.length; N++)
            v.push(T2[N].start);
          ({ consequent: c, failed: f } = this.tryParseConditionalConsequent()), [y, T2] = this.getArrowLikeExpressions(c);
        }
        f && y.length > 1 && this.raise(I2.AmbiguousConditionalArrow, { at: a3.startLoc }), f && y.length === 1 && (this.state = a3, v.push(y[0].start), this.state.noArrowAt = v, { consequent: c, failed: f } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(c, true), this.state.noArrowAt = n, this.expect(14), o.test = e, o.consequent = c, o.alternate = this.forwardNoArrowParamsConversionAt(o, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(o, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      let e = this.parseMaybeAssignAllowIn(), s2 = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), { consequent: e, failed: s2 };
    }
    getArrowLikeExpressions(e, s2) {
      let r = [e], i2 = [];
      for (; r.length !== 0; ) {
        let a3 = r.pop();
        a3.type === "ArrowFunctionExpression" ? (a3.typeParameters || !a3.returnType ? this.finishArrowValidation(a3) : i2.push(a3), r.push(a3.body)) : a3.type === "ConditionalExpression" && (r.push(a3.consequent), r.push(a3.alternate));
      }
      return s2 ? (i2.forEach((a3) => this.finishArrowValidation(a3)), [i2, []]) : xh(i2, (a3) => a3.params.every((n) => this.isAssignable(n, true)));
    }
    finishArrowValidation(e) {
      var s2;
      this.toAssignableList(e.params, (s2 = e.extra) == null ? void 0 : s2.trailingCommaLoc, false), this.scope.enter(Ae2 | Xt2), super.checkParams(e, false, true), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(e, s2) {
      let r;
      return this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), r = s2(), this.state.noArrowParamsConversionAt.pop()) : r = s2(), r;
    }
    parseParenItem(e, s2, r) {
      if (e = super.parseParenItem(e, s2, r), this.eat(17) && (e.optional = true, this.resetEndLocation(e)), this.match(14)) {
        let i2 = this.startNodeAt(s2, r);
        return i2.expression = e, i2.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(i2, "TypeCastExpression");
      }
      return e;
    }
    assertModuleNodeAllowed(e) {
      e.type === "ImportDeclaration" && (e.importKind === "type" || e.importKind === "typeof") || e.type === "ExportNamedDeclaration" && e.exportKind === "type" || e.type === "ExportAllDeclaration" && e.exportKind === "type" || super.assertModuleNodeAllowed(e);
    }
    parseExport(e) {
      let s2 = super.parseExport(e);
      return (s2.type === "ExportNamedDeclaration" || s2.type === "ExportAllDeclaration") && (s2.exportKind = s2.exportKind || "value"), s2;
    }
    parseExportDeclaration(e) {
      if (this.isContextual(126)) {
        e.exportKind = "type";
        let s2 = this.startNode();
        return this.next(), this.match(5) ? (e.specifiers = this.parseExportSpecifiers(true), this.parseExportFrom(e), null) : this.flowParseTypeAlias(s2);
      } else if (this.isContextual(127)) {
        e.exportKind = "type";
        let s2 = this.startNode();
        return this.next(), this.flowParseOpaqueType(s2, false);
      } else if (this.isContextual(125)) {
        e.exportKind = "type";
        let s2 = this.startNode();
        return this.next(), this.flowParseInterface(s2);
      } else if (this.shouldParseEnums() && this.isContextual(122)) {
        e.exportKind = "value";
        let s2 = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(s2);
      } else
        return super.parseExportDeclaration(e);
    }
    eatExportStar(e) {
      return super.eatExportStar(...arguments) ? true : this.isContextual(126) && this.lookahead().type === 55 ? (e.exportKind = "type", this.next(), this.next(), true) : false;
    }
    maybeParseExportNamespaceSpecifier(e) {
      let { startLoc: s2 } = this.state, r = super.maybeParseExportNamespaceSpecifier(e);
      return r && e.exportKind === "type" && this.unexpected(s2), r;
    }
    parseClassId(e, s2, r) {
      super.parseClassId(e, s2, r), this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(e, s2, r) {
      let { startLoc: i2 } = this.state;
      if (this.isContextual(121)) {
        if (this.parseClassMemberFromModifier(e, s2))
          return;
        s2.declare = true;
      }
      super.parseClassMember(e, s2, r), s2.declare && (s2.type !== "ClassProperty" && s2.type !== "ClassPrivateProperty" && s2.type !== "PropertyDefinition" ? this.raise(I2.DeclareClassElement, { at: i2 }) : s2.value && this.raise(I2.DeclareClassFieldInitializer, { at: s2.value }));
    }
    isIterator(e) {
      return e === "iterator" || e === "asyncIterator";
    }
    readIterator() {
      let e = super.readWord1(), s2 = "@@" + e;
      (!this.isIterator(e) || !this.state.inType) && this.raise(l.InvalidIdentifier, { at: this.state.curPosition(), identifierName: s2 }), this.finishToken(128, s2);
    }
    getTokenFromCode(e) {
      let s2 = this.input.charCodeAt(this.state.pos + 1);
      return e === 123 && s2 === 124 ? this.finishOp(6, 2) : this.state.inType && (e === 62 || e === 60) ? this.finishOp(e === 62 ? 48 : 47, 1) : this.state.inType && e === 63 ? s2 === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : Do2(e, s2, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(e);
    }
    isAssignable(e, s2) {
      return e.type === "TypeCastExpression" ? this.isAssignable(e.expression, s2) : super.isAssignable(e, s2);
    }
    toAssignable(e) {
      !(arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false) && e.type === "AssignmentExpression" && e.left.type === "TypeCastExpression" && (e.left = this.typeCastToParameter(e.left)), super.toAssignable(...arguments);
    }
    toAssignableList(e, s2, r) {
      for (let i2 = 0; i2 < e.length; i2++) {
        let a3 = e[i2];
        (a3 == null ? void 0 : a3.type) === "TypeCastExpression" && (e[i2] = this.typeCastToParameter(a3));
      }
      super.toAssignableList(e, s2, r);
    }
    toReferencedList(e, s2) {
      for (let i2 = 0; i2 < e.length; i2++) {
        var r;
        let a3 = e[i2];
        a3 && a3.type === "TypeCastExpression" && !((r = a3.extra) != null && r.parenthesized) && (e.length > 1 || !s2) && this.raise(I2.TypeCastInPattern, { at: a3.typeAnnotation });
      }
      return e;
    }
    parseArrayLike(e, s2, r, i2) {
      let a3 = super.parseArrayLike(e, s2, r, i2);
      return s2 && !this.state.maybeInArrowParameters && this.toReferencedList(a3.elements), a3;
    }
    isValidLVal(e) {
      for (var s2 = arguments.length, r = new Array(s2 > 1 ? s2 - 1 : 0), i2 = 1; i2 < s2; i2++)
        r[i2 - 1] = arguments[i2];
      return e === "TypeCastExpression" || super.isValidLVal(e, ...r);
    }
    parseClassProperty(e) {
      return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e);
    }
    parseClassPrivateProperty(e) {
      return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(e) {
      return !this.match(14) && super.isNonstaticConstructor(e);
    }
    pushClassMethod(e, s2, r, i2, a3, n) {
      if (s2.variance && this.unexpected(s2.variance.loc.start), delete s2.variance, this.match(47) && (s2.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e, s2, r, i2, a3, n), s2.params && a3) {
        let o = s2.params;
        o.length > 0 && this.isThisParam(o[0]) && this.raise(I2.ThisParamBannedInConstructor, { at: s2 });
      } else if (s2.type === "MethodDefinition" && a3 && s2.value.params) {
        let o = s2.value.params;
        o.length > 0 && this.isThisParam(o[0]) && this.raise(I2.ThisParamBannedInConstructor, { at: s2 });
      }
    }
    pushClassPrivateMethod(e, s2, r, i2) {
      s2.variance && this.unexpected(s2.variance.loc.start), delete s2.variance, this.match(47) && (s2.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e, s2, r, i2);
    }
    parseClassSuper(e) {
      if (super.parseClassSuper(e), e.superClass && this.match(47) && (e.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(110)) {
        this.next();
        let s2 = e.implements = [];
        do {
          let r = this.startNode();
          r.id = this.flowParseRestrictedIdentifier(true), this.match(47) ? r.typeParameters = this.flowParseTypeParameterInstantiation() : r.typeParameters = null, s2.push(this.finishNode(r, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(e) {
      super.checkGetterSetterParams(e);
      let s2 = this.getObjectOrClassMethodParams(e);
      if (s2.length > 0) {
        let r = s2[0];
        this.isThisParam(r) && e.kind === "get" ? this.raise(I2.GetterMayNotHaveThisParam, { at: r }) : this.isThisParam(r) && this.raise(I2.SetterMayNotHaveThisParam, { at: r });
      }
    }
    parsePropertyNamePrefixOperator(e) {
      e.variance = this.flowParseVariance();
    }
    parseObjPropValue(e, s2, r, i2, a3, n, o, c) {
      e.variance && this.unexpected(e.variance.loc.start), delete e.variance;
      let f;
      this.match(47) && !o && (f = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected()), super.parseObjPropValue(e, s2, r, i2, a3, n, o, c), f && ((e.value || e).typeParameters = f);
    }
    parseAssignableListItemTypes(e) {
      return this.eat(17) && (e.type !== "Identifier" && this.raise(I2.PatternIsOptional, { at: e }), this.isThisParam(e) && this.raise(I2.ThisParamMayNotBeOptional, { at: e }), e.optional = true), this.match(14) ? e.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(e) && this.raise(I2.ThisParamAnnotationRequired, { at: e }), this.match(29) && this.isThisParam(e) && this.raise(I2.ThisParamNoDefault, { at: e }), this.resetEndLocation(e), e;
    }
    parseMaybeDefault(e, s2, r) {
      let i2 = super.parseMaybeDefault(e, s2, r);
      return i2.type === "AssignmentPattern" && i2.typeAnnotation && i2.right.start < i2.typeAnnotation.start && this.raise(I2.TypeBeforeInitializer, { at: i2.typeAnnotation }), i2;
    }
    shouldParseDefaultImport(e) {
      return us2(e) ? Fr2(this.state.type) : super.shouldParseDefaultImport(e);
    }
    parseImportSpecifierLocal(e, s2, r) {
      s2.local = us2(e) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(s2, r));
    }
    maybeParseDefaultImportSpecifier(e) {
      e.importKind = "value";
      let s2 = null;
      if (this.match(87) ? s2 = "typeof" : this.isContextual(126) && (s2 = "type"), s2) {
        let r = this.lookahead(), { type: i2 } = r;
        s2 === "type" && i2 === 55 && this.unexpected(null, r.type), (Fr2(i2) || i2 === 5 || i2 === 55) && (this.next(), e.importKind = s2);
      }
      return super.maybeParseDefaultImportSpecifier(e);
    }
    parseImportSpecifier(e, s2, r, i2) {
      let a3 = e.imported, n = null;
      a3.type === "Identifier" && (a3.name === "type" ? n = "type" : a3.name === "typeof" && (n = "typeof"));
      let o = false;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        let f = this.parseIdentifier(true);
        n !== null && !ye2(this.state.type) ? (e.imported = f, e.importKind = n, e.local = Ee(f)) : (e.imported = a3, e.importKind = null, e.local = this.parseIdentifier());
      } else {
        if (n !== null && ye2(this.state.type))
          e.imported = this.parseIdentifier(true), e.importKind = n;
        else {
          if (s2)
            throw this.raise(l.ImportBindingIsString, { at: e, importName: a3.value });
          e.imported = a3, e.importKind = null;
        }
        this.eatContextual(93) ? e.local = this.parseIdentifier() : (o = true, e.local = Ee(e.imported));
      }
      let c = us2(e);
      return r && c && this.raise(I2.ImportTypeShorthandOnlyInPureImport, { at: e }), (r || c) && this.checkReservedType(e.local.name, e.local.loc.start, true), o && !r && !c && this.checkReservedWord(e.local.name, e.loc.start, true, true), this.finishImportSpecifier(e, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(true);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(e, s2) {
      let r = e.kind;
      r !== "get" && r !== "set" && this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e, s2);
    }
    parseVarId(e, s2) {
      super.parseVarId(e, s2), this.match(14) && (e.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e.id));
    }
    parseAsyncArrowFromCallExpression(e, s2) {
      if (this.match(14)) {
        let r = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = true, e.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = r;
      }
      return super.parseAsyncArrowFromCallExpression(e, s2);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(e, s2) {
      var r;
      let i2 = null, a3;
      if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
        if (i2 = this.state.clone(), a3 = this.tryParse(() => super.parseMaybeAssign(e, s2), i2), !a3.error)
          return a3.node;
        let { context: c } = this.state, f = c[c.length - 1];
        (f === U.j_oTag || f === U.j_expr) && c.pop();
      }
      if ((r = a3) != null && r.error || this.match(47)) {
        var n, o;
        i2 = i2 || this.state.clone();
        let c, f = this.tryParse((T2) => {
          var v;
          c = this.flowParseTypeParameterDeclaration();
          let N = this.forwardNoArrowParamsConversionAt(c, () => {
            let z = super.parseMaybeAssign(e, s2);
            return this.resetStartLocationFromNode(z, c), z;
          });
          (v = N.extra) != null && v.parenthesized && T2();
          let R = this.maybeUnwrapTypeCastExpression(N);
          return R.type !== "ArrowFunctionExpression" && T2(), R.typeParameters = c, this.resetStartLocationFromNode(R, c), N;
        }, i2), y = null;
        if (f.node && this.maybeUnwrapTypeCastExpression(f.node).type === "ArrowFunctionExpression") {
          if (!f.error && !f.aborted)
            return f.node.async && this.raise(I2.UnexpectedTypeParameterBeforeAsyncArrowFunction, { at: c }), f.node;
          y = f.node;
        }
        if ((n = a3) != null && n.node)
          return this.state = a3.failState, a3.node;
        if (y)
          return this.state = f.failState, y;
        throw (o = a3) != null && o.thrown ? a3.error : f.thrown ? f.error : this.raise(I2.UnexpectedTokenAfterTypeParameter, { at: c });
      }
      return super.parseMaybeAssign(e, s2);
    }
    parseArrow(e) {
      if (this.match(14)) {
        let s2 = this.tryParse(() => {
          let r = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          let i2 = this.startNode();
          return [i2.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = r, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), i2;
        });
        if (s2.thrown)
          return null;
        s2.error && (this.state = s2.failState), e.returnType = s2.node.typeAnnotation ? this.finishNode(s2.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(e);
    }
    shouldParseArrow(e) {
      return this.match(14) || super.shouldParseArrow(e);
    }
    setArrowFunctionParameters(e, s2) {
      this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1 ? e.params = s2 : super.setArrowFunctionParameters(e, s2);
    }
    checkParams(e, s2, r) {
      if (!(r && this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1)) {
        for (let i2 = 0; i2 < e.params.length; i2++)
          this.isThisParam(e.params[i2]) && i2 > 0 && this.raise(I2.ThisParamMustBeFirst, { at: e.params[i2] });
        return super.checkParams(...arguments);
      }
    }
    parseParenAndDistinguishExpression(e) {
      return super.parseParenAndDistinguishExpression(e && this.state.noArrowAt.indexOf(this.state.start) === -1);
    }
    parseSubscripts(e, s2, r, i2) {
      if (e.type === "Identifier" && e.name === "async" && this.state.noArrowAt.indexOf(s2) !== -1) {
        this.next();
        let a3 = this.startNodeAt(s2, r);
        a3.callee = e, a3.arguments = this.parseCallExpressionArguments(11, false), e = this.finishNode(a3, "CallExpression");
      } else if (e.type === "Identifier" && e.name === "async" && this.match(47)) {
        let a3 = this.state.clone(), n = this.tryParse((c) => this.parseAsyncArrowWithTypeParameters(s2, r) || c(), a3);
        if (!n.error && !n.aborted)
          return n.node;
        let o = this.tryParse(() => super.parseSubscripts(e, s2, r, i2), a3);
        if (o.node && !o.error)
          return o.node;
        if (n.node)
          return this.state = n.failState, n.node;
        if (o.node)
          return this.state = o.failState, o.node;
        throw n.error || o.error;
      }
      return super.parseSubscripts(e, s2, r, i2);
    }
    parseSubscript(e, s2, r, i2, a3) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (a3.optionalChainMember = true, i2)
          return a3.stop = true, e;
        this.next();
        let n = this.startNodeAt(s2, r);
        return n.callee = e, n.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), n.arguments = this.parseCallExpressionArguments(11, false), n.optional = true, this.finishCallExpression(n, true);
      } else if (!i2 && this.shouldParseTypes() && this.match(47)) {
        let n = this.startNodeAt(s2, r);
        n.callee = e;
        let o = this.tryParse(() => (n.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), n.arguments = this.parseCallExpressionArguments(11, false), a3.optionalChainMember && (n.optional = false), this.finishCallExpression(n, a3.optionalChainMember)));
        if (o.node)
          return o.error && (this.state = o.failState), o.node;
      }
      return super.parseSubscript(e, s2, r, i2, a3);
    }
    parseNewCallee(e) {
      super.parseNewCallee(e);
      let s2 = null;
      this.shouldParseTypes() && this.match(47) && (s2 = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), e.typeArguments = s2;
    }
    parseAsyncArrowWithTypeParameters(e, s2) {
      let r = this.startNodeAt(e, s2);
      if (this.parseFunctionParams(r), !!this.parseArrow(r))
        return this.parseArrowExpression(r, void 0, true);
    }
    readToken_mult_modulo(e) {
      let s2 = this.input.charCodeAt(this.state.pos + 1);
      if (e === 42 && s2 === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = false, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(e);
    }
    readToken_pipe_amp(e) {
      let s2 = this.input.charCodeAt(this.state.pos + 1);
      if (e === 124 && s2 === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(e);
    }
    parseTopLevel(e, s2) {
      let r = super.parseTopLevel(e, s2);
      return this.state.hasFlowComment && this.raise(I2.UnterminatedFlowComment, { at: this.state.curPosition() }), r;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(I2.NestedFlowComment, { at: this.state.startLoc });
        this.hasFlowCommentCompletion(), this.state.pos += this.skipFlowComment(), this.state.hasFlowComment = true;
        return;
      }
      if (this.state.hasFlowComment) {
        let e = this.input.indexOf("*-/", this.state.pos + 2);
        if (e === -1)
          throw this.raise(l.UnterminatedComment, { at: this.state.curPosition() });
        this.state.pos = e + 2 + 3;
        return;
      }
      return super.skipBlockComment();
    }
    skipFlowComment() {
      let { pos: e } = this.state, s2 = 2;
      for (; [32, 9].includes(this.input.charCodeAt(e + s2)); )
        s2++;
      let r = this.input.charCodeAt(s2 + e), i2 = this.input.charCodeAt(s2 + e + 1);
      return r === 58 && i2 === 58 ? s2 + 2 : this.input.slice(s2 + e, s2 + e + 12) === "flow-include" ? s2 + 12 : r === 58 && i2 !== 58 ? s2 : false;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(l.UnterminatedComment, { at: this.state.curPosition() });
    }
    flowEnumErrorBooleanMemberNotInitialized(e, s2) {
      let { enumName: r, memberName: i2 } = s2;
      this.raise(I2.EnumBooleanMemberNotInitialized, { at: e, memberName: i2, enumName: r });
    }
    flowEnumErrorInvalidMemberInitializer(e, s2) {
      return this.raise(s2.explicitType ? s2.explicitType === "symbol" ? I2.EnumInvalidMemberInitializerSymbolType : I2.EnumInvalidMemberInitializerPrimaryType : I2.EnumInvalidMemberInitializerUnknownType, Object.assign({ at: e }, s2));
    }
    flowEnumErrorNumberMemberNotInitialized(e, s2) {
      let { enumName: r, memberName: i2 } = s2;
      this.raise(I2.EnumNumberMemberNotInitialized, { at: e, enumName: r, memberName: i2 });
    }
    flowEnumErrorStringMemberInconsistentlyInitailized(e, s2) {
      let { enumName: r } = s2;
      this.raise(I2.EnumStringMemberInconsistentlyInitailized, { at: e, enumName: r });
    }
    flowEnumMemberInit() {
      let e = this.state.startLoc, s2 = () => this.match(12) || this.match(8);
      switch (this.state.type) {
        case 130: {
          let r = this.parseNumericLiteral(this.state.value);
          return s2() ? { type: "number", loc: r.loc.start, value: r } : { type: "invalid", loc: e };
        }
        case 129: {
          let r = this.parseStringLiteral(this.state.value);
          return s2() ? { type: "string", loc: r.loc.start, value: r } : { type: "invalid", loc: e };
        }
        case 85:
        case 86: {
          let r = this.parseBooleanLiteral(this.match(85));
          return s2() ? { type: "boolean", loc: r.loc.start, value: r } : { type: "invalid", loc: e };
        }
        default:
          return { type: "invalid", loc: e };
      }
    }
    flowEnumMemberRaw() {
      let e = this.state.startLoc, s2 = this.parseIdentifier(true), r = this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc: e };
      return { id: s2, init: r };
    }
    flowEnumCheckExplicitTypeMismatch(e, s2, r) {
      let { explicitType: i2 } = s2;
      i2 !== null && i2 !== r && this.flowEnumErrorInvalidMemberInitializer(e, s2);
    }
    flowEnumMembers(e) {
      let { enumName: s2, explicitType: r } = e, i2 = /* @__PURE__ */ new Set(), a3 = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] }, n = false;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          n = true;
          break;
        }
        let o = this.startNode(), { id: c, init: f } = this.flowEnumMemberRaw(), y = c.name;
        if (y === "")
          continue;
        /^[a-z]/.test(y) && this.raise(I2.EnumInvalidMemberName, { at: c, memberName: y, suggestion: y[0].toUpperCase() + y.slice(1), enumName: s2 }), i2.has(y) && this.raise(I2.EnumDuplicateMemberName, { at: c, memberName: y, enumName: s2 }), i2.add(y);
        let T2 = { enumName: s2, explicitType: r, memberName: y };
        switch (o.id = c, f.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(f.loc, T2, "boolean"), o.init = f.value, a3.booleanMembers.push(this.finishNode(o, "EnumBooleanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(f.loc, T2, "number"), o.init = f.value, a3.numberMembers.push(this.finishNode(o, "EnumNumberMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(f.loc, T2, "string"), o.init = f.value, a3.stringMembers.push(this.finishNode(o, "EnumStringMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(f.loc, T2);
          case "none":
            switch (r) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(f.loc, T2);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(f.loc, T2);
                break;
              default:
                a3.defaultedMembers.push(this.finishNode(o, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return { members: a3, hasUnknownMembers: n };
    }
    flowEnumStringMembers(e, s2, r) {
      let { enumName: i2 } = r;
      if (e.length === 0)
        return s2;
      if (s2.length === 0)
        return e;
      if (s2.length > e.length) {
        for (let a3 of e)
          this.flowEnumErrorStringMemberInconsistentlyInitailized(a3, { enumName: i2 });
        return s2;
      } else {
        for (let a3 of s2)
          this.flowEnumErrorStringMemberInconsistentlyInitailized(a3, { enumName: i2 });
        return e;
      }
    }
    flowEnumParseExplicitType(e) {
      let { enumName: s2 } = e;
      if (!this.eatContextual(101))
        return null;
      if (!K(this.state.type))
        throw this.raise(I2.EnumInvalidExplicitTypeUnknownSupplied, { at: this.state.startLoc, enumName: s2 });
      let { value: r } = this.state;
      return this.next(), r !== "boolean" && r !== "number" && r !== "string" && r !== "symbol" && this.raise(I2.EnumInvalidExplicitType, { at: this.state.startLoc, enumName: s2, invalidEnumType: r }), r;
    }
    flowEnumBody(e, s2) {
      let r = s2.name, i2 = s2.loc.start, a3 = this.flowEnumParseExplicitType({ enumName: r });
      this.expect(5);
      let { members: n, hasUnknownMembers: o } = this.flowEnumMembers({ enumName: r, explicitType: a3 });
      switch (e.hasUnknownMembers = o, a3) {
        case "boolean":
          return e.explicitType = true, e.members = n.booleanMembers, this.expect(8), this.finishNode(e, "EnumBooleanBody");
        case "number":
          return e.explicitType = true, e.members = n.numberMembers, this.expect(8), this.finishNode(e, "EnumNumberBody");
        case "string":
          return e.explicitType = true, e.members = this.flowEnumStringMembers(n.stringMembers, n.defaultedMembers, { enumName: r }), this.expect(8), this.finishNode(e, "EnumStringBody");
        case "symbol":
          return e.members = n.defaultedMembers, this.expect(8), this.finishNode(e, "EnumSymbolBody");
        default: {
          let c = () => (e.members = [], this.expect(8), this.finishNode(e, "EnumStringBody"));
          e.explicitType = false;
          let f = n.booleanMembers.length, y = n.numberMembers.length, T2 = n.stringMembers.length, v = n.defaultedMembers.length;
          if (!f && !y && !T2 && !v)
            return c();
          if (!f && !y)
            return e.members = this.flowEnumStringMembers(n.stringMembers, n.defaultedMembers, { enumName: r }), this.expect(8), this.finishNode(e, "EnumStringBody");
          if (!y && !T2 && f >= v) {
            for (let N of n.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(N.loc.start, { enumName: r, memberName: N.id.name });
            return e.members = n.booleanMembers, this.expect(8), this.finishNode(e, "EnumBooleanBody");
          } else if (!f && !T2 && y >= v) {
            for (let N of n.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(N.loc.start, { enumName: r, memberName: N.id.name });
            return e.members = n.numberMembers, this.expect(8), this.finishNode(e, "EnumNumberBody");
          } else
            return this.raise(I2.EnumInconsistentMemberValues, { at: i2, enumName: r }), c();
        }
      }
    }
    flowParseEnumDeclaration(e) {
      let s2 = this.parseIdentifier();
      return e.id = s2, e.body = this.flowEnumBody(this.startNode(), s2), this.finishNode(e, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      let e = this.nextTokenStart();
      if (this.input.charCodeAt(e) === 60) {
        let s2 = this.input.charCodeAt(e + 1);
        return s2 !== 60 && s2 !== 61;
      }
      return false;
    }
    maybeUnwrapTypeCastExpression(e) {
      return e.type === "TypeCastExpression" ? e.expression : e;
    }
  }, Ph = { __proto__: null, quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "\xA0", iexcl: "\xA1", cent: "\xA2", pound: "\xA3", curren: "\xA4", yen: "\xA5", brvbar: "\xA6", sect: "\xA7", uml: "\xA8", copy: "\xA9", ordf: "\xAA", laquo: "\xAB", not: "\xAC", shy: "\xAD", reg: "\xAE", macr: "\xAF", deg: "\xB0", plusmn: "\xB1", sup2: "\xB2", sup3: "\xB3", acute: "\xB4", micro: "\xB5", para: "\xB6", middot: "\xB7", cedil: "\xB8", sup1: "\xB9", ordm: "\xBA", raquo: "\xBB", frac14: "\xBC", frac12: "\xBD", frac34: "\xBE", iquest: "\xBF", Agrave: "\xC0", Aacute: "\xC1", Acirc: "\xC2", Atilde: "\xC3", Auml: "\xC4", Aring: "\xC5", AElig: "\xC6", Ccedil: "\xC7", Egrave: "\xC8", Eacute: "\xC9", Ecirc: "\xCA", Euml: "\xCB", Igrave: "\xCC", Iacute: "\xCD", Icirc: "\xCE", Iuml: "\xCF", ETH: "\xD0", Ntilde: "\xD1", Ograve: "\xD2", Oacute: "\xD3", Ocirc: "\xD4", Otilde: "\xD5", Ouml: "\xD6", times: "\xD7", Oslash: "\xD8", Ugrave: "\xD9", Uacute: "\xDA", Ucirc: "\xDB", Uuml: "\xDC", Yacute: "\xDD", THORN: "\xDE", szlig: "\xDF", agrave: "\xE0", aacute: "\xE1", acirc: "\xE2", atilde: "\xE3", auml: "\xE4", aring: "\xE5", aelig: "\xE6", ccedil: "\xE7", egrave: "\xE8", eacute: "\xE9", ecirc: "\xEA", euml: "\xEB", igrave: "\xEC", iacute: "\xED", icirc: "\xEE", iuml: "\xEF", eth: "\xF0", ntilde: "\xF1", ograve: "\xF2", oacute: "\xF3", ocirc: "\xF4", otilde: "\xF5", ouml: "\xF6", divide: "\xF7", oslash: "\xF8", ugrave: "\xF9", uacute: "\xFA", ucirc: "\xFB", uuml: "\xFC", yacute: "\xFD", thorn: "\xFE", yuml: "\xFF", OElig: "\u0152", oelig: "\u0153", Scaron: "\u0160", scaron: "\u0161", Yuml: "\u0178", fnof: "\u0192", circ: "\u02C6", tilde: "\u02DC", Alpha: "\u0391", Beta: "\u0392", Gamma: "\u0393", Delta: "\u0394", Epsilon: "\u0395", Zeta: "\u0396", Eta: "\u0397", Theta: "\u0398", Iota: "\u0399", Kappa: "\u039A", Lambda: "\u039B", Mu: "\u039C", Nu: "\u039D", Xi: "\u039E", Omicron: "\u039F", Pi: "\u03A0", Rho: "\u03A1", Sigma: "\u03A3", Tau: "\u03A4", Upsilon: "\u03A5", Phi: "\u03A6", Chi: "\u03A7", Psi: "\u03A8", Omega: "\u03A9", alpha: "\u03B1", beta: "\u03B2", gamma: "\u03B3", delta: "\u03B4", epsilon: "\u03B5", zeta: "\u03B6", eta: "\u03B7", theta: "\u03B8", iota: "\u03B9", kappa: "\u03BA", lambda: "\u03BB", mu: "\u03BC", nu: "\u03BD", xi: "\u03BE", omicron: "\u03BF", pi: "\u03C0", rho: "\u03C1", sigmaf: "\u03C2", sigma: "\u03C3", tau: "\u03C4", upsilon: "\u03C5", phi: "\u03C6", chi: "\u03C7", psi: "\u03C8", omega: "\u03C9", thetasym: "\u03D1", upsih: "\u03D2", piv: "\u03D6", ensp: "\u2002", emsp: "\u2003", thinsp: "\u2009", zwnj: "\u200C", zwj: "\u200D", lrm: "\u200E", rlm: "\u200F", ndash: "\u2013", mdash: "\u2014", lsquo: "\u2018", rsquo: "\u2019", sbquo: "\u201A", ldquo: "\u201C", rdquo: "\u201D", bdquo: "\u201E", dagger: "\u2020", Dagger: "\u2021", bull: "\u2022", hellip: "\u2026", permil: "\u2030", prime: "\u2032", Prime: "\u2033", lsaquo: "\u2039", rsaquo: "\u203A", oline: "\u203E", frasl: "\u2044", euro: "\u20AC", image: "\u2111", weierp: "\u2118", real: "\u211C", trade: "\u2122", alefsym: "\u2135", larr: "\u2190", uarr: "\u2191", rarr: "\u2192", darr: "\u2193", harr: "\u2194", crarr: "\u21B5", lArr: "\u21D0", uArr: "\u21D1", rArr: "\u21D2", dArr: "\u21D3", hArr: "\u21D4", forall: "\u2200", part: "\u2202", exist: "\u2203", empty: "\u2205", nabla: "\u2207", isin: "\u2208", notin: "\u2209", ni: "\u220B", prod: "\u220F", sum: "\u2211", minus: "\u2212", lowast: "\u2217", radic: "\u221A", prop: "\u221D", infin: "\u221E", ang: "\u2220", and: "\u2227", or: "\u2228", cap: "\u2229", cup: "\u222A", int: "\u222B", there4: "\u2234", sim: "\u223C", cong: "\u2245", asymp: "\u2248", ne: "\u2260", equiv: "\u2261", le: "\u2264", ge: "\u2265", sub: "\u2282", sup: "\u2283", nsub: "\u2284", sube: "\u2286", supe: "\u2287", oplus: "\u2295", otimes: "\u2297", perp: "\u22A5", sdot: "\u22C5", lceil: "\u2308", rceil: "\u2309", lfloor: "\u230A", rfloor: "\u230B", lang: "\u2329", rang: "\u232A", loz: "\u25CA", spades: "\u2660", clubs: "\u2663", hearts: "\u2665", diams: "\u2666" }, Be = j(qn || (qn = ht$1(["jsx"])))((t) => ({ AttributeIsEmpty: t("JSX attributes must only be assigned a non-empty expression."), MissingClosingTagElement: t((e) => {
    let { openingTagName: s2 } = e;
    return "Expected corresponding JSX closing tag for <".concat(s2, ">.");
  }), MissingClosingTagFragment: t("Expected corresponding JSX closing tag for <>."), UnexpectedSequenceExpression: t("Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?"), UnexpectedToken: t((e) => {
    let { unexpected: s2, HTMLEntity: r } = e;
    return "Unexpected token `".concat(s2, "`. Did you mean `").concat(r, "` or `{'").concat(s2, "'}`?");
  }), UnsupportedJsxValue: t("JSX value should be either an expression or a quoted JSX text."), UnterminatedJsxContent: t("Unterminated JSX contents."), UnwrappedAdjacentJSXElements: t("Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?") }));
  function Ne2(t) {
    return t ? t.type === "JSXOpeningFragment" || t.type === "JSXClosingFragment" : false;
  }
  function Ge2(t) {
    if (t.type === "JSXIdentifier")
      return t.name;
    if (t.type === "JSXNamespacedName")
      return t.namespace.name + ":" + t.name.name;
    if (t.type === "JSXMemberExpression")
      return Ge2(t.object) + "." + Ge2(t.property);
    throw new Error("Node had unexpected type: " + t.type);
  }
  var Th = (t) => class extends t {
    jsxReadToken() {
      let e = "", s2 = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(Be.UnterminatedJsxContent, { at: this.state.startLoc });
        let r = this.input.charCodeAt(this.state.pos);
        switch (r) {
          case 60:
          case 123:
            return this.state.pos === this.state.start ? r === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(138)) : super.getTokenFromCode(r) : (e += this.input.slice(s2, this.state.pos), this.finishToken(137, e));
          case 38:
            e += this.input.slice(s2, this.state.pos), e += this.jsxReadEntity(), s2 = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            Oe2(r) ? (e += this.input.slice(s2, this.state.pos), e += this.jsxReadNewLine(true), s2 = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(e) {
      let s2 = this.input.charCodeAt(this.state.pos), r;
      return ++this.state.pos, s2 === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, r = e ? `
` : `\r
`) : r = String.fromCharCode(s2), ++this.state.curLine, this.state.lineStart = this.state.pos, r;
    }
    jsxReadString(e) {
      let s2 = "", r = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(l.UnterminatedString, { at: this.state.startLoc });
        let i2 = this.input.charCodeAt(this.state.pos);
        if (i2 === e)
          break;
        i2 === 38 ? (s2 += this.input.slice(r, this.state.pos), s2 += this.jsxReadEntity(), r = this.state.pos) : Oe2(i2) ? (s2 += this.input.slice(r, this.state.pos), s2 += this.jsxReadNewLine(false), r = this.state.pos) : ++this.state.pos;
      }
      return s2 += this.input.slice(r, this.state.pos++), this.finishToken(129, s2);
    }
    jsxReadEntity() {
      let e = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let s2 = 10;
        this.codePointAtPos(this.state.pos) === 120 && (s2 = 16, ++this.state.pos);
        let r = this.readInt(s2, void 0, false, "bail");
        if (r !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(r);
      } else {
        let s2 = 0, r = false;
        for (; s2++ < 10 && this.state.pos < this.length && !(r = this.codePointAtPos(this.state.pos) == 59); )
          ++this.state.pos;
        if (r) {
          let i2 = this.input.slice(e, this.state.pos), a3 = Ph[i2];
          if (++this.state.pos, a3)
            return a3;
        }
      }
      return this.state.pos = e, "&";
    }
    jsxReadWord() {
      let e, s2 = this.state.pos;
      do
        e = this.input.charCodeAt(++this.state.pos);
      while (ze(e) || e === 45);
      return this.finishToken(136, this.input.slice(s2, this.state.pos));
    }
    jsxParseIdentifier() {
      let e = this.startNode();
      return this.match(136) ? e.name = this.state.value : Vt(this.state.type) ? e.name = ve2(this.state.type) : this.unexpected(), this.next(), this.finishNode(e, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      let e = this.state.start, s2 = this.state.startLoc, r = this.jsxParseIdentifier();
      if (!this.eat(14))
        return r;
      let i2 = this.startNodeAt(e, s2);
      return i2.namespace = r, i2.name = this.jsxParseIdentifier(), this.finishNode(i2, "JSXNamespacedName");
    }
    jsxParseElementName() {
      let e = this.state.start, s2 = this.state.startLoc, r = this.jsxParseNamespacedName();
      if (r.type === "JSXNamespacedName")
        return r;
      for (; this.eat(16); ) {
        let i2 = this.startNodeAt(e, s2);
        i2.object = r, i2.property = this.jsxParseIdentifier(), r = this.finishNode(i2, "JSXMemberExpression");
      }
      return r;
    }
    jsxParseAttributeValue() {
      let e;
      switch (this.state.type) {
        case 5:
          return e = this.startNode(), this.setContext(U.brace), this.next(), e = this.jsxParseExpressionContainer(e, U.j_oTag), e.expression.type === "JSXEmptyExpression" && this.raise(Be.AttributeIsEmpty, { at: e }), e;
        case 138:
        case 129:
          return this.parseExprAtom();
        default:
          throw this.raise(Be.UnsupportedJsxValue, { at: this.state.startLoc });
      }
    }
    jsxParseEmptyExpression() {
      let e = this.startNodeAt(this.state.lastTokEndLoc.index, this.state.lastTokEndLoc);
      return this.finishNodeAt(e, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(e) {
      return this.next(), e.expression = this.parseExpression(), this.setContext(U.j_oTag), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(e, s2) {
      if (this.match(8))
        e.expression = this.jsxParseEmptyExpression();
      else {
        let r = this.parseExpression();
        e.expression = r;
      }
      return this.setContext(s2), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      let e = this.startNode();
      return this.match(5) ? (this.setContext(U.brace), this.next(), this.expect(21), e.argument = this.parseMaybeAssignAllowIn(), this.setContext(U.j_oTag), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXSpreadAttribute")) : (e.name = this.jsxParseNamespacedName(), e.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(e, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(e, s2) {
      let r = this.startNodeAt(e, s2);
      return this.eat(139) ? this.finishNode(r, "JSXOpeningFragment") : (r.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(r));
    }
    jsxParseOpeningElementAfterName(e) {
      let s2 = [];
      for (; !this.match(56) && !this.match(139); )
        s2.push(this.jsxParseAttribute());
      return e.attributes = s2, e.selfClosing = this.eat(56), this.expect(139), this.finishNode(e, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(e, s2) {
      let r = this.startNodeAt(e, s2);
      return this.eat(139) ? this.finishNode(r, "JSXClosingFragment") : (r.name = this.jsxParseElementName(), this.expect(139), this.finishNode(r, "JSXClosingElement"));
    }
    jsxParseElementAt(e, s2) {
      let r = this.startNodeAt(e, s2), i2 = [], a3 = this.jsxParseOpeningElementAt(e, s2), n = null;
      if (!a3.selfClosing) {
        e:
          for (; ; )
            switch (this.state.type) {
              case 138:
                if (e = this.state.start, s2 = this.state.startLoc, this.next(), this.eat(56)) {
                  n = this.jsxParseClosingElementAt(e, s2);
                  break e;
                }
                i2.push(this.jsxParseElementAt(e, s2));
                break;
              case 137:
                i2.push(this.parseExprAtom());
                break;
              case 5: {
                let o = this.startNode();
                this.setContext(U.brace), this.next(), this.match(21) ? i2.push(this.jsxParseSpreadChild(o)) : i2.push(this.jsxParseExpressionContainer(o, U.j_expr));
                break;
              }
              default:
                throw this.unexpected();
            }
        Ne2(a3) && !Ne2(n) && n !== null ? this.raise(Be.MissingClosingTagFragment, { at: n }) : !Ne2(a3) && Ne2(n) ? this.raise(Be.MissingClosingTagElement, { at: n, openingTagName: Ge2(a3.name) }) : !Ne2(a3) && !Ne2(n) && Ge2(n.name) !== Ge2(a3.name) && this.raise(Be.MissingClosingTagElement, { at: n, openingTagName: Ge2(a3.name) });
      }
      if (Ne2(a3) ? (r.openingFragment = a3, r.closingFragment = n) : (r.openingElement = a3, r.closingElement = n), r.children = i2, this.match(47))
        throw this.raise(Be.UnwrappedAdjacentJSXElements, { at: this.state.startLoc });
      return Ne2(a3) ? this.finishNode(r, "JSXFragment") : this.finishNode(r, "JSXElement");
    }
    jsxParseElement() {
      let e = this.state.start, s2 = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(e, s2);
    }
    setContext(e) {
      let { context: s2 } = this.state;
      s2[s2.length - 1] = e;
    }
    parseExprAtom(e) {
      return this.match(137) ? this.parseLiteral(this.state.value, "JSXText") : this.match(138) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(138), this.jsxParseElement()) : super.parseExprAtom(e);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(e) {
      let s2 = this.curContext();
      if (s2 === U.j_expr)
        return this.jsxReadToken();
      if (s2 === U.j_oTag || s2 === U.j_cTag) {
        if (ge2(e))
          return this.jsxReadWord();
        if (e === 62)
          return ++this.state.pos, this.finishToken(139);
        if ((e === 34 || e === 39) && s2 === U.j_oTag)
          return this.jsxReadString(e);
      }
      return e === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33 ? (++this.state.pos, this.finishToken(138)) : super.getTokenFromCode(e);
    }
    updateContext(e) {
      let { context: s2, type: r } = this.state;
      if (r === 56 && e === 138)
        s2.splice(-2, 2, U.j_cTag), this.state.canStartJSXElement = false;
      else if (r === 138)
        s2.push(U.j_oTag);
      else if (r === 139) {
        let i2 = s2[s2.length - 1];
        i2 === U.j_oTag && e === 56 || i2 === U.j_cTag ? (s2.pop(), this.state.canStartJSXElement = s2[s2.length - 1] === U.j_expr) : (this.setContext(U.j_expr), this.state.canStartJSXElement = true);
      } else
        this.state.canStartJSXElement = fo2(r);
    }
  }, Eh = class extends ns2 {
    constructor() {
      super(...arguments), this.types = /* @__PURE__ */ new Set(), this.enums = /* @__PURE__ */ new Set(), this.constEnums = /* @__PURE__ */ new Set(), this.classes = /* @__PURE__ */ new Set(), this.exportOnlyBindings = /* @__PURE__ */ new Set();
    }
  }, bh = class extends os2 {
    createScope(t) {
      return new Eh(t);
    }
    declareName(t, e, s2) {
      let r = this.currentScope();
      if (e & Qt2) {
        this.maybeExportDefined(r, t), r.exportOnlyBindings.add(t);
        return;
      }
      super.declareName(...arguments), e & Ve2 && (e & Pe2 || (this.checkRedeclarationInScope(r, t, e, s2), this.maybeExportDefined(r, t)), r.types.add(t)), e & Yt2 && r.enums.add(t), e & $t && r.constEnums.add(t), e & mt2 && r.classes.add(t);
    }
    isRedeclaredInScope(t, e, s2) {
      if (t.enums.has(e)) {
        if (s2 & Yt2) {
          let r = !!(s2 & $t), i2 = t.constEnums.has(e);
          return r !== i2;
        }
        return true;
      }
      return s2 & mt2 && t.classes.has(e) ? t.lexical.has(e) ? !!(s2 & Pe2) : false : s2 & Ve2 && t.types.has(e) ? true : super.isRedeclaredInScope(...arguments);
    }
    checkLocalExport(t) {
      let e = this.scopeStack[0], { name: s2 } = t;
      !e.types.has(s2) && !e.exportOnlyBindings.has(s2) && super.checkLocalExport(t);
    }
  }, Ch = (t, e) => Object.hasOwnProperty.call(t, e) && t[e];
  function vh(t) {
    if (t == null)
      throw new Error("Unexpected ".concat(t, " value."));
    return t;
  }
  function Lr2(t) {
    if (!t)
      throw new Error("Assert fail");
  }
  function Sh(t) {
    return Kt2(t) || Eo2(t);
  }
  var S2 = j(Un || (Un = ht$1(["typescript"])))((t) => ({ AbstractMethodHasImplementation: t((e) => {
    let { methodName: s2 } = e;
    return "Method '".concat(s2, "' cannot have an implementation because it is marked abstract.");
  }), AbstractPropertyHasInitializer: t((e) => {
    let { propertyName: s2 } = e;
    return "Property '".concat(s2, "' cannot have an initializer because it is marked abstract.");
  }), AccesorCannotDeclareThisParameter: t("'get' and 'set' accessors cannot declare 'this' parameters."), AccesorCannotHaveTypeParameters: t("An accessor cannot have type parameters."), CannotFindName: t((e) => {
    let { name: s2 } = e;
    return "Cannot find name '".concat(s2, "'.");
  }), ClassMethodHasDeclare: t("Class methods cannot have the 'declare' modifier."), ClassMethodHasReadonly: t("Class methods cannot have the 'readonly' modifier."), ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: t("A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference."), ConstructorHasTypeParameters: t("Type parameters cannot appear on a constructor declaration."), DeclareAccessor: t((e) => {
    let { kind: s2 } = e;
    return "'declare' is not allowed in ".concat(s2, "ters.");
  }), DeclareClassFieldHasInitializer: t("Initializers are not allowed in ambient contexts."), DeclareFunctionHasImplementation: t("An implementation cannot be declared in ambient contexts."), DuplicateAccessibilityModifier: t((e) => {
    return "Accessibility modifier already seen.";
  }), DuplicateModifier: t((e) => {
    let { modifier: s2 } = e;
    return "Duplicate modifier: '".concat(s2, "'.");
  }), EmptyHeritageClauseType: t((e) => {
    let { token: s2 } = e;
    return "'".concat(s2, "' list cannot be empty.");
  }), EmptyTypeArguments: t("Type argument list cannot be empty."), EmptyTypeParameters: t("Type parameter list cannot be empty."), ExpectedAmbientAfterExportDeclare: t("'export declare' must be followed by an ambient declaration."), ImportAliasHasImportType: t("An import alias can not use 'import type'."), IncompatibleModifiers: t((e) => {
    let { modifiers: s2 } = e;
    return "'".concat(s2[0], "' modifier cannot be used with '").concat(s2[1], "' modifier.");
  }), IndexSignatureHasAbstract: t("Index signatures cannot have the 'abstract' modifier."), IndexSignatureHasAccessibility: t((e) => {
    let { modifier: s2 } = e;
    return "Index signatures cannot have an accessibility modifier ('".concat(s2, "').");
  }), IndexSignatureHasDeclare: t("Index signatures cannot have the 'declare' modifier."), IndexSignatureHasOverride: t("'override' modifier cannot appear on an index signature."), IndexSignatureHasStatic: t("Index signatures cannot have the 'static' modifier."), InitializerNotAllowedInAmbientContext: t("Initializers are not allowed in ambient contexts."), InvalidModifierOnTypeMember: t((e) => {
    let { modifier: s2 } = e;
    return "'".concat(s2, "' modifier cannot appear on a type member.");
  }), InvalidModifierOnTypeParameter: t((e) => {
    let { modifier: s2 } = e;
    return "'".concat(s2, "' modifier cannot appear on a type parameter.");
  }), InvalidModifierOnTypeParameterPositions: t((e) => {
    let { modifier: s2 } = e;
    return "'".concat(s2, "' modifier can only appear on a type parameter of a class, interface or type alias.");
  }), InvalidModifiersOrder: t((e) => {
    let { orderedModifiers: s2 } = e;
    return "'".concat(s2[0], "' modifier must precede '").concat(s2[1], "' modifier.");
  }), InvalidTupleMemberLabel: t("Tuple members must be labeled with a simple identifier."), MissingInterfaceName: t("'interface' declarations must be followed by an identifier."), MixedLabeledAndUnlabeledElements: t("Tuple members must all have names or all not have names."), NonAbstractClassHasAbstractMethod: t("Abstract methods can only appear within an abstract class."), NonClassMethodPropertyHasAbstractModifer: t("'abstract' modifier can only appear on a class, method, or property declaration."), OptionalTypeBeforeRequired: t("A required element cannot follow an optional element."), OverrideNotInSubClass: t("This member cannot have an 'override' modifier because its containing class does not extend another class."), PatternIsOptional: t("A binding pattern parameter cannot be optional in an implementation signature."), PrivateElementHasAbstract: t("Private elements cannot have the 'abstract' modifier."), PrivateElementHasAccessibility: t((e) => {
    let { modifier: s2 } = e;
    return "Private elements cannot have an accessibility modifier ('".concat(s2, "').");
  }), ReadonlyForMethodSignature: t("'readonly' modifier can only appear on a property declaration or index signature."), ReservedArrowTypeParam: t("This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`."), ReservedTypeAssertion: t("This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead."), SetAccesorCannotHaveOptionalParameter: t("A 'set' accessor cannot have an optional parameter."), SetAccesorCannotHaveRestParameter: t("A 'set' accessor cannot have rest parameter."), SetAccesorCannotHaveReturnType: t("A 'set' accessor cannot have a return type annotation."), SingleTypeParameterWithoutTrailingComma: t((e) => {
    let { typeParameterName: s2 } = e;
    return "Single type parameter ".concat(s2, " should have a trailing comma. Example usage: <").concat(s2, ",>.");
  }), StaticBlockCannotHaveModifier: t("Static class blocks cannot have any modifier."), TypeAnnotationAfterAssign: t("Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`."), TypeImportCannotSpecifyDefaultAndNamed: t("A type-only import can specify a default import or named bindings, but not both."), TypeModifierIsUsedInTypeExports: t("The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement."), TypeModifierIsUsedInTypeImports: t("The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement."), UnexpectedParameterModifier: t("A parameter property is only allowed in a constructor implementation."), UnexpectedReadonly: t("'readonly' type modifier is only permitted on array and tuple literal types."), UnexpectedTypeAnnotation: t("Did not expect a type annotation here."), UnexpectedTypeCastInParameter: t("Unexpected type cast in parameter position."), UnsupportedImportTypeArgument: t("Argument in a type import must be a string literal."), UnsupportedParameterPropertyKind: t("A parameter property may not be declared using a binding pattern."), UnsupportedSignatureParameterKind: t((e) => {
    let { type: s2 } = e;
    return "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ".concat(s2, ".");
  }) }));
  function wh(t) {
    switch (t) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  function Or2(t) {
    return t === "private" || t === "public" || t === "protected";
  }
  function Nh(t) {
    return t === "in" || t === "out";
  }
  var Ih = (t) => class extends t {
    getScopeHandler() {
      return bh;
    }
    tsIsIdentifier() {
      return K(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(134) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      return this.next(), this.tsTokenCanFollowModifier();
    }
    tsParseModifier(e, s2) {
      if (!K(this.state.type) && this.state.type !== 58)
        return;
      let r = this.state.value;
      if (e.indexOf(r) !== -1) {
        if (s2 && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return r;
      }
    }
    tsParseModifiers(e) {
      let { modified: s2, allowedModifiers: r, disallowedModifiers: i2, stopOnStartOfClassStaticBlock: a3, errorTemplate: n = S2.InvalidModifierOnTypeMember } = e, o = (f, y, T2, v) => {
        y === T2 && s2[v] && this.raise(S2.InvalidModifiersOrder, { at: f, orderedModifiers: [T2, v] });
      }, c = (f, y, T2, v) => {
        (s2[T2] && y === v || s2[v] && y === T2) && this.raise(S2.IncompatibleModifiers, { at: f, modifiers: [T2, v] });
      };
      for (; ; ) {
        let { startLoc: f } = this.state, y = this.tsParseModifier(r.concat(i2 != null ? i2 : []), a3);
        if (!y)
          break;
        Or2(y) ? s2.accessibility ? this.raise(S2.DuplicateAccessibilityModifier, { at: f, modifier: y }) : (o(f, y, y, "override"), o(f, y, y, "static"), o(f, y, y, "readonly"), s2.accessibility = y) : Nh(y) ? (s2[y] && this.raise(S2.DuplicateModifier, { at: f, modifier: y }), s2[y] = true, o(f, y, "in", "out")) : (Object.hasOwnProperty.call(s2, y) ? this.raise(S2.DuplicateModifier, { at: f, modifier: y }) : (o(f, y, "static", "readonly"), o(f, y, "static", "override"), o(f, y, "override", "readonly"), o(f, y, "abstract", "override"), c(f, y, "declare", "override"), c(f, y, "static", "abstract")), s2[y] = true), i2 != null && i2.includes(y) && this.raise(n, { at: f, modifier: y });
      }
    }
    tsIsListTerminator(e) {
      switch (e) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
      throw new Error("Unreachable");
    }
    tsParseList(e, s2) {
      let r = [];
      for (; !this.tsIsListTerminator(e); )
        r.push(s2());
      return r;
    }
    tsParseDelimitedList(e, s2, r) {
      return vh(this.tsParseDelimitedListWorker(e, s2, true, r));
    }
    tsParseDelimitedListWorker(e, s2, r, i2) {
      let a3 = [], n = -1;
      for (; !this.tsIsListTerminator(e); ) {
        n = -1;
        let o = s2();
        if (o == null)
          return;
        if (a3.push(o), this.eat(12)) {
          n = this.state.lastTokStart;
          continue;
        }
        if (this.tsIsListTerminator(e))
          break;
        r && this.expect(12);
        return;
      }
      return i2 && (i2.value = n), a3;
    }
    tsParseBracketedList(e, s2, r, i2, a3) {
      i2 || (r ? this.expect(0) : this.expect(47));
      let n = this.tsParseDelimitedList(e, s2, a3);
      return r ? this.expect(3) : this.expect(48), n;
    }
    tsParseImportType() {
      let e = this.startNode();
      return this.expect(83), this.expect(10), this.match(129) || this.raise(S2.UnsupportedImportTypeArgument, { at: this.state.startLoc }), e.argument = this.parseExprAtom(), this.expect(11), this.eat(16) && (e.qualifier = this.tsParseEntityName()), this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSImportType");
    }
    tsParseEntityName() {
      let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true, s2 = this.parseIdentifier(e);
      for (; this.eat(16); ) {
        let r = this.startNodeAtNode(s2);
        r.left = s2, r.right = this.parseIdentifier(e), s2 = this.finishNode(r, "TSQualifiedName");
      }
      return s2;
    }
    tsParseTypeReference() {
      let e = this.startNode();
      return e.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeReference");
    }
    tsParseThisTypePredicate(e) {
      this.next();
      let s2 = this.startNodeAtNode(e);
      return s2.parameterName = e, s2.typeAnnotation = this.tsParseTypeAnnotation(false), s2.asserts = false, this.finishNode(s2, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      let e = this.startNode();
      return this.next(), this.finishNode(e, "TSThisType");
    }
    tsParseTypeQuery() {
      let e = this.startNode();
      return this.expect(87), this.match(83) ? e.exprName = this.tsParseImportType() : e.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeQuery");
    }
    tsParseInOutModifiers(e) {
      this.tsParseModifiers({ modified: e, allowedModifiers: ["in", "out"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: S2.InvalidModifierOnTypeParameter });
    }
    tsParseNoneModifiers(e) {
      this.tsParseModifiers({ modified: e, allowedModifiers: [], disallowedModifiers: ["in", "out"], errorTemplate: S2.InvalidModifierOnTypeParameterPositions });
    }
    tsParseTypeParameter() {
      let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.tsParseNoneModifiers.bind(this), s2 = this.startNode();
      return e(s2), s2.name = this.tsParseTypeParameterName(), s2.constraint = this.tsEatThenParseType(81), s2.default = this.tsEatThenParseType(29), this.finishNode(s2, "TSTypeParameter");
    }
    tsTryParseTypeParameters(e) {
      if (this.match(47))
        return this.tsParseTypeParameters(e);
    }
    tsParseTypeParameters(e) {
      let s2 = this.startNode();
      this.match(47) || this.match(138) ? this.next() : this.unexpected();
      let r = { value: -1 };
      return s2.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, e), false, true, r), s2.params.length === 0 && this.raise(S2.EmptyTypeParameters, { at: s2 }), r.value !== -1 && this.addExtra(s2, "trailingComma", r.value), this.finishNode(s2, "TSTypeParameterDeclaration");
    }
    tsTryNextParseConstantContext() {
      if (this.lookahead().type !== 75)
        return null;
      this.next();
      let e = this.tsParseTypeReference();
      return e.typeParameters && this.raise(S2.CannotFindName, { at: e.typeName, name: "const" }), e;
    }
    tsFillSignature(e, s2) {
      let r = e === 19, i2 = "parameters", a3 = "typeAnnotation";
      s2.typeParameters = this.tsTryParseTypeParameters(), this.expect(10), s2[i2] = this.tsParseBindingListForSignature(), r ? s2[a3] = this.tsParseTypeOrTypePredicateAnnotation(e) : this.match(e) && (s2[a3] = this.tsParseTypeOrTypePredicateAnnotation(e));
    }
    tsParseBindingListForSignature() {
      return this.parseBindingList(11, 41).map((e) => (e.type !== "Identifier" && e.type !== "RestElement" && e.type !== "ObjectPattern" && e.type !== "ArrayPattern" && this.raise(S2.UnsupportedSignatureParameterKind, { at: e, type: e.type }), e));
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(e, s2) {
      return this.tsFillSignature(14, s2), this.tsParseTypeMemberSemicolon(), this.finishNode(s2, e);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), K(this.state.type) ? (this.next(), this.match(14)) : false;
    }
    tsTryParseIndexSignature(e) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      let s2 = this.parseIdentifier();
      s2.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(s2), this.expect(3), e.parameters = [s2];
      let r = this.tsTryParseTypeAnnotation();
      return r && (e.typeAnnotation = r), this.tsParseTypeMemberSemicolon(), this.finishNode(e, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(e, s2) {
      this.eat(17) && (e.optional = true);
      let r = e;
      if (this.match(10) || this.match(47)) {
        s2 && this.raise(S2.ReadonlyForMethodSignature, { at: e });
        let i2 = r;
        i2.kind && this.match(47) && this.raise(S2.AccesorCannotHaveTypeParameters, { at: this.state.curPosition() }), this.tsFillSignature(14, i2), this.tsParseTypeMemberSemicolon();
        let a3 = "parameters", n = "typeAnnotation";
        if (i2.kind === "get")
          i2[a3].length > 0 && (this.raise(l.BadGetterArity, { at: this.state.curPosition() }), this.isThisParam(i2[a3][0]) && this.raise(S2.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }));
        else if (i2.kind === "set") {
          if (i2[a3].length !== 1)
            this.raise(l.BadSetterArity, { at: this.state.curPosition() });
          else {
            let o = i2[a3][0];
            this.isThisParam(o) && this.raise(S2.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }), o.type === "Identifier" && o.optional && this.raise(S2.SetAccesorCannotHaveOptionalParameter, { at: this.state.curPosition() }), o.type === "RestElement" && this.raise(S2.SetAccesorCannotHaveRestParameter, { at: this.state.curPosition() });
          }
          i2[n] && this.raise(S2.SetAccesorCannotHaveReturnType, { at: i2[n] });
        } else
          i2.kind = "method";
        return this.finishNode(i2, "TSMethodSignature");
      } else {
        let i2 = r;
        s2 && (i2.readonly = true);
        let a3 = this.tsTryParseTypeAnnotation();
        return a3 && (i2.typeAnnotation = a3), this.tsParseTypeMemberSemicolon(), this.finishNode(i2, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      let e = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", e);
      if (this.match(77)) {
        let r = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e) : (e.key = this.createIdentifier(r, "new"), this.tsParsePropertyOrMethodSignature(e, false));
      }
      this.tsParseModifiers({ modified: e, allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] });
      let s2 = this.tsTryParseIndexSignature(e);
      return s2 || (this.parsePropertyName(e), !e.computed && e.key.type === "Identifier" && (e.key.name === "get" || e.key.name === "set") && this.tsTokenCanFollowModifier() && (e.kind = e.key.name, this.parsePropertyName(e)), this.tsParsePropertyOrMethodSignature(e, !!e.readonly));
    }
    tsParseTypeLiteral() {
      let e = this.startNode();
      return e.members = this.tsParseObjectTypeMembers(), this.finishNode(e, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      let e = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), e;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(118) : (this.isContextual(118) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? false : (this.next(), this.match(58)));
    }
    tsParseMappedTypeParameter() {
      let e = this.startNode();
      return e.name = this.tsParseTypeParameterName(), e.constraint = this.tsExpectThenParseType(58), this.finishNode(e, "TSTypeParameter");
    }
    tsParseMappedType() {
      let e = this.startNode();
      return this.expect(5), this.match(53) ? (e.readonly = this.state.value, this.next(), this.expectContextual(118)) : this.eatContextual(118) && (e.readonly = true), this.expect(0), e.typeParameter = this.tsParseMappedTypeParameter(), e.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (e.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (e.optional = true), e.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(e, "TSMappedType");
    }
    tsParseTupleType() {
      let e = this.startNode();
      e.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
      let s2 = false, r = null;
      return e.elementTypes.forEach((i2) => {
        var a3;
        let { type: n } = i2;
        s2 && n !== "TSRestType" && n !== "TSOptionalType" && !(n === "TSNamedTupleMember" && i2.optional) && this.raise(S2.OptionalTypeBeforeRequired, { at: i2 }), s2 = s2 || n === "TSNamedTupleMember" && i2.optional || n === "TSOptionalType", n === "TSRestType" && (i2 = i2.typeAnnotation, n = i2.type);
        let o = n === "TSNamedTupleMember";
        r = (a3 = r) != null ? a3 : o, r !== o && this.raise(S2.MixedLabeledAndUnlabeledElements, { at: i2 });
      }), this.finishNode(e, "TSTupleType");
    }
    tsParseTupleElementType() {
      let { start: e, startLoc: s2 } = this.state, r = this.eat(21), i2 = this.tsParseType(), a3 = this.eat(17);
      if (this.eat(14)) {
        let o = this.startNodeAtNode(i2);
        o.optional = a3, i2.type === "TSTypeReference" && !i2.typeParameters && i2.typeName.type === "Identifier" ? o.label = i2.typeName : (this.raise(S2.InvalidTupleMemberLabel, { at: i2 }), o.label = i2), o.elementType = this.tsParseType(), i2 = this.finishNode(o, "TSNamedTupleMember");
      } else if (a3) {
        let o = this.startNodeAtNode(i2);
        o.typeAnnotation = i2, i2 = this.finishNode(o, "TSOptionalType");
      }
      if (r) {
        let o = this.startNodeAt(e, s2);
        o.typeAnnotation = i2, i2 = this.finishNode(o, "TSRestType");
      }
      return i2;
    }
    tsParseParenthesizedType() {
      let e = this.startNode();
      return this.expect(10), e.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(e, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(e, s2) {
      let r = this.startNode();
      return e === "TSConstructorType" && (r.abstract = !!s2, s2 && this.next(), this.next()), this.tsFillSignature(19, r), this.finishNode(r, e);
    }
    tsParseLiteralTypeNode() {
      let e = this.startNode();
      return e.literal = (() => {
        switch (this.state.type) {
          case 130:
          case 131:
          case 129:
          case 85:
          case 86:
            return this.parseExprAtom();
          default:
            throw this.unexpected();
        }
      })(), this.finishNode(e, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      let e = this.startNode();
      return e.literal = this.parseTemplate(false), this.finishNode(e, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      let e = this.tsParseThisTypeNode();
      return this.isContextual(113) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e) : e;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 129:
        case 130:
        case 131:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            let e = this.startNode(), s2 = this.lookahead();
            if (s2.type !== 130 && s2.type !== 131)
              throw this.unexpected();
            return e.literal = this.parseMaybeUnary(), this.finishNode(e, "TSLiteralType");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          let { type: e } = this.state;
          if (K(e) || e === 88 || e === 84) {
            let s2 = e === 88 ? "TSVoidKeyword" : e === 84 ? "TSNullKeyword" : wh(this.state.value);
            if (s2 !== void 0 && this.lookaheadCharCode() !== 46) {
              let r = this.startNode();
              return this.next(), this.finishNode(r, s2);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      throw this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let e = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          let s2 = this.startNodeAtNode(e);
          s2.elementType = e, this.expect(3), e = this.finishNode(s2, "TSArrayType");
        } else {
          let s2 = this.startNodeAtNode(e);
          s2.objectType = e, s2.indexType = this.tsParseType(), this.expect(3), e = this.finishNode(s2, "TSIndexedAccessType");
        }
      return e;
    }
    tsParseTypeOperator() {
      let e = this.startNode(), s2 = this.state.value;
      return this.next(), e.operator = s2, e.typeAnnotation = this.tsParseTypeOperatorOrHigher(), s2 === "readonly" && this.tsCheckTypeAnnotationForReadOnly(e), this.finishNode(e, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(e) {
      switch (e.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(S2.UnexpectedReadonly, { at: e });
      }
    }
    tsParseInferType() {
      let e = this.startNode();
      this.expectContextual(112);
      let s2 = this.startNode();
      return s2.name = this.tsParseTypeParameterName(), s2.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), e.typeParameter = this.finishNode(s2, "TSTypeParameter"), this.finishNode(e, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        let e = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return e;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return Po2(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(112) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(e, s2, r) {
      let i2 = this.startNode(), a3 = this.eat(r), n = [];
      do
        n.push(s2());
      while (this.eat(r));
      return n.length === 1 && !a3 ? n[0] : (i2.types = n, this.finishNode(i2, e));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? true : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (K(this.state.type) || this.match(78))
        return this.next(), true;
      if (this.match(5)) {
        let { errors: e } = this.state, s2 = e.length;
        try {
          return this.parseObjectLike(8, true), e.length === s2;
        } catch {
          return false;
        }
      }
      if (this.match(0)) {
        this.next();
        let { errors: e } = this.state, s2 = e.length;
        try {
          return this.parseBindingList(3, 93, true), e.length === s2;
        } catch {
          return false;
        }
      }
      return false;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(e) {
      return this.tsInType(() => {
        let s2 = this.startNode();
        this.expect(e);
        let r = this.startNode(), i2 = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (i2 && this.match(78)) {
          let o = this.tsParseThisTypeOrThisTypePredicate();
          return o.type === "TSThisType" ? (r.parameterName = o, r.asserts = true, r.typeAnnotation = null, o = this.finishNode(r, "TSTypePredicate")) : (this.resetStartLocationFromNode(o, r), o.asserts = true), s2.typeAnnotation = o, this.finishNode(s2, "TSTypeAnnotation");
        }
        let a3 = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!a3)
          return i2 ? (r.parameterName = this.parseIdentifier(), r.asserts = i2, r.typeAnnotation = null, s2.typeAnnotation = this.finishNode(r, "TSTypePredicate"), this.finishNode(s2, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, s2);
        let n = this.tsParseTypeAnnotation(false);
        return r.parameterName = a3, r.typeAnnotation = n, r.asserts = i2, s2.typeAnnotation = this.finishNode(r, "TSTypePredicate"), this.finishNode(s2, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : void 0;
    }
    tsTryParseTypeAnnotation() {
      return this.match(14) ? this.tsParseTypeAnnotation() : void 0;
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      let e = this.parseIdentifier();
      if (this.isContextual(113) && !this.hasPrecedingLineBreak())
        return this.next(), e;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 106)
        return false;
      let e = this.state.containsEsc;
      return this.next(), !K(this.state.type) && !this.match(78) ? false : (e && this.raise(l.InvalidEscapedReservedWord, { at: this.state.lastTokStartLoc, reservedWord: "asserts" }), true);
    }
    tsParseTypeAnnotation() {
      let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true, s2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.startNode();
      return this.tsInType(() => {
        e && this.expect(14), s2.typeAnnotation = this.tsParseType();
      }), this.finishNode(s2, "TSTypeAnnotation");
    }
    tsParseType() {
      Lr2(this.state.inType);
      let e = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return e;
      let s2 = this.startNodeAtNode(e);
      return s2.checkType = e, s2.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), s2.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), s2.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(s2, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(120) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(S2.ReservedTypeAssertion, { at: this.state.startLoc });
      let e = this.startNode(), s2 = this.tsTryNextParseConstantContext();
      return e.typeAnnotation = s2 || this.tsNextThenParseType(), this.expect(48), e.expression = this.parseMaybeUnary(), this.finishNode(e, "TSTypeAssertion");
    }
    tsParseHeritageClause(e) {
      let s2 = this.state.startLoc, r = this.tsParseDelimitedList("HeritageClauseElement", () => {
        let i2 = this.startNode();
        return i2.expression = this.tsParseEntityName(), this.match(47) && (i2.typeParameters = this.tsParseTypeArguments()), this.finishNode(i2, "TSExpressionWithTypeArguments");
      });
      return r.length || this.raise(S2.EmptyHeritageClauseType, { at: s2, token: e }), r;
    }
    tsParseInterfaceDeclaration(e) {
      let s2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.hasFollowingLineBreak())
        return null;
      this.expectContextual(125), s2.declare && (e.declare = true), K(this.state.type) ? (e.id = this.parseIdentifier(), this.checkIdentifier(e.id, Oo2)) : (e.id = null, this.raise(S2.MissingInterfaceName, { at: this.state.startLoc })), e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this)), this.eat(81) && (e.extends = this.tsParseHeritageClause("extends"));
      let r = this.startNode();
      return r.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e.body = this.finishNode(r, "TSInterfaceBody"), this.finishNode(e, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(e) {
      return e.id = this.parseIdentifier(), this.checkIdentifier(e.id, Bo2), e.typeAnnotation = this.tsInType(() => {
        if (e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this)), this.expect(29), this.isContextual(111) && this.lookahead().type !== 16) {
          let s2 = this.startNode();
          return this.next(), this.finishNode(s2, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(e, "TSTypeAliasDeclaration");
    }
    tsInNoContext(e) {
      let s2 = this.state.context;
      this.state.context = [s2[0]];
      try {
        return e();
      } finally {
        this.state.context = s2;
      }
    }
    tsInType(e) {
      let s2 = this.state.inType;
      this.state.inType = true;
      try {
        return e();
      } finally {
        this.state.inType = s2;
      }
    }
    tsInDisallowConditionalTypesContext(e) {
      let s2 = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = true;
      try {
        return e();
      } finally {
        this.state.inDisallowConditionalTypesContext = s2;
      }
    }
    tsInAllowConditionalTypesContext(e) {
      let s2 = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = false;
      try {
        return e();
      } finally {
        this.state.inDisallowConditionalTypesContext = s2;
      }
    }
    tsEatThenParseType(e) {
      return this.match(e) ? this.tsNextThenParseType() : void 0;
    }
    tsExpectThenParseType(e) {
      return this.tsDoThenParseType(() => this.expect(e));
    }
    tsNextThenParseType() {
      return this.tsDoThenParseType(() => this.next());
    }
    tsDoThenParseType(e) {
      return this.tsInType(() => (e(), this.tsParseType()));
    }
    tsParseEnumMember() {
      let e = this.startNode();
      return e.id = this.match(129) ? this.parseExprAtom() : this.parseIdentifier(true), this.eat(29) && (e.initializer = this.parseMaybeAssignAllowIn()), this.finishNode(e, "TSEnumMember");
    }
    tsParseEnumDeclaration(e) {
      let s2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return s2.const && (e.const = true), s2.declare && (e.declare = true), this.expectContextual(122), e.id = this.parseIdentifier(), this.checkIdentifier(e.id, e.const ? Ro2 : Pr2), this.expect(5), e.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(e, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      let e = this.startNode();
      return this.scope.enter(Ke2), this.expect(5), this.parseBlockOrModuleBlockBody(e.body = [], void 0, true, 8), this.scope.exit(), this.finishNode(e, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(e) {
      let s2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (e.id = this.parseIdentifier(), s2 || this.checkIdentifier(e.id, jo2), this.eat(16)) {
        let r = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(r, true), e.body = r;
      } else
        this.scope.enter(pt2), this.prodParam.enter(He2), e.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(e, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(e) {
      return this.isContextual(109) ? (e.global = true, e.id = this.parseIdentifier()) : this.match(129) ? e.id = this.parseExprAtom() : this.unexpected(), this.match(5) ? (this.scope.enter(pt2), this.prodParam.enter(He2), e.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(e, s2) {
      e.isExport = s2 || false, e.id = this.parseIdentifier(), this.checkIdentifier(e.id, Te2), this.expect(29);
      let r = this.tsParseModuleReference();
      return e.importKind === "type" && r.type !== "TSExternalModuleReference" && this.raise(S2.ImportAliasHasImportType, { at: r }), e.moduleReference = r, this.semicolon(), this.finishNode(e, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(116) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
    }
    tsParseExternalModuleReference() {
      let e = this.startNode();
      if (this.expectContextual(116), this.expect(10), !this.match(129))
        throw this.unexpected();
      return e.expression = this.parseExprAtom(), this.expect(11), this.finishNode(e, "TSExternalModuleReference");
    }
    tsLookAhead(e) {
      let s2 = this.state.clone(), r = e();
      return this.state = s2, r;
    }
    tsTryParseAndCatch(e) {
      let s2 = this.tryParse((r) => e() || r());
      if (!(s2.aborted || !s2.node))
        return s2.error && (this.state = s2.failState), s2.node;
    }
    tsTryParse(e) {
      let s2 = this.state.clone(), r = e();
      if (r !== void 0 && r !== false)
        return r;
      this.state = s2;
    }
    tsTryParseDeclare(e) {
      if (this.isLineTerminator())
        return;
      let s2 = this.state.type, r;
      return this.isContextual(99) && (s2 = 74, r = "let"), this.tsInAmbientContext(() => {
        if (s2 === 68)
          return e.declare = true, this.parseFunctionStatement(e, false, true);
        if (s2 === 80)
          return e.declare = true, this.parseClass(e, true, false);
        if (s2 === 122)
          return this.tsParseEnumDeclaration(e, { declare: true });
        if (s2 === 109)
          return this.tsParseAmbientExternalModuleDeclaration(e);
        if (s2 === 75 || s2 === 74)
          return !this.match(75) || !this.isLookaheadContextual("enum") ? (e.declare = true, this.parseVarStatement(e, r || this.state.value, true)) : (this.expect(75), this.tsParseEnumDeclaration(e, { const: true, declare: true }));
        if (s2 === 125) {
          let i2 = this.tsParseInterfaceDeclaration(e, { declare: true });
          if (i2)
            return i2;
        }
        if (K(s2))
          return this.tsParseDeclaration(e, this.state.value, true);
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, true);
    }
    tsParseExpressionStatement(e, s2) {
      switch (s2.name) {
        case "declare": {
          let r = this.tsTryParseDeclare(e);
          if (r)
            return r.declare = true, r;
          break;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(pt2), this.prodParam.enter(He2);
            let r = e;
            return r.global = true, r.id = s2, r.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(r, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(e, s2.name, false);
      }
    }
    tsParseDeclaration(e, s2, r) {
      switch (s2) {
        case "abstract":
          if (this.tsCheckLineTerminator(r) && (this.match(80) || K(this.state.type)))
            return this.tsParseAbstractDeclaration(e);
          break;
        case "module":
          if (this.tsCheckLineTerminator(r)) {
            if (this.match(129))
              return this.tsParseAmbientExternalModuleDeclaration(e);
            if (K(this.state.type))
              return this.tsParseModuleOrNamespaceDeclaration(e);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(r) && K(this.state.type))
            return this.tsParseModuleOrNamespaceDeclaration(e);
          break;
        case "type":
          if (this.tsCheckLineTerminator(r) && K(this.state.type))
            return this.tsParseTypeAliasDeclaration(e);
          break;
      }
    }
    tsCheckLineTerminator(e) {
      return e ? this.hasFollowingLineBreak() ? false : (this.next(), true) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(e, s2) {
      if (!this.match(47))
        return;
      let r = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = true;
      let i2 = this.tsTryParseAndCatch(() => {
        let a3 = this.startNodeAt(e, s2);
        return a3.typeParameters = this.tsParseTypeParameters(), super.parseFunctionParams(a3), a3.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), a3;
      });
      if (this.state.maybeInArrowParameters = r, !!i2)
        return this.parseArrowExpression(i2, null, true);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      let e = this.startNode();
      return e.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), e.params.length === 0 && this.raise(S2.EmptyTypeArguments, { at: e }), this.expect(48), this.finishNode(e, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return To2(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? false : super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(e, s2) {
      let r = this.state.start, i2 = this.state.startLoc, a3, n = false, o = false;
      if (e !== void 0) {
        let y = {};
        this.tsParseModifiers({ modified: y, allowedModifiers: ["public", "private", "protected", "override", "readonly"] }), a3 = y.accessibility, o = y.override, n = y.readonly, e === false && (a3 || n || o) && this.raise(S2.UnexpectedParameterModifier, { at: i2 });
      }
      let c = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(c);
      let f = this.parseMaybeDefault(c.start, c.loc.start, c);
      if (a3 || n || o) {
        let y = this.startNodeAt(r, i2);
        return s2.length && (y.decorators = s2), a3 && (y.accessibility = a3), n && (y.readonly = n), o && (y.override = o), f.type !== "Identifier" && f.type !== "AssignmentPattern" && this.raise(S2.UnsupportedParameterPropertyKind, { at: y }), y.parameter = f, this.finishNode(y, "TSParameterProperty");
      }
      return s2.length && (c.decorators = s2), f;
    }
    isSimpleParameter(e) {
      return e.type === "TSParameterProperty" && super.isSimpleParameter(e.parameter) || super.isSimpleParameter(e);
    }
    parseFunctionBodyAndFinish(e, s2) {
      let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      this.match(14) && (e.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      let i2 = s2 === "FunctionDeclaration" ? "TSDeclareFunction" : s2 === "ClassMethod" || s2 === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      if (i2 && !this.match(5) && this.isLineTerminator()) {
        this.finishNode(e, i2);
        return;
      }
      if (i2 === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(S2.DeclareFunctionHasImplementation, { at: e }), e.declare)) {
        super.parseFunctionBodyAndFinish(e, i2, r);
        return;
      }
      super.parseFunctionBodyAndFinish(e, s2, r);
    }
    registerFunctionStatementId(e) {
      !e.body && e.id ? this.checkIdentifier(e.id, Tr2) : super.registerFunctionStatementId(...arguments);
    }
    tsCheckForInvalidTypeCasts(e) {
      e.forEach((s2) => {
        (s2 == null ? void 0 : s2.type) === "TSTypeCastExpression" && this.raise(S2.UnexpectedTypeAnnotation, { at: s2.typeAnnotation });
      });
    }
    toReferencedList(e, s2) {
      return this.tsCheckForInvalidTypeCasts(e), e;
    }
    parseArrayLike() {
      let e = super.parseArrayLike(...arguments);
      return e.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(e.elements), e;
    }
    parseSubscript(e, s2, r, i2, a3) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = false, this.next();
        let o = this.startNodeAt(s2, r);
        return o.expression = e, this.finishNode(o, "TSNonNullExpression");
      }
      let n = false;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (i2)
          return a3.stop = true, e;
        a3.optionalChainMember = n = true, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let o, c = this.tsTryParseAndCatch(() => {
          if (!i2 && this.atPossibleAsyncArrow(e)) {
            let T2 = this.tsTryParseGenericAsyncArrowFunction(s2, r);
            if (T2)
              return T2;
          }
          let f = this.tsParseTypeArgumentsInExpression();
          if (!f)
            throw this.unexpected();
          if (n && !this.match(10))
            throw o = this.state.curPosition(), this.unexpected();
          if (ut2(this.state.type)) {
            let T2 = this.parseTaggedTemplateExpression(e, s2, r, a3);
            return T2.typeParameters = f, T2;
          }
          if (!i2 && this.eat(10)) {
            let T2 = this.startNodeAt(s2, r);
            return T2.callee = e, T2.arguments = this.parseCallExpressionArguments(11, false), this.tsCheckForInvalidTypeCasts(T2.arguments), T2.typeParameters = f, a3.optionalChainMember && (T2.optional = n), this.finishCallExpression(T2, a3.optionalChainMember);
          }
          if (Sh(this.state.type) && this.state.type !== 10)
            throw this.unexpected();
          let y = this.startNodeAt(s2, r);
          return y.expression = e, y.typeParameters = f, this.finishNode(y, "TSInstantiationExpression");
        });
        if (o && this.unexpected(o, 10), c)
          return c;
      }
      return super.parseSubscript(e, s2, r, i2, a3);
    }
    parseNewCallee(e) {
      var s2;
      super.parseNewCallee(e);
      let { callee: r } = e;
      r.type === "TSInstantiationExpression" && !((s2 = r.extra) != null && s2.parenthesized) && (e.typeParameters = r.typeParameters, e.callee = r.expression);
    }
    parseExprOp(e, s2, r, i2) {
      if (lt2(58) > i2 && !this.hasPrecedingLineBreak() && this.isContextual(93)) {
        let a3 = this.startNodeAt(s2, r);
        a3.expression = e;
        let n = this.tsTryNextParseConstantContext();
        return n ? a3.typeAnnotation = n : a3.typeAnnotation = this.tsNextThenParseType(), this.finishNode(a3, "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(a3, s2, r, i2);
      }
      return super.parseExprOp(e, s2, r, i2);
    }
    checkReservedWord(e, s2, r, i2) {
      this.state.isAmbientContext || super.checkReservedWord(e, s2, r, i2);
    }
    checkDuplicateExports() {
    }
    parseImport(e) {
      if (e.importKind = "value", K(this.state.type) || this.match(55) || this.match(5)) {
        let r = this.lookahead();
        if (this.isContextual(126) && r.type !== 12 && r.type !== 97 && r.type !== 29 && (e.importKind = "type", this.next(), r = this.lookahead()), K(this.state.type) && r.type === 29)
          return this.tsParseImportEqualsDeclaration(e);
      }
      let s2 = super.parseImport(e);
      return s2.importKind === "type" && s2.specifiers.length > 1 && s2.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(S2.TypeImportCannotSpecifyDefaultAndNamed, { at: s2 }), s2;
    }
    parseExport(e) {
      if (this.match(83))
        return this.next(), this.isContextual(126) && this.lookaheadCharCode() !== 61 ? (e.importKind = "type", this.next()) : e.importKind = "value", this.tsParseImportEqualsDeclaration(e, true);
      if (this.eat(29)) {
        let s2 = e;
        return s2.expression = this.parseExpression(), this.semicolon(), this.finishNode(s2, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        let s2 = e;
        return this.expectContextual(124), s2.id = this.parseIdentifier(), this.semicolon(), this.finishNode(s2, "TSNamespaceExportDeclaration");
      } else
        return this.isContextual(126) && this.lookahead().type === 5 ? (this.next(), e.exportKind = "type") : e.exportKind = "value", super.parseExport(e);
    }
    isAbstractClass() {
      return this.isContextual(120) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        let e = this.startNode();
        return this.next(), e.abstract = true, this.parseClass(e, true, true), e;
      }
      if (this.match(125)) {
        let e = this.tsParseInterfaceDeclaration(this.startNode());
        if (e)
          return e;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(e, s2) {
      let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, { isAmbientContext: i2 } = this.state, a3 = super.parseVarStatement(e, s2, r || i2);
      if (!i2)
        return a3;
      for (let { id: n, init: o } of a3.declarations)
        !o || (s2 !== "const" || !!n.typeAnnotation ? this.raise(S2.InitializerNotAllowedInAmbientContext, { at: o }) : o.type !== "StringLiteral" && o.type !== "BooleanLiteral" && o.type !== "NumericLiteral" && o.type !== "BigIntLiteral" && (o.type !== "TemplateLiteral" || o.expressions.length > 0) && !kh(o) && this.raise(S2.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, { at: o }));
      return a3;
    }
    parseStatementContent(e, s2) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        let r = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(r, { const: true });
      }
      if (this.isContextual(122))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(125)) {
        let r = this.tsParseInterfaceDeclaration(this.startNode());
        if (r)
          return r;
      }
      return super.parseStatementContent(e, s2);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(e, s2) {
      return s2.some((r) => Or2(r) ? e.accessibility === r : !!e[r]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(104) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(e, s2, r) {
      let i2 = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({ modified: s2, allowedModifiers: i2, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: true, errorTemplate: S2.InvalidModifierOnTypeParameterPositions });
      let a3 = () => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(s2, i2) && this.raise(S2.StaticBlockCannotHaveModifier, { at: this.state.curPosition() }), this.parseClassStaticBlock(e, s2)) : this.parseClassMemberWithIsStatic(e, s2, r, !!s2.static);
      };
      s2.declare ? this.tsInAmbientContext(a3) : a3();
    }
    parseClassMemberWithIsStatic(e, s2, r, i2) {
      let a3 = this.tsTryParseIndexSignature(s2);
      if (a3) {
        e.body.push(a3), s2.abstract && this.raise(S2.IndexSignatureHasAbstract, { at: s2 }), s2.accessibility && this.raise(S2.IndexSignatureHasAccessibility, { at: s2, modifier: s2.accessibility }), s2.declare && this.raise(S2.IndexSignatureHasDeclare, { at: s2 }), s2.override && this.raise(S2.IndexSignatureHasOverride, { at: s2 });
        return;
      }
      !this.state.inAbstractClass && s2.abstract && this.raise(S2.NonAbstractClassHasAbstractMethod, { at: s2 }), s2.override && (r.hadSuperClass || this.raise(S2.OverrideNotInSubClass, { at: s2 })), super.parseClassMemberWithIsStatic(e, s2, r, i2);
    }
    parsePostMemberNameModifiers(e) {
      this.eat(17) && (e.optional = true), e.readonly && this.match(10) && this.raise(S2.ClassMethodHasReadonly, { at: e }), e.declare && this.match(10) && this.raise(S2.ClassMethodHasDeclare, { at: e });
    }
    parseExpressionStatement(e, s2) {
      return (s2.type === "Identifier" ? this.tsParseExpressionStatement(e, s2) : void 0) || super.parseExpressionStatement(e, s2);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? true : super.shouldParseExportDeclaration();
    }
    parseConditional(e, s2, r, i2) {
      if (!this.state.maybeInArrowParameters || !this.match(17))
        return super.parseConditional(e, s2, r, i2);
      let a3 = this.tryParse(() => super.parseConditional(e, s2, r));
      return a3.node ? (a3.error && (this.state = a3.failState), a3.node) : (a3.error && super.setOptionalParametersError(i2, a3.error), e);
    }
    parseParenItem(e, s2, r) {
      if (e = super.parseParenItem(e, s2, r), this.eat(17) && (e.optional = true, this.resetEndLocation(e)), this.match(14)) {
        let i2 = this.startNodeAt(s2, r);
        return i2.expression = e, i2.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(i2, "TSTypeCastExpression");
      }
      return e;
    }
    parseExportDeclaration(e) {
      if (!this.state.isAmbientContext && this.isContextual(121))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(e));
      let s2 = this.state.start, r = this.state.startLoc, i2 = this.eatContextual(121);
      if (i2 && (this.isContextual(121) || !this.shouldParseExportDeclaration()))
        throw this.raise(S2.ExpectedAmbientAfterExportDeclare, { at: this.state.startLoc });
      let n = K(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(e);
      return n ? ((n.type === "TSInterfaceDeclaration" || n.type === "TSTypeAliasDeclaration" || i2) && (e.exportKind = "type"), i2 && (this.resetStartLocation(n, s2, r), n.declare = true), n) : null;
    }
    parseClassId(e, s2, r) {
      if ((!s2 || r) && this.isContextual(110))
        return;
      super.parseClassId(e, s2, r, e.declare ? Tr2 : gr2);
      let i2 = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
      i2 && (e.typeParameters = i2);
    }
    parseClassPropertyAnnotation(e) {
      !e.optional && this.eat(35) && (e.definite = true);
      let s2 = this.tsTryParseTypeAnnotation();
      s2 && (e.typeAnnotation = s2);
    }
    parseClassProperty(e) {
      if (this.parseClassPropertyAnnotation(e), this.state.isAmbientContext && this.match(29) && this.raise(S2.DeclareClassFieldHasInitializer, { at: this.state.startLoc }), e.abstract && this.match(29)) {
        let { key: s2 } = e;
        this.raise(S2.AbstractPropertyHasInitializer, { at: this.state.startLoc, propertyName: s2.type === "Identifier" && !e.computed ? s2.name : "[".concat(this.input.slice(s2.start, s2.end), "]") });
      }
      return super.parseClassProperty(e);
    }
    parseClassPrivateProperty(e) {
      return e.abstract && this.raise(S2.PrivateElementHasAbstract, { at: e }), e.accessibility && this.raise(S2.PrivateElementHasAccessibility, { at: e, modifier: e.accessibility }), this.parseClassPropertyAnnotation(e), super.parseClassPrivateProperty(e);
    }
    pushClassMethod(e, s2, r, i2, a3, n) {
      let o = this.tsTryParseTypeParameters();
      o && a3 && this.raise(S2.ConstructorHasTypeParameters, { at: o });
      let { declare: c = false, kind: f } = s2;
      c && (f === "get" || f === "set") && this.raise(S2.DeclareAccessor, { at: s2, kind: f }), o && (s2.typeParameters = o), super.pushClassMethod(e, s2, r, i2, a3, n);
    }
    pushClassPrivateMethod(e, s2, r, i2) {
      let a3 = this.tsTryParseTypeParameters();
      a3 && (s2.typeParameters = a3), super.pushClassPrivateMethod(e, s2, r, i2);
    }
    declareClassPrivateMethodInScope(e, s2) {
      e.type !== "TSDeclareMethod" && (e.type === "MethodDefinition" && !e.value.body || super.declareClassPrivateMethodInScope(e, s2));
    }
    parseClassSuper(e) {
      super.parseClassSuper(e), e.superClass && (this.match(47) || this.match(51)) && (e.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(110) && (e.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(e) {
      let s2 = this.tsTryParseTypeParameters();
      s2 && (e.typeParameters = s2);
      for (var r = arguments.length, i2 = new Array(r > 1 ? r - 1 : 0), a3 = 1; a3 < r; a3++)
        i2[a3 - 1] = arguments[a3];
      super.parseObjPropValue(e, ...i2);
    }
    parseFunctionParams(e, s2) {
      let r = this.tsTryParseTypeParameters();
      r && (e.typeParameters = r), super.parseFunctionParams(e, s2);
    }
    parseVarId(e, s2) {
      super.parseVarId(e, s2), e.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (e.definite = true);
      let r = this.tsTryParseTypeAnnotation();
      r && (e.id.typeAnnotation = r, this.resetEndLocation(e.id));
    }
    parseAsyncArrowFromCallExpression(e, s2) {
      return this.match(14) && (e.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e, s2);
    }
    parseMaybeAssign() {
      for (var e = arguments.length, s2 = new Array(e), r = 0; r < e; r++)
        s2[r] = arguments[r];
      var i2, a3, n, o, c, f, y;
      let T2, v, N;
      if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
        if (T2 = this.state.clone(), v = this.tryParse(() => super.parseMaybeAssign(...s2), T2), !v.error)
          return v.node;
        let { context: te2 } = this.state, he2 = te2[te2.length - 1];
        (he2 === U.j_oTag || he2 === U.j_expr) && te2.pop();
      }
      if (!((i2 = v) != null && i2.error) && !this.match(47))
        return super.parseMaybeAssign(...s2);
      let R;
      T2 = T2 || this.state.clone();
      let z = this.tryParse((te2) => {
        var he2, pe, st2;
        R = this.tsParseTypeParameters();
        let de2 = super.parseMaybeAssign(...s2);
        return (de2.type !== "ArrowFunctionExpression" || (he2 = de2.extra) != null && he2.parenthesized) && te2(), ((pe = R) == null ? void 0 : pe.params.length) !== 0 && this.resetStartLocationFromNode(de2, R), de2.typeParameters = R, this.hasPlugin("jsx") && de2.typeParameters.params.length === 1 && !((st2 = de2.typeParameters.extra) != null && st2.trailingComma) && de2.typeParameters.params[0].constraint, de2;
      }, T2);
      if (!z.error && !z.aborted)
        return R && this.reportReservedArrowTypeParam(R), z.node;
      if (!v && (Lr2(!this.hasPlugin("jsx")), N = this.tryParse(() => super.parseMaybeAssign(...s2), T2), !N.error))
        return N.node;
      if ((a3 = v) != null && a3.node)
        return this.state = v.failState, v.node;
      if (z.node)
        return this.state = z.failState, R && this.reportReservedArrowTypeParam(R), z.node;
      if ((n = N) != null && n.node)
        return this.state = N.failState, N.node;
      throw (o = v) != null && o.thrown ? v.error : z.thrown ? z.error : (c = N) != null && c.thrown ? N.error : ((f = v) == null ? void 0 : f.error) || z.error || ((y = N) == null ? void 0 : y.error);
    }
    reportReservedArrowTypeParam(e) {
      var s2;
      e.params.length === 1 && !((s2 = e.extra) != null && s2.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(S2.ReservedArrowTypeParam, { at: e });
    }
    parseMaybeUnary(e) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e);
    }
    parseArrow(e) {
      if (this.match(14)) {
        let s2 = this.tryParse((r) => {
          let i2 = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && r(), i2;
        });
        if (s2.aborted)
          return;
        s2.thrown || (s2.error && (this.state = s2.failState), e.returnType = s2.node);
      }
      return super.parseArrow(e);
    }
    parseAssignableListItemTypes(e) {
      this.eat(17) && (e.type !== "Identifier" && !this.state.isAmbientContext && !this.state.inType && this.raise(S2.PatternIsOptional, { at: e }), e.optional = true);
      let s2 = this.tsTryParseTypeAnnotation();
      return s2 && (e.typeAnnotation = s2), this.resetEndLocation(e), e;
    }
    isAssignable(e, s2) {
      switch (e.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(e.expression, s2);
        case "TSParameterProperty":
          return true;
        default:
          return super.isAssignable(e, s2);
      }
    }
    toAssignable(e) {
      let s2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      switch (e.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(e, s2);
          break;
        case "TSAsExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          s2 ? this.expressionScope.recordArrowParemeterBindingError(S2.UnexpectedTypeCastInParameter, { at: e }) : this.raise(S2.UnexpectedTypeCastInParameter, { at: e }), this.toAssignable(e.expression, s2);
          break;
        case "AssignmentExpression":
          !s2 && e.left.type === "TSTypeCastExpression" && (e.left = this.typeCastToParameter(e.left));
        default:
          super.toAssignable(e, s2);
      }
    }
    toAssignableParenthesizedExpression(e, s2) {
      switch (e.expression.type) {
        case "TSAsExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(e.expression, s2);
          break;
        default:
          super.toAssignable(e, s2);
      }
    }
    checkToRestConversion(e, s2) {
      switch (e.type) {
        case "TSAsExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(e.expression, false);
          break;
        default:
          super.checkToRestConversion(e, s2);
      }
    }
    isValidLVal(e, s2, r) {
      return Ch({ TSTypeCastExpression: true, TSParameterProperty: "parameter", TSNonNullExpression: "expression", TSAsExpression: (r !== Le2 || !s2) && ["expression", true], TSTypeAssertion: (r !== Le2 || !s2) && ["expression", true] }, e) || super.isValidLVal(e, s2, r);
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(true);
        default:
          return super.parseBindingAtom();
      }
    }
    parseMaybeDecoratorArguments(e) {
      if (this.match(47) || this.match(51)) {
        let s2 = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          let r = super.parseMaybeDecoratorArguments(e);
          return r.typeParameters = s2, r;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(e);
    }
    checkCommaAfterRest(e) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e ? (this.next(), false) : super.checkCommaAfterRest(e);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault() {
      let e = super.parseMaybeDefault(...arguments);
      return e.type === "AssignmentPattern" && e.typeAnnotation && e.right.start < e.typeAnnotation.start && this.raise(S2.TypeAnnotationAfterAssign, { at: e.typeAnnotation }), e;
    }
    getTokenFromCode(e) {
      if (this.state.inType) {
        if (e === 62)
          return this.finishOp(48, 1);
        if (e === 60)
          return this.finishOp(47, 1);
      }
      return super.getTokenFromCode(e);
    }
    reScan_lt_gt() {
      let { type: e } = this.state;
      e === 47 ? (this.state.pos -= 1, this.readToken_lt()) : e === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let { type: e } = this.state;
      return e === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : e;
    }
    toAssignableList(e) {
      for (let s2 = 0; s2 < e.length; s2++) {
        let r = e[s2];
        (r == null ? void 0 : r.type) === "TSTypeCastExpression" && (e[s2] = this.typeCastToParameter(r));
      }
      super.toAssignableList(...arguments);
    }
    typeCastToParameter(e) {
      return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
    }
    shouldParseArrow(e) {
      return this.match(14) ? e.every((s2) => this.isAssignable(s2, true)) : super.shouldParseArrow(e);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(e) {
      if (this.match(47) || this.match(51)) {
        let s2 = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        s2 && (e.typeParameters = s2);
      }
      return super.jsxParseOpeningElementAfterName(e);
    }
    getGetterSetterExpectedParamCount(e) {
      let s2 = super.getGetterSetterExpectedParamCount(e), i2 = this.getObjectOrClassMethodParams(e)[0];
      return i2 && this.isThisParam(i2) ? s2 + 1 : s2;
    }
    parseCatchClauseParam() {
      let e = super.parseCatchClauseParam(), s2 = this.tsTryParseTypeAnnotation();
      return s2 && (e.typeAnnotation = s2, this.resetEndLocation(e)), e;
    }
    tsInAmbientContext(e) {
      let s2 = this.state.isAmbientContext;
      this.state.isAmbientContext = true;
      try {
        return e();
      } finally {
        this.state.isAmbientContext = s2;
      }
    }
    parseClass(e) {
      let s2 = this.state.inAbstractClass;
      this.state.inAbstractClass = !!e.abstract;
      try {
        for (var r = arguments.length, i2 = new Array(r > 1 ? r - 1 : 0), a3 = 1; a3 < r; a3++)
          i2[a3 - 1] = arguments[a3];
        return super.parseClass(e, ...i2);
      } finally {
        this.state.inAbstractClass = s2;
      }
    }
    tsParseAbstractDeclaration(e) {
      if (this.match(80))
        return e.abstract = true, this.parseClass(e, true, false);
      if (this.isContextual(125)) {
        if (!this.hasFollowingLineBreak())
          return e.abstract = true, this.raise(S2.NonClassMethodPropertyHasAbstractModifer, { at: e }), this.tsParseInterfaceDeclaration(e);
      } else
        this.unexpected(null, 80);
    }
    parseMethod() {
      let e = super.parseMethod(...arguments);
      if (e.abstract && (this.hasPlugin("estree") ? !!e.value.body : !!e.body)) {
        let { key: r } = e;
        this.raise(S2.AbstractMethodHasImplementation, { at: e, methodName: r.type === "Identifier" && !e.computed ? r.name : "[".concat(this.input.slice(r.start, r.end), "]") });
      }
      return e;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
    }
    parseExportSpecifier(e, s2, r, i2) {
      return !s2 && i2 ? (this.parseTypeOnlyImportExportSpecifier(e, false, r), this.finishNode(e, "ExportSpecifier")) : (e.exportKind = "value", super.parseExportSpecifier(e, s2, r, i2));
    }
    parseImportSpecifier(e, s2, r, i2) {
      return !s2 && i2 ? (this.parseTypeOnlyImportExportSpecifier(e, true, r), this.finishNode(e, "ImportSpecifier")) : (e.importKind = "value", super.parseImportSpecifier(e, s2, r, i2));
    }
    parseTypeOnlyImportExportSpecifier(e, s2, r) {
      let i2 = s2 ? "imported" : "local", a3 = s2 ? "local" : "exported", n = e[i2], o, c = false, f = true, y = n.loc.start;
      if (this.isContextual(93)) {
        let v = this.parseIdentifier();
        if (this.isContextual(93)) {
          let N = this.parseIdentifier();
          ye2(this.state.type) ? (c = true, n = v, o = s2 ? this.parseIdentifier() : this.parseModuleExportName(), f = false) : (o = N, f = false);
        } else
          ye2(this.state.type) ? (f = false, o = s2 ? this.parseIdentifier() : this.parseModuleExportName()) : (c = true, n = v);
      } else
        ye2(this.state.type) && (c = true, s2 ? (n = this.parseIdentifier(true), this.isContextual(93) || this.checkReservedWord(n.name, n.loc.start, true, true)) : n = this.parseModuleExportName());
      c && r && this.raise(s2 ? S2.TypeModifierIsUsedInTypeImports : S2.TypeModifierIsUsedInTypeExports, { at: y }), e[i2] = n, e[a3] = o;
      let T2 = s2 ? "importKind" : "exportKind";
      e[T2] = c ? "type" : "value", f && this.eatContextual(93) && (e[a3] = s2 ? this.parseIdentifier() : this.parseModuleExportName()), e[a3] || (e[a3] = Ee(e[i2])), s2 && this.checkIdentifier(e[a3], Te2);
    }
  };
  function kh(t) {
    if (t.type !== "MemberExpression")
      return false;
    let { computed: e, property: s2 } = t;
    return e && s2.type !== "StringLiteral" && (s2.type !== "TemplateLiteral" || s2.expressions.length > 0) ? false : Br2(t.object);
  }
  function Br2(t) {
    return t.type === "Identifier" ? true : t.type !== "MemberExpression" || t.computed ? false : Br2(t.object);
  }
  var Mr2 = j(_n || (_n = ht$1(["placeholders"])))((t) => ({ ClassNameIsRequired: t("A class name is required."), UnexpectedSpace: t("Unexpected space in placeholder.") })), Dh = (t) => class extends t {
    parsePlaceholder(e) {
      if (this.match(140)) {
        let s2 = this.startNode();
        return this.next(), this.assertNoSpace(), s2.name = super.parseIdentifier(true), this.assertNoSpace(), this.expect(140), this.finishPlaceholder(s2, e);
      }
    }
    finishPlaceholder(e, s2) {
      let r = !!(e.expectedNode && e.type === "Placeholder");
      return e.expectedNode = s2, r ? e : this.finishNode(e, "Placeholder");
    }
    getTokenFromCode(e) {
      return e === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(140, 2) : super.getTokenFromCode(...arguments);
    }
    parseExprAtom() {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
    }
    parseIdentifier() {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
    }
    checkReservedWord(e) {
      e !== void 0 && super.checkReservedWord(...arguments);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
    }
    isValidLVal(e) {
      for (var s2 = arguments.length, r = new Array(s2 > 1 ? s2 - 1 : 0), i2 = 1; i2 < s2; i2++)
        r[i2 - 1] = arguments[i2];
      return e === "Placeholder" || super.isValidLVal(e, ...r);
    }
    toAssignable(e) {
      e && e.type === "Placeholder" && e.expectedNode === "Expression" ? e.expectedNode = "Pattern" : super.toAssignable(...arguments);
    }
    isLet(e) {
      return super.isLet(e) ? true : !this.isContextual(99) || e ? false : this.lookahead().type === 140;
    }
    verifyBreakContinue(e) {
      e.label && e.label.type === "Placeholder" || super.verifyBreakContinue(...arguments);
    }
    parseExpressionStatement(e, s2) {
      if (s2.type !== "Placeholder" || s2.extra && s2.extra.parenthesized)
        return super.parseExpressionStatement(...arguments);
      if (this.match(14)) {
        let r = e;
        return r.label = this.finishPlaceholder(s2, "Identifier"), this.next(), r.body = this.parseStatement("label"), this.finishNode(r, "LabeledStatement");
      }
      return this.semicolon(), e.name = s2.name, this.finishPlaceholder(e, "Statement");
    }
    parseBlock() {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
    }
    parseFunctionId() {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
    }
    parseClass(e, s2, r) {
      let i2 = s2 ? "ClassDeclaration" : "ClassExpression";
      this.next(), this.takeDecorators(e);
      let a3 = this.state.strict, n = this.parsePlaceholder("Identifier");
      if (n)
        if (this.match(81) || this.match(140) || this.match(5))
          e.id = n;
        else {
          if (r || !s2)
            return e.id = null, e.body = this.finishPlaceholder(n, "ClassBody"), this.finishNode(e, i2);
          throw this.raise(Mr2.ClassNameIsRequired, { at: this.state.startLoc });
        }
      else
        this.parseClassId(e, s2, r);
      return this.parseClassSuper(e), e.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!e.superClass, a3), this.finishNode(e, i2);
    }
    parseExport(e) {
      let s2 = this.parsePlaceholder("Identifier");
      if (!s2)
        return super.parseExport(...arguments);
      if (!this.isContextual(97) && !this.match(12))
        return e.specifiers = [], e.source = null, e.declaration = this.finishPlaceholder(s2, "Declaration"), this.finishNode(e, "ExportNamedDeclaration");
      this.expectPlugin("exportDefaultFrom");
      let r = this.startNode();
      return r.exported = s2, e.specifiers = [this.finishNode(r, "ExportDefaultSpecifier")], super.parseExport(e);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        let e = this.nextTokenStart();
        if (this.isUnparsedContextual(e, "from") && this.input.startsWith(ve2(140), this.nextTokenStartSince(e + 4)))
          return true;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(e) {
      return e.specifiers && e.specifiers.length > 0 ? true : super.maybeParseExportDefaultSpecifier(...arguments);
    }
    checkExport(e) {
      let { specifiers: s2 } = e;
      s2 != null && s2.length && (e.specifiers = s2.filter((r) => r.exported.type === "Placeholder")), super.checkExport(e), e.specifiers = s2;
    }
    parseImport(e) {
      let s2 = this.parsePlaceholder("Identifier");
      if (!s2)
        return super.parseImport(...arguments);
      if (e.specifiers = [], !this.isContextual(97) && !this.match(12))
        return e.source = this.finishPlaceholder(s2, "StringLiteral"), this.semicolon(), this.finishNode(e, "ImportDeclaration");
      let r = this.startNodeAtNode(s2);
      return r.local = s2, this.finishNode(r, "ImportDefaultSpecifier"), e.specifiers.push(r), this.eat(12) && (this.maybeParseStarImportSpecifier(e) || this.parseNamedImportSpecifiers(e)), this.expectContextual(97), e.source = this.parseImportSource(), this.semicolon(), this.finishNode(e, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
    }
    assertNoSpace() {
      this.state.start > this.state.lastTokEndLoc.index && this.raise(Mr2.UnexpectedSpace, { at: this.state.lastTokEndLoc });
    }
  }, Fh = (t) => class extends t {
    parseV8Intrinsic() {
      if (this.match(54)) {
        let e = this.state.startLoc, s2 = this.startNode();
        if (this.next(), K(this.state.type)) {
          let r = this.parseIdentifierName(this.state.start), i2 = this.createIdentifier(s2, r);
          if (i2.type = "V8IntrinsicIdentifier", this.match(10))
            return i2;
        }
        this.unexpected(e);
      }
    }
    parseExprAtom() {
      return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
    }
  };
  function se(t, e) {
    let [s2, r] = typeof e == "string" ? [e, {}] : e, i2 = Object.keys(r), a3 = i2.length === 0;
    return t.some((n) => {
      if (typeof n == "string")
        return a3 && n === s2;
      {
        let [o, c] = n;
        if (o !== s2)
          return false;
        for (let f of i2)
          if (c[f] !== r[f])
            return false;
        return true;
      }
    });
  }
  function et2(t, e, s2) {
    let r = t.find((i2) => Array.isArray(i2) ? i2[0] === e : i2 === e);
    return r && Array.isArray(r) ? r[1][s2] : null;
  }
  var Rr = ["minimal", "fsharp", "hack", "smart"], jr2 = ["^^", "@@", "^", "%", "#"], qr2 = ["hash", "bar"];
  function Lh(t) {
    if (se(t, "decorators")) {
      if (se(t, "decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      let e = et2(t, "decorators", "decoratorsBeforeExport");
      if (e == null)
        throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
      if (typeof e != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean.");
    }
    if (se(t, "flow") && se(t, "typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (se(t, "placeholders") && se(t, "v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (se(t, "pipelineOperator")) {
      let e = et2(t, "pipelineOperator", "proposal");
      if (!Rr.includes(e)) {
        let r = Rr.map((i2) => '"'.concat(i2, '"')).join(", ");
        throw new Error('"pipelineOperator" requires "proposal" option whose value must be one of: '.concat(r, "."));
      }
      let s2 = se(t, ["recordAndTuple", { syntaxType: "hash" }]);
      if (e === "hack") {
        if (se(t, "placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (se(t, "v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        let r = et2(t, "pipelineOperator", "topicToken");
        if (!jr2.includes(r)) {
          let i2 = jr2.map((a3) => '"'.concat(a3, '"')).join(", ");
          throw new Error('"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: '.concat(i2, "."));
        }
        if (r === "#" && s2)
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
      } else if (e === "smart" && s2)
        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
    }
    if (se(t, "moduleAttributes")) {
      if (se(t, "importAssertions"))
        throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
      if (et2(t, "moduleAttributes", "version") !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
    }
    if (se(t, "recordAndTuple") && !qr2.includes(et2(t, "recordAndTuple", "syntaxType")))
      throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + qr2.map((e) => "'".concat(e, "'")).join(", "));
    if (se(t, "asyncDoExpressions") && !se(t, "doExpressions")) {
      let e = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw e.missingPlugins = "doExpressions", e;
    }
  }
  var Ur2 = { estree: Ce2, jsx: Th, flow: Ah, typescript: Ih, v8intrinsic: Fh, placeholders: Dh }, Oh = Object.keys(Ur2), _r2 = { sourceType: "script", sourceFilename: void 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, plugins: [], strictMode: null, ranges: false, tokens: false, createParenthesizedExpressions: false, errorRecovery: false, attachComment: true };
  function Bh(t) {
    let e = {};
    for (let s2 of Object.keys(_r2))
      e[s2] = t && t[s2] != null ? t[s2] : _r2[s2];
    return e;
  }
  var Mh = (t, e) => Object.hasOwnProperty.call(t, e) && t[e], zr2 = (t) => t.type === "ParenthesizedExpression" ? zr2(t.expression) : t, Rh = class extends fh {
    toAssignable(t) {
      let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var s2, r;
      let i2;
      switch ((t.type === "ParenthesizedExpression" || (s2 = t.extra) != null && s2.parenthesized) && (i2 = zr2(t), e ? i2.type === "Identifier" ? this.expressionScope.recordArrowParemeterBindingError(l.InvalidParenthesizedAssignment, { at: t }) : i2.type !== "MemberExpression" && this.raise(l.InvalidParenthesizedAssignment, { at: t }) : this.raise(l.InvalidParenthesizedAssignment, { at: t })), t.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          t.type = "ObjectPattern";
          for (let n = 0, o = t.properties.length, c = o - 1; n < o; n++) {
            var a3;
            let f = t.properties[n], y = n === c;
            this.toAssignableObjectExpressionProp(f, y, e), y && f.type === "RestElement" && (a3 = t.extra) != null && a3.trailingCommaLoc && this.raise(l.RestTrailingComma, { at: t.extra.trailingCommaLoc });
          }
          break;
        case "ObjectProperty": {
          let { key: n, value: o } = t;
          this.isPrivateName(n) && this.classScope.usePrivateName(this.getPrivateNameSV(n), n.loc.start), this.toAssignable(o, e);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
        case "ArrayExpression":
          t.type = "ArrayPattern", this.toAssignableList(t.elements, (r = t.extra) == null ? void 0 : r.trailingCommaLoc, e);
          break;
        case "AssignmentExpression":
          t.operator !== "=" && this.raise(l.MissingEqInAssignment, { at: t.left.loc.end }), t.type = "AssignmentPattern", delete t.operator, this.toAssignable(t.left, e);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(i2, e);
          break;
      }
    }
    toAssignableObjectExpressionProp(t, e, s2) {
      if (t.type === "ObjectMethod")
        this.raise(t.kind === "get" || t.kind === "set" ? l.PatternHasAccessor : l.PatternHasMethod, { at: t.key });
      else if (t.type === "SpreadElement") {
        t.type = "RestElement";
        let r = t.argument;
        this.checkToRestConversion(r, false), this.toAssignable(r, s2), e || this.raise(l.RestTrailingComma, { at: t });
      } else
        this.toAssignable(t, s2);
    }
    toAssignableList(t, e, s2) {
      let r = t.length - 1;
      for (let i2 = 0; i2 <= r; i2++) {
        let a3 = t[i2];
        if (!!a3) {
          if (a3.type === "SpreadElement") {
            a3.type = "RestElement";
            let n = a3.argument;
            this.checkToRestConversion(n, true), this.toAssignable(n, s2);
          } else
            this.toAssignable(a3, s2);
          a3.type === "RestElement" && (i2 < r ? this.raise(l.RestTrailingComma, { at: a3 }) : e && this.raise(l.RestTrailingComma, { at: e }));
        }
      }
    }
    isAssignable(t, e) {
      switch (t.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return true;
        case "ObjectExpression": {
          let s2 = t.properties.length - 1;
          return t.properties.every((r, i2) => r.type !== "ObjectMethod" && (i2 === s2 || r.type !== "SpreadElement") && this.isAssignable(r));
        }
        case "ObjectProperty":
          return this.isAssignable(t.value);
        case "SpreadElement":
          return this.isAssignable(t.argument);
        case "ArrayExpression":
          return t.elements.every((s2) => s2 === null || this.isAssignable(s2));
        case "AssignmentExpression":
          return t.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(t.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !e;
        default:
          return false;
      }
    }
    toReferencedList(t, e) {
      return t;
    }
    toReferencedListDeep(t, e) {
      this.toReferencedList(t, e);
      for (let s2 of t)
        (s2 == null ? void 0 : s2.type) === "ArrayExpression" && this.toReferencedListDeep(s2.elements);
    }
    parseSpread(t, e) {
      let s2 = this.startNode();
      return this.next(), s2.argument = this.parseMaybeAssignAllowIn(t, void 0, e), this.finishNode(s2, "SpreadElement");
    }
    parseRestBinding() {
      let t = this.startNode();
      return this.next(), t.argument = this.parseBindingAtom(), this.finishNode(t, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          let t = this.startNode();
          return this.next(), t.elements = this.parseBindingList(3, 93, true), this.finishNode(t, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, true);
      }
      return this.parseIdentifier();
    }
    parseBindingList(t, e, s2, r) {
      let i2 = [], a3 = true;
      for (; !this.eat(t); )
        if (a3 ? a3 = false : this.expect(12), s2 && this.match(12))
          i2.push(null);
        else {
          if (this.eat(t))
            break;
          if (this.match(21)) {
            if (i2.push(this.parseAssignableListItemTypes(this.parseRestBinding())), !this.checkCommaAfterRest(e)) {
              this.expect(t);
              break;
            }
          } else {
            let n = [];
            for (this.match(26) && this.hasPlugin("decorators") && this.raise(l.UnsupportedParameterDecorator, { at: this.state.startLoc }); this.match(26); )
              n.push(this.parseDecorator());
            i2.push(this.parseAssignableListItem(r, n));
          }
        }
      return i2;
    }
    parseBindingRestProperty(t) {
      return this.next(), t.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(t, "RestElement");
    }
    parseBindingProperty() {
      let t = this.startNode(), { type: e, start: s2, startLoc: r } = this.state;
      return e === 21 ? this.parseBindingRestProperty(t) : (e === 134 ? (this.expectPlugin("destructuringPrivate", r), this.classScope.usePrivateName(this.state.value, r), t.key = this.parsePrivateName()) : this.parsePropertyName(t), t.method = false, this.parseObjPropValue(t, s2, r, false, false, true, false), t);
    }
    parseAssignableListItem(t, e) {
      let s2 = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(s2);
      let r = this.parseMaybeDefault(s2.start, s2.loc.start, s2);
      return e.length && (s2.decorators = e), r;
    }
    parseAssignableListItemTypes(t) {
      return t;
    }
    parseMaybeDefault(t, e, s2) {
      var r, i2, a3;
      if (e = (r = e) != null ? r : this.state.startLoc, t = (i2 = t) != null ? i2 : this.state.start, s2 = (a3 = s2) != null ? a3 : this.parseBindingAtom(), !this.eat(29))
        return s2;
      let n = this.startNodeAt(t, e);
      return n.left = s2, n.right = this.parseMaybeAssignAllowIn(), this.finishNode(n, "AssignmentPattern");
    }
    isValidLVal(t, e, s2) {
      return Mh({ AssignmentPattern: "left", RestElement: "argument", ObjectProperty: "value", ParenthesizedExpression: "expression", ArrayPattern: "elements", ObjectPattern: "properties" }, t);
    }
    checkLVal(t, e) {
      let { in: s2, binding: r = Le2, checkClashes: i2 = false, strictModeChanged: a3 = false, allowingSloppyLetBinding: n = !(r & Se2), hasParenthesizedAncestor: o = false } = e;
      var c;
      let f = t.type;
      if (this.isObjectMethod(t))
        return;
      if (f === "MemberExpression") {
        r !== Le2 && this.raise(l.InvalidPropertyBindingPattern, { at: t });
        return;
      }
      if (t.type === "Identifier") {
        this.checkIdentifier(t, r, a3, n);
        let { name: R } = t;
        i2 && (i2.has(R) ? this.raise(l.ParamDupe, { at: t }) : i2.add(R));
        return;
      }
      let y = this.isValidLVal(t.type, !(o || (c = t.extra) != null && c.parenthesized) && s2.type === "AssignmentExpression", r);
      if (y === true)
        return;
      if (y === false) {
        let R = r === Le2 ? l.InvalidLhs : l.InvalidLhsBinding;
        this.raise(R, { at: t, ancestor: s2.type === "UpdateExpression" ? { type: "UpdateExpression", prefix: s2.prefix } : { type: s2.type } });
        return;
      }
      let [T2, v] = Array.isArray(y) ? y : [y, f === "ParenthesizedExpression"], N = t.type === "ArrayPattern" || t.type === "ObjectPattern" || t.type === "ParenthesizedExpression" ? t : s2;
      for (let R of [].concat(t[T2]))
        R && this.checkLVal(R, { in: N, binding: r, checkClashes: i2, allowingSloppyLetBinding: n, strictModeChanged: a3, hasParenthesizedAncestor: v });
    }
    checkIdentifier(t, e) {
      let s2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !(e & Se2);
      this.state.strict && (s2 ? fr2(t.name, this.inModule) : pr2(t.name)) && (e === Le2 ? this.raise(l.StrictEvalArguments, { at: t, referenceName: t.name }) : this.raise(l.StrictEvalArgumentsBinding, { at: t, bindingName: t.name })), !r && t.name === "let" && this.raise(l.LetInLexicalBinding, { at: t }), e & Le2 || this.declareNameFromIdentifier(t, e);
    }
    declareNameFromIdentifier(t, e) {
      this.scope.declareName(t.name, e, t.loc.start);
    }
    checkToRestConversion(t, e) {
      switch (t.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(t.expression, e);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (e)
            break;
        default:
          this.raise(l.InvalidRestAssignmentPattern, { at: t });
      }
    }
    checkCommaAfterRest(t) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === t ? l.RestTrailingComma : l.ElementAfterRest, { at: this.state.startLoc }), true) : false;
    }
  }, jh = class extends Rh {
    checkProto(t, e, s2, r) {
      if (t.type === "SpreadElement" || this.isObjectMethod(t) || t.computed || t.shorthand)
        return;
      let i2 = t.key;
      if ((i2.type === "Identifier" ? i2.name : i2.value) === "__proto__") {
        if (e) {
          this.raise(l.RecordNoProto, { at: i2 });
          return;
        }
        s2.used && (r ? r.doubleProtoLoc === null && (r.doubleProtoLoc = i2.loc.start) : this.raise(l.DuplicateProto, { at: i2 })), s2.used = true;
      }
    }
    shouldExitDescending(t, e) {
      return t.type === "ArrowFunctionExpression" && t.start === e;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      let t = this.parseExpression();
      return this.match(135) || this.unexpected(), this.finalizeRemainingComments(), t.comments = this.state.comments, t.errors = this.state.errors, this.options.tokens && (t.tokens = this.tokens), t;
    }
    parseExpression(t, e) {
      return t ? this.disallowInAnd(() => this.parseExpressionBase(e)) : this.allowInAnd(() => this.parseExpressionBase(e));
    }
    parseExpressionBase(t) {
      let e = this.state.start, s2 = this.state.startLoc, r = this.parseMaybeAssign(t);
      if (this.match(12)) {
        let i2 = this.startNodeAt(e, s2);
        for (i2.expressions = [r]; this.eat(12); )
          i2.expressions.push(this.parseMaybeAssign(t));
        return this.toReferencedList(i2.expressions), this.finishNode(i2, "SequenceExpression");
      }
      return r;
    }
    parseMaybeAssignDisallowIn(t, e) {
      return this.disallowInAnd(() => this.parseMaybeAssign(t, e));
    }
    parseMaybeAssignAllowIn(t, e) {
      return this.allowInAnd(() => this.parseMaybeAssign(t, e));
    }
    setOptionalParametersError(t, e) {
      var s2;
      t.optionalParametersLoc = (s2 = e == null ? void 0 : e.loc) != null ? s2 : this.state.startLoc;
    }
    parseMaybeAssign(t, e) {
      let s2 = this.state.start, r = this.state.startLoc;
      if (this.isContextual(105) && this.prodParam.hasYield) {
        let o = this.parseYield();
        return e && (o = e.call(this, o, s2, r)), o;
      }
      let i2;
      t ? i2 = false : (t = new bt2(), i2 = true);
      let { type: a3 } = this.state;
      (a3 === 10 || K(a3)) && (this.state.potentialArrowAt = this.state.start);
      let n = this.parseMaybeConditional(t);
      if (e && (n = e.call(this, n, s2, r)), mo2(this.state.type)) {
        let o = this.startNodeAt(s2, r), c = this.state.value;
        return o.operator = c, this.match(29) ? (this.toAssignable(n, true), o.left = n, t.doubleProtoLoc != null && t.doubleProtoLoc.index >= s2 && (t.doubleProtoLoc = null), t.shorthandAssignLoc != null && t.shorthandAssignLoc.index >= s2 && (t.shorthandAssignLoc = null), t.privateKeyLoc != null && t.privateKeyLoc.index >= s2 && (this.checkDestructuringPrivate(t), t.privateKeyLoc = null)) : o.left = n, this.next(), o.right = this.parseMaybeAssign(), this.checkLVal(n, { in: this.finishNode(o, "AssignmentExpression") }), o;
      } else
        i2 && this.checkExpressionErrors(t, true);
      return n;
    }
    parseMaybeConditional(t) {
      let e = this.state.start, s2 = this.state.startLoc, r = this.state.potentialArrowAt, i2 = this.parseExprOps(t);
      return this.shouldExitDescending(i2, r) ? i2 : this.parseConditional(i2, e, s2, t);
    }
    parseConditional(t, e, s2, r) {
      if (this.eat(17)) {
        let i2 = this.startNodeAt(e, s2);
        return i2.test = t, i2.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), i2.alternate = this.parseMaybeAssign(), this.finishNode(i2, "ConditionalExpression");
      }
      return t;
    }
    parseMaybeUnaryOrPrivate(t) {
      return this.match(134) ? this.parsePrivateName() : this.parseMaybeUnary(t);
    }
    parseExprOps(t) {
      let e = this.state.start, s2 = this.state.startLoc, r = this.state.potentialArrowAt, i2 = this.parseMaybeUnaryOrPrivate(t);
      return this.shouldExitDescending(i2, r) ? i2 : this.parseExprOp(i2, e, s2, -1);
    }
    parseExprOp(t, e, s2, r) {
      if (this.isPrivateName(t)) {
        let a3 = this.getPrivateNameSV(t);
        (r >= lt2(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(l.PrivateInExpectedIn, { at: t, identifierName: a3 }), this.classScope.usePrivateName(a3, t.loc.start);
      }
      let i2 = this.state.type;
      if (xo2(i2) && (this.prodParam.hasIn || !this.match(58))) {
        let a3 = lt2(i2);
        if (a3 > r) {
          if (i2 === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return t;
            this.checkPipelineAtInfixOperator(t, s2);
          }
          let n = this.startNodeAt(e, s2);
          n.left = t, n.operator = this.state.value;
          let o = i2 === 41 || i2 === 42, c = i2 === 40;
          if (c && (a3 = lt2(42)), this.next(), i2 === 39 && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(l.UnexpectedAwaitAfterPipelineBody, { at: this.state.startLoc });
          n.right = this.parseExprOpRightExpr(i2, a3), this.finishNode(n, o || c ? "LogicalExpression" : "BinaryExpression");
          let f = this.state.type;
          if (c && (f === 41 || f === 42) || o && f === 40)
            throw this.raise(l.MixingCoalesceWithLogical, { at: this.state.startLoc });
          return this.parseExprOp(n, e, s2, r);
        }
      }
      return t;
    }
    parseExprOpRightExpr(t, e) {
      let s2 = this.state.start, r = this.state.startLoc;
      switch (t) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "smart":
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(105))
                  throw this.raise(l.PipeBodyIsTighter, { at: this.state.startLoc });
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(t, e), s2, r);
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(e));
          }
        default:
          return this.parseExprOpBaseRightExpr(t, e);
      }
    }
    parseExprOpBaseRightExpr(t, e) {
      let s2 = this.state.start, r = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s2, r, bo2(t) ? e - 1 : e);
    }
    parseHackPipeBody() {
      var t;
      let { startLoc: e } = this.state, s2 = this.parseMaybeAssign();
      return L.has(s2.type) && !((t = s2.extra) != null && t.parenthesized) && this.raise(l.PipeUnparenthesizedBody, { at: e, type: s2.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(l.PipeTopicUnused, { at: e }), s2;
    }
    checkExponentialAfterUnary(t) {
      this.match(57) && this.raise(l.UnexpectedTokenUnaryExponentiation, { at: t.argument });
    }
    parseMaybeUnary(t, e) {
      let s2 = this.state.start, r = this.state.startLoc, i2 = this.isContextual(96);
      if (i2 && this.isAwaitAllowed()) {
        this.next();
        let c = this.parseAwait(s2, r);
        return e || this.checkExponentialAfterUnary(c), c;
      }
      let a3 = this.match(34), n = this.startNode();
      if (Ao2(this.state.type)) {
        n.operator = this.state.value, n.prefix = true, this.match(72) && this.expectPlugin("throwExpressions");
        let c = this.match(89);
        if (this.next(), n.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(t, true), this.state.strict && c) {
          let f = n.argument;
          f.type === "Identifier" ? this.raise(l.StrictDelete, { at: n }) : this.hasPropertyAsPrivateName(f) && this.raise(l.DeletePrivateField, { at: n });
        }
        if (!a3)
          return e || this.checkExponentialAfterUnary(n), this.finishNode(n, "UnaryExpression");
      }
      let o = this.parseUpdate(n, a3, t);
      if (i2) {
        let { type: c } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? Kt2(c) : Kt2(c) && !this.match(54)) && !this.isAmbiguousAwait())
          return this.raiseOverwrite(l.AwaitNotInAsyncContext, { at: r }), this.parseAwait(s2, r);
      }
      return o;
    }
    parseUpdate(t, e, s2) {
      if (e)
        return this.checkLVal(t.argument, { in: this.finishNode(t, "UpdateExpression") }), t;
      let r = this.state.start, i2 = this.state.startLoc, a3 = this.parseExprSubscripts(s2);
      if (this.checkExpressionErrors(s2, false))
        return a3;
      for (; go2(this.state.type) && !this.canInsertSemicolon(); ) {
        let n = this.startNodeAt(r, i2);
        n.operator = this.state.value, n.prefix = false, n.argument = a3, this.next(), this.checkLVal(a3, { in: a3 = this.finishNode(n, "UpdateExpression") });
      }
      return a3;
    }
    parseExprSubscripts(t) {
      let e = this.state.start, s2 = this.state.startLoc, r = this.state.potentialArrowAt, i2 = this.parseExprAtom(t);
      return this.shouldExitDescending(i2, r) ? i2 : this.parseSubscripts(i2, e, s2);
    }
    parseSubscripts(t, e, s2, r) {
      let i2 = { optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(t), stop: false };
      do
        t = this.parseSubscript(t, e, s2, r, i2), i2.maybeAsyncArrow = false;
      while (!i2.stop);
      return t;
    }
    parseSubscript(t, e, s2, r, i2) {
      let { type: a3 } = this.state;
      if (!r && a3 === 15)
        return this.parseBind(t, e, s2, r, i2);
      if (ut2(a3))
        return this.parseTaggedTemplateExpression(t, e, s2, i2);
      let n = false;
      if (a3 === 18) {
        if (r && this.lookaheadCharCode() === 40)
          return i2.stop = true, t;
        i2.optionalChainMember = n = true, this.next();
      }
      if (!r && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(t, e, s2, i2, n);
      {
        let o = this.eat(0);
        return o || n || this.eat(16) ? this.parseMember(t, e, s2, i2, o, n) : (i2.stop = true, t);
      }
    }
    parseMember(t, e, s2, r, i2, a3) {
      let n = this.startNodeAt(e, s2);
      return n.object = t, n.computed = i2, i2 ? (n.property = this.parseExpression(), this.expect(3)) : this.match(134) ? (t.type === "Super" && this.raise(l.SuperPrivateField, { at: s2 }), this.classScope.usePrivateName(this.state.value, this.state.startLoc), n.property = this.parsePrivateName()) : n.property = this.parseIdentifier(true), r.optionalChainMember ? (n.optional = a3, this.finishNode(n, "OptionalMemberExpression")) : this.finishNode(n, "MemberExpression");
    }
    parseBind(t, e, s2, r, i2) {
      let a3 = this.startNodeAt(e, s2);
      return a3.object = t, this.next(), a3.callee = this.parseNoCallExpr(), i2.stop = true, this.parseSubscripts(this.finishNode(a3, "BindExpression"), e, s2, r);
    }
    parseCoverCallAndAsyncArrowHead(t, e, s2, r, i2) {
      let a3 = this.state.maybeInArrowParameters, n = null;
      this.state.maybeInArrowParameters = true, this.next();
      let o = this.startNodeAt(e, s2);
      o.callee = t;
      let { maybeAsyncArrow: c, optionalChainMember: f } = r;
      return c && (this.expressionScope.enter(hh2()), n = new bt2()), f && (o.optional = i2), i2 ? o.arguments = this.parseCallExpressionArguments(11) : o.arguments = this.parseCallExpressionArguments(11, t.type === "Import", t.type !== "Super", o, n), this.finishCallExpression(o, f), c && this.shouldParseAsyncArrow() && !i2 ? (r.stop = true, this.checkDestructuringPrivate(n), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), o = this.parseAsyncArrowFromCallExpression(this.startNodeAt(e, s2), o)) : (c && (this.checkExpressionErrors(n, true), this.expressionScope.exit()), this.toReferencedArguments(o)), this.state.maybeInArrowParameters = a3, o;
    }
    toReferencedArguments(t, e) {
      this.toReferencedListDeep(t.arguments, e);
    }
    parseTaggedTemplateExpression(t, e, s2, r) {
      let i2 = this.startNodeAt(e, s2);
      return i2.tag = t, i2.quasi = this.parseTemplate(true), r.optionalChainMember && this.raise(l.OptionalChainingNoTemplate, { at: s2 }), this.finishNode(i2, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(t) {
      return t.type === "Identifier" && t.name === "async" && this.state.lastTokEndLoc.index === t.end && !this.canInsertSemicolon() && t.end - t.start === 5 && t.start === this.state.potentialArrowAt;
    }
    finishCallExpression(t, e) {
      if (t.callee.type === "Import")
        if (t.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectPlugin("importAssertions")), t.arguments.length === 0 || t.arguments.length > 2)
          this.raise(l.ImportCallArity, { at: t, maxArgumentCount: this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1 });
        else
          for (let s2 of t.arguments)
            s2.type === "SpreadElement" && this.raise(l.ImportCallSpreadArgument, { at: s2 });
      return this.finishNode(t, e ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(t, e, s2, r, i2) {
      let a3 = [], n = true, o = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = false; !this.eat(t); ) {
        if (n)
          n = false;
        else if (this.expect(12), this.match(t)) {
          e && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(l.ImportCallArgumentTrailingComma, { at: this.state.lastTokStartLoc }), r && this.addTrailingCommaExtraToNode(r), this.next();
          break;
        }
        a3.push(this.parseExprListItem(false, i2, s2));
      }
      return this.state.inFSharpPipelineDirectBody = o, a3;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(t, e) {
      var s2;
      return this.resetPreviousNodeTrailingComments(e), this.expect(19), this.parseArrowExpression(t, e.arguments, true, (s2 = e.extra) == null ? void 0 : s2.trailingCommaLoc), e.innerComments && Qe(t, e.innerComments), e.callee.trailingComments && Qe(t, e.callee.trailingComments), t;
    }
    parseNoCallExpr() {
      let t = this.state.start, e = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), t, e, true);
    }
    parseExprAtom(t) {
      let e, { type: s2 } = this.state;
      switch (s2) {
        case 79:
          return this.parseSuper();
        case 83:
          return e = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(e) : (this.match(10) || this.raise(l.UnsupportedImport, { at: this.state.lastTokStartLoc }), this.finishNode(e, "Import"));
        case 78:
          return e = this.startNode(), this.next(), this.finishNode(e, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), false);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 130:
          return this.parseNumericLiteral(this.state.value);
        case 131:
          return this.parseBigIntLiteral(this.state.value);
        case 132:
          return this.parseDecimalLiteral(this.state.value);
        case 129:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(true);
        case 86:
          return this.parseBooleanLiteral(false);
        case 10: {
          let r = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(r);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
        case 0:
          return this.parseArrayLike(3, true, false, t);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
        case 5:
          return this.parseObjectLike(8, false, false, t);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          this.parseDecorators();
        case 80:
          return e = this.startNode(), this.takeDecorators(e), this.parseClass(e, false);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(false);
        case 15: {
          e = this.startNode(), this.next(), e.object = null;
          let r = e.callee = this.parseNoCallExpr();
          if (r.type === "MemberExpression")
            return this.finishNode(e, "BindExpression");
          throw this.raise(l.UnsupportedBind, { at: r });
        }
        case 134:
          return this.raise(l.PrivateInExpectedIn, { at: this.state.startLoc, identifierName: this.state.value }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          let r = this.getPluginOption("pipelineOperator", "proposal");
          if (r)
            return this.parseTopicReference(r);
          throw this.unexpected();
        }
        case 47: {
          let r = this.input.codePointAt(this.nextTokenStart());
          if (ge2(r) || r === 62) {
            this.expectOnePlugin(["jsx", "flow", "typescript"]);
            break;
          } else
            throw this.unexpected();
        }
        default:
          if (K(s2)) {
            if (this.isContextual(123) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak())
              return this.parseModuleExpression();
            let r = this.state.potentialArrowAt === this.state.start, i2 = this.state.containsEsc, a3 = this.parseIdentifier();
            if (!i2 && a3.name === "async" && !this.canInsertSemicolon()) {
              let { type: n } = this.state;
              if (n === 68)
                return this.resetPreviousNodeTrailingComments(a3), this.next(), this.parseFunction(this.startNodeAtNode(a3), void 0, true);
              if (K(n))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(a3)) : a3;
              if (n === 90)
                return this.resetPreviousNodeTrailingComments(a3), this.parseDo(this.startNodeAtNode(a3), true);
            }
            return r && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(a3), [a3], false)) : a3;
          } else
            throw this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(t, e) {
      let s2 = this.getPluginOption("pipelineOperator", "proposal");
      if (s2)
        return this.state.type = t, this.state.value = e, this.state.pos--, this.state.end--, this.state.endLoc = m2(this.state.endLoc, -1), this.parseTopicReference(s2);
      throw this.unexpected();
    }
    parseTopicReference(t) {
      let e = this.startNode(), s2 = this.state.startLoc, r = this.state.type;
      return this.next(), this.finishTopicReference(e, s2, t, r);
    }
    finishTopicReference(t, e, s2, r) {
      if (this.testTopicReferenceConfiguration(s2, e, r)) {
        let i2 = s2 === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
        return this.topicReferenceIsAllowedInCurrentContext() || this.raise(s2 === "smart" ? l.PrimaryTopicNotAllowed : l.PipeTopicUnbound, { at: e }), this.registerTopicReference(), this.finishNode(t, i2);
      } else
        throw this.raise(l.PipeTopicUnconfiguredToken, { at: e, token: ve2(r) });
    }
    testTopicReferenceConfiguration(t, e, s2) {
      switch (t) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", { topicToken: ve2(s2) }]);
        case "smart":
          return s2 === 27;
        default:
          throw this.raise(l.PipeTopicRequiresHackPipes, { at: e });
      }
    }
    parseAsyncArrowUnaryFunction(t) {
      this.prodParam.enter(Et2(true, this.prodParam.hasYield));
      let e = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(l.LineTerminatorBeforeArrow, { at: this.state.curPosition() }), this.expect(19), this.parseArrowExpression(t, e, true), t;
    }
    parseDo(t, e) {
      this.expectPlugin("doExpressions"), e && this.expectPlugin("asyncDoExpressions"), t.async = e, this.next();
      let s2 = this.state.labels;
      return this.state.labels = [], e ? (this.prodParam.enter(Tt2), t.body = this.parseBlock(), this.prodParam.exit()) : t.body = this.parseBlock(), this.state.labels = s2, this.finishNode(t, "DoExpression");
    }
    parseSuper() {
      let t = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(l.SuperNotAllowed, { at: t }) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(l.UnexpectedSuper, { at: t }), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(l.UnsupportedSuper, { at: t }), this.finishNode(t, "Super");
    }
    parsePrivateName() {
      let t = this.startNode(), e = this.startNodeAt(this.state.start + 1, new p(this.state.curLine, this.state.start + 1 - this.state.lineStart, this.state.start + 1)), s2 = this.state.value;
      return this.next(), t.id = this.createIdentifier(e, s2), this.finishNode(t, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      let t = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        let e = this.createIdentifier(this.startNodeAtNode(t), "function");
        return this.next(), this.match(102) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(t, e, "sent");
      }
      return this.parseFunction(t);
    }
    parseMetaProperty(t, e, s2) {
      t.meta = e;
      let r = this.state.containsEsc;
      return t.property = this.parseIdentifier(true), (t.property.name !== s2 || r) && this.raise(l.UnsupportedMetaProperty, { at: t.property, target: e.name, onlyValidPropertyName: s2 }), this.finishNode(t, "MetaProperty");
    }
    parseImportMetaProperty(t) {
      let e = this.createIdentifier(this.startNodeAtNode(t), "import");
      return this.next(), this.isContextual(100) && (this.inModule || this.raise(l.ImportMetaOutsideModule, { at: e }), this.sawUnambiguousESM = true), this.parseMetaProperty(t, e, "meta");
    }
    parseLiteralAtNode(t, e, s2) {
      return this.addExtra(s2, "rawValue", t), this.addExtra(s2, "raw", this.input.slice(s2.start, this.state.end)), s2.value = t, this.next(), this.finishNode(s2, e);
    }
    parseLiteral(t, e) {
      let s2 = this.startNode();
      return this.parseLiteralAtNode(t, e, s2);
    }
    parseStringLiteral(t) {
      return this.parseLiteral(t, "StringLiteral");
    }
    parseNumericLiteral(t) {
      return this.parseLiteral(t, "NumericLiteral");
    }
    parseBigIntLiteral(t) {
      return this.parseLiteral(t, "BigIntLiteral");
    }
    parseDecimalLiteral(t) {
      return this.parseLiteral(t, "DecimalLiteral");
    }
    parseRegExpLiteral(t) {
      let e = this.parseLiteral(t.value, "RegExpLiteral");
      return e.pattern = t.pattern, e.flags = t.flags, e;
    }
    parseBooleanLiteral(t) {
      let e = this.startNode();
      return e.value = t, this.next(), this.finishNode(e, "BooleanLiteral");
    }
    parseNullLiteral() {
      let t = this.startNode();
      return this.next(), this.finishNode(t, "NullLiteral");
    }
    parseParenAndDistinguishExpression(t) {
      let e = this.state.start, s2 = this.state.startLoc, r;
      this.next(), this.expressionScope.enter(oh());
      let i2 = this.state.maybeInArrowParameters, a3 = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
      let n = this.state.start, o = this.state.startLoc, c = [], f = new bt2(), y = true, T2, v;
      for (; !this.match(11); ) {
        if (y)
          y = false;
        else if (this.expect(12, f.optionalParametersLoc === null ? null : f.optionalParametersLoc), this.match(11)) {
          v = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          let z = this.state.start, te2 = this.state.startLoc;
          if (T2 = this.state.startLoc, c.push(this.parseParenItem(this.parseRestBinding(), z, te2)), !this.checkCommaAfterRest(41))
            break;
        } else
          c.push(this.parseMaybeAssignAllowIn(f, this.parseParenItem));
      }
      let N = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = i2, this.state.inFSharpPipelineDirectBody = a3;
      let R = this.startNodeAt(e, s2);
      return t && this.shouldParseArrow(c) && (R = this.parseArrow(R)) ? (this.checkDestructuringPrivate(f), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(R, c, false), R) : (this.expressionScope.exit(), c.length || this.unexpected(this.state.lastTokStartLoc), v && this.unexpected(v), T2 && this.unexpected(T2), this.checkExpressionErrors(f, true), this.toReferencedListDeep(c, true), c.length > 1 ? (r = this.startNodeAt(n, o), r.expressions = c, this.finishNode(r, "SequenceExpression"), this.resetEndLocation(r, N)) : r = c[0], this.wrapParenthesis(e, s2, r));
    }
    wrapParenthesis(t, e, s2) {
      if (!this.options.createParenthesizedExpressions)
        return this.addExtra(s2, "parenthesized", true), this.addExtra(s2, "parenStart", t), this.takeSurroundingComments(s2, t, this.state.lastTokEndLoc.index), s2;
      let r = this.startNodeAt(t, e);
      return r.expression = s2, this.finishNode(r, "ParenthesizedExpression"), r;
    }
    shouldParseArrow(t) {
      return !this.canInsertSemicolon();
    }
    parseArrow(t) {
      if (this.eat(19))
        return t;
    }
    parseParenItem(t, e, s2) {
      return t;
    }
    parseNewOrNewTarget() {
      let t = this.startNode();
      if (this.next(), this.match(16)) {
        let e = this.createIdentifier(this.startNodeAtNode(t), "new");
        this.next();
        let s2 = this.parseMetaProperty(t, e, "target");
        return !this.scope.inNonArrowFunction && !this.scope.inClass && this.raise(l.UnexpectedNewTarget, { at: s2 }), s2;
      }
      return this.parseNew(t);
    }
    parseNew(t) {
      if (this.parseNewCallee(t), this.eat(10)) {
        let e = this.parseExprList(11);
        this.toReferencedList(e), t.arguments = e;
      } else
        t.arguments = [];
      return this.finishNode(t, "NewExpression");
    }
    parseNewCallee(t) {
      t.callee = this.parseNoCallExpr(), t.callee.type === "Import" ? this.raise(l.ImportCallNotNewExpression, { at: t.callee }) : this.isOptionalChain(t.callee) ? this.raise(l.OptionalChainingNoNew, { at: this.state.lastTokEndLoc }) : this.eat(18) && this.raise(l.OptionalChainingNoNew, { at: this.state.startLoc });
    }
    parseTemplateElement(t) {
      let { start: e, startLoc: s2, end: r, value: i2 } = this.state, a3 = e + 1, n = this.startNodeAt(a3, m2(s2, 1));
      i2 === null && (t || this.raise(l.InvalidEscapeSequenceTemplate, { at: m2(s2, 2) }));
      let o = this.match(24), c = o ? -1 : -2, f = r + c;
      return n.value = { raw: this.input.slice(a3, f).replace(/\r\n?/g, `
`), cooked: i2 === null ? null : i2.slice(1, c) }, n.tail = o, this.next(), this.finishNode(n, "TemplateElement"), this.resetEndLocation(n, m2(this.state.lastTokEndLoc, c)), n;
    }
    parseTemplate(t) {
      let e = this.startNode();
      e.expressions = [];
      let s2 = this.parseTemplateElement(t);
      for (e.quasis = [s2]; !s2.tail; )
        e.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), e.quasis.push(s2 = this.parseTemplateElement(t));
      return this.finishNode(e, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(t, e, s2, r) {
      s2 && this.expectPlugin("recordAndTuple");
      let i2 = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      let a3 = /* @__PURE__ */ Object.create(null), n = true, o = this.startNode();
      for (o.properties = [], this.next(); !this.match(t); ) {
        if (n)
          n = false;
        else if (this.expect(12), this.match(t)) {
          this.addTrailingCommaExtraToNode(o);
          break;
        }
        let f;
        e ? f = this.parseBindingProperty() : (f = this.parsePropertyDefinition(r), this.checkProto(f, s2, a3, r)), s2 && !this.isObjectProperty(f) && f.type !== "SpreadElement" && this.raise(l.InvalidRecordProperty, { at: f }), f.shorthand && this.addExtra(f, "shorthand", true), o.properties.push(f);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = i2;
      let c = "ObjectExpression";
      return e ? c = "ObjectPattern" : s2 && (c = "RecordExpression"), this.finishNode(o, c);
    }
    addTrailingCommaExtraToNode(t) {
      this.addExtra(t, "trailingComma", this.state.lastTokStart), this.addExtra(t, "trailingCommaLoc", this.state.lastTokStartLoc, false);
    }
    maybeAsyncOrAccessorProp(t) {
      return !t.computed && t.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(t) {
      let e = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(l.UnsupportedPropertyDecorator, { at: this.state.startLoc }); this.match(26); )
          e.push(this.parseDecorator());
      let s2 = this.startNode(), r = false, i2 = false, a3, n;
      if (this.match(21))
        return e.length && this.unexpected(), this.parseSpread();
      e.length && (s2.decorators = e, e = []), s2.method = false, t && (a3 = this.state.start, n = this.state.startLoc);
      let o = this.eat(55);
      this.parsePropertyNamePrefixOperator(s2);
      let c = this.state.containsEsc, f = this.parsePropertyName(s2, t);
      if (!o && !c && this.maybeAsyncOrAccessorProp(s2)) {
        let y = f.name;
        y === "async" && !this.hasPrecedingLineBreak() && (r = true, this.resetPreviousNodeTrailingComments(f), o = this.eat(55), this.parsePropertyName(s2)), (y === "get" || y === "set") && (i2 = true, this.resetPreviousNodeTrailingComments(f), s2.kind = y, this.match(55) && (o = true, this.raise(l.AccessorIsGenerator, { at: this.state.curPosition(), kind: y }), this.next()), this.parsePropertyName(s2));
      }
      return this.parseObjPropValue(s2, a3, n, o, r, false, i2, t), s2;
    }
    getGetterSetterExpectedParamCount(t) {
      return t.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(t) {
      return t.params;
    }
    checkGetterSetterParams(t) {
      var e;
      let s2 = this.getGetterSetterExpectedParamCount(t), r = this.getObjectOrClassMethodParams(t);
      r.length !== s2 && this.raise(t.kind === "get" ? l.BadGetterArity : l.BadSetterArity, { at: t }), t.kind === "set" && ((e = r[r.length - 1]) == null ? void 0 : e.type) === "RestElement" && this.raise(l.BadSetterRestParameter, { at: t });
    }
    parseObjectMethod(t, e, s2, r, i2) {
      if (i2)
        return this.parseMethod(t, e, false, false, false, "ObjectMethod"), this.checkGetterSetterParams(t), t;
      if (s2 || e || this.match(10))
        return r && this.unexpected(), t.kind = "method", t.method = true, this.parseMethod(t, e, s2, false, false, "ObjectMethod");
    }
    parseObjectProperty(t, e, s2, r, i2) {
      if (t.shorthand = false, this.eat(14))
        return t.value = r ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(i2), this.finishNode(t, "ObjectProperty");
      if (!t.computed && t.key.type === "Identifier") {
        if (this.checkReservedWord(t.key.name, t.key.loc.start, true, false), r)
          t.value = this.parseMaybeDefault(e, s2, Ee(t.key));
        else if (this.match(29)) {
          let a3 = this.state.startLoc;
          i2 != null ? i2.shorthandAssignLoc === null && (i2.shorthandAssignLoc = a3) : this.raise(l.InvalidCoverInitializedName, { at: a3 }), t.value = this.parseMaybeDefault(e, s2, Ee(t.key));
        } else
          t.value = Ee(t.key);
        return t.shorthand = true, this.finishNode(t, "ObjectProperty");
      }
    }
    parseObjPropValue(t, e, s2, r, i2, a3, n, o) {
      let c = this.parseObjectMethod(t, r, i2, a3, n) || this.parseObjectProperty(t, e, s2, a3, o);
      return c || this.unexpected(), c;
    }
    parsePropertyName(t, e) {
      if (this.eat(0))
        t.computed = true, t.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        let { type: s2, value: r } = this.state, i2;
        if (ye2(s2))
          i2 = this.parseIdentifier(true);
        else
          switch (s2) {
            case 130:
              i2 = this.parseNumericLiteral(r);
              break;
            case 129:
              i2 = this.parseStringLiteral(r);
              break;
            case 131:
              i2 = this.parseBigIntLiteral(r);
              break;
            case 132:
              i2 = this.parseDecimalLiteral(r);
              break;
            case 134: {
              let a3 = this.state.startLoc;
              e != null ? e.privateKeyLoc === null && (e.privateKeyLoc = a3) : this.raise(l.UnexpectedPrivateField, { at: a3 }), i2 = this.parsePrivateName();
              break;
            }
            default:
              throw this.unexpected();
          }
        t.key = i2, s2 !== 134 && (t.computed = false);
      }
      return t.key;
    }
    initFunction(t, e) {
      t.id = null, t.generator = false, t.async = !!e;
    }
    parseMethod(t, e, s2, r, i2, a3) {
      let n = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
      this.initFunction(t, s2), t.generator = !!e;
      let o = r;
      return this.scope.enter(Ae2 | ct2 | (n ? Fe2 : 0) | (i2 ? mr2 : 0)), this.prodParam.enter(Et2(s2, t.generator)), this.parseFunctionParams(t, o), this.parseFunctionBodyAndFinish(t, a3, true), this.prodParam.exit(), this.scope.exit(), t;
    }
    parseArrayLike(t, e, s2, r) {
      s2 && this.expectPlugin("recordAndTuple");
      let i2 = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      let a3 = this.startNode();
      return this.next(), a3.elements = this.parseExprList(t, !s2, r, a3), this.state.inFSharpPipelineDirectBody = i2, this.finishNode(a3, s2 ? "TupleExpression" : "ArrayExpression");
    }
    parseArrowExpression(t, e, s2, r) {
      this.scope.enter(Ae2 | Xt2);
      let i2 = Et2(s2, false);
      !this.match(5) && this.prodParam.hasIn && (i2 |= We2), this.prodParam.enter(i2), this.initFunction(t, s2);
      let a3 = this.state.maybeInArrowParameters;
      return e && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(t, e, r)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(t, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = a3, this.finishNode(t, "ArrowFunctionExpression");
    }
    setArrowFunctionParameters(t, e, s2) {
      this.toAssignableList(e, s2, false), t.params = e;
    }
    parseFunctionBodyAndFinish(t, e) {
      let s2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      this.parseFunctionBody(t, false, s2), this.finishNode(t, e);
    }
    parseFunctionBody(t, e) {
      let s2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, r = e && !this.match(5);
      if (this.expressionScope.enter(Ir2()), r)
        t.body = this.parseMaybeAssign(), this.checkParams(t, false, e, false);
      else {
        let i2 = this.state.strict, a3 = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | Dr2), t.body = this.parseBlock(true, false, (n) => {
          let o = !this.isSimpleParamList(t.params);
          n && o && this.raise(l.IllegalLanguageModeDirective, { at: (t.kind === "method" || t.kind === "constructor") && !!t.key ? t.key.loc.end : t });
          let c = !i2 && this.state.strict;
          this.checkParams(t, !this.state.strict && !e && !s2 && !o, e, c), this.state.strict && t.id && this.checkIdentifier(t.id, Mo2, c);
        }), this.prodParam.exit(), this.state.labels = a3;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(t) {
      return t.type === "Identifier";
    }
    isSimpleParamList(t) {
      for (let e = 0, s2 = t.length; e < s2; e++)
        if (!this.isSimpleParameter(t[e]))
          return false;
      return true;
    }
    checkParams(t, e, s2) {
      let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true, i2 = !e && /* @__PURE__ */ new Set(), a3 = { type: "FormalParameters" };
      for (let n of t.params)
        this.checkLVal(n, { in: a3, binding: yt2, checkClashes: i2, strictModeChanged: r });
    }
    parseExprList(t, e, s2, r) {
      let i2 = [], a3 = true;
      for (; !this.eat(t); ) {
        if (a3)
          a3 = false;
        else if (this.expect(12), this.match(t)) {
          r && this.addTrailingCommaExtraToNode(r), this.next();
          break;
        }
        i2.push(this.parseExprListItem(e, s2));
      }
      return i2;
    }
    parseExprListItem(t, e, s2) {
      let r;
      if (this.match(12))
        t || this.raise(l.UnexpectedToken, { at: this.state.curPosition(), unexpected: "," }), r = null;
      else if (this.match(21)) {
        let i2 = this.state.start, a3 = this.state.startLoc;
        r = this.parseParenItem(this.parseSpread(e), i2, a3);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), s2 || this.raise(l.UnexpectedArgumentPlaceholder, { at: this.state.startLoc });
        let i2 = this.startNode();
        this.next(), r = this.finishNode(i2, "ArgumentPlaceholder");
      } else
        r = this.parseMaybeAssignAllowIn(e, this.parseParenItem);
      return r;
    }
    parseIdentifier(t) {
      let e = this.startNode(), s2 = this.parseIdentifierName(e.start, t);
      return this.createIdentifier(e, s2);
    }
    createIdentifier(t, e) {
      return t.name = e, t.loc.identifierName = e, this.finishNode(t, "Identifier");
    }
    parseIdentifierName(t, e) {
      let s2, { startLoc: r, type: i2 } = this.state;
      if (ye2(i2))
        s2 = this.state.value;
      else
        throw this.unexpected();
      let a3 = po2(i2);
      return e ? a3 && this.replaceToken(128) : this.checkReservedWord(s2, r, a3, false), this.next(), s2;
    }
    checkReservedWord(t, e, s2, r) {
      if (t.length > 10 || !Lo2(t))
        return;
      if (t === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(l.YieldBindingIdentifier, { at: e });
          return;
        }
      } else if (t === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(l.AwaitBindingIdentifier, { at: e });
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(l.AwaitBindingIdentifierInStaticBlock, { at: e });
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError({ at: e });
      } else if (t === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(l.ArgumentsInClass, { at: e });
        return;
      }
      if (s2 && ko2(t)) {
        this.raise(l.UnexpectedKeyword, { at: e, keyword: t });
        return;
      }
      (this.state.strict ? r ? fr2 : cr2 : ur2)(t, this.inModule) && this.raise(l.UnexpectedReservedWord, { at: e, reservedWord: t });
    }
    isAwaitAllowed() {
      return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
    }
    parseAwait(t, e) {
      let s2 = this.startNodeAt(t, e);
      return this.expressionScope.recordParameterInitializerError(l.AwaitExpressionFormalParameter, { at: s2 }), this.eat(55) && this.raise(l.ObsoleteAwaitStar, { at: s2 }), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (s2.argument = this.parseMaybeUnary(null, true)), this.finishNode(s2, "AwaitExpression");
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak())
        return true;
      let { type: t } = this.state;
      return t === 53 || t === 10 || t === 0 || ut2(t) || t === 133 || t === 56 || this.hasPlugin("v8intrinsic") && t === 54;
    }
    parseYield() {
      let t = this.startNode();
      this.expressionScope.recordParameterInitializerError(l.YieldInParameter, { at: t }), this.next();
      let e = false, s2 = null;
      if (!this.hasPrecedingLineBreak())
        switch (e = this.eat(55), this.state.type) {
          case 13:
          case 135:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!e)
              break;
          default:
            s2 = this.parseMaybeAssign();
        }
      return t.delegate = e, t.argument = s2, this.finishNode(t, "YieldExpression");
    }
    checkPipelineAtInfixOperator(t, e) {
      this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && t.type === "SequenceExpression" && this.raise(l.PipelineHeadSequenceExpression, { at: e });
    }
    parseSmartPipelineBodyInStyle(t, e, s2) {
      let r = this.startNodeAt(e, s2);
      return this.isSimpleReference(t) ? (r.callee = t, this.finishNode(r, "PipelineBareFunction")) : (this.checkSmartPipeTopicBodyEarlyErrors(s2), r.expression = t, this.finishNode(r, "PipelineTopicExpression"));
    }
    isSimpleReference(t) {
      switch (t.type) {
        case "MemberExpression":
          return !t.computed && this.isSimpleReference(t.object);
        case "Identifier":
          return true;
        default:
          return false;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(t) {
      if (this.match(19))
        throw this.raise(l.PipelineBodyNoArrow, { at: this.state.startLoc });
      this.topicReferenceWasUsedInCurrentContext() || this.raise(l.PipelineTopicUnused, { at: t });
    }
    withTopicBindingContext(t) {
      let e = this.state.topicContext;
      this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
      try {
        return t();
      } finally {
        this.state.topicContext = e;
      }
    }
    withSmartMixTopicForbiddingContext(t) {
      if (this.hasPlugin(["pipelineOperator", { proposal: "smart" }])) {
        let e = this.state.topicContext;
        this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
        try {
          return t();
        } finally {
          this.state.topicContext = e;
        }
      } else
        return t();
    }
    withSoloAwaitPermittingContext(t) {
      let e = this.state.soloAwait;
      this.state.soloAwait = true;
      try {
        return t();
      } finally {
        this.state.soloAwait = e;
      }
    }
    allowInAnd(t) {
      let e = this.prodParam.currentFlags();
      if (We2 & ~e) {
        this.prodParam.enter(e | We2);
        try {
          return t();
        } finally {
          this.prodParam.exit();
        }
      }
      return t();
    }
    disallowInAnd(t) {
      let e = this.prodParam.currentFlags();
      if (We2 & e) {
        this.prodParam.enter(e & ~We2);
        try {
          return t();
        } finally {
          this.prodParam.exit();
        }
      }
      return t();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(t) {
      let e = this.state.start, s2 = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      let r = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = true;
      let i2 = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), e, s2, t);
      return this.state.inFSharpPipelineDirectBody = r, i2;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      let t = this.startNode();
      this.next(), this.eat(5);
      let e = this.initializeScopes(true);
      this.enterInitialScopes();
      let s2 = this.startNode();
      try {
        t.body = this.parseProgram(s2, 8, "module");
      } finally {
        e();
      }
      return this.eat(8), this.finishNode(t, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(t) {
    }
  }, cs2 = { kind: "loop" }, qh = { kind: "switch" }, Uh = 0, ps2 = 1, Kr2 = 2, Vr2 = 4, _h = /[\uD800-\uDFFF]/u, fs2 = /in(?:stanceof)?/y;
  function zh(t, e) {
    for (let s2 = 0; s2 < t.length; s2++) {
      let r = t[s2], { type: i2 } = r;
      if (typeof i2 == "number") {
        {
          if (i2 === 134) {
            let { loc: a3, start: n, value: o, end: c } = r, f = n + 1, y = m2(a3.start, 1);
            t.splice(s2, 1, new we2({ type: xe2(27), value: "#", start: n, end: f, startLoc: a3.start, endLoc: y }), new we2({ type: xe2(128), value: o, start: f, end: c, startLoc: y, endLoc: a3.end })), s2++;
            continue;
          }
          if (ut2(i2)) {
            let { loc: a3, start: n, value: o, end: c } = r, f = n + 1, y = m2(a3.start, 1), T2;
            e.charCodeAt(n) === 96 ? T2 = new we2({ type: xe2(22), value: "`", start: n, end: f, startLoc: a3.start, endLoc: y }) : T2 = new we2({ type: xe2(8), value: "}", start: n, end: f, startLoc: a3.start, endLoc: y });
            let v, N, R, z;
            i2 === 24 ? (N = c - 1, R = m2(a3.end, -1), v = o === null ? null : o.slice(1, -1), z = new we2({ type: xe2(22), value: "`", start: N, end: c, startLoc: R, endLoc: a3.end })) : (N = c - 2, R = m2(a3.end, -2), v = o === null ? null : o.slice(1, -2), z = new we2({ type: xe2(23), value: "${", start: N, end: c, startLoc: R, endLoc: a3.end })), t.splice(s2, 1, T2, new we2({ type: xe2(20), value: v, start: f, end: N, startLoc: y, endLoc: R }), z), s2 += 2;
            continue;
          }
        }
        r.type = xe2(i2);
      }
    }
    return t;
  }
  var Kh = class extends jh {
    parseTopLevel(t, e) {
      return t.program = this.parseProgram(e), t.comments = this.state.comments, this.options.tokens && (t.tokens = zh(this.tokens, this.input)), this.finishNode(t, "File");
    }
    parseProgram(t) {
      let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 135, s2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.options.sourceType;
      if (t.sourceType = s2, t.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t, true, true, e), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
        for (let [r, i2] of Array.from(this.scope.undefinedExports))
          this.raise(l.ModuleExportUndefined, { at: i2, localName: r });
      return this.finishNode(t, "Program");
    }
    stmtToDirective(t) {
      let e = t;
      e.type = "Directive", e.value = e.expression, delete e.expression;
      let s2 = e.value, r = s2.value, i2 = this.input.slice(s2.start, s2.end), a3 = s2.value = i2.slice(1, -1);
      return this.addExtra(s2, "raw", i2), this.addExtra(s2, "rawValue", a3), this.addExtra(s2, "expressionValue", r), s2.type = "DirectiveLiteral", e;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      let t = this.startNode();
      return t.value = this.state.value, this.next(), this.finishNode(t, "InterpreterDirective");
    }
    isLet(t) {
      return this.isContextual(99) ? this.isLetKeyword(t) : false;
    }
    isLetKeyword(t) {
      let e = this.nextTokenStart(), s2 = this.codePointAtPos(e);
      if (s2 === 92 || s2 === 91)
        return true;
      if (t)
        return false;
      if (s2 === 123)
        return true;
      if (ge2(s2)) {
        if (fs2.lastIndex = e, fs2.test(this.input)) {
          let r = this.codePointAtPos(fs2.lastIndex);
          if (!ze(r) && r !== 92)
            return false;
        }
        return true;
      }
      return false;
    }
    parseStatement(t, e) {
      return this.match(26) && this.parseDecorators(true), this.parseStatementContent(t, e);
    }
    parseStatementContent(t, e) {
      let s2 = this.state.type, r = this.startNode(), i2;
      switch (this.isLet(t) && (s2 = 74, i2 = "let"), s2) {
        case 60:
          return this.parseBreakContinueStatement(r, true);
        case 63:
          return this.parseBreakContinueStatement(r, false);
        case 64:
          return this.parseDebuggerStatement(r);
        case 90:
          return this.parseDoStatement(r);
        case 91:
          return this.parseForStatement(r);
        case 68:
          if (this.lookaheadCharCode() === 46)
            break;
          return t && (this.state.strict ? this.raise(l.StrictFunction, { at: this.state.startLoc }) : t !== "if" && t !== "label" && this.raise(l.SloppyFunction, { at: this.state.startLoc })), this.parseFunctionStatement(r, false, !t);
        case 80:
          return t && this.unexpected(), this.parseClass(r, true);
        case 69:
          return this.parseIfStatement(r);
        case 70:
          return this.parseReturnStatement(r);
        case 71:
          return this.parseSwitchStatement(r);
        case 72:
          return this.parseThrowStatement(r);
        case 73:
          return this.parseTryStatement(r);
        case 75:
        case 74:
          return i2 = i2 || this.state.value, t && i2 !== "var" && this.raise(l.UnexpectedLexicalDeclaration, { at: this.state.startLoc }), this.parseVarStatement(r, i2);
        case 92:
          return this.parseWhileStatement(r);
        case 76:
          return this.parseWithStatement(r);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(r);
        case 83: {
          let o = this.lookaheadCharCode();
          if (o === 40 || o === 46)
            break;
        }
        case 82: {
          !this.options.allowImportExportEverywhere && !e && this.raise(l.UnexpectedImportExport, { at: this.state.startLoc }), this.next();
          let o;
          return s2 === 83 ? (o = this.parseImport(r), o.type === "ImportDeclaration" && (!o.importKind || o.importKind === "value") && (this.sawUnambiguousESM = true)) : (o = this.parseExport(r), (o.type === "ExportNamedDeclaration" && (!o.exportKind || o.exportKind === "value") || o.type === "ExportAllDeclaration" && (!o.exportKind || o.exportKind === "value") || o.type === "ExportDefaultDeclaration") && (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(r), o;
        }
        default:
          if (this.isAsyncFunction())
            return t && this.raise(l.AsyncFunctionInSingleStatementContext, { at: this.state.startLoc }), this.next(), this.parseFunctionStatement(r, true, !t);
      }
      let a3 = this.state.value, n = this.parseExpression();
      return K(s2) && n.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(r, a3, n, t) : this.parseExpressionStatement(r, n);
    }
    assertModuleNodeAllowed(t) {
      !this.options.allowImportExportEverywhere && !this.inModule && this.raise(l.ImportOutsideModule, { at: t });
    }
    takeDecorators(t) {
      let e = this.state.decoratorStack[this.state.decoratorStack.length - 1];
      e.length && (t.decorators = e, this.resetStartLocationFromNode(t, e[0]), this.state.decoratorStack[this.state.decoratorStack.length - 1] = []);
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(t) {
      let e = this.state.decoratorStack[this.state.decoratorStack.length - 1];
      for (; this.match(26); ) {
        let s2 = this.parseDecorator();
        e.push(s2);
      }
      if (this.match(82))
        t || this.unexpected(), this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(l.DecoratorExportClass, { at: this.state.startLoc });
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(l.UnexpectedLeadingDecorator, { at: this.state.startLoc });
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators-legacy", "decorators"]);
      let t = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        this.state.decoratorStack.push([]);
        let e = this.state.start, s2 = this.state.startLoc, r;
        if (this.match(10)) {
          let i2 = this.state.start, a3 = this.state.startLoc;
          this.next(), r = this.parseExpression(), this.expect(11), r = this.wrapParenthesis(i2, a3, r);
        } else
          for (r = this.parseIdentifier(false); this.eat(16); ) {
            let i2 = this.startNodeAt(e, s2);
            i2.object = r, i2.property = this.parseIdentifier(true), i2.computed = false, r = this.finishNode(i2, "MemberExpression");
          }
        t.expression = this.parseMaybeDecoratorArguments(r), this.state.decoratorStack.pop();
      } else
        t.expression = this.parseExprSubscripts();
      return this.finishNode(t, "Decorator");
    }
    parseMaybeDecoratorArguments(t) {
      if (this.eat(10)) {
        let e = this.startNodeAtNode(t);
        return e.callee = t, e.arguments = this.parseCallExpressionArguments(11, false), this.toReferencedList(e.arguments), this.finishNode(e, "CallExpression");
      }
      return t;
    }
    parseBreakContinueStatement(t, e) {
      return this.next(), this.isLineTerminator() ? t.label = null : (t.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(t, e), this.finishNode(t, e ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(t, e) {
      let s2;
      for (s2 = 0; s2 < this.state.labels.length; ++s2) {
        let r = this.state.labels[s2];
        if ((t.label == null || r.name === t.label.name) && (r.kind != null && (e || r.kind === "loop") || t.label && e))
          break;
      }
      if (s2 === this.state.labels.length) {
        let r = e ? "BreakStatement" : "ContinueStatement";
        this.raise(l.IllegalBreakContinue, { at: t, type: r });
      }
    }
    parseDebuggerStatement(t) {
      return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      let t = this.parseExpression();
      return this.expect(11), t;
    }
    parseDoStatement(t) {
      return this.next(), this.state.labels.push(cs2), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("do")), this.state.labels.pop(), this.expect(92), t.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(t, "DoWhileStatement");
    }
    parseForStatement(t) {
      this.next(), this.state.labels.push(cs2);
      let e = null;
      if (this.isAwaitAllowed() && this.eatContextual(96) && (e = this.state.lastTokStartLoc), this.scope.enter(Ke2), this.expect(10), this.match(13))
        return e !== null && this.unexpected(e), this.parseFor(t, null);
      let s2 = this.isContextual(99), r = s2 && this.isLetKeyword();
      if (this.match(74) || this.match(75) || r) {
        let c = this.startNode(), f = r ? "let" : this.state.value;
        return this.next(), this.parseVar(c, true, f), this.finishNode(c, "VariableDeclaration"), (this.match(58) || this.isContextual(101)) && c.declarations.length === 1 ? this.parseForIn(t, c, e) : (e !== null && this.unexpected(e), this.parseFor(t, c));
      }
      let i2 = this.isContextual(95), a3 = new bt2(), n = this.parseExpression(true, a3), o = this.isContextual(101);
      if (o && (s2 && this.raise(l.ForOfLet, { at: n }), e === null && i2 && n.type === "Identifier" && this.raise(l.ForOfAsync, { at: n })), o || this.match(58)) {
        this.checkDestructuringPrivate(a3), this.toAssignable(n, true);
        let c = o ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(n, { in: { type: c } }), this.parseForIn(t, n, e);
      } else
        this.checkExpressionErrors(a3, true);
      return e !== null && this.unexpected(e), this.parseFor(t, n);
    }
    parseFunctionStatement(t, e, s2) {
      return this.next(), this.parseFunction(t, ps2 | (s2 ? 0 : Kr2), e);
    }
    parseIfStatement(t) {
      return this.next(), t.test = this.parseHeaderExpression(), t.consequent = this.parseStatement("if"), t.alternate = this.eat(66) ? this.parseStatement("if") : null, this.finishNode(t, "IfStatement");
    }
    parseReturnStatement(t) {
      return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(l.IllegalReturn, { at: this.state.startLoc }), this.next(), this.isLineTerminator() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement");
    }
    parseSwitchStatement(t) {
      this.next(), t.discriminant = this.parseHeaderExpression();
      let e = t.cases = [];
      this.expect(5), this.state.labels.push(qh), this.scope.enter(Ke2);
      let s2;
      for (let r; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          let i2 = this.match(61);
          s2 && this.finishNode(s2, "SwitchCase"), e.push(s2 = this.startNode()), s2.consequent = [], this.next(), i2 ? s2.test = this.parseExpression() : (r && this.raise(l.MultipleDefaultsInSwitch, { at: this.state.lastTokStartLoc }), r = true, s2.test = null), this.expect(14);
        } else
          s2 ? s2.consequent.push(this.parseStatement(null)) : this.unexpected();
      return this.scope.exit(), s2 && this.finishNode(s2, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t, "SwitchStatement");
    }
    parseThrowStatement(t) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(l.NewlineAfterThrow, { at: this.state.lastTokEndLoc }), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, "ThrowStatement");
    }
    parseCatchClauseParam() {
      let t = this.parseBindingAtom(), e = t.type === "Identifier";
      return this.scope.enter(e ? dr2 : 0), this.checkLVal(t, { in: { type: "CatchClause" }, binding: Te2, allowingSloppyLetBinding: true }), t;
    }
    parseTryStatement(t) {
      if (this.next(), t.block = this.parseBlock(), t.handler = null, this.match(62)) {
        let e = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), e.param = this.parseCatchClauseParam(), this.expect(11)) : (e.param = null, this.scope.enter(Ke2)), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), t.handler = this.finishNode(e, "CatchClause");
      }
      return t.finalizer = this.eat(67) ? this.parseBlock() : null, !t.handler && !t.finalizer && this.raise(l.NoCatchOrFinally, { at: t }), this.finishNode(t, "TryStatement");
    }
    parseVarStatement(t, e) {
      let s2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      return this.next(), this.parseVar(t, false, e, s2), this.semicolon(), this.finishNode(t, "VariableDeclaration");
    }
    parseWhileStatement(t) {
      return this.next(), t.test = this.parseHeaderExpression(), this.state.labels.push(cs2), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("while")), this.state.labels.pop(), this.finishNode(t, "WhileStatement");
    }
    parseWithStatement(t) {
      return this.state.strict && this.raise(l.StrictWith, { at: this.state.startLoc }), this.next(), t.object = this.parseHeaderExpression(), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("with")), this.finishNode(t, "WithStatement");
    }
    parseEmptyStatement(t) {
      return this.next(), this.finishNode(t, "EmptyStatement");
    }
    parseLabeledStatement(t, e, s2, r) {
      for (let a3 of this.state.labels)
        a3.name === e && this.raise(l.LabelRedeclaration, { at: s2, labelName: e });
      let i2 = yo2(this.state.type) ? "loop" : this.match(71) ? "switch" : null;
      for (let a3 = this.state.labels.length - 1; a3 >= 0; a3--) {
        let n = this.state.labels[a3];
        if (n.statementStart === t.start)
          n.statementStart = this.state.start, n.kind = i2;
        else
          break;
      }
      return this.state.labels.push({ name: e, kind: i2, statementStart: this.state.start }), t.body = this.parseStatement(r ? r.indexOf("label") === -1 ? r + "label" : r : "label"), this.state.labels.pop(), t.label = s2, this.finishNode(t, "LabeledStatement");
    }
    parseExpressionStatement(t, e) {
      return t.expression = e, this.semicolon(), this.finishNode(t, "ExpressionStatement");
    }
    parseBlock() {
      let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, s2 = arguments.length > 2 ? arguments[2] : void 0, r = this.startNode();
      return t && this.state.strictErrors.clear(), this.expect(5), e && this.scope.enter(Ke2), this.parseBlockBody(r, t, false, 8, s2), e && this.scope.exit(), this.finishNode(r, "BlockStatement");
    }
    isValidDirective(t) {
      return t.type === "ExpressionStatement" && t.expression.type === "StringLiteral" && !t.expression.extra.parenthesized;
    }
    parseBlockBody(t, e, s2, r, i2) {
      let a3 = t.body = [], n = t.directives = [];
      this.parseBlockOrModuleBlockBody(a3, e ? n : void 0, s2, r, i2);
    }
    parseBlockOrModuleBlockBody(t, e, s2, r, i2) {
      let a3 = this.state.strict, n = false, o = false;
      for (; !this.match(r); ) {
        let c = this.parseStatement(null, s2);
        if (e && !o) {
          if (this.isValidDirective(c)) {
            let f = this.stmtToDirective(c);
            e.push(f), !n && f.value.value === "use strict" && (n = true, this.setStrict(true));
            continue;
          }
          o = true, this.state.strictErrors.clear();
        }
        t.push(c);
      }
      i2 && i2.call(this, n), a3 || this.setStrict(false), this.next();
    }
    parseFor(t, e) {
      return t.init = e, this.semicolon(false), t.test = this.match(13) ? null : this.parseExpression(), this.semicolon(false), t.update = this.match(11) ? null : this.parseExpression(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, "ForStatement");
    }
    parseForIn(t, e, s2) {
      let r = this.match(58);
      return this.next(), r ? s2 !== null && this.unexpected(s2) : t.await = s2 !== null, e.type === "VariableDeclaration" && e.declarations[0].init != null && (!r || this.state.strict || e.kind !== "var" || e.declarations[0].id.type !== "Identifier") && this.raise(l.ForInOfLoopInitializer, { at: e, type: r ? "ForInStatement" : "ForOfStatement" }), e.type === "AssignmentPattern" && this.raise(l.InvalidLhs, { at: e, ancestor: { type: "ForStatement" } }), t.left = e, t.right = r ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, r ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(t, e, s2) {
      let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, i2 = t.declarations = [];
      for (t.kind = s2; ; ) {
        let a3 = this.startNode();
        if (this.parseVarId(a3, s2), a3.init = this.eat(29) ? e ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, a3.init === null && !r && (a3.id.type !== "Identifier" && !(e && (this.match(58) || this.isContextual(101))) ? this.raise(l.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: "destructuring" }) : s2 === "const" && !(this.match(58) || this.isContextual(101)) && this.raise(l.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: "const" })), i2.push(this.finishNode(a3, "VariableDeclarator")), !this.eat(12))
          break;
      }
      return t;
    }
    parseVarId(t, e) {
      t.id = this.parseBindingAtom(), this.checkLVal(t.id, { in: { type: "VariableDeclarator" }, binding: e === "var" ? yt2 : Te2 });
    }
    parseFunction(t) {
      let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Uh, s2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, r = e & ps2, i2 = e & Kr2, a3 = !!r && !(e & Vr2);
      this.initFunction(t, s2), this.match(55) && i2 && this.raise(l.GeneratorInSingleStatementContext, { at: this.state.startLoc }), t.generator = this.eat(55), r && (t.id = this.parseFunctionId(a3));
      let n = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = false, this.scope.enter(Ae2), this.prodParam.enter(Et2(s2, t.generator)), r || (t.id = this.parseFunctionId()), this.parseFunctionParams(t, false), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(t, r ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), r && !i2 && this.registerFunctionStatementId(t), this.state.maybeInArrowParameters = n, t;
    }
    parseFunctionId(t) {
      return t || K(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(t, e) {
      this.expect(10), this.expressionScope.enter(nh()), t.params = this.parseBindingList(11, 41, false, e), this.expressionScope.exit();
    }
    registerFunctionStatementId(t) {
      !t.id || this.scope.declareName(t.id.name, this.state.strict || t.generator || t.async ? this.scope.treatFunctionsAsVar ? yt2 : Te2 : Ar2, t.id.loc.start);
    }
    parseClass(t, e, s2) {
      this.next(), this.takeDecorators(t);
      let r = this.state.strict;
      return this.state.strict = true, this.parseClassId(t, e, s2), this.parseClassSuper(t), t.body = this.parseClassBody(!!t.superClass, r), this.finishNode(t, e ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    isNonstaticConstructor(t) {
      return !t.computed && !t.static && (t.key.name === "constructor" || t.key.value === "constructor");
    }
    parseClassBody(t, e) {
      this.classScope.enter();
      let s2 = { hadConstructor: false, hadSuperClass: t }, r = [], i2 = this.startNode();
      if (i2.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (r.length > 0)
              throw this.raise(l.DecoratorSemicolon, { at: this.state.lastTokEndLoc });
            continue;
          }
          if (this.match(26)) {
            r.push(this.parseDecorator());
            continue;
          }
          let a3 = this.startNode();
          r.length && (a3.decorators = r, this.resetStartLocationFromNode(a3, r[0]), r = []), this.parseClassMember(i2, a3, s2), a3.kind === "constructor" && a3.decorators && a3.decorators.length > 0 && this.raise(l.DecoratorConstructor, { at: a3 });
        }
      }), this.state.strict = e, this.next(), r.length)
        throw this.raise(l.TrailingDecorator, { at: this.state.startLoc });
      return this.classScope.exit(), this.finishNode(i2, "ClassBody");
    }
    parseClassMemberFromModifier(t, e) {
      let s2 = this.parseIdentifier(true);
      if (this.isClassMethod()) {
        let r = e;
        return r.kind = "method", r.computed = false, r.key = s2, r.static = false, this.pushClassMethod(t, r, false, false, false, false), true;
      } else if (this.isClassProperty()) {
        let r = e;
        return r.computed = false, r.key = s2, r.static = false, t.body.push(this.parseClassProperty(r)), true;
      }
      return this.resetPreviousNodeTrailingComments(s2), false;
    }
    parseClassMember(t, e, s2) {
      let r = this.isContextual(104);
      if (r) {
        if (this.parseClassMemberFromModifier(t, e))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(t, e);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(t, e, s2, r);
    }
    parseClassMemberWithIsStatic(t, e, s2, r) {
      let i2 = e, a3 = e, n = e, o = e, c = e, f = i2, y = i2;
      if (e.static = r, this.parsePropertyNamePrefixOperator(e), this.eat(55)) {
        f.kind = "method";
        let z = this.match(134);
        if (this.parseClassElementName(f), z) {
          this.pushClassPrivateMethod(t, a3, true, false);
          return;
        }
        this.isNonstaticConstructor(i2) && this.raise(l.ConstructorIsGenerator, { at: i2.key }), this.pushClassMethod(t, i2, true, false, false, false);
        return;
      }
      let T2 = K(this.state.type) && !this.state.containsEsc, v = this.match(134), N = this.parseClassElementName(e), R = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(y), this.isClassMethod()) {
        if (f.kind = "method", v) {
          this.pushClassPrivateMethod(t, a3, false, false);
          return;
        }
        let z = this.isNonstaticConstructor(i2), te2 = false;
        z && (i2.kind = "constructor", s2.hadConstructor && !this.hasPlugin("typescript") && this.raise(l.DuplicateConstructor, { at: N }), z && this.hasPlugin("typescript") && e.override && this.raise(l.OverrideOnConstructor, { at: N }), s2.hadConstructor = true, te2 = s2.hadSuperClass), this.pushClassMethod(t, i2, false, false, z, te2);
      } else if (this.isClassProperty())
        v ? this.pushClassPrivateProperty(t, o) : this.pushClassProperty(t, n);
      else if (T2 && N.name === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(N);
        let z = this.eat(55);
        y.optional && this.unexpected(R), f.kind = "method";
        let te2 = this.match(134);
        this.parseClassElementName(f), this.parsePostMemberNameModifiers(y), te2 ? this.pushClassPrivateMethod(t, a3, z, true) : (this.isNonstaticConstructor(i2) && this.raise(l.ConstructorIsAsync, { at: i2.key }), this.pushClassMethod(t, i2, z, true, false, false));
      } else if (T2 && (N.name === "get" || N.name === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(N), f.kind = N.name;
        let z = this.match(134);
        this.parseClassElementName(i2), z ? this.pushClassPrivateMethod(t, a3, false, false) : (this.isNonstaticConstructor(i2) && this.raise(l.ConstructorIsAccessor, { at: i2.key }), this.pushClassMethod(t, i2, false, false, false, false)), this.checkGetterSetterParams(i2);
      } else if (T2 && N.name === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(N);
        let z = this.match(134);
        this.parseClassElementName(n), this.pushClassAccessorProperty(t, c, z);
      } else
        this.isLineTerminator() ? v ? this.pushClassPrivateProperty(t, o) : this.pushClassProperty(t, n) : this.unexpected();
    }
    parseClassElementName(t) {
      let { type: e, value: s2 } = this.state;
      if ((e === 128 || e === 129) && t.static && s2 === "prototype" && this.raise(l.StaticPrototype, { at: this.state.startLoc }), e === 134) {
        s2 === "constructor" && this.raise(l.ConstructorClassPrivateField, { at: this.state.startLoc });
        let r = this.parsePrivateName();
        return t.key = r, r;
      }
      return this.parsePropertyName(t);
    }
    parseClassStaticBlock(t, e) {
      var s2;
      this.scope.enter(Fe2 | Jt2 | ct2);
      let r = this.state.labels;
      this.state.labels = [], this.prodParam.enter(He2);
      let i2 = e.body = [];
      this.parseBlockOrModuleBlockBody(i2, void 0, false, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = r, t.body.push(this.finishNode(e, "StaticBlock")), (s2 = e.decorators) != null && s2.length && this.raise(l.DecoratorStaticBlock, { at: e });
    }
    pushClassProperty(t, e) {
      !e.computed && (e.key.name === "constructor" || e.key.value === "constructor") && this.raise(l.ConstructorClassField, { at: e.key }), t.body.push(this.parseClassProperty(e));
    }
    pushClassPrivateProperty(t, e) {
      let s2 = this.parseClassPrivateProperty(e);
      t.body.push(s2), this.classScope.declarePrivateName(this.getPrivateNameSV(s2.key), rs2, s2.key.loc.start);
    }
    pushClassAccessorProperty(t, e, s2) {
      if (!s2 && !e.computed) {
        let i2 = e.key;
        (i2.name === "constructor" || i2.value === "constructor") && this.raise(l.ConstructorClassField, { at: i2 });
      }
      let r = this.parseClassAccessorProperty(e);
      t.body.push(r), s2 && this.classScope.declarePrivateName(this.getPrivateNameSV(r.key), rs2, r.key.loc.start);
    }
    pushClassMethod(t, e, s2, r, i2, a3) {
      t.body.push(this.parseMethod(e, s2, r, i2, a3, "ClassMethod", true));
    }
    pushClassPrivateMethod(t, e, s2, r) {
      let i2 = this.parseMethod(e, s2, r, false, false, "ClassPrivateMethod", true);
      t.body.push(i2);
      let a3 = i2.kind === "get" ? i2.static ? Uo2 : zo2 : i2.kind === "set" ? i2.static ? _o2 : Ko : rs2;
      this.declareClassPrivateMethodInScope(i2, a3);
    }
    declareClassPrivateMethodInScope(t, e) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(t.key), e, t.key.loc.start);
    }
    parsePostMemberNameModifiers(t) {
    }
    parseClassPrivateProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassPrivateProperty");
    }
    parseClassProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassProperty");
    }
    parseClassAccessorProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassAccessorProperty");
    }
    parseInitializer(t) {
      this.scope.enter(Fe2 | ct2), this.expressionScope.enter(Ir2()), this.prodParam.enter(He2), t.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(t, e, s2) {
      let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : gr2;
      if (K(this.state.type))
        t.id = this.parseIdentifier(), e && this.declareNameFromIdentifier(t.id, r);
      else if (s2 || !e)
        t.id = null;
      else
        throw this.raise(l.MissingClassName, { at: this.state.startLoc });
    }
    parseClassSuper(t) {
      t.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(t) {
      let e = this.maybeParseExportDefaultSpecifier(t), s2 = !e || this.eat(12), r = s2 && this.eatExportStar(t), i2 = r && this.maybeParseExportNamespaceSpecifier(t), a3 = s2 && (!i2 || this.eat(12)), n = e || r;
      if (r && !i2)
        return e && this.unexpected(), this.parseExportFrom(t, true), this.finishNode(t, "ExportAllDeclaration");
      let o = this.maybeParseExportNamedSpecifiers(t);
      if (e && s2 && !r && !o || i2 && a3 && !o)
        throw this.unexpected(null, 5);
      let c;
      if (n || o ? (c = false, this.parseExportFrom(t, n)) : c = this.maybeParseExportDeclaration(t), n || o || c)
        return this.checkExport(t, true, false, !!t.source), this.finishNode(t, "ExportNamedDeclaration");
      if (this.eat(65))
        return t.declaration = this.parseExportDefaultExpression(), this.checkExport(t, true, true), this.finishNode(t, "ExportDefaultDeclaration");
      throw this.unexpected(null, 5);
    }
    eatExportStar(t) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(t) {
      if (this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom");
        let e = this.startNode();
        return e.exported = this.parseIdentifier(true), t.specifiers = [this.finishNode(e, "ExportDefaultSpecifier")], true;
      }
      return false;
    }
    maybeParseExportNamespaceSpecifier(t) {
      if (this.isContextual(93)) {
        t.specifiers || (t.specifiers = []);
        let e = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
        return this.next(), e.exported = this.parseModuleExportName(), t.specifiers.push(this.finishNode(e, "ExportNamespaceSpecifier")), true;
      }
      return false;
    }
    maybeParseExportNamedSpecifiers(t) {
      if (this.match(5)) {
        t.specifiers || (t.specifiers = []);
        let e = t.exportKind === "type";
        return t.specifiers.push(...this.parseExportSpecifiers(e)), t.source = null, t.declaration = null, this.hasPlugin("importAssertions") && (t.assertions = []), true;
      }
      return false;
    }
    maybeParseExportDeclaration(t) {
      return this.shouldParseExportDeclaration() ? (t.specifiers = [], t.source = null, this.hasPlugin("importAssertions") && (t.assertions = []), t.declaration = this.parseExportDeclaration(t), true) : false;
    }
    isAsyncFunction() {
      if (!this.isContextual(95))
        return false;
      let t = this.nextTokenStart();
      return !is2.test(this.input.slice(this.state.pos, t)) && this.isUnparsedContextual(t, "function");
    }
    parseExportDefaultExpression() {
      let t = this.startNode(), e = this.isAsyncFunction();
      if (this.match(68) || e)
        return this.next(), e && this.next(), this.parseFunction(t, ps2 | Vr2, e);
      if (this.match(80))
        return this.parseClass(t, true, true);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(l.DecoratorBeforeExport, { at: this.state.startLoc }), this.parseDecorators(false), this.parseClass(t, true, true);
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(l.UnsupportedDefaultExport, { at: this.state.startLoc });
      let s2 = this.parseMaybeAssignAllowIn();
      return this.semicolon(), s2;
    }
    parseExportDeclaration(t) {
      return this.parseStatement(null);
    }
    isExportDefaultSpecifier() {
      let { type: t } = this.state;
      if (K(t)) {
        if (t === 95 && !this.state.containsEsc || t === 99)
          return false;
        if ((t === 126 || t === 125) && !this.state.containsEsc) {
          let { type: r } = this.lookahead();
          if (K(r) && r !== 97 || r === 5)
            return this.expectOnePlugin(["flow", "typescript"]), false;
        }
      } else if (!this.match(65))
        return false;
      let e = this.nextTokenStart(), s2 = this.isUnparsedContextual(e, "from");
      if (this.input.charCodeAt(e) === 44 || K(this.state.type) && s2)
        return true;
      if (this.match(65) && s2) {
        let r = this.input.charCodeAt(this.nextTokenStartSince(e + 4));
        return r === 34 || r === 39;
      }
      return false;
    }
    parseExportFrom(t, e) {
      if (this.eatContextual(97)) {
        t.source = this.parseImportSource(), this.checkExport(t);
        let s2 = this.maybeParseImportAssertions();
        s2 && (t.assertions = s2);
      } else
        e && this.unexpected();
      this.semicolon();
    }
    shouldParseExportDeclaration() {
      let { type: t } = this.state;
      if (t === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators"))) {
        if (this.getPluginOption("decorators", "decoratorsBeforeExport"))
          throw this.raise(l.DecoratorBeforeExport, { at: this.state.startLoc });
        return true;
      }
      return t === 74 || t === 75 || t === 68 || t === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(t, e, s2, r) {
      if (e) {
        if (s2) {
          if (this.checkDuplicateExports(t, "default"), this.hasPlugin("exportDefaultFrom")) {
            var i2;
            let n = t.declaration;
            n.type === "Identifier" && n.name === "from" && n.end - n.start === 4 && !((i2 = n.extra) != null && i2.parenthesized) && this.raise(l.ExportDefaultFromAsIdentifier, { at: n });
          }
        } else if (t.specifiers && t.specifiers.length)
          for (let n of t.specifiers) {
            let { exported: o } = n, c = o.type === "Identifier" ? o.name : o.value;
            if (this.checkDuplicateExports(n, c), !r && n.local) {
              let { local: f } = n;
              f.type !== "Identifier" ? this.raise(l.ExportBindingIsString, { at: n, localName: f.value, exportName: c }) : (this.checkReservedWord(f.name, f.loc.start, true, false), this.scope.checkLocalExport(f));
            }
          }
        else if (t.declaration) {
          if (t.declaration.type === "FunctionDeclaration" || t.declaration.type === "ClassDeclaration") {
            let n = t.declaration.id;
            if (!n)
              throw new Error("Assertion failure");
            this.checkDuplicateExports(t, n.name);
          } else if (t.declaration.type === "VariableDeclaration")
            for (let n of t.declaration.declarations)
              this.checkDeclaration(n.id);
        }
      }
      if (this.state.decoratorStack[this.state.decoratorStack.length - 1].length)
        throw this.raise(l.UnsupportedDecoratorExport, { at: t });
    }
    checkDeclaration(t) {
      if (t.type === "Identifier")
        this.checkDuplicateExports(t, t.name);
      else if (t.type === "ObjectPattern")
        for (let e of t.properties)
          this.checkDeclaration(e);
      else if (t.type === "ArrayPattern")
        for (let e of t.elements)
          e && this.checkDeclaration(e);
      else
        t.type === "ObjectProperty" ? this.checkDeclaration(t.value) : t.type === "RestElement" ? this.checkDeclaration(t.argument) : t.type === "AssignmentPattern" && this.checkDeclaration(t.left);
    }
    checkDuplicateExports(t, e) {
      this.exportedIdentifiers.has(e) && (e === "default" ? this.raise(l.DuplicateDefaultExport, { at: t }) : this.raise(l.DuplicateExport, { at: t, exportName: e })), this.exportedIdentifiers.add(e);
    }
    parseExportSpecifiers(t) {
      let e = [], s2 = true;
      for (this.expect(5); !this.eat(8); ) {
        if (s2)
          s2 = false;
        else if (this.expect(12), this.eat(8))
          break;
        let r = this.isContextual(126), i2 = this.match(129), a3 = this.startNode();
        a3.local = this.parseModuleExportName(), e.push(this.parseExportSpecifier(a3, i2, t, r));
      }
      return e;
    }
    parseExportSpecifier(t, e, s2, r) {
      return this.eatContextual(93) ? t.exported = this.parseModuleExportName() : e ? t.exported = ph(t.local) : t.exported || (t.exported = Ee(t.local)), this.finishNode(t, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(129)) {
        let t = this.parseStringLiteral(this.state.value), e = t.value.match(_h);
        return e && this.raise(l.ModuleExportNameHasLoneSurrogate, { at: t, surrogateCharCode: e[0].charCodeAt(0) }), t;
      }
      return this.parseIdentifier(true);
    }
    parseImport(t) {
      if (t.specifiers = [], !this.match(129)) {
        let r = !this.maybeParseDefaultImportSpecifier(t) || this.eat(12), i2 = r && this.maybeParseStarImportSpecifier(t);
        r && !i2 && this.parseNamedImportSpecifiers(t), this.expectContextual(97);
      }
      t.source = this.parseImportSource();
      let e = this.maybeParseImportAssertions();
      if (e)
        t.assertions = e;
      else {
        let s2 = this.maybeParseModuleAttributes();
        s2 && (t.attributes = s2);
      }
      return this.semicolon(), this.finishNode(t, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(129) || this.unexpected(), this.parseExprAtom();
    }
    shouldParseDefaultImport(t) {
      return K(this.state.type);
    }
    parseImportSpecifierLocal(t, e, s2) {
      e.local = this.parseIdentifier(), t.specifiers.push(this.finishImportSpecifier(e, s2));
    }
    finishImportSpecifier(t, e) {
      return this.checkLVal(t.local, { in: t, binding: Te2 }), this.finishNode(t, e);
    }
    parseAssertEntries() {
      let t = [], e = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        let s2 = this.startNode(), r = this.state.value;
        if (e.has(r) && this.raise(l.ModuleAttributesWithDuplicateKeys, { at: this.state.startLoc, key: r }), e.add(r), this.match(129) ? s2.key = this.parseStringLiteral(r) : s2.key = this.parseIdentifier(true), this.expect(14), !this.match(129))
          throw this.raise(l.ModuleAttributeInvalidValue, { at: this.state.startLoc });
        s2.value = this.parseStringLiteral(this.state.value), this.finishNode(s2, "ImportAttribute"), t.push(s2);
      } while (this.eat(12));
      return t;
    }
    maybeParseModuleAttributes() {
      if (this.match(76) && !this.hasPrecedingLineBreak())
        this.expectPlugin("moduleAttributes"), this.next();
      else
        return this.hasPlugin("moduleAttributes") ? [] : null;
      let t = [], e = /* @__PURE__ */ new Set();
      do {
        let s2 = this.startNode();
        if (s2.key = this.parseIdentifier(true), s2.key.name !== "type" && this.raise(l.ModuleAttributeDifferentFromType, { at: s2.key }), e.has(s2.key.name) && this.raise(l.ModuleAttributesWithDuplicateKeys, { at: s2.key, key: s2.key.name }), e.add(s2.key.name), this.expect(14), !this.match(129))
          throw this.raise(l.ModuleAttributeInvalidValue, { at: this.state.startLoc });
        s2.value = this.parseStringLiteral(this.state.value), this.finishNode(s2, "ImportAttribute"), t.push(s2);
      } while (this.eat(12));
      return t;
    }
    maybeParseImportAssertions() {
      if (this.isContextual(94) && !this.hasPrecedingLineBreak())
        this.expectPlugin("importAssertions"), this.next();
      else
        return this.hasPlugin("importAssertions") ? [] : null;
      this.eat(5);
      let t = this.parseAssertEntries();
      return this.eat(8), t;
    }
    maybeParseDefaultImportSpecifier(t) {
      return this.shouldParseDefaultImport(t) ? (this.parseImportSpecifierLocal(t, this.startNode(), "ImportDefaultSpecifier"), true) : false;
    }
    maybeParseStarImportSpecifier(t) {
      if (this.match(55)) {
        let e = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(t, e, "ImportNamespaceSpecifier"), true;
      }
      return false;
    }
    parseNamedImportSpecifiers(t) {
      let e = true;
      for (this.expect(5); !this.eat(8); ) {
        if (e)
          e = false;
        else {
          if (this.eat(14))
            throw this.raise(l.DestructureNamedImport, { at: this.state.startLoc });
          if (this.expect(12), this.eat(8))
            break;
        }
        let s2 = this.startNode(), r = this.match(129), i2 = this.isContextual(126);
        s2.imported = this.parseModuleExportName();
        let a3 = this.parseImportSpecifier(s2, r, t.importKind === "type" || t.importKind === "typeof", i2);
        t.specifiers.push(a3);
      }
    }
    parseImportSpecifier(t, e, s2, r) {
      if (this.eatContextual(93))
        t.local = this.parseIdentifier();
      else {
        let { imported: i2 } = t;
        if (e)
          throw this.raise(l.ImportBindingIsString, { at: t, importName: i2.value });
        this.checkReservedWord(i2.name, t.loc.start, true, true), t.local || (t.local = Ee(i2));
      }
      return this.finishImportSpecifier(t, "ImportSpecifier");
    }
    isThisParam(t) {
      return t.type === "Identifier" && t.name === "this";
    }
  }, Hr2 = class extends Kh {
    constructor(t, e) {
      t = Bh(t), super(t, e), this.options = t, this.initializeScopes(), this.plugins = Vh(this.options.plugins), this.filename = t.sourceFilename;
    }
    getScopeHandler() {
      return os2;
    }
    parse() {
      this.enterInitialScopes();
      let t = this.startNode(), e = this.startNode();
      return this.nextToken(), t.errors = null, this.parseTopLevel(t, e), t.errors = this.state.errors, t;
    }
  };
  function Vh(t) {
    let e = /* @__PURE__ */ new Map();
    for (let s2 of t) {
      let [r, i2] = Array.isArray(s2) ? s2 : [s2, {}];
      e.has(r) || e.set(r, i2 || {});
    }
    return e;
  }
  function Hh(t, e) {
    var s2;
    if (((s2 = e) == null ? void 0 : s2.sourceType) === "unambiguous") {
      e = Object.assign({}, e);
      try {
        e.sourceType = "module";
        let r = tt(e, t), i2 = r.parse();
        if (r.sawUnambiguousESM)
          return i2;
        if (r.ambiguousScriptDifferentAst)
          try {
            return e.sourceType = "script", tt(e, t).parse();
          } catch {
          }
        else
          i2.program.sourceType = "script";
        return i2;
      } catch (r) {
        try {
          return e.sourceType = "script", tt(e, t).parse();
        } catch {
        }
        throw r;
      }
    } else
      return tt(e, t).parse();
  }
  function Wh(t, e) {
    let s2 = tt(e, t);
    return s2.options.strictMode && (s2.state.strict = true), s2.getExpression();
  }
  function Gh(t) {
    let e = {};
    for (let s2 of Object.keys(t))
      e[s2] = xe2(t[s2]);
    return e;
  }
  var Xh = Gh(co2);
  function tt(t, e) {
    let s2 = Hr2;
    return t != null && t.plugins && (Lh(t.plugins), s2 = Jh(t.plugins)), new s2(t, e);
  }
  var Wr2 = {};
  function Jh(t) {
    let e = Oh.filter((i2) => se(t, i2)), s2 = e.join("/"), r = Wr2[s2];
    if (!r) {
      r = Hr2;
      for (let i2 of e)
        r = Ur2[i2](r);
      Wr2[s2] = r;
    }
    return r;
  }
  h2.parse = Hh, h2.parseExpression = Wh, h2.tokTypes = Xh;
} }), hf$1 = W({ "src/language-js/parse/json.js"(h2, u) {
  H();
  var p = io$1(), d4 = ar(), m2 = no$1(), x2 = oo$1();
  function A2() {
    let C2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, { allowComments: M2 = true } = C2;
    return function(k2) {
      let { parseExpression: G } = uo$1(), Z3;
      try {
        Z3 = G(k2, { tokens: true, ranges: true });
      } catch (B) {
        throw x2(B);
      }
      if (!M2 && p(Z3.comments))
        throw g2(Z3.comments[0], "Comment");
      return E(Z3), Z3;
    };
  }
  function g2(C2, M2) {
    let [L, k2] = [C2.loc.start, C2.loc.end].map((G) => {
      let { line: Z3, column: B } = G;
      return { line: Z3, column: B + 1 };
    });
    return d4("".concat(M2, " is not allowed in JSON."), { start: L, end: k2 });
  }
  function E(C2) {
    switch (C2.type) {
      case "ArrayExpression":
        for (let M2 of C2.elements)
          M2 !== null && E(M2);
        return;
      case "ObjectExpression":
        for (let M2 of C2.properties)
          E(M2);
        return;
      case "ObjectProperty":
        if (C2.computed)
          throw g2(C2.key, "Computed key");
        if (C2.shorthand)
          throw g2(C2.key, "Shorthand property");
        C2.key.type !== "Identifier" && E(C2.key), E(C2.value);
        return;
      case "UnaryExpression": {
        let { operator: M2, argument: L } = C2;
        if (M2 !== "+" && M2 !== "-")
          throw g2(C2, "Operator '".concat(C2.operator, "'"));
        if (L.type === "NumericLiteral" || L.type === "Identifier" && (L.name === "Infinity" || L.name === "NaN"))
          return;
        throw g2(L, "Operator '".concat(M2, "' before '").concat(L.type, "'"));
      }
      case "Identifier":
        if (C2.name !== "Infinity" && C2.name !== "NaN" && C2.name !== "undefined")
          throw g2(C2, "Identifier '".concat(C2.name, "'"));
        return;
      case "TemplateLiteral":
        if (p(C2.expressions))
          throw g2(C2.expressions[0], "'TemplateLiteral' with expression");
        for (let M2 of C2.quasis)
          E(M2);
        return;
      case "NullLiteral":
      case "BooleanLiteral":
      case "NumericLiteral":
      case "StringLiteral":
      case "TemplateElement":
        return;
      default:
        throw g2(C2, "'".concat(C2.type, "'"));
    }
  }
  var F = A2(), D2 = { json: m2({ parse: F, hasPragma() {
    return true;
  } }), json5: m2(F), "json-stringify": m2({ parse: A2({ allowComments: false }), astFormat: "estree-json" }) };
  u.exports = D2;
} }), lf$1 = W({ "src/language-js/parse/babel.js"(h2, u) {
  H();
  var p = zp(), d4 = Kn$1(), m2 = Wp(), x2 = no$1(), A2 = oo$1(), g2 = of$1(), E = hf$1(), F = { sourceType: "module", allowImportExportEverywhere: true, allowReturnOutsideFunction: true, allowSuperOutsideMethod: true, allowUndeclaredExports: true, errorRecovery: true, createParenthesizedExpressions: true, plugins: ["doExpressions", "exportDefaultFrom", "functionBind", "functionSent", "throwExpressions", "partialApplication", ["decorators", { decoratorsBeforeExport: false }], "importAssertions", "decimal", "moduleBlocks", "asyncDoExpressions", "regexpUnicodeSets", "destructuringPrivate", "decoratorAutoAccessors"], tokens: true, ranges: true }, D2 = ["recordAndTuple", { syntaxType: "hash" }], C2 = "v8intrinsic", M2 = [["pipelineOperator", { proposal: "hack", topicToken: "%" }], ["pipelineOperator", { proposal: "minimal" }], ["pipelineOperator", { proposal: "fsharp" }]], L = function(V) {
    let $ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : F;
    return Object.assign(Object.assign({}, $), {}, { plugins: [...$.plugins, ...V] });
  }, k2 = /@(?:no)?flow\b/;
  function G(V, $) {
    if ($.filepath && $.filepath.endsWith(".js.flow"))
      return true;
    let me2 = d4(V);
    me2 && (V = V.slice(me2.length));
    let ce = m2(V, 0);
    return ce !== false && (V = V.slice(0, ce)), k2.test(V);
  }
  function Z3(V, $, me2) {
    let ae2 = uo$1()[V]($, me2), q = ae2.errors.find((X3) => !ee2.has(X3.reasonCode));
    if (q)
      throw q;
    return ae2;
  }
  function B(V) {
    for (var $ = arguments.length, me2 = new Array($ > 1 ? $ - 1 : 0), ce = 1; ce < $; ce++)
      me2[ce - 1] = arguments[ce];
    return function(ae2, q) {
      let X3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if ((X3.parser === "babel" || X3.parser === "__babel_estree") && G(ae2, X3))
        return X3.parser = "babel-flow", l(ae2, q, X3);
      let re2 = me2;
      X3.__babelSourceType === "script" && (re2 = re2.map((oe2) => Object.assign(Object.assign({}, oe2), {}, { sourceType: "script" }))), /#[[{]/.test(ae2) && (re2 = re2.map((oe2) => L([D2], oe2)));
      let ne = /%[A-Z]/.test(ae2);
      ae2.includes("|>") ? re2 = (ne ? [...M2, C2] : M2).flatMap((Je2) => re2.map((Ye2) => L([Je2], Ye2))) : ne && (re2 = re2.map((oe2) => L([C2], oe2)));
      let { result: Ue2, error: _e2 } = p(...re2.map((oe2) => () => Z3(V, ae2, oe2)));
      if (!Ue2)
        throw A2(_e2);
      return X3.originalText = ae2, g2(Ue2, X3);
    };
  }
  var j = B("parse", L(["jsx", "flow"])), l = B("parse", L(["jsx", ["flow", { all: true, enums: true }]])), Y3 = B("parse", L(["jsx", "typescript"]), L(["typescript"])), ie = B("parse", L(["jsx", "flow", "estree"])), Q = B("parseExpression", L(["jsx"])), Ce2 = B("parseExpression", L(["typescript"])), ee2 = /* @__PURE__ */ new Set(["StrictNumericEscape", "StrictWith", "StrictOctalLiteral", "StrictDelete", "StrictEvalArguments", "StrictEvalArgumentsBinding", "StrictFunction", "EmptyTypeArguments", "EmptyTypeParameters", "ConstructorHasTypeParameters", "UnsupportedParameterPropertyKind", "UnexpectedParameterModifier", "MixedLabeledAndUnlabeledElements", "InvalidTupleMemberLabel", "NonClassMethodPropertyHasAbstractModifer", "ReadonlyForMethodSignature", "ClassMethodHasDeclare", "ClassMethodHasReadonly", "InvalidModifierOnTypeMember", "DuplicateAccessibilityModifier", "IndexSignatureHasDeclare", "DecoratorExportClass", "ParamDupe", "InvalidDecimal", "RestTrailingComma", "UnsupportedParameterDecorator", "UnterminatedJsxContent", "UnexpectedReservedWord", "ModuleAttributesWithDuplicateKeys", "LineTerminatorBeforeArrow", "InvalidEscapeSequenceTemplate", "NonAbstractClassHasAbstractMethod", "UnsupportedPropertyDecorator", "OptionalTypeBeforeRequired", "PatternIsOptional", "OptionalBindingPattern", "DeclareClassFieldHasInitializer", "TypeImportCannotSpecifyDefaultAndNamed", "DeclareFunctionHasImplementation", "ConstructorClassField", "VarRedeclaration", "InvalidPrivateFieldResolution", "DuplicateExport"]), U = x2(j), O2 = x2(Y3), P = x2(Q), De2 = x2(Ce2);
  u.exports = { parsers: Object.assign(Object.assign({ babel: U, "babel-flow": x2(l), "babel-ts": O2 }, E), {}, { __js_expression: P, __vue_expression: P, __vue_ts_expression: De2, __vue_event_binding: U, __vue_ts_event_binding: O2, __babel_estree: x2(ie) }) };
} }), Fd = lf$1();
var T = (e, r) => () => (r || e((r = { exports: {} }).exports, r), r.exports);
var X = T(($D2, Vr2) => {
  var Oe2 = function(e) {
    return e && e.Math == Math && e;
  };
  Vr2.exports = Oe2(typeof globalThis == "object" && globalThis) || Oe2(typeof window == "object" && window) || Oe2(typeof self == "object" && self) || Oe2(typeof global == "object" && global) || function() {
    return this;
  }() || Function("return this")();
});
var ae = T((UD2, Xr) => {
  Xr.exports = function(e) {
    try {
      return !!e();
    } catch {
      return true;
    }
  };
});
var De$1 = T((GD2, Hr2) => {
  var ms2 = ae();
  Hr2.exports = !ms2(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] != 7;
  });
});
var qe = T((VD2, zr2) => {
  var gs2 = ae();
  zr2.exports = !gs2(function() {
    var e = function() {
    }.bind();
    return typeof e != "function" || e.hasOwnProperty("prototype");
  });
});
var le = T((XD2, Wr2) => {
  var Fs2 = qe(), Ie2 = Function.prototype.call;
  Wr2.exports = Fs2 ? Ie2.bind(Ie2) : function() {
    return Ie2.apply(Ie2, arguments);
  };
});
var Jr = T((Kr2) => {
  var Yr2 = {}.propertyIsEnumerable, Qr = Object.getOwnPropertyDescriptor, As2 = Qr && !Yr2.call({ 1: 2 }, 1);
  Kr2.f = As2 ? function(r) {
    var t = Qr(this, r);
    return !!t && t.enumerable;
  } : Yr2;
});
var Re$1 = T((zD2, Zr) => {
  Zr.exports = function(e, r) {
    return { enumerable: !(e & 1), configurable: !(e & 2), writable: !(e & 4), value: r };
  };
});
var te = T((WD2, tt) => {
  var et2 = qe(), rt2 = Function.prototype, vs2 = rt2.bind, rr2 = rt2.call, _s2 = et2 && vs2.bind(rr2, rr2);
  tt.exports = et2 ? function(e) {
    return e && _s2(e);
  } : function(e) {
    return e && function() {
      return rr2.apply(e, arguments);
    };
  };
});
var xe$1 = T((YD2, nt) => {
  var ut2 = te(), Ss2 = ut2({}.toString), ys2 = ut2("".slice);
  nt.exports = function(e) {
    return ys2(Ss2(e), 8, -1);
  };
});
var at$1 = T((QD2, st2) => {
  var Ts2 = X(), Bs2 = te(), bs2 = ae(), ws2 = xe$1(), tr2 = Ts2.Object, Ns2 = Bs2("".split);
  st2.exports = bs2(function() {
    return !tr2("z").propertyIsEnumerable(0);
  }) ? function(e) {
    return ws2(e) == "String" ? Ns2(e, "") : tr2(e);
  } : tr2;
});
var ur = T((KD2, it2) => {
  var Os2 = X(), qs2 = Os2.TypeError;
  it2.exports = function(e) {
    if (e == null)
      throw qs2("Can't call method on " + e);
    return e;
  };
});
var Pe$1 = T((JD2, ot2) => {
  var Is2 = at$1(), Rs2 = ur();
  ot2.exports = function(e) {
    return Is2(Rs2(e));
  };
});
var ue$1 = T((ZD2, ct2) => {
  ct2.exports = function(e) {
    return typeof e == "function";
  };
});
var he = T((el2, Dt2) => {
  var xs2 = ue$1();
  Dt2.exports = function(e) {
    return typeof e == "object" ? e !== null : xs2(e);
  };
});
var ve$1 = T((rl2, lt2) => {
  var nr2 = X(), Ps2 = ue$1(), ks2 = function(e) {
    return Ps2(e) ? e : void 0;
  };
  lt2.exports = function(e, r) {
    return arguments.length < 2 ? ks2(nr2[e]) : nr2[e] && nr2[e][r];
  };
});
var sr = T((tl2, ht2) => {
  var Ls2 = te();
  ht2.exports = Ls2({}.isPrototypeOf);
});
var ft$1 = T((ul2, pt2) => {
  var Ms2 = ve$1();
  pt2.exports = Ms2("navigator", "userAgent") || "";
});
var At$1 = T((nl2, Ft2) => {
  var gt2 = X(), ar2 = ft$1(), dt2 = gt2.process, Et2 = gt2.Deno, Ct2 = dt2 && dt2.versions || Et2 && Et2.version, mt2 = Ct2 && Ct2.v8, ne, ke2;
  mt2 && (ne = mt2.split("."), ke2 = ne[0] > 0 && ne[0] < 4 ? 1 : +(ne[0] + ne[1]));
  !ke2 && ar2 && (ne = ar2.match(/Edge\/(\d+)/), (!ne || ne[1] >= 74) && (ne = ar2.match(/Chrome\/(\d+)/), ne && (ke2 = +ne[1])));
  Ft2.exports = ke2;
});
var ir$1 = T((sl2, _t2) => {
  var vt2 = At$1(), js2 = ae();
  _t2.exports = !!Object.getOwnPropertySymbols && !js2(function() {
    var e = Symbol();
    return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && vt2 && vt2 < 41;
  });
});
var or$1 = T((al2, St2) => {
  var $s2 = ir$1();
  St2.exports = $s2 && !Symbol.sham && typeof Symbol.iterator == "symbol";
});
var cr$1 = T((il2, yt2) => {
  var Us2 = X(), Gs2 = ve$1(), Vs2 = ue$1(), Xs2 = sr(), Hs2 = or$1(), zs2 = Us2.Object;
  yt2.exports = Hs2 ? function(e) {
    return typeof e == "symbol";
  } : function(e) {
    var r = Gs2("Symbol");
    return Vs2(r) && Xs2(r.prototype, zs2(e));
  };
});
var Le = T((ol2, Tt2) => {
  var Ws2 = X(), Ys2 = Ws2.String;
  Tt2.exports = function(e) {
    try {
      return Ys2(e);
    } catch {
      return "Object";
    }
  };
});
var _e = T((cl2, Bt) => {
  var Qs2 = X(), Ks2 = ue$1(), Js2 = Le(), Zs2 = Qs2.TypeError;
  Bt.exports = function(e) {
    if (Ks2(e))
      return e;
    throw Zs2(Js2(e) + " is not a function");
  };
});
var Me$1 = T((Dl2, bt2) => {
  var ea2 = _e();
  bt2.exports = function(e, r) {
    var t = e[r];
    return t == null ? void 0 : ea2(t);
  };
});
var Nt = T((ll2, wt2) => {
  var ra2 = X(), Dr2 = le(), lr2 = ue$1(), hr2 = he(), ta2 = ra2.TypeError;
  wt2.exports = function(e, r) {
    var t, s2;
    if (r === "string" && lr2(t = e.toString) && !hr2(s2 = Dr2(t, e)) || lr2(t = e.valueOf) && !hr2(s2 = Dr2(t, e)) || r !== "string" && lr2(t = e.toString) && !hr2(s2 = Dr2(t, e)))
      return s2;
    throw ta2("Can't convert object to primitive value");
  };
});
var qt$1 = T((hl2, Ot2) => {
  Ot2.exports = false;
});
var je = T((pl2, Rt2) => {
  var It2 = X(), ua2 = Object.defineProperty;
  Rt2.exports = function(e, r) {
    try {
      ua2(It2, e, { value: r, configurable: true, writable: true });
    } catch {
      It2[e] = r;
    }
    return r;
  };
});
var $e$1 = T((fl2, Pt2) => {
  var na2 = X(), sa2 = je(), xt2 = "__core-js_shared__", aa2 = na2[xt2] || sa2(xt2, {});
  Pt2.exports = aa2;
});
var pr$1 = T((dl2, Lt2) => {
  var ia2 = qt$1(), kt2 = $e$1();
  (Lt2.exports = function(e, r) {
    return kt2[e] || (kt2[e] = r !== void 0 ? r : {});
  })("versions", []).push({ version: "3.22.2", mode: ia2 ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.22.2/LICENSE", source: "https://github.com/zloirock/core-js" });
});
var fr$1 = T((El2, Mt2) => {
  var oa2 = X(), ca2 = ur(), Da2 = oa2.Object;
  Mt2.exports = function(e) {
    return Da2(ca2(e));
  };
});
var oe$1 = T((Cl2, jt2) => {
  var la2 = te(), ha2 = fr$1(), pa2 = la2({}.hasOwnProperty);
  jt2.exports = Object.hasOwn || function(r, t) {
    return pa2(ha2(r), t);
  };
});
var dr$1 = T((ml2, $t) => {
  var fa2 = te(), da2 = 0, Ea2 = Math.random(), Ca2 = fa2(1 .toString);
  $t.exports = function(e) {
    return "Symbol(" + (e === void 0 ? "" : e) + ")_" + Ca2(++da2 + Ea2, 36);
  };
});
var fe = T((gl2, Ht2) => {
  var ma2 = X(), ga2 = pr$1(), Ut2 = oe$1(), Fa2 = dr$1(), Gt2 = ir$1(), Xt2 = or$1(), Ce2 = ga2("wks"), pe = ma2.Symbol, Vt = pe && pe.for, Aa2 = Xt2 ? pe : pe && pe.withoutSetter || Fa2;
  Ht2.exports = function(e) {
    if (!Ut2(Ce2, e) || !(Gt2 || typeof Ce2[e] == "string")) {
      var r = "Symbol." + e;
      Gt2 && Ut2(pe, e) ? Ce2[e] = pe[e] : Xt2 && Vt ? Ce2[e] = Vt(r) : Ce2[e] = Aa2(r);
    }
    return Ce2[e];
  };
});
var Qt$1 = T((Fl2, Yt2) => {
  var va2 = X(), _a3 = le(), zt2 = he(), Wt2 = cr$1(), Sa2 = Me$1(), ya2 = Nt(), Ta2 = fe(), Ba2 = va2.TypeError, ba2 = Ta2("toPrimitive");
  Yt2.exports = function(e, r) {
    if (!zt2(e) || Wt2(e))
      return e;
    var t = Sa2(e, ba2), s2;
    if (t) {
      if (r === void 0 && (r = "default"), s2 = _a3(t, e, r), !zt2(s2) || Wt2(s2))
        return s2;
      throw Ba2("Can't convert object to primitive value");
    }
    return r === void 0 && (r = "number"), ya2(e, r);
  };
});
var Ue$1 = T((Al2, Kt2) => {
  var wa2 = Qt$1(), Na2 = cr$1();
  Kt2.exports = function(e) {
    var r = wa2(e, "string");
    return Na2(r) ? r : r + "";
  };
});
var eu = T((vl2, Zt) => {
  var Oa2 = X(), Jt2 = he(), Er2 = Oa2.document, qa2 = Jt2(Er2) && Jt2(Er2.createElement);
  Zt.exports = function(e) {
    return qa2 ? Er2.createElement(e) : {};
  };
});
var Cr$1 = T((_l2, ru) => {
  var Ia2 = De$1(), Ra2 = ae(), xa2 = eu();
  ru.exports = !Ia2 && !Ra2(function() {
    return Object.defineProperty(xa2("div"), "a", { get: function() {
      return 7;
    } }).a != 7;
  });
});
var mr$1 = T((uu) => {
  var Pa2 = De$1(), ka2 = le(), La2 = Jr(), Ma2 = Re$1(), ja2 = Pe$1(), $a2 = Ue$1(), Ua2 = oe$1(), Ga2 = Cr$1(), tu = Object.getOwnPropertyDescriptor;
  uu.f = Pa2 ? tu : function(r, t) {
    if (r = ja2(r), t = $a2(t), Ga2)
      try {
        return tu(r, t);
      } catch {
      }
    if (Ua2(r, t))
      return Ma2(!ka2(La2.f, r, t), r[t]);
  };
});
var su = T((yl2, nu) => {
  var Va2 = De$1(), Xa2 = ae();
  nu.exports = Va2 && Xa2(function() {
    return Object.defineProperty(function() {
    }, "prototype", { value: 42, writable: false }).prototype != 42;
  });
});
var me$1 = T((Tl2, iu) => {
  var au2 = X(), Ha2 = he(), za2 = au2.String, Wa2 = au2.TypeError;
  iu.exports = function(e) {
    if (Ha2(e))
      return e;
    throw Wa2(za2(e) + " is not an object");
  };
});
var Ve$1 = T((cu) => {
  var Ya2 = X(), Qa2 = De$1(), Ka2 = Cr$1(), Ja2 = su(), Ge2 = me$1(), ou = Ue$1(), Za2 = Ya2.TypeError, gr2 = Object.defineProperty, ei = Object.getOwnPropertyDescriptor, Fr2 = "enumerable", Ar2 = "configurable", vr2 = "writable";
  cu.f = Qa2 ? Ja2 ? function(r, t, s2) {
    if (Ge2(r), t = ou(t), Ge2(s2), typeof r == "function" && t === "prototype" && "value" in s2 && vr2 in s2 && !s2[vr2]) {
      var c = ei(r, t);
      c && c[vr2] && (r[t] = s2.value, s2 = { configurable: Ar2 in s2 ? s2[Ar2] : c[Ar2], enumerable: Fr2 in s2 ? s2[Fr2] : c[Fr2], writable: false });
    }
    return gr2(r, t, s2);
  } : gr2 : function(r, t, s2) {
    if (Ge2(r), t = ou(t), Ge2(s2), Ka2)
      try {
        return gr2(r, t, s2);
      } catch {
      }
    if ("get" in s2 || "set" in s2)
      throw Za2("Accessors not supported");
    return "value" in s2 && (r[t] = s2.value), r;
  };
});
var Xe = T((bl2, Du) => {
  var ri = De$1(), ti2 = Ve$1(), ui = Re$1();
  Du.exports = ri ? function(e, r, t) {
    return ti2.f(e, r, ui(1, t));
  } : function(e, r, t) {
    return e[r] = t, e;
  };
});
var He$1 = T((wl2, lu) => {
  var ni2 = te(), si2 = ue$1(), _r2 = $e$1(), ai2 = ni2(Function.toString);
  si2(_r2.inspectSource) || (_r2.inspectSource = function(e) {
    return ai2(e);
  });
  lu.exports = _r2.inspectSource;
});
var fu = T((Nl2, pu) => {
  var ii = X(), oi = ue$1(), ci2 = He$1(), hu = ii.WeakMap;
  pu.exports = oi(hu) && /native code/.test(ci2(hu));
});
var Cu = T((Ol2, Eu) => {
  var Di2 = pr$1(), li2 = dr$1(), du2 = Di2("keys");
  Eu.exports = function(e) {
    return du2[e] || (du2[e] = li2(e));
  };
});
var Sr$1 = T((ql2, mu) => {
  mu.exports = {};
});
var Su = T((Il2, _u) => {
  var hi = fu(), vu = X(), yr2 = te(), pi = he(), fi2 = Xe(), Tr2 = oe$1(), Br2 = $e$1(), di2 = Cu(), Ei2 = Sr$1(), gu = "Object already initialized", wr2 = vu.TypeError, Ci = vu.WeakMap, ze, Se2, We2, mi = function(e) {
    return We2(e) ? Se2(e) : ze(e, {});
  }, gi2 = function(e) {
    return function(r) {
      var t;
      if (!pi(r) || (t = Se2(r)).type !== e)
        throw wr2("Incompatible receiver, " + e + " required");
      return t;
    };
  };
  hi || Br2.state ? (ce = Br2.state || (Br2.state = new Ci()), Fu = yr2(ce.get), br2 = yr2(ce.has), Au2 = yr2(ce.set), ze = function(e, r) {
    if (br2(ce, e))
      throw new wr2(gu);
    return r.facade = e, Au2(ce, e, r), r;
  }, Se2 = function(e) {
    return Fu(ce, e) || {};
  }, We2 = function(e) {
    return br2(ce, e);
  }) : (de2 = di2("state"), Ei2[de2] = true, ze = function(e, r) {
    if (Tr2(e, de2))
      throw new wr2(gu);
    return r.facade = e, fi2(e, de2, r), r;
  }, Se2 = function(e) {
    return Tr2(e, de2) ? e[de2] : {};
  }, We2 = function(e) {
    return Tr2(e, de2);
  });
  var ce, Fu, br2, Au2, de2;
  _u.exports = { set: ze, get: Se2, has: We2, enforce: mi, getterFor: gi2 };
});
var Bu = T((Rl2, Tu) => {
  var Nr2 = De$1(), Fi = oe$1(), yu = Function.prototype, Ai2 = Nr2 && Object.getOwnPropertyDescriptor, Or2 = Fi(yu, "name"), vi2 = Or2 && function() {
  }.name === "something", _i = Or2 && (!Nr2 || Nr2 && Ai2(yu, "name").configurable);
  Tu.exports = { EXISTS: Or2, PROPER: vi2, CONFIGURABLE: _i };
});
var qu = T((xl2, Ou) => {
  var Si2 = X(), bu = ue$1(), yi2 = oe$1(), wu2 = Xe(), Ti = je(), Bi2 = He$1(), Nu = Su(), bi2 = Bu().CONFIGURABLE, wi = Nu.get, Ni2 = Nu.enforce, Oi2 = String(String).split("String");
  (Ou.exports = function(e, r, t, s2) {
    var c = s2 ? !!s2.unsafe : false, n = s2 ? !!s2.enumerable : false, a3 = s2 ? !!s2.noTargetGet : false, f = s2 && s2.name !== void 0 ? s2.name : r, D2;
    if (bu(t) && (String(f).slice(0, 7) === "Symbol(" && (f = "[" + String(f).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!yi2(t, "name") || bi2 && t.name !== f) && wu2(t, "name", f), D2 = Ni2(t), D2.source || (D2.source = Oi2.join(typeof f == "string" ? f : ""))), e === Si2) {
      n ? e[r] = t : Ti(r, t);
      return;
    } else
      c ? !a3 && e[r] && (n = true) : delete e[r];
    n ? e[r] = t : wu2(e, r, t);
  })(Function.prototype, "toString", function() {
    return bu(this) && wi(this).source || Bi2(this);
  });
});
var qr$1 = T((Pl2, Iu) => {
  var qi = Math.ceil, Ii2 = Math.floor;
  Iu.exports = function(e) {
    var r = +e;
    return r !== r || r === 0 ? 0 : (r > 0 ? Ii2 : qi)(r);
  };
});
var xu = T((kl2, Ru) => {
  var Ri2 = qr$1(), xi = Math.max, Pi2 = Math.min;
  Ru.exports = function(e, r) {
    var t = Ri2(e);
    return t < 0 ? xi(t + r, 0) : Pi2(t, r);
  };
});
var ku = T((Ll2, Pu) => {
  var ki = qr$1(), Li = Math.min;
  Pu.exports = function(e) {
    return e > 0 ? Li(ki(e), 9007199254740991) : 0;
  };
});
var ye$1 = T((Ml2, Lu) => {
  var Mi2 = ku();
  Lu.exports = function(e) {
    return Mi2(e.length);
  };
});
var $u = T((jl2, ju) => {
  var ji2 = Pe$1(), $i2 = xu(), Ui2 = ye$1(), Mu2 = function(e) {
    return function(r, t, s2) {
      var c = ji2(r), n = Ui2(c), a3 = $i2(s2, n), f;
      if (e && t != t) {
        for (; n > a3; )
          if (f = c[a3++], f != f)
            return true;
      } else
        for (; n > a3; a3++)
          if ((e || a3 in c) && c[a3] === t)
            return e || a3 || 0;
      return !e && -1;
    };
  };
  ju.exports = { includes: Mu2(true), indexOf: Mu2(false) };
});
var Vu = T(($l2, Gu) => {
  var Gi2 = te(), Ir2 = oe$1(), Vi = Pe$1(), Xi = $u().indexOf, Hi = Sr$1(), Uu = Gi2([].push);
  Gu.exports = function(e, r) {
    var t = Vi(e), s2 = 0, c = [], n;
    for (n in t)
      !Ir2(Hi, n) && Ir2(t, n) && Uu(c, n);
    for (; r.length > s2; )
      Ir2(t, n = r[s2++]) && (~Xi(c, n) || Uu(c, n));
    return c;
  };
});
var Hu = T((Ul2, Xu) => {
  Xu.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
});
var Wu = T((zu) => {
  var zi2 = Vu(), Wi = Hu(), Yi2 = Wi.concat("length", "prototype");
  zu.f = Object.getOwnPropertyNames || function(r) {
    return zi2(r, Yi2);
  };
});
var Qu = T((Yu) => {
  Yu.f = Object.getOwnPropertySymbols;
});
var Ju = T((Xl2, Ku) => {
  var Qi2 = ve$1(), Ki2 = te(), Ji2 = Wu(), Zi2 = Qu(), eo2 = me$1(), ro2 = Ki2([].concat);
  Ku.exports = Qi2("Reflect", "ownKeys") || function(r) {
    var t = Ji2.f(eo2(r)), s2 = Zi2.f;
    return s2 ? ro2(t, s2(r)) : t;
  };
});
var rn = T((Hl2, en2) => {
  var Zu = oe$1(), to2 = Ju(), uo2 = mr$1(), no2 = Ve$1();
  en2.exports = function(e, r, t) {
    for (var s2 = to2(r), c = no2.f, n = uo2.f, a3 = 0; a3 < s2.length; a3++) {
      var f = s2[a3];
      !Zu(e, f) && !(t && Zu(t, f)) && c(e, f, n(r, f));
    }
  };
});
var un = T((zl2, tn) => {
  var so2 = ae(), ao2 = ue$1(), io2 = /#|\.prototype\./, Te2 = function(e, r) {
    var t = co2[oo2(e)];
    return t == lo2 ? true : t == Do2 ? false : ao2(r) ? so2(r) : !!r;
  }, oo2 = Te2.normalize = function(e) {
    return String(e).replace(io2, ".").toLowerCase();
  }, co2 = Te2.data = {}, Do2 = Te2.NATIVE = "N", lo2 = Te2.POLYFILL = "P";
  tn.exports = Te2;
});
var Ye = T((Wl2, nn2) => {
  var Rr = X(), ho2 = mr$1().f, po2 = Xe(), fo2 = qu(), Eo2 = je(), Co2 = rn(), mo2 = un();
  nn2.exports = function(e, r) {
    var t = e.target, s2 = e.global, c = e.stat, n, a3, f, D2, v, i2;
    if (s2 ? a3 = Rr : c ? a3 = Rr[t] || Eo2(t, {}) : a3 = (Rr[t] || {}).prototype, a3)
      for (f in r) {
        if (v = r[f], e.noTargetGet ? (i2 = ho2(a3, f), D2 = i2 && i2.value) : D2 = a3[f], n = mo2(s2 ? f : t + (c ? "." : "#") + f, e.forced), !n && D2 !== void 0) {
          if (typeof v == typeof D2)
            continue;
          Co2(v, D2);
        }
        (e.sham || D2 && D2.sham) && po2(v, "sham", true), fo2(a3, f, v, e);
      }
  };
});
var sn = T(() => {
  var go2 = Ye(), Fo2 = X();
  go2({ global: true }, { globalThis: Fo2 });
});
var xr = T((Kl2, an2) => {
  var Ao2 = xe$1();
  an2.exports = Array.isArray || function(r) {
    return Ao2(r) == "Array";
  };
});
var Pr = T((Jl2, cn) => {
  var on2 = te(), vo2 = _e(), _o2 = qe(), So2 = on2(on2.bind);
  cn.exports = function(e, r) {
    return vo2(e), r === void 0 ? e : _o2 ? So2(e, r) : function() {
      return e.apply(r, arguments);
    };
  };
});
var hn$1 = T((Zl2, ln) => {
  var yo2 = X(), To2 = xr(), Bo2 = ye$1(), bo2 = Pr(), wo2 = yo2.TypeError, Dn = function(e, r, t, s2, c, n, a3, f) {
    for (var D2 = c, v = 0, i2 = a3 ? bo2(a3, f) : false, l, p; v < s2; ) {
      if (v in t) {
        if (l = i2 ? i2(t[v], v, r) : t[v], n > 0 && To2(l))
          p = Bo2(l), D2 = Dn(e, r, l, p, D2, n - 1) - 1;
        else {
          if (D2 >= 9007199254740991)
            throw wo2("Exceed the acceptable array length");
          e[D2] = l;
        }
        D2++;
      }
      v++;
    }
    return D2;
  };
  ln.exports = Dn;
});
var dn = T((e2, fn2) => {
  var No2 = fe(), Oo2 = No2("toStringTag"), pn2 = {};
  pn2[Oo2] = "z";
  fn2.exports = String(pn2) === "[object z]";
});
var kr = T((r2, En2) => {
  var qo2 = X(), Io2 = dn(), Ro2 = ue$1(), Qe = xe$1(), xo2 = fe(), Po2 = xo2("toStringTag"), ko2 = qo2.Object, Lo2 = Qe(function() {
    return arguments;
  }()) == "Arguments", Mo2 = function(e, r) {
    try {
      return e[r];
    } catch {
    }
  };
  En2.exports = Io2 ? Qe : function(e) {
    var r, t, s2;
    return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (t = Mo2(r = ko2(e), Po2)) == "string" ? t : Lo2 ? Qe(r) : (s2 = Qe(r)) == "Object" && Ro2(r.callee) ? "Arguments" : s2;
  };
});
var vn = T((t2, An2) => {
  var jo2 = te(), $o2 = ae(), Cn2 = ue$1(), Uo2 = kr(), Go2 = ve$1(), Vo2 = He$1(), mn2 = function() {
  }, Xo = [], gn2 = Go2("Reflect", "construct"), Lr2 = /^\s*(?:class|function)\b/, Ho2 = jo2(Lr2.exec), zo2 = !Lr2.exec(mn2), Be = function(r) {
    if (!Cn2(r))
      return false;
    try {
      return gn2(mn2, Xo, r), true;
    } catch {
      return false;
    }
  }, Fn2 = function(r) {
    if (!Cn2(r))
      return false;
    switch (Uo2(r)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return false;
    }
    try {
      return zo2 || !!Ho2(Lr2, Vo2(r));
    } catch {
      return true;
    }
  };
  Fn2.sham = true;
  An2.exports = !gn2 || $o2(function() {
    var e;
    return Be(Be.call) || !Be(Object) || !Be(function() {
      e = true;
    }) || e;
  }) ? Fn2 : Be;
});
var Tn = T((u2, yn2) => {
  var Wo2 = X(), _n2 = xr(), Yo = vn(), Qo = he(), Ko = fe(), Jo2 = Ko("species"), Sn2 = Wo2.Array;
  yn2.exports = function(e) {
    var r;
    return _n2(e) && (r = e.constructor, Yo(r) && (r === Sn2 || _n2(r.prototype)) ? r = void 0 : Qo(r) && (r = r[Jo2], r === null && (r = void 0))), r === void 0 ? Sn2 : r;
  };
});
var bn$1 = T((n2, Bn2) => {
  var Zo = Tn();
  Bn2.exports = function(e, r) {
    return new (Zo(e))(r === 0 ? 0 : r);
  };
});
var Mr = T((s2, wn2) => {
  wn2.exports = {};
});
var On$1 = T((a22, Nn2) => {
  var ac = fe(), ic = Mr(), oc = ac("iterator"), cc = Array.prototype;
  Nn2.exports = function(e) {
    return e !== void 0 && (ic.Array === e || cc[oc] === e);
  };
});
var jr$1 = T((i2, In2) => {
  var Dc = kr(), qn2 = Me$1(), lc = Mr(), hc = fe(), pc = hc("iterator");
  In2.exports = function(e) {
    if (e != null)
      return qn2(e, pc) || qn2(e, "@@iterator") || lc[Dc(e)];
  };
});
var xn = T((o2, Rn2) => {
  var fc = X(), dc = le(), Ec = _e(), Cc = me$1(), mc = Le(), gc = jr$1(), Fc = fc.TypeError;
  Rn2.exports = function(e, r) {
    var t = arguments.length < 2 ? gc(e) : r;
    if (Ec(t))
      return Cc(dc(t, e));
    throw Fc(mc(e) + " is not iterable");
  };
});
var Ln = T((c2, kn2) => {
  var Ac = le(), Pn2 = me$1(), vc = Me$1();
  kn2.exports = function(e, r, t) {
    var s2, c;
    Pn2(e);
    try {
      if (s2 = vc(e, "return"), !s2) {
        if (r === "throw")
          throw t;
        return t;
      }
      s2 = Ac(s2, e);
    } catch (n) {
      c = true, s2 = n;
    }
    if (r === "throw")
      throw t;
    if (c)
      throw s2;
    return Pn2(s2), t;
  };
});
var Gn = T((D2, Un2) => {
  var _c2 = X(), Sc = Pr(), yc = le(), Tc = me$1(), Bc = Le(), bc = On$1(), wc = ye$1(), Mn2 = sr(), Nc = xn(), Oc = jr$1(), jn2 = Ln(), qc = _c2.TypeError, Ke2 = function(e, r) {
    this.stopped = e, this.result = r;
  }, $n2 = Ke2.prototype;
  Un2.exports = function(e, r, t) {
    var s2 = t && t.that, c = !!(t && t.AS_ENTRIES), n = !!(t && t.IS_ITERATOR), a3 = !!(t && t.INTERRUPTED), f = Sc(r, s2), D3, v, i2, l, p, g2, C2, m2 = function(w2) {
      return D3 && jn2(D3, "normal", w2), new Ke2(true, w2);
    }, B = function(w2) {
      return c ? (Tc(w2), a3 ? f(w2[0], w2[1], m2) : f(w2[0], w2[1])) : a3 ? f(w2, m2) : f(w2);
    };
    if (n)
      D3 = e;
    else {
      if (v = Oc(e), !v)
        throw qc(Bc(e) + " is not iterable");
      if (bc(v)) {
        for (i2 = 0, l = wc(e); l > i2; i2++)
          if (p = B(e[i2]), p && Mn2($n2, p))
            return p;
        return new Ke2(false);
      }
      D3 = Nc(e, v);
    }
    for (g2 = D3.next; !(C2 = yc(g2, D3)).done; ) {
      try {
        p = B(C2.value);
      } catch (w2) {
        jn2(D3, "throw", w2);
      }
      if (typeof p == "object" && p && Mn2($n2, p))
        return p;
    }
    return new Ke2(false);
  };
});
var Xn = T((l2, Vn2) => {
  var Ic = Ue$1(), Rc = Ve$1(), xc = Re$1();
  Vn2.exports = function(e, r, t) {
    var s2 = Ic(r);
    s2 in e ? Rc.f(e, s2, xc(0, t)) : e[s2] = t;
  };
});
sn();
var ec = Ye(), rc = hn$1(), tc = _e(), uc = fr$1(), nc = ye$1(), sc = bn$1();
ec({ target: "Array", proto: true }, { flatMap: function(r) {
  var t = uc(this), s2 = nc(t), c;
  return tc(r), c = sc(t, 0), c.length = rc(c, t, t, s2, 0, 1, r, arguments.length > 1 ? arguments[1] : void 0), c;
} });
var Pc = Ye(), kc = Gn(), Lc = Xn();
Pc({ target: "Object", stat: true }, { fromEntries: function(r) {
  var t = {};
  return kc(r, function(s2, c) {
    Lc(t, s2, c);
  }, { AS_ENTRIES: true }), t;
} });
var Mc = ["cliName", "cliCategory", "cliDescription"], Hn$1, zn, Wn$1, Yn$1, Qn, Kn;
function jc(e, r) {
  if (e == null)
    return {};
  var t = $c(e, r), s2, c;
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    for (c = 0; c < n.length; c++)
      s2 = n[c], !(r.indexOf(s2) >= 0) && (!Object.prototype.propertyIsEnumerable.call(e, s2) || (t[s2] = e[s2]));
  }
  return t;
}
function $c(e, r) {
  if (e == null)
    return {};
  var t = {}, s2 = Object.keys(e), c, n;
  for (n = 0; n < s2.length; n++)
    c = s2[n], !(r.indexOf(c) >= 0) && (t[c] = e[c]);
  return t;
}
function ge$1(e, r) {
  return r || (r = e.slice(0)), Object.freeze(Object.defineProperties(e, { raw: { value: Object.freeze(r) } }));
}
var Uc = Object.create, Je$1 = Object.defineProperty, Gc = Object.getOwnPropertyDescriptor, $r$1 = Object.getOwnPropertyNames, Vc = Object.getPrototypeOf, Xc$1 = Object.prototype.hasOwnProperty, Fe$1 = (e, r) => function() {
  return e && (r = (0, e[$r$1(e)[0]])(e = 0)), r;
}, I$1 = (e, r) => function() {
  return r || (0, e[$r$1(e)[0]])((r = { exports: {} }).exports, r), r.exports;
}, ts = (e, r) => {
  for (var t in r)
    Je$1(e, t, { get: r[t], enumerable: true });
}, us$1 = (e, r, t, s2) => {
  if (r && typeof r == "object" || typeof r == "function")
    for (let c of $r$1(r))
      !Xc$1.call(e, c) && c !== t && Je$1(e, c, { get: () => r[c], enumerable: !(s2 = Gc(r, c)) || s2.enumerable });
  return e;
}, Hc = (e, r, t) => (t = e != null ? Uc(Vc(e)) : {}, us$1(r || !e || !e.__esModule ? Je$1(t, "default", { value: e, enumerable: true }) : t, e)), ns$1 = (e) => us$1(Je$1({}, "__esModule", { value: true }), e), Jn, Zn, be$1, O = Fe$1({ "<define:process>"() {
  Jn = {}, Zn = [], be$1 = { env: Jn, argv: Zn };
} }), ss$1 = I$1({ "node_modules/angular-html-parser/lib/compiler/src/chars.js"(e) {
  O(), Object.defineProperty(e, "__esModule", { value: true }), e.$EOF = 0, e.$BSPACE = 8, e.$TAB = 9, e.$LF = 10, e.$VTAB = 11, e.$FF = 12, e.$CR = 13, e.$SPACE = 32, e.$BANG = 33, e.$DQ = 34, e.$HASH = 35, e.$$ = 36, e.$PERCENT = 37, e.$AMPERSAND = 38, e.$SQ = 39, e.$LPAREN = 40, e.$RPAREN = 41, e.$STAR = 42, e.$PLUS = 43, e.$COMMA = 44, e.$MINUS = 45, e.$PERIOD = 46, e.$SLASH = 47, e.$COLON = 58, e.$SEMICOLON = 59, e.$LT = 60, e.$EQ = 61, e.$GT = 62, e.$QUESTION = 63, e.$0 = 48, e.$7 = 55, e.$9 = 57, e.$A = 65, e.$E = 69, e.$F = 70, e.$X = 88, e.$Z = 90, e.$LBRACKET = 91, e.$BACKSLASH = 92, e.$RBRACKET = 93, e.$CARET = 94, e.$_ = 95, e.$a = 97, e.$b = 98, e.$e = 101, e.$f = 102, e.$n = 110, e.$r = 114, e.$t = 116, e.$u = 117, e.$v = 118, e.$x = 120, e.$z = 122, e.$LBRACE = 123, e.$BAR = 124, e.$RBRACE = 125, e.$NBSP = 160, e.$PIPE = 124, e.$TILDA = 126, e.$AT = 64, e.$BT = 96;
  function r(f) {
    return f >= e.$TAB && f <= e.$SPACE || f == e.$NBSP;
  }
  e.isWhitespace = r;
  function t(f) {
    return e.$0 <= f && f <= e.$9;
  }
  e.isDigit = t;
  function s2(f) {
    return f >= e.$a && f <= e.$z || f >= e.$A && f <= e.$Z;
  }
  e.isAsciiLetter = s2;
  function c(f) {
    return f >= e.$a && f <= e.$f || f >= e.$A && f <= e.$F || t(f);
  }
  e.isAsciiHexDigit = c;
  function n(f) {
    return f === e.$LF || f === e.$CR;
  }
  e.isNewLine = n;
  function a3(f) {
    return e.$0 <= f && f <= e.$7;
  }
  e.isOctalDigit = a3;
} }), zc = I$1({ "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(e) {
  O(), Object.defineProperty(e, "__esModule", { value: true });
  var r = class {
    constructor(s2, c, n) {
      this.filePath = s2, this.name = c, this.members = n;
    }
    assertNoMembers() {
      if (this.members.length)
        throw new Error("Illegal state: symbol without members expected, but got ".concat(JSON.stringify(this), "."));
    }
  };
  e.StaticSymbol = r;
  var t = class {
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
    }
    get(s2, c, n) {
      n = n || [];
      let a3 = n.length ? ".".concat(n.join(".")) : "", f = '"'.concat(s2, '".').concat(c).concat(a3), D2 = this.cache.get(f);
      return D2 || (D2 = new r(s2, c, n), this.cache.set(f, D2)), D2;
    }
  };
  e.StaticSymbolCache = t;
} }), Wc = I$1({ "node_modules/angular-html-parser/lib/compiler/src/util.js"(e) {
  O(), Object.defineProperty(e, "__esModule", { value: true });
  var r = /-+([a-z0-9])/g;
  function t(o) {
    return o.replace(r, function() {
      for (var d4 = arguments.length, h2 = new Array(d4), F = 0; F < d4; F++)
        h2[F] = arguments[F];
      return h2[1].toUpperCase();
    });
  }
  e.dashCaseToCamelCase = t;
  function s2(o, d4) {
    return n(o, ":", d4);
  }
  e.splitAtColon = s2;
  function c(o, d4) {
    return n(o, ".", d4);
  }
  e.splitAtPeriod = c;
  function n(o, d4, h2) {
    let F = o.indexOf(d4);
    return F == -1 ? h2 : [o.slice(0, F).trim(), o.slice(F + 1).trim()];
  }
  function a3(o, d4, h2) {
    return Array.isArray(o) ? d4.visitArray(o, h2) : S2(o) ? d4.visitStringMap(o, h2) : o == null || typeof o == "string" || typeof o == "number" || typeof o == "boolean" ? d4.visitPrimitive(o, h2) : d4.visitOther(o, h2);
  }
  e.visitValue = a3;
  function f(o) {
    return o != null;
  }
  e.isDefined = f;
  function D2(o) {
    return o === void 0 ? null : o;
  }
  e.noUndefined = D2;
  var v = class {
    visitArray(o, d4) {
      return o.map((h2) => a3(h2, this, d4));
    }
    visitStringMap(o, d4) {
      let h2 = {};
      return Object.keys(o).forEach((F) => {
        h2[F] = a3(o[F], this, d4);
      }), h2;
    }
    visitPrimitive(o, d4) {
      return o;
    }
    visitOther(o, d4) {
      return o;
    }
  };
  e.ValueTransformer = v, e.SyncAsync = { assertSync: (o) => {
    if (R(o))
      throw new Error("Illegal state: value cannot be a promise");
    return o;
  }, then: (o, d4) => R(o) ? o.then(d4) : d4(o), all: (o) => o.some(R) ? Promise.all(o) : o };
  function i2(o) {
    throw new Error("Internal Error: ".concat(o));
  }
  e.error = i2;
  function l(o, d4) {
    let h2 = Error(o);
    return h2[p] = true, d4 && (h2[g2] = d4), h2;
  }
  e.syntaxError = l;
  var p = "ngSyntaxError", g2 = "ngParseErrors";
  function C2(o) {
    return o[p];
  }
  e.isSyntaxError = C2;
  function m2(o) {
    return o[g2] || [];
  }
  e.getParseErrors = m2;
  function B(o) {
    return o.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
  }
  e.escapeRegExp = B;
  var w2 = Object.getPrototypeOf({});
  function S2(o) {
    return typeof o == "object" && o !== null && Object.getPrototypeOf(o) === w2;
  }
  function N(o) {
    let d4 = "";
    for (let h2 = 0; h2 < o.length; h2++) {
      let F = o.charCodeAt(h2);
      if (F >= 55296 && F <= 56319 && o.length > h2 + 1) {
        let q = o.charCodeAt(h2 + 1);
        q >= 56320 && q <= 57343 && (h2++, F = (F - 55296 << 10) + q - 56320 + 65536);
      }
      F <= 127 ? d4 += String.fromCharCode(F) : F <= 2047 ? d4 += String.fromCharCode(F >> 6 & 31 | 192, F & 63 | 128) : F <= 65535 ? d4 += String.fromCharCode(F >> 12 | 224, F >> 6 & 63 | 128, F & 63 | 128) : F <= 2097151 && (d4 += String.fromCharCode(F >> 18 & 7 | 240, F >> 12 & 63 | 128, F >> 6 & 63 | 128, F & 63 | 128));
    }
    return d4;
  }
  e.utf8Encode = N;
  function b2(o) {
    if (typeof o == "string")
      return o;
    if (o instanceof Array)
      return "[" + o.map(b2).join(", ") + "]";
    if (o == null)
      return "" + o;
    if (o.overriddenName)
      return "".concat(o.overriddenName);
    if (o.name)
      return "".concat(o.name);
    if (!o.toString)
      return "object";
    let d4 = o.toString();
    if (d4 == null)
      return "" + d4;
    let h2 = d4.indexOf(`
`);
    return h2 === -1 ? d4 : d4.substring(0, h2);
  }
  e.stringify = b2;
  function j(o) {
    return typeof o == "function" && o.hasOwnProperty("__forward_ref__") ? o() : o;
  }
  e.resolveForwardRef = j;
  function R(o) {
    return !!o && typeof o.then == "function";
  }
  e.isPromise = R;
  var U = class {
    constructor(o) {
      this.full = o;
      let d4 = o.split(".");
      this.major = d4[0], this.minor = d4[1], this.patch = d4.slice(2).join(".");
    }
  };
  e.Version = U;
  var k2 = typeof window < "u" && window, $ = typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self, L = typeof globalThis < "u" && globalThis, u = L || k2 || $;
  e.global = u;
} }), Yc$1 = I$1({ "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(e) {
  O(), Object.defineProperty(e, "__esModule", { value: true });
  var r = zc(), t = Wc(), s2 = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
  function c(h2) {
    return h2.replace(/\W/g, "_");
  }
  e.sanitizeIdentifier = c;
  var n = 0;
  function a3(h2) {
    if (!h2 || !h2.reference)
      return null;
    let F = h2.reference;
    if (F instanceof r.StaticSymbol)
      return F.name;
    if (F.__anonymousType)
      return F.__anonymousType;
    let q = t.stringify(F);
    return q.indexOf("(") >= 0 ? (q = "anonymous_".concat(n++), F.__anonymousType = q) : q = c(q), q;
  }
  e.identifierName = a3;
  function f(h2) {
    let F = h2.reference;
    return F instanceof r.StaticSymbol ? F.filePath : "./".concat(t.stringify(F));
  }
  e.identifierModuleUrl = f;
  function D2(h2, F) {
    return "View_".concat(a3({ reference: h2 }), "_").concat(F);
  }
  e.viewClassName = D2;
  function v(h2) {
    return "RenderType_".concat(a3({ reference: h2 }));
  }
  e.rendererTypeName = v;
  function i2(h2) {
    return "HostView_".concat(a3({ reference: h2 }));
  }
  e.hostViewClassName = i2;
  function l(h2) {
    return "".concat(a3({ reference: h2 }), "NgFactory");
  }
  e.componentFactoryName = l;
  var p;
  (function(h2) {
    h2[h2.Pipe = 0] = "Pipe", h2[h2.Directive = 1] = "Directive", h2[h2.NgModule = 2] = "NgModule", h2[h2.Injectable = 3] = "Injectable";
  })(p = e.CompileSummaryKind || (e.CompileSummaryKind = {}));
  function g2(h2) {
    return h2.value != null ? c(h2.value) : a3(h2.identifier);
  }
  e.tokenName = g2;
  function C2(h2) {
    return h2.identifier != null ? h2.identifier.reference : h2.value;
  }
  e.tokenReference = C2;
  var m2 = class {
    constructor() {
      let { moduleUrl: h2, styles: F, styleUrls: q } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.moduleUrl = h2 || null, this.styles = R(F), this.styleUrls = R(q);
    }
  };
  e.CompileStylesheetMetadata = m2;
  var B = class {
    constructor(h2) {
      let { encapsulation: F, template: q, templateUrl: P, htmlAst: G, styles: H3, styleUrls: K, externalStylesheets: z, animations: Y3, ngContentSelectors: J2, interpolation: Z3, isInline: _, preserveWhitespaces: E } = h2;
      if (this.encapsulation = F, this.template = q, this.templateUrl = P, this.htmlAst = G, this.styles = R(H3), this.styleUrls = R(K), this.externalStylesheets = R(z), this.animations = Y3 ? k2(Y3) : [], this.ngContentSelectors = J2 || [], Z3 && Z3.length != 2)
        throw new Error("'interpolation' should have a start and an end symbol.");
      this.interpolation = Z3, this.isInline = _, this.preserveWhitespaces = E;
    }
    toSummary() {
      return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
    }
  };
  e.CompileTemplateMetadata = B;
  var w2 = class {
    static create(h2) {
      let { isHost: F, type: q, isComponent: P, selector: G, exportAs: H3, changeDetection: K, inputs: z, outputs: Y3, host: J2, providers: Z3, viewProviders: _, queries: E, guards: A2, viewQueries: y, entryComponents: x2, template: M2, componentViewType: V, rendererType: W2, componentFactory: Q } = h2, se = {}, Ee = {}, er2 = {};
      J2 != null && Object.keys(J2).forEach((ee2) => {
        let re2 = J2[ee2], ie = ee2.match(s2);
        ie === null ? er2[ee2] = re2 : ie[1] != null ? Ee[ie[1]] = re2 : ie[2] != null && (se[ie[2]] = re2);
      });
      let Ae2 = {};
      z != null && z.forEach((ee2) => {
        let re2 = t.splitAtColon(ee2, [ee2, ee2]);
        Ae2[re2[0]] = re2[1];
      });
      let Ne2 = {};
      return Y3 != null && Y3.forEach((ee2) => {
        let re2 = t.splitAtColon(ee2, [ee2, ee2]);
        Ne2[re2[0]] = re2[1];
      }), new w2({ isHost: F, type: q, isComponent: !!P, selector: G, exportAs: H3, changeDetection: K, inputs: Ae2, outputs: Ne2, hostListeners: se, hostProperties: Ee, hostAttributes: er2, providers: Z3, viewProviders: _, queries: E, guards: A2, viewQueries: y, entryComponents: x2, template: M2, componentViewType: V, rendererType: W2, componentFactory: Q });
    }
    constructor(h2) {
      let { isHost: F, type: q, isComponent: P, selector: G, exportAs: H3, changeDetection: K, inputs: z, outputs: Y3, hostListeners: J2, hostProperties: Z3, hostAttributes: _, providers: E, viewProviders: A2, queries: y, guards: x2, viewQueries: M2, entryComponents: V, template: W2, componentViewType: Q, rendererType: se, componentFactory: Ee } = h2;
      this.isHost = !!F, this.type = q, this.isComponent = P, this.selector = G, this.exportAs = H3, this.changeDetection = K, this.inputs = z, this.outputs = Y3, this.hostListeners = J2, this.hostProperties = Z3, this.hostAttributes = _, this.providers = R(E), this.viewProviders = R(A2), this.queries = R(y), this.guards = x2, this.viewQueries = R(M2), this.entryComponents = R(V), this.template = W2, this.componentViewType = Q, this.rendererType = se, this.componentFactory = Ee;
    }
    toSummary() {
      return { summaryKind: p.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
    }
  };
  e.CompileDirectiveMetadata = w2;
  var S2 = class {
    constructor(h2) {
      let { type: F, name: q, pure: P } = h2;
      this.type = F, this.name = q, this.pure = !!P;
    }
    toSummary() {
      return { summaryKind: p.Pipe, type: this.type, name: this.name, pure: this.pure };
    }
  };
  e.CompilePipeMetadata = S2;
  var N = class {
  };
  e.CompileShallowModuleMetadata = N;
  var b2 = class {
    constructor(h2) {
      let { type: F, providers: q, declaredDirectives: P, exportedDirectives: G, declaredPipes: H3, exportedPipes: K, entryComponents: z, bootstrapComponents: Y3, importedModules: J2, exportedModules: Z3, schemas: _, transitiveModule: E, id: A2 } = h2;
      this.type = F || null, this.declaredDirectives = R(P), this.exportedDirectives = R(G), this.declaredPipes = R(H3), this.exportedPipes = R(K), this.providers = R(q), this.entryComponents = R(z), this.bootstrapComponents = R(Y3), this.importedModules = R(J2), this.exportedModules = R(Z3), this.schemas = R(_), this.id = A2 || null, this.transitiveModule = E || null;
    }
    toSummary() {
      let h2 = this.transitiveModule;
      return { summaryKind: p.NgModule, type: this.type, entryComponents: h2.entryComponents, providers: h2.providers, modules: h2.modules, exportedDirectives: h2.exportedDirectives, exportedPipes: h2.exportedPipes };
    }
  };
  e.CompileNgModuleMetadata = b2;
  var j = class {
    constructor() {
      this.directivesSet = /* @__PURE__ */ new Set(), this.directives = [], this.exportedDirectivesSet = /* @__PURE__ */ new Set(), this.exportedDirectives = [], this.pipesSet = /* @__PURE__ */ new Set(), this.pipes = [], this.exportedPipesSet = /* @__PURE__ */ new Set(), this.exportedPipes = [], this.modulesSet = /* @__PURE__ */ new Set(), this.modules = [], this.entryComponentsSet = /* @__PURE__ */ new Set(), this.entryComponents = [], this.providers = [];
    }
    addProvider(h2, F) {
      this.providers.push({ provider: h2, module: F });
    }
    addDirective(h2) {
      this.directivesSet.has(h2.reference) || (this.directivesSet.add(h2.reference), this.directives.push(h2));
    }
    addExportedDirective(h2) {
      this.exportedDirectivesSet.has(h2.reference) || (this.exportedDirectivesSet.add(h2.reference), this.exportedDirectives.push(h2));
    }
    addPipe(h2) {
      this.pipesSet.has(h2.reference) || (this.pipesSet.add(h2.reference), this.pipes.push(h2));
    }
    addExportedPipe(h2) {
      this.exportedPipesSet.has(h2.reference) || (this.exportedPipesSet.add(h2.reference), this.exportedPipes.push(h2));
    }
    addModule(h2) {
      this.modulesSet.has(h2.reference) || (this.modulesSet.add(h2.reference), this.modules.push(h2));
    }
    addEntryComponent(h2) {
      this.entryComponentsSet.has(h2.componentType) || (this.entryComponentsSet.add(h2.componentType), this.entryComponents.push(h2));
    }
  };
  e.TransitiveCompileNgModuleMetadata = j;
  function R(h2) {
    return h2 || [];
  }
  var U = class {
    constructor(h2, F) {
      let { useClass: q, useValue: P, useExisting: G, useFactory: H3, deps: K, multi: z } = F;
      this.token = h2, this.useClass = q || null, this.useValue = P, this.useExisting = G, this.useFactory = H3 || null, this.dependencies = K || null, this.multi = !!z;
    }
  };
  e.ProviderMeta = U;
  function k2(h2) {
    return h2.reduce((F, q) => {
      let P = Array.isArray(q) ? k2(q) : q;
      return F.concat(P);
    }, []);
  }
  e.flatten = k2;
  function $(h2) {
    return h2.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
  }
  function L(h2, F, q) {
    let P;
    return q.isInline ? F.type.reference instanceof r.StaticSymbol ? P = "".concat(F.type.reference.filePath, ".").concat(F.type.reference.name, ".html") : P = "".concat(a3(h2), "/").concat(a3(F.type), ".html") : P = q.templateUrl, F.type.reference instanceof r.StaticSymbol ? P : $(P);
  }
  e.templateSourceUrl = L;
  function u(h2, F) {
    let q = h2.moduleUrl.split(/\/\\/g), P = q[q.length - 1];
    return $("css/".concat(F).concat(P, ".ngstyle.js"));
  }
  e.sharedStylesheetJitUrl = u;
  function o(h2) {
    return $("".concat(a3(h2.type), "/module.ngfactory.js"));
  }
  e.ngModuleJitUrl = o;
  function d4(h2, F) {
    return $("".concat(a3(h2), "/").concat(a3(F.type), ".ngfactory.js"));
  }
  e.templateJitUrl = d4;
} }), we$1 = I$1({ "node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(e) {
  O(), Object.defineProperty(e, "__esModule", { value: true });
  var r = ss$1(), t = Yc$1(), s2 = class {
    constructor(i2, l, p, g2) {
      this.file = i2, this.offset = l, this.line = p, this.col = g2;
    }
    toString() {
      return this.offset != null ? "".concat(this.file.url, "@").concat(this.line, ":").concat(this.col) : this.file.url;
    }
    moveBy(i2) {
      let l = this.file.content, p = l.length, g2 = this.offset, C2 = this.line, m2 = this.col;
      for (; g2 > 0 && i2 < 0; )
        if (g2--, i2++, l.charCodeAt(g2) == r.$LF) {
          C2--;
          let w2 = l.substr(0, g2 - 1).lastIndexOf(String.fromCharCode(r.$LF));
          m2 = w2 > 0 ? g2 - w2 : g2;
        } else
          m2--;
      for (; g2 < p && i2 > 0; ) {
        let B = l.charCodeAt(g2);
        g2++, i2--, B == r.$LF ? (C2++, m2 = 0) : m2++;
      }
      return new s2(this.file, g2, C2, m2);
    }
    getContext(i2, l) {
      let p = this.file.content, g2 = this.offset;
      if (g2 != null) {
        g2 > p.length - 1 && (g2 = p.length - 1);
        let C2 = g2, m2 = 0, B = 0;
        for (; m2 < i2 && g2 > 0 && (g2--, m2++, !(p[g2] == `
` && ++B == l)); )
          ;
        for (m2 = 0, B = 0; m2 < i2 && C2 < p.length - 1 && (C2++, m2++, !(p[C2] == `
` && ++B == l)); )
          ;
        return { before: p.substring(g2, this.offset), after: p.substring(this.offset, C2 + 1) };
      }
      return null;
    }
  };
  e.ParseLocation = s2;
  var c = class {
    constructor(i2, l) {
      this.content = i2, this.url = l;
    }
  };
  e.ParseSourceFile = c;
  var n = class {
    constructor(i2, l) {
      let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      this.start = i2, this.end = l, this.details = p;
    }
    toString() {
      return this.start.file.content.substring(this.start.offset, this.end.offset);
    }
  };
  e.ParseSourceSpan = n, e.EMPTY_PARSE_LOCATION = new s2(new c("", ""), 0, 0, 0), e.EMPTY_SOURCE_SPAN = new n(e.EMPTY_PARSE_LOCATION, e.EMPTY_PARSE_LOCATION);
  var a3;
  (function(i2) {
    i2[i2.WARNING = 0] = "WARNING", i2[i2.ERROR = 1] = "ERROR";
  })(a3 = e.ParseErrorLevel || (e.ParseErrorLevel = {}));
  var f = class {
    constructor(i2, l) {
      let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : a3.ERROR;
      this.span = i2, this.msg = l, this.level = p;
    }
    contextualMessage() {
      let i2 = this.span.start.getContext(100, 3);
      return i2 ? "".concat(this.msg, ' ("').concat(i2.before, "[").concat(a3[this.level], " ->]").concat(i2.after, '")') : this.msg;
    }
    toString() {
      let i2 = this.span.details ? ", ".concat(this.span.details) : "";
      return "".concat(this.contextualMessage(), ": ").concat(this.span.start).concat(i2);
    }
  };
  e.ParseError = f;
  function D2(i2, l) {
    let p = t.identifierModuleUrl(l), g2 = p != null ? "in ".concat(i2, " ").concat(t.identifierName(l), " in ").concat(p) : "in ".concat(i2, " ").concat(t.identifierName(l)), C2 = new c("", g2);
    return new n(new s2(C2, -1, -1, -1), new s2(C2, -1, -1, -1));
  }
  e.typeSourceSpan = D2;
  function v(i2, l, p) {
    let g2 = "in ".concat(i2, " ").concat(l, " in ").concat(p), C2 = new c("", g2);
    return new n(new s2(C2, -1, -1, -1), new s2(C2, -1, -1, -1));
  }
  e.r3JitTypeSourceSpan = v;
} }), Qc = I$1({ "src/utils/front-matter/parse.js"(e, r) {
  O();
  var t = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
  function s2(c) {
    let n = c.match(t);
    if (!n)
      return { content: c };
    let { startDelimiter: a3, language: f, value: D2 = "", endDelimiter: v } = n.groups, i2 = f.trim() || "yaml";
    if (a3 === "+++" && (i2 = "toml"), i2 !== "yaml" && a3 !== v)
      return { content: c };
    let [l] = n;
    return { frontMatter: { type: "front-matter", lang: i2, value: D2, startDelimiter: a3, endDelimiter: v, raw: l.replace(/\n$/, "") }, content: l.replace(/[^\n]/g, " ") + c.slice(l.length) };
  }
  r.exports = s2;
} }), as$1 = I$1({ "src/utils/get-last.js"(e, r) {
  O();
  var t = (s2) => s2[s2.length - 1];
  r.exports = t;
} }), Kc = I$1({ "src/common/parser-create-error.js"(e, r) {
  O();
  function t(s2, c) {
    let n = new SyntaxError(s2 + " (" + c.start.line + ":" + c.start.column + ")");
    return n.loc = c, n;
  }
  r.exports = t;
} }), is$1 = {};
ts(is$1, { default: () => Jc });
function Jc(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
var Zc$1 = Fe$1({ "node_modules/escape-string-regexp/index.js"() {
  O();
} }), os$1 = I$1({ "node_modules/semver/internal/debug.js"(e, r) {
  O();
  var t = typeof be$1 == "object" && be$1.env && be$1.env.NODE_DEBUG && /\bsemver\b/i.test(be$1.env.NODE_DEBUG) ? function() {
    for (var s2 = arguments.length, c = new Array(s2), n = 0; n < s2; n++)
      c[n] = arguments[n];
    return console.error("SEMVER", ...c);
  } : () => {
  };
  r.exports = t;
} }), cs$1 = I$1({ "node_modules/semver/internal/constants.js"(e, r) {
  O();
  var t = "2.0.0", s2 = 256, c = Number.MAX_SAFE_INTEGER || 9007199254740991, n = 16;
  r.exports = { SEMVER_SPEC_VERSION: t, MAX_LENGTH: s2, MAX_SAFE_INTEGER: c, MAX_SAFE_COMPONENT_LENGTH: n };
} }), eD = I$1({ "node_modules/semver/internal/re.js"(e, r) {
  O();
  var { MAX_SAFE_COMPONENT_LENGTH: t } = cs$1(), s2 = os$1();
  e = r.exports = {};
  var c = e.re = [], n = e.src = [], a3 = e.t = {}, f = 0, D2 = (v, i2, l) => {
    let p = f++;
    s2(v, p, i2), a3[v] = p, n[p] = i2, c[p] = new RegExp(i2, l ? "g" : void 0);
  };
  D2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), D2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), D2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), D2("MAINVERSION", "(".concat(n[a3.NUMERICIDENTIFIER], ")\\.(").concat(n[a3.NUMERICIDENTIFIER], ")\\.(").concat(n[a3.NUMERICIDENTIFIER], ")")), D2("MAINVERSIONLOOSE", "(".concat(n[a3.NUMERICIDENTIFIERLOOSE], ")\\.(").concat(n[a3.NUMERICIDENTIFIERLOOSE], ")\\.(").concat(n[a3.NUMERICIDENTIFIERLOOSE], ")")), D2("PRERELEASEIDENTIFIER", "(?:".concat(n[a3.NUMERICIDENTIFIER], "|").concat(n[a3.NONNUMERICIDENTIFIER], ")")), D2("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(n[a3.NUMERICIDENTIFIERLOOSE], "|").concat(n[a3.NONNUMERICIDENTIFIER], ")")), D2("PRERELEASE", "(?:-(".concat(n[a3.PRERELEASEIDENTIFIER], "(?:\\.").concat(n[a3.PRERELEASEIDENTIFIER], ")*))")), D2("PRERELEASELOOSE", "(?:-?(".concat(n[a3.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(n[a3.PRERELEASEIDENTIFIERLOOSE], ")*))")), D2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), D2("BUILD", "(?:\\+(".concat(n[a3.BUILDIDENTIFIER], "(?:\\.").concat(n[a3.BUILDIDENTIFIER], ")*))")), D2("FULLPLAIN", "v?".concat(n[a3.MAINVERSION]).concat(n[a3.PRERELEASE], "?").concat(n[a3.BUILD], "?")), D2("FULL", "^".concat(n[a3.FULLPLAIN], "$")), D2("LOOSEPLAIN", "[v=\\s]*".concat(n[a3.MAINVERSIONLOOSE]).concat(n[a3.PRERELEASELOOSE], "?").concat(n[a3.BUILD], "?")), D2("LOOSE", "^".concat(n[a3.LOOSEPLAIN], "$")), D2("GTLT", "((?:<|>)?=?)"), D2("XRANGEIDENTIFIERLOOSE", "".concat(n[a3.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), D2("XRANGEIDENTIFIER", "".concat(n[a3.NUMERICIDENTIFIER], "|x|X|\\*")), D2("XRANGEPLAIN", "[v=\\s]*(".concat(n[a3.XRANGEIDENTIFIER], ")(?:\\.(").concat(n[a3.XRANGEIDENTIFIER], ")(?:\\.(").concat(n[a3.XRANGEIDENTIFIER], ")(?:").concat(n[a3.PRERELEASE], ")?").concat(n[a3.BUILD], "?)?)?")), D2("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(n[a3.XRANGEIDENTIFIERLOOSE], ")(?:\\.(").concat(n[a3.XRANGEIDENTIFIERLOOSE], ")(?:\\.(").concat(n[a3.XRANGEIDENTIFIERLOOSE], ")(?:").concat(n[a3.PRERELEASELOOSE], ")?").concat(n[a3.BUILD], "?)?)?")), D2("XRANGE", "^".concat(n[a3.GTLT], "\\s*").concat(n[a3.XRANGEPLAIN], "$")), D2("XRANGELOOSE", "^".concat(n[a3.GTLT], "\\s*").concat(n[a3.XRANGEPLAINLOOSE], "$")), D2("COERCE", "(^|[^\\d])(\\d{1,".concat(t, "})(?:\\.(\\d{1,").concat(t, "}))?(?:\\.(\\d{1,").concat(t, "}))?(?:$|[^\\d])")), D2("COERCERTL", n[a3.COERCE], true), D2("LONETILDE", "(?:~>?)"), D2("TILDETRIM", "(\\s*)".concat(n[a3.LONETILDE], "\\s+"), true), e.tildeTrimReplace = "$1~", D2("TILDE", "^".concat(n[a3.LONETILDE]).concat(n[a3.XRANGEPLAIN], "$")), D2("TILDELOOSE", "^".concat(n[a3.LONETILDE]).concat(n[a3.XRANGEPLAINLOOSE], "$")), D2("LONECARET", "(?:\\^)"), D2("CARETTRIM", "(\\s*)".concat(n[a3.LONECARET], "\\s+"), true), e.caretTrimReplace = "$1^", D2("CARET", "^".concat(n[a3.LONECARET]).concat(n[a3.XRANGEPLAIN], "$")), D2("CARETLOOSE", "^".concat(n[a3.LONECARET]).concat(n[a3.XRANGEPLAINLOOSE], "$")), D2("COMPARATORLOOSE", "^".concat(n[a3.GTLT], "\\s*(").concat(n[a3.LOOSEPLAIN], ")$|^$")), D2("COMPARATOR", "^".concat(n[a3.GTLT], "\\s*(").concat(n[a3.FULLPLAIN], ")$|^$")), D2("COMPARATORTRIM", "(\\s*)".concat(n[a3.GTLT], "\\s*(").concat(n[a3.LOOSEPLAIN], "|").concat(n[a3.XRANGEPLAIN], ")"), true), e.comparatorTrimReplace = "$1$2$3", D2("HYPHENRANGE", "^\\s*(".concat(n[a3.XRANGEPLAIN], ")\\s+-\\s+(").concat(n[a3.XRANGEPLAIN], ")\\s*$")), D2("HYPHENRANGELOOSE", "^\\s*(".concat(n[a3.XRANGEPLAINLOOSE], ")\\s+-\\s+(").concat(n[a3.XRANGEPLAINLOOSE], ")\\s*$")), D2("STAR", "(<|>)?=?\\s*\\*"), D2("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), D2("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
} }), rD = I$1({ "node_modules/semver/internal/parse-options.js"(e, r) {
  O();
  var t = ["includePrerelease", "loose", "rtl"], s2 = (c) => c ? typeof c != "object" ? { loose: true } : t.filter((n) => c[n]).reduce((n, a3) => (n[a3] = true, n), {}) : {};
  r.exports = s2;
} }), tD = I$1({ "node_modules/semver/internal/identifiers.js"(e, r) {
  O();
  var t = /^[0-9]+$/, s2 = (n, a3) => {
    let f = t.test(n), D2 = t.test(a3);
    return f && D2 && (n = +n, a3 = +a3), n === a3 ? 0 : f && !D2 ? -1 : D2 && !f ? 1 : n < a3 ? -1 : 1;
  }, c = (n, a3) => s2(a3, n);
  r.exports = { compareIdentifiers: s2, rcompareIdentifiers: c };
} }), uD = I$1({ "node_modules/semver/classes/semver.js"(e, r) {
  O();
  var t = os$1(), { MAX_LENGTH: s2, MAX_SAFE_INTEGER: c } = cs$1(), { re: n, t: a3 } = eD(), f = rD(), { compareIdentifiers: D2 } = tD(), v = class {
    constructor(i2, l) {
      if (l = f(l), i2 instanceof v) {
        if (i2.loose === !!l.loose && i2.includePrerelease === !!l.includePrerelease)
          return i2;
        i2 = i2.version;
      } else if (typeof i2 != "string")
        throw new TypeError("Invalid Version: ".concat(i2));
      if (i2.length > s2)
        throw new TypeError("version is longer than ".concat(s2, " characters"));
      t("SemVer", i2, l), this.options = l, this.loose = !!l.loose, this.includePrerelease = !!l.includePrerelease;
      let p = i2.trim().match(l.loose ? n[a3.LOOSE] : n[a3.FULL]);
      if (!p)
        throw new TypeError("Invalid Version: ".concat(i2));
      if (this.raw = i2, this.major = +p[1], this.minor = +p[2], this.patch = +p[3], this.major > c || this.major < 0)
        throw new TypeError("Invalid major version");
      if (this.minor > c || this.minor < 0)
        throw new TypeError("Invalid minor version");
      if (this.patch > c || this.patch < 0)
        throw new TypeError("Invalid patch version");
      p[4] ? this.prerelease = p[4].split(".").map((g2) => {
        if (/^[0-9]+$/.test(g2)) {
          let C2 = +g2;
          if (C2 >= 0 && C2 < c)
            return C2;
        }
        return g2;
      }) : this.prerelease = [], this.build = p[5] ? p[5].split(".") : [], this.format();
    }
    format() {
      return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version;
    }
    toString() {
      return this.version;
    }
    compare(i2) {
      if (t("SemVer.compare", this.version, this.options, i2), !(i2 instanceof v)) {
        if (typeof i2 == "string" && i2 === this.version)
          return 0;
        i2 = new v(i2, this.options);
      }
      return i2.version === this.version ? 0 : this.compareMain(i2) || this.comparePre(i2);
    }
    compareMain(i2) {
      return i2 instanceof v || (i2 = new v(i2, this.options)), D2(this.major, i2.major) || D2(this.minor, i2.minor) || D2(this.patch, i2.patch);
    }
    comparePre(i2) {
      if (i2 instanceof v || (i2 = new v(i2, this.options)), this.prerelease.length && !i2.prerelease.length)
        return -1;
      if (!this.prerelease.length && i2.prerelease.length)
        return 1;
      if (!this.prerelease.length && !i2.prerelease.length)
        return 0;
      let l = 0;
      do {
        let p = this.prerelease[l], g2 = i2.prerelease[l];
        if (t("prerelease compare", l, p, g2), p === void 0 && g2 === void 0)
          return 0;
        if (g2 === void 0)
          return 1;
        if (p === void 0)
          return -1;
        if (p === g2)
          continue;
        return D2(p, g2);
      } while (++l);
    }
    compareBuild(i2) {
      i2 instanceof v || (i2 = new v(i2, this.options));
      let l = 0;
      do {
        let p = this.build[l], g2 = i2.build[l];
        if (t("prerelease compare", l, p, g2), p === void 0 && g2 === void 0)
          return 0;
        if (g2 === void 0)
          return 1;
        if (p === void 0)
          return -1;
        if (p === g2)
          continue;
        return D2(p, g2);
      } while (++l);
    }
    inc(i2, l) {
      switch (i2) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", l);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", l);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", l), this.inc("pre", l);
          break;
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", l), this.inc("pre", l);
          break;
        case "major":
          (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0)
            this.prerelease = [0];
          else {
            let p = this.prerelease.length;
            for (; --p >= 0; )
              typeof this.prerelease[p] == "number" && (this.prerelease[p]++, p = -2);
            p === -1 && this.prerelease.push(0);
          }
          l && (D2(this.prerelease[0], l) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [l, 0]) : this.prerelease = [l, 0]);
          break;
        default:
          throw new Error("invalid increment argument: ".concat(i2));
      }
      return this.format(), this.raw = this.version, this;
    }
  };
  r.exports = v;
} }), Ur = I$1({ "node_modules/semver/functions/compare.js"(e, r) {
  O();
  var t = uD(), s2 = (c, n, a3) => new t(c, a3).compare(new t(n, a3));
  r.exports = s2;
} }), nD = I$1({ "node_modules/semver/functions/lt.js"(e, r) {
  O();
  var t = Ur(), s2 = (c, n, a3) => t(c, n, a3) < 0;
  r.exports = s2;
} }), sD = I$1({ "node_modules/semver/functions/gte.js"(e, r) {
  O();
  var t = Ur(), s2 = (c, n, a3) => t(c, n, a3) >= 0;
  r.exports = s2;
} }), aD = I$1({ "src/utils/arrayify.js"(e, r) {
  O(), r.exports = (t, s2) => Object.entries(t).map((c) => {
    let [n, a3] = c;
    return Object.assign({ [s2]: n }, a3);
  });
} }), iD = I$1({ "package.json"(e, r) {
  r.exports = { version: "2.7.1" };
} }), oD = I$1({ "node_modules/outdent/lib/index.js"(e, r) {
  O(), Object.defineProperty(e, "__esModule", { value: true }), e.outdent = void 0;
  function t() {
    for (var S2 = [], N = 0; N < arguments.length; N++)
      S2[N] = arguments[N];
  }
  function s2() {
    return typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : c();
  }
  function c() {
    return { add: t, delete: t, get: t, set: t, has: function(S2) {
      return false;
    } };
  }
  var n = Object.prototype.hasOwnProperty, a3 = function(S2, N) {
    return n.call(S2, N);
  };
  function f(S2, N) {
    for (var b2 in N)
      a3(N, b2) && (S2[b2] = N[b2]);
    return S2;
  }
  var D2 = /^[ \t]*(?:\r\n|\r|\n)/, v = /(?:\r\n|\r|\n)[ \t]*$/, i2 = /^(?:[\r\n]|$)/, l = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p = /^[ \t]*[\r\n][ \t\r\n]*$/;
  function g2(S2, N, b2) {
    var j = 0, R = S2[0].match(l);
    R && (j = R[1].length);
    var U = "(\\r\\n|\\r|\\n).{0," + j + "}", k2 = new RegExp(U, "g");
    N && (S2 = S2.slice(1));
    var $ = b2.newline, L = b2.trimLeadingNewline, u = b2.trimTrailingNewline, o = typeof $ == "string", d4 = S2.length, h2 = S2.map(function(F, q) {
      return F = F.replace(k2, "$1"), q === 0 && L && (F = F.replace(D2, "")), q === d4 - 1 && u && (F = F.replace(v, "")), o && (F = F.replace(/\r\n|\n|\r/g, function(P) {
        return $;
      })), F;
    });
    return h2;
  }
  function C2(S2, N) {
    for (var b2 = "", j = 0, R = S2.length; j < R; j++)
      b2 += S2[j], j < R - 1 && (b2 += N[j]);
    return b2;
  }
  function m2(S2) {
    return a3(S2, "raw") && a3(S2, "length");
  }
  function B(S2) {
    var N = s2(), b2 = s2();
    function j(U) {
      for (var k2 = [], $ = 1; $ < arguments.length; $++)
        k2[$ - 1] = arguments[$];
      if (m2(U)) {
        var L = U, u = (k2[0] === j || k2[0] === w2) && p.test(L[0]) && i2.test(L[1]), o = u ? b2 : N, d4 = o.get(L);
        if (d4 || (d4 = g2(L, u, S2), o.set(L, d4)), k2.length === 0)
          return d4[0];
        var h2 = C2(d4, u ? k2.slice(1) : k2);
        return h2;
      } else
        return B(f(f({}, S2), U || {}));
    }
    var R = f(j, { string: function(U) {
      return g2([U], false, S2)[0];
    } });
    return R;
  }
  var w2 = B({ trimLeadingNewline: true, trimTrailingNewline: true });
  if (e.outdent = w2, e.default = w2, typeof r < "u")
    try {
      r.exports = w2, Object.defineProperty(w2, "__esModule", { value: true }), w2.default = w2, w2.outdent = w2;
    } catch {
    }
} }), cD = I$1({ "src/main/core-options.js"(e, r) {
  O();
  var { outdent: t } = oD(), s2 = "Config", c = "Editor", n = "Format", a3 = "Other", f = "Output", D2 = "Global", v = "Special", i2 = { cursorOffset: { since: "1.4.0", category: v, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: t(Hn$1 || (Hn$1 = ge$1([`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `]))), cliCategory: c }, endOfLine: { since: "1.15.0", category: D2, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: t(zn || (zn = ge$1([`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `]))) }] }, filepath: { since: "1.4.0", category: v, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: a3, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: v, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: a3 }, parser: { since: "0.0.10", category: D2, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (l) => typeof l == "string" || typeof l == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "acorn", since: "2.6.0", description: "JavaScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: D2, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (l) => typeof l == "string" || typeof l == "object", cliName: "plugin", cliCategory: s2 }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: D2, description: t(Wn$1 || (Wn$1 = ge$1([`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `]))), exception: (l) => typeof l == "string" || typeof l == "object", cliName: "plugin-search-dir", cliCategory: s2 }, printWidth: { since: "0.0.0", category: D2, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: v, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t(Yn$1 || (Yn$1 = ge$1([`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `]))), cliCategory: c }, rangeStart: { since: "1.4.0", category: v, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t(Qn || (Qn = ge$1([`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `]))), cliCategory: c }, requirePragma: { since: "1.7.0", category: v, type: "boolean", default: false, description: t(Kn || (Kn = ge$1([`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `]))), cliCategory: a3 }, tabWidth: { type: "int", category: D2, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: D2, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: D2, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
  r.exports = { CATEGORY_CONFIG: s2, CATEGORY_EDITOR: c, CATEGORY_FORMAT: n, CATEGORY_OTHER: a3, CATEGORY_OUTPUT: f, CATEGORY_GLOBAL: D2, CATEGORY_SPECIAL: v, options: i2 };
} }), DD = I$1({ "src/main/support.js"(e, r) {
  O();
  var t = { compare: Ur(), lt: nD(), gte: sD() }, s2 = aD(), c = iD().version, n = cD().options;
  function a3() {
    let { plugins: D2 = [], showUnreleased: v = false, showDeprecated: i2 = false, showInternal: l = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, p = c.split("-", 1)[0], g2 = D2.flatMap((S2) => S2.languages || []).filter(m2), C2 = s2(Object.assign({}, ...D2.map((S2) => {
      let { options: N } = S2;
      return N;
    }), n), "name").filter((S2) => m2(S2) && B(S2)).sort((S2, N) => S2.name === N.name ? 0 : S2.name < N.name ? -1 : 1).map(w2).map((S2) => {
      S2 = Object.assign({}, S2), Array.isArray(S2.default) && (S2.default = S2.default.length === 1 ? S2.default[0].value : S2.default.filter(m2).sort((b2, j) => t.compare(j.since, b2.since))[0].value), Array.isArray(S2.choices) && (S2.choices = S2.choices.filter((b2) => m2(b2) && B(b2)), S2.name === "parser" && f(S2, g2, D2));
      let N = Object.fromEntries(D2.filter((b2) => b2.defaultOptions && b2.defaultOptions[S2.name] !== void 0).map((b2) => [b2.name, b2.defaultOptions[S2.name]]));
      return Object.assign(Object.assign({}, S2), {}, { pluginDefaults: N });
    });
    return { languages: g2, options: C2 };
    function m2(S2) {
      return v || !("since" in S2) || S2.since && t.gte(p, S2.since);
    }
    function B(S2) {
      return i2 || !("deprecated" in S2) || S2.deprecated && t.lt(p, S2.deprecated);
    }
    function w2(S2) {
      if (l)
        return S2;
      return jc(S2, Mc);
    }
  }
  function f(D2, v, i2) {
    let l = new Set(D2.choices.map((p) => p.value));
    for (let p of v)
      if (p.parsers) {
        for (let g2 of p.parsers)
          if (!l.has(g2)) {
            l.add(g2);
            let C2 = i2.find((B) => B.parsers && B.parsers[g2]), m2 = p.name;
            C2 && C2.name && (m2 += " (plugin: ".concat(C2.name, ")")), D2.choices.push({ value: g2, description: m2 });
          }
      }
  }
  r.exports = { getSupportInfo: a3 };
} }), lD = I$1({ "src/utils/is-non-empty-array.js"(e, r) {
  O();
  function t(s2) {
    return Array.isArray(s2) && s2.length > 0;
  }
  r.exports = t;
} });
function hD() {
  let { onlyFirst: e = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
  return new RegExp(r, e ? void 0 : "g");
}
var pD = Fe$1({ "node_modules/strip-ansi/node_modules/ansi-regex/index.js"() {
  O();
} });
function fD(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a `string`, got `".concat(typeof e, "`"));
  return e.replace(hD(), "");
}
var dD = Fe$1({ "node_modules/strip-ansi/index.js"() {
  O(), pD();
} });
function ED(e) {
  return Number.isInteger(e) ? e >= 4352 && (e <= 4447 || e === 9001 || e === 9002 || 11904 <= e && e <= 12871 && e !== 12351 || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141) : false;
}
var CD = Fe$1({ "node_modules/is-fullwidth-code-point/index.js"() {
  O();
} }), mD = I$1({ "node_modules/emoji-regex/index.js"(e, r) {
  O(), r.exports = function() {
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
  };
} }), Ds$1 = {};
ts(Ds$1, { default: () => gD });
function gD(e) {
  if (typeof e != "string" || e.length === 0 || (e = fD(e), e.length === 0))
    return 0;
  e = e.replace((0, ls$1.default)(), "  ");
  let r = 0;
  for (let t = 0; t < e.length; t++) {
    let s2 = e.codePointAt(t);
    s2 <= 31 || s2 >= 127 && s2 <= 159 || s2 >= 768 && s2 <= 879 || (s2 > 65535 && t++, r += ED(s2) ? 2 : 1);
  }
  return r;
}
var ls$1, FD = Fe$1({ "node_modules/string-width/index.js"() {
  O(), dD(), CD(), ls$1 = Hc(mD());
} }), AD = I$1({ "src/utils/get-string-width.js"(e, r) {
  O();
  var t = (FD(), ns$1(Ds$1)).default, s2 = /[^\x20-\x7F]/;
  function c(n) {
    return n ? s2.test(n) ? t(n) : n.length : 0;
  }
  r.exports = c;
} }), Gr$1 = I$1({ "src/utils/text/skip.js"(e, r) {
  O();
  function t(f) {
    return (D2, v, i2) => {
      let l = i2 && i2.backwards;
      if (v === false)
        return false;
      let { length: p } = D2, g2 = v;
      for (; g2 >= 0 && g2 < p; ) {
        let C2 = D2.charAt(g2);
        if (f instanceof RegExp) {
          if (!f.test(C2))
            return g2;
        } else if (!f.includes(C2))
          return g2;
        l ? g2-- : g2++;
      }
      return g2 === -1 || g2 === p ? g2 : false;
    };
  }
  var s2 = t(/\s/), c = t(" 	"), n = t(",; 	"), a3 = t(/[^\n\r]/);
  r.exports = { skipWhitespace: s2, skipSpaces: c, skipToLineEnd: n, skipEverythingButNewLine: a3 };
} }), hs$1 = I$1({ "src/utils/text/skip-inline-comment.js"(e, r) {
  O();
  function t(s2, c) {
    if (c === false)
      return false;
    if (s2.charAt(c) === "/" && s2.charAt(c + 1) === "*") {
      for (let n = c + 2; n < s2.length; ++n)
        if (s2.charAt(n) === "*" && s2.charAt(n + 1) === "/")
          return n + 2;
    }
    return c;
  }
  r.exports = t;
} }), ps$1 = I$1({ "src/utils/text/skip-trailing-comment.js"(e, r) {
  O();
  var { skipEverythingButNewLine: t } = Gr$1();
  function s2(c, n) {
    return n === false ? false : c.charAt(n) === "/" && c.charAt(n + 1) === "/" ? t(c, n) : n;
  }
  r.exports = s2;
} }), fs$1 = I$1({ "src/utils/text/skip-newline.js"(e, r) {
  O();
  function t(s2, c, n) {
    let a3 = n && n.backwards;
    if (c === false)
      return false;
    let f = s2.charAt(c);
    if (a3) {
      if (s2.charAt(c - 1) === "\r" && f === `
`)
        return c - 2;
      if (f === `
` || f === "\r" || f === "\u2028" || f === "\u2029")
        return c - 1;
    } else {
      if (f === "\r" && s2.charAt(c + 1) === `
`)
        return c + 2;
      if (f === `
` || f === "\r" || f === "\u2028" || f === "\u2029")
        return c + 1;
    }
    return c;
  }
  r.exports = t;
} }), vD = I$1({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e, r) {
  O();
  var t = hs$1(), s2 = fs$1(), c = ps$1(), { skipSpaces: n } = Gr$1();
  function a3(f, D2) {
    let v = null, i2 = D2;
    for (; i2 !== v; )
      v = i2, i2 = n(f, i2), i2 = t(f, i2), i2 = c(f, i2), i2 = s2(f, i2);
    return i2;
  }
  r.exports = a3;
} }), _D = I$1({ "src/common/util.js"(e, r) {
  O();
  var { default: t } = (Zc$1(), ns$1(is$1)), s2 = as$1(), { getSupportInfo: c } = DD(), n = lD(), a3 = AD(), { skipWhitespace: f, skipSpaces: D2, skipToLineEnd: v, skipEverythingButNewLine: i2 } = Gr$1(), l = hs$1(), p = ps$1(), g2 = fs$1(), C2 = vD(), m2 = (_) => _[_.length - 2];
  function B(_) {
    return (E, A2, y) => {
      let x2 = y && y.backwards;
      if (A2 === false)
        return false;
      let { length: M2 } = E, V = A2;
      for (; V >= 0 && V < M2; ) {
        let W2 = E.charAt(V);
        if (_ instanceof RegExp) {
          if (!_.test(W2))
            return V;
        } else if (!_.includes(W2))
          return V;
        x2 ? V-- : V++;
      }
      return V === -1 || V === M2 ? V : false;
    };
  }
  function w2(_, E) {
    let A2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, y = D2(_, A2.backwards ? E - 1 : E, A2), x2 = g2(_, y, A2);
    return y !== x2;
  }
  function S2(_, E, A2) {
    for (let y = E; y < A2; ++y)
      if (_.charAt(y) === `
`)
        return true;
    return false;
  }
  function N(_, E, A2) {
    let y = A2(E) - 1;
    y = D2(_, y, { backwards: true }), y = g2(_, y, { backwards: true }), y = D2(_, y, { backwards: true });
    let x2 = g2(_, y, { backwards: true });
    return y !== x2;
  }
  function b2(_, E) {
    let A2 = null, y = E;
    for (; y !== A2; )
      A2 = y, y = v(_, y), y = l(_, y), y = D2(_, y);
    return y = p(_, y), y = g2(_, y), y !== false && w2(_, y);
  }
  function j(_, E, A2) {
    return b2(_, A2(E));
  }
  function R(_, E, A2) {
    return C2(_, A2(E));
  }
  function U(_, E, A2) {
    return _.charAt(R(_, E, A2));
  }
  function k2(_, E) {
    let A2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return D2(_, A2.backwards ? E - 1 : E, A2) !== E;
  }
  function $(_, E) {
    let A2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, y = 0;
    for (let x2 = A2; x2 < _.length; ++x2)
      _[x2] === "	" ? y = y + E - y % E : y++;
    return y;
  }
  function L(_, E) {
    let A2 = _.lastIndexOf(`
`);
    return A2 === -1 ? 0 : $(_.slice(A2 + 1).match(/^[\t ]*/)[0], E);
  }
  function u(_, E) {
    let A2 = { quote: '"', regex: /"/g, escaped: "&quot;" }, y = { quote: "'", regex: /'/g, escaped: "&apos;" }, x2 = E === "'" ? y : A2, M2 = x2 === y ? A2 : y, V = x2;
    if (_.includes(x2.quote) || _.includes(M2.quote)) {
      let W2 = (_.match(x2.regex) || []).length, Q = (_.match(M2.regex) || []).length;
      V = W2 > Q ? M2 : x2;
    }
    return V;
  }
  function o(_, E) {
    let A2 = _.slice(1, -1), y = E.parser === "json" || E.parser === "json5" && E.quoteProps === "preserve" && !E.singleQuote ? '"' : E.__isInHtmlAttribute ? "'" : u(A2, E.singleQuote ? "'" : '"').quote;
    return d4(A2, y, !(E.parser === "css" || E.parser === "less" || E.parser === "scss" || E.__embeddedInHtml));
  }
  function d4(_, E, A2) {
    let y = E === '"' ? "'" : '"', x2 = /\\(.)|(["'])/gs, M2 = _.replace(x2, (V, W2, Q) => W2 === y ? W2 : Q === E ? "\\" + Q : Q || (A2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(W2) ? W2 : "\\" + W2));
    return E + M2 + E;
  }
  function h2(_) {
    return _.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
  }
  function F(_, E) {
    let A2 = _.match(new RegExp("(".concat(t(E), ")+"), "g"));
    return A2 === null ? 0 : A2.reduce((y, x2) => Math.max(y, x2.length / E.length), 0);
  }
  function q(_, E) {
    let A2 = _.match(new RegExp("(".concat(t(E), ")+"), "g"));
    if (A2 === null)
      return 0;
    let y = /* @__PURE__ */ new Map(), x2 = 0;
    for (let M2 of A2) {
      let V = M2.length / E.length;
      y.set(V, true), V > x2 && (x2 = V);
    }
    for (let M2 = 1; M2 < x2; M2++)
      if (!y.get(M2))
        return M2;
    return x2 + 1;
  }
  function P(_, E) {
    (_.comments || (_.comments = [])).push(E), E.printed = false, E.nodeDescription = Z3(_);
  }
  function G(_, E) {
    E.leading = true, E.trailing = false, P(_, E);
  }
  function H3(_, E, A2) {
    E.leading = false, E.trailing = false, A2 && (E.marker = A2), P(_, E);
  }
  function K(_, E) {
    E.leading = false, E.trailing = true, P(_, E);
  }
  function z(_, E) {
    let { languages: A2 } = c({ plugins: E.plugins }), y = A2.find((x2) => {
      let { name: M2 } = x2;
      return M2.toLowerCase() === _;
    }) || A2.find((x2) => {
      let { aliases: M2 } = x2;
      return Array.isArray(M2) && M2.includes(_);
    }) || A2.find((x2) => {
      let { extensions: M2 } = x2;
      return Array.isArray(M2) && M2.includes(".".concat(_));
    });
    return y && y.parsers[0];
  }
  function Y3(_) {
    return _ && _.type === "front-matter";
  }
  function J2(_) {
    let E = /* @__PURE__ */ new WeakMap();
    return function(A2) {
      return E.has(A2) || E.set(A2, Symbol(_)), E.get(A2);
    };
  }
  function Z3(_) {
    let E = _.type || _.kind || "(unknown type)", A2 = String(_.name || _.id && (typeof _.id == "object" ? _.id.name : _.id) || _.key && (typeof _.key == "object" ? _.key.name : _.key) || _.value && (typeof _.value == "object" ? "" : String(_.value)) || _.operator || "");
    return A2.length > 20 && (A2 = A2.slice(0, 19) + "\u2026"), E + (A2 ? " " + A2 : "");
  }
  r.exports = { inferParserByLanguage: z, getStringWidth: a3, getMaxContinuousCount: F, getMinNotPresentContinuousCount: q, getPenultimate: m2, getLast: s2, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: C2, getNextNonSpaceNonCommentCharacterIndex: R, getNextNonSpaceNonCommentCharacter: U, skip: B, skipWhitespace: f, skipSpaces: D2, skipToLineEnd: v, skipEverythingButNewLine: i2, skipInlineComment: l, skipTrailingComment: p, skipNewline: g2, isNextLineEmptyAfterIndex: b2, isNextLineEmpty: j, isPreviousLineEmpty: N, hasNewline: w2, hasNewlineInRange: S2, hasSpaces: k2, getAlignmentSize: $, getIndentSize: L, getPreferredQuote: u, printString: o, printNumber: h2, makeString: d4, addLeadingComment: G, addDanglingComment: H3, addTrailingComment: K, isFrontMatterNode: Y3, isNonEmptyArray: n, createGroupIdMapper: J2 };
} }), SD = I$1({ "vendors/html-tag-names.json"(e, r) {
  r.exports = { htmlTagNames: ["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"] };
} }), ds$1 = I$1({ "src/language-html/utils/array-to-map.js"(e, r) {
  O();
  function t(s2) {
    let c = /* @__PURE__ */ Object.create(null);
    for (let n of s2)
      c[n] = true;
    return c;
  }
  r.exports = t;
} }), yD = I$1({ "src/language-html/utils/html-tag-names.js"(e, r) {
  O();
  var { htmlTagNames: t } = SD(), s2 = ds$1(), c = s2(t);
  r.exports = c;
} }), TD = I$1({ "vendors/html-element-attributes.json"(e, r) {
  r.exports = { htmlElementAttributes: { "*": ["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "slot", "spellcheck", "style", "tabindex", "title", "translate"], a: ["charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "target", "type"], applet: ["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"], area: ["alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "target", "type"], audio: ["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"], base: ["href", "target"], basefont: ["color", "face", "size"], blockquote: ["cite"], body: ["alink", "background", "bgcolor", "link", "text", "vlink"], br: ["clear"], button: ["disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "type", "value"], canvas: ["height", "width"], caption: ["align"], col: ["align", "char", "charoff", "span", "valign", "width"], colgroup: ["align", "char", "charoff", "span", "valign", "width"], data: ["value"], del: ["cite", "datetime"], details: ["open"], dialog: ["open"], dir: ["compact"], div: ["align"], dl: ["compact"], embed: ["height", "src", "type", "width"], fieldset: ["disabled", "form", "name"], font: ["color", "face", "size"], form: ["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"], frame: ["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"], frameset: ["cols", "rows"], h1: ["align"], h2: ["align"], h3: ["align"], h4: ["align"], h5: ["align"], h6: ["align"], head: ["profile"], hr: ["align", "noshade", "size", "width"], html: ["manifest", "version"], iframe: ["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"], img: ["align", "alt", "border", "crossorigin", "decoding", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"], input: ["accept", "align", "alt", "autocomplete", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "readonly", "required", "size", "src", "step", "type", "usemap", "value", "width"], ins: ["cite", "datetime"], isindex: ["prompt"], label: ["for", "form"], legend: ["align"], li: ["type", "value"], link: ["as", "charset", "color", "crossorigin", "disabled", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "referrerpolicy", "rel", "rev", "sizes", "target", "type"], map: ["name"], menu: ["compact"], meta: ["charset", "content", "http-equiv", "media", "name", "scheme"], meter: ["high", "low", "max", "min", "optimum", "value"], object: ["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "type", "typemustmatch", "usemap", "vspace", "width"], ol: ["compact", "reversed", "start", "type"], optgroup: ["disabled", "label"], option: ["disabled", "label", "selected", "value"], output: ["for", "form", "name"], p: ["align"], param: ["name", "type", "value", "valuetype"], pre: ["width"], progress: ["max", "value"], q: ["cite"], script: ["async", "charset", "crossorigin", "defer", "integrity", "language", "nomodule", "referrerpolicy", "src", "type"], select: ["autocomplete", "disabled", "form", "multiple", "name", "required", "size"], slot: ["name"], source: ["height", "media", "sizes", "src", "srcset", "type", "width"], style: ["media", "type"], table: ["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"], tbody: ["align", "char", "charoff", "valign"], td: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], textarea: ["autocomplete", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "wrap"], tfoot: ["align", "char", "charoff", "valign"], th: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], thead: ["align", "char", "charoff", "valign"], time: ["datetime"], tr: ["align", "bgcolor", "char", "charoff", "valign"], track: ["default", "kind", "label", "src", "srclang"], ul: ["compact", "type"], video: ["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"] } };
} }), BD = I$1({ "src/language-html/utils/map-object.js"(e, r) {
  O();
  function t(s2, c) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let [a3, f] of Object.entries(s2))
      n[a3] = c(f, a3);
    return n;
  }
  r.exports = t;
} }), bD = I$1({ "src/language-html/utils/html-elements-attributes.js"(e, r) {
  O();
  var { htmlElementAttributes: t } = TD(), s2 = BD(), c = ds$1(), n = s2(t, c);
  r.exports = n;
} }), wD = I$1({ "src/language-html/utils/is-unknown-namespace.js"(e, r) {
  O();
  function t(s2) {
    return s2.type === "element" && !s2.hasExplicitNamespace && !["html", "svg"].includes(s2.namespace);
  }
  r.exports = t;
} }), ND = I$1({ "src/language-html/pragma.js"(e, r) {
  O();
  function t(c) {
    return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(c);
  }
  function s2(c) {
    return `<!-- @format -->

` + c.replace(/^\s*\n/, "");
  }
  r.exports = { hasPragma: t, insertPragma: s2 };
} }), OD = I$1({ "src/language-html/ast.js"(e, r) {
  O();
  var t = { attrs: true, children: true }, s2 = /* @__PURE__ */ new Set(["parent"]), c = class {
    constructor() {
      let a3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      for (let f of /* @__PURE__ */ new Set([...s2, ...Object.keys(a3)]))
        this.setProperty(f, a3[f]);
    }
    setProperty(a3, f) {
      if (this[a3] !== f) {
        if (a3 in t && (f = f.map((D2) => this.createChild(D2))), !s2.has(a3)) {
          this[a3] = f;
          return;
        }
        Object.defineProperty(this, a3, { value: f, enumerable: false, configurable: true });
      }
    }
    map(a3) {
      let f;
      for (let D2 in t) {
        let v = this[D2];
        if (v) {
          let i2 = n(v, (l) => l.map(a3));
          f !== v && (f || (f = new c({ parent: this.parent })), f.setProperty(D2, i2));
        }
      }
      if (f)
        for (let D2 in this)
          D2 in t || (f[D2] = this[D2]);
      return a3(f || this);
    }
    walk(a3) {
      for (let f in t) {
        let D2 = this[f];
        if (D2)
          for (let v = 0; v < D2.length; v++)
            D2[v].walk(a3);
      }
      a3(this);
    }
    createChild(a3) {
      let f = a3 instanceof c ? a3.clone() : new c(a3);
      return f.setProperty("parent", this), f;
    }
    insertChildBefore(a3, f) {
      this.children.splice(this.children.indexOf(a3), 0, this.createChild(f));
    }
    removeChild(a3) {
      this.children.splice(this.children.indexOf(a3), 1);
    }
    replaceChild(a3, f) {
      this.children[this.children.indexOf(a3)] = this.createChild(f);
    }
    clone() {
      return new c(this);
    }
    get firstChild() {
      var a3;
      return (a3 = this.children) === null || a3 === void 0 ? void 0 : a3[0];
    }
    get lastChild() {
      var a3;
      return (a3 = this.children) === null || a3 === void 0 ? void 0 : a3[this.children.length - 1];
    }
    get prev() {
      var a3;
      return (a3 = this.parent) === null || a3 === void 0 ? void 0 : a3.children[this.parent.children.indexOf(this) - 1];
    }
    get next() {
      var a3;
      return (a3 = this.parent) === null || a3 === void 0 ? void 0 : a3.children[this.parent.children.indexOf(this) + 1];
    }
    get rawName() {
      return this.hasExplicitNamespace ? this.fullName : this.name;
    }
    get fullName() {
      return this.namespace ? this.namespace + ":" + this.name : this.name;
    }
    get attrMap() {
      return Object.fromEntries(this.attrs.map((a3) => [a3.fullName, a3.value]));
    }
  };
  function n(a3, f) {
    let D2 = a3.map(f);
    return D2.some((v, i2) => v !== a3[i2]) ? D2 : a3;
  }
  r.exports = { Node: c };
} }), qD = I$1({ "src/language-html/conditional-comment.js"(e, r) {
  O();
  var { ParseSourceSpan: t } = we$1(), s2 = [{ regex: /^(\[if([^\]]*)]>)(.*?)<!\s*\[endif]$/s, parse: n }, { regex: /^\[if([^\]]*)]><!$/, parse: a3 }, { regex: /^<!\s*\[endif]$/, parse: f }];
  function c(D2, v) {
    if (D2.value)
      for (let { regex: i2, parse: l } of s2) {
        let p = D2.value.match(i2);
        if (p)
          return l(D2, v, p);
      }
    return null;
  }
  function n(D2, v, i2) {
    let [, l, p, g2] = i2, C2 = 4 + l.length, m2 = D2.sourceSpan.start.moveBy(C2), B = m2.moveBy(g2.length), [w2, S2] = (() => {
      try {
        return [true, v(g2, m2).children];
      } catch {
        let N = { type: "text", value: g2, sourceSpan: new t(m2, B) };
        return [false, [N]];
      }
    })();
    return { type: "ieConditionalComment", complete: w2, children: S2, condition: p.trim().replace(/\s+/g, " "), sourceSpan: D2.sourceSpan, startSourceSpan: new t(D2.sourceSpan.start, m2), endSourceSpan: new t(B, D2.sourceSpan.end) };
  }
  function a3(D2, v, i2) {
    let [, l] = i2;
    return { type: "ieConditionalStartComment", condition: l.trim().replace(/\s+/g, " "), sourceSpan: D2.sourceSpan };
  }
  function f(D2) {
    return { type: "ieConditionalEndComment", sourceSpan: D2.sourceSpan };
  }
  r.exports = { parseIeConditionalComment: c };
} }), ID = I$1({ "src/language-html/loc.js"(e, r) {
  O();
  function t(c) {
    return c.sourceSpan.start.offset;
  }
  function s2(c) {
    return c.sourceSpan.end.offset;
  }
  r.exports = { locStart: t, locEnd: s2 };
} }), Ze$1 = I$1({ "node_modules/angular-html-parser/lib/compiler/src/ml_parser/tags.js"(e) {
  O(), Object.defineProperty(e, "__esModule", { value: true });
  (function(D2) {
    D2[D2.RAW_TEXT = 0] = "RAW_TEXT", D2[D2.ESCAPABLE_RAW_TEXT = 1] = "ESCAPABLE_RAW_TEXT", D2[D2.PARSABLE_DATA = 2] = "PARSABLE_DATA";
  })(e.TagContentType || (e.TagContentType = {}));
  function t(D2) {
    if (D2[0] != ":")
      return [null, D2];
    let v = D2.indexOf(":", 1);
    if (v == -1)
      throw new Error('Unsupported format "'.concat(D2, '" expecting ":namespace:name"'));
    return [D2.slice(1, v), D2.slice(v + 1)];
  }
  e.splitNsName = t;
  function s2(D2) {
    return t(D2)[1] === "ng-container";
  }
  e.isNgContainer = s2;
  function c(D2) {
    return t(D2)[1] === "ng-content";
  }
  e.isNgContent = c;
  function n(D2) {
    return t(D2)[1] === "ng-template";
  }
  e.isNgTemplate = n;
  function a3(D2) {
    return D2 === null ? null : t(D2)[0];
  }
  e.getNsPrefix = a3;
  function f(D2, v) {
    return D2 ? ":".concat(D2, ":").concat(v) : v;
  }
  e.mergeNsAndName = f, e.NAMED_ENTITIES = { Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}", Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\u2A3F", AMP: "&", amp: "&", And: "\u2A53", and: "\u2227", andand: "\u2A55", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsd: "\u2221", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", ap: "\u2248", apacir: "\u2A6F", apE: "\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5", Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", Barwed: "\u2306", barwed: "\u2305", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", Because: "\u2235", because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxDL: "\u2557", boxDl: "\u2556", boxdL: "\u2555", boxdl: "\u2510", boxDR: "\u2554", boxDr: "\u2553", boxdR: "\u2552", boxdr: "\u250C", boxH: "\u2550", boxh: "\u2500", boxHD: "\u2566", boxHd: "\u2564", boxhD: "\u2565", boxhd: "\u252C", boxHU: "\u2569", boxHu: "\u2567", boxhU: "\u2568", boxhu: "\u2534", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxUL: "\u255D", boxUl: "\u255C", boxuL: "\u255B", boxul: "\u2518", boxUR: "\u255A", boxUr: "\u2559", boxuR: "\u2558", boxur: "\u2514", boxV: "\u2551", boxv: "\u2502", boxVH: "\u256C", boxVh: "\u256B", boxvH: "\u256A", boxvh: "\u253C", boxVL: "\u2563", boxVl: "\u2562", boxvL: "\u2561", boxvl: "\u2524", boxVR: "\u2560", boxVr: "\u255F", boxvR: "\u255E", boxvr: "\u251C", bprime: "\u2035", Breve: "\u02D8", breve: "\u02D8", brvbar: "\xA6", Bscr: "\u212C", bscr: "\u{1D4B7}", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsol: "\\", bsolb: "\u29C5", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", Cap: "\u22D2", cap: "\u2229", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", CenterDot: "\xB7", centerdot: "\xB7", Cfr: "\u212D", cfr: "\u{1D520}", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", Chi: "\u03A7", chi: "\u03C7", cir: "\u25CB", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", Colon: "\u2237", colon: ":", Colone: "\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", Conint: "\u222F", conint: "\u222E", ContourIntegral: "\u222E", Copf: "\u2102", copf: "\u{1D554}", coprod: "\u2210", Coproduct: "\u2210", COPY: "\xA9", copy: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", Cross: "\u2A2F", cross: "\u2717", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", Cup: "\u22D3", cup: "\u222A", cupbrcap: "\u2A48", CupCap: "\u224D", cupcap: "\u2A46", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", Dagger: "\u2021", dagger: "\u2020", daleth: "\u2138", Darr: "\u21A1", dArr: "\u21D3", darr: "\u2193", dash: "\u2010", Dashv: "\u2AE4", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", DD: "\u2145", dd: "\u2146", ddagger: "\u2021", ddarr: "\u21CA", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", Diamond: "\u22C4", diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}", dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrow: "\u2193", Downarrow: "\u21D3", downarrow: "\u2193", DownArrowBar: "\u2913", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVector: "\u21BD", DownLeftVectorBar: "\u2956", DownRightTeeVector: "\u295F", DownRightVector: "\u21C1", DownRightVectorBar: "\u2957", DownTee: "\u22A4", DownTeeArrow: "\u21A7", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}", dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9", easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", ecir: "\u2256", Ecirc: "\xCA", ecirc: "\xEA", ecolon: "\u2255", Ecy: "\u042D", ecy: "\u044D", eDDot: "\u2A77", Edot: "\u0116", eDot: "\u2251", edot: "\u0117", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}", eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp: "\u2003", emsp13: "\u2004", emsp14: "\u2005", ENG: "\u014A", eng: "\u014B", ensp: "\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", Escr: "\u2130", escr: "\u212F", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", ExponentialE: "\u2147", exponentiale: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", ForAll: "\u2200", forall: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", Fscr: "\u2131", fscr: "\u{1D4BB}", gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F", Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", gE: "\u2267", ge: "\u2265", gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", ges: "\u2A7E", gescc: "\u2AA9", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", Gg: "\u22D9", gg: "\u226B", ggg: "\u22D9", gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gl: "\u2277", gla: "\u2AA5", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gnE: "\u2269", gne: "\u2A88", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", GT: ">", Gt: "\u226B", gt: ">", gtcc: "\u2AA7", gtcir: "\u2A7A", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", hArr: "\u21D4", harr: "\u2194", harrcir: "\u2948", harrw: "\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", Hfr: "\u210C", hfr: "\u{1D525}", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", Hopf: "\u210D", hopf: "\u{1D559}", horbar: "\u2015", HorizontalLine: "\u2500", Hscr: "\u210B", hscr: "\u{1D4BD}", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", Ifr: "\u2111", ifr: "\u{1D526}", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Im: "\u2111", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", in: "\u2208", incare: "\u2105", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", Int: "\u222C", int: "\u222B", intcal: "\u22BA", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", Iscr: "\u2110", iscr: "\u{1D4BE}", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}", Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA", kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", Lang: "\u27EA", lang: "\u27E8", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", Larr: "\u219E", lArr: "\u21D0", larr: "\u2190", larrb: "\u21E4", larrbfs: "\u291F", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", lat: "\u2AAB", lAtail: "\u291B", latail: "\u2919", late: "\u2AAD", lates: "\u2AAD\uFE00", lBarr: "\u290E", lbarr: "\u290C", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", lE: "\u2266", le: "\u2264", LeftAngleBracket: "\u27E8", LeftArrow: "\u2190", Leftarrow: "\u21D0", leftarrow: "\u2190", LeftArrowBar: "\u21E4", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVector: "\u21C3", LeftDownVectorBar: "\u2959", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrow: "\u2194", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTee: "\u22A3", LeftTeeArrow: "\u21A4", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangle: "\u22B2", LeftTriangleBar: "\u29CF", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVector: "\u21BF", LeftUpVectorBar: "\u2958", LeftVector: "\u21BC", LeftVectorBar: "\u2952", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", les: "\u2A7D", lescc: "\u2AA8", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", Ll: "\u22D8", ll: "\u226A", llarr: "\u21C7", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoust: "\u23B0", lmoustache: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lnE: "\u2268", lne: "\u2A87", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftarrow: "\u27F5", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\u27FA", longleftrightarrow: "\u27F7", longmapsto: "\u27FC", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", longrightarrow: "\u27F6", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", Lscr: "\u2112", lscr: "\u{1D4C1}", Lsh: "\u21B0", lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\u0142", LT: "<", Lt: "\u226A", lt: "<", ltcc: "\u2AA6", ltcir: "\u2A79", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", mid: "\u2223", midast: "*", midcir: "\u2AF0", middot: "\xB7", minus: "\u2212", minusb: "\u229F", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\u2213", Mscr: "\u2133", mscr: "\u{1D4C2}", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natur: "\u266E", natural: "\u266E", naturals: "\u2115", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D", ncy: "\u043D", ndash: "\u2013", ne: "\u2260", nearhk: "\u2924", neArr: "\u21D7", nearr: "\u2197", nearrow: "\u2197", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: `
`, nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F", nGtv: "\u226B\u0338", nhArr: "\u21CE", nharr: "\u21AE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\u040A", njcy: "\u045A", nlArr: "\u21CD", nlarr: "\u219A", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nLeftarrow: "\u21CD", nleftarrow: "\u219A", nLeftrightarrow: "\u21CE", nleftrightarrow: "\u21AE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", Nopf: "\u2115", nopf: "\u{1D55F}", Not: "\u2AEC", not: "\xAC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangle: "\u22EA", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangle: "\u22EB", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", npar: "\u2226", nparallel: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", npre: "\u2AAF\u0338", nprec: "\u2280", npreceq: "\u2AAF\u0338", nrArr: "\u21CF", nrarr: "\u219B", nrarrc: "\u2933\u0338", nrarrw: "\u219D\u0338", nRightarrow: "\u21CF", nrightarrow: "\u219B", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nVDash: "\u22AF", nVdash: "\u22AE", nvDash: "\u22AD", nvdash: "\u22AC", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwArr: "\u21D6", nwarr: "\u2196", nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", ocir: "\u229A", Ocirc: "\xD4", ocirc: "\xF4", Ocy: "\u041E", ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", Or: "\u2A54", or: "\u2228", orarr: "\u21BB", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\xF5", Otimes: "\u2A37", otimes: "\u2297", otimesas: "\u2A36", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", par: "\u2225", para: "\xB6", parallel: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plus: "+", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", Popf: "\u2119", popf: "\u{1D561}", pound: "\xA3", Pr: "\u2ABB", pr: "\u227A", prap: "\u2AB7", prcue: "\u227C", prE: "\u2AB3", pre: "\u2AAF", prec: "\u227A", precapprox: "\u2AB7", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", precsim: "\u227E", Prime: "\u2033", prime: "\u2032", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportion: "\u2237", Proportional: "\u221D", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}", qfr: "\u{1D52E}", qint: "\u2A0C", Qopf: "\u211A", qopf: "\u{1D562}", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", QUOT: '"', quot: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", Rang: "\u27EB", rang: "\u27E9", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", Rarr: "\u21A0", rArr: "\u21D2", rarr: "\u2192", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", rAtail: "\u291C", ratail: "\u291A", ratio: "\u2236", rationals: "\u211A", RBarr: "\u2910", rBarr: "\u290F", rbarr: "\u290D", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309", rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", Re: "\u211C", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", rect: "\u25AD", REG: "\xAE", reg: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", Rfr: "\u211C", rfr: "\u{1D52F}", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrow: "\u2192", Rightarrow: "\u21D2", rightarrow: "\u2192", RightArrowBar: "\u21E5", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVector: "\u21C2", RightDownVectorBar: "\u2955", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTee: "\u22A2", RightTeeArrow: "\u21A6", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangle: "\u22B3", RightTriangleBar: "\u29D0", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVector: "\u21BE", RightUpVectorBar: "\u2954", RightVector: "\u21C0", RightVectorBar: "\u2953", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoust: "\u23B1", rmoustache: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", Ropf: "\u211D", ropf: "\u{1D563}", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", Rscr: "\u211B", rscr: "\u{1D4C7}", Rsh: "\u21B1", rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\u015A", sacute: "\u015B", sbquo: "\u201A", Sc: "\u2ABC", sc: "\u227B", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", sccue: "\u227D", scE: "\u2AB4", sce: "\u2AB0", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdot: "\u22C5", sdotb: "\u22A1", sdote: "\u2A66", searhk: "\u2925", seArr: "\u21D8", searr: "\u2198", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", sol: "/", solb: "\u29C4", solbar: "\u233F", Sopf: "\u{1D54A}", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", squ: "\u25A1", Square: "\u25A1", square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squf: "\u25AA", srarr: "\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", Sub: "\u22D0", sub: "\u2282", subdot: "\u2ABD", subE: "\u2AC5", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", Subset: "\u22D0", subset: "\u2282", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succ: "\u227B", succapprox: "\u2AB8", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", Sum: "\u2211", sum: "\u2211", sung: "\u266A", Sup: "\u22D1", sup: "\u2283", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", supdot: "\u2ABE", supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", Supset: "\u22D1", supset: "\u2283", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swArr: "\u21D9", swarr: "\u2199", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4", tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", Therefore: "\u2234", therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", thinsp: "\u2009", ThinSpace: "\u2009", thkap: "\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", Tilde: "\u223C", tilde: "\u02DC", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", times: "\xD7", timesb: "\u22A0", timesbar: "\u2A31", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", top: "\u22A4", topbot: "\u2336", topcir: "\u2AF1", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", TRADE: "\u2122", trade: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", Uarr: "\u219F", uArr: "\u21D1", uarr: "\u2191", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB", ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}", uopf: "\u{1D566}", UpArrow: "\u2191", Uparrow: "\u21D1", uparrow: "\u2191", UpArrowBar: "\u2912", UpArrowDownArrow: "\u21C5", UpDownArrow: "\u2195", Updownarrow: "\u21D5", updownarrow: "\u2195", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", Upsi: "\u03D2", upsi: "\u03C5", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5", UpTee: "\u22A5", UpTeeArrow: "\u21A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", vArr: "\u21D5", varr: "\u2195", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", Vbar: "\u2AEB", vBar: "\u2AE8", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", VDash: "\u22AB", Vdash: "\u22A9", vDash: "\u22A8", vdash: "\u22A2", Vdashl: "\u2AE6", Vee: "\u22C1", vee: "\u2228", veebar: "\u22BB", veeeq: "\u225A", vellip: "\u22EE", Verbar: "\u2016", verbar: "|", Vert: "\u2016", vert: "|", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", Wedge: "\u22C0", wedge: "\u2227", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", Xfr: "\u{1D51B}", xfr: "\u{1D535}", xhArr: "\u27FA", xharr: "\u27F7", Xi: "\u039E", xi: "\u03BE", xlArr: "\u27F8", xlarr: "\u27F5", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrArr: "\u27F9", xrarr: "\u27F6", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}", yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E", yucy: "\u044E", Yuml: "\u0178", yuml: "\xFF", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", Zfr: "\u2128", zfr: "\u{1D537}", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", Zopf: "\u2124", zopf: "\u{1D56B}", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" }, e.NGSP_UNICODE = "\uE500", e.NAMED_ENTITIES.ngsp = e.NGSP_UNICODE;
} }), Es$1 = I$1({ "node_modules/angular-html-parser/lib/compiler/src/ml_parser/html_tags.js"(e) {
  O(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Ze$1(), t = class {
    constructor() {
      let { closedByChildren: a3, implicitNamespacePrefix: f, contentType: D2 = r.TagContentType.PARSABLE_DATA, closedByParent: v = false, isVoid: i2 = false, ignoreFirstLf: l = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.closedByChildren = {}, this.closedByParent = false, this.canSelfClose = false, a3 && a3.length > 0 && a3.forEach((p) => this.closedByChildren[p] = true), this.isVoid = i2, this.closedByParent = v || i2, this.implicitNamespacePrefix = f || null, this.contentType = D2, this.ignoreFirstLf = l;
    }
    isClosedByChild(a3) {
      return this.isVoid || a3.toLowerCase() in this.closedByChildren;
    }
  };
  e.HtmlTagDefinition = t;
  var s2, c;
  function n(a3) {
    return c || (s2 = new t(), c = { base: new t({ isVoid: true }), meta: new t({ isVoid: true }), area: new t({ isVoid: true }), embed: new t({ isVoid: true }), link: new t({ isVoid: true }), img: new t({ isVoid: true }), input: new t({ isVoid: true }), param: new t({ isVoid: true }), hr: new t({ isVoid: true }), br: new t({ isVoid: true }), source: new t({ isVoid: true }), track: new t({ isVoid: true }), wbr: new t({ isVoid: true }), p: new t({ closedByChildren: ["address", "article", "aside", "blockquote", "div", "dl", "fieldset", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"], closedByParent: true }), thead: new t({ closedByChildren: ["tbody", "tfoot"] }), tbody: new t({ closedByChildren: ["tbody", "tfoot"], closedByParent: true }), tfoot: new t({ closedByChildren: ["tbody"], closedByParent: true }), tr: new t({ closedByChildren: ["tr"], closedByParent: true }), td: new t({ closedByChildren: ["td", "th"], closedByParent: true }), th: new t({ closedByChildren: ["td", "th"], closedByParent: true }), col: new t({ isVoid: true }), svg: new t({ implicitNamespacePrefix: "svg" }), math: new t({ implicitNamespacePrefix: "math" }), li: new t({ closedByChildren: ["li"], closedByParent: true }), dt: new t({ closedByChildren: ["dt", "dd"] }), dd: new t({ closedByChildren: ["dt", "dd"], closedByParent: true }), rb: new t({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), rt: new t({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), rtc: new t({ closedByChildren: ["rb", "rtc", "rp"], closedByParent: true }), rp: new t({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), optgroup: new t({ closedByChildren: ["optgroup"], closedByParent: true }), option: new t({ closedByChildren: ["option", "optgroup"], closedByParent: true }), pre: new t({ ignoreFirstLf: true }), listing: new t({ ignoreFirstLf: true }), style: new t({ contentType: r.TagContentType.RAW_TEXT }), script: new t({ contentType: r.TagContentType.RAW_TEXT }), title: new t({ contentType: r.TagContentType.ESCAPABLE_RAW_TEXT }), textarea: new t({ contentType: r.TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }) }), c[a3] || s2;
  }
  e.getHtmlTagDefinition = n;
} }), RD = I$1({ "node_modules/angular-html-parser/lib/compiler/src/ast_path.js"(e) {
  O(), Object.defineProperty(e, "__esModule", { value: true });
  var r = class {
    constructor(t) {
      let s2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
      this.path = t, this.position = s2;
    }
    get empty() {
      return !this.path || !this.path.length;
    }
    get head() {
      return this.path[0];
    }
    get tail() {
      return this.path[this.path.length - 1];
    }
    parentOf(t) {
      return t && this.path[this.path.indexOf(t) - 1];
    }
    childOf(t) {
      return this.path[this.path.indexOf(t) + 1];
    }
    first(t) {
      for (let s2 = this.path.length - 1; s2 >= 0; s2--) {
        let c = this.path[s2];
        if (c instanceof t)
          return c;
      }
    }
    push(t) {
      this.path.push(t);
    }
    pop() {
      return this.path.pop();
    }
  };
  e.AstPath = r;
} }), Cs$1 = I$1({ "node_modules/angular-html-parser/lib/compiler/src/ml_parser/ast.js"(e) {
  O(), Object.defineProperty(e, "__esModule", { value: true });
  var r = RD(), t = class {
    constructor(C2, m2, B) {
      this.value = C2, this.sourceSpan = m2, this.i18n = B, this.type = "text";
    }
    visit(C2, m2) {
      return C2.visitText(this, m2);
    }
  };
  e.Text = t;
  var s2 = class {
    constructor(C2, m2) {
      this.value = C2, this.sourceSpan = m2, this.type = "cdata";
    }
    visit(C2, m2) {
      return C2.visitCdata(this, m2);
    }
  };
  e.CDATA = s2;
  var c = class {
    constructor(C2, m2, B, w2, S2, N) {
      this.switchValue = C2, this.type = m2, this.cases = B, this.sourceSpan = w2, this.switchValueSourceSpan = S2, this.i18n = N;
    }
    visit(C2, m2) {
      return C2.visitExpansion(this, m2);
    }
  };
  e.Expansion = c;
  var n = class {
    constructor(C2, m2, B, w2, S2) {
      this.value = C2, this.expression = m2, this.sourceSpan = B, this.valueSourceSpan = w2, this.expSourceSpan = S2;
    }
    visit(C2, m2) {
      return C2.visitExpansionCase(this, m2);
    }
  };
  e.ExpansionCase = n;
  var a3 = class {
    constructor(C2, m2, B) {
      let w2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, S2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null, N = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null;
      this.name = C2, this.value = m2, this.sourceSpan = B, this.valueSpan = w2, this.nameSpan = S2, this.i18n = N, this.type = "attribute";
    }
    visit(C2, m2) {
      return C2.visitAttribute(this, m2);
    }
  };
  e.Attribute = a3;
  var f = class {
    constructor(C2, m2, B, w2) {
      let S2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null, N = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null, b2 = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null, j = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null;
      this.name = C2, this.attrs = m2, this.children = B, this.sourceSpan = w2, this.startSourceSpan = S2, this.endSourceSpan = N, this.nameSpan = b2, this.i18n = j, this.type = "element";
    }
    visit(C2, m2) {
      return C2.visitElement(this, m2);
    }
  };
  e.Element = f;
  var D2 = class {
    constructor(C2, m2) {
      this.value = C2, this.sourceSpan = m2, this.type = "comment";
    }
    visit(C2, m2) {
      return C2.visitComment(this, m2);
    }
  };
  e.Comment = D2;
  var v = class {
    constructor(C2, m2) {
      this.value = C2, this.sourceSpan = m2, this.type = "docType";
    }
    visit(C2, m2) {
      return C2.visitDocType(this, m2);
    }
  };
  e.DocType = v;
  function i2(C2, m2) {
    let B = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, w2 = [], S2 = C2.visit ? (N) => C2.visit(N, B) || N.visit(C2, B) : (N) => N.visit(C2, B);
    return m2.forEach((N) => {
      let b2 = S2(N);
      b2 && w2.push(b2);
    }), w2;
  }
  e.visitAll = i2;
  var l = class {
    constructor() {
    }
    visitElement(C2, m2) {
      this.visitChildren(m2, (B) => {
        B(C2.attrs), B(C2.children);
      });
    }
    visitAttribute(C2, m2) {
    }
    visitText(C2, m2) {
    }
    visitCdata(C2, m2) {
    }
    visitComment(C2, m2) {
    }
    visitDocType(C2, m2) {
    }
    visitExpansion(C2, m2) {
      return this.visitChildren(m2, (B) => {
        B(C2.cases);
      });
    }
    visitExpansionCase(C2, m2) {
    }
    visitChildren(C2, m2) {
      let B = [], w2 = this;
      function S2(N) {
        N && B.push(i2(w2, N, C2));
      }
      return m2(S2), Array.prototype.concat.apply([], B);
    }
  };
  e.RecursiveVisitor = l;
  function p(C2) {
    let m2 = C2.sourceSpan.start.offset, B = C2.sourceSpan.end.offset;
    return C2 instanceof f && (C2.endSourceSpan ? B = C2.endSourceSpan.end.offset : C2.children && C2.children.length && (B = p(C2.children[C2.children.length - 1]).end)), { start: m2, end: B };
  }
  function g2(C2, m2) {
    let B = [], w2 = new class extends l {
      visit(S2, N) {
        let b2 = p(S2);
        if (b2.start <= m2 && m2 < b2.end)
          B.push(S2);
        else
          return true;
      }
    }();
    return i2(w2, C2), new r.AstPath(B, m2);
  }
  e.findNode = g2;
} }), xD = I$1({ "node_modules/angular-html-parser/lib/compiler/src/assertions.js"(e) {
  O(), Object.defineProperty(e, "__esModule", { value: true });
  function r(c, n) {
    if (n != null) {
      if (!Array.isArray(n))
        throw new Error("Expected '".concat(c, "' to be an array of strings."));
      for (let a3 = 0; a3 < n.length; a3 += 1)
        if (typeof n[a3] != "string")
          throw new Error("Expected '".concat(c, "' to be an array of strings."));
    }
  }
  e.assertArrayOfStrings = r;
  var t = [/^\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\/\//];
  function s2(c, n) {
    if (n != null && !(Array.isArray(n) && n.length == 2))
      throw new Error("Expected '".concat(c, "' to be an array, [start, end]."));
    if (n != null) {
      let a3 = n[0], f = n[1];
      t.forEach((D2) => {
        if (D2.test(a3) || D2.test(f))
          throw new Error("['".concat(a3, "', '").concat(f, "'] contains unusable interpolation symbol."));
      });
    }
  }
  e.assertInterpolationSymbols = s2;
} }), PD = I$1({ "node_modules/angular-html-parser/lib/compiler/src/ml_parser/interpolation_config.js"(e) {
  O(), Object.defineProperty(e, "__esModule", { value: true });
  var r = xD(), t = class {
    constructor(s2, c) {
      this.start = s2, this.end = c;
    }
    static fromArray(s2) {
      return s2 ? (r.assertInterpolationSymbols("interpolation", s2), new t(s2[0], s2[1])) : e.DEFAULT_INTERPOLATION_CONFIG;
    }
  };
  e.InterpolationConfig = t, e.DEFAULT_INTERPOLATION_CONFIG = new t("{{", "}}");
} }), kD = I$1({ "node_modules/angular-html-parser/lib/compiler/src/ml_parser/lexer.js"(e) {
  O(), Object.defineProperty(e, "__esModule", { value: true });
  var r = ss$1(), t = we$1(), s2 = PD(), c = Ze$1(), n;
  (function(u) {
    u[u.TAG_OPEN_START = 0] = "TAG_OPEN_START", u[u.TAG_OPEN_END = 1] = "TAG_OPEN_END", u[u.TAG_OPEN_END_VOID = 2] = "TAG_OPEN_END_VOID", u[u.TAG_CLOSE = 3] = "TAG_CLOSE", u[u.TEXT = 4] = "TEXT", u[u.ESCAPABLE_RAW_TEXT = 5] = "ESCAPABLE_RAW_TEXT", u[u.RAW_TEXT = 6] = "RAW_TEXT", u[u.COMMENT_START = 7] = "COMMENT_START", u[u.COMMENT_END = 8] = "COMMENT_END", u[u.CDATA_START = 9] = "CDATA_START", u[u.CDATA_END = 10] = "CDATA_END", u[u.ATTR_NAME = 11] = "ATTR_NAME", u[u.ATTR_QUOTE = 12] = "ATTR_QUOTE", u[u.ATTR_VALUE = 13] = "ATTR_VALUE", u[u.DOC_TYPE_START = 14] = "DOC_TYPE_START", u[u.DOC_TYPE_END = 15] = "DOC_TYPE_END", u[u.EXPANSION_FORM_START = 16] = "EXPANSION_FORM_START", u[u.EXPANSION_CASE_VALUE = 17] = "EXPANSION_CASE_VALUE", u[u.EXPANSION_CASE_EXP_START = 18] = "EXPANSION_CASE_EXP_START", u[u.EXPANSION_CASE_EXP_END = 19] = "EXPANSION_CASE_EXP_END", u[u.EXPANSION_FORM_END = 20] = "EXPANSION_FORM_END", u[u.EOF = 21] = "EOF";
  })(n = e.TokenType || (e.TokenType = {}));
  var a3 = class {
    constructor(u, o, d4) {
      this.type = u, this.parts = o, this.sourceSpan = d4;
    }
  };
  e.Token = a3;
  var f = class extends t.ParseError {
    constructor(u, o, d4) {
      super(d4, u), this.tokenType = o;
    }
  };
  e.TokenError = f;
  var D2 = class {
    constructor(u, o) {
      this.tokens = u, this.errors = o;
    }
  };
  e.TokenizeResult = D2;
  function v(u, o, d4) {
    let h2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return new C2(new t.ParseSourceFile(u, o), d4, h2).tokenize();
  }
  e.tokenize = v;
  var i2 = /\r\n?/g;
  function l(u) {
    let o = u === r.$EOF ? "EOF" : String.fromCharCode(u);
    return 'Unexpected character "'.concat(o, '"');
  }
  function p(u) {
    return 'Unknown entity "'.concat(u, '" - use the "&#<decimal>;" or  "&#x<hex>;" syntax');
  }
  var g2 = class {
    constructor(u) {
      this.error = u;
    }
  }, C2 = class {
    constructor(u, o, d4) {
      this._getTagContentType = o, this._currentTokenStart = null, this._currentTokenType = null, this._expansionCaseStack = [], this._inInterpolation = false, this._fullNameStack = [], this.tokens = [], this.errors = [], this._tokenizeIcu = d4.tokenizeExpansionForms || false, this._interpolationConfig = d4.interpolationConfig || s2.DEFAULT_INTERPOLATION_CONFIG, this._leadingTriviaCodePoints = d4.leadingTriviaChars && d4.leadingTriviaChars.map((F) => F.codePointAt(0) || 0), this._canSelfClose = d4.canSelfClose || false, this._allowHtmComponentClosingTags = d4.allowHtmComponentClosingTags || false;
      let h2 = d4.range || { endPos: u.content.length, startPos: 0, startLine: 0, startCol: 0 };
      this._cursor = d4.escapedString ? new $(u, h2) : new k2(u, h2);
      try {
        this._cursor.init();
      } catch (F) {
        this.handleError(F);
      }
    }
    _processCarriageReturns(u) {
      return u.replace(i2, `
`);
    }
    tokenize() {
      for (; this._cursor.peek() !== r.$EOF; ) {
        let u = this._cursor.clone();
        try {
          if (this._attemptCharCode(r.$LT))
            if (this._attemptCharCode(r.$BANG))
              this._attemptStr("[CDATA[") ? this._consumeCdata(u) : this._attemptStr("--") ? this._consumeComment(u) : this._attemptStrCaseInsensitive("doctype") ? this._consumeDocType(u) : this._consumeBogusComment(u);
            else if (this._attemptCharCode(r.$SLASH))
              this._consumeTagClose(u);
            else {
              let o = this._cursor.clone();
              this._attemptCharCode(r.$QUESTION) ? (this._cursor = o, this._consumeBogusComment(u)) : this._consumeTagOpen(u);
            }
          else
            this._tokenizeIcu && this._tokenizeExpansionForm() || this._consumeText();
        } catch (o) {
          this.handleError(o);
        }
      }
      return this._beginToken(n.EOF), this._endToken([]), new D2(U(this.tokens), this.errors);
    }
    _tokenizeExpansionForm() {
      if (this.isExpansionFormStart())
        return this._consumeExpansionFormStart(), true;
      if (b2(this._cursor.peek()) && this._isInExpansionForm())
        return this._consumeExpansionCaseStart(), true;
      if (this._cursor.peek() === r.$RBRACE) {
        if (this._isInExpansionCase())
          return this._consumeExpansionCaseEnd(), true;
        if (this._isInExpansionForm())
          return this._consumeExpansionFormEnd(), true;
      }
      return false;
    }
    _beginToken(u) {
      let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._cursor.clone();
      this._currentTokenStart = o, this._currentTokenType = u;
    }
    _endToken(u) {
      let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._cursor.clone();
      if (this._currentTokenStart === null)
        throw new f("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(o));
      if (this._currentTokenType === null)
        throw new f("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
      let d4 = new a3(this._currentTokenType, u, this._cursor.getSpan(this._currentTokenStart, this._leadingTriviaCodePoints));
      return this.tokens.push(d4), this._currentTokenStart = null, this._currentTokenType = null, d4;
    }
    _createError(u, o) {
      this._isInExpansionForm() && (u += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`);
      let d4 = new f(u, this._currentTokenType, o);
      return this._currentTokenStart = null, this._currentTokenType = null, new g2(d4);
    }
    handleError(u) {
      if (u instanceof L && (u = this._createError(u.msg, this._cursor.getSpan(u.cursor))), u instanceof g2)
        this.errors.push(u.error);
      else
        throw u;
    }
    _attemptCharCode(u) {
      return this._cursor.peek() === u ? (this._cursor.advance(), true) : false;
    }
    _attemptCharCodeCaseInsensitive(u) {
      return j(this._cursor.peek(), u) ? (this._cursor.advance(), true) : false;
    }
    _requireCharCode(u) {
      let o = this._cursor.clone();
      if (!this._attemptCharCode(u))
        throw this._createError(l(this._cursor.peek()), this._cursor.getSpan(o));
    }
    _attemptStr(u) {
      let o = u.length;
      if (this._cursor.charsLeft() < o)
        return false;
      let d4 = this._cursor.clone();
      for (let h2 = 0; h2 < o; h2++)
        if (!this._attemptCharCode(u.charCodeAt(h2)))
          return this._cursor = d4, false;
      return true;
    }
    _attemptStrCaseInsensitive(u) {
      for (let o = 0; o < u.length; o++)
        if (!this._attemptCharCodeCaseInsensitive(u.charCodeAt(o)))
          return false;
      return true;
    }
    _requireStr(u) {
      let o = this._cursor.clone();
      if (!this._attemptStr(u))
        throw this._createError(l(this._cursor.peek()), this._cursor.getSpan(o));
    }
    _requireStrCaseInsensitive(u) {
      let o = this._cursor.clone();
      if (!this._attemptStrCaseInsensitive(u))
        throw this._createError(l(this._cursor.peek()), this._cursor.getSpan(o));
    }
    _attemptCharCodeUntilFn(u) {
      for (; !u(this._cursor.peek()); )
        this._cursor.advance();
    }
    _requireCharCodeUntilFn(u, o) {
      let d4 = this._cursor.clone();
      if (this._attemptCharCodeUntilFn(u), this._cursor.clone().diff(d4) < o)
        throw this._createError(l(this._cursor.peek()), this._cursor.getSpan(d4));
    }
    _attemptUntilChar(u) {
      for (; this._cursor.peek() !== u; )
        this._cursor.advance();
    }
    _readChar(u) {
      if (u && this._cursor.peek() === r.$AMPERSAND)
        return this._decodeEntity();
      {
        let o = String.fromCodePoint(this._cursor.peek());
        return this._cursor.advance(), o;
      }
    }
    _decodeEntity() {
      let u = this._cursor.clone();
      if (this._cursor.advance(), this._attemptCharCode(r.$HASH)) {
        let o = this._attemptCharCode(r.$x) || this._attemptCharCode(r.$X), d4 = this._cursor.clone();
        if (this._attemptCharCodeUntilFn(S2), this._cursor.peek() != r.$SEMICOLON)
          throw this._createError(l(this._cursor.peek()), this._cursor.getSpan());
        let h2 = this._cursor.getChars(d4);
        this._cursor.advance();
        try {
          let F = parseInt(h2, o ? 16 : 10);
          return String.fromCharCode(F);
        } catch {
          throw this._createError(p(this._cursor.getChars(u)), this._cursor.getSpan());
        }
      } else {
        let o = this._cursor.clone();
        if (this._attemptCharCodeUntilFn(N), this._cursor.peek() != r.$SEMICOLON)
          return this._cursor = o, "&";
        let d4 = this._cursor.getChars(o);
        this._cursor.advance();
        let h2 = c.NAMED_ENTITIES[d4];
        if (!h2)
          throw this._createError(p(d4), this._cursor.getSpan(u));
        return h2;
      }
    }
    _consumeRawText(u, o) {
      this._beginToken(u ? n.ESCAPABLE_RAW_TEXT : n.RAW_TEXT);
      let d4 = [];
      for (; ; ) {
        let h2 = this._cursor.clone(), F = o();
        if (this._cursor = h2, F)
          break;
        d4.push(this._readChar(u));
      }
      return this._endToken([this._processCarriageReturns(d4.join(""))]);
    }
    _consumeComment(u) {
      this._beginToken(n.COMMENT_START, u), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("-->")), this._beginToken(n.COMMENT_END), this._requireStr("-->"), this._endToken([]);
    }
    _consumeBogusComment(u) {
      this._beginToken(n.COMMENT_START, u), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === r.$GT), this._beginToken(n.COMMENT_END), this._cursor.advance(), this._endToken([]);
    }
    _consumeCdata(u) {
      this._beginToken(n.CDATA_START, u), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("]]>")), this._beginToken(n.CDATA_END), this._requireStr("]]>"), this._endToken([]);
    }
    _consumeDocType(u) {
      this._beginToken(n.DOC_TYPE_START, u), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === r.$GT), this._beginToken(n.DOC_TYPE_END), this._cursor.advance(), this._endToken([]);
    }
    _consumePrefixAndName() {
      let u = this._cursor.clone(), o = "";
      for (; this._cursor.peek() !== r.$COLON && !w2(this._cursor.peek()); )
        this._cursor.advance();
      let d4;
      this._cursor.peek() === r.$COLON ? (o = this._cursor.getChars(u), this._cursor.advance(), d4 = this._cursor.clone()) : d4 = u, this._requireCharCodeUntilFn(B, o === "" ? 0 : 1);
      let h2 = this._cursor.getChars(d4);
      return [o, h2];
    }
    _consumeTagOpen(u) {
      let o, d4, h2, F = this.tokens.length, q = this._cursor.clone(), P = [];
      try {
        if (!r.isAsciiLetter(this._cursor.peek()))
          throw this._createError(l(this._cursor.peek()), this._cursor.getSpan(u));
        for (h2 = this._consumeTagOpenStart(u), d4 = h2.parts[0], o = h2.parts[1], this._attemptCharCodeUntilFn(m2); this._cursor.peek() !== r.$SLASH && this._cursor.peek() !== r.$GT; ) {
          let [H3, K] = this._consumeAttributeName();
          if (this._attemptCharCodeUntilFn(m2), this._attemptCharCode(r.$EQ)) {
            this._attemptCharCodeUntilFn(m2);
            let z = this._consumeAttributeValue();
            P.push({ prefix: H3, name: K, value: z });
          } else
            P.push({ prefix: H3, name: K });
          this._attemptCharCodeUntilFn(m2);
        }
        this._consumeTagOpenEnd();
      } catch (H3) {
        if (H3 instanceof g2) {
          this._cursor = q, h2 && (this.tokens.length = F), this._beginToken(n.TEXT, u), this._endToken(["<"]);
          return;
        }
        throw H3;
      }
      if (this._canSelfClose && this.tokens[this.tokens.length - 1].type === n.TAG_OPEN_END_VOID)
        return;
      let G = this._getTagContentType(o, d4, this._fullNameStack.length > 0, P);
      this._handleFullNameStackForTagOpen(d4, o), G === c.TagContentType.RAW_TEXT ? this._consumeRawTextWithTagClose(d4, o, false) : G === c.TagContentType.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(d4, o, true);
    }
    _consumeRawTextWithTagClose(u, o, d4) {
      this._consumeRawText(d4, () => !this._attemptCharCode(r.$LT) || !this._attemptCharCode(r.$SLASH) || (this._attemptCharCodeUntilFn(m2), !this._attemptStrCaseInsensitive(u ? "".concat(u, ":").concat(o) : o)) ? false : (this._attemptCharCodeUntilFn(m2), this._attemptCharCode(r.$GT)));
      this._beginToken(n.TAG_CLOSE), this._requireCharCodeUntilFn((F) => F === r.$GT, 3), this._cursor.advance(), this._endToken([u, o]), this._handleFullNameStackForTagClose(u, o);
    }
    _consumeTagOpenStart(u) {
      this._beginToken(n.TAG_OPEN_START, u);
      let o = this._consumePrefixAndName();
      return this._endToken(o);
    }
    _consumeAttributeName() {
      let u = this._cursor.peek();
      if (u === r.$SQ || u === r.$DQ)
        throw this._createError(l(u), this._cursor.getSpan());
      this._beginToken(n.ATTR_NAME);
      let o = this._consumePrefixAndName();
      return this._endToken(o), o;
    }
    _consumeAttributeValue() {
      let u;
      if (this._cursor.peek() === r.$SQ || this._cursor.peek() === r.$DQ) {
        this._beginToken(n.ATTR_QUOTE);
        let o = this._cursor.peek();
        this._cursor.advance(), this._endToken([String.fromCodePoint(o)]), this._beginToken(n.ATTR_VALUE);
        let d4 = [];
        for (; this._cursor.peek() !== o; )
          d4.push(this._readChar(true));
        u = this._processCarriageReturns(d4.join("")), this._endToken([u]), this._beginToken(n.ATTR_QUOTE), this._cursor.advance(), this._endToken([String.fromCodePoint(o)]);
      } else {
        this._beginToken(n.ATTR_VALUE);
        let o = this._cursor.clone();
        this._requireCharCodeUntilFn(B, 1), u = this._processCarriageReturns(this._cursor.getChars(o)), this._endToken([u]);
      }
      return u;
    }
    _consumeTagOpenEnd() {
      let u = this._attemptCharCode(r.$SLASH) ? n.TAG_OPEN_END_VOID : n.TAG_OPEN_END;
      this._beginToken(u), this._requireCharCode(r.$GT), this._endToken([]);
    }
    _consumeTagClose(u) {
      if (this._beginToken(n.TAG_CLOSE, u), this._attemptCharCodeUntilFn(m2), this._allowHtmComponentClosingTags && this._attemptCharCode(r.$SLASH))
        this._attemptCharCodeUntilFn(m2), this._requireCharCode(r.$GT), this._endToken([]);
      else {
        let [o, d4] = this._consumePrefixAndName();
        this._attemptCharCodeUntilFn(m2), this._requireCharCode(r.$GT), this._endToken([o, d4]), this._handleFullNameStackForTagClose(o, d4);
      }
    }
    _consumeExpansionFormStart() {
      this._beginToken(n.EXPANSION_FORM_START), this._requireCharCode(r.$LBRACE), this._endToken([]), this._expansionCaseStack.push(n.EXPANSION_FORM_START), this._beginToken(n.RAW_TEXT);
      let u = this._readUntil(r.$COMMA);
      this._endToken([u]), this._requireCharCode(r.$COMMA), this._attemptCharCodeUntilFn(m2), this._beginToken(n.RAW_TEXT);
      let o = this._readUntil(r.$COMMA);
      this._endToken([o]), this._requireCharCode(r.$COMMA), this._attemptCharCodeUntilFn(m2);
    }
    _consumeExpansionCaseStart() {
      this._beginToken(n.EXPANSION_CASE_VALUE);
      let u = this._readUntil(r.$LBRACE).trim();
      this._endToken([u]), this._attemptCharCodeUntilFn(m2), this._beginToken(n.EXPANSION_CASE_EXP_START), this._requireCharCode(r.$LBRACE), this._endToken([]), this._attemptCharCodeUntilFn(m2), this._expansionCaseStack.push(n.EXPANSION_CASE_EXP_START);
    }
    _consumeExpansionCaseEnd() {
      this._beginToken(n.EXPANSION_CASE_EXP_END), this._requireCharCode(r.$RBRACE), this._endToken([]), this._attemptCharCodeUntilFn(m2), this._expansionCaseStack.pop();
    }
    _consumeExpansionFormEnd() {
      this._beginToken(n.EXPANSION_FORM_END), this._requireCharCode(r.$RBRACE), this._endToken([]), this._expansionCaseStack.pop();
    }
    _consumeText() {
      let u = this._cursor.clone();
      this._beginToken(n.TEXT, u);
      let o = [];
      do
        this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (o.push(this._interpolationConfig.start), this._inInterpolation = true) : this._interpolationConfig && this._inInterpolation && this._attemptStr(this._interpolationConfig.end) ? (o.push(this._interpolationConfig.end), this._inInterpolation = false) : o.push(this._readChar(true));
      while (!this._isTextEnd());
      this._endToken([this._processCarriageReturns(o.join(""))]);
    }
    _isTextEnd() {
      return !!(this._cursor.peek() === r.$LT || this._cursor.peek() === r.$EOF || this._tokenizeIcu && !this._inInterpolation && (this.isExpansionFormStart() || this._cursor.peek() === r.$RBRACE && this._isInExpansionCase()));
    }
    _readUntil(u) {
      let o = this._cursor.clone();
      return this._attemptUntilChar(u), this._cursor.getChars(o);
    }
    _isInExpansionCase() {
      return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === n.EXPANSION_CASE_EXP_START;
    }
    _isInExpansionForm() {
      return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === n.EXPANSION_FORM_START;
    }
    isExpansionFormStart() {
      if (this._cursor.peek() !== r.$LBRACE)
        return false;
      if (this._interpolationConfig) {
        let u = this._cursor.clone(), o = this._attemptStr(this._interpolationConfig.start);
        return this._cursor = u, !o;
      }
      return true;
    }
    _handleFullNameStackForTagOpen(u, o) {
      let d4 = c.mergeNsAndName(u, o);
      (this._fullNameStack.length === 0 || this._fullNameStack[this._fullNameStack.length - 1] === d4) && this._fullNameStack.push(d4);
    }
    _handleFullNameStackForTagClose(u, o) {
      let d4 = c.mergeNsAndName(u, o);
      this._fullNameStack.length !== 0 && this._fullNameStack[this._fullNameStack.length - 1] === d4 && this._fullNameStack.pop();
    }
  };
  function m2(u) {
    return !r.isWhitespace(u) || u === r.$EOF;
  }
  function B(u) {
    return r.isWhitespace(u) || u === r.$GT || u === r.$SLASH || u === r.$SQ || u === r.$DQ || u === r.$EQ;
  }
  function w2(u) {
    return (u < r.$a || r.$z < u) && (u < r.$A || r.$Z < u) && (u < r.$0 || u > r.$9);
  }
  function S2(u) {
    return u == r.$SEMICOLON || u == r.$EOF || !r.isAsciiHexDigit(u);
  }
  function N(u) {
    return u == r.$SEMICOLON || u == r.$EOF || !r.isAsciiLetter(u);
  }
  function b2(u) {
    return u === r.$EQ || r.isAsciiLetter(u) || r.isDigit(u);
  }
  function j(u, o) {
    return R(u) == R(o);
  }
  function R(u) {
    return u >= r.$a && u <= r.$z ? u - r.$a + r.$A : u;
  }
  function U(u) {
    let o = [], d4;
    for (let h2 = 0; h2 < u.length; h2++) {
      let F = u[h2];
      d4 && d4.type == n.TEXT && F.type == n.TEXT ? (d4.parts[0] += F.parts[0], d4.sourceSpan.end = F.sourceSpan.end) : (d4 = F, o.push(d4));
    }
    return o;
  }
  var k2 = class {
    constructor(u, o) {
      if (u instanceof k2)
        this.file = u.file, this.input = u.input, this.end = u.end, this.state = Object.assign({}, u.state);
      else {
        if (!o)
          throw new Error("Programming error: the range argument must be provided with a file argument.");
        this.file = u, this.input = u.content, this.end = o.endPos, this.state = { peek: -1, offset: o.startPos, line: o.startLine, column: o.startCol };
      }
    }
    clone() {
      return new k2(this);
    }
    peek() {
      return this.state.peek;
    }
    charsLeft() {
      return this.end - this.state.offset;
    }
    diff(u) {
      return this.state.offset - u.state.offset;
    }
    advance() {
      this.advanceState(this.state);
    }
    init() {
      this.updatePeek(this.state);
    }
    getSpan(u, o) {
      if (u = u || this, o)
        for (u = u.clone(); this.diff(u) > 0 && o.indexOf(u.peek()) !== -1; )
          u.advance();
      return new t.ParseSourceSpan(new t.ParseLocation(u.file, u.state.offset, u.state.line, u.state.column), new t.ParseLocation(this.file, this.state.offset, this.state.line, this.state.column));
    }
    getChars(u) {
      return this.input.substring(u.state.offset, this.state.offset);
    }
    charAt(u) {
      return this.input.charCodeAt(u);
    }
    advanceState(u) {
      if (u.offset >= this.end)
        throw this.state = u, new L('Unexpected character "EOF"', this);
      let o = this.charAt(u.offset);
      o === r.$LF ? (u.line++, u.column = 0) : r.isNewLine(o) || u.column++, u.offset++, this.updatePeek(u);
    }
    updatePeek(u) {
      u.peek = u.offset >= this.end ? r.$EOF : this.charAt(u.offset);
    }
  }, $ = class extends k2 {
    constructor(u, o) {
      u instanceof $ ? (super(u), this.internalState = Object.assign({}, u.internalState)) : (super(u, o), this.internalState = this.state);
    }
    advance() {
      this.state = this.internalState, super.advance(), this.processEscapeSequence();
    }
    init() {
      super.init(), this.processEscapeSequence();
    }
    clone() {
      return new $(this);
    }
    getChars(u) {
      let o = u.clone(), d4 = "";
      for (; o.internalState.offset < this.internalState.offset; )
        d4 += String.fromCodePoint(o.peek()), o.advance();
      return d4;
    }
    processEscapeSequence() {
      let u = () => this.internalState.peek;
      if (u() === r.$BACKSLASH)
        if (this.internalState = Object.assign({}, this.state), this.advanceState(this.internalState), u() === r.$n)
          this.state.peek = r.$LF;
        else if (u() === r.$r)
          this.state.peek = r.$CR;
        else if (u() === r.$v)
          this.state.peek = r.$VTAB;
        else if (u() === r.$t)
          this.state.peek = r.$TAB;
        else if (u() === r.$b)
          this.state.peek = r.$BSPACE;
        else if (u() === r.$f)
          this.state.peek = r.$FF;
        else if (u() === r.$u)
          if (this.advanceState(this.internalState), u() === r.$LBRACE) {
            this.advanceState(this.internalState);
            let o = this.clone(), d4 = 0;
            for (; u() !== r.$RBRACE; )
              this.advanceState(this.internalState), d4++;
            this.state.peek = this.decodeHexDigits(o, d4);
          } else {
            let o = this.clone();
            this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(o, 4);
          }
        else if (u() === r.$x) {
          this.advanceState(this.internalState);
          let o = this.clone();
          this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(o, 2);
        } else if (r.isOctalDigit(u())) {
          let o = "", d4 = 0, h2 = this.clone();
          for (; r.isOctalDigit(u()) && d4 < 3; )
            h2 = this.clone(), o += String.fromCodePoint(u()), this.advanceState(this.internalState), d4++;
          this.state.peek = parseInt(o, 8), this.internalState = h2.internalState;
        } else
          r.isNewLine(this.internalState.peek) ? (this.advanceState(this.internalState), this.state = this.internalState) : this.state.peek = this.internalState.peek;
    }
    decodeHexDigits(u, o) {
      let d4 = this.input.substr(u.internalState.offset, o), h2 = parseInt(d4, 16);
      if (isNaN(h2))
        throw u.state = u.internalState, new L("Invalid hexadecimal escape sequence", u);
      return h2;
    }
  }, L = class {
    constructor(u, o) {
      this.msg = u, this.cursor = o;
    }
  };
  e.CursorError = L;
} }), es = I$1({ "node_modules/angular-html-parser/lib/compiler/src/ml_parser/parser.js"(e) {
  O(), Object.defineProperty(e, "__esModule", { value: true });
  var r = we$1(), t = Cs$1(), s2 = kD(), c = Ze$1(), n = class extends r.ParseError {
    constructor(i2, l, p) {
      super(l, p), this.elementName = i2;
    }
    static create(i2, l, p) {
      return new n(i2, l, p);
    }
  };
  e.TreeError = n;
  var a3 = class {
    constructor(i2, l) {
      this.rootNodes = i2, this.errors = l;
    }
  };
  e.ParseTreeResult = a3;
  var f = class {
    constructor(i2) {
      this.getTagDefinition = i2;
    }
    parse(i2, l, p) {
      let g2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, C2 = arguments.length > 4 ? arguments[4] : void 0, m2 = (k2) => function($) {
        for (var L = arguments.length, u = new Array(L > 1 ? L - 1 : 0), o = 1; o < L; o++)
          u[o - 1] = arguments[o];
        return k2($.toLowerCase(), ...u);
      }, B = g2 ? this.getTagDefinition : m2(this.getTagDefinition), w2 = (k2) => B(k2).contentType, S2 = g2 ? C2 : m2(C2), N = C2 ? (k2, $, L, u) => {
        let o = S2(k2, $, L, u);
        return o !== void 0 ? o : w2(k2);
      } : w2, b2 = s2.tokenize(i2, l, N, p), j = p && p.canSelfClose || false, R = p && p.allowHtmComponentClosingTags || false, U = new D2(b2.tokens, B, j, R, g2).build();
      return new a3(U.rootNodes, b2.errors.concat(U.errors));
    }
  };
  e.Parser = f;
  var D2 = class {
    constructor(i2, l, p, g2, C2) {
      this.tokens = i2, this.getTagDefinition = l, this.canSelfClose = p, this.allowHtmComponentClosingTags = g2, this.isTagNameCaseSensitive = C2, this._index = -1, this._rootNodes = [], this._errors = [], this._elementStack = [], this._advance();
    }
    build() {
      for (; this._peek.type !== s2.TokenType.EOF; )
        this._peek.type === s2.TokenType.TAG_OPEN_START ? this._consumeStartTag(this._advance()) : this._peek.type === s2.TokenType.TAG_CLOSE ? (this._closeVoidElement(), this._consumeEndTag(this._advance())) : this._peek.type === s2.TokenType.CDATA_START ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : this._peek.type === s2.TokenType.COMMENT_START ? (this._closeVoidElement(), this._consumeComment(this._advance())) : this._peek.type === s2.TokenType.TEXT || this._peek.type === s2.TokenType.RAW_TEXT || this._peek.type === s2.TokenType.ESCAPABLE_RAW_TEXT ? (this._closeVoidElement(), this._consumeText(this._advance())) : this._peek.type === s2.TokenType.EXPANSION_FORM_START ? this._consumeExpansion(this._advance()) : this._peek.type === s2.TokenType.DOC_TYPE_START ? this._consumeDocType(this._advance()) : this._advance();
      return new a3(this._rootNodes, this._errors);
    }
    _advance() {
      let i2 = this._peek;
      return this._index < this.tokens.length - 1 && this._index++, this._peek = this.tokens[this._index], i2;
    }
    _advanceIf(i2) {
      return this._peek.type === i2 ? this._advance() : null;
    }
    _consumeCdata(i2) {
      let l = this._advance(), p = this._getText(l), g2 = this._advanceIf(s2.TokenType.CDATA_END);
      this._addToParent(new t.CDATA(p, new r.ParseSourceSpan(i2.sourceSpan.start, (g2 || l).sourceSpan.end)));
    }
    _consumeComment(i2) {
      let l = this._advanceIf(s2.TokenType.RAW_TEXT), p = this._advanceIf(s2.TokenType.COMMENT_END), g2 = l != null ? l.parts[0].trim() : null, C2 = new r.ParseSourceSpan(i2.sourceSpan.start, (p || l || i2).sourceSpan.end);
      this._addToParent(new t.Comment(g2, C2));
    }
    _consumeDocType(i2) {
      let l = this._advanceIf(s2.TokenType.RAW_TEXT), p = this._advanceIf(s2.TokenType.DOC_TYPE_END), g2 = l != null ? l.parts[0].trim() : null, C2 = new r.ParseSourceSpan(i2.sourceSpan.start, (p || l || i2).sourceSpan.end);
      this._addToParent(new t.DocType(g2, C2));
    }
    _consumeExpansion(i2) {
      let l = this._advance(), p = this._advance(), g2 = [];
      for (; this._peek.type === s2.TokenType.EXPANSION_CASE_VALUE; ) {
        let m2 = this._parseExpansionCase();
        if (!m2)
          return;
        g2.push(m2);
      }
      if (this._peek.type !== s2.TokenType.EXPANSION_FORM_END) {
        this._errors.push(n.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
        return;
      }
      let C2 = new r.ParseSourceSpan(i2.sourceSpan.start, this._peek.sourceSpan.end);
      this._addToParent(new t.Expansion(l.parts[0], p.parts[0], g2, C2, l.sourceSpan)), this._advance();
    }
    _parseExpansionCase() {
      let i2 = this._advance();
      if (this._peek.type !== s2.TokenType.EXPANSION_CASE_EXP_START)
        return this._errors.push(n.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
      let l = this._advance(), p = this._collectExpansionExpTokens(l);
      if (!p)
        return null;
      let g2 = this._advance();
      p.push(new s2.Token(s2.TokenType.EOF, [], g2.sourceSpan));
      let C2 = new D2(p, this.getTagDefinition, this.canSelfClose, this.allowHtmComponentClosingTags, this.isTagNameCaseSensitive).build();
      if (C2.errors.length > 0)
        return this._errors = this._errors.concat(C2.errors), null;
      let m2 = new r.ParseSourceSpan(i2.sourceSpan.start, g2.sourceSpan.end), B = new r.ParseSourceSpan(l.sourceSpan.start, g2.sourceSpan.end);
      return new t.ExpansionCase(i2.parts[0], C2.rootNodes, m2, i2.sourceSpan, B);
    }
    _collectExpansionExpTokens(i2) {
      let l = [], p = [s2.TokenType.EXPANSION_CASE_EXP_START];
      for (; ; ) {
        if ((this._peek.type === s2.TokenType.EXPANSION_FORM_START || this._peek.type === s2.TokenType.EXPANSION_CASE_EXP_START) && p.push(this._peek.type), this._peek.type === s2.TokenType.EXPANSION_CASE_EXP_END)
          if (v(p, s2.TokenType.EXPANSION_CASE_EXP_START)) {
            if (p.pop(), p.length == 0)
              return l;
          } else
            return this._errors.push(n.create(null, i2.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
        if (this._peek.type === s2.TokenType.EXPANSION_FORM_END)
          if (v(p, s2.TokenType.EXPANSION_FORM_START))
            p.pop();
          else
            return this._errors.push(n.create(null, i2.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
        if (this._peek.type === s2.TokenType.EOF)
          return this._errors.push(n.create(null, i2.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
        l.push(this._advance());
      }
    }
    _getText(i2) {
      let l = i2.parts[0];
      if (l.length > 0 && l[0] == `
`) {
        let p = this._getParentElement();
        p != null && p.children.length == 0 && this.getTagDefinition(p.name).ignoreFirstLf && (l = l.substring(1));
      }
      return l;
    }
    _consumeText(i2) {
      let l = this._getText(i2);
      l.length > 0 && this._addToParent(new t.Text(l, i2.sourceSpan));
    }
    _closeVoidElement() {
      let i2 = this._getParentElement();
      i2 && this.getTagDefinition(i2.name).isVoid && this._elementStack.pop();
    }
    _consumeStartTag(i2) {
      let l = i2.parts[0], p = i2.parts[1], g2 = [];
      for (; this._peek.type === s2.TokenType.ATTR_NAME; )
        g2.push(this._consumeAttr(this._advance()));
      let C2 = this._getElementFullName(l, p, this._getParentElement()), m2 = false;
      if (this._peek.type === s2.TokenType.TAG_OPEN_END_VOID) {
        this._advance(), m2 = true;
        let b2 = this.getTagDefinition(C2);
        this.canSelfClose || b2.canSelfClose || c.getNsPrefix(C2) !== null || b2.isVoid || this._errors.push(n.create(C2, i2.sourceSpan, 'Only void and foreign elements can be self closed "'.concat(i2.parts[1], '"')));
      } else
        this._peek.type === s2.TokenType.TAG_OPEN_END && (this._advance(), m2 = false);
      let B = this._peek.sourceSpan.start, w2 = new r.ParseSourceSpan(i2.sourceSpan.start, B), S2 = new r.ParseSourceSpan(i2.sourceSpan.start.moveBy(1), i2.sourceSpan.end), N = new t.Element(C2, g2, [], w2, w2, void 0, S2);
      this._pushElement(N), m2 && (this._popElement(C2), N.endSourceSpan = w2);
    }
    _pushElement(i2) {
      let l = this._getParentElement();
      l && this.getTagDefinition(l.name).isClosedByChild(i2.name) && this._elementStack.pop(), this._addToParent(i2), this._elementStack.push(i2);
    }
    _consumeEndTag(i2) {
      let l = this.allowHtmComponentClosingTags && i2.parts.length === 0 ? null : this._getElementFullName(i2.parts[0], i2.parts[1], this._getParentElement());
      if (this._getParentElement() && (this._getParentElement().endSourceSpan = i2.sourceSpan), l && this.getTagDefinition(l).isVoid)
        this._errors.push(n.create(l, i2.sourceSpan, 'Void elements do not have end tags "'.concat(i2.parts[1], '"')));
      else if (!this._popElement(l)) {
        let p = 'Unexpected closing tag "'.concat(l, '". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags');
        this._errors.push(n.create(l, i2.sourceSpan, p));
      }
    }
    _popElement(i2) {
      for (let l = this._elementStack.length - 1; l >= 0; l--) {
        let p = this._elementStack[l];
        if (!i2 || (c.getNsPrefix(p.name) ? p.name == i2 : p.name.toLowerCase() == i2.toLowerCase()))
          return this._elementStack.splice(l, this._elementStack.length - l), true;
        if (!this.getTagDefinition(p.name).closedByParent)
          return false;
      }
      return false;
    }
    _consumeAttr(i2) {
      let l = c.mergeNsAndName(i2.parts[0], i2.parts[1]), p = i2.sourceSpan.end, g2 = "", C2, m2;
      if (this._peek.type === s2.TokenType.ATTR_QUOTE && (m2 = this._advance().sourceSpan.start), this._peek.type === s2.TokenType.ATTR_VALUE) {
        let B = this._advance();
        g2 = B.parts[0], p = B.sourceSpan.end, C2 = B.sourceSpan;
      }
      return this._peek.type === s2.TokenType.ATTR_QUOTE && (p = this._advance().sourceSpan.end, C2 = new r.ParseSourceSpan(m2, p)), new t.Attribute(l, g2, new r.ParseSourceSpan(i2.sourceSpan.start, p), C2, i2.sourceSpan);
    }
    _getParentElement() {
      return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;
    }
    _getParentElementSkippingContainers() {
      let i2 = null;
      for (let l = this._elementStack.length - 1; l >= 0; l--) {
        if (!c.isNgContainer(this._elementStack[l].name))
          return { parent: this._elementStack[l], container: i2 };
        i2 = this._elementStack[l];
      }
      return { parent: null, container: i2 };
    }
    _addToParent(i2) {
      let l = this._getParentElement();
      l != null ? l.children.push(i2) : this._rootNodes.push(i2);
    }
    _insertBeforeContainer(i2, l, p) {
      if (!l)
        this._addToParent(p), this._elementStack.push(p);
      else {
        if (i2) {
          let g2 = i2.children.indexOf(l);
          i2.children[g2] = p;
        } else
          this._rootNodes.push(p);
        p.children.push(l), this._elementStack.splice(this._elementStack.indexOf(l), 0, p);
      }
    }
    _getElementFullName(i2, l, p) {
      return i2 === "" && (i2 = this.getTagDefinition(l).implicitNamespacePrefix || "", i2 === "" && p != null && (i2 = c.getNsPrefix(p.name))), c.mergeNsAndName(i2, l);
    }
  };
  function v(i2, l) {
    return i2.length > 0 && i2[i2.length - 1] === l;
  }
} }), LD = I$1({ "node_modules/angular-html-parser/lib/compiler/src/ml_parser/html_parser.js"(e) {
  O(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Es$1(), t = es(), s2 = es();
  e.ParseTreeResult = s2.ParseTreeResult, e.TreeError = s2.TreeError;
  var c = class extends t.Parser {
    constructor() {
      super(r.getHtmlTagDefinition);
    }
    parse(n, a3, f) {
      let D2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, v = arguments.length > 4 ? arguments[4] : void 0;
      return super.parse(n, a3, f, D2, v);
    }
  };
  e.HtmlParser = c;
} }), rs$1 = I$1({ "node_modules/angular-html-parser/lib/angular-html-parser/src/index.js"(e) {
  O(), Object.defineProperty(e, "__esModule", { value: true });
  var r = LD(), t = Ze$1();
  e.TagContentType = t.TagContentType;
  var s2 = null, c = () => (s2 || (s2 = new r.HtmlParser()), s2);
  function n(a3) {
    let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, { canSelfClose: D2 = false, allowHtmComponentClosingTags: v = false, isTagNameCaseSensitive: i2 = false, getTagContentType: l } = f;
    return c().parse(a3, "angular-html-parser", { tokenizeExpansionForms: false, interpolationConfig: void 0, canSelfClose: D2, allowHtmComponentClosingTags: v }, i2, l);
  }
  e.parse = n;
} }), MD = I$1({ "src/language-html/parser-html.js"(e, r) {
  O();
  var { ParseSourceSpan: t, ParseLocation: s2, ParseSourceFile: c } = we$1(), n = Qc(), a3 = as$1(), f = Kc(), { inferParserByLanguage: D2 } = _D(), v = yD(), i2 = bD(), l = wD(), { hasPragma: p } = ND(), { Node: g2 } = OD(), { parseIeConditionalComment: C2 } = qD(), { locStart: m2, locEnd: B } = ID();
  function w2(b2, j, R) {
    let { recognizeSelfClosing: U, normalizeTagName: k2, normalizeAttributeName: $, allowHtmComponentClosingTags: L, isTagNameCaseSensitive: u, getTagContentType: o } = j, d4 = rs$1(), { RecursiveVisitor: h2, visitAll: F } = Cs$1(), { ParseSourceSpan: q } = we$1(), { getHtmlTagDefinition: P } = Es$1(), { rootNodes: G, errors: H3 } = d4.parse(b2, { canSelfClose: U, allowHtmComponentClosingTags: L, isTagNameCaseSensitive: u, getTagContentType: o });
    if (R.parser === "vue")
      if (G.some((A2) => A2.type === "docType" && A2.value === "html" || A2.type === "element" && A2.name.toLowerCase() === "html")) {
        U = true, k2 = true, $ = true, L = true, u = false;
        let A2 = d4.parse(b2, { canSelfClose: U, allowHtmComponentClosingTags: L, isTagNameCaseSensitive: u });
        G = A2.rootNodes, H3 = A2.errors;
      } else {
        let A2 = (y) => {
          if (!y || y.type !== "element" || y.name !== "template")
            return false;
          let x2 = y.attrs.find((V) => V.name === "lang"), M2 = x2 && x2.value;
          return !M2 || D2(M2, R) === "html";
        };
        if (G.some(A2)) {
          let y, x2 = () => d4.parse(b2, { canSelfClose: U, allowHtmComponentClosingTags: L, isTagNameCaseSensitive: u }), M2 = () => y || (y = x2()), V = (W2) => M2().rootNodes.find((Q) => {
            let { startSourceSpan: se } = Q;
            return se && se.start.offset === W2.startSourceSpan.start.offset;
          });
          for (let W2 = 0; W2 < G.length; W2++) {
            let Q = G[W2], { endSourceSpan: se, startSourceSpan: Ee } = Q;
            if (se === null)
              H3 = M2().errors, G[W2] = V(Q) || Q;
            else if (A2(Q)) {
              let Ae2 = M2(), Ne2 = Ee.end.offset, ee2 = se.start.offset;
              for (let re2 of Ae2.errors) {
                let { offset: ie } = re2.span.start;
                if (Ne2 < ie && ie < ee2) {
                  H3 = [re2];
                  break;
                }
              }
              G[W2] = V(Q) || Q;
            }
          }
        }
      }
    if (H3.length > 0) {
      let { msg: E, span: { start: A2, end: y } } = H3[0];
      throw f(E, { start: { line: A2.line + 1, column: A2.col + 1 }, end: { line: y.line + 1, column: y.col + 1 } });
    }
    let K = (E) => {
      let A2 = E.name.startsWith(":") ? E.name.slice(1).split(":")[0] : null, y = E.nameSpan.toString(), x2 = A2 !== null && y.startsWith("".concat(A2, ":")), M2 = x2 ? y.slice(A2.length + 1) : y;
      E.name = M2, E.namespace = A2, E.hasExplicitNamespace = x2;
    }, z = (E) => {
      switch (E.type) {
        case "element":
          K(E);
          for (let A2 of E.attrs)
            K(A2), A2.valueSpan ? (A2.value = A2.valueSpan.toString(), /["']/.test(A2.value[0]) && (A2.value = A2.value.slice(1, -1))) : A2.value = null;
          break;
        case "comment":
          E.value = E.sourceSpan.toString().slice(4, -3);
          break;
        case "text":
          E.value = E.sourceSpan.toString();
          break;
      }
    }, Y3 = (E, A2) => {
      let y = E.toLowerCase();
      return A2(y) ? y : E;
    }, J2 = (E) => {
      if (E.type === "element" && (k2 && (!E.namespace || E.namespace === E.tagDefinition.implicitNamespacePrefix || l(E)) && (E.name = Y3(E.name, (A2) => A2 in v)), $)) {
        let A2 = i2[E.name] || /* @__PURE__ */ Object.create(null);
        for (let y of E.attrs)
          y.namespace || (y.name = Y3(y.name, (x2) => E.name in i2 && (x2 in i2["*"] || x2 in A2)));
      }
    }, Z3 = (E) => {
      E.sourceSpan && E.endSourceSpan && (E.sourceSpan = new q(E.sourceSpan.start, E.endSourceSpan.end));
    }, _ = (E) => {
      if (E.type === "element") {
        let A2 = P(u ? E.name : E.name.toLowerCase());
        !E.namespace || E.namespace === A2.implicitNamespacePrefix || l(E) ? E.tagDefinition = A2 : E.tagDefinition = P("");
      }
    };
    return F(new class extends h2 {
      visit(E) {
        z(E), _(E), J2(E), Z3(E);
      }
    }(), G), G;
  }
  function S2(b2, j, R) {
    let U = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true, { frontMatter: k2, content: $ } = U ? n(b2) : { frontMatter: null, content: b2 }, L = new c(b2, j.filepath), u = new s2(L, 0, 0, 0), o = u.moveBy(b2.length), d4 = { type: "root", sourceSpan: new t(u, o), children: w2($, R, j) };
    if (k2) {
      let q = new s2(L, 0, 0, 0), P = q.moveBy(k2.raw.length);
      k2.sourceSpan = new t(q, P), d4.children.unshift(k2);
    }
    let h2 = new g2(d4), F = (q, P) => {
      let { offset: G } = P, H3 = b2.slice(0, G).replace(/[^\n\r]/g, " "), z = S2(H3 + q, j, R, false);
      z.sourceSpan = new t(P, a3(z.children).sourceSpan.end);
      let Y3 = z.children[0];
      return Y3.length === G ? z.children.shift() : (Y3.sourceSpan = new t(Y3.sourceSpan.start.moveBy(G), Y3.sourceSpan.end), Y3.value = Y3.value.slice(G)), z;
    };
    return h2.walk((q) => {
      if (q.type === "comment") {
        let P = C2(q, F);
        P && q.parent.replaceChild(q, P);
      }
    }), h2;
  }
  function N() {
    let { name: b2, recognizeSelfClosing: j = false, normalizeTagName: R = false, normalizeAttributeName: U = false, allowHtmComponentClosingTags: k2 = false, isTagNameCaseSensitive: $ = false, getTagContentType: L } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return { parse: (u, o, d4) => S2(u, Object.assign({ parser: b2 }, d4), { recognizeSelfClosing: j, normalizeTagName: R, normalizeAttributeName: U, allowHtmComponentClosingTags: k2, isTagNameCaseSensitive: $, getTagContentType: L }), hasPragma: p, astFormat: "html", locStart: m2, locEnd: B };
  }
  r.exports = { parsers: { html: N({ name: "html", recognizeSelfClosing: true, normalizeTagName: true, normalizeAttributeName: true, allowHtmComponentClosingTags: true }), angular: N({ name: "angular" }), vue: N({ name: "vue", recognizeSelfClosing: true, isTagNameCaseSensitive: true, getTagContentType: (b2, j, R, U) => {
    if (b2.toLowerCase() !== "html" && !R && (b2 !== "template" || U.some((k2) => {
      let { name: $, value: L } = k2;
      return $ === "lang" && L !== "html" && L !== "" && L !== void 0;
    })))
      return rs$1().TagContentType.RAW_TEXT;
  } }), lwc: N({ name: "lwc" }) } };
} }), d2 = MD();
var standalone$1 = { exports: {} };
var standalone = { exports: {} };
var hasRequiredStandalone;
function requireStandalone() {
  if (hasRequiredStandalone)
    return standalone.exports;
  hasRequiredStandalone = 1;
  (function(module, exports) {
    (function(e) {
      module.exports = e();
    })(function() {
      var we2 = (e, n) => () => (n || e((n = { exports: {} }).exports, n), n.exports);
      var Ye2 = we2((Ig, ru) => {
        var rr2 = function(e) {
          return e && e.Math == Math && e;
        };
        ru.exports = rr2(typeof globalThis == "object" && globalThis) || rr2(typeof window == "object" && window) || rr2(typeof self == "object" && self) || rr2(typeof commonjsGlobal == "object" && commonjsGlobal) || function() {
          return this;
        }() || Function("return this")();
      });
      var Dt2 = we2((Lg, nu) => {
        nu.exports = function(e) {
          try {
            return !!e();
          } catch {
            return true;
          }
        };
      });
      var Ct2 = we2((jg, uu) => {
        var So2 = Dt2();
        uu.exports = !So2(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        });
      });
      var nr2 = we2((Og, su2) => {
        var xo2 = Dt2();
        su2.exports = !xo2(function() {
          var e = function() {
          }.bind();
          return typeof e != "function" || e.hasOwnProperty("prototype");
        });
      });
      var Et2 = we2((qg, iu) => {
        var bo2 = nr2(), ur2 = Function.prototype.call;
        iu.exports = bo2 ? ur2.bind(ur2) : function() {
          return ur2.apply(ur2, arguments);
        };
      });
      var cu = we2((lu) => {
        var au2 = {}.propertyIsEnumerable, ou = Object.getOwnPropertyDescriptor, To2 = ou && !au2.call({ 1: 2 }, 1);
        lu.f = To2 ? function(n) {
          var t = ou(this, n);
          return !!t && t.enumerable;
        } : au2;
      });
      var sr2 = we2((Rg, pu) => {
        pu.exports = function(e, n) {
          return { enumerable: !(e & 1), configurable: !(e & 2), writable: !(e & 4), value: n };
        };
      });
      var at2 = we2((Vg, mu) => {
        var fu2 = nr2(), Du = Function.prototype, Bo2 = Du.bind, Or2 = Du.call, No2 = fu2 && Bo2.bind(Or2, Or2);
        mu.exports = fu2 ? function(e) {
          return e && No2(e);
        } : function(e) {
          return e && function() {
            return Or2.apply(e, arguments);
          };
        };
      });
      var ir2 = we2((Wg, gu) => {
        var du2 = at2(), wo2 = du2({}.toString), _o2 = du2("".slice);
        gu.exports = function(e) {
          return _o2(wo2(e), 8, -1);
        };
      });
      var hu = we2(($g, yu) => {
        var Po2 = Ye2(), ko2 = at2(), Io2 = Dt2(), Lo2 = ir2(), qr2 = Po2.Object, jo2 = ko2("".split);
        yu.exports = Io2(function() {
          return !qr2("z").propertyIsEnumerable(0);
        }) ? function(e) {
          return Lo2(e) == "String" ? jo2(e, "") : qr2(e);
        } : qr2;
      });
      var Mr2 = we2((Hg, vu) => {
        var Oo2 = Ye2(), qo2 = Oo2.TypeError;
        vu.exports = function(e) {
          if (e == null)
            throw qo2("Can't call method on " + e);
          return e;
        };
      });
      var ar2 = we2((Gg, Cu2) => {
        var Mo2 = hu(), Ro2 = Mr2();
        Cu2.exports = function(e) {
          return Mo2(Ro2(e));
        };
      });
      var ot2 = we2((Jg, Eu) => {
        Eu.exports = function(e) {
          return typeof e == "function";
        };
      });
      var Ft2 = we2((Ug, Fu) => {
        var Vo2 = ot2();
        Fu.exports = function(e) {
          return typeof e == "object" ? e !== null : Vo2(e);
        };
      });
      var Rt2 = we2((zg, Au2) => {
        var Rr = Ye2(), Wo2 = ot2(), $o2 = function(e) {
          return Wo2(e) ? e : void 0;
        };
        Au2.exports = function(e, n) {
          return arguments.length < 2 ? $o2(Rr[e]) : Rr[e] && Rr[e][n];
        };
      });
      var Vr2 = we2((Xg, Su2) => {
        var Ho2 = at2();
        Su2.exports = Ho2({}.isPrototypeOf);
      });
      var bu = we2((Kg, xu2) => {
        var Go2 = Rt2();
        xu2.exports = Go2("navigator", "userAgent") || "";
      });
      var ku2 = we2((Yg, Pu) => {
        var _u = Ye2(), Wr2 = bu(), Tu = _u.process, Bu2 = _u.Deno, Nu = Tu && Tu.versions || Bu2 && Bu2.version, wu2 = Nu && Nu.v8, ft2, or2;
        wu2 && (ft2 = wu2.split("."), or2 = ft2[0] > 0 && ft2[0] < 4 ? 1 : +(ft2[0] + ft2[1]));
        !or2 && Wr2 && (ft2 = Wr2.match(/Edge\/(\d+)/), (!ft2 || ft2[1] >= 74) && (ft2 = Wr2.match(/Chrome\/(\d+)/), ft2 && (or2 = +ft2[1])));
        Pu.exports = or2;
      });
      var $r2 = we2((Qg, Lu) => {
        var Iu = ku2(), Jo2 = Dt2();
        Lu.exports = !!Object.getOwnPropertySymbols && !Jo2(function() {
          var e = Symbol();
          return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && Iu && Iu < 41;
        });
      });
      var Hr2 = we2((Zg, ju) => {
        var Uo2 = $r2();
        ju.exports = Uo2 && !Symbol.sham && typeof Symbol.iterator == "symbol";
      });
      var Gr2 = we2((e0, Ou) => {
        var zo2 = Ye2(), Xo = Rt2(), Ko = ot2(), Yo = Vr2(), Qo = Hr2(), Zo = zo2.Object;
        Ou.exports = Qo ? function(e) {
          return typeof e == "symbol";
        } : function(e) {
          var n = Xo("Symbol");
          return Ko(n) && Yo(n.prototype, Zo(e));
        };
      });
      var lr2 = we2((t0, qu2) => {
        var el2 = Ye2(), tl2 = el2.String;
        qu2.exports = function(e) {
          try {
            return tl2(e);
          } catch {
            return "Object";
          }
        };
      });
      var Vt = we2((r0, Mu2) => {
        var rl2 = Ye2(), nl2 = ot2(), ul2 = lr2(), sl2 = rl2.TypeError;
        Mu2.exports = function(e) {
          if (nl2(e))
            return e;
          throw sl2(ul2(e) + " is not a function");
        };
      });
      var cr2 = we2((n0, Ru) => {
        var il2 = Vt();
        Ru.exports = function(e, n) {
          var t = e[n];
          return t == null ? void 0 : il2(t);
        };
      });
      var Wu2 = we2((u0, Vu2) => {
        var al2 = Ye2(), Jr2 = Et2(), Ur2 = ot2(), zr2 = Ft2(), ol2 = al2.TypeError;
        Vu2.exports = function(e, n) {
          var t, s2;
          if (n === "string" && Ur2(t = e.toString) && !zr2(s2 = Jr2(t, e)) || Ur2(t = e.valueOf) && !zr2(s2 = Jr2(t, e)) || n !== "string" && Ur2(t = e.toString) && !zr2(s2 = Jr2(t, e)))
            return s2;
          throw ol2("Can't convert object to primitive value");
        };
      });
      var Hu2 = we2((s0, $u2) => {
        $u2.exports = false;
      });
      var pr2 = we2((i0, Ju2) => {
        var Gu = Ye2(), ll2 = Object.defineProperty;
        Ju2.exports = function(e, n) {
          try {
            ll2(Gu, e, { value: n, configurable: true, writable: true });
          } catch {
            Gu[e] = n;
          }
          return n;
        };
      });
      var fr2 = we2((a0, zu) => {
        var cl2 = Ye2(), pl2 = pr2(), Uu = "__core-js_shared__", fl2 = cl2[Uu] || pl2(Uu, {});
        zu.exports = fl2;
      });
      var Xr = we2((o0, Ku) => {
        var Dl2 = Hu2(), Xu = fr2();
        (Ku.exports = function(e, n) {
          return Xu[e] || (Xu[e] = n !== void 0 ? n : {});
        })("versions", []).push({ version: "3.22.2", mode: Dl2 ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.22.2/LICENSE", source: "https://github.com/zloirock/core-js" });
      });
      var Dr2 = we2((l0, Yu) => {
        var ml2 = Ye2(), dl2 = Mr2(), gl2 = ml2.Object;
        Yu.exports = function(e) {
          return gl2(dl2(e));
        };
      });
      var gt2 = we2((c0, Qu2) => {
        var yl2 = at2(), hl2 = Dr2(), vl2 = yl2({}.hasOwnProperty);
        Qu2.exports = Object.hasOwn || function(n, t) {
          return vl2(hl2(n), t);
        };
      });
      var Kr2 = we2((p0, Zu) => {
        var Cl2 = at2(), El2 = 0, Fl2 = Math.random(), Al2 = Cl2(1 .toString);
        Zu.exports = function(e) {
          return "Symbol(" + (e === void 0 ? "" : e) + ")_" + Al2(++El2 + Fl2, 36);
        };
      });
      var St2 = we2((f0, us2) => {
        var Sl2 = Ye2(), xl2 = Xr(), es2 = gt2(), bl2 = Kr2(), ts2 = $r2(), ns2 = Hr2(), Nt2 = xl2("wks"), At2 = Sl2.Symbol, rs2 = At2 && At2.for, Tl2 = ns2 ? At2 : At2 && At2.withoutSetter || bl2;
        us2.exports = function(e) {
          if (!es2(Nt2, e) || !(ts2 || typeof Nt2[e] == "string")) {
            var n = "Symbol." + e;
            ts2 && es2(At2, e) ? Nt2[e] = At2[e] : ns2 && rs2 ? Nt2[e] = rs2(n) : Nt2[e] = Tl2(n);
          }
          return Nt2[e];
        };
      });
      var os2 = we2((D0, as2) => {
        var Bl2 = Ye2(), Nl2 = Et2(), ss3 = Ft2(), is2 = Gr2(), wl2 = cr2(), _l2 = Wu2(), Pl2 = St2(), kl2 = Bl2.TypeError, Il2 = Pl2("toPrimitive");
        as2.exports = function(e, n) {
          if (!ss3(e) || is2(e))
            return e;
          var t = wl2(e, Il2), s2;
          if (t) {
            if (n === void 0 && (n = "default"), s2 = Nl2(t, e, n), !ss3(s2) || is2(s2))
              return s2;
            throw kl2("Can't convert object to primitive value");
          }
          return n === void 0 && (n = "number"), _l2(e, n);
        };
      });
      var mr2 = we2((m0, ls2) => {
        var Ll2 = os2(), jl2 = Gr2();
        ls2.exports = function(e) {
          var n = Ll2(e, "string");
          return jl2(n) ? n : n + "";
        };
      });
      var fs2 = we2((d0, ps2) => {
        var Ol2 = Ye2(), cs2 = Ft2(), Yr2 = Ol2.document, ql2 = cs2(Yr2) && cs2(Yr2.createElement);
        ps2.exports = function(e) {
          return ql2 ? Yr2.createElement(e) : {};
        };
      });
      var Qr = we2((g0, Ds2) => {
        var Ml2 = Ct2(), Rl2 = Dt2(), Vl2 = fs2();
        Ds2.exports = !Ml2 && !Rl2(function() {
          return Object.defineProperty(Vl2("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      });
      var Zr = we2((ds2) => {
        var Wl2 = Ct2(), $l2 = Et2(), Hl2 = cu(), Gl2 = sr2(), Jl2 = ar2(), Ul2 = mr2(), zl2 = gt2(), Xl2 = Qr(), ms2 = Object.getOwnPropertyDescriptor;
        ds2.f = Wl2 ? ms2 : function(n, t) {
          if (n = Jl2(n), t = Ul2(t), Xl2)
            try {
              return ms2(n, t);
            } catch {
            }
          if (zl2(n, t))
            return Gl2(!$l2(Hl2.f, n, t), n[t]);
        };
      });
      var ys2 = we2((h0, gs2) => {
        var Kl2 = Ct2(), Yl2 = Dt2();
        gs2.exports = Kl2 && Yl2(function() {
          return Object.defineProperty(function() {
          }, "prototype", { value: 42, writable: false }).prototype != 42;
        });
      });
      var wt2 = we2((v0, vs2) => {
        var hs2 = Ye2(), Ql2 = Ft2(), Zl2 = hs2.String, ec2 = hs2.TypeError;
        vs2.exports = function(e) {
          if (Ql2(e))
            return e;
          throw ec2(Zl2(e) + " is not an object");
        };
      });
      var gr2 = we2((Es2) => {
        var tc2 = Ye2(), rc2 = Ct2(), nc2 = Qr(), uc2 = ys2(), dr2 = wt2(), Cs2 = mr2(), sc2 = tc2.TypeError, en2 = Object.defineProperty, ic = Object.getOwnPropertyDescriptor, tn = "enumerable", rn2 = "configurable", nn2 = "writable";
        Es2.f = rc2 ? uc2 ? function(n, t, s2) {
          if (dr2(n), t = Cs2(t), dr2(s2), typeof n == "function" && t === "prototype" && "value" in s2 && nn2 in s2 && !s2[nn2]) {
            var a3 = ic(n, t);
            a3 && a3[nn2] && (n[t] = s2.value, s2 = { configurable: rn2 in s2 ? s2[rn2] : a3[rn2], enumerable: tn in s2 ? s2[tn] : a3[tn], writable: false });
          }
          return en2(n, t, s2);
        } : en2 : function(n, t, s2) {
          if (dr2(n), t = Cs2(t), dr2(s2), nc2)
            try {
              return en2(n, t, s2);
            } catch {
            }
          if ("get" in s2 || "set" in s2)
            throw sc2("Accessors not supported");
          return "value" in s2 && (n[t] = s2.value), n;
        };
      });
      var yr2 = we2((E0, Fs2) => {
        var ac = Ct2(), oc = gr2(), lc = sr2();
        Fs2.exports = ac ? function(e, n, t) {
          return oc.f(e, n, lc(1, t));
        } : function(e, n, t) {
          return e[n] = t, e;
        };
      });
      var hr2 = we2((F0, As2) => {
        var cc = at2(), pc = ot2(), un2 = fr2(), fc = cc(Function.toString);
        pc(un2.inspectSource) || (un2.inspectSource = function(e) {
          return fc(e);
        });
        As2.exports = un2.inspectSource;
      });
      var bs2 = we2((A0, xs2) => {
        var Dc = Ye2(), mc = ot2(), dc = hr2(), Ss2 = Dc.WeakMap;
        xs2.exports = mc(Ss2) && /native code/.test(dc(Ss2));
      });
      var Ns2 = we2((S0, Bs2) => {
        var gc = Xr(), yc = Kr2(), Ts2 = gc("keys");
        Bs2.exports = function(e) {
          return Ts2[e] || (Ts2[e] = yc(e));
        };
      });
      var sn2 = we2((x0, ws2) => {
        ws2.exports = {};
      });
      var js2 = we2((b0, Ls2) => {
        var hc = bs2(), Is2 = Ye2(), an2 = at2(), vc = Ft2(), Cc = yr2(), on2 = gt2(), ln = fr2(), Ec = Ns2(), Fc = sn2(), _s2 = "Object already initialized", pn2 = Is2.TypeError, Ac = Is2.WeakMap, vr2, Wt2, Cr2, Sc = function(e) {
          return Cr2(e) ? Wt2(e) : vr2(e, {});
        }, xc = function(e) {
          return function(n) {
            var t;
            if (!vc(n) || (t = Wt2(n)).type !== e)
              throw pn2("Incompatible receiver, " + e + " required");
            return t;
          };
        };
        hc || ln.state ? (yt2 = ln.state || (ln.state = new Ac()), Ps2 = an2(yt2.get), cn = an2(yt2.has), ks2 = an2(yt2.set), vr2 = function(e, n) {
          if (cn(yt2, e))
            throw new pn2(_s2);
          return n.facade = e, ks2(yt2, e, n), n;
        }, Wt2 = function(e) {
          return Ps2(yt2, e) || {};
        }, Cr2 = function(e) {
          return cn(yt2, e);
        }) : (xt2 = Ec("state"), Fc[xt2] = true, vr2 = function(e, n) {
          if (on2(e, xt2))
            throw new pn2(_s2);
          return n.facade = e, Cc(e, xt2, n), n;
        }, Wt2 = function(e) {
          return on2(e, xt2) ? e[xt2] : {};
        }, Cr2 = function(e) {
          return on2(e, xt2);
        });
        var yt2, Ps2, cn, ks2, xt2;
        Ls2.exports = { set: vr2, get: Wt2, has: Cr2, enforce: Sc, getterFor: xc };
      });
      var Ms2 = we2((T0, qs2) => {
        var fn2 = Ct2(), bc = gt2(), Os2 = Function.prototype, Tc = fn2 && Object.getOwnPropertyDescriptor, Dn = bc(Os2, "name"), Bc = Dn && function() {
        }.name === "something", Nc = Dn && (!fn2 || fn2 && Tc(Os2, "name").configurable);
        qs2.exports = { EXISTS: Dn, PROPER: Bc, CONFIGURABLE: Nc };
      });
      var Hs2 = we2((B0, $s2) => {
        var wc = Ye2(), Rs2 = ot2(), _c2 = gt2(), Vs2 = yr2(), Pc2 = pr2(), kc2 = hr2(), Ws2 = js2(), Ic = Ms2().CONFIGURABLE, Lc2 = Ws2.get, jc2 = Ws2.enforce, Oc = String(String).split("String");
        ($s2.exports = function(e, n, t, s2) {
          var a3 = s2 ? !!s2.unsafe : false, r = s2 ? !!s2.enumerable : false, u = s2 ? !!s2.noTargetGet : false, i2 = s2 && s2.name !== void 0 ? s2.name : n, o;
          if (Rs2(t) && (String(i2).slice(0, 7) === "Symbol(" && (i2 = "[" + String(i2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!_c2(t, "name") || Ic && t.name !== i2) && Vs2(t, "name", i2), o = jc2(t), o.source || (o.source = Oc.join(typeof i2 == "string" ? i2 : ""))), e === wc) {
            r ? e[n] = t : Pc2(n, t);
            return;
          } else
            a3 ? !u && e[n] && (r = true) : delete e[n];
          r ? e[n] = t : Vs2(e, n, t);
        })(Function.prototype, "toString", function() {
          return Rs2(this) && Lc2(this).source || kc2(this);
        });
      });
      var Er2 = we2((N0, Gs2) => {
        var qc = Math.ceil, Mc2 = Math.floor;
        Gs2.exports = function(e) {
          var n = +e;
          return n !== n || n === 0 ? 0 : (n > 0 ? Mc2 : qc)(n);
        };
      });
      var Us2 = we2((w0, Js2) => {
        var Rc = Er2(), Vc2 = Math.max, Wc2 = Math.min;
        Js2.exports = function(e, n) {
          var t = Rc(e);
          return t < 0 ? Vc2(t + n, 0) : Wc2(t, n);
        };
      });
      var Xs2 = we2((_0, zs2) => {
        var $c2 = Er2(), Hc2 = Math.min;
        zs2.exports = function(e) {
          return e > 0 ? Hc2($c2(e), 9007199254740991) : 0;
        };
      });
      var _t2 = we2((P0, Ks2) => {
        var Gc2 = Xs2();
        Ks2.exports = function(e) {
          return Gc2(e.length);
        };
      });
      var Zs2 = we2((k0, Qs2) => {
        var Jc2 = ar2(), Uc2 = Us2(), zc2 = _t2(), Ys2 = function(e) {
          return function(n, t, s2) {
            var a3 = Jc2(n), r = zc2(a3), u = Uc2(s2, r), i2;
            if (e && t != t) {
              for (; r > u; )
                if (i2 = a3[u++], i2 != i2)
                  return true;
            } else
              for (; r > u; u++)
                if ((e || u in a3) && a3[u] === t)
                  return e || u || 0;
            return !e && -1;
          };
        };
        Qs2.exports = { includes: Ys2(true), indexOf: Ys2(false) };
      });
      var ri = we2((I0, ti2) => {
        var Xc2 = at2(), mn2 = gt2(), Kc2 = ar2(), Yc2 = Zs2().indexOf, Qc2 = sn2(), ei = Xc2([].push);
        ti2.exports = function(e, n) {
          var t = Kc2(e), s2 = 0, a3 = [], r;
          for (r in t)
            !mn2(Qc2, r) && mn2(t, r) && ei(a3, r);
          for (; n.length > s2; )
            mn2(t, r = n[s2++]) && (~Yc2(a3, r) || ei(a3, r));
          return a3;
        };
      });
      var ui = we2((L0, ni2) => {
        ni2.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      });
      var ii = we2((si2) => {
        var Zc2 = ri(), ep = ui(), tp = ep.concat("length", "prototype");
        si2.f = Object.getOwnPropertyNames || function(n) {
          return Zc2(n, tp);
        };
      });
      var oi = we2((ai2) => {
        ai2.f = Object.getOwnPropertySymbols;
      });
      var ci2 = we2((q0, li2) => {
        var rp = Rt2(), np = at2(), up = ii(), sp = oi(), ip = wt2(), ap = np([].concat);
        li2.exports = rp("Reflect", "ownKeys") || function(n) {
          var t = up.f(ip(n)), s2 = sp.f;
          return s2 ? ap(t, s2(n)) : t;
        };
      });
      var Di2 = we2((M0, fi2) => {
        var pi = gt2(), op = ci2(), lp = Zr(), cp = gr2();
        fi2.exports = function(e, n, t) {
          for (var s2 = op(n), a3 = cp.f, r = lp.f, u = 0; u < s2.length; u++) {
            var i2 = s2[u];
            !pi(e, i2) && !(t && pi(t, i2)) && a3(e, i2, r(n, i2));
          }
        };
      });
      var di2 = we2((R0, mi) => {
        var pp = Dt2(), fp = ot2(), Dp2 = /#|\.prototype\./, $t = function(e, n) {
          var t = dp[mp(e)];
          return t == yp ? true : t == gp ? false : fp(n) ? pp(n) : !!n;
        }, mp = $t.normalize = function(e) {
          return String(e).replace(Dp2, ".").toLowerCase();
        }, dp = $t.data = {}, gp = $t.NATIVE = "N", yp = $t.POLYFILL = "P";
        mi.exports = $t;
      });
      var Ht2 = we2((V0, gi2) => {
        var dn2 = Ye2(), hp = Zr().f, vp = yr2(), Cp = Hs2(), Ep = pr2(), Fp2 = Di2(), Ap = di2();
        gi2.exports = function(e, n) {
          var t = e.target, s2 = e.global, a3 = e.stat, r, u, i2, o, c, v;
          if (s2 ? u = dn2 : a3 ? u = dn2[t] || Ep(t, {}) : u = (dn2[t] || {}).prototype, u)
            for (i2 in n) {
              if (c = n[i2], e.noTargetGet ? (v = hp(u, i2), o = v && v.value) : o = u[i2], r = Ap(s2 ? i2 : t + (a3 ? "." : "#") + i2, e.forced), !r && o !== void 0) {
                if (typeof c == typeof o)
                  continue;
                Fp2(c, o);
              }
              (e.sham || o && o.sham) && vp(c, "sham", true), Cp(u, i2, c, e);
            }
        };
      });
      var gn2 = we2((W0, yi2) => {
        var Sp = ir2();
        yi2.exports = Array.isArray || function(n) {
          return Sp(n) == "Array";
        };
      });
      var yn2 = we2(($0, vi2) => {
        var hi = at2(), xp = Vt(), bp = nr2(), Tp = hi(hi.bind);
        vi2.exports = function(e, n) {
          return xp(e), n === void 0 ? e : bp ? Tp(e, n) : function() {
            return e.apply(n, arguments);
          };
        };
      });
      var hn2 = we2((H0, Ei2) => {
        var Bp2 = Ye2(), Np = gn2(), wp = _t2(), _p2 = yn2(), Pp = Bp2.TypeError, Ci = function(e, n, t, s2, a3, r, u, i2) {
          for (var o = a3, c = 0, v = u ? _p2(u, i2) : false, m2, d4; c < s2; ) {
            if (c in t) {
              if (m2 = v ? v(t[c], c, n) : t[c], r > 0 && Np(m2))
                d4 = wp(m2), o = Ci(e, n, m2, d4, o, r - 1) - 1;
              else {
                if (o >= 9007199254740991)
                  throw Pp("Exceed the acceptable array length");
                e[o] = m2;
              }
              o++;
            }
            c++;
          }
          return o;
        };
        Ei2.exports = Ci;
      });
      var Si2 = we2((G0, Ai2) => {
        var kp = St2(), Ip = kp("toStringTag"), Fi = {};
        Fi[Ip] = "z";
        Ai2.exports = String(Fi) === "[object z]";
      });
      var vn2 = we2((J0, xi) => {
        var Lp2 = Ye2(), jp2 = Si2(), Op2 = ot2(), Fr2 = ir2(), qp2 = St2(), Mp2 = qp2("toStringTag"), Rp2 = Lp2.Object, Vp2 = Fr2(function() {
          return arguments;
        }()) == "Arguments", Wp2 = function(e, n) {
          try {
            return e[n];
          } catch {
          }
        };
        xi.exports = jp2 ? Fr2 : function(e) {
          var n, t, s2;
          return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (t = Wp2(n = Rp2(e), Mp2)) == "string" ? t : Vp2 ? Fr2(n) : (s2 = Fr2(n)) == "Object" && Op2(n.callee) ? "Arguments" : s2;
        };
      });
      var _i = we2((U0, wi) => {
        var $p2 = at2(), Hp2 = Dt2(), bi2 = ot2(), Gp2 = vn2(), Jp2 = Rt2(), Up2 = hr2(), Ti = function() {
        }, zp2 = [], Bi2 = Jp2("Reflect", "construct"), Cn2 = /^\s*(?:class|function)\b/, Xp2 = $p2(Cn2.exec), Kp2 = !Cn2.exec(Ti), Gt2 = function(n) {
          if (!bi2(n))
            return false;
          try {
            return Bi2(Ti, zp2, n), true;
          } catch {
            return false;
          }
        }, Ni2 = function(n) {
          if (!bi2(n))
            return false;
          switch (Gp2(n)) {
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
              return false;
          }
          try {
            return Kp2 || !!Xp2(Cn2, Up2(n));
          } catch {
            return true;
          }
        };
        Ni2.sham = true;
        wi.exports = !Bi2 || Hp2(function() {
          var e;
          return Gt2(Gt2.call) || !Gt2(Object) || !Gt2(function() {
            e = true;
          }) || e;
        }) ? Ni2 : Gt2;
      });
      var Li = we2((z0, Ii2) => {
        var Yp2 = Ye2(), Pi2 = gn2(), Qp2 = _i(), Zp2 = Ft2(), ef2 = St2(), tf2 = ef2("species"), ki = Yp2.Array;
        Ii2.exports = function(e) {
          var n;
          return Pi2(e) && (n = e.constructor, Qp2(n) && (n === ki || Pi2(n.prototype)) ? n = void 0 : Zp2(n) && (n = n[tf2], n === null && (n = void 0))), n === void 0 ? ki : n;
        };
      });
      var En2 = we2((X0, ji2) => {
        var rf2 = Li();
        ji2.exports = function(e, n) {
          return new (rf2(e))(n === 0 ? 0 : n);
        };
      });
      var Oi2 = we2(() => {
        var nf2 = Ht2(), uf2 = hn2(), sf2 = Vt(), af2 = Dr2(), of2 = _t2(), lf2 = En2();
        nf2({ target: "Array", proto: true }, { flatMap: function(n) {
          var t = af2(this), s2 = of2(t), a3;
          return sf2(n), a3 = lf2(t, 0), a3.length = uf2(a3, t, t, s2, 0, 1, n, arguments.length > 1 ? arguments[1] : void 0), a3;
        } });
      });
      var Fn2 = we2((Q0, qi) => {
        qi.exports = {};
      });
      var Ri2 = we2((Z0, Mi2) => {
        var cf2 = St2(), pf2 = Fn2(), ff2 = cf2("iterator"), Df = Array.prototype;
        Mi2.exports = function(e) {
          return e !== void 0 && (pf2.Array === e || Df[ff2] === e);
        };
      });
      var An2 = we2((ey, Wi) => {
        var mf2 = vn2(), Vi = cr2(), df2 = Fn2(), gf2 = St2(), yf2 = gf2("iterator");
        Wi.exports = function(e) {
          if (e != null)
            return Vi(e, yf2) || Vi(e, "@@iterator") || df2[mf2(e)];
        };
      });
      var Hi = we2((ty, $i2) => {
        var hf2 = Ye2(), vf2 = Et2(), Cf = Vt(), Ef2 = wt2(), Ff = lr2(), Af2 = An2(), Sf2 = hf2.TypeError;
        $i2.exports = function(e, n) {
          var t = arguments.length < 2 ? Af2(e) : n;
          if (Cf(t))
            return Ef2(vf2(t, e));
          throw Sf2(Ff(e) + " is not iterable");
        };
      });
      var Ui2 = we2((ry, Ji2) => {
        var xf2 = Et2(), Gi2 = wt2(), bf2 = cr2();
        Ji2.exports = function(e, n, t) {
          var s2, a3;
          Gi2(e);
          try {
            if (s2 = bf2(e, "return"), !s2) {
              if (n === "throw")
                throw t;
              return t;
            }
            s2 = xf2(s2, e);
          } catch (r) {
            a3 = true, s2 = r;
          }
          if (n === "throw")
            throw t;
          if (a3)
            throw s2;
          return Gi2(s2), t;
        };
      });
      var Qi2 = we2((ny, Yi2) => {
        var Tf2 = Ye2(), Bf = yn2(), Nf = Et2(), wf2 = wt2(), _f2 = lr2(), Pf2 = Ri2(), kf2 = _t2(), zi2 = Vr2(), If2 = Hi(), Lf = An2(), Xi = Ui2(), jf = Tf2.TypeError, Ar2 = function(e, n) {
          this.stopped = e, this.result = n;
        }, Ki2 = Ar2.prototype;
        Yi2.exports = function(e, n, t) {
          var s2 = t && t.that, a3 = !!(t && t.AS_ENTRIES), r = !!(t && t.IS_ITERATOR), u = !!(t && t.INTERRUPTED), i2 = Bf(n, s2), o, c, v, m2, d4, p, f, h2 = function(T2) {
            return o && Xi(o, "normal", T2), new Ar2(true, T2);
          }, w2 = function(T2) {
            return a3 ? (wf2(T2), u ? i2(T2[0], T2[1], h2) : i2(T2[0], T2[1])) : u ? i2(T2, h2) : i2(T2);
          };
          if (r)
            o = e;
          else {
            if (c = Lf(e), !c)
              throw jf(_f2(e) + " is not iterable");
            if (Pf2(c)) {
              for (v = 0, m2 = kf2(e); m2 > v; v++)
                if (d4 = w2(e[v]), d4 && zi2(Ki2, d4))
                  return d4;
              return new Ar2(false);
            }
            o = If2(e, c);
          }
          for (p = o.next; !(f = Nf(p, o)).done; ) {
            try {
              d4 = w2(f.value);
            } catch (T2) {
              Xi(o, "throw", T2);
            }
            if (typeof d4 == "object" && d4 && zi2(Ki2, d4))
              return d4;
          }
          return new Ar2(false);
        };
      });
      var ea2 = we2((uy, Zi2) => {
        var Of2 = mr2(), qf2 = gr2(), Mf2 = sr2();
        Zi2.exports = function(e, n, t) {
          var s2 = Of2(n);
          s2 in e ? qf2.f(e, s2, Mf2(0, t)) : e[s2] = t;
        };
      });
      var ta2 = we2(() => {
        var Rf2 = Ht2(), Vf2 = Qi2(), Wf2 = ea2();
        Rf2({ target: "Object", stat: true }, { fromEntries: function(n) {
          var t = {};
          return Vf2(n, function(s2, a3) {
            Wf2(t, s2, a3);
          }, { AS_ENTRIES: true }), t;
        } });
      });
      var ra2 = we2(() => {
        var $f2 = Ht2(), Hf2 = Ye2();
        $f2({ global: true }, { globalThis: Hf2 });
      });
      var na2 = we2(() => {
        ra2();
      });
      var ua2 = we2(() => {
        var Gf2 = Ht2(), Jf2 = hn2(), Uf2 = Dr2(), zf2 = _t2(), Xf2 = Er2(), Kf2 = En2();
        Gf2({ target: "Array", proto: true }, { flat: function() {
          var n = arguments.length ? arguments[0] : void 0, t = Uf2(this), s2 = zf2(t), a3 = Kf2(t, 0);
          return a3.length = Jf2(a3, t, t, s2, 0, n === void 0 ? 1 : Xf2(n)), a3;
        } });
      });
      var Pg = we2((my, Co2) => {
        var Yf2 = ["cliName", "cliCategory", "cliDescription"], Qf2 = ["_"], Zf2 = ["languageId"], sa2, ia2, aa2, oa2, la2, ca2;
        function kn2(e, n) {
          if (e == null)
            return {};
          var t = eD2(e, n), s2, a3;
          if (Object.getOwnPropertySymbols) {
            var r = Object.getOwnPropertySymbols(e);
            for (a3 = 0; a3 < r.length; a3++)
              s2 = r[a3], !(n.indexOf(s2) >= 0) && (!Object.prototype.propertyIsEnumerable.call(e, s2) || (t[s2] = e[s2]));
          }
          return t;
        }
        function eD2(e, n) {
          if (e == null)
            return {};
          var t = {}, s2 = Object.keys(e), a3, r;
          for (r = 0; r < s2.length; r++)
            a3 = s2[r], !(n.indexOf(a3) >= 0) && (t[a3] = e[a3]);
          return t;
        }
        Oi2();
        ta2();
        na2();
        ua2();
        function Pt2(e, n) {
          return n || (n = e.slice(0)), Object.freeze(Object.defineProperties(e, { raw: { value: Object.freeze(n) } }));
        }
        var tD2 = Object.create, Br2 = Object.defineProperty, rD2 = Object.getOwnPropertyDescriptor, In2 = Object.getOwnPropertyNames, nD2 = Object.getPrototypeOf, uD2 = Object.prototype.hasOwnProperty, mt2 = (e, n) => function() {
          return e && (n = (0, e[In2(e)[0]])(e = 0)), n;
        }, Z3 = (e, n) => function() {
          return n || (0, e[In2(e)[0]])((n = { exports: {} }).exports, n), n.exports;
        }, Ut2 = (e, n) => {
          for (var t in n)
            Br2(e, t, { get: n[t], enumerable: true });
        }, ga2 = (e, n, t, s2) => {
          if (n && typeof n == "object" || typeof n == "function")
            for (let a3 of In2(n))
              !uD2.call(e, a3) && a3 !== t && Br2(e, a3, { get: () => n[a3], enumerable: !(s2 = rD2(n, a3)) || s2.enumerable });
          return e;
        }, sD2 = (e, n, t) => (t = e != null ? tD2(nD2(e)) : {}, ga2(n || !e || !e.__esModule ? Br2(t, "default", { value: e, enumerable: true }) : t, e)), lt2 = (e) => ga2(Br2({}, "__esModule", { value: true }), e), pa2, fa2, Tt2, re2 = mt2({ "<define:process>"() {
          pa2 = {}, fa2 = [], Tt2 = { env: pa2, argv: fa2 };
        } }), ya2 = Z3({ "package.json"(e, n) {
          n.exports = { version: "2.7.1" };
        } }), iD2 = Z3({ "node_modules/diff/lib/diff/base.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true }), e.default = n;
          function n() {
          }
          n.prototype = { diff: function(r, u) {
            var i2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = i2.callback;
            typeof i2 == "function" && (o = i2, i2 = {}), this.options = i2;
            var c = this;
            function v(S2) {
              return o ? (setTimeout(function() {
                o(void 0, S2);
              }, 0), true) : S2;
            }
            r = this.castInput(r), u = this.castInput(u), r = this.removeEmpty(this.tokenize(r)), u = this.removeEmpty(this.tokenize(u));
            var m2 = u.length, d4 = r.length, p = 1, f = m2 + d4, h2 = [{ newPos: -1, components: [] }], w2 = this.extractCommon(h2[0], u, r, 0);
            if (h2[0].newPos + 1 >= m2 && w2 + 1 >= d4)
              return v([{ value: this.join(u), count: u.length }]);
            function T2() {
              for (var S2 = -1 * p; S2 <= p; S2 += 2) {
                var B = void 0, I2 = h2[S2 - 1], k2 = h2[S2 + 1], P = (k2 ? k2.newPos : 0) - S2;
                I2 && (h2[S2 - 1] = void 0);
                var C2 = I2 && I2.newPos + 1 < m2, D2 = k2 && 0 <= P && P < d4;
                if (!C2 && !D2) {
                  h2[S2] = void 0;
                  continue;
                }
                if (!C2 || D2 && I2.newPos < k2.newPos ? (B = s2(k2), c.pushComponent(B.components, void 0, true)) : (B = I2, B.newPos++, c.pushComponent(B.components, true, void 0)), P = c.extractCommon(B, u, r, S2), B.newPos + 1 >= m2 && P + 1 >= d4)
                  return v(t(c, B.components, u, r, c.useLongestToken));
                h2[S2] = B;
              }
              p++;
            }
            if (o)
              (function S2() {
                setTimeout(function() {
                  if (p > f)
                    return o();
                  T2() || S2();
                }, 0);
              })();
            else
              for (; p <= f; ) {
                var A2 = T2();
                if (A2)
                  return A2;
              }
          }, pushComponent: function(r, u, i2) {
            var o = r[r.length - 1];
            o && o.added === u && o.removed === i2 ? r[r.length - 1] = { count: o.count + 1, added: u, removed: i2 } : r.push({ count: 1, added: u, removed: i2 });
          }, extractCommon: function(r, u, i2, o) {
            for (var c = u.length, v = i2.length, m2 = r.newPos, d4 = m2 - o, p = 0; m2 + 1 < c && d4 + 1 < v && this.equals(u[m2 + 1], i2[d4 + 1]); )
              m2++, d4++, p++;
            return p && r.components.push({ count: p }), r.newPos = m2, d4;
          }, equals: function(r, u) {
            return this.options.comparator ? this.options.comparator(r, u) : r === u || this.options.ignoreCase && r.toLowerCase() === u.toLowerCase();
          }, removeEmpty: function(r) {
            for (var u = [], i2 = 0; i2 < r.length; i2++)
              r[i2] && u.push(r[i2]);
            return u;
          }, castInput: function(r) {
            return r;
          }, tokenize: function(r) {
            return r.split("");
          }, join: function(r) {
            return r.join("");
          } };
          function t(a3, r, u, i2, o) {
            for (var c = 0, v = r.length, m2 = 0, d4 = 0; c < v; c++) {
              var p = r[c];
              if (p.removed) {
                if (p.value = a3.join(i2.slice(d4, d4 + p.count)), d4 += p.count, c && r[c - 1].added) {
                  var h2 = r[c - 1];
                  r[c - 1] = r[c], r[c] = h2;
                }
              } else {
                if (!p.added && o) {
                  var f = u.slice(m2, m2 + p.count);
                  f = f.map(function(T2, A2) {
                    var S2 = i2[d4 + A2];
                    return S2.length > T2.length ? S2 : T2;
                  }), p.value = a3.join(f);
                } else
                  p.value = a3.join(u.slice(m2, m2 + p.count));
                m2 += p.count, p.added || (d4 += p.count);
              }
            }
            var w2 = r[v - 1];
            return v > 1 && typeof w2.value == "string" && (w2.added || w2.removed) && a3.equals("", w2.value) && (r[v - 2].value += w2.value, r.pop()), r;
          }
          function s2(a3) {
            return { newPos: a3.newPos, components: a3.components.slice(0) };
          }
        } }), aD2 = Z3({ "node_modules/diff/lib/diff/array.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true }), e.diffArrays = a3, e.arrayDiff = void 0;
          var n = t(iD2());
          function t(r) {
            return r && r.__esModule ? r : { default: r };
          }
          var s2 = new n.default();
          e.arrayDiff = s2, s2.tokenize = function(r) {
            return r.slice();
          }, s2.join = s2.removeEmpty = function(r) {
            return r;
          };
          function a3(r, u, i2) {
            return s2.diff(r, u, i2);
          }
        } }), Ln2 = Z3({ "src/document/doc-builders.js"(e, n) {
          re2();
          function t(F) {
            return { type: "concat", parts: F };
          }
          function s2(F) {
            return { type: "indent", contents: F };
          }
          function a3(F, l) {
            return { type: "align", contents: l, n: F };
          }
          function r(F) {
            let l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return { type: "group", id: l.id, contents: F, break: Boolean(l.shouldBreak), expandedStates: l.expandedStates };
          }
          function u(F) {
            return a3(Number.NEGATIVE_INFINITY, F);
          }
          function i2(F) {
            return a3({ type: "root" }, F);
          }
          function o(F) {
            return a3(-1, F);
          }
          function c(F, l) {
            return r(F[0], Object.assign(Object.assign({}, l), {}, { expandedStates: F }));
          }
          function v(F) {
            return { type: "fill", parts: F };
          }
          function m2(F, l) {
            let E = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return { type: "if-break", breakContents: F, flatContents: l, groupId: E.groupId };
          }
          function d4(F, l) {
            return { type: "indent-if-break", contents: F, groupId: l.groupId, negate: l.negate };
          }
          function p(F) {
            return { type: "line-suffix", contents: F };
          }
          var f = { type: "line-suffix-boundary" }, h2 = { type: "break-parent" }, w2 = { type: "trim" }, T2 = { type: "line", hard: true }, A2 = { type: "line", hard: true, literal: true }, S2 = { type: "line" }, B = { type: "line", soft: true }, I2 = t([T2, h2]), k2 = t([A2, h2]), P = { type: "cursor", placeholder: Symbol("cursor") };
          function C2(F, l) {
            let E = [];
            for (let y = 0; y < l.length; y++)
              y !== 0 && E.push(F), E.push(l[y]);
            return t(E);
          }
          function D2(F, l, E) {
            let y = F;
            if (l > 0) {
              for (let N = 0; N < Math.floor(l / E); ++N)
                y = s2(y);
              y = a3(l % E, y), y = a3(Number.NEGATIVE_INFINITY, y);
            }
            return y;
          }
          function g2(F, l) {
            return { type: "label", label: F, contents: l };
          }
          n.exports = { concat: t, join: C2, line: S2, softline: B, hardline: I2, literalline: k2, group: r, conditionalGroup: c, fill: v, lineSuffix: p, lineSuffixBoundary: f, cursor: P, breakParent: h2, ifBreak: m2, trim: w2, indent: s2, indentIfBreak: d4, align: a3, addAlignmentToDoc: D2, markAsRoot: i2, dedentToRoot: u, dedent: o, hardlineWithoutBreakParent: T2, literallineWithoutBreakParent: A2, label: g2 };
        } }), jn2 = Z3({ "src/common/end-of-line.js"(e, n) {
          re2();
          function t(u) {
            let i2 = u.indexOf("\r");
            return i2 >= 0 ? u.charAt(i2 + 1) === `
` ? "crlf" : "cr" : "lf";
          }
          function s2(u) {
            switch (u) {
              case "cr":
                return "\r";
              case "crlf":
                return `\r
`;
              default:
                return `
`;
            }
          }
          function a3(u, i2) {
            let o;
            switch (i2) {
              case `
`:
                o = /\n/g;
                break;
              case "\r":
                o = /\r/g;
                break;
              case `\r
`:
                o = /\r\n/g;
                break;
              default:
                throw new Error('Unexpected "eol" '.concat(JSON.stringify(i2), "."));
            }
            let c = u.match(o);
            return c ? c.length : 0;
          }
          function r(u) {
            return u.replace(/\r\n?/g, `
`);
          }
          n.exports = { guessEndOfLine: t, convertEndOfLineToChars: s2, countEndOfLineChars: a3, normalizeEndOfLine: r };
        } }), it2 = Z3({ "src/utils/get-last.js"(e, n) {
          re2();
          var t = (s2) => s2[s2.length - 1];
          n.exports = t;
        } });
        function oD2() {
          let { onlyFirst: e = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
          return new RegExp(n, e ? void 0 : "g");
        }
        var lD2 = mt2({ "node_modules/strip-ansi/node_modules/ansi-regex/index.js"() {
          re2();
        } });
        function cD2(e) {
          if (typeof e != "string")
            throw new TypeError("Expected a `string`, got `".concat(typeof e, "`"));
          return e.replace(oD2(), "");
        }
        var pD2 = mt2({ "node_modules/strip-ansi/index.js"() {
          re2(), lD2();
        } });
        function fD2(e) {
          return Number.isInteger(e) ? e >= 4352 && (e <= 4447 || e === 9001 || e === 9002 || 11904 <= e && e <= 12871 && e !== 12351 || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141) : false;
        }
        var DD3 = mt2({ "node_modules/is-fullwidth-code-point/index.js"() {
          re2();
        } }), mD2 = Z3({ "node_modules/emoji-regex/index.js"(e, n) {
          re2(), n.exports = function() {
            return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
          };
        } }), ha2 = {};
        Ut2(ha2, { default: () => dD2 });
        function dD2(e) {
          if (typeof e != "string" || e.length === 0 || (e = cD2(e), e.length === 0))
            return 0;
          e = e.replace((0, va2.default)(), "  ");
          let n = 0;
          for (let t = 0; t < e.length; t++) {
            let s2 = e.codePointAt(t);
            s2 <= 31 || s2 >= 127 && s2 <= 159 || s2 >= 768 && s2 <= 879 || (s2 > 65535 && t++, n += fD2(s2) ? 2 : 1);
          }
          return n;
        }
        var va2, gD2 = mt2({ "node_modules/string-width/index.js"() {
          re2(), pD2(), DD3(), va2 = sD2(mD2());
        } }), Ca2 = Z3({ "src/utils/get-string-width.js"(e, n) {
          re2();
          var t = (gD2(), lt2(ha2)).default, s2 = /[^\x20-\x7F]/;
          function a3(r) {
            return r ? s2.test(r) ? t(r) : r.length : 0;
          }
          n.exports = a3;
        } }), On2 = Z3({ "src/document/doc-utils.js"(e, n) {
          re2();
          var t = it2(), { literalline: s2, join: a3 } = Ln2(), r = (l) => Array.isArray(l) || l && l.type === "concat", u = (l) => {
            if (Array.isArray(l))
              return l;
            if (l.type !== "concat" && l.type !== "fill")
              throw new Error("Expect doc type to be `concat` or `fill`.");
            return l.parts;
          }, i2 = {};
          function o(l, E, y, N) {
            let x2 = [l];
            for (; x2.length > 0; ) {
              let b2 = x2.pop();
              if (b2 === i2) {
                y(x2.pop());
                continue;
              }
              if (y && x2.push(b2, i2), !E || E(b2) !== false)
                if (r(b2) || b2.type === "fill") {
                  let L = u(b2);
                  for (let M2 = L.length, j = M2 - 1; j >= 0; --j)
                    x2.push(L[j]);
                } else if (b2.type === "if-break")
                  b2.flatContents && x2.push(b2.flatContents), b2.breakContents && x2.push(b2.breakContents);
                else if (b2.type === "group" && b2.expandedStates)
                  if (N)
                    for (let L = b2.expandedStates.length, M2 = L - 1; M2 >= 0; --M2)
                      x2.push(b2.expandedStates[M2]);
                  else
                    x2.push(b2.contents);
                else
                  b2.contents && x2.push(b2.contents);
            }
          }
          function c(l, E) {
            let y = /* @__PURE__ */ new Map();
            return N(l);
            function N(b2) {
              if (y.has(b2))
                return y.get(b2);
              let L = x2(b2);
              return y.set(b2, L), L;
            }
            function x2(b2) {
              if (Array.isArray(b2))
                return E(b2.map(N));
              if (b2.type === "concat" || b2.type === "fill") {
                let L = b2.parts.map(N);
                return E(Object.assign(Object.assign({}, b2), {}, { parts: L }));
              }
              if (b2.type === "if-break") {
                let L = b2.breakContents && N(b2.breakContents), M2 = b2.flatContents && N(b2.flatContents);
                return E(Object.assign(Object.assign({}, b2), {}, { breakContents: L, flatContents: M2 }));
              }
              if (b2.type === "group" && b2.expandedStates) {
                let L = b2.expandedStates.map(N), M2 = L[0];
                return E(Object.assign(Object.assign({}, b2), {}, { contents: M2, expandedStates: L }));
              }
              if (b2.contents) {
                let L = N(b2.contents);
                return E(Object.assign(Object.assign({}, b2), {}, { contents: L }));
              }
              return E(b2);
            }
          }
          function v(l, E, y) {
            let N = y, x2 = false;
            function b2(L) {
              let M2 = E(L);
              if (M2 !== void 0 && (x2 = true, N = M2), x2)
                return false;
            }
            return o(l, b2), N;
          }
          function m2(l) {
            if (l.type === "group" && l.break || l.type === "line" && l.hard || l.type === "break-parent")
              return true;
          }
          function d4(l) {
            return v(l, m2, false);
          }
          function p(l) {
            if (l.length > 0) {
              let E = t(l);
              !E.expandedStates && !E.break && (E.break = "propagated");
            }
            return null;
          }
          function f(l) {
            let E = /* @__PURE__ */ new Set(), y = [];
            function N(b2) {
              if (b2.type === "break-parent" && p(y), b2.type === "group") {
                if (y.push(b2), E.has(b2))
                  return false;
                E.add(b2);
              }
            }
            function x2(b2) {
              b2.type === "group" && y.pop().break && p(y);
            }
            o(l, N, x2, true);
          }
          function h2(l) {
            return l.type === "line" && !l.hard ? l.soft ? "" : " " : l.type === "if-break" ? l.flatContents || "" : l;
          }
          function w2(l) {
            return c(l, h2);
          }
          var T2 = (l, E) => l && l.type === "line" && l.hard && E && E.type === "break-parent";
          function A2(l) {
            if (!l)
              return l;
            if (r(l) || l.type === "fill") {
              let E = u(l);
              for (; E.length > 1 && T2(...E.slice(-2)); )
                E.length -= 2;
              if (E.length > 0) {
                let y = A2(t(E));
                E[E.length - 1] = y;
              }
              return Array.isArray(l) ? E : Object.assign(Object.assign({}, l), {}, { parts: E });
            }
            switch (l.type) {
              case "align":
              case "indent":
              case "indent-if-break":
              case "group":
              case "line-suffix":
              case "label": {
                let E = A2(l.contents);
                return Object.assign(Object.assign({}, l), {}, { contents: E });
              }
              case "if-break": {
                let E = A2(l.breakContents), y = A2(l.flatContents);
                return Object.assign(Object.assign({}, l), {}, { breakContents: E, flatContents: y });
              }
            }
            return l;
          }
          function S2(l) {
            return A2(I2(l));
          }
          function B(l) {
            switch (l.type) {
              case "fill":
                if (l.parts.every((y) => y === ""))
                  return "";
                break;
              case "group":
                if (!l.contents && !l.id && !l.break && !l.expandedStates)
                  return "";
                if (l.contents.type === "group" && l.contents.id === l.id && l.contents.break === l.break && l.contents.expandedStates === l.expandedStates)
                  return l.contents;
                break;
              case "align":
              case "indent":
              case "indent-if-break":
              case "line-suffix":
                if (!l.contents)
                  return "";
                break;
              case "if-break":
                if (!l.flatContents && !l.breakContents)
                  return "";
                break;
            }
            if (!r(l))
              return l;
            let E = [];
            for (let y of u(l)) {
              if (!y)
                continue;
              let [N, ...x2] = r(y) ? u(y) : [y];
              typeof N == "string" && typeof t(E) == "string" ? E[E.length - 1] += N : E.push(N), E.push(...x2);
            }
            return E.length === 0 ? "" : E.length === 1 ? E[0] : Array.isArray(l) ? E : Object.assign(Object.assign({}, l), {}, { parts: E });
          }
          function I2(l) {
            return c(l, (E) => B(E));
          }
          function k2(l) {
            let E = [], y = l.filter(Boolean);
            for (; y.length > 0; ) {
              let N = y.shift();
              if (!!N) {
                if (r(N)) {
                  y.unshift(...u(N));
                  continue;
                }
                if (E.length > 0 && typeof t(E) == "string" && typeof N == "string") {
                  E[E.length - 1] += N;
                  continue;
                }
                E.push(N);
              }
            }
            return E;
          }
          function P(l) {
            return c(l, (E) => Array.isArray(E) ? k2(E) : E.parts ? Object.assign(Object.assign({}, E), {}, { parts: k2(E.parts) }) : E);
          }
          function C2(l) {
            return c(l, (E) => typeof E == "string" && E.includes(`
`) ? D2(E) : E);
          }
          function D2(l) {
            let E = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s2;
            return a3(E, l.split(`
`)).parts;
          }
          function g2(l) {
            if (l.type === "line")
              return true;
          }
          function F(l) {
            return v(l, g2, false);
          }
          n.exports = { isConcat: r, getDocParts: u, willBreak: d4, traverseDoc: o, findInDoc: v, mapDoc: c, propagateBreaks: f, removeLines: w2, stripTrailingHardline: S2, normalizeParts: k2, normalizeDoc: P, cleanDoc: I2, replaceTextEndOfLine: D2, replaceEndOfLine: C2, canBreak: F };
        } }), yD2 = Z3({ "src/document/doc-printer.js"(e, n) {
          re2();
          var { convertEndOfLineToChars: t } = jn2(), s2 = it2(), a3 = Ca2(), { fill: r, cursor: u, indent: i2 } = Ln2(), { isConcat: o, getDocParts: c } = On2(), v, m2 = 1, d4 = 2;
          function p() {
            return { value: "", length: 0, queue: [] };
          }
          function f(B, I2) {
            return w2(B, { type: "indent" }, I2);
          }
          function h2(B, I2, k2) {
            return I2 === Number.NEGATIVE_INFINITY ? B.root || p() : I2 < 0 ? w2(B, { type: "dedent" }, k2) : I2 ? I2.type === "root" ? Object.assign(Object.assign({}, B), {}, { root: B }) : w2(B, { type: typeof I2 == "string" ? "stringAlign" : "numberAlign", n: I2 }, k2) : B;
          }
          function w2(B, I2, k2) {
            let P = I2.type === "dedent" ? B.queue.slice(0, -1) : [...B.queue, I2], C2 = "", D2 = 0, g2 = 0, F = 0;
            for (let L of P)
              switch (L.type) {
                case "indent":
                  y(), k2.useTabs ? l(1) : E(k2.tabWidth);
                  break;
                case "stringAlign":
                  y(), C2 += L.n, D2 += L.n.length;
                  break;
                case "numberAlign":
                  g2 += 1, F += L.n;
                  break;
                default:
                  throw new Error("Unexpected type '".concat(L.type, "'"));
              }
            return x2(), Object.assign(Object.assign({}, B), {}, { value: C2, length: D2, queue: P });
            function l(L) {
              C2 += "	".repeat(L), D2 += k2.tabWidth * L;
            }
            function E(L) {
              C2 += " ".repeat(L), D2 += L;
            }
            function y() {
              k2.useTabs ? N() : x2();
            }
            function N() {
              g2 > 0 && l(g2), b2();
            }
            function x2() {
              F > 0 && E(F), b2();
            }
            function b2() {
              g2 = 0, F = 0;
            }
          }
          function T2(B) {
            if (B.length === 0)
              return 0;
            let I2 = 0;
            for (; B.length > 0 && typeof s2(B) == "string" && /^[\t ]*$/.test(s2(B)); )
              I2 += B.pop().length;
            if (B.length > 0 && typeof s2(B) == "string") {
              let k2 = s2(B).replace(/[\t ]*$/, "");
              I2 += s2(B).length - k2.length, B[B.length - 1] = k2;
            }
            return I2;
          }
          function A2(B, I2, k2, P, C2, D2) {
            let g2 = I2.length, F = [B], l = [];
            for (; k2 >= 0; ) {
              if (F.length === 0) {
                if (g2 === 0)
                  return true;
                F.push(I2[g2 - 1]), g2--;
                continue;
              }
              let [E, y, N] = F.pop();
              if (typeof N == "string")
                l.push(N), k2 -= a3(N);
              else if (o(N)) {
                let x2 = c(N);
                for (let b2 = x2.length - 1; b2 >= 0; b2--)
                  F.push([E, y, x2[b2]]);
              } else
                switch (N.type) {
                  case "indent":
                    F.push([f(E, P), y, N.contents]);
                    break;
                  case "align":
                    F.push([h2(E, N.n, P), y, N.contents]);
                    break;
                  case "trim":
                    k2 += T2(l);
                    break;
                  case "group": {
                    if (D2 && N.break)
                      return false;
                    let x2 = N.break ? m2 : y;
                    F.push([E, x2, N.expandedStates && x2 === m2 ? s2(N.expandedStates) : N.contents]), N.id && (v[N.id] = x2);
                    break;
                  }
                  case "fill":
                    for (let x2 = N.parts.length - 1; x2 >= 0; x2--)
                      F.push([E, y, N.parts[x2]]);
                    break;
                  case "if-break":
                  case "indent-if-break": {
                    let x2 = N.groupId ? v[N.groupId] : y;
                    if (x2 === m2) {
                      let b2 = N.type === "if-break" ? N.breakContents : N.negate ? N.contents : i2(N.contents);
                      b2 && F.push([E, y, b2]);
                    }
                    if (x2 === d4) {
                      let b2 = N.type === "if-break" ? N.flatContents : N.negate ? i2(N.contents) : N.contents;
                      b2 && F.push([E, y, b2]);
                    }
                    break;
                  }
                  case "line":
                    switch (y) {
                      case d4:
                        if (!N.hard) {
                          N.soft || (l.push(" "), k2 -= 1);
                          break;
                        }
                        return true;
                      case m2:
                        return true;
                    }
                    break;
                  case "line-suffix":
                    C2 = true;
                    break;
                  case "line-suffix-boundary":
                    if (C2)
                      return false;
                    break;
                  case "label":
                    F.push([E, y, N.contents]);
                    break;
                }
            }
            return false;
          }
          function S2(B, I2) {
            v = {};
            let k2 = I2.printWidth, P = t(I2.endOfLine), C2 = 0, D2 = [[p(), m2, B]], g2 = [], F = false, l = [];
            for (; D2.length > 0; ) {
              let [y, N, x2] = D2.pop();
              if (typeof x2 == "string") {
                let b2 = P !== `
` ? x2.replace(/\n/g, P) : x2;
                g2.push(b2), C2 += a3(b2);
              } else if (o(x2)) {
                let b2 = c(x2);
                for (let L = b2.length - 1; L >= 0; L--)
                  D2.push([y, N, b2[L]]);
              } else
                switch (x2.type) {
                  case "cursor":
                    g2.push(u.placeholder);
                    break;
                  case "indent":
                    D2.push([f(y, I2), N, x2.contents]);
                    break;
                  case "align":
                    D2.push([h2(y, x2.n, I2), N, x2.contents]);
                    break;
                  case "trim":
                    C2 -= T2(g2);
                    break;
                  case "group":
                    switch (N) {
                      case d4:
                        if (!F) {
                          D2.push([y, x2.break ? m2 : d4, x2.contents]);
                          break;
                        }
                      case m2: {
                        F = false;
                        let b2 = [y, d4, x2.contents], L = k2 - C2, M2 = l.length > 0;
                        if (!x2.break && A2(b2, D2, L, I2, M2))
                          D2.push(b2);
                        else if (x2.expandedStates) {
                          let j = s2(x2.expandedStates);
                          if (x2.break) {
                            D2.push([y, m2, j]);
                            break;
                          } else
                            for (let $ = 1; $ < x2.expandedStates.length + 1; $++)
                              if ($ >= x2.expandedStates.length) {
                                D2.push([y, m2, j]);
                                break;
                              } else {
                                let V = x2.expandedStates[$], q = [y, d4, V];
                                if (A2(q, D2, L, I2, M2)) {
                                  D2.push(q);
                                  break;
                                }
                              }
                        } else
                          D2.push([y, m2, x2.contents]);
                        break;
                      }
                    }
                    x2.id && (v[x2.id] = s2(D2)[1]);
                    break;
                  case "fill": {
                    let b2 = k2 - C2, { parts: L } = x2;
                    if (L.length === 0)
                      break;
                    let [M2, j] = L, $ = [y, d4, M2], V = [y, m2, M2], q = A2($, [], b2, I2, l.length > 0, true);
                    if (L.length === 1) {
                      q ? D2.push($) : D2.push(V);
                      break;
                    }
                    let Y3 = [y, d4, j], H3 = [y, m2, j];
                    if (L.length === 2) {
                      q ? D2.push(Y3, $) : D2.push(H3, V);
                      break;
                    }
                    L.splice(0, 2);
                    let R = [y, N, r(L)], Q = L[0];
                    A2([y, d4, [M2, j, Q]], [], b2, I2, l.length > 0, true) ? D2.push(R, Y3, $) : q ? D2.push(R, H3, $) : D2.push(R, H3, V);
                    break;
                  }
                  case "if-break":
                  case "indent-if-break": {
                    let b2 = x2.groupId ? v[x2.groupId] : N;
                    if (b2 === m2) {
                      let L = x2.type === "if-break" ? x2.breakContents : x2.negate ? x2.contents : i2(x2.contents);
                      L && D2.push([y, N, L]);
                    }
                    if (b2 === d4) {
                      let L = x2.type === "if-break" ? x2.flatContents : x2.negate ? i2(x2.contents) : x2.contents;
                      L && D2.push([y, N, L]);
                    }
                    break;
                  }
                  case "line-suffix":
                    l.push([y, N, x2.contents]);
                    break;
                  case "line-suffix-boundary":
                    l.length > 0 && D2.push([y, N, { type: "line", hard: true }]);
                    break;
                  case "line":
                    switch (N) {
                      case d4:
                        if (x2.hard)
                          F = true;
                        else {
                          x2.soft || (g2.push(" "), C2 += 1);
                          break;
                        }
                      case m2:
                        if (l.length > 0) {
                          D2.push([y, N, x2], ...l.reverse()), l = [];
                          break;
                        }
                        x2.literal ? y.root ? (g2.push(P, y.root.value), C2 = y.root.length) : (g2.push(P), C2 = 0) : (C2 -= T2(g2), g2.push(P + y.value), C2 = y.length);
                        break;
                    }
                    break;
                  case "label":
                    D2.push([y, N, x2.contents]);
                    break;
                }
              D2.length === 0 && l.length > 0 && (D2.push(...l.reverse()), l = []);
            }
            let E = g2.indexOf(u.placeholder);
            if (E !== -1) {
              let y = g2.indexOf(u.placeholder, E + 1), N = g2.slice(0, E).join(""), x2 = g2.slice(E + 1, y).join(""), b2 = g2.slice(y + 1).join("");
              return { formatted: N + x2 + b2, cursorNodeStart: N.length, cursorNodeText: x2 };
            }
            return { formatted: g2.join("") };
          }
          n.exports = { printDocToString: S2 };
        } }), hD2 = Z3({ "src/document/doc-debug.js"(e, n) {
          re2();
          var { isConcat: t, getDocParts: s2 } = On2();
          function a3(u) {
            if (!u)
              return "";
            if (t(u)) {
              let i2 = [];
              for (let o of s2(u))
                if (t(o))
                  i2.push(...a3(o).parts);
                else {
                  let c = a3(o);
                  c !== "" && i2.push(c);
                }
              return { type: "concat", parts: i2 };
            }
            return u.type === "if-break" ? Object.assign(Object.assign({}, u), {}, { breakContents: a3(u.breakContents), flatContents: a3(u.flatContents) }) : u.type === "group" ? Object.assign(Object.assign({}, u), {}, { contents: a3(u.contents), expandedStates: u.expandedStates && u.expandedStates.map(a3) }) : u.type === "fill" ? { type: "fill", parts: u.parts.map(a3) } : u.contents ? Object.assign(Object.assign({}, u), {}, { contents: a3(u.contents) }) : u;
          }
          function r(u) {
            let i2 = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Set();
            return c(a3(u));
            function c(m2, d4, p) {
              if (typeof m2 == "string")
                return JSON.stringify(m2);
              if (t(m2)) {
                let f = s2(m2).map(c).filter(Boolean);
                return f.length === 1 ? f[0] : "[".concat(f.join(", "), "]");
              }
              if (m2.type === "line") {
                let f = Array.isArray(p) && p[d4 + 1] && p[d4 + 1].type === "break-parent";
                return m2.literal ? f ? "literalline" : "literallineWithoutBreakParent" : m2.hard ? f ? "hardline" : "hardlineWithoutBreakParent" : m2.soft ? "softline" : "line";
              }
              if (m2.type === "break-parent")
                return Array.isArray(p) && p[d4 - 1] && p[d4 - 1].type === "line" && p[d4 - 1].hard ? void 0 : "breakParent";
              if (m2.type === "trim")
                return "trim";
              if (m2.type === "indent")
                return "indent(" + c(m2.contents) + ")";
              if (m2.type === "align")
                return m2.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + c(m2.contents) + ")" : m2.n < 0 ? "dedent(" + c(m2.contents) + ")" : m2.n.type === "root" ? "markAsRoot(" + c(m2.contents) + ")" : "align(" + JSON.stringify(m2.n) + ", " + c(m2.contents) + ")";
              if (m2.type === "if-break")
                return "ifBreak(" + c(m2.breakContents) + (m2.flatContents ? ", " + c(m2.flatContents) : "") + (m2.groupId ? (m2.flatContents ? "" : ', ""') + ", { groupId: ".concat(v(m2.groupId), " }") : "") + ")";
              if (m2.type === "indent-if-break") {
                let f = [];
                m2.negate && f.push("negate: true"), m2.groupId && f.push("groupId: ".concat(v(m2.groupId)));
                let h2 = f.length > 0 ? ", { ".concat(f.join(", "), " }") : "";
                return "indentIfBreak(".concat(c(m2.contents)).concat(h2, ")");
              }
              if (m2.type === "group") {
                let f = [];
                m2.break && m2.break !== "propagated" && f.push("shouldBreak: true"), m2.id && f.push("id: ".concat(v(m2.id)));
                let h2 = f.length > 0 ? ", { ".concat(f.join(", "), " }") : "";
                return m2.expandedStates ? "conditionalGroup([".concat(m2.expandedStates.map((w2) => c(w2)).join(","), "]").concat(h2, ")") : "group(".concat(c(m2.contents)).concat(h2, ")");
              }
              if (m2.type === "fill")
                return "fill([".concat(m2.parts.map((f) => c(f)).join(", "), "])");
              if (m2.type === "line-suffix")
                return "lineSuffix(" + c(m2.contents) + ")";
              if (m2.type === "line-suffix-boundary")
                return "lineSuffixBoundary";
              if (m2.type === "label")
                return "label(".concat(JSON.stringify(m2.label), ", ").concat(c(m2.contents), ")");
              throw new Error("Unknown doc type " + m2.type);
            }
            function v(m2) {
              if (typeof m2 != "symbol")
                return JSON.stringify(String(m2));
              if (m2 in i2)
                return i2[m2];
              let d4 = String(m2).slice(7, -1) || "symbol";
              for (let p = 0; ; p++) {
                let f = d4 + (p > 0 ? " #".concat(p) : "");
                if (!o.has(f))
                  return o.add(f), i2[m2] = "Symbol.for(".concat(JSON.stringify(f), ")");
              }
            }
          }
          n.exports = { printDocToDebug: r };
        } }), Oe2 = Z3({ "src/document/index.js"(e, n) {
          re2(), n.exports = { builders: Ln2(), printer: yD2(), utils: On2(), debug: hD2() };
        } }), Ea2 = {};
        Ut2(Ea2, { default: () => vD2 });
        function vD2(e) {
          if (typeof e != "string")
            throw new TypeError("Expected a string");
          return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
        }
        var CD2 = mt2({ "node_modules/escape-string-regexp/index.js"() {
          re2();
        } }), Fa2 = Z3({ "node_modules/semver/internal/debug.js"(e, n) {
          re2();
          var t = typeof Tt2 == "object" && Tt2.env && Tt2.env.NODE_DEBUG && /\bsemver\b/i.test(Tt2.env.NODE_DEBUG) ? function() {
            for (var s2 = arguments.length, a3 = new Array(s2), r = 0; r < s2; r++)
              a3[r] = arguments[r];
            return console.error("SEMVER", ...a3);
          } : () => {
          };
          n.exports = t;
        } }), Aa2 = Z3({ "node_modules/semver/internal/constants.js"(e, n) {
          re2();
          var t = "2.0.0", s2 = 256, a3 = Number.MAX_SAFE_INTEGER || 9007199254740991, r = 16;
          n.exports = { SEMVER_SPEC_VERSION: t, MAX_LENGTH: s2, MAX_SAFE_INTEGER: a3, MAX_SAFE_COMPONENT_LENGTH: r };
        } }), ED2 = Z3({ "node_modules/semver/internal/re.js"(e, n) {
          re2();
          var { MAX_SAFE_COMPONENT_LENGTH: t } = Aa2(), s2 = Fa2();
          e = n.exports = {};
          var a3 = e.re = [], r = e.src = [], u = e.t = {}, i2 = 0, o = (c, v, m2) => {
            let d4 = i2++;
            s2(c, d4, v), u[c] = d4, r[d4] = v, a3[d4] = new RegExp(v, m2 ? "g" : void 0);
          };
          o("NUMERICIDENTIFIER", "0|[1-9]\\d*"), o("NUMERICIDENTIFIERLOOSE", "[0-9]+"), o("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), o("MAINVERSION", "(".concat(r[u.NUMERICIDENTIFIER], ")\\.(").concat(r[u.NUMERICIDENTIFIER], ")\\.(").concat(r[u.NUMERICIDENTIFIER], ")")), o("MAINVERSIONLOOSE", "(".concat(r[u.NUMERICIDENTIFIERLOOSE], ")\\.(").concat(r[u.NUMERICIDENTIFIERLOOSE], ")\\.(").concat(r[u.NUMERICIDENTIFIERLOOSE], ")")), o("PRERELEASEIDENTIFIER", "(?:".concat(r[u.NUMERICIDENTIFIER], "|").concat(r[u.NONNUMERICIDENTIFIER], ")")), o("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(r[u.NUMERICIDENTIFIERLOOSE], "|").concat(r[u.NONNUMERICIDENTIFIER], ")")), o("PRERELEASE", "(?:-(".concat(r[u.PRERELEASEIDENTIFIER], "(?:\\.").concat(r[u.PRERELEASEIDENTIFIER], ")*))")), o("PRERELEASELOOSE", "(?:-?(".concat(r[u.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(r[u.PRERELEASEIDENTIFIERLOOSE], ")*))")), o("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), o("BUILD", "(?:\\+(".concat(r[u.BUILDIDENTIFIER], "(?:\\.").concat(r[u.BUILDIDENTIFIER], ")*))")), o("FULLPLAIN", "v?".concat(r[u.MAINVERSION]).concat(r[u.PRERELEASE], "?").concat(r[u.BUILD], "?")), o("FULL", "^".concat(r[u.FULLPLAIN], "$")), o("LOOSEPLAIN", "[v=\\s]*".concat(r[u.MAINVERSIONLOOSE]).concat(r[u.PRERELEASELOOSE], "?").concat(r[u.BUILD], "?")), o("LOOSE", "^".concat(r[u.LOOSEPLAIN], "$")), o("GTLT", "((?:<|>)?=?)"), o("XRANGEIDENTIFIERLOOSE", "".concat(r[u.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), o("XRANGEIDENTIFIER", "".concat(r[u.NUMERICIDENTIFIER], "|x|X|\\*")), o("XRANGEPLAIN", "[v=\\s]*(".concat(r[u.XRANGEIDENTIFIER], ")(?:\\.(").concat(r[u.XRANGEIDENTIFIER], ")(?:\\.(").concat(r[u.XRANGEIDENTIFIER], ")(?:").concat(r[u.PRERELEASE], ")?").concat(r[u.BUILD], "?)?)?")), o("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(r[u.XRANGEIDENTIFIERLOOSE], ")(?:\\.(").concat(r[u.XRANGEIDENTIFIERLOOSE], ")(?:\\.(").concat(r[u.XRANGEIDENTIFIERLOOSE], ")(?:").concat(r[u.PRERELEASELOOSE], ")?").concat(r[u.BUILD], "?)?)?")), o("XRANGE", "^".concat(r[u.GTLT], "\\s*").concat(r[u.XRANGEPLAIN], "$")), o("XRANGELOOSE", "^".concat(r[u.GTLT], "\\s*").concat(r[u.XRANGEPLAINLOOSE], "$")), o("COERCE", "(^|[^\\d])(\\d{1,".concat(t, "})(?:\\.(\\d{1,").concat(t, "}))?(?:\\.(\\d{1,").concat(t, "}))?(?:$|[^\\d])")), o("COERCERTL", r[u.COERCE], true), o("LONETILDE", "(?:~>?)"), o("TILDETRIM", "(\\s*)".concat(r[u.LONETILDE], "\\s+"), true), e.tildeTrimReplace = "$1~", o("TILDE", "^".concat(r[u.LONETILDE]).concat(r[u.XRANGEPLAIN], "$")), o("TILDELOOSE", "^".concat(r[u.LONETILDE]).concat(r[u.XRANGEPLAINLOOSE], "$")), o("LONECARET", "(?:\\^)"), o("CARETTRIM", "(\\s*)".concat(r[u.LONECARET], "\\s+"), true), e.caretTrimReplace = "$1^", o("CARET", "^".concat(r[u.LONECARET]).concat(r[u.XRANGEPLAIN], "$")), o("CARETLOOSE", "^".concat(r[u.LONECARET]).concat(r[u.XRANGEPLAINLOOSE], "$")), o("COMPARATORLOOSE", "^".concat(r[u.GTLT], "\\s*(").concat(r[u.LOOSEPLAIN], ")$|^$")), o("COMPARATOR", "^".concat(r[u.GTLT], "\\s*(").concat(r[u.FULLPLAIN], ")$|^$")), o("COMPARATORTRIM", "(\\s*)".concat(r[u.GTLT], "\\s*(").concat(r[u.LOOSEPLAIN], "|").concat(r[u.XRANGEPLAIN], ")"), true), e.comparatorTrimReplace = "$1$2$3", o("HYPHENRANGE", "^\\s*(".concat(r[u.XRANGEPLAIN], ")\\s+-\\s+(").concat(r[u.XRANGEPLAIN], ")\\s*$")), o("HYPHENRANGELOOSE", "^\\s*(".concat(r[u.XRANGEPLAINLOOSE], ")\\s+-\\s+(").concat(r[u.XRANGEPLAINLOOSE], ")\\s*$")), o("STAR", "(<|>)?=?\\s*\\*"), o("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), o("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
        } }), FD2 = Z3({ "node_modules/semver/internal/parse-options.js"(e, n) {
          re2();
          var t = ["includePrerelease", "loose", "rtl"], s2 = (a3) => a3 ? typeof a3 != "object" ? { loose: true } : t.filter((r) => a3[r]).reduce((r, u) => (r[u] = true, r), {}) : {};
          n.exports = s2;
        } }), AD2 = Z3({ "node_modules/semver/internal/identifiers.js"(e, n) {
          re2();
          var t = /^[0-9]+$/, s2 = (r, u) => {
            let i2 = t.test(r), o = t.test(u);
            return i2 && o && (r = +r, u = +u), r === u ? 0 : i2 && !o ? -1 : o && !i2 ? 1 : r < u ? -1 : 1;
          }, a3 = (r, u) => s2(u, r);
          n.exports = { compareIdentifiers: s2, rcompareIdentifiers: a3 };
        } }), SD2 = Z3({ "node_modules/semver/classes/semver.js"(e, n) {
          re2();
          var t = Fa2(), { MAX_LENGTH: s2, MAX_SAFE_INTEGER: a3 } = Aa2(), { re: r, t: u } = ED2(), i2 = FD2(), { compareIdentifiers: o } = AD2(), c = class {
            constructor(v, m2) {
              if (m2 = i2(m2), v instanceof c) {
                if (v.loose === !!m2.loose && v.includePrerelease === !!m2.includePrerelease)
                  return v;
                v = v.version;
              } else if (typeof v != "string")
                throw new TypeError("Invalid Version: ".concat(v));
              if (v.length > s2)
                throw new TypeError("version is longer than ".concat(s2, " characters"));
              t("SemVer", v, m2), this.options = m2, this.loose = !!m2.loose, this.includePrerelease = !!m2.includePrerelease;
              let d4 = v.trim().match(m2.loose ? r[u.LOOSE] : r[u.FULL]);
              if (!d4)
                throw new TypeError("Invalid Version: ".concat(v));
              if (this.raw = v, this.major = +d4[1], this.minor = +d4[2], this.patch = +d4[3], this.major > a3 || this.major < 0)
                throw new TypeError("Invalid major version");
              if (this.minor > a3 || this.minor < 0)
                throw new TypeError("Invalid minor version");
              if (this.patch > a3 || this.patch < 0)
                throw new TypeError("Invalid patch version");
              d4[4] ? this.prerelease = d4[4].split(".").map((p) => {
                if (/^[0-9]+$/.test(p)) {
                  let f = +p;
                  if (f >= 0 && f < a3)
                    return f;
                }
                return p;
              }) : this.prerelease = [], this.build = d4[5] ? d4[5].split(".") : [], this.format();
            }
            format() {
              return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version;
            }
            toString() {
              return this.version;
            }
            compare(v) {
              if (t("SemVer.compare", this.version, this.options, v), !(v instanceof c)) {
                if (typeof v == "string" && v === this.version)
                  return 0;
                v = new c(v, this.options);
              }
              return v.version === this.version ? 0 : this.compareMain(v) || this.comparePre(v);
            }
            compareMain(v) {
              return v instanceof c || (v = new c(v, this.options)), o(this.major, v.major) || o(this.minor, v.minor) || o(this.patch, v.patch);
            }
            comparePre(v) {
              if (v instanceof c || (v = new c(v, this.options)), this.prerelease.length && !v.prerelease.length)
                return -1;
              if (!this.prerelease.length && v.prerelease.length)
                return 1;
              if (!this.prerelease.length && !v.prerelease.length)
                return 0;
              let m2 = 0;
              do {
                let d4 = this.prerelease[m2], p = v.prerelease[m2];
                if (t("prerelease compare", m2, d4, p), d4 === void 0 && p === void 0)
                  return 0;
                if (p === void 0)
                  return 1;
                if (d4 === void 0)
                  return -1;
                if (d4 === p)
                  continue;
                return o(d4, p);
              } while (++m2);
            }
            compareBuild(v) {
              v instanceof c || (v = new c(v, this.options));
              let m2 = 0;
              do {
                let d4 = this.build[m2], p = v.build[m2];
                if (t("prerelease compare", m2, d4, p), d4 === void 0 && p === void 0)
                  return 0;
                if (p === void 0)
                  return 1;
                if (d4 === void 0)
                  return -1;
                if (d4 === p)
                  continue;
                return o(d4, p);
              } while (++m2);
            }
            inc(v, m2) {
              switch (v) {
                case "premajor":
                  this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", m2);
                  break;
                case "preminor":
                  this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", m2);
                  break;
                case "prepatch":
                  this.prerelease.length = 0, this.inc("patch", m2), this.inc("pre", m2);
                  break;
                case "prerelease":
                  this.prerelease.length === 0 && this.inc("patch", m2), this.inc("pre", m2);
                  break;
                case "major":
                  (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                  break;
                case "minor":
                  (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                  break;
                case "patch":
                  this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                  break;
                case "pre":
                  if (this.prerelease.length === 0)
                    this.prerelease = [0];
                  else {
                    let d4 = this.prerelease.length;
                    for (; --d4 >= 0; )
                      typeof this.prerelease[d4] == "number" && (this.prerelease[d4]++, d4 = -2);
                    d4 === -1 && this.prerelease.push(0);
                  }
                  m2 && (o(this.prerelease[0], m2) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [m2, 0]) : this.prerelease = [m2, 0]);
                  break;
                default:
                  throw new Error("invalid increment argument: ".concat(v));
              }
              return this.format(), this.raw = this.version, this;
            }
          };
          n.exports = c;
        } }), qn2 = Z3({ "node_modules/semver/functions/compare.js"(e, n) {
          re2();
          var t = SD2(), s2 = (a3, r, u) => new t(a3, u).compare(new t(r, u));
          n.exports = s2;
        } }), xD2 = Z3({ "node_modules/semver/functions/lt.js"(e, n) {
          re2();
          var t = qn2(), s2 = (a3, r, u) => t(a3, r, u) < 0;
          n.exports = s2;
        } }), bD2 = Z3({ "node_modules/semver/functions/gte.js"(e, n) {
          re2();
          var t = qn2(), s2 = (a3, r, u) => t(a3, r, u) >= 0;
          n.exports = s2;
        } }), TD2 = Z3({ "src/utils/arrayify.js"(e, n) {
          re2(), n.exports = (t, s2) => Object.entries(t).map((a3) => {
            let [r, u] = a3;
            return Object.assign({ [s2]: r }, u);
          });
        } }), BD2 = Z3({ "node_modules/outdent/lib/index.js"(e, n) {
          re2(), Object.defineProperty(e, "__esModule", { value: true }), e.outdent = void 0;
          function t() {
            for (var A2 = [], S2 = 0; S2 < arguments.length; S2++)
              A2[S2] = arguments[S2];
          }
          function s2() {
            return typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : a3();
          }
          function a3() {
            return { add: t, delete: t, get: t, set: t, has: function(A2) {
              return false;
            } };
          }
          var r = Object.prototype.hasOwnProperty, u = function(A2, S2) {
            return r.call(A2, S2);
          };
          function i2(A2, S2) {
            for (var B in S2)
              u(S2, B) && (A2[B] = S2[B]);
            return A2;
          }
          var o = /^[ \t]*(?:\r\n|\r|\n)/, c = /(?:\r\n|\r|\n)[ \t]*$/, v = /^(?:[\r\n]|$)/, m2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, d4 = /^[ \t]*[\r\n][ \t\r\n]*$/;
          function p(A2, S2, B) {
            var I2 = 0, k2 = A2[0].match(m2);
            k2 && (I2 = k2[1].length);
            var P = "(\\r\\n|\\r|\\n).{0," + I2 + "}", C2 = new RegExp(P, "g");
            S2 && (A2 = A2.slice(1));
            var D2 = B.newline, g2 = B.trimLeadingNewline, F = B.trimTrailingNewline, l = typeof D2 == "string", E = A2.length, y = A2.map(function(N, x2) {
              return N = N.replace(C2, "$1"), x2 === 0 && g2 && (N = N.replace(o, "")), x2 === E - 1 && F && (N = N.replace(c, "")), l && (N = N.replace(/\r\n|\n|\r/g, function(b2) {
                return D2;
              })), N;
            });
            return y;
          }
          function f(A2, S2) {
            for (var B = "", I2 = 0, k2 = A2.length; I2 < k2; I2++)
              B += A2[I2], I2 < k2 - 1 && (B += S2[I2]);
            return B;
          }
          function h2(A2) {
            return u(A2, "raw") && u(A2, "length");
          }
          function w2(A2) {
            var S2 = s2(), B = s2();
            function I2(P) {
              for (var C2 = [], D2 = 1; D2 < arguments.length; D2++)
                C2[D2 - 1] = arguments[D2];
              if (h2(P)) {
                var g2 = P, F = (C2[0] === I2 || C2[0] === T2) && d4.test(g2[0]) && v.test(g2[1]), l = F ? B : S2, E = l.get(g2);
                if (E || (E = p(g2, F, A2), l.set(g2, E)), C2.length === 0)
                  return E[0];
                var y = f(E, F ? C2.slice(1) : C2);
                return y;
              } else
                return w2(i2(i2({}, A2), P || {}));
            }
            var k2 = i2(I2, { string: function(P) {
              return p([P], false, A2)[0];
            } });
            return k2;
          }
          var T2 = w2({ trimLeadingNewline: true, trimTrailingNewline: true });
          if (e.outdent = T2, e.default = T2, typeof n < "u")
            try {
              n.exports = T2, Object.defineProperty(T2, "__esModule", { value: true }), T2.default = T2, T2.outdent = T2;
            } catch {
            }
        } }), ND2 = Z3({ "src/main/core-options.js"(e, n) {
          re2();
          var { outdent: t } = BD2(), s2 = "Config", a3 = "Editor", r = "Format", u = "Other", i2 = "Output", o = "Global", c = "Special", v = { cursorOffset: { since: "1.4.0", category: c, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: t(sa2 || (sa2 = Pt2([`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `]))), cliCategory: a3 }, endOfLine: { since: "1.15.0", category: o, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: t(ia2 || (ia2 = Pt2([`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `]))) }] }, filepath: { since: "1.4.0", category: c, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: u, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: c, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: u }, parser: { since: "0.0.10", category: o, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (m2) => typeof m2 == "string" || typeof m2 == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "acorn", since: "2.6.0", description: "JavaScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: o, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (m2) => typeof m2 == "string" || typeof m2 == "object", cliName: "plugin", cliCategory: s2 }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: o, description: t(aa2 || (aa2 = Pt2([`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `]))), exception: (m2) => typeof m2 == "string" || typeof m2 == "object", cliName: "plugin-search-dir", cliCategory: s2 }, printWidth: { since: "0.0.0", category: o, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: c, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t(oa2 || (oa2 = Pt2([`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `]))), cliCategory: a3 }, rangeStart: { since: "1.4.0", category: c, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t(la2 || (la2 = Pt2([`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `]))), cliCategory: a3 }, requirePragma: { since: "1.7.0", category: c, type: "boolean", default: false, description: t(ca2 || (ca2 = Pt2([`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `]))), cliCategory: u }, tabWidth: { type: "int", category: o, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: o, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: o, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
          n.exports = { CATEGORY_CONFIG: s2, CATEGORY_EDITOR: a3, CATEGORY_FORMAT: r, CATEGORY_OTHER: u, CATEGORY_OUTPUT: i2, CATEGORY_GLOBAL: o, CATEGORY_SPECIAL: c, options: v };
        } }), Mn2 = Z3({ "src/main/support.js"(e, n) {
          re2();
          var t = { compare: qn2(), lt: xD2(), gte: bD2() }, s2 = TD2(), a3 = ya2().version, r = ND2().options;
          function u() {
            let { plugins: o = [], showUnreleased: c = false, showDeprecated: v = false, showInternal: m2 = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, d4 = a3.split("-", 1)[0], p = o.flatMap((A2) => A2.languages || []).filter(h2), f = s2(Object.assign({}, ...o.map((A2) => {
              let { options: S2 } = A2;
              return S2;
            }), r), "name").filter((A2) => h2(A2) && w2(A2)).sort((A2, S2) => A2.name === S2.name ? 0 : A2.name < S2.name ? -1 : 1).map(T2).map((A2) => {
              A2 = Object.assign({}, A2), Array.isArray(A2.default) && (A2.default = A2.default.length === 1 ? A2.default[0].value : A2.default.filter(h2).sort((B, I2) => t.compare(I2.since, B.since))[0].value), Array.isArray(A2.choices) && (A2.choices = A2.choices.filter((B) => h2(B) && w2(B)), A2.name === "parser" && i2(A2, p, o));
              let S2 = Object.fromEntries(o.filter((B) => B.defaultOptions && B.defaultOptions[A2.name] !== void 0).map((B) => [B.name, B.defaultOptions[A2.name]]));
              return Object.assign(Object.assign({}, A2), {}, { pluginDefaults: S2 });
            });
            return { languages: p, options: f };
            function h2(A2) {
              return c || !("since" in A2) || A2.since && t.gte(d4, A2.since);
            }
            function w2(A2) {
              return v || !("deprecated" in A2) || A2.deprecated && t.lt(d4, A2.deprecated);
            }
            function T2(A2) {
              if (m2)
                return A2;
              return kn2(A2, Yf2);
            }
          }
          function i2(o, c, v) {
            let m2 = new Set(o.choices.map((d4) => d4.value));
            for (let d4 of c)
              if (d4.parsers) {
                for (let p of d4.parsers)
                  if (!m2.has(p)) {
                    m2.add(p);
                    let f = v.find((w2) => w2.parsers && w2.parsers[p]), h2 = d4.name;
                    f && f.name && (h2 += " (plugin: ".concat(f.name, ")")), o.choices.push({ value: p, description: h2 });
                  }
              }
          }
          n.exports = { getSupportInfo: u };
        } }), Rn2 = Z3({ "src/utils/is-non-empty-array.js"(e, n) {
          re2();
          function t(s2) {
            return Array.isArray(s2) && s2.length > 0;
          }
          n.exports = t;
        } }), Nr2 = Z3({ "src/utils/text/skip.js"(e, n) {
          re2();
          function t(i2) {
            return (o, c, v) => {
              let m2 = v && v.backwards;
              if (c === false)
                return false;
              let { length: d4 } = o, p = c;
              for (; p >= 0 && p < d4; ) {
                let f = o.charAt(p);
                if (i2 instanceof RegExp) {
                  if (!i2.test(f))
                    return p;
                } else if (!i2.includes(f))
                  return p;
                m2 ? p-- : p++;
              }
              return p === -1 || p === d4 ? p : false;
            };
          }
          var s2 = t(/\s/), a3 = t(" 	"), r = t(",; 	"), u = t(/[^\n\r]/);
          n.exports = { skipWhitespace: s2, skipSpaces: a3, skipToLineEnd: r, skipEverythingButNewLine: u };
        } }), Sa2 = Z3({ "src/utils/text/skip-inline-comment.js"(e, n) {
          re2();
          function t(s2, a3) {
            if (a3 === false)
              return false;
            if (s2.charAt(a3) === "/" && s2.charAt(a3 + 1) === "*") {
              for (let r = a3 + 2; r < s2.length; ++r)
                if (s2.charAt(r) === "*" && s2.charAt(r + 1) === "/")
                  return r + 2;
            }
            return a3;
          }
          n.exports = t;
        } }), xa2 = Z3({ "src/utils/text/skip-trailing-comment.js"(e, n) {
          re2();
          var { skipEverythingButNewLine: t } = Nr2();
          function s2(a3, r) {
            return r === false ? false : a3.charAt(r) === "/" && a3.charAt(r + 1) === "/" ? t(a3, r) : r;
          }
          n.exports = s2;
        } }), ba2 = Z3({ "src/utils/text/skip-newline.js"(e, n) {
          re2();
          function t(s2, a3, r) {
            let u = r && r.backwards;
            if (a3 === false)
              return false;
            let i2 = s2.charAt(a3);
            if (u) {
              if (s2.charAt(a3 - 1) === "\r" && i2 === `
`)
                return a3 - 2;
              if (i2 === `
` || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
                return a3 - 1;
            } else {
              if (i2 === "\r" && s2.charAt(a3 + 1) === `
`)
                return a3 + 2;
              if (i2 === `
` || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
                return a3 + 1;
            }
            return a3;
          }
          n.exports = t;
        } }), wD2 = Z3({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e, n) {
          re2();
          var t = Sa2(), s2 = ba2(), a3 = xa2(), { skipSpaces: r } = Nr2();
          function u(i2, o) {
            let c = null, v = o;
            for (; v !== c; )
              c = v, v = r(i2, v), v = t(i2, v), v = a3(i2, v), v = s2(i2, v);
            return v;
          }
          n.exports = u;
        } }), Ue2 = Z3({ "src/common/util.js"(e, n) {
          re2();
          var { default: t } = (CD2(), lt2(Ea2)), s2 = it2(), { getSupportInfo: a3 } = Mn2(), r = Rn2(), u = Ca2(), { skipWhitespace: i2, skipSpaces: o, skipToLineEnd: c, skipEverythingButNewLine: v } = Nr2(), m2 = Sa2(), d4 = xa2(), p = ba2(), f = wD2(), h2 = (H3) => H3[H3.length - 2];
          function w2(H3) {
            return (R, Q, ee2) => {
              let te2 = ee2 && ee2.backwards;
              if (Q === false)
                return false;
              let { length: oe2 } = R, W2 = Q;
              for (; W2 >= 0 && W2 < oe2; ) {
                let X3 = R.charAt(W2);
                if (H3 instanceof RegExp) {
                  if (!H3.test(X3))
                    return W2;
                } else if (!H3.includes(X3))
                  return W2;
                te2 ? W2-- : W2++;
              }
              return W2 === -1 || W2 === oe2 ? W2 : false;
            };
          }
          function T2(H3, R) {
            let Q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, ee2 = o(H3, Q.backwards ? R - 1 : R, Q), te2 = p(H3, ee2, Q);
            return ee2 !== te2;
          }
          function A2(H3, R, Q) {
            for (let ee2 = R; ee2 < Q; ++ee2)
              if (H3.charAt(ee2) === `
`)
                return true;
            return false;
          }
          function S2(H3, R, Q) {
            let ee2 = Q(R) - 1;
            ee2 = o(H3, ee2, { backwards: true }), ee2 = p(H3, ee2, { backwards: true }), ee2 = o(H3, ee2, { backwards: true });
            let te2 = p(H3, ee2, { backwards: true });
            return ee2 !== te2;
          }
          function B(H3, R) {
            let Q = null, ee2 = R;
            for (; ee2 !== Q; )
              Q = ee2, ee2 = c(H3, ee2), ee2 = m2(H3, ee2), ee2 = o(H3, ee2);
            return ee2 = d4(H3, ee2), ee2 = p(H3, ee2), ee2 !== false && T2(H3, ee2);
          }
          function I2(H3, R, Q) {
            return B(H3, Q(R));
          }
          function k2(H3, R, Q) {
            return f(H3, Q(R));
          }
          function P(H3, R, Q) {
            return H3.charAt(k2(H3, R, Q));
          }
          function C2(H3, R) {
            let Q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return o(H3, Q.backwards ? R - 1 : R, Q) !== R;
          }
          function D2(H3, R) {
            let Q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, ee2 = 0;
            for (let te2 = Q; te2 < H3.length; ++te2)
              H3[te2] === "	" ? ee2 = ee2 + R - ee2 % R : ee2++;
            return ee2;
          }
          function g2(H3, R) {
            let Q = H3.lastIndexOf(`
`);
            return Q === -1 ? 0 : D2(H3.slice(Q + 1).match(/^[\t ]*/)[0], R);
          }
          function F(H3, R) {
            let Q = { quote: '"', regex: /"/g, escaped: "&quot;" }, ee2 = { quote: "'", regex: /'/g, escaped: "&apos;" }, te2 = R === "'" ? ee2 : Q, oe2 = te2 === ee2 ? Q : ee2, W2 = te2;
            if (H3.includes(te2.quote) || H3.includes(oe2.quote)) {
              let X3 = (H3.match(te2.regex) || []).length, ue2 = (H3.match(oe2.regex) || []).length;
              W2 = X3 > ue2 ? oe2 : te2;
            }
            return W2;
          }
          function l(H3, R) {
            let Q = H3.slice(1, -1), ee2 = R.parser === "json" || R.parser === "json5" && R.quoteProps === "preserve" && !R.singleQuote ? '"' : R.__isInHtmlAttribute ? "'" : F(Q, R.singleQuote ? "'" : '"').quote;
            return E(Q, ee2, !(R.parser === "css" || R.parser === "less" || R.parser === "scss" || R.__embeddedInHtml));
          }
          function E(H3, R, Q) {
            let ee2 = R === '"' ? "'" : '"', te2 = /\\(.)|(["'])/gs, oe2 = H3.replace(te2, (W2, X3, ue2) => X3 === ee2 ? X3 : ue2 === R ? "\\" + ue2 : ue2 || (Q && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(X3) ? X3 : "\\" + X3));
            return R + oe2 + R;
          }
          function y(H3) {
            return H3.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
          }
          function N(H3, R) {
            let Q = H3.match(new RegExp("(".concat(t(R), ")+"), "g"));
            return Q === null ? 0 : Q.reduce((ee2, te2) => Math.max(ee2, te2.length / R.length), 0);
          }
          function x2(H3, R) {
            let Q = H3.match(new RegExp("(".concat(t(R), ")+"), "g"));
            if (Q === null)
              return 0;
            let ee2 = /* @__PURE__ */ new Map(), te2 = 0;
            for (let oe2 of Q) {
              let W2 = oe2.length / R.length;
              ee2.set(W2, true), W2 > te2 && (te2 = W2);
            }
            for (let oe2 = 1; oe2 < te2; oe2++)
              if (!ee2.get(oe2))
                return oe2;
            return te2 + 1;
          }
          function b2(H3, R) {
            (H3.comments || (H3.comments = [])).push(R), R.printed = false, R.nodeDescription = Y3(H3);
          }
          function L(H3, R) {
            R.leading = true, R.trailing = false, b2(H3, R);
          }
          function M2(H3, R, Q) {
            R.leading = false, R.trailing = false, Q && (R.marker = Q), b2(H3, R);
          }
          function j(H3, R) {
            R.leading = false, R.trailing = true, b2(H3, R);
          }
          function $(H3, R) {
            let { languages: Q } = a3({ plugins: R.plugins }), ee2 = Q.find((te2) => {
              let { name: oe2 } = te2;
              return oe2.toLowerCase() === H3;
            }) || Q.find((te2) => {
              let { aliases: oe2 } = te2;
              return Array.isArray(oe2) && oe2.includes(H3);
            }) || Q.find((te2) => {
              let { extensions: oe2 } = te2;
              return Array.isArray(oe2) && oe2.includes(".".concat(H3));
            });
            return ee2 && ee2.parsers[0];
          }
          function V(H3) {
            return H3 && H3.type === "front-matter";
          }
          function q(H3) {
            let R = /* @__PURE__ */ new WeakMap();
            return function(Q) {
              return R.has(Q) || R.set(Q, Symbol(H3)), R.get(Q);
            };
          }
          function Y3(H3) {
            let R = H3.type || H3.kind || "(unknown type)", Q = String(H3.name || H3.id && (typeof H3.id == "object" ? H3.id.name : H3.id) || H3.key && (typeof H3.key == "object" ? H3.key.name : H3.key) || H3.value && (typeof H3.value == "object" ? "" : String(H3.value)) || H3.operator || "");
            return Q.length > 20 && (Q = Q.slice(0, 19) + "\u2026"), R + (Q ? " " + Q : "");
          }
          n.exports = { inferParserByLanguage: $, getStringWidth: u, getMaxContinuousCount: N, getMinNotPresentContinuousCount: x2, getPenultimate: h2, getLast: s2, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: f, getNextNonSpaceNonCommentCharacterIndex: k2, getNextNonSpaceNonCommentCharacter: P, skip: w2, skipWhitespace: i2, skipSpaces: o, skipToLineEnd: c, skipEverythingButNewLine: v, skipInlineComment: m2, skipTrailingComment: d4, skipNewline: p, isNextLineEmptyAfterIndex: B, isNextLineEmpty: I2, isPreviousLineEmpty: S2, hasNewline: T2, hasNewlineInRange: A2, hasSpaces: C2, getAlignmentSize: D2, getIndentSize: g2, getPreferredQuote: F, printString: l, printNumber: y, makeString: E, addLeadingComment: L, addDanglingComment: M2, addTrailingComment: j, isFrontMatterNode: V, isNonEmptyArray: r, createGroupIdMapper: q };
        } }), Ta2 = {};
        Ut2(Ta2, { basename: () => Pa2, default: () => Ia2, delimiter: () => Bn2, dirname: () => _a3, extname: () => ka2, isAbsolute: () => Wn2, join: () => Na2, normalize: () => Vn2, relative: () => wa2, resolve: () => Tr2, sep: () => Tn2 });
        function Ba2(e, n) {
          for (var t = 0, s2 = e.length - 1; s2 >= 0; s2--) {
            var a3 = e[s2];
            a3 === "." ? e.splice(s2, 1) : a3 === ".." ? (e.splice(s2, 1), t++) : t && (e.splice(s2, 1), t--);
          }
          if (n)
            for (; t--; t)
              e.unshift("..");
          return e;
        }
        function Tr2() {
          for (var e = "", n = false, t = arguments.length - 1; t >= -1 && !n; t--) {
            var s2 = t >= 0 ? arguments[t] : "/";
            if (typeof s2 != "string")
              throw new TypeError("Arguments to path.resolve must be strings");
            if (!s2)
              continue;
            e = s2 + "/" + e, n = s2.charAt(0) === "/";
          }
          return e = Ba2($n2(e.split("/"), function(a3) {
            return !!a3;
          }), !n).join("/"), (n ? "/" : "") + e || ".";
        }
        function Vn2(e) {
          var n = Wn2(e), t = La2(e, -1) === "/";
          return e = Ba2($n2(e.split("/"), function(s2) {
            return !!s2;
          }), !n).join("/"), !e && !n && (e = "."), e && t && (e += "/"), (n ? "/" : "") + e;
        }
        function Wn2(e) {
          return e.charAt(0) === "/";
        }
        function Na2() {
          var e = Array.prototype.slice.call(arguments, 0);
          return Vn2($n2(e, function(n, t) {
            if (typeof n != "string")
              throw new TypeError("Arguments to path.join must be strings");
            return n;
          }).join("/"));
        }
        function wa2(e, n) {
          e = Tr2(e).substr(1), n = Tr2(n).substr(1);
          function t(c) {
            for (var v = 0; v < c.length && c[v] === ""; v++)
              ;
            for (var m2 = c.length - 1; m2 >= 0 && c[m2] === ""; m2--)
              ;
            return v > m2 ? [] : c.slice(v, m2 - v + 1);
          }
          for (var s2 = t(e.split("/")), a3 = t(n.split("/")), r = Math.min(s2.length, a3.length), u = r, i2 = 0; i2 < r; i2++)
            if (s2[i2] !== a3[i2]) {
              u = i2;
              break;
            }
          for (var o = [], i2 = u; i2 < s2.length; i2++)
            o.push("..");
          return o = o.concat(a3.slice(u)), o.join("/");
        }
        function _a3(e) {
          var n = wr2(e), t = n[0], s2 = n[1];
          return !t && !s2 ? "." : (s2 && (s2 = s2.substr(0, s2.length - 1)), t + s2);
        }
        function Pa2(e, n) {
          var t = wr2(e)[2];
          return n && t.substr(-1 * n.length) === n && (t = t.substr(0, t.length - n.length)), t;
        }
        function ka2(e) {
          return wr2(e)[3];
        }
        function $n2(e, n) {
          if (e.filter)
            return e.filter(n);
          for (var t = [], s2 = 0; s2 < e.length; s2++)
            n(e[s2], s2, e) && t.push(e[s2]);
          return t;
        }
        var Da2, wr2, Tn2, Bn2, Ia2, La2, _D2 = mt2({ "node-modules-polyfills:path"() {
          re2(), Da2 = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, wr2 = function(e) {
            return Da2.exec(e).slice(1);
          }, Tn2 = "/", Bn2 = ":", Ia2 = { extname: ka2, basename: Pa2, dirname: _a3, sep: Tn2, delimiter: Bn2, relative: wa2, join: Na2, isAbsolute: Wn2, normalize: Vn2, resolve: Tr2 }, La2 = "ab".substr(-1) === "b" ? function(e, n, t) {
            return e.substr(n, t);
          } : function(e, n, t) {
            return n < 0 && (n = e.length + n), e.substr(n, t);
          };
        } }), PD2 = Z3({ "node-modules-polyfills-commonjs:path"(e, n) {
          re2();
          var t = (_D2(), lt2(Ta2));
          if (t && t.default) {
            n.exports = t.default;
            for (let s2 in t)
              n.exports[s2] = t[s2];
          } else
            t && (n.exports = t);
        } }), zt2 = Z3({ "src/common/errors.js"(e, n) {
          re2();
          var t = class extends Error {
          }, s2 = class extends Error {
          }, a3 = class extends Error {
          }, r = class extends Error {
          };
          n.exports = { ConfigError: t, DebugError: s2, UndefinedParserError: a3, ArgExpansionBailout: r };
        } }), dt2 = {};
        Ut2(dt2, { __assign: () => br2, __asyncDelegator: () => GD2, __asyncGenerator: () => HD2, __asyncValues: () => JD2, __await: () => Jt2, __awaiter: () => qD2, __classPrivateFieldGet: () => KD2, __classPrivateFieldSet: () => YD2, __createBinding: () => RD2, __decorate: () => LD2, __exportStar: () => VD2, __extends: () => kD2, __generator: () => MD2, __importDefault: () => XD2, __importStar: () => zD2, __makeTemplateObject: () => UD2, __metadata: () => OD2, __param: () => jD2, __read: () => ja2, __rest: () => ID2, __spread: () => WD2, __spreadArrays: () => $D2, __values: () => Nn2 });
        function kD2(e, n) {
          xr2(e, n);
          function t() {
            this.constructor = e;
          }
          e.prototype = n === null ? Object.create(n) : (t.prototype = n.prototype, new t());
        }
        function ID2(e, n) {
          var t = {};
          for (var s2 in e)
            Object.prototype.hasOwnProperty.call(e, s2) && n.indexOf(s2) < 0 && (t[s2] = e[s2]);
          if (e != null && typeof Object.getOwnPropertySymbols == "function")
            for (var a3 = 0, s2 = Object.getOwnPropertySymbols(e); a3 < s2.length; a3++)
              n.indexOf(s2[a3]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s2[a3]) && (t[s2[a3]] = e[s2[a3]]);
          return t;
        }
        function LD2(e, n, t, s2) {
          var a3 = arguments.length, r = a3 < 3 ? n : s2 === null ? s2 = Object.getOwnPropertyDescriptor(n, t) : s2, u;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            r = Reflect.decorate(e, n, t, s2);
          else
            for (var i2 = e.length - 1; i2 >= 0; i2--)
              (u = e[i2]) && (r = (a3 < 3 ? u(r) : a3 > 3 ? u(n, t, r) : u(n, t)) || r);
          return a3 > 3 && r && Object.defineProperty(n, t, r), r;
        }
        function jD2(e, n) {
          return function(t, s2) {
            n(t, s2, e);
          };
        }
        function OD2(e, n) {
          if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
            return Reflect.metadata(e, n);
        }
        function qD2(e, n, t, s2) {
          function a3(r) {
            return r instanceof t ? r : new t(function(u) {
              u(r);
            });
          }
          return new (t || (t = Promise))(function(r, u) {
            function i2(v) {
              try {
                c(s2.next(v));
              } catch (m2) {
                u(m2);
              }
            }
            function o(v) {
              try {
                c(s2.throw(v));
              } catch (m2) {
                u(m2);
              }
            }
            function c(v) {
              v.done ? r(v.value) : a3(v.value).then(i2, o);
            }
            c((s2 = s2.apply(e, n || [])).next());
          });
        }
        function MD2(e, n) {
          var t = { label: 0, sent: function() {
            if (r[0] & 1)
              throw r[1];
            return r[1];
          }, trys: [], ops: [] }, s2, a3, r, u;
          return u = { next: i2(0), throw: i2(1), return: i2(2) }, typeof Symbol == "function" && (u[Symbol.iterator] = function() {
            return this;
          }), u;
          function i2(c) {
            return function(v) {
              return o([c, v]);
            };
          }
          function o(c) {
            if (s2)
              throw new TypeError("Generator is already executing.");
            for (; t; )
              try {
                if (s2 = 1, a3 && (r = c[0] & 2 ? a3.return : c[0] ? a3.throw || ((r = a3.return) && r.call(a3), 0) : a3.next) && !(r = r.call(a3, c[1])).done)
                  return r;
                switch (a3 = 0, r && (c = [c[0] & 2, r.value]), c[0]) {
                  case 0:
                  case 1:
                    r = c;
                    break;
                  case 4:
                    return t.label++, { value: c[1], done: false };
                  case 5:
                    t.label++, a3 = c[1], c = [0];
                    continue;
                  case 7:
                    c = t.ops.pop(), t.trys.pop();
                    continue;
                  default:
                    if (r = t.trys, !(r = r.length > 0 && r[r.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                      t = 0;
                      continue;
                    }
                    if (c[0] === 3 && (!r || c[1] > r[0] && c[1] < r[3])) {
                      t.label = c[1];
                      break;
                    }
                    if (c[0] === 6 && t.label < r[1]) {
                      t.label = r[1], r = c;
                      break;
                    }
                    if (r && t.label < r[2]) {
                      t.label = r[2], t.ops.push(c);
                      break;
                    }
                    r[2] && t.ops.pop(), t.trys.pop();
                    continue;
                }
                c = n.call(e, t);
              } catch (v) {
                c = [6, v], a3 = 0;
              } finally {
                s2 = r = 0;
              }
            if (c[0] & 5)
              throw c[1];
            return { value: c[0] ? c[1] : void 0, done: true };
          }
        }
        function RD2(e, n, t, s2) {
          s2 === void 0 && (s2 = t), e[s2] = n[t];
        }
        function VD2(e, n) {
          for (var t in e)
            t !== "default" && !n.hasOwnProperty(t) && (n[t] = e[t]);
        }
        function Nn2(e) {
          var n = typeof Symbol == "function" && Symbol.iterator, t = n && e[n], s2 = 0;
          if (t)
            return t.call(e);
          if (e && typeof e.length == "number")
            return { next: function() {
              return e && s2 >= e.length && (e = void 0), { value: e && e[s2++], done: !e };
            } };
          throw new TypeError(n ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }
        function ja2(e, n) {
          var t = typeof Symbol == "function" && e[Symbol.iterator];
          if (!t)
            return e;
          var s2 = t.call(e), a3, r = [], u;
          try {
            for (; (n === void 0 || n-- > 0) && !(a3 = s2.next()).done; )
              r.push(a3.value);
          } catch (i2) {
            u = { error: i2 };
          } finally {
            try {
              a3 && !a3.done && (t = s2.return) && t.call(s2);
            } finally {
              if (u)
                throw u.error;
            }
          }
          return r;
        }
        function WD2() {
          for (var e = [], n = 0; n < arguments.length; n++)
            e = e.concat(ja2(arguments[n]));
          return e;
        }
        function $D2() {
          for (var e = 0, n = 0, t = arguments.length; n < t; n++)
            e += arguments[n].length;
          for (var s2 = Array(e), a3 = 0, n = 0; n < t; n++)
            for (var r = arguments[n], u = 0, i2 = r.length; u < i2; u++, a3++)
              s2[a3] = r[u];
          return s2;
        }
        function Jt2(e) {
          return this instanceof Jt2 ? (this.v = e, this) : new Jt2(e);
        }
        function HD2(e, n, t) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var s2 = t.apply(e, n || []), a3, r = [];
          return a3 = {}, u("next"), u("throw"), u("return"), a3[Symbol.asyncIterator] = function() {
            return this;
          }, a3;
          function u(d4) {
            s2[d4] && (a3[d4] = function(p) {
              return new Promise(function(f, h2) {
                r.push([d4, p, f, h2]) > 1 || i2(d4, p);
              });
            });
          }
          function i2(d4, p) {
            try {
              o(s2[d4](p));
            } catch (f) {
              m2(r[0][3], f);
            }
          }
          function o(d4) {
            d4.value instanceof Jt2 ? Promise.resolve(d4.value.v).then(c, v) : m2(r[0][2], d4);
          }
          function c(d4) {
            i2("next", d4);
          }
          function v(d4) {
            i2("throw", d4);
          }
          function m2(d4, p) {
            d4(p), r.shift(), r.length && i2(r[0][0], r[0][1]);
          }
        }
        function GD2(e) {
          var n, t;
          return n = {}, s2("next"), s2("throw", function(a3) {
            throw a3;
          }), s2("return"), n[Symbol.iterator] = function() {
            return this;
          }, n;
          function s2(a3, r) {
            n[a3] = e[a3] ? function(u) {
              return (t = !t) ? { value: Jt2(e[a3](u)), done: a3 === "return" } : r ? r(u) : u;
            } : r;
          }
        }
        function JD2(e) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var n = e[Symbol.asyncIterator], t;
          return n ? n.call(e) : (e = typeof Nn2 == "function" ? Nn2(e) : e[Symbol.iterator](), t = {}, s2("next"), s2("throw"), s2("return"), t[Symbol.asyncIterator] = function() {
            return this;
          }, t);
          function s2(r) {
            t[r] = e[r] && function(u) {
              return new Promise(function(i2, o) {
                u = e[r](u), a3(i2, o, u.done, u.value);
              });
            };
          }
          function a3(r, u, i2, o) {
            Promise.resolve(o).then(function(c) {
              r({ value: c, done: i2 });
            }, u);
          }
        }
        function UD2(e, n) {
          return Object.defineProperty ? Object.defineProperty(e, "raw", { value: n }) : e.raw = n, e;
        }
        function zD2(e) {
          if (e && e.__esModule)
            return e;
          var n = {};
          if (e != null)
            for (var t in e)
              Object.hasOwnProperty.call(e, t) && (n[t] = e[t]);
          return n.default = e, n;
        }
        function XD2(e) {
          return e && e.__esModule ? e : { default: e };
        }
        function KD2(e, n) {
          if (!n.has(e))
            throw new TypeError("attempted to get private field on non-instance");
          return n.get(e);
        }
        function YD2(e, n, t) {
          if (!n.has(e))
            throw new TypeError("attempted to set private field on non-instance");
          return n.set(e, t), t;
        }
        var xr2, br2, ht2 = mt2({ "node_modules/tslib/tslib.es6.js"() {
          re2(), xr2 = function(e, n) {
            return xr2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, s2) {
              t.__proto__ = s2;
            } || function(t, s2) {
              for (var a3 in s2)
                s2.hasOwnProperty(a3) && (t[a3] = s2[a3]);
            }, xr2(e, n);
          }, br2 = function() {
            return br2 = Object.assign || function(n) {
              for (var t, s2 = 1, a3 = arguments.length; s2 < a3; s2++) {
                t = arguments[s2];
                for (var r in t)
                  Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
              }
              return n;
            }, br2.apply(this, arguments);
          };
        } }), Oa2 = Z3({ "node_modules/vnopts/lib/descriptors/api.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true }), e.apiDescriptor = { key: (n) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(n) ? n : JSON.stringify(n), value(n) {
            if (n === null || typeof n != "object")
              return JSON.stringify(n);
            if (Array.isArray(n))
              return "[".concat(n.map((s2) => e.apiDescriptor.value(s2)).join(", "), "]");
            let t = Object.keys(n);
            return t.length === 0 ? "{}" : "{ ".concat(t.map((s2) => "".concat(e.apiDescriptor.key(s2), ": ").concat(e.apiDescriptor.value(n[s2]))).join(", "), " }");
          }, pair: (n) => {
            let { key: t, value: s2 } = n;
            return e.apiDescriptor.value({ [t]: s2 });
          } };
        } }), QD2 = Z3({ "node_modules/vnopts/lib/descriptors/index.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true });
          var n = (ht2(), lt2(dt2));
          n.__exportStar(Oa2(), e);
        } }), _r2 = Z3({ "scripts/build/shims/chalk.cjs"(e, n) {
          re2();
          var t = (s2) => s2;
          t.grey = t, t.red = t, t.bold = t, t.yellow = t, t.blue = t, t.default = t, n.exports = t;
        } }), qa2 = Z3({ "node_modules/vnopts/lib/handlers/deprecated/common.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true });
          var n = _r2();
          e.commonDeprecatedHandler = (t, s2, a3) => {
            let { descriptor: r } = a3, u = ["".concat(n.default.yellow(typeof t == "string" ? r.key(t) : r.pair(t)), " is deprecated")];
            return s2 && u.push("we now treat it as ".concat(n.default.blue(typeof s2 == "string" ? r.key(s2) : r.pair(s2)))), u.join("; ") + ".";
          };
        } }), ZD2 = Z3({ "node_modules/vnopts/lib/handlers/deprecated/index.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true });
          var n = (ht2(), lt2(dt2));
          n.__exportStar(qa2(), e);
        } }), em2 = Z3({ "node_modules/vnopts/lib/handlers/invalid/common.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true });
          var n = _r2();
          e.commonInvalidHandler = (t, s2, a3) => ["Invalid ".concat(n.default.red(a3.descriptor.key(t)), " value."), "Expected ".concat(n.default.blue(a3.schemas[t].expected(a3)), ","), "but received ".concat(n.default.red(a3.descriptor.value(s2)), ".")].join(" ");
        } }), Ma2 = Z3({ "node_modules/vnopts/lib/handlers/invalid/index.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true });
          var n = (ht2(), lt2(dt2));
          n.__exportStar(em2(), e);
        } }), tm2 = Z3({ "node_modules/vnopts/node_modules/leven/index.js"(e, n) {
          re2();
          var t = [], s2 = [];
          n.exports = function(a3, r) {
            if (a3 === r)
              return 0;
            var u = a3;
            a3.length > r.length && (a3 = r, r = u);
            var i2 = a3.length, o = r.length;
            if (i2 === 0)
              return o;
            if (o === 0)
              return i2;
            for (; i2 > 0 && a3.charCodeAt(~-i2) === r.charCodeAt(~-o); )
              i2--, o--;
            if (i2 === 0)
              return o;
            for (var c = 0; c < i2 && a3.charCodeAt(c) === r.charCodeAt(c); )
              c++;
            if (i2 -= c, o -= c, i2 === 0)
              return o;
            for (var v, m2, d4, p, f = 0, h2 = 0; f < i2; )
              s2[c + f] = a3.charCodeAt(c + f), t[f] = ++f;
            for (; h2 < o; )
              for (v = r.charCodeAt(c + h2), d4 = h2++, m2 = h2, f = 0; f < i2; f++)
                p = v === s2[c + f] ? d4 : d4 + 1, d4 = t[f], m2 = t[f] = d4 > m2 ? p > m2 ? m2 + 1 : p : p > d4 ? d4 + 1 : p;
            return m2;
          };
        } }), Ra2 = Z3({ "node_modules/vnopts/lib/handlers/unknown/leven.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true });
          var n = _r2(), t = tm2();
          e.levenUnknownHandler = (s2, a3, r) => {
            let { descriptor: u, logger: i2, schemas: o } = r, c = ["Ignored unknown option ".concat(n.default.yellow(u.pair({ key: s2, value: a3 })), ".")], v = Object.keys(o).sort().find((m2) => t(s2, m2) < 3);
            v && c.push("Did you mean ".concat(n.default.blue(u.key(v)), "?")), i2.warn(c.join(" "));
          };
        } }), rm2 = Z3({ "node_modules/vnopts/lib/handlers/unknown/index.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true });
          var n = (ht2(), lt2(dt2));
          n.__exportStar(Ra2(), e);
        } }), nm2 = Z3({ "node_modules/vnopts/lib/handlers/index.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true });
          var n = (ht2(), lt2(dt2));
          n.__exportStar(ZD2(), e), n.__exportStar(Ma2(), e), n.__exportStar(rm2(), e);
        } }), vt2 = Z3({ "node_modules/vnopts/lib/schema.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true });
          var n = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
          function t(r, u) {
            let i2 = new r(u), o = Object.create(i2);
            for (let c of n)
              c in u && (o[c] = a3(u[c], i2, s2.prototype[c].length));
            return o;
          }
          e.createSchema = t;
          var s2 = class {
            constructor(r) {
              this.name = r.name;
            }
            static create(r) {
              return t(this, r);
            }
            default(r) {
            }
            expected(r) {
              return "nothing";
            }
            validate(r, u) {
              return false;
            }
            deprecated(r, u) {
              return false;
            }
            forward(r, u) {
            }
            redirect(r, u) {
            }
            overlap(r, u, i2) {
              return r;
            }
            preprocess(r, u) {
              return r;
            }
            postprocess(r, u) {
              return r;
            }
          };
          e.Schema = s2;
          function a3(r, u, i2) {
            return typeof r == "function" ? function() {
              for (var o = arguments.length, c = new Array(o), v = 0; v < o; v++)
                c[v] = arguments[v];
              return r(...c.slice(0, i2 - 1), u, ...c.slice(i2 - 1));
            } : () => r;
          }
        } }), um2 = Z3({ "node_modules/vnopts/lib/schemas/alias.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true });
          var n = vt2(), t = class extends n.Schema {
            constructor(s2) {
              super(s2), this._sourceName = s2.sourceName;
            }
            expected(s2) {
              return s2.schemas[this._sourceName].expected(s2);
            }
            validate(s2, a3) {
              return a3.schemas[this._sourceName].validate(s2, a3);
            }
            redirect(s2, a3) {
              return this._sourceName;
            }
          };
          e.AliasSchema = t;
        } }), sm2 = Z3({ "node_modules/vnopts/lib/schemas/any.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true });
          var n = vt2(), t = class extends n.Schema {
            expected() {
              return "anything";
            }
            validate() {
              return true;
            }
          };
          e.AnySchema = t;
        } }), im2 = Z3({ "node_modules/vnopts/lib/schemas/array.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true });
          var n = (ht2(), lt2(dt2)), t = vt2(), s2 = class extends t.Schema {
            constructor(r) {
              var { valueSchema: u, name: i2 = u.name } = r, o = n.__rest(r, ["valueSchema", "name"]);
              super(Object.assign({}, o, { name: i2 })), this._valueSchema = u;
            }
            expected(r) {
              return "an array of ".concat(this._valueSchema.expected(r));
            }
            validate(r, u) {
              if (!Array.isArray(r))
                return false;
              let i2 = [];
              for (let o of r) {
                let c = u.normalizeValidateResult(this._valueSchema.validate(o, u), o);
                c !== true && i2.push(c.value);
              }
              return i2.length === 0 ? true : { value: i2 };
            }
            deprecated(r, u) {
              let i2 = [];
              for (let o of r) {
                let c = u.normalizeDeprecatedResult(this._valueSchema.deprecated(o, u), o);
                c !== false && i2.push(...c.map((v) => {
                  let { value: m2 } = v;
                  return { value: [m2] };
                }));
              }
              return i2;
            }
            forward(r, u) {
              let i2 = [];
              for (let o of r) {
                let c = u.normalizeForwardResult(this._valueSchema.forward(o, u), o);
                i2.push(...c.map(a3));
              }
              return i2;
            }
            redirect(r, u) {
              let i2 = [], o = [];
              for (let c of r) {
                let v = u.normalizeRedirectResult(this._valueSchema.redirect(c, u), c);
                "remain" in v && i2.push(v.remain), o.push(...v.redirect.map(a3));
              }
              return i2.length === 0 ? { redirect: o } : { redirect: o, remain: i2 };
            }
            overlap(r, u) {
              return r.concat(u);
            }
          };
          e.ArraySchema = s2;
          function a3(r) {
            let { from: u, to: i2 } = r;
            return { from: [u], to: i2 };
          }
        } }), am2 = Z3({ "node_modules/vnopts/lib/schemas/boolean.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true });
          var n = vt2(), t = class extends n.Schema {
            expected() {
              return "true or false";
            }
            validate(s2) {
              return typeof s2 == "boolean";
            }
          };
          e.BooleanSchema = t;
        } }), Hn2 = Z3({ "node_modules/vnopts/lib/utils.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true });
          function n(p, f) {
            let h2 = /* @__PURE__ */ Object.create(null);
            for (let w2 of p) {
              let T2 = w2[f];
              if (h2[T2])
                throw new Error("Duplicate ".concat(f, " ").concat(JSON.stringify(T2)));
              h2[T2] = w2;
            }
            return h2;
          }
          e.recordFromArray = n;
          function t(p, f) {
            let h2 = /* @__PURE__ */ new Map();
            for (let w2 of p) {
              let T2 = w2[f];
              if (h2.has(T2))
                throw new Error("Duplicate ".concat(f, " ").concat(JSON.stringify(T2)));
              h2.set(T2, w2);
            }
            return h2;
          }
          e.mapFromArray = t;
          function s2() {
            let p = /* @__PURE__ */ Object.create(null);
            return (f) => {
              let h2 = JSON.stringify(f);
              return p[h2] ? true : (p[h2] = true, false);
            };
          }
          e.createAutoChecklist = s2;
          function a3(p, f) {
            let h2 = [], w2 = [];
            for (let T2 of p)
              f(T2) ? h2.push(T2) : w2.push(T2);
            return [h2, w2];
          }
          e.partition = a3;
          function r(p) {
            return p === Math.floor(p);
          }
          e.isInt = r;
          function u(p, f) {
            if (p === f)
              return 0;
            let h2 = typeof p, w2 = typeof f, T2 = ["undefined", "object", "boolean", "number", "string"];
            return h2 !== w2 ? T2.indexOf(h2) - T2.indexOf(w2) : h2 !== "string" ? Number(p) - Number(f) : p.localeCompare(f);
          }
          e.comparePrimitive = u;
          function i2(p) {
            return p === void 0 ? {} : p;
          }
          e.normalizeDefaultResult = i2;
          function o(p, f) {
            return p === true ? true : p === false ? { value: f } : p;
          }
          e.normalizeValidateResult = o;
          function c(p, f) {
            let h2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            return p === false ? false : p === true ? h2 ? true : [{ value: f }] : "value" in p ? [p] : p.length === 0 ? false : p;
          }
          e.normalizeDeprecatedResult = c;
          function v(p, f) {
            return typeof p == "string" || "key" in p ? { from: f, to: p } : "from" in p ? { from: p.from, to: p.to } : { from: f, to: p.to };
          }
          e.normalizeTransferResult = v;
          function m2(p, f) {
            return p === void 0 ? [] : Array.isArray(p) ? p.map((h2) => v(h2, f)) : [v(p, f)];
          }
          e.normalizeForwardResult = m2;
          function d4(p, f) {
            let h2 = m2(typeof p == "object" && "redirect" in p ? p.redirect : p, f);
            return h2.length === 0 ? { remain: f, redirect: h2 } : typeof p == "object" && "remain" in p ? { remain: p.remain, redirect: h2 } : { redirect: h2 };
          }
          e.normalizeRedirectResult = d4;
        } }), om2 = Z3({ "node_modules/vnopts/lib/schemas/choice.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true });
          var n = vt2(), t = Hn2(), s2 = class extends n.Schema {
            constructor(a3) {
              super(a3), this._choices = t.mapFromArray(a3.choices.map((r) => r && typeof r == "object" ? r : { value: r }), "value");
            }
            expected(a3) {
              let { descriptor: r } = a3, u = Array.from(this._choices.keys()).map((c) => this._choices.get(c)).filter((c) => !c.deprecated).map((c) => c.value).sort(t.comparePrimitive).map(r.value), i2 = u.slice(0, -2), o = u.slice(-2);
              return i2.concat(o.join(" or ")).join(", ");
            }
            validate(a3) {
              return this._choices.has(a3);
            }
            deprecated(a3) {
              let r = this._choices.get(a3);
              return r && r.deprecated ? { value: a3 } : false;
            }
            forward(a3) {
              let r = this._choices.get(a3);
              return r ? r.forward : void 0;
            }
            redirect(a3) {
              let r = this._choices.get(a3);
              return r ? r.redirect : void 0;
            }
          };
          e.ChoiceSchema = s2;
        } }), Va2 = Z3({ "node_modules/vnopts/lib/schemas/number.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true });
          var n = vt2(), t = class extends n.Schema {
            expected() {
              return "a number";
            }
            validate(s2, a3) {
              return typeof s2 == "number";
            }
          };
          e.NumberSchema = t;
        } }), lm2 = Z3({ "node_modules/vnopts/lib/schemas/integer.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true });
          var n = Hn2(), t = Va2(), s2 = class extends t.NumberSchema {
            expected() {
              return "an integer";
            }
            validate(a3, r) {
              return r.normalizeValidateResult(super.validate(a3, r), a3) === true && n.isInt(a3);
            }
          };
          e.IntegerSchema = s2;
        } }), cm2 = Z3({ "node_modules/vnopts/lib/schemas/string.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true });
          var n = vt2(), t = class extends n.Schema {
            expected() {
              return "a string";
            }
            validate(s2) {
              return typeof s2 == "string";
            }
          };
          e.StringSchema = t;
        } }), pm2 = Z3({ "node_modules/vnopts/lib/schemas/index.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true });
          var n = (ht2(), lt2(dt2));
          n.__exportStar(um2(), e), n.__exportStar(sm2(), e), n.__exportStar(im2(), e), n.__exportStar(am2(), e), n.__exportStar(om2(), e), n.__exportStar(lm2(), e), n.__exportStar(Va2(), e), n.__exportStar(cm2(), e);
        } }), fm2 = Z3({ "node_modules/vnopts/lib/defaults.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true });
          var n = Oa2(), t = qa2(), s2 = Ma2(), a3 = Ra2();
          e.defaultDescriptor = n.apiDescriptor, e.defaultUnknownHandler = a3.levenUnknownHandler, e.defaultInvalidHandler = s2.commonInvalidHandler, e.defaultDeprecatedHandler = t.commonDeprecatedHandler;
        } }), Dm2 = Z3({ "node_modules/vnopts/lib/normalize.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true });
          var n = fm2(), t = Hn2();
          e.normalize = (a3, r, u) => new s2(r, u).normalize(a3);
          var s2 = class {
            constructor(a3, r) {
              let { logger: u = console, descriptor: i2 = n.defaultDescriptor, unknown: o = n.defaultUnknownHandler, invalid: c = n.defaultInvalidHandler, deprecated: v = n.defaultDeprecatedHandler } = r || {};
              this._utils = { descriptor: i2, logger: u || { warn: () => {
              } }, schemas: t.recordFromArray(a3, "name"), normalizeDefaultResult: t.normalizeDefaultResult, normalizeDeprecatedResult: t.normalizeDeprecatedResult, normalizeForwardResult: t.normalizeForwardResult, normalizeRedirectResult: t.normalizeRedirectResult, normalizeValidateResult: t.normalizeValidateResult }, this._unknownHandler = o, this._invalidHandler = c, this._deprecatedHandler = v, this.cleanHistory();
            }
            cleanHistory() {
              this._hasDeprecationWarned = t.createAutoChecklist();
            }
            normalize(a3) {
              let r = {}, u = [a3], i2 = () => {
                for (; u.length !== 0; ) {
                  let o = u.shift(), c = this._applyNormalization(o, r);
                  u.push(...c);
                }
              };
              i2();
              for (let o of Object.keys(this._utils.schemas)) {
                let c = this._utils.schemas[o];
                if (!(o in r)) {
                  let v = t.normalizeDefaultResult(c.default(this._utils));
                  "value" in v && u.push({ [o]: v.value });
                }
              }
              i2();
              for (let o of Object.keys(this._utils.schemas)) {
                let c = this._utils.schemas[o];
                o in r && (r[o] = c.postprocess(r[o], this._utils));
              }
              return r;
            }
            _applyNormalization(a3, r) {
              let u = [], [i2, o] = t.partition(Object.keys(a3), (c) => c in this._utils.schemas);
              for (let c of i2) {
                let v = this._utils.schemas[c], m2 = v.preprocess(a3[c], this._utils), d4 = t.normalizeValidateResult(v.validate(m2, this._utils), m2);
                if (d4 !== true) {
                  let { value: T2 } = d4, A2 = this._invalidHandler(c, T2, this._utils);
                  throw typeof A2 == "string" ? new Error(A2) : A2;
                }
                let p = (T2) => {
                  let { from: A2, to: S2 } = T2;
                  u.push(typeof S2 == "string" ? { [S2]: A2 } : { [S2.key]: S2.value });
                }, f = (T2) => {
                  let { value: A2, redirectTo: S2 } = T2, B = t.normalizeDeprecatedResult(v.deprecated(A2, this._utils), m2, true);
                  if (B !== false)
                    if (B === true)
                      this._hasDeprecationWarned(c) || this._utils.logger.warn(this._deprecatedHandler(c, S2, this._utils));
                    else
                      for (let { value: I2 } of B) {
                        let k2 = { key: c, value: I2 };
                        if (!this._hasDeprecationWarned(k2)) {
                          let P = typeof S2 == "string" ? { key: S2, value: I2 } : S2;
                          this._utils.logger.warn(this._deprecatedHandler(k2, P, this._utils));
                        }
                      }
                };
                t.normalizeForwardResult(v.forward(m2, this._utils), m2).forEach(p);
                let w2 = t.normalizeRedirectResult(v.redirect(m2, this._utils), m2);
                if (w2.redirect.forEach(p), "remain" in w2) {
                  let T2 = w2.remain;
                  r[c] = c in r ? v.overlap(r[c], T2, this._utils) : T2, f({ value: T2 });
                }
                for (let { from: T2, to: A2 } of w2.redirect)
                  f({ value: T2, redirectTo: A2 });
              }
              for (let c of o) {
                let v = a3[c], m2 = this._unknownHandler(c, v, this._utils);
                if (m2)
                  for (let d4 of Object.keys(m2)) {
                    let p = { [d4]: m2[d4] };
                    d4 in this._utils.schemas ? u.push(p) : Object.assign(r, p);
                  }
              }
              return u;
            }
          };
          e.Normalizer = s2;
        } }), mm3 = Z3({ "node_modules/vnopts/lib/index.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true });
          var n = (ht2(), lt2(dt2));
          n.__exportStar(QD2(), e), n.__exportStar(nm2(), e), n.__exportStar(pm2(), e), n.__exportStar(Dm2(), e), n.__exportStar(vt2(), e);
        } }), dm2 = Z3({ "src/main/options-normalizer.js"(e, n) {
          re2();
          var t = mm3(), s2 = it2(), a3 = { key: (d4) => d4.length === 1 ? "-".concat(d4) : "--".concat(d4), value: (d4) => t.apiDescriptor.value(d4), pair: (d4) => {
            let { key: p, value: f } = d4;
            return f === false ? "--no-".concat(p) : f === true ? a3.key(p) : f === "" ? "".concat(a3.key(p), " without an argument") : "".concat(a3.key(p), "=").concat(f);
          } }, r = (d4) => {
            let { colorsModule: p, levenshteinDistance: f } = d4;
            return class extends t.ChoiceSchema {
              constructor(w2) {
                let { name: T2, flags: A2 } = w2;
                super({ name: T2, choices: A2 }), this._flags = [...A2].sort();
              }
              preprocess(w2, T2) {
                if (typeof w2 == "string" && w2.length > 0 && !this._flags.includes(w2)) {
                  let A2 = this._flags.find((S2) => f(S2, w2) < 3);
                  if (A2)
                    return T2.logger.warn(["Unknown flag ".concat(p.yellow(T2.descriptor.value(w2)), ","), "did you mean ".concat(p.blue(T2.descriptor.value(A2)), "?")].join(" ")), A2;
                }
                return w2;
              }
              expected() {
                return "a flag";
              }
            };
          }, u;
          function i2(d4, p) {
            let { logger: f = false, isCLI: h2 = false, passThrough: w2 = false, colorsModule: T2 = null, levenshteinDistance: A2 = null } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, S2 = w2 ? Array.isArray(w2) ? (D2, g2) => w2.includes(D2) ? { [D2]: g2 } : void 0 : (D2, g2) => ({ [D2]: g2 }) : (D2, g2, F) => {
              let l = F.schemas, y = kn2(l, Qf2);
              return t.levenUnknownHandler(D2, g2, Object.assign(Object.assign({}, F), {}, { schemas: y }));
            }, B = h2 ? a3 : t.apiDescriptor, I2 = o(p, { isCLI: h2, colorsModule: T2, levenshteinDistance: A2 }), k2 = new t.Normalizer(I2, { logger: f, unknown: S2, descriptor: B }), P = f !== false;
            P && u && (k2._hasDeprecationWarned = u);
            let C2 = k2.normalize(d4);
            return P && (u = k2._hasDeprecationWarned), h2 && C2["plugin-search"] === false && (C2["plugin-search-dir"] = false), C2;
          }
          function o(d4, p) {
            let { isCLI: f, colorsModule: h2, levenshteinDistance: w2 } = p, T2 = [];
            f && T2.push(t.AnySchema.create({ name: "_" }));
            for (let A2 of d4)
              T2.push(c(A2, { isCLI: f, optionInfos: d4, colorsModule: h2, levenshteinDistance: w2 })), A2.alias && f && T2.push(t.AliasSchema.create({ name: A2.alias, sourceName: A2.name }));
            return T2;
          }
          function c(d4, p) {
            let { isCLI: f, optionInfos: h2, colorsModule: w2, levenshteinDistance: T2 } = p, { name: A2 } = d4;
            if (A2 === "plugin-search-dir" || A2 === "pluginSearchDirs")
              return t.AnySchema.create({ name: A2, preprocess(k2) {
                return k2 === false || (k2 = Array.isArray(k2) ? k2 : [k2]), k2;
              }, validate(k2) {
                return k2 === false ? true : k2.every((P) => typeof P == "string");
              }, expected() {
                return "false or paths to plugin search dir";
              } });
            let S2 = { name: A2 }, B, I2 = {};
            switch (d4.type) {
              case "int":
                B = t.IntegerSchema, f && (S2.preprocess = Number);
                break;
              case "string":
                B = t.StringSchema;
                break;
              case "choice":
                B = t.ChoiceSchema, S2.choices = d4.choices.map((k2) => typeof k2 == "object" && k2.redirect ? Object.assign(Object.assign({}, k2), {}, { redirect: { to: { key: d4.name, value: k2.redirect } } }) : k2);
                break;
              case "boolean":
                B = t.BooleanSchema;
                break;
              case "flag":
                B = r({ colorsModule: w2, levenshteinDistance: T2 }), S2.flags = h2.flatMap((k2) => [k2.alias, k2.description && k2.name, k2.oppositeDescription && "no-".concat(k2.name)].filter(Boolean));
                break;
              case "path":
                B = t.StringSchema;
                break;
              default:
                throw new Error("Unexpected type ".concat(d4.type));
            }
            if (d4.exception ? S2.validate = (k2, P, C2) => d4.exception(k2) || P.validate(k2, C2) : S2.validate = (k2, P, C2) => k2 === void 0 || P.validate(k2, C2), d4.redirect && (I2.redirect = (k2) => k2 ? { to: { key: d4.redirect.option, value: d4.redirect.value } } : void 0), d4.deprecated && (I2.deprecated = true), f && !d4.array) {
              let k2 = S2.preprocess || ((P) => P);
              S2.preprocess = (P, C2, D2) => C2.preprocess(k2(Array.isArray(P) ? s2(P) : P), D2);
            }
            return d4.array ? t.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, f ? { preprocess: (k2) => Array.isArray(k2) ? k2 : [k2] } : {}), I2), {}, { valueSchema: B.create(S2) })) : B.create(Object.assign(Object.assign({}, S2), I2));
          }
          function v(d4, p, f) {
            return i2(d4, p, f);
          }
          function m2(d4, p, f) {
            return i2(d4, p, Object.assign({ isCLI: true }, f));
          }
          n.exports = { normalizeApiOptions: v, normalizeCliOptions: m2 };
        } }), st2 = Z3({ "src/language-js/loc.js"(e, n) {
          re2();
          var t = Rn2();
          function s2(o, c) {
            let { ignoreDecorators: v } = c || {};
            if (!v) {
              let m2 = o.declaration && o.declaration.decorators || o.decorators;
              if (t(m2))
                return s2(m2[0]);
            }
            return o.range ? o.range[0] : o.start;
          }
          function a3(o) {
            return o.range ? o.range[1] : o.end;
          }
          function r(o, c) {
            let v = s2(o);
            return Number.isInteger(v) && v === s2(c);
          }
          function u(o, c) {
            let v = a3(o);
            return Number.isInteger(v) && v === a3(c);
          }
          function i2(o, c) {
            return r(o, c) && u(o, c);
          }
          n.exports = { locStart: s2, locEnd: a3, hasSameLocStart: r, hasSameLoc: i2 };
        } }), gm2 = Z3({ "src/main/load-parser.js"(e, n) {
          re2(), n.exports = () => {
          };
        } }), ym2 = Z3({ "scripts/build/shims/babel-highlight.cjs"(e, n) {
          re2();
          var t = _r2(), s2 = { shouldHighlight: () => false, getChalk: () => t };
          n.exports = s2;
        } }), hm2 = Z3({ "node_modules/@babel/code-frame/lib/index.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true }), e.codeFrameColumns = u, e.default = i2;
          var n = ym2(), t = false;
          function s2(o) {
            return { gutter: o.grey, marker: o.red.bold, message: o.red.bold };
          }
          var a3 = /\r\n|[\n\r\u2028\u2029]/;
          function r(o, c, v) {
            let m2 = Object.assign({ column: 0, line: -1 }, o.start), d4 = Object.assign({}, m2, o.end), { linesAbove: p = 2, linesBelow: f = 3 } = v || {}, h2 = m2.line, w2 = m2.column, T2 = d4.line, A2 = d4.column, S2 = Math.max(h2 - (p + 1), 0), B = Math.min(c.length, T2 + f);
            h2 === -1 && (S2 = 0), T2 === -1 && (B = c.length);
            let I2 = T2 - h2, k2 = {};
            if (I2)
              for (let P = 0; P <= I2; P++) {
                let C2 = P + h2;
                if (!w2)
                  k2[C2] = true;
                else if (P === 0) {
                  let D2 = c[C2 - 1].length;
                  k2[C2] = [w2, D2 - w2 + 1];
                } else if (P === I2)
                  k2[C2] = [0, A2];
                else {
                  let D2 = c[C2 - P].length;
                  k2[C2] = [0, D2];
                }
              }
            else
              w2 === A2 ? w2 ? k2[h2] = [w2, 0] : k2[h2] = true : k2[h2] = [w2, A2 - w2];
            return { start: S2, end: B, markerLines: k2 };
          }
          function u(o, c) {
            let v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, m2 = (v.highlightCode || v.forceColor) && (0, n.shouldHighlight)(v), d4 = (0, n.getChalk)(v), p = s2(d4), f = (P, C2) => m2 ? P(C2) : C2, h2 = o.split(a3), { start: w2, end: T2, markerLines: A2 } = r(c, h2, v), S2 = c.start && typeof c.start.column == "number", B = String(T2).length, k2 = (m2 ? (0, n.default)(o, v) : o).split(a3, T2).slice(w2, T2).map((P, C2) => {
              let D2 = w2 + 1 + C2, g2 = " ".concat(D2).slice(-B), F = " ".concat(g2, " |"), l = A2[D2], E = !A2[D2 + 1];
              if (l) {
                let y = "";
                if (Array.isArray(l)) {
                  let N = P.slice(0, Math.max(l[0] - 1, 0)).replace(/[^\t]/g, " "), x2 = l[1] || 1;
                  y = [`
 `, f(p.gutter, F.replace(/\d/g, " ")), " ", N, f(p.marker, "^").repeat(x2)].join(""), E && v.message && (y += " " + f(p.message, v.message));
                }
                return [f(p.marker, ">"), f(p.gutter, F), P.length > 0 ? " ".concat(P) : "", y].join("");
              } else
                return " ".concat(f(p.gutter, F)).concat(P.length > 0 ? " ".concat(P) : "");
            }).join(`
`);
            return v.message && !S2 && (k2 = "".concat(" ".repeat(B + 1)).concat(v.message, `
`).concat(k2)), m2 ? d4.reset(k2) : k2;
          }
          function i2(o, c, v) {
            let m2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            if (!t) {
              t = true;
              let p = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
              if (Tt2.emitWarning)
                Tt2.emitWarning(p, "DeprecationWarning");
              else {
                let f = new Error(p);
                f.name = "DeprecationWarning", console.warn(new Error(p));
              }
            }
            return v = Math.max(v, 0), u(o, { start: { column: v, line: c } }, m2);
          }
        } }), Gn2 = Z3({ "src/main/parser.js"(e, n) {
          re2();
          var { ConfigError: t } = zt2(), s2 = st2();
          gm2();
          var { locStart: r, locEnd: u } = s2, i2 = Object.getOwnPropertyNames, o = Object.getOwnPropertyDescriptor;
          function c(d4) {
            let p = {};
            for (let f of d4.plugins)
              if (!!f.parsers)
                for (let h2 of i2(f.parsers))
                  Object.defineProperty(p, h2, o(f.parsers, h2));
            return p;
          }
          function v(d4) {
            let p = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : c(d4);
            if (typeof d4.parser == "function")
              return { parse: d4.parser, astFormat: "estree", locStart: r, locEnd: u };
            if (typeof d4.parser == "string") {
              if (Object.prototype.hasOwnProperty.call(p, d4.parser))
                return p[d4.parser];
              throw new t(`Couldn't resolve parser "`.concat(d4.parser, '". Parsers must be explicitly added to the standalone bundle.'));
            }
          }
          function m2(d4, p) {
            let f = c(p), h2 = Object.defineProperties({}, Object.fromEntries(Object.keys(f).map((T2) => [T2, { enumerable: true, get() {
              return f[T2].parse;
            } }]))), w2 = v(p, f);
            try {
              return w2.preprocess && (d4 = w2.preprocess(d4, p)), { text: d4, ast: w2.parse(d4, h2, p) };
            } catch (T2) {
              let { loc: A2 } = T2;
              if (A2) {
                let { codeFrameColumns: S2 } = hm2();
                throw T2.codeFrame = S2(d4, A2, { highlightCode: true }), T2.message += `
` + T2.codeFrame, T2;
              }
              throw T2.stack;
            }
          }
          n.exports = { parse: m2, resolveParser: v };
        } }), Wa2 = Z3({ "src/main/options.js"(e, n) {
          re2();
          var t = PD2(), { UndefinedParserError: s2 } = zt2(), { getSupportInfo: a3 } = Mn2(), r = dm2(), { resolveParser: u } = Gn2(), i2 = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
          function o(m2) {
            let d4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, p = Object.assign({}, m2), f = a3({ plugins: m2.plugins, showUnreleased: true, showDeprecated: true }).options, h2 = Object.assign(Object.assign({}, i2), Object.fromEntries(f.filter((B) => B.default !== void 0).map((B) => [B.name, B.default])));
            if (!p.parser) {
              if (!p.filepath)
                (d4.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), p.parser = "babel";
              else if (p.parser = v(p.filepath, p.plugins), !p.parser)
                throw new s2("No parser could be inferred for file: ".concat(p.filepath));
            }
            let w2 = u(r.normalizeApiOptions(p, [f.find((B) => B.name === "parser")], { passThrough: true, logger: false }));
            p.astFormat = w2.astFormat, p.locEnd = w2.locEnd, p.locStart = w2.locStart;
            let T2 = c(p);
            p.printer = T2.printers[p.astFormat];
            let A2 = Object.fromEntries(f.filter((B) => B.pluginDefaults && B.pluginDefaults[T2.name] !== void 0).map((B) => [B.name, B.pluginDefaults[T2.name]])), S2 = Object.assign(Object.assign({}, h2), A2);
            for (let [B, I2] of Object.entries(S2))
              (p[B] === null || p[B] === void 0) && (p[B] = I2);
            return p.parser === "json" && (p.trailingComma = "none"), r.normalizeApiOptions(p, f, Object.assign({ passThrough: Object.keys(i2) }, d4));
          }
          function c(m2) {
            let { astFormat: d4 } = m2;
            if (!d4)
              throw new Error("getPlugin() requires astFormat to be set");
            let p = m2.plugins.find((f) => f.printers && f.printers[d4]);
            if (!p)
              throw new Error(`Couldn't find plugin for AST format "`.concat(d4, '"'));
            return p;
          }
          function v(m2, d4) {
            let p = t.basename(m2).toLowerCase(), h2 = a3({ plugins: d4 }).languages.filter((w2) => w2.since !== null).find((w2) => w2.extensions && w2.extensions.some((T2) => p.endsWith(T2)) || w2.filenames && w2.filenames.some((T2) => T2.toLowerCase() === p));
            return h2 && h2.parsers[0];
          }
          n.exports = { normalize: o, hiddenDefaults: i2, inferParser: v };
        } }), vm2 = Z3({ "src/main/massage-ast.js"(e, n) {
          re2();
          function t(s2, a3, r) {
            if (Array.isArray(s2))
              return s2.map((c) => t(c, a3, r)).filter(Boolean);
            if (!s2 || typeof s2 != "object")
              return s2;
            let u = a3.printer.massageAstNode, i2;
            u && u.ignoredProperties ? i2 = u.ignoredProperties : i2 = /* @__PURE__ */ new Set();
            let o = {};
            for (let [c, v] of Object.entries(s2))
              !i2.has(c) && typeof v != "function" && (o[c] = t(v, a3, s2));
            if (u) {
              let c = u(s2, o, r);
              if (c === null)
                return;
              if (c)
                return c;
            }
            return o;
          }
          n.exports = t;
        } }), Xt2 = Z3({ "scripts/build/shims/assert.cjs"(e, n) {
          re2();
          var t = () => {
          };
          t.ok = t, t.strictEqual = t, n.exports = t;
        } }), et2 = Z3({ "src/main/comments.js"(e, n) {
          re2();
          var t = Xt2(), { builders: { line: s2, hardline: a3, breakParent: r, indent: u, lineSuffix: i2, join: o, cursor: c } } = Oe2(), { hasNewline: v, skipNewline: m2, skipSpaces: d4, isPreviousLineEmpty: p, addLeadingComment: f, addDanglingComment: h2, addTrailingComment: w2 } = Ue2(), T2 = /* @__PURE__ */ new WeakMap();
          function A2(L, M2, j) {
            if (!L)
              return;
            let { printer: $, locStart: V, locEnd: q } = M2;
            if (j) {
              if ($.canAttachComment && $.canAttachComment(L)) {
                let H3;
                for (H3 = j.length - 1; H3 >= 0 && !(V(j[H3]) <= V(L) && q(j[H3]) <= q(L)); --H3)
                  ;
                j.splice(H3 + 1, 0, L);
                return;
              }
            } else if (T2.has(L))
              return T2.get(L);
            let Y3 = $.getCommentChildNodes && $.getCommentChildNodes(L, M2) || typeof L == "object" && Object.entries(L).filter((H3) => {
              let [R] = H3;
              return R !== "enclosingNode" && R !== "precedingNode" && R !== "followingNode" && R !== "tokens" && R !== "comments" && R !== "parent";
            }).map((H3) => {
              let [, R] = H3;
              return R;
            });
            if (!!Y3) {
              j || (j = [], T2.set(L, j));
              for (let H3 of Y3)
                A2(H3, M2, j);
              return j;
            }
          }
          function S2(L, M2, j, $) {
            let { locStart: V, locEnd: q } = j, Y3 = V(M2), H3 = q(M2), R = A2(L, j), Q, ee2, te2 = 0, oe2 = R.length;
            for (; te2 < oe2; ) {
              let W2 = te2 + oe2 >> 1, X3 = R[W2], ue2 = V(X3), De2 = q(X3);
              if (ue2 <= Y3 && H3 <= De2)
                return S2(X3, M2, j, X3);
              if (De2 <= Y3) {
                Q = X3, te2 = W2 + 1;
                continue;
              }
              if (H3 <= ue2) {
                ee2 = X3, oe2 = W2;
                continue;
              }
              throw new Error("Comment location overlaps with node location");
            }
            if ($ && $.type === "TemplateLiteral") {
              let { quasis: W2 } = $, X3 = F(W2, M2, j);
              Q && F(W2, Q, j) !== X3 && (Q = null), ee2 && F(W2, ee2, j) !== X3 && (ee2 = null);
            }
            return { enclosingNode: $, precedingNode: Q, followingNode: ee2 };
          }
          var B = () => false;
          function I2(L, M2, j, $) {
            if (!Array.isArray(L))
              return;
            let V = [], { locStart: q, locEnd: Y3, printer: { handleComments: H3 = {} } } = $, { avoidAstMutation: R, ownLine: Q = B, endOfLine: ee2 = B, remaining: te2 = B } = H3, oe2 = L.map((W2, X3) => Object.assign(Object.assign({}, S2(M2, W2, $)), {}, { comment: W2, text: j, options: $, ast: M2, isLastComment: L.length - 1 === X3 }));
            for (let [W2, X3] of oe2.entries()) {
              let { comment: ue2, precedingNode: De2, enclosingNode: ie, followingNode: G, text: z, options: U, ast: le2, isLastComment: ge2 } = X3;
              if (U.parser === "json" || U.parser === "json5" || U.parser === "__js_expression" || U.parser === "__vue_expression" || U.parser === "__vue_ts_expression") {
                if (q(ue2) - q(le2) <= 0) {
                  f(le2, ue2);
                  continue;
                }
                if (Y3(ue2) - Y3(le2) >= 0) {
                  w2(le2, ue2);
                  continue;
                }
              }
              let Ae2;
              if (R ? Ae2 = [X3] : (ue2.enclosingNode = ie, ue2.precedingNode = De2, ue2.followingNode = G, Ae2 = [ue2, z, U, le2, ge2]), P(z, U, oe2, W2))
                ue2.placement = "ownLine", Q(...Ae2) || (G ? f(G, ue2) : De2 ? w2(De2, ue2) : h2(ie || le2, ue2));
              else if (C2(z, U, oe2, W2))
                ue2.placement = "endOfLine", ee2(...Ae2) || (De2 ? w2(De2, ue2) : G ? f(G, ue2) : h2(ie || le2, ue2));
              else if (ue2.placement = "remaining", !te2(...Ae2))
                if (De2 && G) {
                  let Ne2 = V.length;
                  Ne2 > 0 && V[Ne2 - 1].followingNode !== G && D2(V, z, U), V.push(X3);
                } else
                  De2 ? w2(De2, ue2) : G ? f(G, ue2) : h2(ie || le2, ue2);
            }
            if (D2(V, j, $), !R)
              for (let W2 of L)
                delete W2.precedingNode, delete W2.enclosingNode, delete W2.followingNode;
          }
          var k2 = (L) => !/[\S\n\u2028\u2029]/.test(L);
          function P(L, M2, j, $) {
            let { comment: V, precedingNode: q } = j[$], { locStart: Y3, locEnd: H3 } = M2, R = Y3(V);
            if (q)
              for (let Q = $ - 1; Q >= 0; Q--) {
                let { comment: ee2, precedingNode: te2 } = j[Q];
                if (te2 !== q || !k2(L.slice(H3(ee2), R)))
                  break;
                R = Y3(ee2);
              }
            return v(L, R, { backwards: true });
          }
          function C2(L, M2, j, $) {
            let { comment: V, followingNode: q } = j[$], { locStart: Y3, locEnd: H3 } = M2, R = H3(V);
            if (q)
              for (let Q = $ + 1; Q < j.length; Q++) {
                let { comment: ee2, followingNode: te2 } = j[Q];
                if (te2 !== q || !k2(L.slice(R, Y3(ee2))))
                  break;
                R = H3(ee2);
              }
            return v(L, R);
          }
          function D2(L, M2, j) {
            let $ = L.length;
            if ($ === 0)
              return;
            let { precedingNode: V, followingNode: q, enclosingNode: Y3 } = L[0], H3 = j.printer.getGapRegex && j.printer.getGapRegex(Y3) || /^[\s(]*$/, R = j.locStart(q), Q;
            for (Q = $; Q > 0; --Q) {
              let { comment: ee2, precedingNode: te2, followingNode: oe2 } = L[Q - 1];
              t.strictEqual(te2, V), t.strictEqual(oe2, q);
              let W2 = M2.slice(j.locEnd(ee2), R);
              if (H3.test(W2))
                R = j.locStart(ee2);
              else
                break;
            }
            for (let [ee2, { comment: te2 }] of L.entries())
              ee2 < Q ? w2(V, te2) : f(q, te2);
            for (let ee2 of [V, q])
              ee2.comments && ee2.comments.length > 1 && ee2.comments.sort((te2, oe2) => j.locStart(te2) - j.locStart(oe2));
            L.length = 0;
          }
          function g2(L, M2) {
            let j = L.getValue();
            return j.printed = true, M2.printer.printComment(L, M2);
          }
          function F(L, M2, j) {
            let $ = j.locStart(M2) - 1;
            for (let V = 1; V < L.length; ++V)
              if ($ < j.locStart(L[V]))
                return V - 1;
            return 0;
          }
          function l(L, M2) {
            let j = L.getValue(), $ = [g2(L, M2)], { printer: V, originalText: q, locStart: Y3, locEnd: H3 } = M2;
            if (V.isBlockComment && V.isBlockComment(j)) {
              let ee2 = v(q, H3(j)) ? v(q, Y3(j), { backwards: true }) ? a3 : s2 : " ";
              $.push(ee2);
            } else
              $.push(a3);
            let Q = m2(q, d4(q, H3(j)));
            return Q !== false && v(q, Q) && $.push(a3), $;
          }
          function E(L, M2) {
            let j = L.getValue(), $ = g2(L, M2), { printer: V, originalText: q, locStart: Y3 } = M2, H3 = V.isBlockComment && V.isBlockComment(j);
            if (v(q, Y3(j), { backwards: true })) {
              let Q = p(q, j, Y3);
              return i2([a3, Q ? a3 : "", $]);
            }
            let R = [" ", $];
            return H3 || (R = [i2(R), r]), R;
          }
          function y(L, M2, j, $) {
            let V = [], q = L.getValue();
            return !q || !q.comments || (L.each(() => {
              let Y3 = L.getValue();
              !Y3.leading && !Y3.trailing && (!$ || $(Y3)) && V.push(g2(L, M2));
            }, "comments"), V.length === 0) ? "" : j ? o(a3, V) : u([a3, o(a3, V)]);
          }
          function N(L, M2, j) {
            let $ = L.getValue();
            if (!$)
              return {};
            let V = $.comments || [];
            j && (V = V.filter((R) => !j.has(R)));
            let q = $ === M2.cursorNode;
            if (V.length === 0) {
              let R = q ? c : "";
              return { leading: R, trailing: R };
            }
            let Y3 = [], H3 = [];
            return L.each(() => {
              let R = L.getValue();
              if (j && j.has(R))
                return;
              let { leading: Q, trailing: ee2 } = R;
              Q ? Y3.push(l(L, M2)) : ee2 && H3.push(E(L, M2));
            }, "comments"), q && (Y3.unshift(c), H3.push(c)), { leading: Y3, trailing: H3 };
          }
          function x2(L, M2, j, $) {
            let { leading: V, trailing: q } = N(L, j, $);
            return !V && !q ? M2 : [V, M2, q];
          }
          function b2(L) {
            if (!!L)
              for (let M2 of L) {
                if (!M2.printed)
                  throw new Error('Comment "' + M2.value.trim() + '" was not printed. Please report this error!');
                delete M2.printed;
              }
          }
          n.exports = { attach: I2, printComments: x2, printCommentsSeparately: N, printDanglingComments: y, getSortedChildNodes: A2, ensureAllCommentsPrinted: b2 };
        } }), Cm2 = Z3({ "src/common/ast-path.js"(e, n) {
          re2();
          var t = it2();
          function s2(u, i2) {
            let o = a3(u.stack, i2);
            return o === -1 ? null : u.stack[o];
          }
          function a3(u, i2) {
            for (let o = u.length - 1; o >= 0; o -= 2) {
              let c = u[o];
              if (c && !Array.isArray(c) && --i2 < 0)
                return o;
            }
            return -1;
          }
          var r = class {
            constructor(u) {
              this.stack = [u];
            }
            getName() {
              let { stack: u } = this, { length: i2 } = u;
              return i2 > 1 ? u[i2 - 2] : null;
            }
            getValue() {
              return t(this.stack);
            }
            getNode() {
              let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              return s2(this, u);
            }
            getParentNode() {
              let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              return s2(this, u + 1);
            }
            call(u) {
              let { stack: i2 } = this, { length: o } = i2, c = t(i2);
              for (var v = arguments.length, m2 = new Array(v > 1 ? v - 1 : 0), d4 = 1; d4 < v; d4++)
                m2[d4 - 1] = arguments[d4];
              for (let f of m2)
                c = c[f], i2.push(f, c);
              let p = u(this);
              return i2.length = o, p;
            }
            callParent(u) {
              let i2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, o = a3(this.stack, i2 + 1), c = this.stack.splice(o + 1), v = u(this);
              return this.stack.push(...c), v;
            }
            each(u) {
              let { stack: i2 } = this, { length: o } = i2, c = t(i2);
              for (var v = arguments.length, m2 = new Array(v > 1 ? v - 1 : 0), d4 = 1; d4 < v; d4++)
                m2[d4 - 1] = arguments[d4];
              for (let p of m2)
                c = c[p], i2.push(p, c);
              for (let p = 0; p < c.length; ++p)
                i2.push(p, c[p]), u(this, p, c), i2.length -= 2;
              i2.length = o;
            }
            map(u) {
              let i2 = [];
              for (var o = arguments.length, c = new Array(o > 1 ? o - 1 : 0), v = 1; v < o; v++)
                c[v - 1] = arguments[v];
              return this.each((m2, d4, p) => {
                i2[d4] = u(m2, d4, p);
              }, ...c), i2;
            }
            try(u) {
              let { stack: i2 } = this, o = [...i2];
              try {
                return u();
              } finally {
                i2.length = 0, i2.push(...o);
              }
            }
            match() {
              let u = this.stack.length - 1, i2 = null, o = this.stack[u--];
              for (var c = arguments.length, v = new Array(c), m2 = 0; m2 < c; m2++)
                v[m2] = arguments[m2];
              for (let d4 of v) {
                if (o === void 0)
                  return false;
                let p = null;
                if (typeof i2 == "number" && (p = i2, i2 = this.stack[u--], o = this.stack[u--]), d4 && !d4(o, i2, p))
                  return false;
                i2 = this.stack[u--], o = this.stack[u--];
              }
              return true;
            }
            findAncestor(u) {
              let i2 = this.stack.length - 1, o = null, c = this.stack[i2--];
              for (; c; ) {
                let v = null;
                if (typeof o == "number" && (v = o, o = this.stack[i2--], c = this.stack[i2--]), o !== null && u(c, o, v))
                  return c;
                o = this.stack[i2--], c = this.stack[i2--];
              }
            }
          };
          n.exports = r;
        } }), Em2 = Z3({ "src/main/multiparser.js"(e, n) {
          re2();
          var { utils: { stripTrailingHardline: t } } = Oe2(), { normalize: s2 } = Wa2(), a3 = et2();
          function r(i2, o, c, v) {
            if (c.printer.embed && c.embeddedLanguageFormatting === "auto")
              return c.printer.embed(i2, o, (m2, d4, p) => u(m2, d4, c, v, p), c);
          }
          function u(i2, o, c, v) {
            let { stripTrailingHardline: m2 = false } = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {}, d4 = s2(Object.assign(Object.assign(Object.assign({}, c), o), {}, { parentParser: c.parser, originalText: i2 }), { passThrough: true }), p = Gn2().parse(i2, d4), { ast: f } = p;
            i2 = p.text;
            let h2 = f.comments;
            delete f.comments, a3.attach(h2, f, i2, d4), d4[Symbol.for("comments")] = h2 || [], d4[Symbol.for("tokens")] = f.tokens || [];
            let w2 = v(f, d4);
            return a3.ensureAllCommentsPrinted(h2), m2 ? typeof w2 == "string" ? w2.replace(/(?:\r?\n)*$/, "") : t(w2) : w2;
          }
          n.exports = { printSubtree: r };
        } }), Fm2 = Z3({ "src/main/ast-to-doc.js"(e, n) {
          re2();
          var t = Cm2(), { builders: { hardline: s2, addAlignmentToDoc: a3 }, utils: { propagateBreaks: r } } = Oe2(), { printComments: u } = et2(), i2 = Em2();
          function o(m2, d4) {
            let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, { printer: f } = d4;
            f.preprocess && (m2 = f.preprocess(m2, d4));
            let h2 = /* @__PURE__ */ new Map(), w2 = new t(m2), T2 = A2();
            return p > 0 && (T2 = a3([s2, T2], p, d4.tabWidth)), r(T2), T2;
            function A2(B, I2) {
              return B === void 0 || B === w2 ? S2(I2) : Array.isArray(B) ? w2.call(() => S2(I2), ...B) : w2.call(() => S2(I2), B);
            }
            function S2(B) {
              let I2 = w2.getValue(), k2 = I2 && typeof I2 == "object" && B === void 0;
              if (k2 && h2.has(I2))
                return h2.get(I2);
              let P = v(w2, d4, A2, B);
              return k2 && h2.set(I2, P), P;
            }
          }
          function c(m2, d4) {
            let { originalText: p, [Symbol.for("comments")]: f, locStart: h2, locEnd: w2 } = d4, T2 = h2(m2), A2 = w2(m2), S2 = /* @__PURE__ */ new Set();
            for (let B of f)
              h2(B) >= T2 && w2(B) <= A2 && (B.printed = true, S2.add(B));
            return { doc: p.slice(T2, A2), printedComments: S2 };
          }
          function v(m2, d4, p, f) {
            let h2 = m2.getValue(), { printer: w2 } = d4, T2, A2;
            if (w2.hasPrettierIgnore && w2.hasPrettierIgnore(m2))
              ({ doc: T2, printedComments: A2 } = c(h2, d4));
            else {
              if (h2)
                try {
                  T2 = i2.printSubtree(m2, p, d4, o);
                } catch (S2) {
                  if (globalThis.PRETTIER_DEBUG)
                    throw S2;
                }
              T2 || (T2 = w2.print(m2, d4, p, f));
            }
            return (!w2.willPrintOwnComments || !w2.willPrintOwnComments(m2, d4)) && (T2 = u(m2, T2, d4, A2)), T2;
          }
          n.exports = o;
        } }), Am2 = Z3({ "src/main/range-util.js"(e, n) {
          re2();
          var t = Xt2(), s2 = et2(), a3 = (f) => {
            let { parser: h2 } = f;
            return h2 === "json" || h2 === "json5" || h2 === "json-stringify";
          };
          function r(f, h2) {
            let w2 = [f.node, ...f.parentNodes], T2 = /* @__PURE__ */ new Set([h2.node, ...h2.parentNodes]);
            return w2.find((A2) => v.has(A2.type) && T2.has(A2));
          }
          function u(f) {
            let h2 = f.length - 1;
            for (; ; ) {
              let w2 = f[h2];
              if (w2 && (w2.type === "Program" || w2.type === "File"))
                h2--;
              else
                break;
            }
            return f.slice(0, h2 + 1);
          }
          function i2(f, h2, w2) {
            let { locStart: T2, locEnd: A2 } = w2, S2 = f.node, B = h2.node;
            if (S2 === B)
              return { startNode: S2, endNode: B };
            let I2 = T2(f.node);
            for (let P of u(h2.parentNodes))
              if (T2(P) >= I2)
                B = P;
              else
                break;
            let k2 = A2(h2.node);
            for (let P of u(f.parentNodes))
              if (A2(P) <= k2)
                S2 = P;
              else
                break;
            return { startNode: S2, endNode: B };
          }
          function o(f, h2, w2, T2) {
            let A2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], S2 = arguments.length > 5 ? arguments[5] : void 0, { locStart: B, locEnd: I2 } = w2, k2 = B(f), P = I2(f);
            if (!(h2 > P || h2 < k2 || S2 === "rangeEnd" && h2 === k2 || S2 === "rangeStart" && h2 === P)) {
              for (let C2 of s2.getSortedChildNodes(f, w2)) {
                let D2 = o(C2, h2, w2, T2, [f, ...A2], S2);
                if (D2)
                  return D2;
              }
              if (!T2 || T2(f, A2[0]))
                return { node: f, parentNodes: A2 };
            }
          }
          function c(f, h2) {
            return h2 !== "DeclareExportDeclaration" && f !== "TypeParameterDeclaration" && (f === "Directive" || f === "TypeAlias" || f === "TSExportAssignment" || f.startsWith("Declare") || f.startsWith("TSDeclare") || f.endsWith("Statement") || f.endsWith("Declaration"));
          }
          var v = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), m2 = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
          function d4(f, h2, w2) {
            if (!h2)
              return false;
            switch (f.parser) {
              case "flow":
              case "babel":
              case "babel-flow":
              case "babel-ts":
              case "typescript":
              case "acorn":
              case "espree":
              case "meriyah":
              case "__babel_estree":
                return c(h2.type, w2 && w2.type);
              case "json":
              case "json5":
              case "json-stringify":
                return v.has(h2.type);
              case "graphql":
                return m2.has(h2.kind);
              case "vue":
                return h2.tag !== "root";
            }
            return false;
          }
          function p(f, h2, w2) {
            let { rangeStart: T2, rangeEnd: A2, locStart: S2, locEnd: B } = h2;
            t.ok(A2 > T2);
            let I2 = f.slice(T2, A2).search(/\S/), k2 = I2 === -1;
            if (!k2)
              for (T2 += I2; A2 > T2 && !/\S/.test(f[A2 - 1]); --A2)
                ;
            let P = o(w2, T2, h2, (F, l) => d4(h2, F, l), [], "rangeStart"), C2 = k2 ? P : o(w2, A2, h2, (F) => d4(h2, F), [], "rangeEnd");
            if (!P || !C2)
              return { rangeStart: 0, rangeEnd: 0 };
            let D2, g2;
            if (a3(h2)) {
              let F = r(P, C2);
              D2 = F, g2 = F;
            } else
              ({ startNode: D2, endNode: g2 } = i2(P, C2, h2));
            return { rangeStart: Math.min(S2(D2), S2(g2)), rangeEnd: Math.max(B(D2), B(g2)) };
          }
          n.exports = { calculateRange: p, findNodeAtOffset: o };
        } }), Sm2 = Z3({ "src/main/core.js"(e, n) {
          re2();
          var { diffArrays: t } = aD2(), { printer: { printDocToString: s2 }, debug: { printDocToDebug: a3 } } = Oe2(), { getAlignmentSize: r } = Ue2(), { guessEndOfLine: u, convertEndOfLineToChars: i2, countEndOfLineChars: o, normalizeEndOfLine: c } = jn2(), v = Wa2().normalize, m2 = vm2(), d4 = et2(), p = Gn2(), f = Fm2(), h2 = Am2(), w2 = "\uFEFF", T2 = Symbol("cursor");
          function A2(g2, F, l) {
            let E = F.comments;
            return E && (delete F.comments, d4.attach(E, F, g2, l)), l[Symbol.for("comments")] = E || [], l[Symbol.for("tokens")] = F.tokens || [], l.originalText = g2, E;
          }
          function S2(g2, F) {
            let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            if (!g2 || g2.trim().length === 0)
              return { formatted: "", cursorOffset: -1, comments: [] };
            let { ast: E, text: y } = p.parse(g2, F);
            if (F.cursorOffset >= 0) {
              let L = h2.findNodeAtOffset(E, F.cursorOffset, F);
              L && L.node && (F.cursorNode = L.node);
            }
            let N = A2(y, E, F), x2 = f(E, F, l), b2 = s2(x2, F);
            if (d4.ensureAllCommentsPrinted(N), l > 0) {
              let L = b2.formatted.trim();
              b2.cursorNodeStart !== void 0 && (b2.cursorNodeStart -= b2.formatted.indexOf(L)), b2.formatted = L + i2(F.endOfLine);
            }
            if (F.cursorOffset >= 0) {
              let L, M2, j, $, V;
              if (F.cursorNode && b2.cursorNodeText ? (L = F.locStart(F.cursorNode), M2 = y.slice(L, F.locEnd(F.cursorNode)), j = F.cursorOffset - L, $ = b2.cursorNodeStart, V = b2.cursorNodeText) : (L = 0, M2 = y, j = F.cursorOffset, $ = 0, V = b2.formatted), M2 === V)
                return { formatted: b2.formatted, cursorOffset: $ + j, comments: N };
              let q = [...M2];
              q.splice(j, 0, T2);
              let Y3 = [...V], H3 = t(q, Y3), R = $;
              for (let Q of H3)
                if (Q.removed) {
                  if (Q.value.includes(T2))
                    break;
                } else
                  R += Q.count;
              return { formatted: b2.formatted, cursorOffset: R, comments: N };
            }
            return { formatted: b2.formatted, cursorOffset: -1, comments: N };
          }
          function B(g2, F) {
            let { ast: l, text: E } = p.parse(g2, F), { rangeStart: y, rangeEnd: N } = h2.calculateRange(E, F, l), x2 = E.slice(y, N), b2 = Math.min(y, E.lastIndexOf(`
`, y) + 1), L = E.slice(b2, y).match(/^\s*/)[0], M2 = r(L, F.tabWidth), j = S2(x2, Object.assign(Object.assign({}, F), {}, { rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: F.cursorOffset > y && F.cursorOffset <= N ? F.cursorOffset - y : -1, endOfLine: "lf" }), M2), $ = j.formatted.trimEnd(), { cursorOffset: V } = F;
            V > N ? V += $.length - x2.length : j.cursorOffset >= 0 && (V = j.cursorOffset + y);
            let q = E.slice(0, y) + $ + E.slice(N);
            if (F.endOfLine !== "lf") {
              let Y3 = i2(F.endOfLine);
              V >= 0 && Y3 === `\r
` && (V += o(q.slice(0, V), `
`)), q = q.replace(/\n/g, Y3);
            }
            return { formatted: q, cursorOffset: V, comments: j.comments };
          }
          function I2(g2, F, l) {
            return typeof F != "number" || Number.isNaN(F) || F < 0 || F > g2.length ? l : F;
          }
          function k2(g2, F) {
            let { cursorOffset: l, rangeStart: E, rangeEnd: y } = F;
            return l = I2(g2, l, -1), E = I2(g2, E, 0), y = I2(g2, y, g2.length), Object.assign(Object.assign({}, F), {}, { cursorOffset: l, rangeStart: E, rangeEnd: y });
          }
          function P(g2, F) {
            let { cursorOffset: l, rangeStart: E, rangeEnd: y, endOfLine: N } = k2(g2, F), x2 = g2.charAt(0) === w2;
            if (x2 && (g2 = g2.slice(1), l--, E--, y--), N === "auto" && (N = u(g2)), g2.includes("\r")) {
              let b2 = (L) => o(g2.slice(0, Math.max(L, 0)), `\r
`);
              l -= b2(l), E -= b2(E), y -= b2(y), g2 = c(g2);
            }
            return { hasBOM: x2, text: g2, options: k2(g2, Object.assign(Object.assign({}, F), {}, { cursorOffset: l, rangeStart: E, rangeEnd: y, endOfLine: N })) };
          }
          function C2(g2, F) {
            let l = p.resolveParser(F);
            return !l.hasPragma || l.hasPragma(g2);
          }
          function D2(g2, F) {
            let { hasBOM: l, text: E, options: y } = P(g2, v(F));
            if (y.rangeStart >= y.rangeEnd && E !== "" || y.requirePragma && !C2(E, y))
              return { formatted: g2, cursorOffset: F.cursorOffset, comments: [] };
            let N;
            return y.rangeStart > 0 || y.rangeEnd < E.length ? N = B(E, y) : (!y.requirePragma && y.insertPragma && y.printer.insertPragma && !C2(E, y) && (E = y.printer.insertPragma(E)), N = S2(E, y)), l && (N.formatted = w2 + N.formatted, N.cursorOffset >= 0 && N.cursorOffset++), N;
          }
          n.exports = { formatWithCursor: D2, parse(g2, F, l) {
            let { text: E, options: y } = P(g2, v(F)), N = p.parse(E, y);
            return l && (N.ast = m2(N.ast, y)), N;
          }, formatAST(g2, F) {
            F = v(F);
            let l = f(g2, F);
            return s2(l, F);
          }, formatDoc(g2, F) {
            return D2(a3(g2), Object.assign(Object.assign({}, F), {}, { parser: "__js_expression" })).formatted;
          }, printToDoc(g2, F) {
            F = v(F);
            let { ast: l, text: E } = p.parse(g2, F);
            return A2(E, l, F), f(l, F);
          }, printDocToString(g2, F) {
            return s2(g2, v(F));
          } };
        } }), xm2 = Z3({ "src/common/util-shared.js"(e, n) {
          re2();
          var { getMaxContinuousCount: t, getStringWidth: s2, getAlignmentSize: a3, getIndentSize: r, skip: u, skipWhitespace: i2, skipSpaces: o, skipNewline: c, skipToLineEnd: v, skipEverythingButNewLine: m2, skipInlineComment: d4, skipTrailingComment: p, hasNewline: f, hasNewlineInRange: h2, hasSpaces: w2, isNextLineEmpty: T2, isNextLineEmptyAfterIndex: A2, isPreviousLineEmpty: S2, getNextNonSpaceNonCommentCharacterIndex: B, makeString: I2, addLeadingComment: k2, addDanglingComment: P, addTrailingComment: C2 } = Ue2();
          n.exports = { getMaxContinuousCount: t, getStringWidth: s2, getAlignmentSize: a3, getIndentSize: r, skip: u, skipWhitespace: i2, skipSpaces: o, skipNewline: c, skipToLineEnd: v, skipEverythingButNewLine: m2, skipInlineComment: d4, skipTrailingComment: p, hasNewline: f, hasNewlineInRange: h2, hasSpaces: w2, isNextLineEmpty: T2, isNextLineEmptyAfterIndex: A2, isPreviousLineEmpty: S2, getNextNonSpaceNonCommentCharacterIndex: B, makeString: I2, addLeadingComment: k2, addDanglingComment: P, addTrailingComment: C2 };
        } }), Bt = Z3({ "src/utils/create-language.js"(e, n) {
          re2(), n.exports = function(t, s2) {
            let { languageId: a3 } = t, r = kn2(t, Zf2);
            return Object.assign(Object.assign({ linguistLanguageId: a3 }, r), s2(t));
          };
        } }), bm2 = Z3({ "node_modules/esutils/lib/ast.js"(e, n) {
          re2(), function() {
            function t(o) {
              if (o == null)
                return false;
              switch (o.type) {
                case "ArrayExpression":
                case "AssignmentExpression":
                case "BinaryExpression":
                case "CallExpression":
                case "ConditionalExpression":
                case "FunctionExpression":
                case "Identifier":
                case "Literal":
                case "LogicalExpression":
                case "MemberExpression":
                case "NewExpression":
                case "ObjectExpression":
                case "SequenceExpression":
                case "ThisExpression":
                case "UnaryExpression":
                case "UpdateExpression":
                  return true;
              }
              return false;
            }
            function s2(o) {
              if (o == null)
                return false;
              switch (o.type) {
                case "DoWhileStatement":
                case "ForInStatement":
                case "ForStatement":
                case "WhileStatement":
                  return true;
              }
              return false;
            }
            function a3(o) {
              if (o == null)
                return false;
              switch (o.type) {
                case "BlockStatement":
                case "BreakStatement":
                case "ContinueStatement":
                case "DebuggerStatement":
                case "DoWhileStatement":
                case "EmptyStatement":
                case "ExpressionStatement":
                case "ForInStatement":
                case "ForStatement":
                case "IfStatement":
                case "LabeledStatement":
                case "ReturnStatement":
                case "SwitchStatement":
                case "ThrowStatement":
                case "TryStatement":
                case "VariableDeclaration":
                case "WhileStatement":
                case "WithStatement":
                  return true;
              }
              return false;
            }
            function r(o) {
              return a3(o) || o != null && o.type === "FunctionDeclaration";
            }
            function u(o) {
              switch (o.type) {
                case "IfStatement":
                  return o.alternate != null ? o.alternate : o.consequent;
                case "LabeledStatement":
                case "ForStatement":
                case "ForInStatement":
                case "WhileStatement":
                case "WithStatement":
                  return o.body;
              }
              return null;
            }
            function i2(o) {
              var c;
              if (o.type !== "IfStatement" || o.alternate == null)
                return false;
              c = o.consequent;
              do {
                if (c.type === "IfStatement" && c.alternate == null)
                  return true;
                c = u(c);
              } while (c);
              return false;
            }
            n.exports = { isExpression: t, isStatement: a3, isIterationStatement: s2, isSourceElement: r, isProblematicIfStatement: i2, trailingStatement: u };
          }();
        } }), $a2 = Z3({ "node_modules/esutils/lib/code.js"(e, n) {
          re2(), function() {
            var t, s2, a3, r, u, i2;
            s2 = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, t = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ };
            function o(A2) {
              return 48 <= A2 && A2 <= 57;
            }
            function c(A2) {
              return 48 <= A2 && A2 <= 57 || 97 <= A2 && A2 <= 102 || 65 <= A2 && A2 <= 70;
            }
            function v(A2) {
              return A2 >= 48 && A2 <= 55;
            }
            a3 = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279];
            function m2(A2) {
              return A2 === 32 || A2 === 9 || A2 === 11 || A2 === 12 || A2 === 160 || A2 >= 5760 && a3.indexOf(A2) >= 0;
            }
            function d4(A2) {
              return A2 === 10 || A2 === 13 || A2 === 8232 || A2 === 8233;
            }
            function p(A2) {
              if (A2 <= 65535)
                return String.fromCharCode(A2);
              var S2 = String.fromCharCode(Math.floor((A2 - 65536) / 1024) + 55296), B = String.fromCharCode((A2 - 65536) % 1024 + 56320);
              return S2 + B;
            }
            for (r = new Array(128), i2 = 0; i2 < 128; ++i2)
              r[i2] = i2 >= 97 && i2 <= 122 || i2 >= 65 && i2 <= 90 || i2 === 36 || i2 === 95;
            for (u = new Array(128), i2 = 0; i2 < 128; ++i2)
              u[i2] = i2 >= 97 && i2 <= 122 || i2 >= 65 && i2 <= 90 || i2 >= 48 && i2 <= 57 || i2 === 36 || i2 === 95;
            function f(A2) {
              return A2 < 128 ? r[A2] : s2.NonAsciiIdentifierStart.test(p(A2));
            }
            function h2(A2) {
              return A2 < 128 ? u[A2] : s2.NonAsciiIdentifierPart.test(p(A2));
            }
            function w2(A2) {
              return A2 < 128 ? r[A2] : t.NonAsciiIdentifierStart.test(p(A2));
            }
            function T2(A2) {
              return A2 < 128 ? u[A2] : t.NonAsciiIdentifierPart.test(p(A2));
            }
            n.exports = { isDecimalDigit: o, isHexDigit: c, isOctalDigit: v, isWhiteSpace: m2, isLineTerminator: d4, isIdentifierStartES5: f, isIdentifierPartES5: h2, isIdentifierStartES6: w2, isIdentifierPartES6: T2 };
          }();
        } }), Tm2 = Z3({ "node_modules/esutils/lib/keyword.js"(e, n) {
          re2(), function() {
            var t = $a2();
            function s2(f) {
              switch (f) {
                case "implements":
                case "interface":
                case "package":
                case "private":
                case "protected":
                case "public":
                case "static":
                case "let":
                  return true;
                default:
                  return false;
              }
            }
            function a3(f, h2) {
              return !h2 && f === "yield" ? false : r(f, h2);
            }
            function r(f, h2) {
              if (h2 && s2(f))
                return true;
              switch (f.length) {
                case 2:
                  return f === "if" || f === "in" || f === "do";
                case 3:
                  return f === "var" || f === "for" || f === "new" || f === "try";
                case 4:
                  return f === "this" || f === "else" || f === "case" || f === "void" || f === "with" || f === "enum";
                case 5:
                  return f === "while" || f === "break" || f === "catch" || f === "throw" || f === "const" || f === "yield" || f === "class" || f === "super";
                case 6:
                  return f === "return" || f === "typeof" || f === "delete" || f === "switch" || f === "export" || f === "import";
                case 7:
                  return f === "default" || f === "finally" || f === "extends";
                case 8:
                  return f === "function" || f === "continue" || f === "debugger";
                case 10:
                  return f === "instanceof";
                default:
                  return false;
              }
            }
            function u(f, h2) {
              return f === "null" || f === "true" || f === "false" || a3(f, h2);
            }
            function i2(f, h2) {
              return f === "null" || f === "true" || f === "false" || r(f, h2);
            }
            function o(f) {
              return f === "eval" || f === "arguments";
            }
            function c(f) {
              var h2, w2, T2;
              if (f.length === 0 || (T2 = f.charCodeAt(0), !t.isIdentifierStartES5(T2)))
                return false;
              for (h2 = 1, w2 = f.length; h2 < w2; ++h2)
                if (T2 = f.charCodeAt(h2), !t.isIdentifierPartES5(T2))
                  return false;
              return true;
            }
            function v(f, h2) {
              return (f - 55296) * 1024 + (h2 - 56320) + 65536;
            }
            function m2(f) {
              var h2, w2, T2, A2, S2;
              if (f.length === 0)
                return false;
              for (S2 = t.isIdentifierStartES6, h2 = 0, w2 = f.length; h2 < w2; ++h2) {
                if (T2 = f.charCodeAt(h2), 55296 <= T2 && T2 <= 56319) {
                  if (++h2, h2 >= w2 || (A2 = f.charCodeAt(h2), !(56320 <= A2 && A2 <= 57343)))
                    return false;
                  T2 = v(T2, A2);
                }
                if (!S2(T2))
                  return false;
                S2 = t.isIdentifierPartES6;
              }
              return true;
            }
            function d4(f, h2) {
              return c(f) && !u(f, h2);
            }
            function p(f, h2) {
              return m2(f) && !i2(f, h2);
            }
            n.exports = { isKeywordES5: a3, isKeywordES6: r, isReservedWordES5: u, isReservedWordES6: i2, isRestrictedWord: o, isIdentifierNameES5: c, isIdentifierNameES6: m2, isIdentifierES5: d4, isIdentifierES6: p };
          }();
        } }), Bm2 = Z3({ "node_modules/esutils/lib/utils.js"(e) {
          re2(), function() {
            e.ast = bm2(), e.code = $a2(), e.keyword = Tm2();
          }();
        } }), It2 = Z3({ "src/language-js/utils/is-block-comment.js"(e, n) {
          re2();
          var t = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]), s2 = (a3) => t.has(a3 == null ? void 0 : a3.type);
          n.exports = s2;
        } }), Nm2 = Z3({ "src/language-js/utils/is-node-matches.js"(e, n) {
          re2();
          function t(a3, r) {
            let u = r.split(".");
            for (let i2 = u.length - 1; i2 >= 0; i2--) {
              let o = u[i2];
              if (i2 === 0)
                return a3.type === "Identifier" && a3.name === o;
              if (a3.type !== "MemberExpression" || a3.optional || a3.computed || a3.property.type !== "Identifier" || a3.property.name !== o)
                return false;
              a3 = a3.object;
            }
          }
          function s2(a3, r) {
            return r.some((u) => t(a3, u));
          }
          n.exports = s2;
        } }), Ke2 = Z3({ "src/language-js/utils/index.js"(e, n) {
          re2();
          var t = Bm2().keyword.isIdentifierNameES5, { getLast: s2, hasNewline: a3, skipWhitespace: r, isNonEmptyArray: u, isNextLineEmptyAfterIndex: i2, getStringWidth: o } = Ue2(), { locStart: c, locEnd: v, hasSameLocStart: m2 } = st2(), d4 = It2(), p = Nm2(), f = "(?:(?=.)\\s)", h2 = new RegExp("^".concat(f, "*:")), w2 = new RegExp("^".concat(f, "*::"));
          function T2(O2) {
            var fe2, Te2;
            return ((fe2 = O2.extra) === null || fe2 === void 0 ? void 0 : fe2.parenthesized) && d4((Te2 = O2.trailingComments) === null || Te2 === void 0 ? void 0 : Te2[0]) && h2.test(O2.trailingComments[0].value);
          }
          function A2(O2) {
            let fe2 = O2 == null ? void 0 : O2[0];
            return d4(fe2) && w2.test(fe2.value);
          }
          function S2(O2, fe2) {
            if (!O2 || typeof O2 != "object")
              return false;
            if (Array.isArray(O2))
              return O2.some(($e2) => S2($e2, fe2));
            let Te2 = fe2(O2);
            return typeof Te2 == "boolean" ? Te2 : Object.values(O2).some(($e2) => S2($e2, fe2));
          }
          function B(O2) {
            return O2.type === "AssignmentExpression" || O2.type === "BinaryExpression" || O2.type === "LogicalExpression" || O2.type === "NGPipeExpression" || O2.type === "ConditionalExpression" || ue2(O2) || De2(O2) || O2.type === "SequenceExpression" || O2.type === "TaggedTemplateExpression" || O2.type === "BindExpression" || O2.type === "UpdateExpression" && !O2.prefix || O2.type === "TSAsExpression" || O2.type === "TSNonNullExpression";
          }
          function I2(O2) {
            var fe2, Te2, $e2, Je2, Ze2, ut2;
            return O2.expressions ? O2.expressions[0] : (fe2 = (Te2 = ($e2 = (Je2 = (Ze2 = (ut2 = O2.left) !== null && ut2 !== void 0 ? ut2 : O2.test) !== null && Ze2 !== void 0 ? Ze2 : O2.callee) !== null && Je2 !== void 0 ? Je2 : O2.object) !== null && $e2 !== void 0 ? $e2 : O2.tag) !== null && Te2 !== void 0 ? Te2 : O2.argument) !== null && fe2 !== void 0 ? fe2 : O2.expression;
          }
          function k2(O2, fe2) {
            if (fe2.expressions)
              return ["expressions", 0];
            if (fe2.left)
              return ["left"];
            if (fe2.test)
              return ["test"];
            if (fe2.object)
              return ["object"];
            if (fe2.callee)
              return ["callee"];
            if (fe2.tag)
              return ["tag"];
            if (fe2.argument)
              return ["argument"];
            if (fe2.expression)
              return ["expression"];
            throw new Error("Unexpected node has no left side.");
          }
          function P(O2) {
            return O2 = new Set(O2), (fe2) => O2.has(fe2 == null ? void 0 : fe2.type);
          }
          var C2 = P(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose"]), D2 = P(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
          function g2(O2) {
            let fe2 = O2.getParentNode();
            return O2.getName() === "declaration" && D2(fe2) ? fe2 : null;
          }
          var F = P(["BooleanLiteral", "DirectiveLiteral", "Literal", "NullLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "RegExpLiteral", "StringLiteral", "TemplateLiteral", "TSTypeLiteral", "JSXText"]);
          function l(O2) {
            return O2.type === "NumericLiteral" || O2.type === "Literal" && typeof O2.value == "number";
          }
          function E(O2) {
            return O2.type === "UnaryExpression" && (O2.operator === "+" || O2.operator === "-") && l(O2.argument);
          }
          function y(O2) {
            return O2.type === "StringLiteral" || O2.type === "Literal" && typeof O2.value == "string";
          }
          var N = P(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]), x2 = P(["FunctionExpression", "ArrowFunctionExpression"]);
          function b2(O2) {
            return O2.type === "FunctionExpression" || O2.type === "ArrowFunctionExpression" && O2.body.type === "BlockStatement";
          }
          function L(O2) {
            return ue2(O2) && O2.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(O2.callee.name);
          }
          var M2 = P(["JSXElement", "JSXFragment"]);
          function j(O2, fe2) {
            if (O2.parentParser !== "markdown" && O2.parentParser !== "mdx")
              return false;
            let Te2 = fe2.getNode();
            if (!Te2.expression || !M2(Te2.expression))
              return false;
            let $e2 = fe2.getParentNode();
            return $e2.type === "Program" && $e2.body.length === 1;
          }
          function $(O2) {
            return O2.kind === "get" || O2.kind === "set";
          }
          function V(O2) {
            return $(O2) || m2(O2, O2.value);
          }
          function q(O2) {
            return (O2.type === "ObjectTypeProperty" || O2.type === "ObjectTypeInternalSlot") && O2.value.type === "FunctionTypeAnnotation" && !O2.static && !V(O2);
          }
          function Y3(O2) {
            return (O2.type === "TypeAnnotation" || O2.type === "TSTypeAnnotation") && O2.typeAnnotation.type === "FunctionTypeAnnotation" && !O2.static && !m2(O2, O2.typeAnnotation);
          }
          var H3 = P(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
          function R(O2) {
            return De2(O2) || O2.type === "BindExpression" && Boolean(O2.object);
          }
          var Q = /* @__PURE__ */ new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
          function ee2(O2) {
            return O2 ? !!((O2.type === "GenericTypeAnnotation" || O2.type === "TSTypeReference") && !O2.typeParameters || Q.has(O2.type)) : false;
          }
          function te2(O2) {
            let fe2 = /^(?:before|after)(?:Each|All)$/;
            return O2.callee.type === "Identifier" && fe2.test(O2.callee.name) && O2.arguments.length === 1;
          }
          var oe2 = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
          function W2(O2) {
            return p(O2, oe2);
          }
          function X3(O2, fe2) {
            if (O2.type !== "CallExpression")
              return false;
            if (O2.arguments.length === 1) {
              if (L(O2) && fe2 && X3(fe2))
                return x2(O2.arguments[0]);
              if (te2(O2))
                return L(O2.arguments[0]);
            } else if ((O2.arguments.length === 2 || O2.arguments.length === 3) && (O2.arguments[0].type === "TemplateLiteral" || y(O2.arguments[0])) && W2(O2.callee))
              return O2.arguments[2] && !l(O2.arguments[2]) ? false : (O2.arguments.length === 2 ? x2(O2.arguments[1]) : b2(O2.arguments[1]) && Se2(O2.arguments[1]).length <= 1) || L(O2.arguments[1]);
            return false;
          }
          var ue2 = P(["CallExpression", "OptionalCallExpression"]), De2 = P(["MemberExpression", "OptionalMemberExpression"]);
          function ie(O2) {
            let fe2 = "expressions";
            O2.type === "TSTemplateLiteralType" && (fe2 = "types");
            let Te2 = O2[fe2];
            return Te2.length === 0 ? false : Te2.every(($e2) => {
              if (se($e2))
                return false;
              if ($e2.type === "Identifier" || $e2.type === "ThisExpression")
                return true;
              if (De2($e2)) {
                let Je2 = $e2;
                for (; De2(Je2); )
                  if (Je2.property.type !== "Identifier" && Je2.property.type !== "Literal" && Je2.property.type !== "StringLiteral" && Je2.property.type !== "NumericLiteral" || (Je2 = Je2.object, se(Je2)))
                    return false;
                return Je2.type === "Identifier" || Je2.type === "ThisExpression";
              }
              return false;
            });
          }
          function G(O2, fe2) {
            return O2 === "+" || O2 === "-" ? O2 + fe2 : fe2;
          }
          function z(O2, fe2) {
            let Te2 = c(fe2), $e2 = r(O2, v(fe2));
            return $e2 !== false && O2.slice(Te2, Te2 + 2) === "/*" && O2.slice($e2, $e2 + 2) === "*/";
          }
          function U(O2, fe2) {
            return M2(fe2) ? Re2(fe2) : se(fe2, Le2.Leading, (Te2) => a3(O2, v(Te2)));
          }
          function le2(O2, fe2) {
            return fe2.parser !== "json" && y(O2.key) && ve2(O2.key).slice(1, -1) === O2.key.value && (t(O2.key.value) && !(fe2.parser === "babel-ts" && O2.type === "ClassProperty" || fe2.parser === "typescript" && O2.type === "PropertyDefinition") || ge2(O2.key.value) && String(Number(O2.key.value)) === O2.key.value && (fe2.parser === "babel" || fe2.parser === "acorn" || fe2.parser === "espree" || fe2.parser === "meriyah" || fe2.parser === "__babel_estree"));
          }
          function ge2(O2) {
            return /^(?:\d+|\d+\.\d+)$/.test(O2);
          }
          function Ae2(O2, fe2) {
            let Te2 = /^[fx]?(?:describe|it|test)$/;
            return fe2.type === "TaggedTemplateExpression" && fe2.quasi === O2 && fe2.tag.type === "MemberExpression" && fe2.tag.property.type === "Identifier" && fe2.tag.property.name === "each" && (fe2.tag.object.type === "Identifier" && Te2.test(fe2.tag.object.name) || fe2.tag.object.type === "MemberExpression" && fe2.tag.object.property.type === "Identifier" && (fe2.tag.object.property.name === "only" || fe2.tag.object.property.name === "skip") && fe2.tag.object.object.type === "Identifier" && Te2.test(fe2.tag.object.object.name));
          }
          function Ne2(O2) {
            return O2.quasis.some((fe2) => fe2.value.raw.includes(`
`));
          }
          function ke2(O2, fe2) {
            return (O2.type === "TemplateLiteral" && Ne2(O2) || O2.type === "TaggedTemplateExpression" && Ne2(O2.quasi)) && !a3(fe2, c(O2), { backwards: true });
          }
          function ce(O2) {
            if (!se(O2))
              return false;
            let fe2 = s2(He2(O2, Le2.Dangling));
            return fe2 && !d4(fe2);
          }
          function pe(O2) {
            if (O2.length <= 1)
              return false;
            let fe2 = 0;
            for (let Te2 of O2)
              if (x2(Te2)) {
                if (fe2 += 1, fe2 > 1)
                  return true;
              } else if (ue2(Te2)) {
                for (let $e2 of Te2.arguments)
                  if (x2($e2))
                    return true;
              }
            return false;
          }
          function de2(O2) {
            let fe2 = O2.getValue(), Te2 = O2.getParentNode();
            return ue2(fe2) && ue2(Te2) && Te2.callee === fe2 && fe2.arguments.length > Te2.arguments.length && Te2.arguments.length > 0;
          }
          function ae2(O2, fe2) {
            if (fe2 >= 2)
              return false;
            let Te2 = (Je2) => ae2(Je2, fe2 + 1), $e2 = O2.type === "Literal" && "regex" in O2 && O2.regex.pattern || O2.type === "RegExpLiteral" && O2.pattern;
            return $e2 && o($e2) > 5 ? false : O2.type === "Literal" || O2.type === "BigIntLiteral" || O2.type === "DecimalLiteral" || O2.type === "BooleanLiteral" || O2.type === "NullLiteral" || O2.type === "NumericLiteral" || O2.type === "RegExpLiteral" || O2.type === "StringLiteral" || O2.type === "Identifier" || O2.type === "ThisExpression" || O2.type === "Super" || O2.type === "PrivateName" || O2.type === "PrivateIdentifier" || O2.type === "ArgumentPlaceholder" || O2.type === "Import" ? true : O2.type === "TemplateLiteral" ? O2.quasis.every((Je2) => !Je2.value.raw.includes(`
`)) && O2.expressions.every(Te2) : O2.type === "ObjectExpression" ? O2.properties.every((Je2) => !Je2.computed && (Je2.shorthand || Je2.value && Te2(Je2.value))) : O2.type === "ArrayExpression" ? O2.elements.every((Je2) => Je2 === null || Te2(Je2)) : ze(O2) ? (O2.type === "ImportExpression" || ae2(O2.callee, fe2)) && Xe2(O2).every(Te2) : De2(O2) ? ae2(O2.object, fe2) && ae2(O2.property, fe2) : O2.type === "UnaryExpression" && (O2.operator === "!" || O2.operator === "-") ? ae2(O2.argument, fe2) : O2.type === "TSNonNullExpression" ? ae2(O2.expression, fe2) : false;
          }
          function ve2(O2) {
            var fe2, Te2;
            return (fe2 = (Te2 = O2.extra) === null || Te2 === void 0 ? void 0 : Te2.raw) !== null && fe2 !== void 0 ? fe2 : O2.raw;
          }
          function K(O2) {
            return O2;
          }
          function he2(O2) {
            return O2.filepath && /\.tsx$/i.test(O2.filepath);
          }
          function ye2(O2) {
            let fe2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "es5";
            return O2.trailingComma === "es5" && fe2 === "es5" || O2.trailingComma === "all" && (fe2 === "all" || fe2 === "es5");
          }
          function Ce2(O2, fe2) {
            switch (O2 = Ee(O2), O2.type) {
              case "FunctionExpression":
              case "ClassExpression":
              case "DoExpression":
                return fe2;
              case "ObjectExpression":
                return true;
              case "MemberExpression":
              case "OptionalMemberExpression":
                return Ce2(O2.object, fe2);
              case "TaggedTemplateExpression":
                return O2.tag.type === "FunctionExpression" ? false : Ce2(O2.tag, fe2);
              case "CallExpression":
              case "OptionalCallExpression":
                return O2.callee.type === "FunctionExpression" ? false : Ce2(O2.callee, fe2);
              case "ConditionalExpression":
                return Ce2(O2.test, fe2);
              case "UpdateExpression":
                return !O2.prefix && Ce2(O2.argument, fe2);
              case "BindExpression":
                return O2.object && Ce2(O2.object, fe2);
              case "SequenceExpression":
                return Ce2(O2.expressions[0], fe2);
              case "TSAsExpression":
              case "TSNonNullExpression":
                return Ce2(O2.expression, fe2);
              default:
                return false;
            }
          }
          var Ie2 = { "==": true, "!=": true, "===": true, "!==": true }, Fe2 = { "*": true, "/": true, "%": true }, me2 = { ">>": true, ">>>": true, "<<": true };
          function _(O2, fe2) {
            return !(ne(fe2) !== ne(O2) || O2 === "**" || Ie2[O2] && Ie2[fe2] || fe2 === "%" && Fe2[O2] || O2 === "%" && Fe2[fe2] || fe2 !== O2 && Fe2[fe2] && Fe2[O2] || me2[O2] && me2[fe2]);
          }
          var J2 = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((O2, fe2) => O2.map((Te2) => [Te2, fe2])));
          function ne(O2) {
            return J2.get(O2);
          }
          function Ee(O2) {
            for (; O2.left; )
              O2 = O2.left;
            return O2;
          }
          function We2(O2) {
            return Boolean(me2[O2]) || O2 === "|" || O2 === "^" || O2 === "&";
          }
          function Be(O2) {
            var fe2;
            if (O2.rest)
              return true;
            let Te2 = Se2(O2);
            return ((fe2 = s2(Te2)) === null || fe2 === void 0 ? void 0 : fe2.type) === "RestElement";
          }
          var Pe2 = /* @__PURE__ */ new WeakMap();
          function Se2(O2) {
            if (Pe2.has(O2))
              return Pe2.get(O2);
            let fe2 = [];
            return O2.this && fe2.push(O2.this), Array.isArray(O2.parameters) ? fe2.push(...O2.parameters) : Array.isArray(O2.params) && fe2.push(...O2.params), O2.rest && fe2.push(O2.rest), Pe2.set(O2, fe2), fe2;
          }
          function Qe(O2, fe2) {
            let Te2 = O2.getValue(), $e2 = 0, Je2 = (Ze2) => fe2(Ze2, $e2++);
            Te2.this && O2.call(Je2, "this"), Array.isArray(Te2.parameters) ? O2.each(Je2, "parameters") : Array.isArray(Te2.params) && O2.each(Je2, "params"), Te2.rest && O2.call(Je2, "rest");
          }
          var xe2 = /* @__PURE__ */ new WeakMap();
          function Xe2(O2) {
            if (xe2.has(O2))
              return xe2.get(O2);
            let fe2 = O2.arguments;
            return O2.type === "ImportExpression" && (fe2 = [O2.source], O2.attributes && fe2.push(O2.attributes)), xe2.set(O2, fe2), fe2;
          }
          function _e2(O2, fe2) {
            let Te2 = O2.getValue();
            Te2.type === "ImportExpression" ? (O2.call(($e2) => fe2($e2, 0), "source"), Te2.attributes && O2.call(($e2) => fe2($e2, 1), "attributes")) : O2.each(fe2, "arguments");
          }
          function je2(O2) {
            return O2.value.trim() === "prettier-ignore" && !O2.unignore;
          }
          function Re2(O2) {
            return O2 && (O2.prettierIgnore || se(O2, Le2.PrettierIgnore));
          }
          function be2(O2) {
            let fe2 = O2.getValue();
            return Re2(fe2);
          }
          var Le2 = { Leading: 1 << 1, Trailing: 1 << 2, Dangling: 1 << 3, Block: 1 << 4, Line: 1 << 5, PrettierIgnore: 1 << 6, First: 1 << 7, Last: 1 << 8 }, qe2 = (O2, fe2) => {
            if (typeof O2 == "function" && (fe2 = O2, O2 = 0), O2 || fe2)
              return (Te2, $e2, Je2) => !(O2 & Le2.Leading && !Te2.leading || O2 & Le2.Trailing && !Te2.trailing || O2 & Le2.Dangling && (Te2.leading || Te2.trailing) || O2 & Le2.Block && !d4(Te2) || O2 & Le2.Line && !C2(Te2) || O2 & Le2.First && $e2 !== 0 || O2 & Le2.Last && $e2 !== Je2.length - 1 || O2 & Le2.PrettierIgnore && !je2(Te2) || fe2 && !fe2(Te2));
          };
          function se(O2, fe2, Te2) {
            if (!u(O2 == null ? void 0 : O2.comments))
              return false;
            let $e2 = qe2(fe2, Te2);
            return $e2 ? O2.comments.some($e2) : true;
          }
          function He2(O2, fe2, Te2) {
            if (!Array.isArray(O2 == null ? void 0 : O2.comments))
              return [];
            let $e2 = qe2(fe2, Te2);
            return $e2 ? O2.comments.filter($e2) : O2.comments;
          }
          var Me2 = (O2, fe2) => {
            let { originalText: Te2 } = fe2;
            return i2(Te2, v(O2));
          };
          function ze(O2) {
            return ue2(O2) || O2.type === "NewExpression" || O2.type === "ImportExpression";
          }
          function nt(O2) {
            return O2 && (O2.type === "ObjectProperty" || O2.type === "Property" && !O2.method && O2.kind === "init");
          }
          function tt(O2) {
            return Boolean(O2.__isUsingHackPipeline);
          }
          var pt2 = Symbol("ifWithoutBlockAndSameLineComment");
          n.exports = { getFunctionParameters: Se2, iterateFunctionParametersPath: Qe, getCallArguments: Xe2, iterateCallArgumentsPath: _e2, hasRestParameter: Be, getLeftSide: I2, getLeftSidePathName: k2, getParentExportDeclaration: g2, getTypeScriptMappedTypeModifier: G, hasFlowAnnotationComment: A2, hasFlowShorthandAnnotationComment: T2, hasLeadingOwnLineComment: U, hasNakedLeftSide: B, hasNode: S2, hasIgnoreComment: be2, hasNodeIgnoreComment: Re2, identity: K, isBinaryish: H3, isCallLikeExpression: ze, isEnabledHackPipeline: tt, isLineComment: C2, isPrettierIgnoreComment: je2, isCallExpression: ue2, isMemberExpression: De2, isExportDeclaration: D2, isFlowAnnotationComment: z, isFunctionCompositionArgs: pe, isFunctionNotation: V, isFunctionOrArrowExpression: x2, isGetterOrSetter: $, isJestEachTemplateLiteral: Ae2, isJsxNode: M2, isLiteral: F, isLongCurriedCallExpression: de2, isSimpleCallArgument: ae2, isMemberish: R, isNumericLiteral: l, isSignedNumericLiteral: E, isObjectProperty: nt, isObjectType: N, isObjectTypePropertyAFunction: q, isSimpleType: ee2, isSimpleNumber: ge2, isSimpleTemplateLiteral: ie, isStringLiteral: y, isStringPropSafeToUnquote: le2, isTemplateOnItsOwnLine: ke2, isTestCall: X3, isTheOnlyJsxElementInMarkdown: j, isTSXFile: he2, isTypeAnnotationAFunction: Y3, isNextLineEmpty: Me2, needsHardlineAfterDanglingComment: ce, rawText: ve2, shouldPrintComma: ye2, isBitwiseOperator: We2, shouldFlatten: _, startsWithNoLookaheadToken: Ce2, getPrecedence: ne, hasComment: se, getComments: He2, CommentCheckFlags: Le2, markerForIfWithoutBlockAndSameLineComment: pt2 };
        } }), Lt2 = Z3({ "src/language-js/print/template-literal.js"(e, n) {
          re2();
          var t = it2(), { getStringWidth: s2, getIndentSize: a3 } = Ue2(), { builders: { join: r, hardline: u, softline: i2, group: o, indent: c, align: v, lineSuffixBoundary: m2, addAlignmentToDoc: d4 }, printer: { printDocToString: p }, utils: { mapDoc: f } } = Oe2(), { isBinaryish: h2, isJestEachTemplateLiteral: w2, isSimpleTemplateLiteral: T2, hasComment: A2, isMemberExpression: S2 } = Ke2();
          function B(g2, F, l) {
            let E = g2.getValue();
            if (E.type === "TemplateLiteral" && w2(E, g2.getParentNode())) {
              let M2 = I2(g2, l, F);
              if (M2)
                return M2;
            }
            let N = "expressions";
            E.type === "TSTemplateLiteralType" && (N = "types");
            let x2 = [], b2 = g2.map(F, N), L = T2(E);
            return L && (b2 = b2.map((M2) => p(M2, Object.assign(Object.assign({}, l), {}, { printWidth: Number.POSITIVE_INFINITY })).formatted)), x2.push(m2, "`"), g2.each((M2) => {
              let j = M2.getName();
              if (x2.push(F()), j < b2.length) {
                let { tabWidth: $ } = l, V = M2.getValue(), q = a3(V.value.raw, $), Y3 = b2[j];
                if (!L) {
                  let R = E[N][j];
                  (A2(R) || S2(R) || R.type === "ConditionalExpression" || R.type === "SequenceExpression" || R.type === "TSAsExpression" || h2(R)) && (Y3 = [c([i2, Y3]), i2]);
                }
                let H3 = q === 0 && V.value.raw.endsWith(`
`) ? v(Number.NEGATIVE_INFINITY, Y3) : d4(Y3, q, $);
                x2.push(o(["${", H3, m2, "}"]));
              }
            }, "quasis"), x2.push("`"), x2;
          }
          function I2(g2, F, l) {
            let E = g2.getNode(), y = E.quasis[0].value.raw.trim().split(/\s*\|\s*/);
            if (y.length > 1 || y.some((N) => N.length > 0)) {
              F.__inJestEach = true;
              let N = g2.map(l, "expressions");
              F.__inJestEach = false;
              let x2 = [], b2 = N.map((V) => "${" + p(V, Object.assign(Object.assign({}, F), {}, { printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" })).formatted + "}"), L = [{ hasLineBreak: false, cells: [] }];
              for (let V = 1; V < E.quasis.length; V++) {
                let q = t(L), Y3 = b2[V - 1];
                q.cells.push(Y3), Y3.includes(`
`) && (q.hasLineBreak = true), E.quasis[V].value.raw.includes(`
`) && L.push({ hasLineBreak: false, cells: [] });
              }
              let M2 = Math.max(y.length, ...L.map((V) => V.cells.length)), j = Array.from({ length: M2 }).fill(0), $ = [{ cells: y }, ...L.filter((V) => V.cells.length > 0)];
              for (let { cells: V } of $.filter((q) => !q.hasLineBreak))
                for (let [q, Y3] of V.entries())
                  j[q] = Math.max(j[q], s2(Y3));
              return x2.push(m2, "`", c([u, r(u, $.map((V) => r(" | ", V.cells.map((q, Y3) => V.hasLineBreak ? q : q + " ".repeat(j[Y3] - s2(q))))))]), u, "`"), x2;
            }
          }
          function k2(g2, F) {
            let l = g2.getValue(), E = F();
            return A2(l) && (E = o([c([i2, E]), i2])), ["${", E, m2, "}"];
          }
          function P(g2, F) {
            return g2.map((l) => k2(l, F), "expressions");
          }
          function C2(g2, F) {
            return f(g2, (l) => typeof l == "string" ? F ? l.replace(/(\\*)`/g, "$1$1\\`") : D2(l) : l);
          }
          function D2(g2) {
            return g2.replace(/([\\`]|\${)/g, "\\$1");
          }
          n.exports = { printTemplateLiteral: B, printTemplateExpressions: P, escapeTemplateCharacters: C2, uncookTemplateElementValue: D2 };
        } }), wm2 = Z3({ "src/language-js/embed/markdown.js"(e, n) {
          re2();
          var { builders: { indent: t, softline: s2, literalline: a3, dedentToRoot: r } } = Oe2(), { escapeTemplateCharacters: u } = Lt2();
          function i2(c, v, m2) {
            let p = c.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (T2, A2) => "\\".repeat(A2.length / 2) + "`"), f = o(p), h2 = f !== "";
            h2 && (p = p.replace(new RegExp("^".concat(f), "gm"), ""));
            let w2 = u(m2(p, { parser: "markdown", __inJsTemplate: true }, { stripTrailingHardline: true }), true);
            return ["`", h2 ? t([s2, w2]) : [a3, r(w2)], s2, "`"];
          }
          function o(c) {
            let v = c.match(/^([^\S\n]*)\S/m);
            return v === null ? "" : v[1];
          }
          n.exports = i2;
        } }), _m2 = Z3({ "src/language-js/embed/css.js"(e, n) {
          re2();
          var { isNonEmptyArray: t } = Ue2(), { builders: { indent: s2, hardline: a3, softline: r }, utils: { mapDoc: u, replaceEndOfLine: i2, cleanDoc: o } } = Oe2(), { printTemplateExpressions: c } = Lt2();
          function v(p, f, h2) {
            let w2 = p.getValue(), T2 = w2.quasis.map((k2) => k2.value.raw), A2 = 0, S2 = T2.reduce((k2, P, C2) => C2 === 0 ? P : k2 + "@prettier-placeholder-" + A2++ + "-id" + P, ""), B = h2(S2, { parser: "scss" }, { stripTrailingHardline: true }), I2 = c(p, f);
            return m2(B, w2, I2);
          }
          function m2(p, f, h2) {
            if (f.quasis.length === 1 && !f.quasis[0].value.raw.trim())
              return "``";
            let T2 = d4(p, h2);
            if (!T2)
              throw new Error("Couldn't insert all the expressions");
            return ["`", s2([a3, T2]), r, "`"];
          }
          function d4(p, f) {
            if (!t(f))
              return p;
            let h2 = 0, w2 = u(o(p), (T2) => typeof T2 != "string" || !T2.includes("@prettier-placeholder") ? T2 : T2.split(/@prettier-placeholder-(\d+)-id/).map((A2, S2) => S2 % 2 === 0 ? i2(A2) : (h2++, f[A2])));
            return f.length === h2 ? w2 : null;
          }
          n.exports = v;
        } }), Pm2 = Z3({ "src/language-js/embed/graphql.js"(e, n) {
          re2();
          var { builders: { indent: t, join: s2, hardline: a3 } } = Oe2(), { escapeTemplateCharacters: r, printTemplateExpressions: u } = Lt2();
          function i2(c, v, m2) {
            let d4 = c.getValue(), p = d4.quasis.length;
            if (p === 1 && d4.quasis[0].value.raw.trim() === "")
              return "``";
            let f = u(c, v), h2 = [];
            for (let w2 = 0; w2 < p; w2++) {
              let T2 = d4.quasis[w2], A2 = w2 === 0, S2 = w2 === p - 1, B = T2.value.cooked, I2 = B.split(`
`), k2 = I2.length, P = f[w2], C2 = k2 > 2 && I2[0].trim() === "" && I2[1].trim() === "", D2 = k2 > 2 && I2[k2 - 1].trim() === "" && I2[k2 - 2].trim() === "", g2 = I2.every((l) => /^\s*(?:#[^\n\r]*)?$/.test(l));
              if (!S2 && /#[^\n\r]*$/.test(I2[k2 - 1]))
                return null;
              let F = null;
              g2 ? F = o(I2) : F = m2(B, { parser: "graphql" }, { stripTrailingHardline: true }), F ? (F = r(F, false), !A2 && C2 && h2.push(""), h2.push(F), !S2 && D2 && h2.push("")) : !A2 && !S2 && C2 && h2.push(""), P && h2.push(P);
            }
            return ["`", t([a3, s2(a3, h2)]), a3, "`"];
          }
          function o(c) {
            let v = [], m2 = false, d4 = c.map((p) => p.trim());
            for (let [p, f] of d4.entries())
              f !== "" && (d4[p - 1] === "" && m2 ? v.push([a3, f]) : v.push(f), m2 = true);
            return v.length === 0 ? null : s2(a3, v);
          }
          n.exports = i2;
        } }), km2 = Z3({ "src/language-js/embed/html.js"(e, n) {
          re2();
          var { builders: { indent: t, line: s2, hardline: a3, group: r }, utils: { mapDoc: u } } = Oe2(), { printTemplateExpressions: i2, uncookTemplateElementValue: o } = Lt2(), c = 0;
          function v(m2, d4, p, f, h2) {
            let { parser: w2 } = h2, T2 = m2.getValue(), A2 = c;
            c = c + 1 >>> 0;
            let S2 = (E) => "PRETTIER_HTML_PLACEHOLDER_".concat(E, "_").concat(A2, "_IN_JS"), B = T2.quasis.map((E, y, N) => y === N.length - 1 ? E.value.cooked : E.value.cooked + S2(y)).join(""), I2 = i2(m2, d4);
            if (I2.length === 0 && B.trim().length === 0)
              return "``";
            let k2 = new RegExp(S2("(\\d+)"), "g"), P = 0, C2 = p(B, { parser: w2, __onHtmlRoot(E) {
              P = E.children.length;
            } }, { stripTrailingHardline: true }), D2 = u(C2, (E) => {
              if (typeof E != "string")
                return E;
              let y = [], N = E.split(k2);
              for (let x2 = 0; x2 < N.length; x2++) {
                let b2 = N[x2];
                if (x2 % 2 === 0) {
                  b2 && (b2 = o(b2), f.__embeddedInHtml && (b2 = b2.replace(/<\/(script)\b/gi, "<\\/$1")), y.push(b2));
                  continue;
                }
                let L = Number(b2);
                y.push(I2[L]);
              }
              return y;
            }), g2 = /^\s/.test(B) ? " " : "", F = /\s$/.test(B) ? " " : "", l = f.htmlWhitespaceSensitivity === "ignore" ? a3 : g2 && F ? s2 : null;
            return r(l ? ["`", t([l, r(D2)]), l, "`"] : ["`", g2, P > 1 ? t(r(D2)) : r(D2), F, "`"]);
          }
          n.exports = v;
        } }), Im2 = Z3({ "src/language-js/embed.js"(e, n) {
          re2();
          var { hasComment: t, CommentCheckFlags: s2, isObjectProperty: a3 } = Ke2(), r = wm2(), u = _m2(), i2 = Pm2(), o = km2();
          function c(C2) {
            if (d4(C2) || w2(C2) || T2(C2) || p(C2))
              return "css";
            if (B(C2))
              return "graphql";
            if (k2(C2))
              return "html";
            if (f(C2))
              return "angular";
            if (m2(C2))
              return "markdown";
          }
          function v(C2, D2, g2, F) {
            let l = C2.getValue();
            if (l.type !== "TemplateLiteral" || P(l))
              return;
            let E = c(C2);
            if (!!E) {
              if (E === "markdown")
                return r(C2, D2, g2);
              if (E === "css")
                return u(C2, D2, g2);
              if (E === "graphql")
                return i2(C2, D2, g2);
              if (E === "html" || E === "angular")
                return o(C2, D2, g2, F, { parser: E });
            }
          }
          function m2(C2) {
            let D2 = C2.getValue(), g2 = C2.getParentNode();
            return g2 && g2.type === "TaggedTemplateExpression" && D2.quasis.length === 1 && g2.tag.type === "Identifier" && (g2.tag.name === "md" || g2.tag.name === "markdown");
          }
          function d4(C2) {
            let D2 = C2.getValue(), g2 = C2.getParentNode(), F = C2.getParentNode(1);
            return F && D2.quasis && g2.type === "JSXExpressionContainer" && F.type === "JSXElement" && F.openingElement.name.name === "style" && F.openingElement.attributes.some((l) => l.name.name === "jsx") || g2 && g2.type === "TaggedTemplateExpression" && g2.tag.type === "Identifier" && g2.tag.name === "css" || g2 && g2.type === "TaggedTemplateExpression" && g2.tag.type === "MemberExpression" && g2.tag.object.name === "css" && (g2.tag.property.name === "global" || g2.tag.property.name === "resolve");
          }
          function p(C2) {
            return C2.match((D2) => D2.type === "TemplateLiteral", (D2, g2) => D2.type === "ArrayExpression" && g2 === "elements", (D2, g2) => a3(D2) && D2.key.type === "Identifier" && D2.key.name === "styles" && g2 === "value", ...h2);
          }
          function f(C2) {
            return C2.match((D2) => D2.type === "TemplateLiteral", (D2, g2) => a3(D2) && D2.key.type === "Identifier" && D2.key.name === "template" && g2 === "value", ...h2);
          }
          var h2 = [(C2, D2) => C2.type === "ObjectExpression" && D2 === "properties", (C2, D2) => C2.type === "CallExpression" && C2.callee.type === "Identifier" && C2.callee.name === "Component" && D2 === "arguments", (C2, D2) => C2.type === "Decorator" && D2 === "expression"];
          function w2(C2) {
            let D2 = C2.getParentNode();
            if (!D2 || D2.type !== "TaggedTemplateExpression")
              return false;
            let g2 = D2.tag.type === "ParenthesizedExpression" ? D2.tag.expression : D2.tag;
            switch (g2.type) {
              case "MemberExpression":
                return A2(g2.object) || S2(g2);
              case "CallExpression":
                return A2(g2.callee) || g2.callee.type === "MemberExpression" && (g2.callee.object.type === "MemberExpression" && (A2(g2.callee.object.object) || S2(g2.callee.object)) || g2.callee.object.type === "CallExpression" && A2(g2.callee.object.callee));
              case "Identifier":
                return g2.name === "css";
              default:
                return false;
            }
          }
          function T2(C2) {
            let D2 = C2.getParentNode(), g2 = C2.getParentNode(1);
            return g2 && D2.type === "JSXExpressionContainer" && g2.type === "JSXAttribute" && g2.name.type === "JSXIdentifier" && g2.name.name === "css";
          }
          function A2(C2) {
            return C2.type === "Identifier" && C2.name === "styled";
          }
          function S2(C2) {
            return /^[A-Z]/.test(C2.object.name) && C2.property.name === "extend";
          }
          function B(C2) {
            let D2 = C2.getValue(), g2 = C2.getParentNode();
            return I2(D2, "GraphQL") || g2 && (g2.type === "TaggedTemplateExpression" && (g2.tag.type === "MemberExpression" && g2.tag.object.name === "graphql" && g2.tag.property.name === "experimental" || g2.tag.type === "Identifier" && (g2.tag.name === "gql" || g2.tag.name === "graphql")) || g2.type === "CallExpression" && g2.callee.type === "Identifier" && g2.callee.name === "graphql");
          }
          function I2(C2, D2) {
            return t(C2, s2.Block | s2.Leading, (g2) => {
              let { value: F } = g2;
              return F === " ".concat(D2, " ");
            });
          }
          function k2(C2) {
            return I2(C2.getValue(), "HTML") || C2.match((D2) => D2.type === "TemplateLiteral", (D2, g2) => D2.type === "TaggedTemplateExpression" && D2.tag.type === "Identifier" && D2.tag.name === "html" && g2 === "quasi");
          }
          function P(C2) {
            let { quasis: D2 } = C2;
            return D2.some((g2) => {
              let { value: { cooked: F } } = g2;
              return F === null;
            });
          }
          n.exports = v;
        } }), Lm2 = Z3({ "src/language-js/clean.js"(e, n) {
          re2();
          var t = It2(), s2 = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), a3 = (u) => {
            for (let i2 of u.quasis)
              delete i2.value;
          };
          function r(u, i2, o) {
            if (u.type === "Program" && delete i2.sourceType, (u.type === "BigIntLiteral" || u.type === "BigIntLiteralTypeAnnotation") && i2.value && (i2.value = i2.value.toLowerCase()), (u.type === "BigIntLiteral" || u.type === "Literal") && i2.bigint && (i2.bigint = i2.bigint.toLowerCase()), u.type === "DecimalLiteral" && (i2.value = Number(i2.value)), u.type === "Literal" && i2.decimal && (i2.decimal = Number(i2.decimal)), u.type === "EmptyStatement" || u.type === "JSXText" || u.type === "JSXExpressionContainer" && (u.expression.type === "Literal" || u.expression.type === "StringLiteral") && u.expression.value === " ")
              return null;
            if ((u.type === "Property" || u.type === "ObjectProperty" || u.type === "MethodDefinition" || u.type === "ClassProperty" || u.type === "ClassMethod" || u.type === "PropertyDefinition" || u.type === "TSDeclareMethod" || u.type === "TSPropertySignature" || u.type === "ObjectTypeProperty") && typeof u.key == "object" && u.key && (u.key.type === "Literal" || u.key.type === "NumericLiteral" || u.key.type === "StringLiteral" || u.key.type === "Identifier") && delete i2.key, u.type === "JSXElement" && u.openingElement.name.name === "style" && u.openingElement.attributes.some((m2) => m2.name.name === "jsx"))
              for (let { type: m2, expression: d4 } of i2.children)
                m2 === "JSXExpressionContainer" && d4.type === "TemplateLiteral" && a3(d4);
            u.type === "JSXAttribute" && u.name.name === "css" && u.value.type === "JSXExpressionContainer" && u.value.expression.type === "TemplateLiteral" && a3(i2.value.expression), u.type === "JSXAttribute" && u.value && u.value.type === "Literal" && /["']|&quot;|&apos;/.test(u.value.value) && (i2.value.value = i2.value.value.replace(/["']|&quot;|&apos;/g, '"'));
            let c = u.expression || u.callee;
            if (u.type === "Decorator" && c.type === "CallExpression" && c.callee.name === "Component" && c.arguments.length === 1) {
              let m2 = u.expression.arguments[0].properties;
              for (let [d4, p] of i2.expression.arguments[0].properties.entries())
                switch (m2[d4].key.name) {
                  case "styles":
                    p.value.type === "ArrayExpression" && a3(p.value.elements[0]);
                    break;
                  case "template":
                    p.value.type === "TemplateLiteral" && a3(p.value);
                    break;
                }
            }
            if (u.type === "TaggedTemplateExpression" && (u.tag.type === "MemberExpression" || u.tag.type === "Identifier" && (u.tag.name === "gql" || u.tag.name === "graphql" || u.tag.name === "css" || u.tag.name === "md" || u.tag.name === "markdown" || u.tag.name === "html") || u.tag.type === "CallExpression") && a3(i2.quasi), u.type === "TemplateLiteral") {
              var v;
              (((v = u.leadingComments) === null || v === void 0 ? void 0 : v.some((d4) => t(d4) && ["GraphQL", "HTML"].some((p) => d4.value === " ".concat(p, " ")))) || o.type === "CallExpression" && o.callee.name === "graphql" || !u.leadingComments) && a3(i2);
            }
            if (u.type === "InterpreterDirective" && (i2.value = i2.value.trimEnd()), (u.type === "TSIntersectionType" || u.type === "TSUnionType") && u.types.length === 1)
              return i2.types[0];
          }
          r.ignoredProperties = s2, n.exports = r;
        } }), Ha2 = {};
        Ut2(Ha2, { EOL: () => Pn2, arch: () => jm2, cpus: () => Ya2, default: () => ro2, endianness: () => Ga2, freemem: () => Xa2, getNetworkInterfaces: () => to2, hostname: () => Ja2, loadavg: () => Ua2, networkInterfaces: () => eo2, platform: () => Om2, release: () => Za2, tmpDir: () => wn2, tmpdir: () => _n2, totalmem: () => Ka2, type: () => Qa2, uptime: () => za2 });
        function Ga2() {
          if (typeof Sr2 > "u") {
            var e = new ArrayBuffer(2), n = new Uint8Array(e), t = new Uint16Array(e);
            if (n[0] = 1, n[1] = 2, t[0] === 258)
              Sr2 = "BE";
            else if (t[0] === 513)
              Sr2 = "LE";
            else
              throw new Error("unable to figure out endianess");
          }
          return Sr2;
        }
        function Ja2() {
          return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
        }
        function Ua2() {
          return [];
        }
        function za2() {
          return 0;
        }
        function Xa2() {
          return Number.MAX_VALUE;
        }
        function Ka2() {
          return Number.MAX_VALUE;
        }
        function Ya2() {
          return [];
        }
        function Qa2() {
          return "Browser";
        }
        function Za2() {
          return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
        }
        function eo2() {
        }
        function to2() {
        }
        function jm2() {
          return "javascript";
        }
        function Om2() {
          return "browser";
        }
        function wn2() {
          return "/tmp";
        }
        var Sr2, _n2, Pn2, ro2, qm2 = mt2({ "node-modules-polyfills:os"() {
          re2(), _n2 = wn2, Pn2 = `
`, ro2 = { EOL: Pn2, tmpdir: _n2, tmpDir: wn2, networkInterfaces: eo2, getNetworkInterfaces: to2, release: Za2, type: Qa2, cpus: Ya2, totalmem: Ka2, freemem: Xa2, uptime: za2, loadavg: Ua2, hostname: Ja2, endianness: Ga2 };
        } }), Mm2 = Z3({ "node-modules-polyfills-commonjs:os"(e, n) {
          re2();
          var t = (qm2(), lt2(Ha2));
          if (t && t.default) {
            n.exports = t.default;
            for (let s2 in t)
              n.exports[s2] = t[s2];
          } else
            t && (n.exports = t);
        } }), Rm2 = Z3({ "node_modules/detect-newline/index.js"(e, n) {
          re2();
          var t = (s2) => {
            if (typeof s2 != "string")
              throw new TypeError("Expected a string");
            let a3 = s2.match(/(?:\r?\n)/g) || [];
            if (a3.length === 0)
              return;
            let r = a3.filter((i2) => i2 === `\r
`).length, u = a3.length - r;
            return r > u ? `\r
` : `
`;
          };
          n.exports = t, n.exports.graceful = (s2) => typeof s2 == "string" && t(s2) || `
`;
        } }), Vm2 = Z3({ "node_modules/jest-docblock/build/index.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true }), e.extract = p, e.parse = h2, e.parseWithComments = w2, e.print = T2, e.strip = f;
          function n() {
            let S2 = Mm2();
            return n = function() {
              return S2;
            }, S2;
          }
          function t() {
            let S2 = s2(Rm2());
            return t = function() {
              return S2;
            }, S2;
          }
          function s2(S2) {
            return S2 && S2.__esModule ? S2 : { default: S2 };
          }
          var a3 = /\*\/$/, r = /^\/\*\*/, u = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, i2 = /(^|\s+)\/\/([^\r\n]*)/g, o = /^(\r?\n)+/, c = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, v = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, m2 = /(\r?\n|^) *\* ?/g, d4 = [];
          function p(S2) {
            let B = S2.match(u);
            return B ? B[0].trimLeft() : "";
          }
          function f(S2) {
            let B = S2.match(u);
            return B && B[0] ? S2.substring(B[0].length) : S2;
          }
          function h2(S2) {
            return w2(S2).pragmas;
          }
          function w2(S2) {
            let B = (0, t().default)(S2) || n().EOL;
            S2 = S2.replace(r, "").replace(a3, "").replace(m2, "$1");
            let I2 = "";
            for (; I2 !== S2; )
              I2 = S2, S2 = S2.replace(c, "".concat(B, "$1 $2").concat(B));
            S2 = S2.replace(o, "").trimRight();
            let k2 = /* @__PURE__ */ Object.create(null), P = S2.replace(v, "").replace(o, "").trimRight(), C2;
            for (; C2 = v.exec(S2); ) {
              let D2 = C2[2].replace(i2, "");
              typeof k2[C2[1]] == "string" || Array.isArray(k2[C2[1]]) ? k2[C2[1]] = d4.concat(k2[C2[1]], D2) : k2[C2[1]] = D2;
            }
            return { comments: P, pragmas: k2 };
          }
          function T2(S2) {
            let { comments: B = "", pragmas: I2 = {} } = S2, k2 = (0, t().default)(B) || n().EOL, P = "/**", C2 = " *", D2 = " */", g2 = Object.keys(I2), F = g2.map((E) => A2(E, I2[E])).reduce((E, y) => E.concat(y), []).map((E) => C2 + " " + E + k2).join("");
            if (!B) {
              if (g2.length === 0)
                return "";
              if (g2.length === 1 && !Array.isArray(I2[g2[0]])) {
                let E = I2[g2[0]];
                return "".concat(P, " ").concat(A2(g2[0], E)[0]).concat(D2);
              }
            }
            let l = B.split(k2).map((E) => "".concat(C2, " ").concat(E)).join(k2) + k2;
            return P + k2 + (B ? l : "") + (B && g2.length ? C2 + k2 : "") + F + D2;
          }
          function A2(S2, B) {
            return d4.concat(B).map((I2) => "@".concat(S2, " ").concat(I2).trim());
          }
        } }), Wm2 = Z3({ "src/language-js/utils/get-shebang.js"(e, n) {
          re2();
          function t(s2) {
            if (!s2.startsWith("#!"))
              return "";
            let a3 = s2.indexOf(`
`);
            return a3 === -1 ? s2 : s2.slice(0, a3);
          }
          n.exports = t;
        } }), no2 = Z3({ "src/language-js/pragma.js"(e, n) {
          re2();
          var { parseWithComments: t, strip: s2, extract: a3, print: r } = Vm2(), { normalizeEndOfLine: u } = jn2(), i2 = Wm2();
          function o(m2) {
            let d4 = i2(m2);
            d4 && (m2 = m2.slice(d4.length + 1));
            let p = a3(m2), { pragmas: f, comments: h2 } = t(p);
            return { shebang: d4, text: m2, pragmas: f, comments: h2 };
          }
          function c(m2) {
            let d4 = Object.keys(o(m2).pragmas);
            return d4.includes("prettier") || d4.includes("format");
          }
          function v(m2) {
            let { shebang: d4, text: p, pragmas: f, comments: h2 } = o(m2), w2 = s2(p), T2 = r({ pragmas: Object.assign({ format: "" }, f), comments: h2.trimStart() });
            return (d4 ? "".concat(d4, `
`) : "") + u(T2) + (w2.startsWith(`
`) ? `
` : `

`) + w2;
          }
          n.exports = { hasPragma: c, insertPragma: v };
        } }), uo2 = Z3({ "src/language-js/comments.js"(e, n) {
          re2();
          var { getLast: t, hasNewline: s2, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: a3, getNextNonSpaceNonCommentCharacter: r, hasNewlineInRange: u, addLeadingComment: i2, addTrailingComment: o, addDanglingComment: c, getNextNonSpaceNonCommentCharacterIndex: v, isNonEmptyArray: m2 } = Ue2(), { getFunctionParameters: d4, isPrettierIgnoreComment: p, isJsxNode: f, hasFlowShorthandAnnotationComment: h2, hasFlowAnnotationComment: w2, hasIgnoreComment: T2, isCallLikeExpression: A2, getCallArguments: S2, isCallExpression: B, isMemberExpression: I2, isObjectProperty: k2, isLineComment: P, getComments: C2, CommentCheckFlags: D2, markerForIfWithoutBlockAndSameLineComment: g2 } = Ke2(), { locStart: F, locEnd: l } = st2(), E = It2();
          function y(me2) {
            return [ve2, De2, q, j, $, V, Q, Ae2, U, ge2, Ne2, ke2, te2, ie, G].some((_) => _(me2));
          }
          function N(me2) {
            return [M2, De2, Y3, Ne2, j, $, V, Q, ie, z, le2, ge2, de2, G, he2].some((_) => _(me2));
          }
          function x2(me2) {
            return [ve2, j, $, H3, ue2, te2, ge2, X3, W2, K, G, ae2].some((_) => _(me2));
          }
          function b2(me2, _) {
            let J2 = (me2.body || me2.properties).find((ne) => {
              let { type: Ee } = ne;
              return Ee !== "EmptyStatement";
            });
            J2 ? i2(J2, _) : c(me2, _);
          }
          function L(me2, _) {
            me2.type === "BlockStatement" ? b2(me2, _) : i2(me2, _);
          }
          function M2(me2) {
            let { comment: _, followingNode: J2 } = me2;
            return J2 && Ie2(_) ? (i2(J2, _), true) : false;
          }
          function j(me2) {
            let { comment: _, precedingNode: J2, enclosingNode: ne, followingNode: Ee, text: We2 } = me2;
            if ((ne == null ? void 0 : ne.type) !== "IfStatement" || !Ee)
              return false;
            if (r(We2, _, l) === ")")
              return o(J2, _), true;
            if (J2 === ne.consequent && Ee === ne.alternate) {
              if (J2.type === "BlockStatement")
                o(J2, _);
              else {
                let Pe2 = _.type === "SingleLine" || _.loc.start.line === _.loc.end.line, Se2 = _.loc.start.line === J2.loc.start.line;
                Pe2 && Se2 ? c(J2, _, g2) : c(ne, _);
              }
              return true;
            }
            return Ee.type === "BlockStatement" ? (b2(Ee, _), true) : Ee.type === "IfStatement" ? (L(Ee.consequent, _), true) : ne.consequent === Ee ? (i2(Ee, _), true) : false;
          }
          function $(me2) {
            let { comment: _, precedingNode: J2, enclosingNode: ne, followingNode: Ee, text: We2 } = me2;
            return (ne == null ? void 0 : ne.type) !== "WhileStatement" || !Ee ? false : r(We2, _, l) === ")" ? (o(J2, _), true) : Ee.type === "BlockStatement" ? (b2(Ee, _), true) : ne.body === Ee ? (i2(Ee, _), true) : false;
          }
          function V(me2) {
            let { comment: _, precedingNode: J2, enclosingNode: ne, followingNode: Ee } = me2;
            return (ne == null ? void 0 : ne.type) !== "TryStatement" && (ne == null ? void 0 : ne.type) !== "CatchClause" || !Ee ? false : ne.type === "CatchClause" && J2 ? (o(J2, _), true) : Ee.type === "BlockStatement" ? (b2(Ee, _), true) : Ee.type === "TryStatement" ? (L(Ee.finalizer, _), true) : Ee.type === "CatchClause" ? (L(Ee.body, _), true) : false;
          }
          function q(me2) {
            let { comment: _, enclosingNode: J2, followingNode: ne } = me2;
            return I2(J2) && (ne == null ? void 0 : ne.type) === "Identifier" ? (i2(J2, _), true) : false;
          }
          function Y3(me2) {
            let { comment: _, precedingNode: J2, enclosingNode: ne, followingNode: Ee, text: We2 } = me2, Be = J2 && !u(We2, l(J2), F(_));
            return (!J2 || !Be) && ((ne == null ? void 0 : ne.type) === "ConditionalExpression" || (ne == null ? void 0 : ne.type) === "TSConditionalType") && Ee ? (i2(Ee, _), true) : false;
          }
          function H3(me2) {
            let { comment: _, precedingNode: J2, enclosingNode: ne } = me2;
            return k2(ne) && ne.shorthand && ne.key === J2 && ne.value.type === "AssignmentPattern" ? (o(ne.value.left, _), true) : false;
          }
          var R = /* @__PURE__ */ new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
          function Q(me2) {
            let { comment: _, precedingNode: J2, enclosingNode: ne, followingNode: Ee } = me2;
            if (R.has(ne == null ? void 0 : ne.type)) {
              if (m2(ne.decorators) && !(Ee && Ee.type === "Decorator"))
                return o(t(ne.decorators), _), true;
              if (ne.body && Ee === ne.body)
                return b2(ne.body, _), true;
              if (Ee) {
                if (ne.superClass && Ee === ne.superClass && J2 && (J2 === ne.id || J2 === ne.typeParameters))
                  return o(J2, _), true;
                for (let We2 of ["implements", "extends", "mixins"])
                  if (ne[We2] && Ee === ne[We2][0])
                    return J2 && (J2 === ne.id || J2 === ne.typeParameters || J2 === ne.superClass) ? o(J2, _) : c(ne, _, We2), true;
              }
            }
            return false;
          }
          var ee2 = /* @__PURE__ */ new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition"]);
          function te2(me2) {
            let { comment: _, precedingNode: J2, enclosingNode: ne, text: Ee } = me2;
            return ne && J2 && r(Ee, _, l) === "(" && (ne.type === "Property" || ne.type === "TSDeclareMethod" || ne.type === "TSAbstractMethodDefinition") && J2.type === "Identifier" && ne.key === J2 && r(Ee, J2, l) !== ":" || (J2 == null ? void 0 : J2.type) === "Decorator" && ee2.has(ne == null ? void 0 : ne.type) ? (o(J2, _), true) : false;
          }
          var oe2 = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
          function W2(me2) {
            let { comment: _, precedingNode: J2, enclosingNode: ne, text: Ee } = me2;
            return r(Ee, _, l) !== "(" ? false : J2 && oe2.has(ne == null ? void 0 : ne.type) ? (o(J2, _), true) : false;
          }
          function X3(me2) {
            let { comment: _, enclosingNode: J2, text: ne } = me2;
            if ((J2 == null ? void 0 : J2.type) !== "ArrowFunctionExpression")
              return false;
            let Ee = v(ne, _, l);
            return Ee !== false && ne.slice(Ee, Ee + 2) === "=>" ? (c(J2, _), true) : false;
          }
          function ue2(me2) {
            let { comment: _, enclosingNode: J2, text: ne } = me2;
            return r(ne, _, l) !== ")" ? false : J2 && (ye2(J2) && d4(J2).length === 0 || A2(J2) && S2(J2).length === 0) ? (c(J2, _), true) : ((J2 == null ? void 0 : J2.type) === "MethodDefinition" || (J2 == null ? void 0 : J2.type) === "TSAbstractMethodDefinition") && d4(J2.value).length === 0 ? (c(J2.value, _), true) : false;
          }
          function De2(me2) {
            let { comment: _, precedingNode: J2, enclosingNode: ne, followingNode: Ee, text: We2 } = me2;
            if ((J2 == null ? void 0 : J2.type) === "FunctionTypeParam" && (ne == null ? void 0 : ne.type) === "FunctionTypeAnnotation" && (Ee == null ? void 0 : Ee.type) !== "FunctionTypeParam" || ((J2 == null ? void 0 : J2.type) === "Identifier" || (J2 == null ? void 0 : J2.type) === "AssignmentPattern") && ne && ye2(ne) && r(We2, _, l) === ")")
              return o(J2, _), true;
            if ((ne == null ? void 0 : ne.type) === "FunctionDeclaration" && (Ee == null ? void 0 : Ee.type) === "BlockStatement") {
              let Be = (() => {
                let Pe2 = d4(ne);
                if (Pe2.length > 0)
                  return a3(We2, l(t(Pe2)));
                let Se2 = a3(We2, l(ne.id));
                return Se2 !== false && a3(We2, Se2 + 1);
              })();
              if (F(_) > Be)
                return b2(Ee, _), true;
            }
            return false;
          }
          function ie(me2) {
            let { comment: _, enclosingNode: J2 } = me2;
            return (J2 == null ? void 0 : J2.type) === "LabeledStatement" ? (i2(J2, _), true) : false;
          }
          function G(me2) {
            let { comment: _, enclosingNode: J2 } = me2;
            return ((J2 == null ? void 0 : J2.type) === "ContinueStatement" || (J2 == null ? void 0 : J2.type) === "BreakStatement") && !J2.label ? (o(J2, _), true) : false;
          }
          function z(me2) {
            let { comment: _, precedingNode: J2, enclosingNode: ne } = me2;
            return B(ne) && J2 && ne.callee === J2 && ne.arguments.length > 0 ? (i2(ne.arguments[0], _), true) : false;
          }
          function U(me2) {
            let { comment: _, precedingNode: J2, enclosingNode: ne, followingNode: Ee } = me2;
            return (ne == null ? void 0 : ne.type) === "UnionTypeAnnotation" || (ne == null ? void 0 : ne.type) === "TSUnionType" ? (p(_) && (Ee.prettierIgnore = true, _.unignore = true), J2 ? (o(J2, _), true) : false) : (((Ee == null ? void 0 : Ee.type) === "UnionTypeAnnotation" || (Ee == null ? void 0 : Ee.type) === "TSUnionType") && p(_) && (Ee.types[0].prettierIgnore = true, _.unignore = true), false);
          }
          function le2(me2) {
            let { comment: _, enclosingNode: J2 } = me2;
            return k2(J2) ? (i2(J2, _), true) : false;
          }
          function ge2(me2) {
            let { comment: _, enclosingNode: J2, followingNode: ne, ast: Ee, isLastComment: We2 } = me2;
            return Ee && Ee.body && Ee.body.length === 0 ? (We2 ? c(Ee, _) : i2(Ee, _), true) : (J2 == null ? void 0 : J2.type) === "Program" && (J2 == null ? void 0 : J2.body.length) === 0 && !m2(J2.directives) ? (We2 ? c(J2, _) : i2(J2, _), true) : (ne == null ? void 0 : ne.type) === "Program" && (ne == null ? void 0 : ne.body.length) === 0 && (J2 == null ? void 0 : J2.type) === "ModuleExpression" ? (c(ne, _), true) : false;
          }
          function Ae2(me2) {
            let { comment: _, enclosingNode: J2 } = me2;
            return (J2 == null ? void 0 : J2.type) === "ForInStatement" || (J2 == null ? void 0 : J2.type) === "ForOfStatement" ? (i2(J2, _), true) : false;
          }
          function Ne2(me2) {
            let { comment: _, precedingNode: J2, enclosingNode: ne, text: Ee } = me2;
            if ((ne == null ? void 0 : ne.type) === "ImportSpecifier" || (ne == null ? void 0 : ne.type) === "ExportSpecifier")
              return i2(ne, _), true;
            let We2 = (J2 == null ? void 0 : J2.type) === "ImportSpecifier" && (ne == null ? void 0 : ne.type) === "ImportDeclaration", Be = (J2 == null ? void 0 : J2.type) === "ExportSpecifier" && (ne == null ? void 0 : ne.type) === "ExportNamedDeclaration";
            return (We2 || Be) && s2(Ee, l(_)) ? (o(J2, _), true) : false;
          }
          function ke2(me2) {
            let { comment: _, enclosingNode: J2 } = me2;
            return (J2 == null ? void 0 : J2.type) === "AssignmentPattern" ? (i2(J2, _), true) : false;
          }
          var ce = /* @__PURE__ */ new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]), pe = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
          function de2(me2) {
            let { comment: _, enclosingNode: J2, followingNode: ne } = me2;
            return ce.has(J2 == null ? void 0 : J2.type) && ne && (pe.has(ne.type) || E(_)) ? (i2(ne, _), true) : false;
          }
          function ae2(me2) {
            let { comment: _, enclosingNode: J2, followingNode: ne, text: Ee } = me2;
            return !ne && ((J2 == null ? void 0 : J2.type) === "TSMethodSignature" || (J2 == null ? void 0 : J2.type) === "TSDeclareFunction" || (J2 == null ? void 0 : J2.type) === "TSAbstractMethodDefinition") && r(Ee, _, l) === ";" ? (o(J2, _), true) : false;
          }
          function ve2(me2) {
            let { comment: _, enclosingNode: J2, followingNode: ne } = me2;
            if (p(_) && (J2 == null ? void 0 : J2.type) === "TSMappedType" && (ne == null ? void 0 : ne.type) === "TSTypeParameter" && ne.constraint)
              return J2.prettierIgnore = true, _.unignore = true, true;
          }
          function K(me2) {
            let { comment: _, precedingNode: J2, enclosingNode: ne, followingNode: Ee } = me2;
            return (ne == null ? void 0 : ne.type) !== "TSMappedType" ? false : (Ee == null ? void 0 : Ee.type) === "TSTypeParameter" && Ee.name ? (i2(Ee.name, _), true) : (J2 == null ? void 0 : J2.type) === "TSTypeParameter" && J2.constraint ? (o(J2.constraint, _), true) : false;
          }
          function he2(me2) {
            let { comment: _, enclosingNode: J2, followingNode: ne } = me2;
            return !J2 || J2.type !== "SwitchCase" || J2.test ? false : (ne.type === "BlockStatement" && P(_) ? b2(ne, _) : c(J2, _), true);
          }
          function ye2(me2) {
            return me2.type === "ArrowFunctionExpression" || me2.type === "FunctionExpression" || me2.type === "FunctionDeclaration" || me2.type === "ObjectMethod" || me2.type === "ClassMethod" || me2.type === "TSDeclareFunction" || me2.type === "TSCallSignatureDeclaration" || me2.type === "TSConstructSignatureDeclaration" || me2.type === "TSMethodSignature" || me2.type === "TSConstructorType" || me2.type === "TSFunctionType" || me2.type === "TSDeclareMethod";
          }
          function Ce2(me2, _) {
            if ((_.parser === "typescript" || _.parser === "flow" || _.parser === "acorn" || _.parser === "espree" || _.parser === "meriyah" || _.parser === "__babel_estree") && me2.type === "MethodDefinition" && me2.value && me2.value.type === "FunctionExpression" && d4(me2.value).length === 0 && !me2.value.returnType && !m2(me2.value.typeParameters) && me2.value.body)
              return [...me2.decorators || [], me2.key, me2.value.body];
          }
          function Ie2(me2) {
            return E(me2) && me2.value[0] === "*" && /@type\b/.test(me2.value);
          }
          function Fe2(me2) {
            let _ = me2.getValue(), J2 = me2.getParentNode(), ne = (Ee) => w2(C2(Ee, D2.Leading)) || w2(C2(Ee, D2.Trailing));
            return (_ && (f(_) || h2(_) || B(J2) && ne(_)) || J2 && (J2.type === "JSXSpreadAttribute" || J2.type === "JSXSpreadChild" || J2.type === "UnionTypeAnnotation" || J2.type === "TSUnionType" || (J2.type === "ClassDeclaration" || J2.type === "ClassExpression") && J2.superClass === _)) && (!T2(me2) || J2.type === "UnionTypeAnnotation" || J2.type === "TSUnionType");
          }
          n.exports = { handleOwnLineComment: y, handleEndOfLineComment: N, handleRemainingComment: x2, isTypeCastComment: Ie2, getCommentChildNodes: Ce2, willPrintOwnComments: Fe2 };
        } }), jt2 = Z3({ "src/language-js/needs-parens.js"(e, n) {
          re2();
          var t = it2(), s2 = Rn2(), { getFunctionParameters: a3, getLeftSidePathName: r, hasFlowShorthandAnnotationComment: u, hasNakedLeftSide: i2, hasNode: o, isBitwiseOperator: c, startsWithNoLookaheadToken: v, shouldFlatten: m2, getPrecedence: d4, isCallExpression: p, isMemberExpression: f, isObjectProperty: h2 } = Ke2();
          function w2(P, C2) {
            let D2 = P.getParentNode();
            if (!D2)
              return false;
            let g2 = P.getName(), F = P.getNode();
            if (C2.__isInHtmlInterpolation && !C2.bracketSpacing && B(F) && I2(P))
              return true;
            if (T2(F))
              return false;
            if (C2.parser !== "flow" && u(P.getValue()))
              return true;
            if (F.type === "Identifier")
              return !!(F.extra && F.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(F.name) || g2 === "left" && F.name === "async" && D2.type === "ForOfStatement" && !D2.await);
            switch (D2.type) {
              case "ParenthesizedExpression":
                return false;
              case "ClassDeclaration":
              case "ClassExpression": {
                if (g2 === "superClass" && (F.type === "ArrowFunctionExpression" || F.type === "AssignmentExpression" || F.type === "AwaitExpression" || F.type === "BinaryExpression" || F.type === "ConditionalExpression" || F.type === "LogicalExpression" || F.type === "NewExpression" || F.type === "ObjectExpression" || F.type === "SequenceExpression" || F.type === "TaggedTemplateExpression" || F.type === "UnaryExpression" || F.type === "UpdateExpression" || F.type === "YieldExpression" || F.type === "TSNonNullExpression"))
                  return true;
                break;
              }
              case "ExportDefaultDeclaration":
                return k2(P, C2) || F.type === "SequenceExpression";
              case "Decorator": {
                if (g2 === "expression") {
                  let l = false, E = false, y = F;
                  for (; y; )
                    switch (y.type) {
                      case "MemberExpression":
                        E = true, y = y.object;
                        break;
                      case "CallExpression":
                        if (E || l)
                          return C2.parser !== "typescript";
                        l = true, y = y.callee;
                        break;
                      case "Identifier":
                        return false;
                      case "TaggedTemplateExpression":
                        return C2.parser !== "typescript";
                      default:
                        return true;
                    }
                  return true;
                }
                break;
              }
              case "ExpressionStatement": {
                if (v(F, true))
                  return true;
                break;
              }
              case "ArrowFunctionExpression": {
                if (g2 === "body" && F.type !== "SequenceExpression" && v(F, false))
                  return true;
                break;
              }
            }
            switch (F.type) {
              case "UpdateExpression":
                if (D2.type === "UnaryExpression")
                  return F.prefix && (F.operator === "++" && D2.operator === "+" || F.operator === "--" && D2.operator === "-");
              case "UnaryExpression":
                switch (D2.type) {
                  case "UnaryExpression":
                    return F.operator === D2.operator && (F.operator === "+" || F.operator === "-");
                  case "BindExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return g2 === "object";
                  case "TaggedTemplateExpression":
                    return true;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return g2 === "callee";
                  case "BinaryExpression":
                    return g2 === "left" && D2.operator === "**";
                  case "TSNonNullExpression":
                    return true;
                  default:
                    return false;
                }
              case "BinaryExpression": {
                if (D2.type === "UpdateExpression" || F.operator === "in" && A2(P))
                  return true;
                if (F.operator === "|>" && F.extra && F.extra.parenthesized) {
                  let l = P.getParentNode(1);
                  if (l.type === "BinaryExpression" && l.operator === "|>")
                    return true;
                }
              }
              case "TSTypeAssertion":
              case "TSAsExpression":
              case "LogicalExpression":
                switch (D2.type) {
                  case "TSAsExpression":
                    return F.type !== "TSAsExpression";
                  case "ConditionalExpression":
                    return F.type === "TSAsExpression";
                  case "CallExpression":
                  case "NewExpression":
                  case "OptionalCallExpression":
                    return g2 === "callee";
                  case "ClassExpression":
                  case "ClassDeclaration":
                    return g2 === "superClass";
                  case "TSTypeAssertion":
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "JSXSpreadAttribute":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "BindExpression":
                  case "AwaitExpression":
                  case "TSNonNullExpression":
                  case "UpdateExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return g2 === "object";
                  case "AssignmentExpression":
                  case "AssignmentPattern":
                    return g2 === "left" && (F.type === "TSTypeAssertion" || F.type === "TSAsExpression");
                  case "LogicalExpression":
                    if (F.type === "LogicalExpression")
                      return D2.operator !== F.operator;
                  case "BinaryExpression": {
                    let { operator: l, type: E } = F;
                    if (!l && E !== "TSTypeAssertion")
                      return true;
                    let y = d4(l), N = D2.operator, x2 = d4(N);
                    return x2 > y || g2 === "right" && x2 === y || x2 === y && !m2(N, l) ? true : x2 < y && l === "%" ? N === "+" || N === "-" : !!c(N);
                  }
                  default:
                    return false;
                }
              case "SequenceExpression":
                switch (D2.type) {
                  case "ReturnStatement":
                    return false;
                  case "ForStatement":
                    return false;
                  case "ExpressionStatement":
                    return g2 !== "expression";
                  case "ArrowFunctionExpression":
                    return g2 !== "body";
                  default:
                    return true;
                }
              case "YieldExpression":
                if (D2.type === "UnaryExpression" || D2.type === "AwaitExpression" || D2.type === "TSAsExpression" || D2.type === "TSNonNullExpression")
                  return true;
              case "AwaitExpression":
                switch (D2.type) {
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "LogicalExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "TSAsExpression":
                  case "TSNonNullExpression":
                  case "BindExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return g2 === "object";
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return g2 === "callee";
                  case "ConditionalExpression":
                    return g2 === "test";
                  case "BinaryExpression":
                    return !(!F.argument && D2.operator === "|>");
                  default:
                    return false;
                }
              case "TSConditionalType":
                if (g2 === "extendsType" && D2.type === "TSConditionalType")
                  return true;
              case "TSFunctionType":
              case "TSConstructorType":
                if (g2 === "checkType" && D2.type === "TSConditionalType")
                  return true;
              case "TSUnionType":
              case "TSIntersectionType":
                if ((D2.type === "TSUnionType" || D2.type === "TSIntersectionType") && D2.types.length > 1 && (!F.types || F.types.length > 1))
                  return true;
              case "TSInferType":
                if (F.type === "TSInferType" && D2.type === "TSRestType")
                  return false;
              case "TSTypeOperator":
                return D2.type === "TSArrayType" || D2.type === "TSOptionalType" || D2.type === "TSRestType" || g2 === "objectType" && D2.type === "TSIndexedAccessType" || D2.type === "TSTypeOperator" || D2.type === "TSTypeAnnotation" && P.getParentNode(1).type.startsWith("TSJSDoc");
              case "ArrayTypeAnnotation":
                return D2.type === "NullableTypeAnnotation";
              case "IntersectionTypeAnnotation":
              case "UnionTypeAnnotation":
                return D2.type === "ArrayTypeAnnotation" || D2.type === "NullableTypeAnnotation" || D2.type === "IntersectionTypeAnnotation" || D2.type === "UnionTypeAnnotation" || g2 === "objectType" && (D2.type === "IndexedAccessType" || D2.type === "OptionalIndexedAccessType");
              case "NullableTypeAnnotation":
                return D2.type === "ArrayTypeAnnotation" || g2 === "objectType" && (D2.type === "IndexedAccessType" || D2.type === "OptionalIndexedAccessType");
              case "FunctionTypeAnnotation": {
                let l = D2.type === "NullableTypeAnnotation" ? P.getParentNode(1) : D2;
                return l.type === "UnionTypeAnnotation" || l.type === "IntersectionTypeAnnotation" || l.type === "ArrayTypeAnnotation" || g2 === "objectType" && (l.type === "IndexedAccessType" || l.type === "OptionalIndexedAccessType") || l.type === "NullableTypeAnnotation" || D2.type === "FunctionTypeParam" && D2.name === null && a3(F).some((E) => E.typeAnnotation && E.typeAnnotation.type === "NullableTypeAnnotation");
              }
              case "OptionalIndexedAccessType":
                return g2 === "objectType" && D2.type === "IndexedAccessType";
              case "TypeofTypeAnnotation":
                return g2 === "objectType" && (D2.type === "IndexedAccessType" || D2.type === "OptionalIndexedAccessType");
              case "StringLiteral":
              case "NumericLiteral":
              case "Literal":
                if (typeof F.value == "string" && D2.type === "ExpressionStatement" && !D2.directive) {
                  let l = P.getParentNode(1);
                  return l.type === "Program" || l.type === "BlockStatement";
                }
                return g2 === "object" && D2.type === "MemberExpression" && typeof F.value == "number";
              case "AssignmentExpression": {
                let l = P.getParentNode(1);
                return g2 === "body" && D2.type === "ArrowFunctionExpression" ? true : g2 === "key" && (D2.type === "ClassProperty" || D2.type === "PropertyDefinition") && D2.computed || (g2 === "init" || g2 === "update") && D2.type === "ForStatement" ? false : D2.type === "ExpressionStatement" ? F.left.type === "ObjectPattern" : !(g2 === "key" && D2.type === "TSPropertySignature" || D2.type === "AssignmentExpression" || D2.type === "SequenceExpression" && l && l.type === "ForStatement" && (l.init === D2 || l.update === D2) || g2 === "value" && D2.type === "Property" && l && l.type === "ObjectPattern" && l.properties.includes(D2) || D2.type === "NGChainedExpression");
              }
              case "ConditionalExpression":
                switch (D2.type) {
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "BinaryExpression":
                  case "LogicalExpression":
                  case "NGPipeExpression":
                  case "ExportDefaultDeclaration":
                  case "AwaitExpression":
                  case "JSXSpreadAttribute":
                  case "TSTypeAssertion":
                  case "TypeCastExpression":
                  case "TSAsExpression":
                  case "TSNonNullExpression":
                    return true;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return g2 === "callee";
                  case "ConditionalExpression":
                    return g2 === "test";
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return g2 === "object";
                  default:
                    return false;
                }
              case "FunctionExpression":
                switch (D2.type) {
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return g2 === "callee";
                  case "TaggedTemplateExpression":
                    return true;
                  default:
                    return false;
                }
              case "ArrowFunctionExpression":
                switch (D2.type) {
                  case "BinaryExpression":
                    return D2.operator !== "|>" || F.extra && F.extra.parenthesized;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return g2 === "callee";
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return g2 === "object";
                  case "TSAsExpression":
                  case "TSNonNullExpression":
                  case "BindExpression":
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "LogicalExpression":
                  case "AwaitExpression":
                  case "TSTypeAssertion":
                    return true;
                  case "ConditionalExpression":
                    return g2 === "test";
                  default:
                    return false;
                }
              case "ClassExpression":
                if (s2(F.decorators))
                  return true;
                switch (D2.type) {
                  case "NewExpression":
                    return g2 === "callee";
                  default:
                    return false;
                }
              case "OptionalMemberExpression":
              case "OptionalCallExpression": {
                let l = P.getParentNode(1);
                if (g2 === "object" && D2.type === "MemberExpression" || g2 === "callee" && (D2.type === "CallExpression" || D2.type === "NewExpression") || D2.type === "TSNonNullExpression" && l.type === "MemberExpression" && l.object === D2)
                  return true;
              }
              case "CallExpression":
              case "MemberExpression":
              case "TaggedTemplateExpression":
              case "TSNonNullExpression":
                if (g2 === "callee" && (D2.type === "BindExpression" || D2.type === "NewExpression")) {
                  let l = F;
                  for (; l; )
                    switch (l.type) {
                      case "CallExpression":
                      case "OptionalCallExpression":
                        return true;
                      case "MemberExpression":
                      case "OptionalMemberExpression":
                      case "BindExpression":
                        l = l.object;
                        break;
                      case "TaggedTemplateExpression":
                        l = l.tag;
                        break;
                      case "TSNonNullExpression":
                        l = l.expression;
                        break;
                      default:
                        return false;
                    }
                }
                return false;
              case "BindExpression":
                return g2 === "callee" && (D2.type === "BindExpression" || D2.type === "NewExpression") || g2 === "object" && f(D2);
              case "NGPipeExpression":
                return !(D2.type === "NGRoot" || D2.type === "NGMicrosyntaxExpression" || D2.type === "ObjectProperty" && !(F.extra && F.extra.parenthesized) || D2.type === "ArrayExpression" || p(D2) && D2.arguments[g2] === F || g2 === "right" && D2.type === "NGPipeExpression" || g2 === "property" && D2.type === "MemberExpression" || D2.type === "AssignmentExpression");
              case "JSXFragment":
              case "JSXElement":
                return g2 === "callee" || g2 === "left" && D2.type === "BinaryExpression" && D2.operator === "<" || D2.type !== "ArrayExpression" && D2.type !== "ArrowFunctionExpression" && D2.type !== "AssignmentExpression" && D2.type !== "AssignmentPattern" && D2.type !== "BinaryExpression" && D2.type !== "NewExpression" && D2.type !== "ConditionalExpression" && D2.type !== "ExpressionStatement" && D2.type !== "JsExpressionRoot" && D2.type !== "JSXAttribute" && D2.type !== "JSXElement" && D2.type !== "JSXExpressionContainer" && D2.type !== "JSXFragment" && D2.type !== "LogicalExpression" && !p(D2) && !h2(D2) && D2.type !== "ReturnStatement" && D2.type !== "ThrowStatement" && D2.type !== "TypeCastExpression" && D2.type !== "VariableDeclarator" && D2.type !== "YieldExpression";
              case "TypeAnnotation":
                return g2 === "returnType" && D2.type === "ArrowFunctionExpression" && S2(F);
            }
            return false;
          }
          function T2(P) {
            return P.type === "BlockStatement" || P.type === "BreakStatement" || P.type === "ClassBody" || P.type === "ClassDeclaration" || P.type === "ClassMethod" || P.type === "ClassProperty" || P.type === "PropertyDefinition" || P.type === "ClassPrivateProperty" || P.type === "ContinueStatement" || P.type === "DebuggerStatement" || P.type === "DeclareClass" || P.type === "DeclareExportAllDeclaration" || P.type === "DeclareExportDeclaration" || P.type === "DeclareFunction" || P.type === "DeclareInterface" || P.type === "DeclareModule" || P.type === "DeclareModuleExports" || P.type === "DeclareVariable" || P.type === "DoWhileStatement" || P.type === "EnumDeclaration" || P.type === "ExportAllDeclaration" || P.type === "ExportDefaultDeclaration" || P.type === "ExportNamedDeclaration" || P.type === "ExpressionStatement" || P.type === "ForInStatement" || P.type === "ForOfStatement" || P.type === "ForStatement" || P.type === "FunctionDeclaration" || P.type === "IfStatement" || P.type === "ImportDeclaration" || P.type === "InterfaceDeclaration" || P.type === "LabeledStatement" || P.type === "MethodDefinition" || P.type === "ReturnStatement" || P.type === "SwitchStatement" || P.type === "ThrowStatement" || P.type === "TryStatement" || P.type === "TSDeclareFunction" || P.type === "TSEnumDeclaration" || P.type === "TSImportEqualsDeclaration" || P.type === "TSInterfaceDeclaration" || P.type === "TSModuleDeclaration" || P.type === "TSNamespaceExportDeclaration" || P.type === "TypeAlias" || P.type === "VariableDeclaration" || P.type === "WhileStatement" || P.type === "WithStatement";
          }
          function A2(P) {
            let C2 = 0, D2 = P.getValue();
            for (; D2; ) {
              let g2 = P.getParentNode(C2++);
              if (g2 && g2.type === "ForStatement" && g2.init === D2)
                return true;
              D2 = g2;
            }
            return false;
          }
          function S2(P) {
            return o(P, (C2) => C2.type === "ObjectTypeAnnotation" && o(C2, (D2) => D2.type === "FunctionTypeAnnotation" || void 0) || void 0);
          }
          function B(P) {
            switch (P.type) {
              case "ObjectExpression":
                return true;
              default:
                return false;
            }
          }
          function I2(P) {
            let C2 = P.getValue(), D2 = P.getParentNode(), g2 = P.getName();
            switch (D2.type) {
              case "NGPipeExpression":
                if (typeof g2 == "number" && D2.arguments[g2] === C2 && D2.arguments.length - 1 === g2)
                  return P.callParent(I2);
                break;
              case "ObjectProperty":
                if (g2 === "value") {
                  let F = P.getParentNode(1);
                  return t(F.properties) === D2;
                }
                break;
              case "BinaryExpression":
              case "LogicalExpression":
                if (g2 === "right")
                  return P.callParent(I2);
                break;
              case "ConditionalExpression":
                if (g2 === "alternate")
                  return P.callParent(I2);
                break;
              case "UnaryExpression":
                if (D2.prefix)
                  return P.callParent(I2);
                break;
            }
            return false;
          }
          function k2(P, C2) {
            let D2 = P.getValue(), g2 = P.getParentNode();
            return D2.type === "FunctionExpression" || D2.type === "ClassExpression" ? g2.type === "ExportDefaultDeclaration" || !w2(P, C2) : !i2(D2) || g2.type !== "ExportDefaultDeclaration" && w2(P, C2) ? false : P.call((F) => k2(F, C2), ...r(P, D2));
          }
          n.exports = w2;
        } }), so2 = Z3({ "src/language-js/print-preprocess.js"(e, n) {
          re2();
          function t(s2, a3) {
            switch (a3.parser) {
              case "json":
              case "json5":
              case "json-stringify":
              case "__js_expression":
              case "__vue_expression":
              case "__vue_ts_expression":
                return Object.assign(Object.assign({}, s2), {}, { type: a3.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: s2, comments: [], rootMarker: a3.rootMarker });
              default:
                return s2;
            }
          }
          n.exports = t;
        } }), $m2 = Z3({ "src/language-js/print/html-binding.js"(e, n) {
          re2();
          var { builders: { join: t, line: s2, group: a3, softline: r, indent: u } } = Oe2();
          function i2(c, v, m2) {
            let d4 = c.getValue();
            if (v.__onHtmlBindingRoot && c.getName() === null && v.__onHtmlBindingRoot(d4, v), d4.type === "File") {
              if (v.__isVueForBindingLeft)
                return c.call((p) => {
                  let f = t([",", s2], p.map(m2, "params")), { params: h2 } = p.getValue();
                  return h2.length === 1 ? f : ["(", u([r, a3(f)]), r, ")"];
                }, "program", "body", 0);
              if (v.__isVueBindings)
                return c.call((p) => t([",", s2], p.map(m2, "params")), "program", "body", 0);
            }
          }
          function o(c) {
            switch (c.type) {
              case "MemberExpression":
                switch (c.property.type) {
                  case "Identifier":
                  case "NumericLiteral":
                  case "StringLiteral":
                    return o(c.object);
                }
                return false;
              case "Identifier":
                return true;
              default:
                return false;
            }
          }
          n.exports = { isVueEventBindingExpression: o, printHtmlBinding: i2 };
        } }), Jn2 = Z3({ "src/language-js/print/binaryish.js"(e, n) {
          re2();
          var { printComments: t } = et2(), { getLast: s2 } = Ue2(), { builders: { join: a3, line: r, softline: u, group: i2, indent: o, align: c, ifBreak: v, indentIfBreak: m2 }, utils: { cleanDoc: d4, getDocParts: p, isConcat: f } } = Oe2(), { hasLeadingOwnLineComment: h2, isBinaryish: w2, isJsxNode: T2, shouldFlatten: A2, hasComment: S2, CommentCheckFlags: B, isCallExpression: I2, isMemberExpression: k2, isObjectProperty: P, isEnabledHackPipeline: C2 } = Ke2(), D2 = 0;
          function g2(E, y, N) {
            let x2 = E.getValue(), b2 = E.getParentNode(), L = E.getParentNode(1), M2 = x2 !== b2.body && (b2.type === "IfStatement" || b2.type === "WhileStatement" || b2.type === "SwitchStatement" || b2.type === "DoWhileStatement"), j = C2(y) && x2.operator === "|>", $ = F(E, N, y, false, M2);
            if (M2)
              return $;
            if (j)
              return i2($);
            if (I2(b2) && b2.callee === x2 || b2.type === "UnaryExpression" || k2(b2) && !b2.computed)
              return i2([o([u, ...$]), u]);
            let V = b2.type === "ReturnStatement" || b2.type === "ThrowStatement" || b2.type === "JSXExpressionContainer" && L.type === "JSXAttribute" || x2.operator !== "|" && b2.type === "JsExpressionRoot" || x2.type !== "NGPipeExpression" && (b2.type === "NGRoot" && y.parser === "__ng_binding" || b2.type === "NGMicrosyntaxExpression" && L.type === "NGMicrosyntax" && L.body.length === 1) || x2 === b2.body && b2.type === "ArrowFunctionExpression" || x2 !== b2.body && b2.type === "ForStatement" || b2.type === "ConditionalExpression" && L.type !== "ReturnStatement" && L.type !== "ThrowStatement" && !I2(L) || b2.type === "TemplateLiteral", q = b2.type === "AssignmentExpression" || b2.type === "VariableDeclarator" || b2.type === "ClassProperty" || b2.type === "PropertyDefinition" || b2.type === "TSAbstractPropertyDefinition" || b2.type === "ClassPrivateProperty" || P(b2), Y3 = w2(x2.left) && A2(x2.operator, x2.left.operator);
            if (V || l(x2) && !Y3 || !l(x2) && q)
              return i2($);
            if ($.length === 0)
              return "";
            let H3 = T2(x2.right), R = $.findIndex((X3) => typeof X3 != "string" && !Array.isArray(X3) && X3.type === "group"), Q = $.slice(0, R === -1 ? 1 : R + 1), ee2 = $.slice(Q.length, H3 ? -1 : void 0), te2 = Symbol("logicalChain-" + ++D2), oe2 = i2([...Q, o(ee2)], { id: te2 });
            if (!H3)
              return oe2;
            let W2 = s2($);
            return i2([oe2, m2(W2, { groupId: te2 })]);
          }
          function F(E, y, N, x2, b2) {
            let L = E.getValue();
            if (!w2(L))
              return [i2(y())];
            let M2 = [];
            A2(L.operator, L.left.operator) ? M2 = E.call((ee2) => F(ee2, y, N, true, b2), "left") : M2.push(i2(y("left")));
            let j = l(L), $ = (L.operator === "|>" || L.type === "NGPipeExpression" || L.operator === "|" && N.parser === "__vue_expression") && !h2(N.originalText, L.right), V = L.type === "NGPipeExpression" ? "|" : L.operator, q = L.type === "NGPipeExpression" && L.arguments.length > 0 ? i2(o([u, ": ", a3([u, ":", v(" ")], E.map(y, "arguments").map((ee2) => c(2, i2(ee2))))])) : "", Y3;
            if (j)
              Y3 = [V, " ", y("right"), q];
            else {
              let te2 = C2(N) && V === "|>" ? E.call((oe2) => F(oe2, y, N, true, b2), "right") : y("right");
              Y3 = [$ ? r : "", V, $ ? " " : r, te2, q];
            }
            let H3 = E.getParentNode(), R = S2(L.left, B.Trailing | B.Line), Q = R || !(b2 && L.type === "LogicalExpression") && H3.type !== L.type && L.left.type !== L.type && L.right.type !== L.type;
            if (M2.push($ ? "" : " ", Q ? i2(Y3, { shouldBreak: R }) : Y3), x2 && S2(L)) {
              let ee2 = d4(t(E, M2, N));
              return f(ee2) || ee2.type === "fill" ? p(ee2) : [ee2];
            }
            return M2;
          }
          function l(E) {
            return E.type !== "LogicalExpression" ? false : !!(E.right.type === "ObjectExpression" && E.right.properties.length > 0 || E.right.type === "ArrayExpression" && E.right.elements.length > 0 || T2(E.right));
          }
          n.exports = { printBinaryishExpression: g2, shouldInlineLogicalExpression: l };
        } }), Hm2 = Z3({ "src/language-js/print/angular.js"(e, n) {
          re2();
          var { builders: { join: t, line: s2, group: a3 } } = Oe2(), { hasNode: r, hasComment: u, getComments: i2 } = Ke2(), { printBinaryishExpression: o } = Jn2();
          function c(d4, p, f) {
            let h2 = d4.getValue();
            if (!!h2.type.startsWith("NG"))
              switch (h2.type) {
                case "NGRoot":
                  return [f("node"), u(h2.node) ? " //" + i2(h2.node)[0].value.trimEnd() : ""];
                case "NGPipeExpression":
                  return o(d4, p, f);
                case "NGChainedExpression":
                  return a3(t([";", s2], d4.map((w2) => m2(w2) ? f() : ["(", f(), ")"], "expressions")));
                case "NGEmptyExpression":
                  return "";
                case "NGQuotedExpression":
                  return [h2.prefix, ": ", h2.value.trim()];
                case "NGMicrosyntax":
                  return d4.map((w2, T2) => [T2 === 0 ? "" : v(w2.getValue(), T2, h2) ? " " : [";", s2], f()], "body");
                case "NGMicrosyntaxKey":
                  return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(h2.name) ? h2.name : JSON.stringify(h2.name);
                case "NGMicrosyntaxExpression":
                  return [f("expression"), h2.alias === null ? "" : [" as ", f("alias")]];
                case "NGMicrosyntaxKeyedExpression": {
                  let w2 = d4.getName(), T2 = d4.getParentNode(), A2 = v(h2, w2, T2) || (w2 === 1 && (h2.key.name === "then" || h2.key.name === "else") || w2 === 2 && h2.key.name === "else" && T2.body[w2 - 1].type === "NGMicrosyntaxKeyedExpression" && T2.body[w2 - 1].key.name === "then") && T2.body[0].type === "NGMicrosyntaxExpression";
                  return [f("key"), A2 ? " " : ": ", f("expression")];
                }
                case "NGMicrosyntaxLet":
                  return ["let ", f("key"), h2.value === null ? "" : [" = ", f("value")]];
                case "NGMicrosyntaxAs":
                  return [f("key"), " as ", f("alias")];
                default:
                  throw new Error("Unknown Angular node type: ".concat(JSON.stringify(h2.type), "."));
              }
          }
          function v(d4, p, f) {
            return d4.type === "NGMicrosyntaxKeyedExpression" && d4.key.name === "of" && p === 1 && f.body[0].type === "NGMicrosyntaxLet" && f.body[0].value === null;
          }
          function m2(d4) {
            return r(d4.getValue(), (p) => {
              switch (p.type) {
                case void 0:
                  return false;
                case "CallExpression":
                case "OptionalCallExpression":
                case "AssignmentExpression":
                  return true;
              }
            });
          }
          n.exports = { printAngular: c };
        } }), Gm2 = Z3({ "src/language-js/print/jsx.js"(e, n) {
          re2();
          var { printComments: t, printDanglingComments: s2 } = et2(), { builders: { line: a3, hardline: r, softline: u, group: i2, indent: o, conditionalGroup: c, fill: v, ifBreak: m2, lineSuffixBoundary: d4, join: p }, utils: { willBreak: f } } = Oe2(), { getLast: h2, getPreferredQuote: w2 } = Ue2(), { isJsxNode: T2, rawText: A2, isLiteral: S2, isCallExpression: B, isStringLiteral: I2, isBinaryish: k2, hasComment: P, CommentCheckFlags: C2, hasNodeIgnoreComment: D2 } = Ke2(), g2 = jt2(), { willPrintOwnComments: F } = uo2(), l = (ie) => ie === "" || ie === a3 || ie === r || ie === u;
          function E(ie, G, z) {
            let U = ie.getValue();
            if (U.type === "JSXElement" && W2(U))
              return [z("openingElement"), z("closingElement")];
            let le2 = U.type === "JSXElement" ? z("openingElement") : z("openingFragment"), ge2 = U.type === "JSXElement" ? z("closingElement") : z("closingFragment");
            if (U.children.length === 1 && U.children[0].type === "JSXExpressionContainer" && (U.children[0].expression.type === "TemplateLiteral" || U.children[0].expression.type === "TaggedTemplateExpression"))
              return [le2, ...ie.map(z, "children"), ge2];
            U.children = U.children.map((Fe2) => ue2(Fe2) ? { type: "JSXText", value: " ", raw: " " } : Fe2);
            let Ae2 = U.children.some(T2), Ne2 = U.children.filter((Fe2) => Fe2.type === "JSXExpressionContainer").length > 1, ke2 = U.type === "JSXElement" && U.openingElement.attributes.length > 1, ce = f(le2) || Ae2 || ke2 || Ne2, pe = ie.getParentNode().rootMarker === "mdx", de2 = G.singleQuote ? "{' '}" : '{" "}', ae2 = pe ? " " : m2([de2, u], " "), ve2 = U.openingElement && U.openingElement.name && U.openingElement.name.name === "fbt", K = y(ie, G, z, ae2, ve2), he2 = U.children.some((Fe2) => X3(Fe2));
            for (let Fe2 = K.length - 2; Fe2 >= 0; Fe2--) {
              let me2 = K[Fe2] === "" && K[Fe2 + 1] === "", _ = K[Fe2] === r && K[Fe2 + 1] === "" && K[Fe2 + 2] === r, J2 = (K[Fe2] === u || K[Fe2] === r) && K[Fe2 + 1] === "" && K[Fe2 + 2] === ae2, ne = K[Fe2] === ae2 && K[Fe2 + 1] === "" && (K[Fe2 + 2] === u || K[Fe2 + 2] === r), Ee = K[Fe2] === ae2 && K[Fe2 + 1] === "" && K[Fe2 + 2] === ae2, We2 = K[Fe2] === u && K[Fe2 + 1] === "" && K[Fe2 + 2] === r || K[Fe2] === r && K[Fe2 + 1] === "" && K[Fe2 + 2] === u;
              _ && he2 || me2 || J2 || Ee || We2 ? K.splice(Fe2, 2) : ne && K.splice(Fe2 + 1, 2);
            }
            for (; K.length > 0 && l(h2(K)); )
              K.pop();
            for (; K.length > 1 && l(K[0]) && l(K[1]); )
              K.shift(), K.shift();
            let ye2 = [];
            for (let [Fe2, me2] of K.entries()) {
              if (me2 === ae2) {
                if (Fe2 === 1 && K[Fe2 - 1] === "") {
                  if (K.length === 2) {
                    ye2.push(de2);
                    continue;
                  }
                  ye2.push([de2, r]);
                  continue;
                } else if (Fe2 === K.length - 1) {
                  ye2.push(de2);
                  continue;
                } else if (K[Fe2 - 1] === "" && K[Fe2 - 2] === r) {
                  ye2.push(de2);
                  continue;
                }
              }
              ye2.push(me2), f(me2) && (ce = true);
            }
            let Ce2 = he2 ? v(ye2) : i2(ye2, { shouldBreak: true });
            if (pe)
              return Ce2;
            let Ie2 = i2([le2, o([r, Ce2]), r, ge2]);
            return ce ? Ie2 : c([i2([le2, ...K, ge2]), Ie2]);
          }
          function y(ie, G, z, U, le2) {
            let ge2 = [];
            return ie.each((Ae2, Ne2, ke2) => {
              let ce = Ae2.getValue();
              if (S2(ce)) {
                let pe = A2(ce);
                if (X3(ce)) {
                  let de2 = pe.split(ee2);
                  if (de2[0] === "") {
                    if (ge2.push(""), de2.shift(), /\n/.test(de2[0])) {
                      let ve2 = ke2[Ne2 + 1];
                      ge2.push(x2(le2, de2[1], ce, ve2));
                    } else
                      ge2.push(U);
                    de2.shift();
                  }
                  let ae2;
                  if (h2(de2) === "" && (de2.pop(), ae2 = de2.pop()), de2.length === 0)
                    return;
                  for (let [ve2, K] of de2.entries())
                    ve2 % 2 === 1 ? ge2.push(a3) : ge2.push(K);
                  if (ae2 !== void 0)
                    if (/\n/.test(ae2)) {
                      let ve2 = ke2[Ne2 + 1];
                      ge2.push(x2(le2, h2(ge2), ce, ve2));
                    } else
                      ge2.push(U);
                  else {
                    let ve2 = ke2[Ne2 + 1];
                    ge2.push(N(le2, h2(ge2), ce, ve2));
                  }
                } else
                  /\n/.test(pe) ? pe.match(/\n/g).length > 1 && ge2.push("", r) : ge2.push("", U);
              } else {
                let pe = z();
                ge2.push(pe);
                let de2 = ke2[Ne2 + 1];
                if (de2 && X3(de2)) {
                  let ve2 = oe2(A2(de2)).split(ee2)[0];
                  ge2.push(N(le2, ve2, ce, de2));
                } else
                  ge2.push(r);
              }
            }, "children"), ge2;
          }
          function N(ie, G, z, U) {
            return ie ? "" : z.type === "JSXElement" && !z.closingElement || U && U.type === "JSXElement" && !U.closingElement ? G.length === 1 ? u : r : u;
          }
          function x2(ie, G, z, U) {
            return ie ? r : G.length === 1 ? z.type === "JSXElement" && !z.closingElement || U && U.type === "JSXElement" && !U.closingElement ? r : u : r;
          }
          function b2(ie, G, z) {
            let U = ie.getParentNode();
            if (!U || { ArrayExpression: true, JSXAttribute: true, JSXElement: true, JSXExpressionContainer: true, JSXFragment: true, ExpressionStatement: true, CallExpression: true, OptionalCallExpression: true, ConditionalExpression: true, JsExpressionRoot: true }[U.type])
              return G;
            let ge2 = ie.match(void 0, (Ne2) => Ne2.type === "ArrowFunctionExpression", B, (Ne2) => Ne2.type === "JSXExpressionContainer"), Ae2 = g2(ie, z);
            return i2([Ae2 ? "" : m2("("), o([u, G]), u, Ae2 ? "" : m2(")")], { shouldBreak: ge2 });
          }
          function L(ie, G, z) {
            let U = ie.getValue(), le2 = [];
            if (le2.push(z("name")), U.value) {
              let ge2;
              if (I2(U.value)) {
                let Ne2 = A2(U.value).slice(1, -1).replace(/&apos;/g, "'").replace(/&quot;/g, '"'), { escaped: ke2, quote: ce, regex: pe } = w2(Ne2, G.jsxSingleQuote ? "'" : '"');
                Ne2 = Ne2.replace(pe, ke2), ge2 = [ce, Ne2, ce];
              } else
                ge2 = z("value");
              le2.push("=", ge2);
            }
            return le2;
          }
          function M2(ie, G, z) {
            let U = ie.getValue(), le2 = (ge2, Ae2) => ge2.type === "JSXEmptyExpression" || !P(ge2) && (ge2.type === "ArrayExpression" || ge2.type === "ObjectExpression" || ge2.type === "ArrowFunctionExpression" || ge2.type === "AwaitExpression" && (le2(ge2.argument, ge2) || ge2.argument.type === "JSXElement") || B(ge2) || ge2.type === "FunctionExpression" || ge2.type === "TemplateLiteral" || ge2.type === "TaggedTemplateExpression" || ge2.type === "DoExpression" || T2(Ae2) && (ge2.type === "ConditionalExpression" || k2(ge2)));
            return le2(U.expression, ie.getParentNode(0)) ? i2(["{", z("expression"), d4, "}"]) : i2(["{", o([u, z("expression")]), u, d4, "}"]);
          }
          function j(ie, G, z) {
            let U = ie.getValue(), le2 = U.name && P(U.name) || U.typeParameters && P(U.typeParameters);
            if (U.selfClosing && U.attributes.length === 0 && !le2)
              return ["<", z("name"), z("typeParameters"), " />"];
            if (U.attributes && U.attributes.length === 1 && U.attributes[0].value && I2(U.attributes[0].value) && !U.attributes[0].value.value.includes(`
`) && !le2 && !P(U.attributes[0]))
              return i2(["<", z("name"), z("typeParameters"), " ", ...ie.map(z, "attributes"), U.selfClosing ? " />" : ">"]);
            let ge2 = U.attributes.length > 0 && P(h2(U.attributes), C2.Trailing), Ae2 = U.attributes.length === 0 && !le2 || (G.bracketSameLine || G.jsxBracketSameLine) && (!le2 || U.attributes.length > 0) && !ge2, Ne2 = U.attributes && U.attributes.some((ce) => ce.value && I2(ce.value) && ce.value.value.includes(`
`)), ke2 = G.singleAttributePerLine && U.attributes.length > 1 ? r : a3;
            return i2(["<", z("name"), z("typeParameters"), o(ie.map(() => [ke2, z()], "attributes")), U.selfClosing ? a3 : Ae2 ? ">" : u, U.selfClosing ? "/>" : Ae2 ? "" : ">"], { shouldBreak: Ne2 });
          }
          function $(ie, G, z) {
            let U = ie.getValue(), le2 = [];
            le2.push("</");
            let ge2 = z("name");
            return P(U.name, C2.Leading | C2.Line) ? le2.push(o([r, ge2]), r) : P(U.name, C2.Leading | C2.Block) ? le2.push(" ", ge2) : le2.push(ge2), le2.push(">"), le2;
          }
          function V(ie, G) {
            let z = ie.getValue(), U = P(z), le2 = P(z, C2.Line), ge2 = z.type === "JSXOpeningFragment";
            return [ge2 ? "<" : "</", o([le2 ? r : U && !ge2 ? " " : "", s2(ie, G, true)]), le2 ? r : "", ">"];
          }
          function q(ie, G, z) {
            let U = t(ie, E(ie, G, z), G);
            return b2(ie, U, G);
          }
          function Y3(ie, G) {
            let z = ie.getValue(), U = P(z, C2.Line);
            return [s2(ie, G, !U), U ? r : ""];
          }
          function H3(ie, G, z) {
            let U = ie.getValue();
            return ["{", ie.call((le2) => {
              let ge2 = ["...", z()], Ae2 = le2.getValue();
              return !P(Ae2) || !F(le2) ? ge2 : [o([u, t(le2, ge2, G)]), u];
            }, U.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
          }
          function R(ie, G, z) {
            let U = ie.getValue();
            if (!!U.type.startsWith("JSX"))
              switch (U.type) {
                case "JSXAttribute":
                  return L(ie, G, z);
                case "JSXIdentifier":
                  return String(U.name);
                case "JSXNamespacedName":
                  return p(":", [z("namespace"), z("name")]);
                case "JSXMemberExpression":
                  return p(".", [z("object"), z("property")]);
                case "JSXSpreadAttribute":
                  return H3(ie, G, z);
                case "JSXSpreadChild":
                  return H3(ie, G, z);
                case "JSXExpressionContainer":
                  return M2(ie, G, z);
                case "JSXFragment":
                case "JSXElement":
                  return q(ie, G, z);
                case "JSXOpeningElement":
                  return j(ie, G, z);
                case "JSXClosingElement":
                  return $(ie, G, z);
                case "JSXOpeningFragment":
                case "JSXClosingFragment":
                  return V(ie, G);
                case "JSXEmptyExpression":
                  return Y3(ie, G);
                case "JSXText":
                  throw new Error("JSXTest should be handled by JSXElement");
                default:
                  throw new Error("Unknown JSX node type: ".concat(JSON.stringify(U.type), "."));
              }
          }
          var Q = ` 
\r	`, ee2 = new RegExp("([" + Q + "]+)"), te2 = new RegExp("[^" + Q + "]"), oe2 = (ie) => ie.replace(new RegExp("(?:^" + ee2.source + "|" + ee2.source + "$)"), "");
          function W2(ie) {
            if (ie.children.length === 0)
              return true;
            if (ie.children.length > 1)
              return false;
            let G = ie.children[0];
            return S2(G) && !X3(G);
          }
          function X3(ie) {
            return S2(ie) && (te2.test(A2(ie)) || !/\n/.test(A2(ie)));
          }
          function ue2(ie) {
            return ie.type === "JSXExpressionContainer" && S2(ie.expression) && ie.expression.value === " " && !P(ie.expression);
          }
          function De2(ie) {
            let G = ie.getValue(), z = ie.getParentNode();
            if (!z || !G || !T2(G) || !T2(z))
              return false;
            let U = z.children.indexOf(G), le2 = null;
            for (let ge2 = U; ge2 > 0; ge2--) {
              let Ae2 = z.children[ge2 - 1];
              if (!(Ae2.type === "JSXText" && !X3(Ae2))) {
                le2 = Ae2;
                break;
              }
            }
            return le2 && le2.type === "JSXExpressionContainer" && le2.expression.type === "JSXEmptyExpression" && D2(le2.expression);
          }
          n.exports = { hasJsxIgnoreComment: De2, printJsx: R };
        } }), ct2 = Z3({ "src/language-js/print/misc.js"(e, n) {
          re2();
          var { isNonEmptyArray: t } = Ue2(), { builders: { indent: s2, join: a3, line: r } } = Oe2(), { isFlowAnnotationComment: u } = Ke2();
          function i2(h2) {
            let w2 = h2.getValue();
            return !w2.optional || w2.type === "Identifier" && w2 === h2.getParentNode().key ? "" : w2.type === "OptionalCallExpression" || w2.type === "OptionalMemberExpression" && w2.computed ? "?." : "?";
          }
          function o(h2) {
            return h2.getValue().definite || h2.match(void 0, (w2, T2) => T2 === "id" && w2.type === "VariableDeclarator" && w2.definite) ? "!" : "";
          }
          function c(h2, w2, T2) {
            let A2 = h2.getValue();
            return A2.typeArguments ? T2("typeArguments") : A2.typeParameters ? T2("typeParameters") : "";
          }
          function v(h2, w2, T2) {
            let A2 = h2.getValue();
            if (!A2.typeAnnotation)
              return "";
            let S2 = h2.getParentNode(), B = S2.type === "DeclareFunction" && S2.id === A2;
            return u(w2.originalText, A2.typeAnnotation) ? [" /*: ", T2("typeAnnotation"), " */"] : [B ? "" : ": ", T2("typeAnnotation")];
          }
          function m2(h2, w2, T2) {
            return ["::", T2("callee")];
          }
          function d4(h2, w2, T2) {
            let A2 = h2.getValue();
            return t(A2.modifiers) ? [a3(" ", h2.map(T2, "modifiers")), " "] : "";
          }
          function p(h2, w2, T2) {
            return h2.type === "EmptyStatement" ? ";" : h2.type === "BlockStatement" || T2 ? [" ", w2] : s2([r, w2]);
          }
          function f(h2, w2, T2) {
            return ["...", T2("argument"), v(h2, w2, T2)];
          }
          n.exports = { printOptionalToken: i2, printDefiniteToken: o, printFunctionTypeParameters: c, printBindExpressionCallee: m2, printTypeScriptModifiers: d4, printTypeAnnotation: v, printRestSpread: f, adjustClause: p };
        } }), Kt2 = Z3({ "src/language-js/print/array.js"(e, n) {
          re2();
          var { printDanglingComments: t } = et2(), { builders: { line: s2, softline: a3, hardline: r, group: u, indent: i2, ifBreak: o, fill: c } } = Oe2(), { getLast: v, hasNewline: m2 } = Ue2(), { shouldPrintComma: d4, hasComment: p, CommentCheckFlags: f, isNextLineEmpty: h2, isNumericLiteral: w2, isSignedNumericLiteral: T2 } = Ke2(), { locStart: A2 } = st2(), { printOptionalToken: S2, printTypeAnnotation: B } = ct2();
          function I2(D2, g2, F) {
            let l = D2.getValue(), E = [], y = l.type === "TupleExpression" ? "#[" : "[", N = "]";
            if (l.elements.length === 0)
              p(l, f.Dangling) ? E.push(u([y, t(D2, g2), a3, N])) : E.push(y, N);
            else {
              let x2 = v(l.elements), b2 = !(x2 && x2.type === "RestElement"), L = x2 === null, M2 = Symbol("array"), j = !g2.__inJestEach && l.elements.length > 1 && l.elements.every((q, Y3, H3) => {
                let R = q && q.type;
                if (R !== "ArrayExpression" && R !== "ObjectExpression")
                  return false;
                let Q = H3[Y3 + 1];
                if (Q && R !== Q.type)
                  return false;
                let ee2 = R === "ArrayExpression" ? "elements" : "properties";
                return q[ee2] && q[ee2].length > 1;
              }), $ = k2(l, g2), V = b2 ? L ? "," : d4(g2) ? $ ? o(",", "", { groupId: M2 }) : o(",") : "" : "";
              E.push(u([y, i2([a3, $ ? C2(D2, g2, F, V) : [P(D2, g2, "elements", F), V], t(D2, g2, true)]), a3, N], { shouldBreak: j, id: M2 }));
            }
            return E.push(S2(D2), B(D2, g2, F)), E;
          }
          function k2(D2, g2) {
            return D2.elements.length > 1 && D2.elements.every((F) => F && (w2(F) || T2(F) && !p(F.argument)) && !p(F, f.Trailing | f.Line, (l) => !m2(g2.originalText, A2(l), { backwards: true })));
          }
          function P(D2, g2, F, l) {
            let E = [], y = [];
            return D2.each((N) => {
              E.push(y, u(l())), y = [",", s2], N.getValue() && h2(N.getValue(), g2) && y.push(a3);
            }, F), E;
          }
          function C2(D2, g2, F, l) {
            let E = [];
            return D2.each((y, N, x2) => {
              let b2 = N === x2.length - 1;
              E.push([F(), b2 ? l : ","]), b2 || E.push(h2(y.getValue(), g2) ? [r, r] : p(x2[N + 1], f.Leading | f.Line) ? r : s2);
            }, "elements"), c(E);
          }
          n.exports = { printArray: I2, printArrayItems: P, isConciselyPrintedArray: k2 };
        } }), io2 = Z3({ "src/language-js/print/call-arguments.js"(e, n) {
          re2();
          var { printDanglingComments: t } = et2(), { getLast: s2, getPenultimate: a3 } = Ue2(), { getFunctionParameters: r, hasComment: u, CommentCheckFlags: i2, isFunctionCompositionArgs: o, isJsxNode: c, isLongCurriedCallExpression: v, shouldPrintComma: m2, getCallArguments: d4, iterateCallArgumentsPath: p, isNextLineEmpty: f, isCallExpression: h2, isStringLiteral: w2, isObjectProperty: T2 } = Ke2(), { builders: { line: A2, hardline: S2, softline: B, group: I2, indent: k2, conditionalGroup: P, ifBreak: C2, breakParent: D2 }, utils: { willBreak: g2 } } = Oe2(), { ArgExpansionBailout: F } = zt2(), { isConciselyPrintedArray: l } = Kt2();
          function E(j, $, V) {
            let q = j.getValue(), Y3 = q.type === "ImportExpression", H3 = d4(q);
            if (H3.length === 0)
              return ["(", t(j, $, true), ")"];
            if (b2(H3))
              return ["(", V(["arguments", 0]), ", ", V(["arguments", 1]), ")"];
            let R = false, Q = false, ee2 = H3.length - 1, te2 = [];
            p(j, (ie, G) => {
              let z = ie.getNode(), U = [V()];
              G === ee2 || (f(z, $) ? (G === 0 && (Q = true), R = true, U.push(",", S2, S2)) : U.push(",", A2)), te2.push(U);
            });
            let oe2 = !(Y3 || q.callee && q.callee.type === "Import") && m2($, "all") ? "," : "";
            function W2() {
              return I2(["(", k2([A2, ...te2]), oe2, A2, ")"], { shouldBreak: true });
            }
            if (R || j.getParentNode().type !== "Decorator" && o(H3))
              return W2();
            let X3 = x2(H3), ue2 = N(H3, $);
            if (X3 || ue2) {
              if (X3 ? te2.slice(1).some(g2) : te2.slice(0, -1).some(g2))
                return W2();
              let ie = [];
              try {
                j.try(() => {
                  p(j, (G, z) => {
                    X3 && z === 0 && (ie = [[V([], { expandFirstArg: true }), te2.length > 1 ? "," : "", Q ? S2 : A2, Q ? S2 : ""], ...te2.slice(1)]), ue2 && z === ee2 && (ie = [...te2.slice(0, -1), V([], { expandLastArg: true })]);
                  });
                });
              } catch (G) {
                if (G instanceof F)
                  return W2();
                throw G;
              }
              return [te2.some(g2) ? D2 : "", P([["(", ...ie, ")"], X3 ? ["(", I2(ie[0], { shouldBreak: true }), ...ie.slice(1), ")"] : ["(", ...te2.slice(0, -1), I2(s2(ie), { shouldBreak: true }), ")"], W2()])];
            }
            let De2 = ["(", k2([B, ...te2]), C2(oe2), B, ")"];
            return v(j) ? De2 : I2(De2, { shouldBreak: te2.some(g2) || R });
          }
          function y(j) {
            let $ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            return j.type === "ObjectExpression" && (j.properties.length > 0 || u(j)) || j.type === "ArrayExpression" && (j.elements.length > 0 || u(j)) || j.type === "TSTypeAssertion" && y(j.expression) || j.type === "TSAsExpression" && y(j.expression) || j.type === "FunctionExpression" || j.type === "ArrowFunctionExpression" && (!j.returnType || !j.returnType.typeAnnotation || j.returnType.typeAnnotation.type !== "TSTypeReference" || L(j.body)) && (j.body.type === "BlockStatement" || j.body.type === "ArrowFunctionExpression" && y(j.body, true) || j.body.type === "ObjectExpression" || j.body.type === "ArrayExpression" || !$ && (h2(j.body) || j.body.type === "ConditionalExpression") || c(j.body)) || j.type === "DoExpression" || j.type === "ModuleExpression";
          }
          function N(j, $) {
            let V = s2(j), q = a3(j);
            return !u(V, i2.Leading) && !u(V, i2.Trailing) && y(V) && (!q || q.type !== V.type) && (j.length !== 2 || q.type !== "ArrowFunctionExpression" || V.type !== "ArrayExpression") && !(j.length > 1 && V.type === "ArrayExpression" && l(V, $));
          }
          function x2(j) {
            if (j.length !== 2)
              return false;
            let [$, V] = j;
            return $.type === "ModuleExpression" && M2(V) ? true : !u($) && ($.type === "FunctionExpression" || $.type === "ArrowFunctionExpression" && $.body.type === "BlockStatement") && V.type !== "FunctionExpression" && V.type !== "ArrowFunctionExpression" && V.type !== "ConditionalExpression" && !y(V);
          }
          function b2(j) {
            return j.length === 2 && j[0].type === "ArrowFunctionExpression" && r(j[0]).length === 0 && j[0].body.type === "BlockStatement" && j[1].type === "ArrayExpression" && !j.some(($) => u($));
          }
          function L(j) {
            return j.type === "BlockStatement" && (j.body.some(($) => $.type !== "EmptyStatement") || u(j, i2.Dangling));
          }
          function M2(j) {
            return j.type === "ObjectExpression" && j.properties.length === 1 && T2(j.properties[0]) && j.properties[0].key.type === "Identifier" && j.properties[0].key.name === "type" && w2(j.properties[0].value) && j.properties[0].value.value === "module";
          }
          n.exports = E;
        } }), ao2 = Z3({ "src/language-js/print/member.js"(e, n) {
          re2();
          var { builders: { softline: t, group: s2, indent: a3, label: r } } = Oe2(), { isNumericLiteral: u, isMemberExpression: i2, isCallExpression: o } = Ke2(), { printOptionalToken: c } = ct2();
          function v(d4, p, f) {
            let h2 = d4.getValue(), w2 = d4.getParentNode(), T2, A2 = 0;
            do
              T2 = d4.getParentNode(A2), A2++;
            while (T2 && (i2(T2) || T2.type === "TSNonNullExpression"));
            let S2 = f("object"), B = m2(d4, p, f), I2 = T2 && (T2.type === "NewExpression" || T2.type === "BindExpression" || T2.type === "AssignmentExpression" && T2.left.type !== "Identifier") || h2.computed || h2.object.type === "Identifier" && h2.property.type === "Identifier" && !i2(w2) || (w2.type === "AssignmentExpression" || w2.type === "VariableDeclarator") && (o(h2.object) && h2.object.arguments.length > 0 || h2.object.type === "TSNonNullExpression" && o(h2.object.expression) && h2.object.expression.arguments.length > 0 || S2.label === "member-chain");
            return r(S2.label === "member-chain" ? "member-chain" : "member", [S2, I2 ? B : s2(a3([t, B]))]);
          }
          function m2(d4, p, f) {
            let h2 = f("property"), w2 = d4.getValue(), T2 = c(d4);
            return w2.computed ? !w2.property || u(w2.property) ? [T2, "[", h2, "]"] : s2([T2, "[", a3([t, h2]), t, "]"]) : [T2, ".", h2];
          }
          n.exports = { printMemberExpression: v, printMemberLookup: m2 };
        } }), Jm2 = Z3({ "src/language-js/print/member-chain.js"(e, n) {
          re2();
          var { printComments: t } = et2(), { getLast: s2, isNextLineEmptyAfterIndex: a3, getNextNonSpaceNonCommentCharacterIndex: r } = Ue2(), u = jt2(), { isCallExpression: i2, isMemberExpression: o, isFunctionOrArrowExpression: c, isLongCurriedCallExpression: v, isMemberish: m2, isNumericLiteral: d4, isSimpleCallArgument: p, hasComment: f, CommentCheckFlags: h2, isNextLineEmpty: w2 } = Ke2(), { locEnd: T2 } = st2(), { builders: { join: A2, hardline: S2, group: B, indent: I2, conditionalGroup: k2, breakParent: P, label: C2 }, utils: { willBreak: D2 } } = Oe2(), g2 = io2(), { printMemberLookup: F } = ao2(), { printOptionalToken: l, printFunctionTypeParameters: E, printBindExpressionCallee: y } = ct2();
          function N(x2, b2, L) {
            let M2 = x2.getParentNode(), j = !M2 || M2.type === "ExpressionStatement", $ = [];
            function V(de2) {
              let { originalText: ae2 } = b2, ve2 = r(ae2, de2, T2);
              return ae2.charAt(ve2) === ")" ? ve2 !== false && a3(ae2, ve2 + 1) : w2(de2, b2);
            }
            function q(de2) {
              let ae2 = de2.getValue();
              i2(ae2) && (m2(ae2.callee) || i2(ae2.callee)) ? ($.unshift({ node: ae2, printed: [t(de2, [l(de2), E(de2, b2, L), g2(de2, b2, L)], b2), V(ae2) ? S2 : ""] }), de2.call((ve2) => q(ve2), "callee")) : m2(ae2) ? ($.unshift({ node: ae2, needsParens: u(de2, b2), printed: t(de2, o(ae2) ? F(de2, b2, L) : y(de2, b2, L), b2) }), de2.call((ve2) => q(ve2), "object")) : ae2.type === "TSNonNullExpression" ? ($.unshift({ node: ae2, printed: t(de2, "!", b2) }), de2.call((ve2) => q(ve2), "expression")) : $.unshift({ node: ae2, printed: L() });
            }
            let Y3 = x2.getValue();
            $.unshift({ node: Y3, printed: [l(x2), E(x2, b2, L), g2(x2, b2, L)] }), Y3.callee && x2.call((de2) => q(de2), "callee");
            let H3 = [], R = [$[0]], Q = 1;
            for (; Q < $.length && ($[Q].node.type === "TSNonNullExpression" || i2($[Q].node) || o($[Q].node) && $[Q].node.computed && d4($[Q].node.property)); ++Q)
              R.push($[Q]);
            if (!i2($[0].node))
              for (; Q + 1 < $.length && (m2($[Q].node) && m2($[Q + 1].node)); ++Q)
                R.push($[Q]);
            H3.push(R), R = [];
            let ee2 = false;
            for (; Q < $.length; ++Q) {
              if (ee2 && m2($[Q].node)) {
                if ($[Q].node.computed && d4($[Q].node.property)) {
                  R.push($[Q]);
                  continue;
                }
                H3.push(R), R = [], ee2 = false;
              }
              (i2($[Q].node) || $[Q].node.type === "ImportExpression") && (ee2 = true), R.push($[Q]), f($[Q].node, h2.Trailing) && (H3.push(R), R = [], ee2 = false);
            }
            R.length > 0 && H3.push(R);
            function te2(de2) {
              return /^[A-Z]|^[$_]+$/.test(de2);
            }
            function oe2(de2) {
              return de2.length <= b2.tabWidth;
            }
            function W2(de2) {
              let ae2 = de2[1].length > 0 && de2[1][0].node.computed;
              if (de2[0].length === 1) {
                let K = de2[0][0].node;
                return K.type === "ThisExpression" || K.type === "Identifier" && (te2(K.name) || j && oe2(K.name) || ae2);
              }
              let ve2 = s2(de2[0]).node;
              return o(ve2) && ve2.property.type === "Identifier" && (te2(ve2.property.name) || ae2);
            }
            let X3 = H3.length >= 2 && !f(H3[1][0].node) && W2(H3);
            function ue2(de2) {
              let ae2 = de2.map((ve2) => ve2.printed);
              return de2.length > 0 && s2(de2).needsParens ? ["(", ...ae2, ")"] : ae2;
            }
            function De2(de2) {
              return de2.length === 0 ? "" : I2(B([S2, A2(S2, de2.map(ue2))]));
            }
            let ie = H3.map(ue2), G = ie, z = X3 ? 3 : 2, U = H3.flat(), le2 = U.slice(1, -1).some((de2) => f(de2.node, h2.Leading)) || U.slice(0, -1).some((de2) => f(de2.node, h2.Trailing)) || H3[z] && f(H3[z][0].node, h2.Leading);
            if (H3.length <= z && !le2)
              return v(x2) ? G : B(G);
            let ge2 = s2(H3[X3 ? 1 : 0]).node, Ae2 = !i2(ge2) && V(ge2), Ne2 = [ue2(H3[0]), X3 ? H3.slice(1, 2).map(ue2) : "", Ae2 ? S2 : "", De2(H3.slice(X3 ? 2 : 1))], ke2 = $.map((de2) => {
              let { node: ae2 } = de2;
              return ae2;
            }).filter(i2);
            function ce() {
              let de2 = s2(s2(H3)).node, ae2 = s2(ie);
              return i2(de2) && D2(ae2) && ke2.slice(0, -1).some((ve2) => ve2.arguments.some(c));
            }
            let pe;
            return le2 || ke2.length > 2 && ke2.some((de2) => !de2.arguments.every((ae2) => p(ae2, 0))) || ie.slice(0, -1).some(D2) || ce() ? pe = B(Ne2) : pe = [D2(G) || Ae2 ? P : "", k2([G, Ne2])], C2("member-chain", pe);
          }
          n.exports = N;
        } }), oo2 = Z3({ "src/language-js/print/call-expression.js"(e, n) {
          re2();
          var { builders: { join: t, group: s2 } } = Oe2(), a3 = jt2(), { getCallArguments: r, hasFlowAnnotationComment: u, isCallExpression: i2, isMemberish: o, isStringLiteral: c, isTemplateOnItsOwnLine: v, isTestCall: m2, iterateCallArgumentsPath: d4 } = Ke2(), p = Jm2(), f = io2(), { printOptionalToken: h2, printFunctionTypeParameters: w2 } = ct2();
          function T2(S2, B, I2) {
            let k2 = S2.getValue(), P = S2.getParentNode(), C2 = k2.type === "NewExpression", D2 = k2.type === "ImportExpression", g2 = h2(S2), F = r(k2);
            if (F.length > 0 && (!D2 && !C2 && A2(k2, P) || F.length === 1 && v(F[0], B.originalText) || !C2 && m2(k2, P))) {
              let y = [];
              return d4(S2, () => {
                y.push(I2());
              }), [C2 ? "new " : "", I2("callee"), g2, w2(S2, B, I2), "(", t(", ", y), ")"];
            }
            let l = (B.parser === "babel" || B.parser === "babel-flow") && k2.callee && k2.callee.type === "Identifier" && u(k2.callee.trailingComments);
            if (l && (k2.callee.trailingComments[0].printed = true), !D2 && !C2 && o(k2.callee) && !S2.call((y) => a3(y, B), "callee"))
              return p(S2, B, I2);
            let E = [C2 ? "new " : "", D2 ? "import" : I2("callee"), g2, l ? "/*:: ".concat(k2.callee.trailingComments[0].value.slice(2).trim(), " */") : "", w2(S2, B, I2), f(S2, B, I2)];
            return D2 || i2(k2.callee) ? s2(E) : E;
          }
          function A2(S2, B) {
            if (S2.callee.type !== "Identifier")
              return false;
            if (S2.callee.name === "require")
              return true;
            if (S2.callee.name === "define") {
              let I2 = r(S2);
              return B.type === "ExpressionStatement" && (I2.length === 1 || I2.length === 2 && I2[0].type === "ArrayExpression" || I2.length === 3 && c(I2[0]) && I2[1].type === "ArrayExpression");
            }
            return false;
          }
          n.exports = { printCallExpression: T2 };
        } }), Yt2 = Z3({ "src/language-js/print/assignment.js"(e, n) {
          re2();
          var { isNonEmptyArray: t, getStringWidth: s2 } = Ue2(), { builders: { line: a3, group: r, indent: u, indentIfBreak: i2, lineSuffixBoundary: o }, utils: { cleanDoc: c, willBreak: v, canBreak: m2 } } = Oe2(), { hasLeadingOwnLineComment: d4, isBinaryish: p, isStringLiteral: f, isLiteral: h2, isNumericLiteral: w2, isCallExpression: T2, isMemberExpression: A2, getCallArguments: S2, rawText: B, hasComment: I2, isSignedNumericLiteral: k2, isObjectProperty: P } = Ke2(), { shouldInlineLogicalExpression: C2 } = Jn2(), { printCallExpression: D2 } = oo2();
          function g2(W2, X3, ue2, De2, ie, G) {
            let z = E(W2, X3, ue2, De2, G), U = ue2(G, { assignmentLayout: z });
            switch (z) {
              case "break-after-operator":
                return r([r(De2), ie, r(u([a3, U]))]);
              case "never-break-after-operator":
                return r([r(De2), ie, " ", U]);
              case "fluid": {
                let le2 = Symbol("assignment");
                return r([r(De2), ie, r(u(a3), { id: le2 }), o, i2(U, { groupId: le2 })]);
              }
              case "break-lhs":
                return r([De2, ie, " ", r(U)]);
              case "chain":
                return [r(De2), ie, a3, U];
              case "chain-tail":
                return [r(De2), ie, u([a3, U])];
              case "chain-tail-arrow-chain":
                return [r(De2), ie, U];
              case "only-left":
                return De2;
            }
          }
          function F(W2, X3, ue2) {
            let De2 = W2.getValue();
            return g2(W2, X3, ue2, ue2("left"), [" ", De2.operator], "right");
          }
          function l(W2, X3, ue2) {
            return g2(W2, X3, ue2, ue2("id"), " =", "init");
          }
          function E(W2, X3, ue2, De2, ie) {
            let G = W2.getValue(), z = G[ie];
            if (!z)
              return "only-left";
            let U = !x2(z);
            if (W2.match(x2, b2, (Ne2) => !U || Ne2.type !== "ExpressionStatement" && Ne2.type !== "VariableDeclaration"))
              return U ? z.type === "ArrowFunctionExpression" && z.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
            if (!U && x2(z.right) || d4(X3.originalText, z))
              return "break-after-operator";
            if (z.type === "CallExpression" && z.callee.name === "require" || X3.parser === "json5" || X3.parser === "json")
              return "never-break-after-operator";
            if (N(G) || L(G) || $(G) || V(G) && m2(De2))
              return "break-lhs";
            let Ae2 = ee2(G, De2, X3);
            return W2.call(() => y(W2, X3, ue2, Ae2), ie) ? "break-after-operator" : Ae2 || z.type === "TemplateLiteral" || z.type === "TaggedTemplateExpression" || z.type === "BooleanLiteral" || w2(z) || z.type === "ClassExpression" ? "never-break-after-operator" : "fluid";
          }
          function y(W2, X3, ue2, De2) {
            let ie = W2.getValue();
            if (p(ie) && !C2(ie))
              return true;
            switch (ie.type) {
              case "StringLiteralTypeAnnotation":
              case "SequenceExpression":
                return true;
              case "ConditionalExpression": {
                let { test: U } = ie;
                return p(U) && !C2(U);
              }
              case "ClassExpression":
                return t(ie.decorators);
            }
            if (De2)
              return false;
            let G = ie, z = [];
            for (; ; )
              if (G.type === "UnaryExpression")
                G = G.argument, z.push("argument");
              else if (G.type === "TSNonNullExpression")
                G = G.expression, z.push("expression");
              else
                break;
            return !!(f(G) || W2.call(() => H3(W2, X3, ue2), ...z));
          }
          function N(W2) {
            if (b2(W2)) {
              let X3 = W2.left || W2.id;
              return X3.type === "ObjectPattern" && X3.properties.length > 2 && X3.properties.some((ue2) => P(ue2) && (!ue2.shorthand || ue2.value && ue2.value.type === "AssignmentPattern"));
            }
            return false;
          }
          function x2(W2) {
            return W2.type === "AssignmentExpression";
          }
          function b2(W2) {
            return x2(W2) || W2.type === "VariableDeclarator";
          }
          function L(W2) {
            let X3 = M2(W2);
            if (t(X3)) {
              let ue2 = W2.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
              if (X3.length > 1 && X3.some((De2) => De2[ue2] || De2.default))
                return true;
            }
            return false;
          }
          function M2(W2) {
            return j(W2) && W2.typeParameters && W2.typeParameters.params ? W2.typeParameters.params : null;
          }
          function j(W2) {
            return W2.type === "TSTypeAliasDeclaration" || W2.type === "TypeAlias";
          }
          function $(W2) {
            if (W2.type !== "VariableDeclarator")
              return false;
            let { typeAnnotation: X3 } = W2.id;
            if (!X3 || !X3.typeAnnotation)
              return false;
            let ue2 = q(X3.typeAnnotation);
            return t(ue2) && ue2.length > 1 && ue2.some((De2) => t(q(De2)) || De2.type === "TSConditionalType");
          }
          function V(W2) {
            return W2.type === "VariableDeclarator" && W2.init && W2.init.type === "ArrowFunctionExpression";
          }
          function q(W2) {
            return Y3(W2) && W2.typeParameters && W2.typeParameters.params ? W2.typeParameters.params : null;
          }
          function Y3(W2) {
            return W2.type === "TSTypeReference" || W2.type === "GenericTypeAnnotation";
          }
          function H3(W2, X3, ue2) {
            let De2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, ie = W2.getValue(), G = () => H3(W2, X3, ue2, true);
            if (ie.type === "TSNonNullExpression")
              return W2.call(G, "expression");
            if (T2(ie)) {
              if (D2(W2, X3, ue2).label === "member-chain")
                return false;
              let U = S2(ie);
              return !(U.length === 0 || U.length === 1 && Q(U[0], X3)) || te2(ie, ue2) ? false : W2.call(G, "callee");
            }
            return A2(ie) ? W2.call(G, "object") : De2 && (ie.type === "Identifier" || ie.type === "ThisExpression");
          }
          var R = 0.25;
          function Q(W2, X3) {
            let { printWidth: ue2 } = X3;
            if (I2(W2))
              return false;
            let De2 = ue2 * R;
            if (W2.type === "ThisExpression" || W2.type === "Identifier" && W2.name.length <= De2 || k2(W2) && !I2(W2.argument))
              return true;
            let ie = W2.type === "Literal" && "regex" in W2 && W2.regex.pattern || W2.type === "RegExpLiteral" && W2.pattern;
            return ie ? ie.length <= De2 : f(W2) ? B(W2).length <= De2 : W2.type === "TemplateLiteral" ? W2.expressions.length === 0 && W2.quasis[0].value.raw.length <= De2 && !W2.quasis[0].value.raw.includes(`
`) : h2(W2);
          }
          function ee2(W2, X3, ue2) {
            if (!P(W2))
              return false;
            X3 = c(X3);
            let De2 = 3;
            return typeof X3 == "string" && s2(X3) < ue2.tabWidth + De2;
          }
          function te2(W2, X3) {
            let ue2 = oe2(W2);
            if (t(ue2)) {
              if (ue2.length > 1)
                return true;
              if (ue2.length === 1) {
                let ie = ue2[0];
                if (ie.type === "TSUnionType" || ie.type === "UnionTypeAnnotation" || ie.type === "TSIntersectionType" || ie.type === "IntersectionTypeAnnotation" || ie.type === "TSTypeLiteral" || ie.type === "ObjectTypeAnnotation")
                  return true;
              }
              let De2 = W2.typeParameters ? "typeParameters" : "typeArguments";
              if (v(X3(De2)))
                return true;
            }
            return false;
          }
          function oe2(W2) {
            return W2.typeParameters && W2.typeParameters.params || W2.typeArguments && W2.typeArguments.params;
          }
          n.exports = { printVariableDeclarator: l, printAssignmentExpression: F, printAssignment: g2, isArrowFunctionVariableDeclarator: V };
        } }), Pr2 = Z3({ "src/language-js/print/function-parameters.js"(e, n) {
          re2();
          var { getNextNonSpaceNonCommentCharacter: t } = Ue2(), { printDanglingComments: s2 } = et2(), { builders: { line: a3, hardline: r, softline: u, group: i2, indent: o, ifBreak: c }, utils: { removeLines: v, willBreak: m2 } } = Oe2(), { getFunctionParameters: d4, iterateFunctionParametersPath: p, isSimpleType: f, isTestCall: h2, isTypeAnnotationAFunction: w2, isObjectType: T2, isObjectTypePropertyAFunction: A2, hasRestParameter: S2, shouldPrintComma: B, hasComment: I2, isNextLineEmpty: k2 } = Ke2(), { locEnd: P } = st2(), { ArgExpansionBailout: C2 } = zt2(), { printFunctionTypeParameters: D2 } = ct2();
          function g2(y, N, x2, b2, L) {
            let M2 = y.getValue(), j = d4(M2), $ = L ? D2(y, x2, N) : "";
            if (j.length === 0)
              return [$, "(", s2(y, x2, true, (ee2) => t(x2.originalText, ee2, P) === ")"), ")"];
            let V = y.getParentNode(), q = h2(V), Y3 = F(M2), H3 = [];
            if (p(y, (ee2, te2) => {
              let oe2 = te2 === j.length - 1;
              oe2 && M2.rest && H3.push("..."), H3.push(N()), !oe2 && (H3.push(","), q || Y3 ? H3.push(" ") : k2(j[te2], x2) ? H3.push(r, r) : H3.push(a3));
            }), b2) {
              if (m2($) || m2(H3))
                throw new C2();
              return i2([v($), "(", v(H3), ")"]);
            }
            let R = j.every((ee2) => !ee2.decorators);
            return Y3 && R ? [$, "(", ...H3, ")"] : q ? [$, "(", ...H3, ")"] : (A2(V) || w2(V) || V.type === "TypeAlias" || V.type === "UnionTypeAnnotation" || V.type === "TSUnionType" || V.type === "IntersectionTypeAnnotation" || V.type === "FunctionTypeAnnotation" && V.returnType === M2) && j.length === 1 && j[0].name === null && M2.this !== j[0] && j[0].typeAnnotation && M2.typeParameters === null && f(j[0].typeAnnotation) && !M2.rest ? x2.arrowParens === "always" ? ["(", ...H3, ")"] : H3 : [$, "(", o([u, ...H3]), c(!S2(M2) && B(x2, "all") ? "," : ""), u, ")"];
          }
          function F(y) {
            if (!y)
              return false;
            let N = d4(y);
            if (N.length !== 1)
              return false;
            let [x2] = N;
            return !I2(x2) && (x2.type === "ObjectPattern" || x2.type === "ArrayPattern" || x2.type === "Identifier" && x2.typeAnnotation && (x2.typeAnnotation.type === "TypeAnnotation" || x2.typeAnnotation.type === "TSTypeAnnotation") && T2(x2.typeAnnotation.typeAnnotation) || x2.type === "FunctionTypeParam" && T2(x2.typeAnnotation) || x2.type === "AssignmentPattern" && (x2.left.type === "ObjectPattern" || x2.left.type === "ArrayPattern") && (x2.right.type === "Identifier" || x2.right.type === "ObjectExpression" && x2.right.properties.length === 0 || x2.right.type === "ArrayExpression" && x2.right.elements.length === 0));
          }
          function l(y) {
            let N;
            return y.returnType ? (N = y.returnType, N.typeAnnotation && (N = N.typeAnnotation)) : y.typeAnnotation && (N = y.typeAnnotation), N;
          }
          function E(y, N) {
            let x2 = l(y);
            if (!x2)
              return false;
            let b2 = y.typeParameters && y.typeParameters.params;
            if (b2) {
              if (b2.length > 1)
                return false;
              if (b2.length === 1) {
                let L = b2[0];
                if (L.constraint || L.default)
                  return false;
              }
            }
            return d4(y).length === 1 && (T2(x2) || m2(N));
          }
          n.exports = { printFunctionParameters: g2, shouldHugFunctionParameters: F, shouldGroupFunctionParameters: E };
        } }), kr2 = Z3({ "src/language-js/print/type-annotation.js"(e, n) {
          re2();
          var { printComments: t, printDanglingComments: s2 } = et2(), { isNonEmptyArray: a3 } = Ue2(), { builders: { group: r, join: u, line: i2, softline: o, indent: c, align: v, ifBreak: m2 } } = Oe2(), d4 = jt2(), { locStart: p } = st2(), { isSimpleType: f, isObjectType: h2, hasLeadingOwnLineComment: w2, isObjectTypePropertyAFunction: T2, shouldPrintComma: A2 } = Ke2(), { printAssignment: S2 } = Yt2(), { printFunctionParameters: B, shouldGroupFunctionParameters: I2 } = Pr2(), { printArrayItems: k2 } = Kt2();
          function P(x2) {
            if (f(x2) || h2(x2))
              return true;
            if (x2.type === "UnionTypeAnnotation" || x2.type === "TSUnionType") {
              let b2 = x2.types.filter((M2) => M2.type === "VoidTypeAnnotation" || M2.type === "TSVoidKeyword" || M2.type === "NullLiteralTypeAnnotation" || M2.type === "TSNullKeyword").length, L = x2.types.some((M2) => M2.type === "ObjectTypeAnnotation" || M2.type === "TSTypeLiteral" || M2.type === "GenericTypeAnnotation" || M2.type === "TSTypeReference");
              if (x2.types.length - 1 === b2 && L)
                return true;
            }
            return false;
          }
          function C2(x2, b2, L) {
            let M2 = b2.semi ? ";" : "", j = x2.getValue(), $ = [];
            return $.push("opaque type ", L("id"), L("typeParameters")), j.supertype && $.push(": ", L("supertype")), j.impltype && $.push(" = ", L("impltype")), $.push(M2), $;
          }
          function D2(x2, b2, L) {
            let M2 = b2.semi ? ";" : "", j = x2.getValue(), $ = [];
            j.declare && $.push("declare "), $.push("type ", L("id"), L("typeParameters"));
            let V = j.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
            return [S2(x2, b2, L, $, " =", V), M2];
          }
          function g2(x2, b2, L) {
            let M2 = x2.getValue(), j = x2.map(L, "types"), $ = [], V = false;
            for (let q = 0; q < j.length; ++q)
              q === 0 ? $.push(j[q]) : h2(M2.types[q - 1]) && h2(M2.types[q]) ? $.push([" & ", V ? c(j[q]) : j[q]]) : !h2(M2.types[q - 1]) && !h2(M2.types[q]) ? $.push(c([" &", i2, j[q]])) : (q > 1 && (V = true), $.push(" & ", q > 1 ? c(j[q]) : j[q]));
            return r($);
          }
          function F(x2, b2, L) {
            let M2 = x2.getValue(), j = x2.getParentNode(), $ = j.type !== "TypeParameterInstantiation" && j.type !== "TSTypeParameterInstantiation" && j.type !== "GenericTypeAnnotation" && j.type !== "TSTypeReference" && j.type !== "TSTypeAssertion" && j.type !== "TupleTypeAnnotation" && j.type !== "TSTupleType" && !(j.type === "FunctionTypeParam" && !j.name && x2.getParentNode(1).this !== j) && !((j.type === "TypeAlias" || j.type === "VariableDeclarator" || j.type === "TSTypeAliasDeclaration") && w2(b2.originalText, M2)), V = P(M2), q = x2.map((R) => {
              let Q = L();
              return V || (Q = v(2, Q)), t(R, Q, b2);
            }, "types");
            if (V)
              return u(" | ", q);
            let Y3 = $ && !w2(b2.originalText, M2), H3 = [m2([Y3 ? i2 : "", "| "]), u([i2, "| "], q)];
            return d4(x2, b2) ? r([c(H3), o]) : j.type === "TupleTypeAnnotation" && j.types.length > 1 || j.type === "TSTupleType" && j.elementTypes.length > 1 ? r([c([m2(["(", o]), H3]), o, m2(")")]) : r($ ? c(H3) : H3);
          }
          function l(x2, b2, L) {
            let M2 = x2.getValue(), j = [], $ = x2.getParentNode(0), V = x2.getParentNode(1), q = x2.getParentNode(2), Y3 = M2.type === "TSFunctionType" || !(($.type === "ObjectTypeProperty" || $.type === "ObjectTypeInternalSlot") && !$.variance && !$.optional && p($) === p(M2) || $.type === "ObjectTypeCallProperty" || q && q.type === "DeclareFunction"), H3 = Y3 && ($.type === "TypeAnnotation" || $.type === "TSTypeAnnotation"), R = H3 && Y3 && ($.type === "TypeAnnotation" || $.type === "TSTypeAnnotation") && V.type === "ArrowFunctionExpression";
            T2($) && (Y3 = true, H3 = true), R && j.push("(");
            let Q = B(x2, L, b2, false, true), ee2 = M2.returnType || M2.predicate || M2.typeAnnotation ? [Y3 ? " => " : ": ", L("returnType"), L("predicate"), L("typeAnnotation")] : "", te2 = I2(M2, ee2);
            return j.push(te2 ? r(Q) : Q), ee2 && j.push(ee2), R && j.push(")"), r(j);
          }
          function E(x2, b2, L) {
            let M2 = x2.getValue(), j = M2.type === "TSTupleType" ? "elementTypes" : "types", $ = M2[j], V = a3($), q = V ? o : "";
            return r(["[", c([q, k2(x2, b2, j, L)]), m2(V && A2(b2, "all") ? "," : ""), s2(x2, b2, true), q, "]"]);
          }
          function y(x2, b2, L) {
            let M2 = x2.getValue(), j = M2.type === "OptionalIndexedAccessType" && M2.optional ? "?.[" : "[";
            return [L("objectType"), j, L("indexType"), "]"];
          }
          function N(x2, b2, L) {
            let M2 = x2.getValue();
            return [M2.postfix ? "" : L, b2("typeAnnotation"), M2.postfix ? L : ""];
          }
          n.exports = { printOpaqueType: C2, printTypeAlias: D2, printIntersectionType: g2, printUnionType: F, printFunctionType: l, printTupleType: E, printIndexedAccessType: y, shouldHugType: P, printJSDocType: N };
        } }), Ir2 = Z3({ "src/language-js/print/type-parameters.js"(e, n) {
          re2();
          var { printDanglingComments: t } = et2(), { builders: { join: s2, line: a3, hardline: r, softline: u, group: i2, indent: o, ifBreak: c } } = Oe2(), { isTestCall: v, hasComment: m2, CommentCheckFlags: d4, isTSXFile: p, shouldPrintComma: f, getFunctionParameters: h2, isObjectType: w2 } = Ke2(), { createGroupIdMapper: T2 } = Ue2(), { shouldHugType: A2 } = kr2(), { isArrowFunctionVariableDeclarator: S2 } = Yt2(), B = T2("typeParameters");
          function I2(C2, D2, g2, F) {
            let l = C2.getValue();
            if (!l[F])
              return "";
            if (!Array.isArray(l[F]))
              return g2(F);
            let E = C2.getNode(2), y = E && v(E);
            if (!C2.match((L) => !(L[F].length === 1 && w2(L[F][0])), void 0, (L, M2) => M2 === "typeAnnotation", (L) => L.type === "Identifier", S2) && (y || l[F].length === 0 || l[F].length === 1 && (l[F][0].type === "NullableTypeAnnotation" || A2(l[F][0]))))
              return ["<", s2(", ", C2.map(g2, F)), k2(C2, D2), ">"];
            let b2 = l.type === "TSTypeParameterInstantiation" ? "" : h2(l).length === 1 && p(D2) && !l[F][0].constraint && C2.getParentNode().type === "ArrowFunctionExpression" ? "," : f(D2, "all") ? c(",") : "";
            return i2(["<", o([u, s2([",", a3], C2.map(g2, F))]), b2, u, ">"], { id: B(l) });
          }
          function k2(C2, D2) {
            let g2 = C2.getValue();
            if (!m2(g2, d4.Dangling))
              return "";
            let F = !m2(g2, d4.Line), l = t(C2, D2, F);
            return F ? l : [l, r];
          }
          function P(C2, D2, g2) {
            let F = C2.getValue(), l = [], E = C2.getParentNode();
            return E.type === "TSMappedType" ? (l.push("[", g2("name")), F.constraint && l.push(" in ", g2("constraint")), E.nameType && l.push(" as ", C2.callParent(() => g2("nameType"))), l.push("]"), l) : (F.variance && l.push(g2("variance")), F.in && l.push("in "), F.out && l.push("out "), l.push(g2("name")), F.bound && l.push(": ", g2("bound")), F.constraint && l.push(" extends ", g2("constraint")), F.default && l.push(" = ", g2("default")), l);
          }
          n.exports = { printTypeParameter: P, printTypeParameters: I2, getTypeParametersGroupId: B };
        } }), Qt2 = Z3({ "src/language-js/print/property.js"(e, n) {
          re2();
          var { printComments: t } = et2(), { printString: s2, printNumber: a3 } = Ue2(), { isNumericLiteral: r, isSimpleNumber: u, isStringLiteral: i2, isStringPropSafeToUnquote: o, rawText: c } = Ke2(), { printAssignment: v } = Yt2(), m2 = /* @__PURE__ */ new WeakMap();
          function d4(f, h2, w2) {
            let T2 = f.getNode();
            if (T2.computed)
              return ["[", w2("key"), "]"];
            let A2 = f.getParentNode(), { key: S2 } = T2;
            if (T2.type === "ClassPrivateProperty" && S2.type === "Identifier")
              return ["#", w2("key")];
            if (h2.quoteProps === "consistent" && !m2.has(A2)) {
              let B = (A2.properties || A2.body || A2.members).some((I2) => !I2.computed && I2.key && i2(I2.key) && !o(I2, h2));
              m2.set(A2, B);
            }
            if ((S2.type === "Identifier" || r(S2) && u(a3(c(S2))) && String(S2.value) === a3(c(S2)) && !(h2.parser === "typescript" || h2.parser === "babel-ts")) && (h2.parser === "json" || h2.quoteProps === "consistent" && m2.get(A2))) {
              let B = s2(JSON.stringify(S2.type === "Identifier" ? S2.name : S2.value.toString()), h2);
              return f.call((I2) => t(I2, B, h2), "key");
            }
            return o(T2, h2) && (h2.quoteProps === "as-needed" || h2.quoteProps === "consistent" && !m2.get(A2)) ? f.call((B) => t(B, /^\d/.test(S2.value) ? a3(S2.value) : S2.value, h2), "key") : w2("key");
          }
          function p(f, h2, w2) {
            return f.getValue().shorthand ? w2("value") : v(f, h2, w2, d4(f, h2, w2), ":", "value");
          }
          n.exports = { printProperty: p, printPropertyKey: d4 };
        } }), Lr2 = Z3({ "src/language-js/print/function.js"(e, n) {
          re2();
          var t = Xt2(), { printDanglingComments: s2, printCommentsSeparately: a3 } = et2(), r = it2(), { getNextNonSpaceNonCommentCharacterIndex: u } = Ue2(), { builders: { line: i2, softline: o, group: c, indent: v, ifBreak: m2, hardline: d4, join: p, indentIfBreak: f }, utils: { removeLines: h2, willBreak: w2 } } = Oe2(), { ArgExpansionBailout: T2 } = zt2(), { getFunctionParameters: A2, hasLeadingOwnLineComment: S2, isFlowAnnotationComment: B, isJsxNode: I2, isTemplateOnItsOwnLine: k2, shouldPrintComma: P, startsWithNoLookaheadToken: C2, isBinaryish: D2, isLineComment: g2, hasComment: F, getComments: l, CommentCheckFlags: E, isCallLikeExpression: y, isCallExpression: N, getCallArguments: x2, hasNakedLeftSide: b2, getLeftSide: L } = Ke2(), { locEnd: M2 } = st2(), { printFunctionParameters: j, shouldGroupFunctionParameters: $ } = Pr2(), { printPropertyKey: V } = Qt2(), { printFunctionTypeParameters: q } = ct2();
          function Y3(z, U, le2, ge2) {
            let Ae2 = z.getValue(), Ne2 = false;
            if ((Ae2.type === "FunctionDeclaration" || Ae2.type === "FunctionExpression") && ge2 && ge2.expandLastArg) {
              let ae2 = z.getParentNode();
              N(ae2) && x2(ae2).length > 1 && (Ne2 = true);
            }
            let ke2 = [];
            Ae2.type === "TSDeclareFunction" && Ae2.declare && ke2.push("declare "), Ae2.async && ke2.push("async "), Ae2.generator ? ke2.push("function* ") : ke2.push("function "), Ae2.id && ke2.push(U("id"));
            let ce = j(z, U, le2, Ne2), pe = X3(z, U, le2), de2 = $(Ae2, pe);
            return ke2.push(q(z, le2, U), c([de2 ? c(ce) : ce, pe]), Ae2.body ? " " : "", U("body")), le2.semi && (Ae2.declare || !Ae2.body) && ke2.push(";"), ke2;
          }
          function H3(z, U, le2) {
            let ge2 = z.getNode(), { kind: Ae2 } = ge2, Ne2 = ge2.value || ge2, ke2 = [];
            return !Ae2 || Ae2 === "init" || Ae2 === "method" || Ae2 === "constructor" ? Ne2.async && ke2.push("async ") : (t.ok(Ae2 === "get" || Ae2 === "set"), ke2.push(Ae2, " ")), Ne2.generator && ke2.push("*"), ke2.push(V(z, U, le2), ge2.optional || ge2.key.optional ? "?" : ""), ge2 === Ne2 ? ke2.push(R(z, U, le2)) : Ne2.type === "FunctionExpression" ? ke2.push(z.call((ce) => R(ce, U, le2), "value")) : ke2.push(le2("value")), ke2;
          }
          function R(z, U, le2) {
            let ge2 = z.getNode(), Ae2 = j(z, le2, U), Ne2 = X3(z, le2, U), ke2 = $(ge2, Ne2), ce = [q(z, U, le2), c([ke2 ? c(Ae2) : Ae2, Ne2])];
            return ge2.body ? ce.push(" ", le2("body")) : ce.push(U.semi ? ";" : ""), ce;
          }
          function Q(z, U, le2, ge2) {
            let Ae2 = z.getValue(), Ne2 = [];
            if (Ae2.async && Ne2.push("async "), W2(z, U))
              Ne2.push(le2(["params", 0]));
            else {
              let ce = ge2 && (ge2.expandLastArg || ge2.expandFirstArg), pe = X3(z, le2, U);
              if (ce) {
                if (w2(pe))
                  throw new T2();
                pe = c(h2(pe));
              }
              Ne2.push(c([j(z, le2, U, ce, true), pe]));
            }
            let ke2 = s2(z, U, true, (ce) => {
              let pe = u(U.originalText, ce, M2);
              return pe !== false && U.originalText.slice(pe, pe + 2) === "=>";
            });
            return ke2 && Ne2.push(" ", ke2), Ne2;
          }
          function ee2(z, U, le2, ge2, Ae2, Ne2) {
            let ke2 = z.getName(), ce = z.getParentNode(), pe = y(ce) && ke2 === "callee", de2 = Boolean(U && U.assignmentLayout), ae2 = Ne2.body.type !== "BlockStatement" && Ne2.body.type !== "ObjectExpression" && Ne2.body.type !== "SequenceExpression", ve2 = pe && ae2 || U && U.assignmentLayout === "chain-tail-arrow-chain", K = Symbol("arrow-chain");
            return Ne2.body.type === "SequenceExpression" && (Ae2 = c(["(", v([o, Ae2]), o, ")"])), c([c(v([pe || de2 ? o : "", c(p([" =>", i2], le2), { shouldBreak: ge2 })]), { id: K, shouldBreak: ve2 }), " =>", f(ae2 ? v([i2, Ae2]) : [" ", Ae2], { groupId: K }), pe ? m2(o, "", { groupId: K }) : ""]);
          }
          function te2(z, U, le2, ge2) {
            let Ae2 = z.getValue(), Ne2 = [], ke2 = [], ce = false;
            if (function K() {
              let he2 = Q(z, U, le2, ge2);
              if (Ne2.length === 0)
                Ne2.push(he2);
              else {
                let { leading: ye2, trailing: Ce2 } = a3(z, U);
                Ne2.push([ye2, he2]), ke2.unshift(Ce2);
              }
              ce = ce || Ae2.returnType && A2(Ae2).length > 0 || Ae2.typeParameters || A2(Ae2).some((ye2) => ye2.type !== "Identifier"), Ae2.body.type !== "ArrowFunctionExpression" || ge2 && ge2.expandLastArg ? ke2.unshift(le2("body", ge2)) : (Ae2 = Ae2.body, z.call(K, "body"));
            }(), Ne2.length > 1)
              return ee2(z, ge2, Ne2, ce, ke2, Ae2);
            let pe = Ne2;
            if (pe.push(" =>"), !S2(U.originalText, Ae2.body) && (Ae2.body.type === "ArrayExpression" || Ae2.body.type === "ObjectExpression" || Ae2.body.type === "BlockStatement" || I2(Ae2.body) || k2(Ae2.body, U.originalText) || Ae2.body.type === "ArrowFunctionExpression" || Ae2.body.type === "DoExpression"))
              return c([...pe, " ", ke2]);
            if (Ae2.body.type === "SequenceExpression")
              return c([...pe, c([" (", v([o, ke2]), o, ")"])]);
            let de2 = (ge2 && ge2.expandLastArg || z.getParentNode().type === "JSXExpressionContainer") && !F(Ae2), ae2 = ge2 && ge2.expandLastArg && P(U, "all"), ve2 = Ae2.body.type === "ConditionalExpression" && !C2(Ae2.body, false);
            return c([...pe, c([v([i2, ve2 ? m2("", "(") : "", ke2, ve2 ? m2("", ")") : ""]), de2 ? [m2(ae2 ? "," : ""), o] : ""])]);
          }
          function oe2(z) {
            let U = A2(z);
            return U.length === 1 && !z.typeParameters && !F(z, E.Dangling) && U[0].type === "Identifier" && !U[0].typeAnnotation && !F(U[0]) && !U[0].optional && !z.predicate && !z.returnType;
          }
          function W2(z, U) {
            if (U.arrowParens === "always")
              return false;
            if (U.arrowParens === "avoid") {
              let le2 = z.getValue();
              return oe2(le2);
            }
            return false;
          }
          function X3(z, U, le2) {
            let ge2 = z.getValue(), Ae2 = U("returnType");
            if (ge2.returnType && B(le2.originalText, ge2.returnType))
              return [" /*: ", Ae2, " */"];
            let Ne2 = [Ae2];
            return ge2.returnType && ge2.returnType.typeAnnotation && Ne2.unshift(": "), ge2.predicate && Ne2.push(ge2.returnType ? " " : ": ", U("predicate")), Ne2;
          }
          function ue2(z, U, le2) {
            let ge2 = z.getValue(), Ae2 = U.semi ? ";" : "", Ne2 = [];
            ge2.argument && (G(U, ge2.argument) ? Ne2.push([" (", v([d4, le2("argument")]), d4, ")"]) : D2(ge2.argument) || ge2.argument.type === "SequenceExpression" ? Ne2.push(c([m2(" (", " "), v([o, le2("argument")]), o, m2(")")])) : Ne2.push(" ", le2("argument")));
            let ke2 = l(ge2), ce = r(ke2), pe = ce && g2(ce);
            return pe && Ne2.push(Ae2), F(ge2, E.Dangling) && Ne2.push(" ", s2(z, U, true)), pe || Ne2.push(Ae2), Ne2;
          }
          function De2(z, U, le2) {
            return ["return", ue2(z, U, le2)];
          }
          function ie(z, U, le2) {
            return ["throw", ue2(z, U, le2)];
          }
          function G(z, U) {
            if (S2(z.originalText, U))
              return true;
            if (b2(U)) {
              let le2 = U, ge2;
              for (; ge2 = L(le2); )
                if (le2 = ge2, S2(z.originalText, le2))
                  return true;
            }
            return false;
          }
          n.exports = { printFunction: Y3, printArrowFunction: te2, printMethod: H3, printReturnStatement: De2, printThrowStatement: ie, printMethodInternal: R, shouldPrintParamsWithoutParens: W2 };
        } }), Un2 = Z3({ "src/language-js/print/decorators.js"(e, n) {
          re2();
          var { isNonEmptyArray: t, hasNewline: s2 } = Ue2(), { builders: { line: a3, hardline: r, join: u, breakParent: i2, group: o } } = Oe2(), { locStart: c, locEnd: v } = st2(), { getParentExportDeclaration: m2 } = Ke2();
          function d4(T2, A2, S2) {
            let B = T2.getValue();
            return o([u(a3, T2.map(S2, "decorators")), h2(B, A2) ? r : a3]);
          }
          function p(T2, A2, S2) {
            return [u(r, T2.map(S2, "declaration", "decorators")), r];
          }
          function f(T2, A2, S2) {
            let B = T2.getValue(), { decorators: I2 } = B;
            if (!t(I2) || w2(T2.getParentNode()))
              return;
            let k2 = B.type === "ClassExpression" || B.type === "ClassDeclaration" || h2(B, A2);
            return [m2(T2) ? r : k2 ? i2 : "", u(a3, T2.map(S2, "decorators")), a3];
          }
          function h2(T2, A2) {
            return T2.decorators.some((S2) => s2(A2.originalText, v(S2)));
          }
          function w2(T2) {
            if (T2.type !== "ExportDefaultDeclaration" && T2.type !== "ExportNamedDeclaration" && T2.type !== "DeclareExportDeclaration")
              return false;
            let A2 = T2.declaration && T2.declaration.decorators;
            return t(A2) && c(T2, { ignoreDecorators: true }) > c(A2[0]);
          }
          n.exports = { printDecorators: f, printClassMemberDecorators: d4, printDecoratorsBeforeExport: p, hasDecoratorsBeforeExport: w2 };
        } }), Zt = Z3({ "src/language-js/print/class.js"(e, n) {
          re2();
          var { isNonEmptyArray: t, createGroupIdMapper: s2 } = Ue2(), { printComments: a3, printDanglingComments: r } = et2(), { builders: { join: u, line: i2, hardline: o, softline: c, group: v, indent: m2, ifBreak: d4 } } = Oe2(), { hasComment: p, CommentCheckFlags: f } = Ke2(), { getTypeParametersGroupId: h2 } = Ir2(), { printMethod: w2 } = Lr2(), { printOptionalToken: T2, printTypeAnnotation: A2, printDefiniteToken: S2 } = ct2(), { printPropertyKey: B } = Qt2(), { printAssignment: I2 } = Yt2(), { printClassMemberDecorators: k2 } = Un2();
          function P(x2, b2, L) {
            let M2 = x2.getValue(), j = [];
            M2.declare && j.push("declare "), M2.abstract && j.push("abstract "), j.push("class");
            let $ = M2.id && p(M2.id, f.Trailing) || M2.typeParameters && p(M2.typeParameters, f.Trailing) || M2.superClass && p(M2.superClass) || t(M2.extends) || t(M2.mixins) || t(M2.implements), V = [], q = [];
            if (M2.id && V.push(" ", L("id")), V.push(L("typeParameters")), M2.superClass) {
              let Y3 = [E(x2, b2, L), L("superTypeParameters")], H3 = x2.call((R) => ["extends ", a3(R, Y3, b2)], "superClass");
              $ ? q.push(i2, v(H3)) : q.push(" ", H3);
            } else
              q.push(l(x2, b2, L, "extends"));
            if (q.push(l(x2, b2, L, "mixins"), l(x2, b2, L, "implements")), $) {
              let Y3;
              F(M2) ? Y3 = [...V, m2(q)] : Y3 = m2([...V, q]), j.push(v(Y3, { id: C2(M2) }));
            } else
              j.push(...V, ...q);
            return j.push(" ", L("body")), j;
          }
          var C2 = s2("heritageGroup");
          function D2(x2) {
            return d4(o, "", { groupId: C2(x2) });
          }
          function g2(x2) {
            return ["superClass", "extends", "mixins", "implements"].filter((b2) => Boolean(x2[b2])).length > 1;
          }
          function F(x2) {
            return x2.typeParameters && !p(x2.typeParameters, f.Trailing | f.Line) && !g2(x2);
          }
          function l(x2, b2, L, M2) {
            let j = x2.getValue();
            if (!t(j[M2]))
              return "";
            let $ = r(x2, b2, true, (V) => {
              let { marker: q } = V;
              return q === M2;
            });
            return [F(j) ? d4(" ", i2, { groupId: h2(j.typeParameters) }) : i2, $, $ && o, M2, v(m2([i2, u([",", i2], x2.map(L, M2))]))];
          }
          function E(x2, b2, L) {
            let M2 = L("superClass");
            return x2.getParentNode().type === "AssignmentExpression" ? v(d4(["(", m2([c, M2]), c, ")"], M2)) : M2;
          }
          function y(x2, b2, L) {
            let M2 = x2.getValue(), j = [];
            return t(M2.decorators) && j.push(k2(x2, b2, L)), M2.accessibility && j.push(M2.accessibility + " "), M2.readonly && j.push("readonly "), M2.declare && j.push("declare "), M2.static && j.push("static "), (M2.type === "TSAbstractMethodDefinition" || M2.abstract) && j.push("abstract "), M2.override && j.push("override "), j.push(w2(x2, b2, L)), j;
          }
          function N(x2, b2, L) {
            let M2 = x2.getValue(), j = [], $ = b2.semi ? ";" : "";
            return t(M2.decorators) && j.push(k2(x2, b2, L)), M2.accessibility && j.push(M2.accessibility + " "), M2.declare && j.push("declare "), M2.static && j.push("static "), (M2.type === "TSAbstractPropertyDefinition" || M2.abstract) && j.push("abstract "), M2.override && j.push("override "), M2.readonly && j.push("readonly "), M2.variance && j.push(L("variance")), M2.type === "ClassAccessorProperty" && j.push("accessor "), j.push(B(x2, b2, L), T2(x2), S2(x2), A2(x2, b2, L)), [I2(x2, b2, L, j, " =", "value"), $];
          }
          n.exports = { printClass: P, printClassMethod: y, printClassProperty: N, printHardlineAfterHeritage: D2 };
        } }), lo2 = Z3({ "src/language-js/print/interface.js"(e, n) {
          re2();
          var { isNonEmptyArray: t } = Ue2(), { builders: { join: s2, line: a3, group: r, indent: u, ifBreak: i2 } } = Oe2(), { hasComment: o, identity: c, CommentCheckFlags: v } = Ke2(), { getTypeParametersGroupId: m2 } = Ir2(), { printTypeScriptModifiers: d4 } = ct2();
          function p(f, h2, w2) {
            let T2 = f.getValue(), A2 = [];
            T2.declare && A2.push("declare "), T2.type === "TSInterfaceDeclaration" && A2.push(T2.abstract ? "abstract " : "", d4(f, h2, w2)), A2.push("interface");
            let S2 = [], B = [];
            T2.type !== "InterfaceTypeAnnotation" && S2.push(" ", w2("id"), w2("typeParameters"));
            let I2 = T2.typeParameters && !o(T2.typeParameters, v.Trailing | v.Line);
            return t(T2.extends) && B.push(I2 ? i2(" ", a3, { groupId: m2(T2.typeParameters) }) : a3, "extends ", (T2.extends.length === 1 ? c : u)(s2([",", a3], f.map(w2, "extends")))), T2.id && o(T2.id, v.Trailing) || t(T2.extends) ? I2 ? A2.push(r([...S2, u(B)])) : A2.push(r(u([...S2, ...B]))) : A2.push(...S2, ...B), A2.push(" ", w2("body")), r(A2);
          }
          n.exports = { printInterface: p };
        } }), co2 = Z3({ "src/language-js/print/module.js"(e, n) {
          re2();
          var { isNonEmptyArray: t } = Ue2(), { builders: { softline: s2, group: a3, indent: r, join: u, line: i2, ifBreak: o, hardline: c } } = Oe2(), { printDanglingComments: v } = et2(), { hasComment: m2, CommentCheckFlags: d4, shouldPrintComma: p, needsHardlineAfterDanglingComment: f, isStringLiteral: h2, rawText: w2 } = Ke2(), { locStart: T2, hasSameLoc: A2 } = st2(), { hasDecoratorsBeforeExport: S2, printDecoratorsBeforeExport: B } = Un2();
          function I2(N, x2, b2) {
            let L = N.getValue(), M2 = x2.semi ? ";" : "", j = [], { importKind: $ } = L;
            return j.push("import"), $ && $ !== "value" && j.push(" ", $), j.push(g2(N, x2, b2), D2(N, x2, b2), l(N, x2, b2), M2), j;
          }
          function k2(N, x2, b2) {
            let L = N.getValue(), M2 = [];
            S2(L) && M2.push(B(N, x2, b2));
            let { type: j, exportKind: $, declaration: V } = L;
            return M2.push("export"), (L.default || j === "ExportDefaultDeclaration") && M2.push(" default"), m2(L, d4.Dangling) && (M2.push(" ", v(N, x2, true)), f(L) && M2.push(c)), V ? M2.push(" ", b2("declaration")) : M2.push($ === "type" ? " type" : "", g2(N, x2, b2), D2(N, x2, b2), l(N, x2, b2)), C2(L, x2) && M2.push(";"), M2;
          }
          function P(N, x2, b2) {
            let L = N.getValue(), M2 = x2.semi ? ";" : "", j = [], { exportKind: $, exported: V } = L;
            return j.push("export"), $ === "type" && j.push(" type"), j.push(" *"), V && j.push(" as ", b2("exported")), j.push(D2(N, x2, b2), l(N, x2, b2), M2), j;
          }
          function C2(N, x2) {
            if (!x2.semi)
              return false;
            let { type: b2, declaration: L } = N, M2 = N.default || b2 === "ExportDefaultDeclaration";
            if (!L)
              return true;
            let { type: j } = L;
            return !!(M2 && j !== "ClassDeclaration" && j !== "FunctionDeclaration" && j !== "TSInterfaceDeclaration" && j !== "DeclareClass" && j !== "DeclareFunction" && j !== "TSDeclareFunction" && j !== "EnumDeclaration");
          }
          function D2(N, x2, b2) {
            let L = N.getValue();
            if (!L.source)
              return "";
            let M2 = [];
            return F(L, x2) || M2.push(" from"), M2.push(" ", b2("source")), M2;
          }
          function g2(N, x2, b2) {
            let L = N.getValue();
            if (F(L, x2))
              return "";
            let M2 = [" "];
            if (t(L.specifiers)) {
              let j = [], $ = [];
              N.each(() => {
                let V = N.getValue().type;
                if (V === "ExportNamespaceSpecifier" || V === "ExportDefaultSpecifier" || V === "ImportNamespaceSpecifier" || V === "ImportDefaultSpecifier")
                  j.push(b2());
                else if (V === "ExportSpecifier" || V === "ImportSpecifier")
                  $.push(b2());
                else
                  throw new Error("Unknown specifier type ".concat(JSON.stringify(V)));
              }, "specifiers"), M2.push(u(", ", j)), $.length > 0 && (j.length > 0 && M2.push(", "), $.length > 1 || j.length > 0 || L.specifiers.some((q) => m2(q)) ? M2.push(a3(["{", r([x2.bracketSpacing ? i2 : s2, u([",", i2], $)]), o(p(x2) ? "," : ""), x2.bracketSpacing ? i2 : s2, "}"])) : M2.push(["{", x2.bracketSpacing ? " " : "", ...$, x2.bracketSpacing ? " " : "", "}"]));
            } else
              M2.push("{}");
            return M2;
          }
          function F(N, x2) {
            let { type: b2, importKind: L, source: M2, specifiers: j } = N;
            return b2 !== "ImportDeclaration" || t(j) || L === "type" ? false : !/{\s*}/.test(x2.originalText.slice(T2(N), T2(M2)));
          }
          function l(N, x2, b2) {
            let L = N.getNode();
            return t(L.assertions) ? [" assert {", x2.bracketSpacing ? " " : "", u(", ", N.map(b2, "assertions")), x2.bracketSpacing ? " " : "", "}"] : "";
          }
          function E(N, x2, b2) {
            let L = N.getNode(), { type: M2 } = L, j = [], $ = M2 === "ImportSpecifier" ? L.importKind : L.exportKind;
            $ && $ !== "value" && j.push($, " ");
            let V = M2.startsWith("Import"), q = V ? "imported" : "local", Y3 = V ? "local" : "exported", H3 = L[q], R = L[Y3], Q = "", ee2 = "";
            return M2 === "ExportNamespaceSpecifier" || M2 === "ImportNamespaceSpecifier" ? Q = "*" : H3 && (Q = b2(q)), R && !y(L) && (ee2 = b2(Y3)), j.push(Q, Q && ee2 ? " as " : "", ee2), j;
          }
          function y(N) {
            if (N.type !== "ImportSpecifier" && N.type !== "ExportSpecifier")
              return false;
            let { local: x2, [N.type === "ImportSpecifier" ? "imported" : "exported"]: b2 } = N;
            if (x2.type !== b2.type || !A2(x2, b2))
              return false;
            if (h2(x2))
              return x2.value === b2.value && w2(x2) === w2(b2);
            switch (x2.type) {
              case "Identifier":
                return x2.name === b2.name;
              default:
                return false;
            }
          }
          n.exports = { printImportDeclaration: I2, printExportDeclaration: k2, printExportAllDeclaration: P, printModuleSpecifier: E };
        } }), zn2 = Z3({ "src/language-js/print/object.js"(e, n) {
          re2();
          var { printDanglingComments: t } = et2(), { builders: { line: s2, softline: a3, group: r, indent: u, ifBreak: i2, hardline: o } } = Oe2(), { getLast: c, hasNewlineInRange: v, hasNewline: m2, isNonEmptyArray: d4 } = Ue2(), { shouldPrintComma: p, hasComment: f, getComments: h2, CommentCheckFlags: w2, isNextLineEmpty: T2 } = Ke2(), { locStart: A2, locEnd: S2 } = st2(), { printOptionalToken: B, printTypeAnnotation: I2 } = ct2(), { shouldHugFunctionParameters: k2 } = Pr2(), { shouldHugType: P } = kr2(), { printHardlineAfterHeritage: C2 } = Zt();
          function D2(g2, F, l) {
            let E = F.semi ? ";" : "", y = g2.getValue(), N;
            y.type === "TSTypeLiteral" ? N = "members" : y.type === "TSInterfaceBody" ? N = "body" : N = "properties";
            let x2 = y.type === "ObjectTypeAnnotation", b2 = [N];
            x2 && b2.push("indexers", "callProperties", "internalSlots");
            let L = b2.map((W2) => y[W2][0]).sort((W2, X3) => A2(W2) - A2(X3))[0], M2 = g2.getParentNode(0), j = x2 && M2 && (M2.type === "InterfaceDeclaration" || M2.type === "DeclareInterface" || M2.type === "DeclareClass") && g2.getName() === "body", $ = y.type === "TSInterfaceBody" || j || y.type === "ObjectPattern" && M2.type !== "FunctionDeclaration" && M2.type !== "FunctionExpression" && M2.type !== "ArrowFunctionExpression" && M2.type !== "ObjectMethod" && M2.type !== "ClassMethod" && M2.type !== "ClassPrivateMethod" && M2.type !== "AssignmentPattern" && M2.type !== "CatchClause" && y.properties.some((W2) => W2.value && (W2.value.type === "ObjectPattern" || W2.value.type === "ArrayPattern")) || y.type !== "ObjectPattern" && L && v(F.originalText, A2(y), A2(L)), V = j ? ";" : y.type === "TSInterfaceBody" || y.type === "TSTypeLiteral" ? i2(E, ";") : ",", q = y.type === "RecordExpression" ? "#{" : y.exact ? "{|" : "{", Y3 = y.exact ? "|}" : "}", H3 = [];
            for (let W2 of b2)
              g2.each((X3) => {
                let ue2 = X3.getValue();
                H3.push({ node: ue2, printed: l(), loc: A2(ue2) });
              }, W2);
            b2.length > 1 && H3.sort((W2, X3) => W2.loc - X3.loc);
            let R = [], Q = H3.map((W2) => {
              let X3 = [...R, r(W2.printed)];
              return R = [V, s2], (W2.node.type === "TSPropertySignature" || W2.node.type === "TSMethodSignature" || W2.node.type === "TSConstructSignatureDeclaration") && f(W2.node, w2.PrettierIgnore) && R.shift(), T2(W2.node, F) && R.push(o), X3;
            });
            if (y.inexact) {
              let W2;
              if (f(y, w2.Dangling)) {
                let X3 = f(y, w2.Line);
                W2 = [t(g2, F, true), X3 || m2(F.originalText, S2(c(h2(y)))) ? o : s2, "..."];
              } else
                W2 = ["..."];
              Q.push([...R, ...W2]);
            }
            let ee2 = c(y[N]), te2 = !(y.inexact || ee2 && ee2.type === "RestElement" || ee2 && (ee2.type === "TSPropertySignature" || ee2.type === "TSCallSignatureDeclaration" || ee2.type === "TSMethodSignature" || ee2.type === "TSConstructSignatureDeclaration") && f(ee2, w2.PrettierIgnore)), oe2;
            if (Q.length === 0) {
              if (!f(y, w2.Dangling))
                return [q, Y3, I2(g2, F, l)];
              oe2 = r([q, t(g2, F), a3, Y3, B(g2), I2(g2, F, l)]);
            } else
              oe2 = [j && d4(y.properties) ? C2(M2) : "", q, u([F.bracketSpacing ? s2 : a3, ...Q]), i2(te2 && (V !== "," || p(F)) ? V : ""), F.bracketSpacing ? s2 : a3, Y3, B(g2), I2(g2, F, l)];
            return g2.match((W2) => W2.type === "ObjectPattern" && !W2.decorators, (W2, X3, ue2) => k2(W2) && (X3 === "params" || X3 === "parameters" || X3 === "this" || X3 === "rest") && ue2 === 0) || g2.match(P, (W2, X3) => X3 === "typeAnnotation", (W2, X3) => X3 === "typeAnnotation", (W2, X3, ue2) => k2(W2) && (X3 === "params" || X3 === "parameters" || X3 === "this" || X3 === "rest") && ue2 === 0) || !$ && g2.match((W2) => W2.type === "ObjectPattern", (W2) => W2.type === "AssignmentExpression" || W2.type === "VariableDeclarator") ? oe2 : r(oe2, { shouldBreak: $ });
          }
          n.exports = { printObject: D2 };
        } }), Um2 = Z3({ "src/language-js/print/flow.js"(e, n) {
          re2();
          var t = Xt2(), { printDanglingComments: s2 } = et2(), { printString: a3, printNumber: r } = Ue2(), { builders: { hardline: u, softline: i2, group: o, indent: c } } = Oe2(), { getParentExportDeclaration: v, isFunctionNotation: m2, isGetterOrSetter: d4, rawText: p, shouldPrintComma: f } = Ke2(), { locStart: h2, locEnd: w2 } = st2(), { printClass: T2 } = Zt(), { printOpaqueType: A2, printTypeAlias: S2, printIntersectionType: B, printUnionType: I2, printFunctionType: k2, printTupleType: P, printIndexedAccessType: C2 } = kr2(), { printInterface: D2 } = lo2(), { printTypeParameter: g2, printTypeParameters: F } = Ir2(), { printExportDeclaration: l, printExportAllDeclaration: E } = co2(), { printArrayItems: y } = Kt2(), { printObject: N } = zn2(), { printPropertyKey: x2 } = Qt2(), { printOptionalToken: b2, printTypeAnnotation: L, printRestSpread: M2 } = ct2();
          function j(V, q, Y3) {
            let H3 = V.getValue(), R = q.semi ? ";" : "", Q = [];
            switch (H3.type) {
              case "DeclareClass":
                return $(V, T2(V, q, Y3));
              case "DeclareFunction":
                return $(V, ["function ", Y3("id"), H3.predicate ? " " : "", Y3("predicate"), R]);
              case "DeclareModule":
                return $(V, ["module ", Y3("id"), " ", Y3("body")]);
              case "DeclareModuleExports":
                return $(V, ["module.exports", ": ", Y3("typeAnnotation"), R]);
              case "DeclareVariable":
                return $(V, ["var ", Y3("id"), R]);
              case "DeclareOpaqueType":
                return $(V, A2(V, q, Y3));
              case "DeclareInterface":
                return $(V, D2(V, q, Y3));
              case "DeclareTypeAlias":
                return $(V, S2(V, q, Y3));
              case "DeclareExportDeclaration":
                return $(V, l(V, q, Y3));
              case "DeclareExportAllDeclaration":
                return $(V, E(V, q, Y3));
              case "OpaqueType":
                return A2(V, q, Y3);
              case "TypeAlias":
                return S2(V, q, Y3);
              case "IntersectionTypeAnnotation":
                return B(V, q, Y3);
              case "UnionTypeAnnotation":
                return I2(V, q, Y3);
              case "FunctionTypeAnnotation":
                return k2(V, q, Y3);
              case "TupleTypeAnnotation":
                return P(V, q, Y3);
              case "GenericTypeAnnotation":
                return [Y3("id"), F(V, q, Y3, "typeParameters")];
              case "IndexedAccessType":
              case "OptionalIndexedAccessType":
                return C2(V, q, Y3);
              case "TypeAnnotation":
                return Y3("typeAnnotation");
              case "TypeParameter":
                return g2(V, q, Y3);
              case "TypeofTypeAnnotation":
                return ["typeof ", Y3("argument")];
              case "ExistsTypeAnnotation":
                return "*";
              case "EmptyTypeAnnotation":
                return "empty";
              case "MixedTypeAnnotation":
                return "mixed";
              case "ArrayTypeAnnotation":
                return [Y3("elementType"), "[]"];
              case "BooleanLiteralTypeAnnotation":
                return String(H3.value);
              case "EnumDeclaration":
                return ["enum ", Y3("id"), " ", Y3("body")];
              case "EnumBooleanBody":
              case "EnumNumberBody":
              case "EnumStringBody":
              case "EnumSymbolBody": {
                if (H3.type === "EnumSymbolBody" || H3.explicitType) {
                  let ee2 = null;
                  switch (H3.type) {
                    case "EnumBooleanBody":
                      ee2 = "boolean";
                      break;
                    case "EnumNumberBody":
                      ee2 = "number";
                      break;
                    case "EnumStringBody":
                      ee2 = "string";
                      break;
                    case "EnumSymbolBody":
                      ee2 = "symbol";
                      break;
                  }
                  Q.push("of ", ee2, " ");
                }
                if (H3.members.length === 0 && !H3.hasUnknownMembers)
                  Q.push(o(["{", s2(V, q), i2, "}"]));
                else {
                  let ee2 = H3.members.length > 0 ? [u, y(V, q, "members", Y3), H3.hasUnknownMembers || f(q) ? "," : ""] : [];
                  Q.push(o(["{", c([...ee2, ...H3.hasUnknownMembers ? [u, "..."] : []]), s2(V, q, true), u, "}"]));
                }
                return Q;
              }
              case "EnumBooleanMember":
              case "EnumNumberMember":
              case "EnumStringMember":
                return [Y3("id"), " = ", typeof H3.init == "object" ? Y3("init") : String(H3.init)];
              case "EnumDefaultedMember":
                return Y3("id");
              case "FunctionTypeParam": {
                let ee2 = H3.name ? Y3("name") : V.getParentNode().this === H3 ? "this" : "";
                return [ee2, b2(V), ee2 ? ": " : "", Y3("typeAnnotation")];
              }
              case "InterfaceDeclaration":
              case "InterfaceTypeAnnotation":
                return D2(V, q, Y3);
              case "ClassImplements":
              case "InterfaceExtends":
                return [Y3("id"), Y3("typeParameters")];
              case "NullableTypeAnnotation":
                return ["?", Y3("typeAnnotation")];
              case "Variance": {
                let { kind: ee2 } = H3;
                return t.ok(ee2 === "plus" || ee2 === "minus"), ee2 === "plus" ? "+" : "-";
              }
              case "ObjectTypeCallProperty":
                return H3.static && Q.push("static "), Q.push(Y3("value")), Q;
              case "ObjectTypeIndexer":
                return [H3.static ? "static " : "", H3.variance ? Y3("variance") : "", "[", Y3("id"), H3.id ? ": " : "", Y3("key"), "]: ", Y3("value")];
              case "ObjectTypeProperty": {
                let ee2 = "";
                return H3.proto ? ee2 = "proto " : H3.static && (ee2 = "static "), [ee2, d4(H3) ? H3.kind + " " : "", H3.variance ? Y3("variance") : "", x2(V, q, Y3), b2(V), m2(H3) ? "" : ": ", Y3("value")];
              }
              case "ObjectTypeAnnotation":
                return N(V, q, Y3);
              case "ObjectTypeInternalSlot":
                return [H3.static ? "static " : "", "[[", Y3("id"), "]]", b2(V), H3.method ? "" : ": ", Y3("value")];
              case "ObjectTypeSpreadProperty":
                return M2(V, q, Y3);
              case "QualifiedTypeofIdentifier":
              case "QualifiedTypeIdentifier":
                return [Y3("qualification"), ".", Y3("id")];
              case "StringLiteralTypeAnnotation":
                return a3(p(H3), q);
              case "NumberLiteralTypeAnnotation":
                t.strictEqual(typeof H3.value, "number");
              case "BigIntLiteralTypeAnnotation":
                return H3.extra ? r(H3.extra.raw) : r(H3.raw);
              case "TypeCastExpression":
                return ["(", Y3("expression"), L(V, q, Y3), ")"];
              case "TypeParameterDeclaration":
              case "TypeParameterInstantiation": {
                let ee2 = F(V, q, Y3, "params");
                if (q.parser === "flow") {
                  let te2 = h2(H3), oe2 = w2(H3), W2 = q.originalText.lastIndexOf("/*", te2), X3 = q.originalText.indexOf("*/", oe2);
                  if (W2 !== -1 && X3 !== -1) {
                    let ue2 = q.originalText.slice(W2 + 2, X3).trim();
                    if (ue2.startsWith("::") && !ue2.includes("/*") && !ue2.includes("*/"))
                      return ["/*:: ", ee2, " */"];
                  }
                }
                return ee2;
              }
              case "InferredPredicate":
                return "%checks";
              case "DeclaredPredicate":
                return ["%checks(", Y3("value"), ")"];
              case "AnyTypeAnnotation":
                return "any";
              case "BooleanTypeAnnotation":
                return "boolean";
              case "BigIntTypeAnnotation":
                return "bigint";
              case "NullLiteralTypeAnnotation":
                return "null";
              case "NumberTypeAnnotation":
                return "number";
              case "SymbolTypeAnnotation":
                return "symbol";
              case "StringTypeAnnotation":
                return "string";
              case "VoidTypeAnnotation":
                return "void";
              case "ThisTypeAnnotation":
                return "this";
              case "Node":
              case "Printable":
              case "SourceLocation":
              case "Position":
              case "Statement":
              case "Function":
              case "Pattern":
              case "Expression":
              case "Declaration":
              case "Specifier":
              case "NamedSpecifier":
              case "Comment":
              case "MemberTypeAnnotation":
              case "Type":
                throw new Error("unprintable type: " + JSON.stringify(H3.type));
            }
          }
          function $(V, q) {
            let Y3 = v(V);
            return Y3 ? (t.strictEqual(Y3.type, "DeclareExportDeclaration"), q) : ["declare ", q];
          }
          n.exports = { printFlow: j };
        } }), zm2 = Z3({ "src/language-js/utils/is-ts-keyword-type.js"(e, n) {
          re2();
          function t(s2) {
            let { type: a3 } = s2;
            return a3.startsWith("TS") && a3.endsWith("Keyword");
          }
          n.exports = t;
        } }), po2 = Z3({ "src/language-js/print/ternary.js"(e, n) {
          re2();
          var { hasNewlineInRange: t } = Ue2(), { isJsxNode: s2, getComments: a3, isCallExpression: r, isMemberExpression: u } = Ke2(), { locStart: i2, locEnd: o } = st2(), c = It2(), { builders: { line: v, softline: m2, group: d4, indent: p, align: f, ifBreak: h2, dedent: w2, breakParent: T2 } } = Oe2();
          function A2(P) {
            let C2 = [P];
            for (let D2 = 0; D2 < C2.length; D2++) {
              let g2 = C2[D2];
              for (let F of ["test", "consequent", "alternate"]) {
                let l = g2[F];
                if (s2(l))
                  return true;
                l.type === "ConditionalExpression" && C2.push(l);
              }
            }
            return false;
          }
          function S2(P, C2, D2) {
            let g2 = P.getValue(), F = g2.type === "ConditionalExpression", l = F ? "alternate" : "falseType", E = P.getParentNode(), y = F ? D2("test") : [D2("checkType"), " ", "extends", " ", D2("extendsType")];
            return E.type === g2.type && E[l] === g2 ? f(2, y) : y;
          }
          var B = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
          function I2(P) {
            let C2 = P.getValue();
            if (C2.type !== "ConditionalExpression")
              return false;
            let D2, g2 = C2;
            for (let F = 0; !D2; F++) {
              let l = P.getParentNode(F);
              if (r(l) && l.callee === g2 || u(l) && l.object === g2 || l.type === "TSNonNullExpression" && l.expression === g2) {
                g2 = l;
                continue;
              }
              l.type === "NewExpression" && l.callee === g2 || l.type === "TSAsExpression" && l.expression === g2 ? (D2 = P.getParentNode(F + 1), g2 = l) : D2 = l;
            }
            return g2 === C2 ? false : D2[B.get(D2.type)] === g2;
          }
          function k2(P, C2, D2) {
            let g2 = P.getValue(), F = g2.type === "ConditionalExpression", l = F ? "consequent" : "trueType", E = F ? "alternate" : "falseType", y = F ? ["test"] : ["checkType", "extendsType"], N = g2[l], x2 = g2[E], b2 = [], L = false, M2 = P.getParentNode(), j = M2.type === g2.type && y.some((ue2) => M2[ue2] === g2), $ = M2.type === g2.type && !j, V, q, Y3 = 0;
            do
              q = V || g2, V = P.getParentNode(Y3), Y3++;
            while (V && V.type === g2.type && y.every((ue2) => V[ue2] !== q));
            let H3 = V || M2, R = q;
            if (F && (s2(g2[y[0]]) || s2(N) || s2(x2) || A2(R))) {
              L = true, $ = true;
              let ue2 = (ie) => [h2("("), p([m2, ie]), m2, h2(")")], De2 = (ie) => ie.type === "NullLiteral" || ie.type === "Literal" && ie.value === null || ie.type === "Identifier" && ie.name === "undefined";
              b2.push(" ? ", De2(N) ? D2(l) : ue2(D2(l)), " : ", x2.type === g2.type || De2(x2) ? D2(E) : ue2(D2(E)));
            } else {
              let ue2 = [v, "? ", N.type === g2.type ? h2("", "(") : "", f(2, D2(l)), N.type === g2.type ? h2("", ")") : "", v, ": ", x2.type === g2.type ? D2(E) : f(2, D2(E))];
              b2.push(M2.type !== g2.type || M2[E] === g2 || j ? ue2 : C2.useTabs ? w2(p(ue2)) : f(Math.max(0, C2.tabWidth - 2), ue2));
            }
            let ee2 = [...y.map((ue2) => a3(g2[ue2])), a3(N), a3(x2)].flat().some((ue2) => c(ue2) && t(C2.originalText, i2(ue2), o(ue2))), te2 = (ue2) => M2 === H3 ? d4(ue2, { shouldBreak: ee2 }) : ee2 ? [ue2, T2] : ue2, oe2 = !L && (u(M2) || M2.type === "NGPipeExpression" && M2.left === g2) && !M2.computed, W2 = I2(P), X3 = te2([S2(P, C2, D2), $ ? b2 : p(b2), F && oe2 && !W2 ? m2 : ""]);
            return j || W2 ? d4([p([m2, X3]), m2]) : X3;
          }
          n.exports = { printTernary: k2 };
        } }), fo2 = Z3({ "src/language-js/print/statement.js"(e, n) {
          re2();
          var { builders: { hardline: t } } = Oe2(), s2 = jt2(), { getLeftSidePathName: a3, hasNakedLeftSide: r, isJsxNode: u, isTheOnlyJsxElementInMarkdown: i2, hasComment: o, CommentCheckFlags: c, isNextLineEmpty: v } = Ke2(), { shouldPrintParamsWithoutParens: m2 } = Lr2();
          function d4(B, I2, k2, P) {
            let C2 = B.getValue(), D2 = [], g2 = C2.type === "ClassBody", F = p(C2[P]);
            return B.each((l, E, y) => {
              let N = l.getValue();
              if (N.type === "EmptyStatement")
                return;
              let x2 = k2();
              !I2.semi && !g2 && !i2(I2, l) && f(l, I2) ? o(N, c.Leading) ? D2.push(k2([], { needsSemi: true })) : D2.push(";", x2) : D2.push(x2), !I2.semi && g2 && A2(N) && S2(N, y[E + 1]) && D2.push(";"), N !== F && (D2.push(t), v(N, I2) && D2.push(t));
            }, P), D2;
          }
          function p(B) {
            for (let I2 = B.length - 1; I2 >= 0; I2--) {
              let k2 = B[I2];
              if (k2.type !== "EmptyStatement")
                return k2;
            }
          }
          function f(B, I2) {
            return B.getNode().type !== "ExpressionStatement" ? false : B.call((P) => h2(P, I2), "expression");
          }
          function h2(B, I2) {
            let k2 = B.getValue();
            switch (k2.type) {
              case "ParenthesizedExpression":
              case "TypeCastExpression":
              case "ArrayExpression":
              case "ArrayPattern":
              case "TemplateLiteral":
              case "TemplateElement":
              case "RegExpLiteral":
                return true;
              case "ArrowFunctionExpression": {
                if (!m2(B, I2))
                  return true;
                break;
              }
              case "UnaryExpression": {
                let { prefix: P, operator: C2 } = k2;
                if (P && (C2 === "+" || C2 === "-"))
                  return true;
                break;
              }
              case "BindExpression": {
                if (!k2.object)
                  return true;
                break;
              }
              case "Literal": {
                if (k2.regex)
                  return true;
                break;
              }
              default:
                if (u(k2))
                  return true;
            }
            return s2(B, I2) ? true : r(k2) ? B.call((P) => h2(P, I2), ...a3(B, k2)) : false;
          }
          function w2(B, I2, k2) {
            return d4(B, I2, k2, "body");
          }
          function T2(B, I2, k2) {
            return d4(B, I2, k2, "consequent");
          }
          var A2 = (B) => {
            let { type: I2 } = B;
            return I2 === "ClassProperty" || I2 === "PropertyDefinition" || I2 === "ClassPrivateProperty" || I2 === "ClassAccessorProperty";
          };
          function S2(B, I2) {
            let k2 = B.key && B.key.name;
            if ((k2 === "static" || k2 === "get" || k2 === "set") && !B.value && !B.typeAnnotation)
              return true;
            if (!I2 || I2.static || I2.accessibility)
              return false;
            if (!I2.computed) {
              let P = I2.key && I2.key.name;
              if (P === "in" || P === "instanceof")
                return true;
            }
            if (A2(I2) && I2.variance && !I2.static && !I2.declare)
              return true;
            switch (I2.type) {
              case "ClassProperty":
              case "PropertyDefinition":
              case "TSAbstractPropertyDefinition":
                return I2.computed;
              case "MethodDefinition":
              case "TSAbstractMethodDefinition":
              case "ClassMethod":
              case "ClassPrivateMethod": {
                if ((I2.value ? I2.value.async : I2.async) || I2.kind === "get" || I2.kind === "set")
                  return false;
                let C2 = I2.value ? I2.value.generator : I2.generator;
                return !!(I2.computed || C2);
              }
              case "TSIndexSignature":
                return true;
            }
            return false;
          }
          n.exports = { printBody: w2, printSwitchCaseConsequent: T2 };
        } }), Do2 = Z3({ "src/language-js/print/block.js"(e, n) {
          re2();
          var { printDanglingComments: t } = et2(), { isNonEmptyArray: s2 } = Ue2(), { builders: { hardline: a3, indent: r } } = Oe2(), { hasComment: u, CommentCheckFlags: i2, isNextLineEmpty: o } = Ke2(), { printHardlineAfterHeritage: c } = Zt(), { printBody: v } = fo2();
          function m2(p, f, h2) {
            let w2 = p.getValue(), T2 = [];
            if (w2.type === "StaticBlock" && T2.push("static "), w2.type === "ClassBody" && s2(w2.body)) {
              let S2 = p.getParentNode();
              T2.push(c(S2));
            }
            T2.push("{");
            let A2 = d4(p, f, h2);
            if (A2)
              T2.push(r([a3, A2]), a3);
            else {
              let S2 = p.getParentNode(), B = p.getParentNode(1);
              S2.type === "ArrowFunctionExpression" || S2.type === "FunctionExpression" || S2.type === "FunctionDeclaration" || S2.type === "ObjectMethod" || S2.type === "ClassMethod" || S2.type === "ClassPrivateMethod" || S2.type === "ForStatement" || S2.type === "WhileStatement" || S2.type === "DoWhileStatement" || S2.type === "DoExpression" || S2.type === "CatchClause" && !B.finalizer || S2.type === "TSModuleDeclaration" || S2.type === "TSDeclareFunction" || w2.type === "StaticBlock" || w2.type === "ClassBody" || T2.push(a3);
            }
            return T2.push("}"), T2;
          }
          function d4(p, f, h2) {
            let w2 = p.getValue(), T2 = s2(w2.directives), A2 = w2.body.some((I2) => I2.type !== "EmptyStatement"), S2 = u(w2, i2.Dangling);
            if (!T2 && !A2 && !S2)
              return "";
            let B = [];
            if (T2 && p.each((I2, k2, P) => {
              B.push(h2()), (k2 < P.length - 1 || A2 || S2) && (B.push(a3), o(I2.getValue(), f) && B.push(a3));
            }, "directives"), A2 && B.push(v(p, f, h2)), S2 && B.push(t(p, f, true)), w2.type === "Program") {
              let I2 = p.getParentNode();
              (!I2 || I2.type !== "ModuleExpression") && B.push(a3);
            }
            return B;
          }
          n.exports = { printBlock: m2, printBlockBody: d4 };
        } }), Xm2 = Z3({ "src/language-js/print/typescript.js"(e, n) {
          re2();
          var { printDanglingComments: t } = et2(), { hasNewlineInRange: s2 } = Ue2(), { builders: { join: a3, line: r, hardline: u, softline: i2, group: o, indent: c, conditionalGroup: v, ifBreak: m2 } } = Oe2(), { isLiteral: d4, getTypeScriptMappedTypeModifier: p, shouldPrintComma: f, isCallExpression: h2, isMemberExpression: w2 } = Ke2(), T2 = zm2(), { locStart: A2, locEnd: S2 } = st2(), { printOptionalToken: B, printTypeScriptModifiers: I2 } = ct2(), { printTernary: k2 } = po2(), { printFunctionParameters: P, shouldGroupFunctionParameters: C2 } = Pr2(), { printTemplateLiteral: D2 } = Lt2(), { printArrayItems: g2 } = Kt2(), { printObject: F } = zn2(), { printClassProperty: l, printClassMethod: E } = Zt(), { printTypeParameter: y, printTypeParameters: N } = Ir2(), { printPropertyKey: x2 } = Qt2(), { printFunction: b2, printMethodInternal: L } = Lr2(), { printInterface: M2 } = lo2(), { printBlock: j } = Do2(), { printTypeAlias: $, printIntersectionType: V, printUnionType: q, printFunctionType: Y3, printTupleType: H3, printIndexedAccessType: R, printJSDocType: Q } = kr2();
          function ee2(te2, oe2, W2) {
            let X3 = te2.getValue();
            if (!X3.type.startsWith("TS"))
              return;
            if (T2(X3))
              return X3.type.slice(2, -7).toLowerCase();
            let ue2 = oe2.semi ? ";" : "", De2 = [];
            switch (X3.type) {
              case "TSThisType":
                return "this";
              case "TSTypeAssertion": {
                let ie = !(X3.expression.type === "ArrayExpression" || X3.expression.type === "ObjectExpression"), G = o(["<", c([i2, W2("typeAnnotation")]), i2, ">"]), z = [m2("("), c([i2, W2("expression")]), i2, m2(")")];
                return ie ? v([[G, W2("expression")], [G, o(z, { shouldBreak: true })], [G, W2("expression")]]) : o([G, W2("expression")]);
              }
              case "TSDeclareFunction":
                return b2(te2, W2, oe2);
              case "TSExportAssignment":
                return ["export = ", W2("expression"), ue2];
              case "TSModuleBlock":
                return j(te2, oe2, W2);
              case "TSInterfaceBody":
              case "TSTypeLiteral":
                return F(te2, oe2, W2);
              case "TSTypeAliasDeclaration":
                return $(te2, oe2, W2);
              case "TSQualifiedName":
                return a3(".", [W2("left"), W2("right")]);
              case "TSAbstractMethodDefinition":
              case "TSDeclareMethod":
                return E(te2, oe2, W2);
              case "TSAbstractPropertyDefinition":
                return l(te2, oe2, W2);
              case "TSInterfaceHeritage":
              case "TSExpressionWithTypeArguments":
                return De2.push(W2("expression")), X3.typeParameters && De2.push(W2("typeParameters")), De2;
              case "TSTemplateLiteralType":
                return D2(te2, W2, oe2);
              case "TSNamedTupleMember":
                return [W2("label"), X3.optional ? "?" : "", ": ", W2("elementType")];
              case "TSRestType":
                return ["...", W2("typeAnnotation")];
              case "TSOptionalType":
                return [W2("typeAnnotation"), "?"];
              case "TSInterfaceDeclaration":
                return M2(te2, oe2, W2);
              case "TSClassImplements":
                return [W2("expression"), W2("typeParameters")];
              case "TSTypeParameterDeclaration":
              case "TSTypeParameterInstantiation":
                return N(te2, oe2, W2, "params");
              case "TSTypeParameter":
                return y(te2, oe2, W2);
              case "TSAsExpression": {
                De2.push(W2("expression"), " as ", W2("typeAnnotation"));
                let ie = te2.getParentNode();
                return h2(ie) && ie.callee === X3 || w2(ie) && ie.object === X3 ? o([c([i2, ...De2]), i2]) : De2;
              }
              case "TSArrayType":
                return [W2("elementType"), "[]"];
              case "TSPropertySignature":
                return X3.readonly && De2.push("readonly "), De2.push(x2(te2, oe2, W2), B(te2)), X3.typeAnnotation && De2.push(": ", W2("typeAnnotation")), X3.initializer && De2.push(" = ", W2("initializer")), De2;
              case "TSParameterProperty":
                return X3.accessibility && De2.push(X3.accessibility + " "), X3.export && De2.push("export "), X3.static && De2.push("static "), X3.override && De2.push("override "), X3.readonly && De2.push("readonly "), De2.push(W2("parameter")), De2;
              case "TSTypeQuery":
                return ["typeof ", W2("exprName"), W2("typeParameters")];
              case "TSIndexSignature": {
                let ie = te2.getParentNode(), G = X3.parameters.length > 1 ? m2(f(oe2) ? "," : "") : "", z = o([c([i2, a3([", ", i2], te2.map(W2, "parameters"))]), G, i2]);
                return [X3.export ? "export " : "", X3.accessibility ? [X3.accessibility, " "] : "", X3.static ? "static " : "", X3.readonly ? "readonly " : "", X3.declare ? "declare " : "", "[", X3.parameters ? z : "", X3.typeAnnotation ? "]: " : "]", X3.typeAnnotation ? W2("typeAnnotation") : "", ie.type === "ClassBody" ? ue2 : ""];
              }
              case "TSTypePredicate":
                return [X3.asserts ? "asserts " : "", W2("parameterName"), X3.typeAnnotation ? [" is ", W2("typeAnnotation")] : ""];
              case "TSNonNullExpression":
                return [W2("expression"), "!"];
              case "TSImportType":
                return [X3.isTypeOf ? "typeof " : "", "import(", W2(X3.parameter ? "parameter" : "argument"), ")", X3.qualifier ? [".", W2("qualifier")] : "", N(te2, oe2, W2, "typeParameters")];
              case "TSLiteralType":
                return W2("literal");
              case "TSIndexedAccessType":
                return R(te2, oe2, W2);
              case "TSConstructSignatureDeclaration":
              case "TSCallSignatureDeclaration":
              case "TSConstructorType": {
                if (X3.type === "TSConstructorType" && X3.abstract && De2.push("abstract "), X3.type !== "TSCallSignatureDeclaration" && De2.push("new "), De2.push(o(P(te2, W2, oe2, false, true))), X3.returnType || X3.typeAnnotation) {
                  let ie = X3.type === "TSConstructorType";
                  De2.push(ie ? " => " : ": ", W2("returnType"), W2("typeAnnotation"));
                }
                return De2;
              }
              case "TSTypeOperator":
                return [X3.operator, " ", W2("typeAnnotation")];
              case "TSMappedType": {
                let ie = s2(oe2.originalText, A2(X3), S2(X3));
                return o(["{", c([oe2.bracketSpacing ? r : i2, X3.readonly ? [p(X3.readonly, "readonly"), " "] : "", I2(te2, oe2, W2), W2("typeParameter"), X3.optional ? p(X3.optional, "?") : "", X3.typeAnnotation ? ": " : "", W2("typeAnnotation"), m2(ue2)]), t(te2, oe2, true), oe2.bracketSpacing ? r : i2, "}"], { shouldBreak: ie });
              }
              case "TSMethodSignature": {
                let ie = X3.kind && X3.kind !== "method" ? "".concat(X3.kind, " ") : "";
                De2.push(X3.accessibility ? [X3.accessibility, " "] : "", ie, X3.export ? "export " : "", X3.static ? "static " : "", X3.readonly ? "readonly " : "", X3.abstract ? "abstract " : "", X3.declare ? "declare " : "", X3.computed ? "[" : "", W2("key"), X3.computed ? "]" : "", B(te2));
                let G = P(te2, W2, oe2, false, true), z = X3.returnType ? "returnType" : "typeAnnotation", U = X3[z], le2 = U ? W2(z) : "", ge2 = C2(X3, le2);
                return De2.push(ge2 ? o(G) : G), U && De2.push(": ", o(le2)), o(De2);
              }
              case "TSNamespaceExportDeclaration":
                return De2.push("export as namespace ", W2("id")), oe2.semi && De2.push(";"), o(De2);
              case "TSEnumDeclaration":
                return X3.declare && De2.push("declare "), X3.modifiers && De2.push(I2(te2, oe2, W2)), X3.const && De2.push("const "), De2.push("enum ", W2("id"), " "), X3.members.length === 0 ? De2.push(o(["{", t(te2, oe2), i2, "}"])) : De2.push(o(["{", c([u, g2(te2, oe2, "members", W2), f(oe2, "es5") ? "," : ""]), t(te2, oe2, true), u, "}"])), De2;
              case "TSEnumMember":
                return X3.computed ? De2.push("[", W2("id"), "]") : De2.push(W2("id")), X3.initializer && De2.push(" = ", W2("initializer")), De2;
              case "TSImportEqualsDeclaration":
                return X3.isExport && De2.push("export "), De2.push("import "), X3.importKind && X3.importKind !== "value" && De2.push(X3.importKind, " "), De2.push(W2("id"), " = ", W2("moduleReference")), oe2.semi && De2.push(";"), o(De2);
              case "TSExternalModuleReference":
                return ["require(", W2("expression"), ")"];
              case "TSModuleDeclaration": {
                let ie = te2.getParentNode(), G = d4(X3.id), z = ie.type === "TSModuleDeclaration", U = X3.body && X3.body.type === "TSModuleDeclaration";
                if (z)
                  De2.push(".");
                else {
                  X3.declare && De2.push("declare "), De2.push(I2(te2, oe2, W2));
                  let le2 = oe2.originalText.slice(A2(X3), A2(X3.id));
                  X3.id.type === "Identifier" && X3.id.name === "global" && !/namespace|module/.test(le2) || De2.push(G || /(?:^|\s)module(?:\s|$)/.test(le2) ? "module " : "namespace ");
                }
                return De2.push(W2("id")), U ? De2.push(W2("body")) : X3.body ? De2.push(" ", o(W2("body"))) : De2.push(ue2), De2;
              }
              case "TSConditionalType":
                return k2(te2, oe2, W2);
              case "TSInferType":
                return ["infer", " ", W2("typeParameter")];
              case "TSIntersectionType":
                return V(te2, oe2, W2);
              case "TSUnionType":
                return q(te2, oe2, W2);
              case "TSFunctionType":
                return Y3(te2, oe2, W2);
              case "TSTupleType":
                return H3(te2, oe2, W2);
              case "TSTypeReference":
                return [W2("typeName"), N(te2, oe2, W2, "typeParameters")];
              case "TSTypeAnnotation":
                return W2("typeAnnotation");
              case "TSEmptyBodyFunctionExpression":
                return L(te2, oe2, W2);
              case "TSJSDocAllType":
                return "*";
              case "TSJSDocUnknownType":
                return "?";
              case "TSJSDocNullableType":
                return Q(te2, W2, "?");
              case "TSJSDocNonNullableType":
                return Q(te2, W2, "!");
              case "TSInstantiationExpression":
                return [W2("expression"), W2("typeParameters")];
              default:
                throw new Error("Unknown TypeScript node type: ".concat(JSON.stringify(X3.type), "."));
            }
          }
          n.exports = { printTypescript: ee2 };
        } }), Km2 = Z3({ "src/language-js/print/comment.js"(e, n) {
          re2();
          var { hasNewline: t } = Ue2(), { builders: { join: s2, hardline: a3 }, utils: { replaceTextEndOfLine: r } } = Oe2(), { isLineComment: u } = Ke2(), { locStart: i2, locEnd: o } = st2(), c = It2();
          function v(p, f) {
            let h2 = p.getValue();
            if (u(h2))
              return f.originalText.slice(i2(h2), o(h2)).trimEnd();
            if (c(h2)) {
              if (m2(h2)) {
                let A2 = d4(h2);
                return h2.trailing && !t(f.originalText, i2(h2), { backwards: true }) ? [a3, A2] : A2;
              }
              let w2 = o(h2), T2 = f.originalText.slice(w2 - 3, w2) === "*-/";
              return ["/*", r(h2.value), T2 ? "*-/" : "*/"];
            }
            throw new Error("Not a comment: " + JSON.stringify(h2));
          }
          function m2(p) {
            let f = "*".concat(p.value, "*").split(`
`);
            return f.length > 1 && f.every((h2) => h2.trim()[0] === "*");
          }
          function d4(p) {
            let f = p.value.split(`
`);
            return ["/*", s2(a3, f.map((h2, w2) => w2 === 0 ? h2.trimEnd() : " " + (w2 < f.length - 1 ? h2.trim() : h2.trimStart()))), "*/"];
          }
          n.exports = { printComment: v };
        } }), Ym2 = Z3({ "src/language-js/print/literal.js"(e, n) {
          re2();
          var { printString: t, printNumber: s2 } = Ue2();
          function a3(i2, o) {
            let c = i2.getNode();
            switch (c.type) {
              case "RegExpLiteral":
                return u(c);
              case "BigIntLiteral":
                return r(c.bigint || c.extra.raw);
              case "NumericLiteral":
                return s2(c.extra.raw);
              case "StringLiteral":
                return t(c.extra.raw, o);
              case "NullLiteral":
                return "null";
              case "BooleanLiteral":
                return String(c.value);
              case "DecimalLiteral":
                return s2(c.value) + "m";
              case "Literal": {
                if (c.regex)
                  return u(c.regex);
                if (c.bigint)
                  return r(c.raw);
                if (c.decimal)
                  return s2(c.decimal) + "m";
                let { value: v } = c;
                return typeof v == "number" ? s2(c.raw) : typeof v == "string" ? t(c.raw, o) : String(v);
              }
            }
          }
          function r(i2) {
            return i2.toLowerCase();
          }
          function u(i2) {
            let { pattern: o, flags: c } = i2;
            return c = [...c].sort().join(""), "/".concat(o, "/").concat(c);
          }
          n.exports = { printLiteral: a3 };
        } }), Qm2 = Z3({ "src/language-js/printer-estree.js"(e, n) {
          re2();
          var { printDanglingComments: t } = et2(), { hasNewline: s2 } = Ue2(), { builders: { join: a3, line: r, hardline: u, softline: i2, group: o, indent: c }, utils: { replaceTextEndOfLine: v } } = Oe2(), m2 = Im2(), d4 = Lm2(), { insertPragma: p } = no2(), f = uo2(), h2 = jt2(), w2 = so2(), { hasFlowShorthandAnnotationComment: T2, hasComment: A2, CommentCheckFlags: S2, isTheOnlyJsxElementInMarkdown: B, isLineComment: I2, isNextLineEmpty: k2, needsHardlineAfterDanglingComment: P, rawText: C2, hasIgnoreComment: D2, isCallExpression: g2, isMemberExpression: F, markerForIfWithoutBlockAndSameLineComment: l } = Ke2(), { locStart: E, locEnd: y } = st2(), N = It2(), { printHtmlBinding: x2, isVueEventBindingExpression: b2 } = $m2(), { printAngular: L } = Hm2(), { printJsx: M2, hasJsxIgnoreComment: j } = Gm2(), { printFlow: $ } = Um2(), { printTypescript: V } = Xm2(), { printOptionalToken: q, printBindExpressionCallee: Y3, printTypeAnnotation: H3, adjustClause: R, printRestSpread: Q, printDefiniteToken: ee2 } = ct2(), { printImportDeclaration: te2, printExportDeclaration: oe2, printExportAllDeclaration: W2, printModuleSpecifier: X3 } = co2(), { printTernary: ue2 } = po2(), { printTemplateLiteral: De2 } = Lt2(), { printArray: ie } = Kt2(), { printObject: G } = zn2(), { printClass: z, printClassMethod: U, printClassProperty: le2 } = Zt(), { printProperty: ge2 } = Qt2(), { printFunction: Ae2, printArrowFunction: Ne2, printMethod: ke2, printReturnStatement: ce, printThrowStatement: pe } = Lr2(), { printCallExpression: de2 } = oo2(), { printVariableDeclarator: ae2, printAssignmentExpression: ve2 } = Yt2(), { printBinaryishExpression: K } = Jn2(), { printSwitchCaseConsequent: he2 } = fo2(), { printMemberExpression: ye2 } = ao2(), { printBlock: Ce2, printBlockBody: Ie2 } = Do2(), { printComment: Fe2 } = Km2(), { printLiteral: me2 } = Ym2(), { printDecorators: _ } = Un2();
          function J2(Be, Pe2, Se2, Qe) {
            let xe2 = ne(Be, Pe2, Se2, Qe);
            if (!xe2)
              return "";
            let Xe2 = Be.getValue(), { type: _e2 } = Xe2;
            if (_e2 === "ClassMethod" || _e2 === "ClassPrivateMethod" || _e2 === "ClassProperty" || _e2 === "ClassAccessorProperty" || _e2 === "PropertyDefinition" || _e2 === "TSAbstractPropertyDefinition" || _e2 === "ClassPrivateProperty" || _e2 === "MethodDefinition" || _e2 === "TSAbstractMethodDefinition" || _e2 === "TSDeclareMethod")
              return xe2;
            let je2 = [xe2], Re2 = _(Be, Pe2, Se2), be2 = Xe2.type === "ClassExpression" && Re2;
            if (Re2 && (je2 = [...Re2, xe2], !be2))
              return o(je2);
            if (!h2(Be, Pe2))
              return Qe && Qe.needsSemi && je2.unshift(";"), je2.length === 1 && je2[0] === xe2 ? xe2 : je2;
            if (be2 && (je2 = [c([r, ...je2])]), je2.unshift("("), Qe && Qe.needsSemi && je2.unshift(";"), T2(Xe2)) {
              let [qe2] = Xe2.trailingComments;
              je2.push(" /*", qe2.value.trimStart(), "*/"), qe2.printed = true;
            }
            return be2 && je2.push(r), je2.push(")"), je2;
          }
          function ne(Be, Pe2, Se2, Qe) {
            let xe2 = Be.getValue(), Xe2 = Pe2.semi ? ";" : "";
            if (!xe2)
              return "";
            if (typeof xe2 == "string")
              return xe2;
            for (let je2 of [me2, x2, L, M2, $, V]) {
              let Re2 = je2(Be, Pe2, Se2);
              if (typeof Re2 < "u")
                return Re2;
            }
            let _e2 = [];
            switch (xe2.type) {
              case "JsExpressionRoot":
                return Se2("node");
              case "JsonRoot":
                return [Se2("node"), u];
              case "File":
                return xe2.program && xe2.program.interpreter && _e2.push(Se2(["program", "interpreter"])), _e2.push(Se2("program")), _e2;
              case "Program":
                return Ie2(Be, Pe2, Se2);
              case "EmptyStatement":
                return "";
              case "ExpressionStatement": {
                if (xe2.directive)
                  return [Ee(xe2.expression, Pe2), Xe2];
                if (Pe2.parser === "__vue_event_binding" || Pe2.parser === "__vue_ts_event_binding") {
                  let Re2 = Be.getParentNode();
                  if (Re2.type === "Program" && Re2.body.length === 1 && Re2.body[0] === xe2)
                    return [Se2("expression"), b2(xe2.expression) ? ";" : ""];
                }
                let je2 = t(Be, Pe2, true, (Re2) => {
                  let { marker: be2 } = Re2;
                  return be2 === l;
                });
                return [Se2("expression"), B(Pe2, Be) ? "" : Xe2, je2 ? [" ", je2] : ""];
              }
              case "ParenthesizedExpression":
                return !A2(xe2.expression) && (xe2.expression.type === "ObjectExpression" || xe2.expression.type === "ArrayExpression") ? ["(", Se2("expression"), ")"] : o(["(", c([i2, Se2("expression")]), i2, ")"]);
              case "AssignmentExpression":
                return ve2(Be, Pe2, Se2);
              case "VariableDeclarator":
                return ae2(Be, Pe2, Se2);
              case "BinaryExpression":
              case "LogicalExpression":
                return K(Be, Pe2, Se2);
              case "AssignmentPattern":
                return [Se2("left"), " = ", Se2("right")];
              case "OptionalMemberExpression":
              case "MemberExpression":
                return ye2(Be, Pe2, Se2);
              case "MetaProperty":
                return [Se2("meta"), ".", Se2("property")];
              case "BindExpression":
                return xe2.object && _e2.push(Se2("object")), _e2.push(o(c([i2, Y3(Be, Pe2, Se2)]))), _e2;
              case "Identifier":
                return [xe2.name, q(Be), ee2(Be), H3(Be, Pe2, Se2)];
              case "V8IntrinsicIdentifier":
                return ["%", xe2.name];
              case "SpreadElement":
              case "SpreadElementPattern":
              case "SpreadProperty":
              case "SpreadPropertyPattern":
              case "RestElement":
                return Q(Be, Pe2, Se2);
              case "FunctionDeclaration":
              case "FunctionExpression":
                return Ae2(Be, Se2, Pe2, Qe);
              case "ArrowFunctionExpression":
                return Ne2(Be, Pe2, Se2, Qe);
              case "YieldExpression":
                return _e2.push("yield"), xe2.delegate && _e2.push("*"), xe2.argument && _e2.push(" ", Se2("argument")), _e2;
              case "AwaitExpression": {
                if (_e2.push("await"), xe2.argument) {
                  _e2.push(" ", Se2("argument"));
                  let je2 = Be.getParentNode();
                  if (g2(je2) && je2.callee === xe2 || F(je2) && je2.object === xe2) {
                    _e2 = [c([i2, ..._e2]), i2];
                    let Re2 = Be.findAncestor((be2) => be2.type === "AwaitExpression" || be2.type === "BlockStatement");
                    if (!Re2 || Re2.type !== "AwaitExpression")
                      return o(_e2);
                  }
                }
                return _e2;
              }
              case "ExportDefaultDeclaration":
              case "ExportNamedDeclaration":
                return oe2(Be, Pe2, Se2);
              case "ExportAllDeclaration":
                return W2(Be, Pe2, Se2);
              case "ImportDeclaration":
                return te2(Be, Pe2, Se2);
              case "ImportSpecifier":
              case "ExportSpecifier":
              case "ImportNamespaceSpecifier":
              case "ExportNamespaceSpecifier":
              case "ImportDefaultSpecifier":
              case "ExportDefaultSpecifier":
                return X3(Be, Pe2, Se2);
              case "ImportAttribute":
                return [Se2("key"), ": ", Se2("value")];
              case "Import":
                return "import";
              case "BlockStatement":
              case "StaticBlock":
              case "ClassBody":
                return Ce2(Be, Pe2, Se2);
              case "ThrowStatement":
                return pe(Be, Pe2, Se2);
              case "ReturnStatement":
                return ce(Be, Pe2, Se2);
              case "NewExpression":
              case "ImportExpression":
              case "OptionalCallExpression":
              case "CallExpression":
                return de2(Be, Pe2, Se2);
              case "ObjectExpression":
              case "ObjectPattern":
              case "RecordExpression":
                return G(Be, Pe2, Se2);
              case "ObjectProperty":
              case "Property":
                return xe2.method || xe2.kind === "get" || xe2.kind === "set" ? ke2(Be, Pe2, Se2) : ge2(Be, Pe2, Se2);
              case "ObjectMethod":
                return ke2(Be, Pe2, Se2);
              case "Decorator":
                return ["@", Se2("expression")];
              case "ArrayExpression":
              case "ArrayPattern":
              case "TupleExpression":
                return ie(Be, Pe2, Se2);
              case "SequenceExpression": {
                let je2 = Be.getParentNode(0);
                if (je2.type === "ExpressionStatement" || je2.type === "ForStatement") {
                  let Re2 = [];
                  return Be.each((be2, Le2) => {
                    Le2 === 0 ? Re2.push(Se2()) : Re2.push(",", c([r, Se2()]));
                  }, "expressions"), o(Re2);
                }
                return o(a3([",", r], Be.map(Se2, "expressions")));
              }
              case "ThisExpression":
                return "this";
              case "Super":
                return "super";
              case "Directive":
                return [Se2("value"), Xe2];
              case "DirectiveLiteral":
                return Ee(xe2, Pe2);
              case "UnaryExpression":
                return _e2.push(xe2.operator), /[a-z]$/.test(xe2.operator) && _e2.push(" "), A2(xe2.argument) ? _e2.push(o(["(", c([i2, Se2("argument")]), i2, ")"])) : _e2.push(Se2("argument")), _e2;
              case "UpdateExpression":
                return _e2.push(Se2("argument"), xe2.operator), xe2.prefix && _e2.reverse(), _e2;
              case "ConditionalExpression":
                return ue2(Be, Pe2, Se2);
              case "VariableDeclaration": {
                let je2 = Be.map(Se2, "declarations"), Re2 = Be.getParentNode(), be2 = Re2.type === "ForStatement" || Re2.type === "ForInStatement" || Re2.type === "ForOfStatement", Le2 = xe2.declarations.some((se) => se.init), qe2;
                return je2.length === 1 && !A2(xe2.declarations[0]) ? qe2 = je2[0] : je2.length > 0 && (qe2 = c(je2[0])), _e2 = [xe2.declare ? "declare " : "", xe2.kind, qe2 ? [" ", qe2] : "", c(je2.slice(1).map((se) => [",", Le2 && !be2 ? u : r, se]))], be2 && Re2.body !== xe2 || _e2.push(Xe2), o(_e2);
              }
              case "WithStatement":
                return o(["with (", Se2("object"), ")", R(xe2.body, Se2("body"))]);
              case "IfStatement": {
                let je2 = R(xe2.consequent, Se2("consequent")), Re2 = o(["if (", o([c([i2, Se2("test")]), i2]), ")", je2]);
                if (_e2.push(Re2), xe2.alternate) {
                  let be2 = A2(xe2.consequent, S2.Trailing | S2.Line) || P(xe2), Le2 = xe2.consequent.type === "BlockStatement" && !be2;
                  _e2.push(Le2 ? " " : u), A2(xe2, S2.Dangling) && _e2.push(t(Be, Pe2, true), be2 ? u : " "), _e2.push("else", o(R(xe2.alternate, Se2("alternate"), xe2.alternate.type === "IfStatement")));
                }
                return _e2;
              }
              case "ForStatement": {
                let je2 = R(xe2.body, Se2("body")), Re2 = t(Be, Pe2, true), be2 = Re2 ? [Re2, i2] : "";
                return !xe2.init && !xe2.test && !xe2.update ? [be2, o(["for (;;)", je2])] : [be2, o(["for (", o([c([i2, Se2("init"), ";", r, Se2("test"), ";", r, Se2("update")]), i2]), ")", je2])];
              }
              case "WhileStatement":
                return o(["while (", o([c([i2, Se2("test")]), i2]), ")", R(xe2.body, Se2("body"))]);
              case "ForInStatement":
                return o(["for (", Se2("left"), " in ", Se2("right"), ")", R(xe2.body, Se2("body"))]);
              case "ForOfStatement":
                return o(["for", xe2.await ? " await" : "", " (", Se2("left"), " of ", Se2("right"), ")", R(xe2.body, Se2("body"))]);
              case "DoWhileStatement": {
                let je2 = R(xe2.body, Se2("body"));
                return _e2 = [o(["do", je2])], xe2.body.type === "BlockStatement" ? _e2.push(" ") : _e2.push(u), _e2.push("while (", o([c([i2, Se2("test")]), i2]), ")", Xe2), _e2;
              }
              case "DoExpression":
                return [xe2.async ? "async " : "", "do ", Se2("body")];
              case "BreakStatement":
                return _e2.push("break"), xe2.label && _e2.push(" ", Se2("label")), _e2.push(Xe2), _e2;
              case "ContinueStatement":
                return _e2.push("continue"), xe2.label && _e2.push(" ", Se2("label")), _e2.push(Xe2), _e2;
              case "LabeledStatement":
                return xe2.body.type === "EmptyStatement" ? [Se2("label"), ":;"] : [Se2("label"), ": ", Se2("body")];
              case "TryStatement":
                return ["try ", Se2("block"), xe2.handler ? [" ", Se2("handler")] : "", xe2.finalizer ? [" finally ", Se2("finalizer")] : ""];
              case "CatchClause":
                if (xe2.param) {
                  let je2 = A2(xe2.param, (be2) => !N(be2) || be2.leading && s2(Pe2.originalText, y(be2)) || be2.trailing && s2(Pe2.originalText, E(be2), { backwards: true })), Re2 = Se2("param");
                  return ["catch ", je2 ? ["(", c([i2, Re2]), i2, ") "] : ["(", Re2, ") "], Se2("body")];
                }
                return ["catch ", Se2("body")];
              case "SwitchStatement":
                return [o(["switch (", c([i2, Se2("discriminant")]), i2, ")"]), " {", xe2.cases.length > 0 ? c([u, a3(u, Be.map((je2, Re2, be2) => {
                  let Le2 = je2.getValue();
                  return [Se2(), Re2 !== be2.length - 1 && k2(Le2, Pe2) ? u : ""];
                }, "cases"))]) : "", u, "}"];
              case "SwitchCase": {
                xe2.test ? _e2.push("case ", Se2("test"), ":") : _e2.push("default:"), A2(xe2, S2.Dangling) && _e2.push(" ", t(Be, Pe2, true));
                let je2 = xe2.consequent.filter((Re2) => Re2.type !== "EmptyStatement");
                if (je2.length > 0) {
                  let Re2 = he2(Be, Pe2, Se2);
                  _e2.push(je2.length === 1 && je2[0].type === "BlockStatement" ? [" ", Re2] : c([u, Re2]));
                }
                return _e2;
              }
              case "DebuggerStatement":
                return ["debugger", Xe2];
              case "ClassDeclaration":
              case "ClassExpression":
                return z(Be, Pe2, Se2);
              case "ClassMethod":
              case "ClassPrivateMethod":
              case "MethodDefinition":
                return U(Be, Pe2, Se2);
              case "ClassProperty":
              case "PropertyDefinition":
              case "ClassPrivateProperty":
              case "ClassAccessorProperty":
                return le2(Be, Pe2, Se2);
              case "TemplateElement":
                return v(xe2.value.raw);
              case "TemplateLiteral":
                return De2(Be, Se2, Pe2);
              case "TaggedTemplateExpression":
                return [Se2("tag"), Se2("typeParameters"), Se2("quasi")];
              case "PrivateIdentifier":
                return ["#", Se2("name")];
              case "PrivateName":
                return ["#", Se2("id")];
              case "InterpreterDirective":
                return _e2.push("#!", xe2.value, u), k2(xe2, Pe2) && _e2.push(u), _e2;
              case "TopicReference":
                return "%";
              case "ArgumentPlaceholder":
                return "?";
              case "ModuleExpression": {
                _e2.push("module {");
                let je2 = Se2("body");
                return je2 && _e2.push(c([u, je2]), u), _e2.push("}"), _e2;
              }
              default:
                throw new Error("unknown type: " + JSON.stringify(xe2.type));
            }
          }
          function Ee(Be, Pe2) {
            let Se2 = C2(Be), Qe = Se2.slice(1, -1);
            if (Qe.includes('"') || Qe.includes("'"))
              return Se2;
            let xe2 = Pe2.singleQuote ? "'" : '"';
            return xe2 + Qe + xe2;
          }
          function We2(Be) {
            return Be.type && !N(Be) && !I2(Be) && Be.type !== "EmptyStatement" && Be.type !== "TemplateElement" && Be.type !== "Import" && Be.type !== "TSEmptyBodyFunctionExpression";
          }
          n.exports = { preprocess: w2, print: J2, embed: m2, insertPragma: p, massageAstNode: d4, hasPrettierIgnore(Be) {
            return D2(Be) || j(Be);
          }, willPrintOwnComments: f.willPrintOwnComments, canAttachComment: We2, printComment: Fe2, isBlockComment: N, handleComments: { avoidAstMutation: true, ownLine: f.handleOwnLineComment, endOfLine: f.handleEndOfLineComment, remaining: f.handleRemainingComment }, getCommentChildNodes: f.getCommentChildNodes };
        } }), Zm2 = Z3({ "src/language-js/printer-estree-json.js"(e, n) {
          re2();
          var { builders: { hardline: t, indent: s2, join: a3 } } = Oe2(), r = so2();
          function u(c, v, m2) {
            let d4 = c.getValue();
            switch (d4.type) {
              case "JsonRoot":
                return [m2("node"), t];
              case "ArrayExpression": {
                if (d4.elements.length === 0)
                  return "[]";
                let p = c.map(() => c.getValue() === null ? "null" : m2(), "elements");
                return ["[", s2([t, a3([",", t], p)]), t, "]"];
              }
              case "ObjectExpression":
                return d4.properties.length === 0 ? "{}" : ["{", s2([t, a3([",", t], c.map(m2, "properties"))]), t, "}"];
              case "ObjectProperty":
                return [m2("key"), ": ", m2("value")];
              case "UnaryExpression":
                return [d4.operator === "+" ? "" : d4.operator, m2("argument")];
              case "NullLiteral":
                return "null";
              case "BooleanLiteral":
                return d4.value ? "true" : "false";
              case "StringLiteral":
              case "NumericLiteral":
                return JSON.stringify(d4.value);
              case "Identifier": {
                let p = c.getParentNode();
                return p && p.type === "ObjectProperty" && p.key === d4 ? JSON.stringify(d4.name) : d4.name;
              }
              case "TemplateLiteral":
                return m2(["quasis", 0]);
              case "TemplateElement":
                return JSON.stringify(d4.value.cooked);
              default:
                throw new Error("unknown type: " + JSON.stringify(d4.type));
            }
          }
          var i2 = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
          function o(c, v) {
            let { type: m2 } = c;
            if (m2 === "ObjectProperty" && c.key.type === "Identifier") {
              v.key = { type: "StringLiteral", value: c.key.name };
              return;
            }
            if (m2 === "UnaryExpression" && c.operator === "+")
              return v.argument;
            if (m2 === "ArrayExpression") {
              for (let [d4, p] of c.elements.entries())
                p === null && v.elements.splice(d4, 0, { type: "NullLiteral" });
              return;
            }
            if (m2 === "TemplateLiteral")
              return { type: "StringLiteral", value: c.quasis[0].value.cooked };
          }
          o.ignoredProperties = i2, n.exports = { preprocess: r, print: u, massageAstNode: o };
        } }), Ot2 = Z3({ "src/common/common-options.js"(e, n) {
          re2();
          var t = "Common";
          n.exports = { bracketSpacing: { since: "0.0.0", category: t, type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: t, type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { since: "1.8.2", category: t, type: "choice", default: [{ since: "1.8.2", value: true }, { since: "1.9.0", value: "preserve" }], description: "How to wrap prose.", choices: [{ since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width." }, { since: "1.9.0", value: "never", description: "Do not wrap prose." }, { since: "1.9.0", value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { since: "2.4.0", category: t, type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { since: "2.6.0", category: t, type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
        } }), ed2 = Z3({ "src/language-js/options.js"(e, n) {
          re2();
          var t = Ot2(), s2 = "JavaScript";
          n.exports = { arrowParens: { since: "1.9.0", category: s2, type: "choice", default: [{ since: "1.9.0", value: "avoid" }, { since: "2.0.0", value: "always" }], description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: t.bracketSameLine, bracketSpacing: t.bracketSpacing, jsxBracketSameLine: { since: "0.17.0", category: s2, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { since: "1.0.0", category: s2, type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, singleQuote: t.singleQuote, jsxSingleQuote: { since: "1.15.0", category: s2, type: "boolean", default: false, description: "Use single quotes in JSX." }, quoteProps: { since: "1.17.0", category: s2, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { since: "0.0.0", category: s2, type: "choice", default: [{ since: "0.0.0", value: false }, { since: "0.19.0", value: "none" }, { since: "2.0.0", value: "es5" }], description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }, { value: "all", description: "Trailing commas wherever possible (including function arguments)." }] }, singleAttributePerLine: t.singleAttributePerLine };
        } }), td2 = Z3({ "src/language-js/parse/parsers.js"() {
          re2();
        } }), Sn2 = Z3({ "node_modules/linguist-languages/data/JavaScript.json"(e, n) {
          n.exports = { name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], languageId: 183 };
        } }), rd2 = Z3({ "node_modules/linguist-languages/data/TypeScript.json"(e, n) {
          n.exports = { name: "TypeScript", type: "programming", color: "#3178c6", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts", ".cts", ".mts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378 };
        } }), nd2 = Z3({ "node_modules/linguist-languages/data/TSX.json"(e, n) {
          n.exports = { name: "TSX", type: "programming", color: "#3178c6", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924 };
        } }), ma2 = Z3({ "node_modules/linguist-languages/data/JSON.json"(e, n) {
          n.exports = { name: "JSON", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"], languageId: 174 };
        } }), ud2 = Z3({ "node_modules/linguist-languages/data/JSON with Comments.json"(e, n) {
          n.exports = { name: "JSON with Comments", type: "data", color: "#292929", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".code-snippets", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [".babelrc", ".devcontainer.json", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"], languageId: 423 };
        } }), sd2 = Z3({ "node_modules/linguist-languages/data/JSON5.json"(e, n) {
          n.exports = { name: "JSON5", type: "data", color: "#267CB9", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175 };
        } }), id2 = Z3({ "src/language-js/index.js"(e, n) {
          re2();
          var t = Bt(), s2 = Qm2(), a3 = Zm2(), r = ed2(), u = td2(), i2 = [t(Sn2(), (c) => ({ since: "0.0.0", parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: [...c.interpreters, "zx"], extensions: [...c.extensions.filter((v) => v !== ".jsx"), ".wxs"] })), t(Sn2(), () => ({ name: "Flow", since: "0.0.0", parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"] })), t(Sn2(), () => ({ name: "JSX", since: "0.0.0", parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], aliases: void 0, filenames: void 0, extensions: [".jsx"], group: "JavaScript", interpreters: void 0, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0 })), t(rd2(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] })), t(nd2(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] })), t(ma2(), () => ({ name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [".importmap"], filenames: ["package.json", "package-lock.json", "composer.json"] })), t(ma2(), (c) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], extensions: c.extensions.filter((v) => v !== ".jsonl") })), t(ud2(), (c) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: [...c.filenames, ".eslintrc", ".swcrc"] })), t(sd2(), () => ({ since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"] }))], o = { estree: s2, "estree-json": a3 };
          n.exports = { languages: i2, options: r, printers: o, parsers: u };
        } }), ad2 = Z3({ "src/language-css/clean.js"(e, n) {
          re2();
          var { isFrontMatterNode: t } = Ue2(), s2 = it2(), a3 = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
          function r(i2, o, c) {
            if (t(i2) && i2.lang === "yaml" && delete o.value, i2.type === "css-comment" && c.type === "css-root" && c.nodes.length > 0 && ((c.nodes[0] === i2 || t(c.nodes[0]) && c.nodes[1] === i2) && (delete o.text, /^\*\s*@(?:format|prettier)\s*$/.test(i2.text)) || c.type === "css-root" && s2(c.nodes) === i2))
              return null;
            if (i2.type === "value-root" && delete o.text, (i2.type === "media-query" || i2.type === "media-query-list" || i2.type === "media-feature-expression") && delete o.value, i2.type === "css-rule" && delete o.params, i2.type === "selector-combinator" && (o.value = o.value.replace(/\s+/g, " ")), i2.type === "media-feature" && (o.value = o.value.replace(/ /g, "")), (i2.type === "value-word" && (i2.isColor && i2.isHex || ["initial", "inherit", "unset", "revert"].includes(o.value.replace().toLowerCase())) || i2.type === "media-feature" || i2.type === "selector-root-invalid" || i2.type === "selector-pseudo") && (o.value = o.value.toLowerCase()), i2.type === "css-decl" && (o.prop = o.prop.toLowerCase()), (i2.type === "css-atrule" || i2.type === "css-import") && (o.name = o.name.toLowerCase()), i2.type === "value-number" && (o.unit = o.unit.toLowerCase()), (i2.type === "media-feature" || i2.type === "media-keyword" || i2.type === "media-type" || i2.type === "media-unknown" || i2.type === "media-url" || i2.type === "media-value" || i2.type === "selector-attribute" || i2.type === "selector-string" || i2.type === "selector-class" || i2.type === "selector-combinator" || i2.type === "value-string") && o.value && (o.value = u(o.value)), i2.type === "selector-attribute" && (o.attribute = o.attribute.trim(), o.namespace && typeof o.namespace == "string" && (o.namespace = o.namespace.trim(), o.namespace.length === 0 && (o.namespace = true)), o.value && (o.value = o.value.trim().replace(/^["']|["']$/g, ""), delete o.quoted)), (i2.type === "media-value" || i2.type === "media-type" || i2.type === "value-number" || i2.type === "selector-root-invalid" || i2.type === "selector-class" || i2.type === "selector-combinator" || i2.type === "selector-tag") && o.value && (o.value = o.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (v, m2, d4) => {
              let p = Number(m2);
              return Number.isNaN(p) ? v : p + d4.toLowerCase();
            })), i2.type === "selector-tag") {
              let v = i2.value.toLowerCase();
              ["from", "to"].includes(v) && (o.value = v);
            }
            if (i2.type === "css-atrule" && i2.name.toLowerCase() === "supports" && delete o.value, i2.type === "selector-unknown" && delete o.value, i2.type === "value-comma_group") {
              let v = i2.groups.findIndex((m2) => m2.type === "value-number" && m2.unit === "...");
              v !== -1 && (o.groups[v].unit = "", o.groups.splice(v + 1, 0, { type: "value-word", value: "...", isColor: false, isHex: false }));
            }
          }
          r.ignoredProperties = a3;
          function u(i2) {
            return i2.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1");
          }
          n.exports = r;
        } }), Xn2 = Z3({ "src/utils/front-matter/print.js"(e, n) {
          re2();
          var { builders: { hardline: t, markAsRoot: s2 } } = Oe2();
          function a3(r, u) {
            if (r.lang === "yaml") {
              let i2 = r.value.trim(), o = i2 ? u(i2, { parser: "yaml" }, { stripTrailingHardline: true }) : "";
              return s2([r.startDelimiter, t, o, o ? t : "", r.endDelimiter]);
            }
          }
          n.exports = a3;
        } }), od2 = Z3({ "src/language-css/embed.js"(e, n) {
          re2();
          var { builders: { hardline: t } } = Oe2(), s2 = Xn2();
          function a3(r, u, i2) {
            let o = r.getValue();
            if (o.type === "front-matter") {
              let c = s2(o, i2);
              return c ? [c, t] : "";
            }
          }
          n.exports = a3;
        } }), mo2 = Z3({ "src/utils/front-matter/parse.js"(e, n) {
          re2();
          var t = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
          function s2(a3) {
            let r = a3.match(t);
            if (!r)
              return { content: a3 };
            let { startDelimiter: u, language: i2, value: o = "", endDelimiter: c } = r.groups, v = i2.trim() || "yaml";
            if (u === "+++" && (v = "toml"), v !== "yaml" && u !== c)
              return { content: a3 };
            let [m2] = r;
            return { frontMatter: { type: "front-matter", lang: v, value: o, startDelimiter: u, endDelimiter: c, raw: m2.replace(/\n$/, "") }, content: m2.replace(/[^\n]/g, " ") + a3.slice(m2.length) };
          }
          n.exports = s2;
        } }), ld2 = Z3({ "src/language-css/pragma.js"(e, n) {
          re2();
          var t = no2(), s2 = mo2();
          function a3(u) {
            return t.hasPragma(s2(u).content);
          }
          function r(u) {
            let { frontMatter: i2, content: o } = s2(u);
            return (i2 ? i2.raw + `

` : "") + t.insertPragma(o);
          }
          n.exports = { hasPragma: a3, insertPragma: r };
        } }), cd2 = Z3({ "src/language-css/utils/index.js"(e, n) {
          re2();
          var t = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
          function s2(G, z) {
            let U = Array.isArray(z) ? z : [z], le2 = -1, ge2;
            for (; ge2 = G.getParentNode(++le2); )
              if (U.includes(ge2.type))
                return le2;
            return -1;
          }
          function a3(G, z) {
            let U = s2(G, z);
            return U === -1 ? null : G.getParentNode(U);
          }
          function r(G) {
            var z;
            let U = a3(G, "css-decl");
            return U == null || (z = U.prop) === null || z === void 0 ? void 0 : z.toLowerCase();
          }
          var u = /* @__PURE__ */ new Set(["initial", "inherit", "unset", "revert"]);
          function i2(G) {
            return u.has(G.toLowerCase());
          }
          function o(G, z) {
            let U = a3(G, "css-atrule");
            return (U == null ? void 0 : U.name) && U.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(z.toLowerCase());
          }
          function c(G) {
            return G.includes("$") || G.includes("@") || G.includes("#") || G.startsWith("%") || G.startsWith("--") || G.startsWith(":--") || G.includes("(") && G.includes(")") ? G : G.toLowerCase();
          }
          function v(G, z) {
            var U;
            let le2 = a3(G, "value-func");
            return (le2 == null || (U = le2.value) === null || U === void 0 ? void 0 : U.toLowerCase()) === z;
          }
          function m2(G) {
            var z;
            let U = a3(G, "css-rule"), le2 = U == null || (z = U.raws) === null || z === void 0 ? void 0 : z.selector;
            return le2 && (le2.startsWith(":import") || le2.startsWith(":export"));
          }
          function d4(G, z) {
            let U = Array.isArray(z) ? z : [z], le2 = a3(G, "css-atrule");
            return le2 && U.includes(le2.name.toLowerCase());
          }
          function p(G) {
            let z = G.getValue(), U = a3(G, "css-atrule");
            return (U == null ? void 0 : U.name) === "import" && z.groups[0].value === "url" && z.groups.length === 2;
          }
          function f(G) {
            return G.type === "value-func" && G.value.toLowerCase() === "url";
          }
          function h2(G, z) {
            var U;
            let le2 = (U = G.getParentNode()) === null || U === void 0 ? void 0 : U.nodes;
            return le2 && le2.indexOf(z) === le2.length - 1;
          }
          function w2(G) {
            let { selector: z } = G;
            return z ? typeof z == "string" && /^@.+:.*$/.test(z) || z.value && /^@.+:.*$/.test(z.value) : false;
          }
          function T2(G) {
            return G.type === "value-word" && ["from", "through", "end"].includes(G.value);
          }
          function A2(G) {
            return G.type === "value-word" && ["and", "or", "not"].includes(G.value);
          }
          function S2(G) {
            return G.type === "value-word" && G.value === "in";
          }
          function B(G) {
            return G.type === "value-operator" && G.value === "*";
          }
          function I2(G) {
            return G.type === "value-operator" && G.value === "/";
          }
          function k2(G) {
            return G.type === "value-operator" && G.value === "+";
          }
          function P(G) {
            return G.type === "value-operator" && G.value === "-";
          }
          function C2(G) {
            return G.type === "value-operator" && G.value === "%";
          }
          function D2(G) {
            return B(G) || I2(G) || k2(G) || P(G) || C2(G);
          }
          function g2(G) {
            return G.type === "value-word" && ["==", "!="].includes(G.value);
          }
          function F(G) {
            return G.type === "value-word" && ["<", ">", "<=", ">="].includes(G.value);
          }
          function l(G) {
            return G.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(G.name);
          }
          function E(G) {
            var z;
            return ((z = G.raws) === null || z === void 0 ? void 0 : z.params) && /^\(\s*\)$/.test(G.raws.params);
          }
          function y(G) {
            return G.name.startsWith("prettier-placeholder");
          }
          function N(G) {
            return G.prop.startsWith("@prettier-placeholder");
          }
          function x2(G, z) {
            return G.value === "$$" && G.type === "value-func" && (z == null ? void 0 : z.type) === "value-word" && !z.raws.before;
          }
          function b2(G) {
            var z, U;
            return ((z = G.value) === null || z === void 0 ? void 0 : z.type) === "value-root" && ((U = G.value.group) === null || U === void 0 ? void 0 : U.type) === "value-value" && G.prop.toLowerCase() === "composes";
          }
          function L(G) {
            var z, U, le2;
            return ((z = G.value) === null || z === void 0 || (U = z.group) === null || U === void 0 || (le2 = U.group) === null || le2 === void 0 ? void 0 : le2.type) === "value-paren_group" && G.value.group.group.open !== null && G.value.group.group.close !== null;
          }
          function M2(G) {
            var z;
            return ((z = G.raws) === null || z === void 0 ? void 0 : z.before) === "";
          }
          function j(G) {
            var z, U;
            return G.type === "value-comma_group" && ((z = G.groups) === null || z === void 0 || (U = z[1]) === null || U === void 0 ? void 0 : U.type) === "value-colon";
          }
          function $(G) {
            var z;
            return G.type === "value-paren_group" && ((z = G.groups) === null || z === void 0 ? void 0 : z[0]) && j(G.groups[0]);
          }
          function V(G) {
            var z;
            let U = G.getValue();
            if (U.groups.length === 0)
              return false;
            let le2 = G.getParentNode(1);
            if (!$(U) && !(le2 && $(le2)))
              return false;
            let ge2 = a3(G, "css-decl");
            return !!(ge2 != null && (z = ge2.prop) !== null && z !== void 0 && z.startsWith("$") || $(le2) || le2.type === "value-func");
          }
          function q(G) {
            return G.type === "value-comment" && G.inline;
          }
          function Y3(G) {
            return G.type === "value-word" && G.value === "#";
          }
          function H3(G) {
            return G.type === "value-word" && G.value === "{";
          }
          function R(G) {
            return G.type === "value-word" && G.value === "}";
          }
          function Q(G) {
            return ["value-word", "value-atword"].includes(G.type);
          }
          function ee2(G) {
            return (G == null ? void 0 : G.type) === "value-colon";
          }
          function te2(G, z) {
            if (!j(z))
              return false;
            let { groups: U } = z, le2 = U.indexOf(G);
            return le2 === -1 ? false : ee2(U[le2 + 1]);
          }
          function oe2(G) {
            return G.value && ["not", "and", "or"].includes(G.value.toLowerCase());
          }
          function W2(G) {
            return G.type !== "value-func" ? false : t.has(G.value.toLowerCase());
          }
          function X3(G) {
            return /\/\//.test(G.split(/[\n\r]/).pop());
          }
          function ue2(G) {
            return (G == null ? void 0 : G.type) === "value-atword" && G.value.startsWith("prettier-placeholder-");
          }
          function De2(G, z) {
            var U, le2;
            if (((U = G.open) === null || U === void 0 ? void 0 : U.value) !== "(" || ((le2 = G.close) === null || le2 === void 0 ? void 0 : le2.value) !== ")" || G.groups.some((ge2) => ge2.type !== "value-comma_group"))
              return false;
            if (z.type === "value-comma_group") {
              let ge2 = z.groups.indexOf(G) - 1, Ae2 = z.groups[ge2];
              if ((Ae2 == null ? void 0 : Ae2.type) === "value-word" && Ae2.value === "with")
                return true;
            }
            return false;
          }
          function ie(G) {
            var z, U;
            return G.type === "value-paren_group" && ((z = G.open) === null || z === void 0 ? void 0 : z.value) === "(" && ((U = G.close) === null || U === void 0 ? void 0 : U.value) === ")";
          }
          n.exports = { getAncestorCounter: s2, getAncestorNode: a3, getPropOfDeclNode: r, maybeToLowerCase: c, insideValueFunctionNode: v, insideICSSRuleNode: m2, insideAtRuleNode: d4, insideURLFunctionInImportAtRuleNode: p, isKeyframeAtRuleKeywords: o, isWideKeywords: i2, isLastNode: h2, isSCSSControlDirectiveNode: l, isDetachedRulesetDeclarationNode: w2, isRelationalOperatorNode: F, isEqualityOperatorNode: g2, isMultiplicationNode: B, isDivisionNode: I2, isAdditionNode: k2, isSubtractionNode: P, isModuloNode: C2, isMathOperatorNode: D2, isEachKeywordNode: S2, isForKeywordNode: T2, isURLFunctionNode: f, isIfElseKeywordNode: A2, hasComposesNode: b2, hasParensAroundNode: L, hasEmptyRawBefore: M2, isDetachedRulesetCallNode: E, isTemplatePlaceholderNode: y, isTemplatePropNode: N, isPostcssSimpleVarNode: x2, isKeyValuePairNode: j, isKeyValuePairInParenGroupNode: $, isKeyInValuePairNode: te2, isSCSSMapItemNode: V, isInlineValueCommentNode: q, isHashNode: Y3, isLeftCurlyBraceNode: H3, isRightCurlyBraceNode: R, isWordNode: Q, isColonNode: ee2, isMediaAndSupportsKeywords: oe2, isColorAdjusterFuncNode: W2, lastLineHasInlineComment: X3, isAtWordPlaceholderNode: ue2, isConfigurationNode: De2, isParenGroupNode: ie };
        } }), pd2 = Z3({ "src/utils/line-column-to-index.js"(e, n) {
          re2(), n.exports = function(t, s2) {
            let a3 = 0;
            for (let r = 0; r < t.line - 1; ++r)
              a3 = s2.indexOf(`
`, a3) + 1;
            return a3 + t.column;
          };
        } }), fd2 = Z3({ "src/language-css/loc.js"(e, n) {
          re2();
          var { skipEverythingButNewLine: t } = Nr2(), s2 = it2(), a3 = pd2();
          function r(p, f) {
            return typeof p.sourceIndex == "number" ? p.sourceIndex : p.source ? a3(p.source.start, f) - 1 : null;
          }
          function u(p, f) {
            if (p.type === "css-comment" && p.inline)
              return t(f, p.source.startOffset);
            let h2 = p.nodes && s2(p.nodes);
            return h2 && p.source && !p.source.end && (p = h2), p.source && p.source.end ? a3(p.source.end, f) : null;
          }
          function i2(p, f) {
            p.source && (p.source.startOffset = r(p, f), p.source.endOffset = u(p, f));
            for (let h2 in p) {
              let w2 = p[h2];
              h2 === "source" || !w2 || typeof w2 != "object" || (w2.type === "value-root" || w2.type === "value-unknown" ? o(w2, c(p), w2.text || w2.value) : i2(w2, f));
            }
          }
          function o(p, f, h2) {
            p.source && (p.source.startOffset = r(p, h2) + f, p.source.endOffset = u(p, h2) + f);
            for (let w2 in p) {
              let T2 = p[w2];
              w2 === "source" || !T2 || typeof T2 != "object" || o(T2, f, h2);
            }
          }
          function c(p) {
            let f = p.source.startOffset;
            return typeof p.prop == "string" && (f += p.prop.length), p.type === "css-atrule" && typeof p.name == "string" && (f += 1 + p.name.length + p.raws.afterName.match(/^\s*:?\s*/)[0].length), p.type !== "css-atrule" && p.raws && typeof p.raws.between == "string" && (f += p.raws.between.length), f;
          }
          function v(p) {
            let f = "initial", h2 = "initial", w2, T2 = false, A2 = [];
            for (let S2 = 0; S2 < p.length; S2++) {
              let B = p[S2];
              switch (f) {
                case "initial":
                  if (B === "'") {
                    f = "single-quotes";
                    continue;
                  }
                  if (B === '"') {
                    f = "double-quotes";
                    continue;
                  }
                  if ((B === "u" || B === "U") && p.slice(S2, S2 + 4).toLowerCase() === "url(") {
                    f = "url", S2 += 3;
                    continue;
                  }
                  if (B === "*" && p[S2 - 1] === "/") {
                    f = "comment-block";
                    continue;
                  }
                  if (B === "/" && p[S2 - 1] === "/") {
                    f = "comment-inline", w2 = S2 - 1;
                    continue;
                  }
                  continue;
                case "single-quotes":
                  if (B === "'" && p[S2 - 1] !== "\\" && (f = h2, h2 = "initial"), B === `
` || B === "\r")
                    return p;
                  continue;
                case "double-quotes":
                  if (B === '"' && p[S2 - 1] !== "\\" && (f = h2, h2 = "initial"), B === `
` || B === "\r")
                    return p;
                  continue;
                case "url":
                  if (B === ")" && (f = "initial"), B === `
` || B === "\r")
                    return p;
                  if (B === "'") {
                    f = "single-quotes", h2 = "url";
                    continue;
                  }
                  if (B === '"') {
                    f = "double-quotes", h2 = "url";
                    continue;
                  }
                  continue;
                case "comment-block":
                  B === "/" && p[S2 - 1] === "*" && (f = "initial");
                  continue;
                case "comment-inline":
                  (B === '"' || B === "'" || B === "*") && (T2 = true), (B === `
` || B === "\r") && (T2 && A2.push([w2, S2]), f = "initial", T2 = false);
                  continue;
              }
            }
            for (let [S2, B] of A2)
              p = p.slice(0, S2) + p.slice(S2, B).replace(/["'*]/g, " ") + p.slice(B);
            return p;
          }
          function m2(p) {
            return p.source.startOffset;
          }
          function d4(p) {
            return p.source.endOffset;
          }
          n.exports = { locStart: m2, locEnd: d4, calculateLoc: i2, replaceQuotesInInlineComments: v };
        } }), Dd2 = Z3({ "src/language-css/utils/is-less-parser.js"(e, n) {
          re2();
          function t(s2) {
            return s2.parser === "css" || s2.parser === "less";
          }
          n.exports = t;
        } }), md2 = Z3({ "src/language-css/utils/is-scss.js"(e, n) {
          re2();
          function t(s2, a3) {
            return s2 === "less" || s2 === "scss" ? s2 === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(a3);
          }
          n.exports = t;
        } }), dd3 = Z3({ "src/language-css/utils/css-units.evaluate.js"(e, n) {
          n.exports = { em: "em", rem: "rem", ex: "ex", rex: "rex", cap: "cap", rcap: "rcap", ch: "ch", rch: "rch", ic: "ic", ric: "ric", lh: "lh", rlh: "rlh", vw: "vw", svw: "svw", lvw: "lvw", dvw: "dvw", vh: "vh", svh: "svh", lvh: "lvh", dvh: "dvh", vi: "vi", svi: "svi", lvi: "lvi", dvi: "dvi", vb: "vb", svb: "svb", lvb: "lvb", dvb: "dvb", vmin: "vmin", svmin: "svmin", lvmin: "lvmin", dvmin: "dvmin", vmax: "vmax", svmax: "svmax", lvmax: "lvmax", dvmax: "dvmax", cm: "cm", mm: "mm", q: "Q", in: "in", pt: "pt", pc: "pc", px: "px", deg: "deg", grad: "grad", rad: "rad", turn: "turn", s: "s", ms: "ms", hz: "Hz", khz: "kHz", dpi: "dpi", dpcm: "dpcm", dppx: "dppx", x: "x" };
        } }), gd2 = Z3({ "src/language-css/utils/print-unit.js"(e, n) {
          re2();
          var t = dd3();
          function s2(a3) {
            let r = a3.toLowerCase();
            return Object.prototype.hasOwnProperty.call(t, r) ? t[r] : a3;
          }
          n.exports = s2;
        } }), yd2 = Z3({ "src/language-css/printer-postcss.js"(e, n) {
          re2();
          var t = it2(), { printNumber: s2, printString: a3, hasNewline: r, isFrontMatterNode: u, isNextLineEmpty: i2, isNonEmptyArray: o } = Ue2(), { builders: { join: c, line: v, hardline: m2, softline: d4, group: p, fill: f, indent: h2, dedent: w2, ifBreak: T2, breakParent: A2 }, utils: { removeLines: S2, getDocParts: B } } = Oe2(), I2 = ad2(), k2 = od2(), { insertPragma: P } = ld2(), { getAncestorNode: C2, getPropOfDeclNode: D2, maybeToLowerCase: g2, insideValueFunctionNode: F, insideICSSRuleNode: l, insideAtRuleNode: E, insideURLFunctionInImportAtRuleNode: y, isKeyframeAtRuleKeywords: N, isWideKeywords: x2, isLastNode: b2, isSCSSControlDirectiveNode: L, isDetachedRulesetDeclarationNode: M2, isRelationalOperatorNode: j, isEqualityOperatorNode: $, isMultiplicationNode: V, isDivisionNode: q, isAdditionNode: Y3, isSubtractionNode: H3, isMathOperatorNode: R, isEachKeywordNode: Q, isForKeywordNode: ee2, isURLFunctionNode: te2, isIfElseKeywordNode: oe2, hasComposesNode: W2, hasParensAroundNode: X3, hasEmptyRawBefore: ue2, isKeyValuePairNode: De2, isKeyInValuePairNode: ie, isDetachedRulesetCallNode: G, isTemplatePlaceholderNode: z, isTemplatePropNode: U, isPostcssSimpleVarNode: le2, isSCSSMapItemNode: ge2, isInlineValueCommentNode: Ae2, isHashNode: Ne2, isLeftCurlyBraceNode: ke2, isRightCurlyBraceNode: ce, isWordNode: pe, isColonNode: de2, isMediaAndSupportsKeywords: ae2, isColorAdjusterFuncNode: ve2, lastLineHasInlineComment: K, isAtWordPlaceholderNode: he2, isConfigurationNode: ye2, isParenGroupNode: Ce2 } = cd2(), { locStart: Ie2, locEnd: Fe2 } = fd2(), me2 = Dd2(), _ = md2(), J2 = gd2();
          function ne(be2) {
            return be2.trailingComma === "es5" || be2.trailingComma === "all";
          }
          function Ee(be2, Le2, qe2) {
            let se = be2.getValue();
            if (!se)
              return "";
            if (typeof se == "string")
              return se;
            switch (se.type) {
              case "front-matter":
                return [se.raw, m2];
              case "css-root": {
                let He2 = We2(be2, Le2, qe2), Me2 = se.raws.after.trim();
                return [He2, Me2 ? " ".concat(Me2) : "", B(He2).length > 0 ? m2 : ""];
              }
              case "css-comment": {
                let He2 = se.inline || se.raws.inline, Me2 = Le2.originalText.slice(Ie2(se), Fe2(se));
                return He2 ? Me2.trimEnd() : Me2;
              }
              case "css-rule":
                return [qe2("selector"), se.important ? " !important" : "", se.nodes ? [se.selector && se.selector.type === "selector-unknown" && K(se.selector.value) ? v : " ", "{", se.nodes.length > 0 ? h2([m2, We2(be2, Le2, qe2)]) : "", m2, "}", M2(se) ? ";" : ""] : ";"];
              case "css-decl": {
                let He2 = be2.getParentNode(), { between: Me2 } = se.raws, ze = Me2.trim(), nt = ze === ":", tt = W2(se) ? S2(qe2("value")) : qe2("value");
                return !nt && K(ze) && (tt = h2([m2, w2(tt)])), [se.raws.before.replace(/[\s;]/g, ""), l(be2) ? se.prop : g2(se.prop), ze.startsWith("//") ? " " : "", ze, se.extend ? "" : " ", me2(Le2) && se.extend && se.selector ? ["extend(", qe2("selector"), ")"] : "", tt, se.raws.important ? se.raws.important.replace(/\s*!\s*important/i, " !important") : se.important ? " !important" : "", se.raws.scssDefault ? se.raws.scssDefault.replace(/\s*!default/i, " !default") : se.scssDefault ? " !default" : "", se.raws.scssGlobal ? se.raws.scssGlobal.replace(/\s*!global/i, " !global") : se.scssGlobal ? " !global" : "", se.nodes ? [" {", h2([d4, We2(be2, Le2, qe2)]), d4, "}"] : U(se) && !He2.raws.semicolon && Le2.originalText[Fe2(se) - 1] !== ";" ? "" : Le2.__isHTMLStyleAttribute && b2(be2, se) ? T2(";") : ";"];
              }
              case "css-atrule": {
                let He2 = be2.getParentNode(), Me2 = z(se) && !He2.raws.semicolon && Le2.originalText[Fe2(se) - 1] !== ";";
                if (me2(Le2)) {
                  if (se.mixin)
                    return [qe2("selector"), se.important ? " !important" : "", Me2 ? "" : ";"];
                  if (se.function)
                    return [se.name, qe2("params"), Me2 ? "" : ";"];
                  if (se.variable)
                    return ["@", se.name, ": ", se.value ? qe2("value") : "", se.raws.between.trim() ? se.raws.between.trim() + " " : "", se.nodes ? ["{", h2([se.nodes.length > 0 ? d4 : "", We2(be2, Le2, qe2)]), d4, "}"] : "", Me2 ? "" : ";"];
                }
                return ["@", G(se) || se.name.endsWith(":") ? se.name : g2(se.name), se.params ? [G(se) ? "" : z(se) ? se.raws.afterName === "" ? "" : se.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(se.raws.afterName) ? [m2, m2] : /^\s*\n/.test(se.raws.afterName) ? m2 : " " : " ", qe2("params")] : "", se.selector ? h2([" ", qe2("selector")]) : "", se.value ? p([" ", qe2("value"), L(se) ? X3(se) ? " " : v : ""]) : se.name === "else" ? " " : "", se.nodes ? [L(se) ? "" : se.selector && !se.selector.nodes && typeof se.selector.value == "string" && K(se.selector.value) || !se.selector && typeof se.params == "string" && K(se.params) ? v : " ", "{", h2([se.nodes.length > 0 ? d4 : "", We2(be2, Le2, qe2)]), d4, "}"] : Me2 ? "" : ";"];
              }
              case "media-query-list": {
                let He2 = [];
                return be2.each((Me2) => {
                  let ze = Me2.getValue();
                  ze.type === "media-query" && ze.value === "" || He2.push(qe2());
                }, "nodes"), p(h2(c(v, He2)));
              }
              case "media-query":
                return [c(" ", be2.map(qe2, "nodes")), b2(be2, se) ? "" : ","];
              case "media-type":
                return je2(Xe2(se.value, Le2));
              case "media-feature-expression":
                return se.nodes ? ["(", ...be2.map(qe2, "nodes"), ")"] : se.value;
              case "media-feature":
                return g2(Xe2(se.value.replace(/ +/g, " "), Le2));
              case "media-colon":
                return [se.value, " "];
              case "media-value":
                return je2(Xe2(se.value, Le2));
              case "media-keyword":
                return Xe2(se.value, Le2);
              case "media-url":
                return Xe2(se.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), Le2);
              case "media-unknown":
                return se.value;
              case "selector-root":
                return p([E(be2, "custom-selector") ? [C2(be2, "css-atrule").customSelector, v] : "", c([",", E(be2, ["extend", "custom-selector", "nest"]) ? v : m2], be2.map(qe2, "nodes"))]);
              case "selector-selector":
                return p(h2(be2.map(qe2, "nodes")));
              case "selector-comment":
                return se.value;
              case "selector-string":
                return Xe2(se.value, Le2);
              case "selector-tag": {
                let He2 = be2.getParentNode(), Me2 = He2 && He2.nodes.indexOf(se), ze = Me2 && He2.nodes[Me2 - 1];
                return [se.namespace ? [se.namespace === true ? "" : se.namespace.trim(), "|"] : "", ze.type === "selector-nesting" ? se.value : je2(N(be2, se.value) ? se.value.toLowerCase() : se.value)];
              }
              case "selector-id":
                return ["#", se.value];
              case "selector-class":
                return [".", je2(Xe2(se.value, Le2))];
              case "selector-attribute":
                return ["[", se.namespace ? [se.namespace === true ? "" : se.namespace.trim(), "|"] : "", se.attribute.trim(), se.operator ? se.operator : "", se.value ? _e2(Xe2(se.value.trim(), Le2), Le2) : "", se.insensitive ? " i" : "", "]"];
              case "selector-combinator": {
                if (se.value === "+" || se.value === ">" || se.value === "~" || se.value === ">>>") {
                  let ze = be2.getParentNode();
                  return [ze.type === "selector-selector" && ze.nodes[0] === se ? "" : v, se.value, b2(be2, se) ? "" : " "];
                }
                let He2 = se.value.trim().startsWith("(") ? v : "", Me2 = je2(Xe2(se.value.trim(), Le2)) || v;
                return [He2, Me2];
              }
              case "selector-universal":
                return [se.namespace ? [se.namespace === true ? "" : se.namespace.trim(), "|"] : "", se.value];
              case "selector-pseudo":
                return [g2(se.value), o(se.nodes) ? ["(", c(", ", be2.map(qe2, "nodes")), ")"] : ""];
              case "selector-nesting":
                return se.value;
              case "selector-unknown": {
                let He2 = C2(be2, "css-rule");
                if (He2 && He2.isSCSSNesterProperty)
                  return je2(Xe2(g2(se.value), Le2));
                let Me2 = be2.getParentNode();
                if (Me2.raws && Me2.raws.selector) {
                  let nt = Ie2(Me2), tt = nt + Me2.raws.selector.length;
                  return Le2.originalText.slice(nt, tt).trim();
                }
                let ze = be2.getParentNode(1);
                if (Me2.type === "value-paren_group" && ze && ze.type === "value-func" && ze.value === "selector") {
                  let nt = Fe2(Me2.open) + 1, tt = Ie2(Me2.close), pt2 = Le2.originalText.slice(nt, tt).trim();
                  return K(pt2) ? [A2, pt2] : pt2;
                }
                return se.value;
              }
              case "value-value":
              case "value-root":
                return qe2("group");
              case "value-comment":
                return Le2.originalText.slice(Ie2(se), Fe2(se));
              case "value-comma_group": {
                let He2 = be2.getParentNode(), Me2 = be2.getParentNode(1), ze = D2(be2), nt = ze && He2.type === "value-value" && (ze === "grid" || ze.startsWith("grid-template")), tt = C2(be2, "css-atrule"), pt2 = tt && L(tt), O2 = se.groups.some((ut2) => Ae2(ut2)), fe2 = be2.map(qe2, "groups"), Te2 = [], $e2 = F(be2, "url"), Je2 = false, Ze2 = false;
                for (let ut2 = 0; ut2 < se.groups.length; ++ut2) {
                  Te2.push(fe2[ut2]);
                  let rt2 = se.groups[ut2 - 1], Ve2 = se.groups[ut2], Ge2 = se.groups[ut2 + 1], tr2 = se.groups[ut2 + 2];
                  if ($e2) {
                    (Ge2 && Y3(Ge2) || Y3(Ve2)) && Te2.push(" ");
                    continue;
                  }
                  if (E(be2, "forward") && Ve2.type === "value-word" && Ve2.value && rt2 !== void 0 && rt2.type === "value-word" && rt2.value === "as" && Ge2.type === "value-operator" && Ge2.value === "*" || !Ge2 || Ve2.type === "value-word" && Ve2.value.endsWith("-") && he2(Ge2))
                    continue;
                  let Eo2 = Ve2.type === "value-string" && Ve2.value.startsWith("#{"), Fo2 = Je2 && Ge2.type === "value-string" && Ge2.value.endsWith("}");
                  if (Eo2 || Fo2) {
                    Je2 = !Je2;
                    continue;
                  }
                  if (Je2 || de2(Ve2) || de2(Ge2) || Ve2.type === "value-atword" && Ve2.value === "" || Ve2.value === "~" || Ve2.value && Ve2.value.includes("\\") && Ge2 && Ge2.type !== "value-comment" || rt2 && rt2.value && rt2.value.indexOf("\\") === rt2.value.length - 1 && Ve2.type === "value-operator" && Ve2.value === "/" || Ve2.value === "\\" || le2(Ve2, Ge2) || Ne2(Ve2) || ke2(Ve2) || ce(Ge2) || ke2(Ge2) && ue2(Ge2) || ce(Ve2) && ue2(Ge2) || Ve2.value === "--" && Ne2(Ge2))
                    continue;
                  let Qn2 = R(Ve2), Zn2 = R(Ge2);
                  if ((Qn2 && Ne2(Ge2) || Zn2 && ce(Ve2)) && ue2(Ge2) || !rt2 && q(Ve2) || F(be2, "calc") && (Y3(Ve2) || Y3(Ge2) || H3(Ve2) || H3(Ge2)) && ue2(Ge2))
                    continue;
                  let Ao2 = (Y3(Ve2) || H3(Ve2)) && ut2 === 0 && (Ge2.type === "value-number" || Ge2.isHex) && Me2 && ve2(Me2) && !ue2(Ge2), eu2 = tr2 && tr2.type === "value-func" || tr2 && pe(tr2) || Ve2.type === "value-func" || pe(Ve2), tu = Ge2.type === "value-func" || pe(Ge2) || rt2 && rt2.type === "value-func" || rt2 && pe(rt2);
                  if (!(!(V(Ge2) || V(Ve2)) && !F(be2, "calc") && !Ao2 && (q(Ge2) && !eu2 || q(Ve2) && !tu || Y3(Ge2) && !eu2 || Y3(Ve2) && !tu || H3(Ge2) || H3(Ve2)) && (ue2(Ge2) || Qn2 && (!rt2 || rt2 && R(rt2))))) {
                    if (Ae2(Ve2)) {
                      if (He2.type === "value-paren_group") {
                        Te2.push(w2(m2));
                        continue;
                      }
                      Te2.push(m2);
                      continue;
                    }
                    if (pt2 && ($(Ge2) || j(Ge2) || oe2(Ge2) || Q(Ve2) || ee2(Ve2))) {
                      Te2.push(" ");
                      continue;
                    }
                    if (tt && tt.name.toLowerCase() === "namespace") {
                      Te2.push(" ");
                      continue;
                    }
                    if (nt) {
                      Ve2.source && Ge2.source && Ve2.source.start.line !== Ge2.source.start.line ? (Te2.push(m2), Ze2 = true) : Te2.push(" ");
                      continue;
                    }
                    if (Zn2) {
                      Te2.push(" ");
                      continue;
                    }
                    if (!(Ge2 && Ge2.value === "...") && !(he2(Ve2) && he2(Ge2) && Fe2(Ve2) === Ie2(Ge2))) {
                      if (he2(Ve2) && Ce2(Ge2) && Fe2(Ve2) === Ie2(Ge2.open)) {
                        Te2.push(d4);
                        continue;
                      }
                      if (Ve2.value === "with" && Ce2(Ge2)) {
                        Te2.push(" ");
                        continue;
                      }
                      Te2.push(v);
                    }
                  }
                }
                return O2 && Te2.push(A2), Ze2 && Te2.unshift(m2), pt2 ? p(h2(Te2)) : y(be2) ? p(f(Te2)) : p(h2(f(Te2)));
              }
              case "value-paren_group": {
                let He2 = be2.getParentNode();
                if (He2 && te2(He2) && (se.groups.length === 1 || se.groups.length > 0 && se.groups[0].type === "value-comma_group" && se.groups[0].groups.length > 0 && se.groups[0].groups[0].type === "value-word" && se.groups[0].groups[0].value.startsWith("data:")))
                  return [se.open ? qe2("open") : "", c(",", be2.map(qe2, "groups")), se.close ? qe2("close") : ""];
                if (!se.open) {
                  let $e2 = be2.map(qe2, "groups"), Je2 = [];
                  for (let Ze2 = 0; Ze2 < $e2.length; Ze2++)
                    Ze2 !== 0 && Je2.push([",", v]), Je2.push($e2[Ze2]);
                  return p(h2(f(Je2)));
                }
                let Me2 = ge2(be2), ze = t(se.groups), nt = ze && ze.type === "value-comment", tt = ie(se, He2), pt2 = ye2(se, He2), O2 = pt2 || Me2 && !tt, fe2 = pt2 || tt, Te2 = p([se.open ? qe2("open") : "", h2([d4, c([v], be2.map(($e2, Je2) => {
                  let Ze2 = $e2.getValue(), ut2 = Je2 === se.groups.length - 1, rt2 = [qe2(), ut2 ? "" : ","];
                  if (De2(Ze2) && Ze2.type === "value-comma_group" && Ze2.groups && Ze2.groups[0].type !== "value-paren_group" && Ze2.groups[2] && Ze2.groups[2].type === "value-paren_group") {
                    let Ve2 = B(rt2[0].contents.contents);
                    return Ve2[1] = p(Ve2[1]), p(w2(rt2));
                  }
                  if (!ut2 && Ze2.type === "value-comma_group" && o(Ze2.groups)) {
                    let Ve2 = t(Ze2.groups);
                    Ve2.source && i2(Le2.originalText, Ve2, Fe2) && rt2.push(m2);
                  }
                  return rt2;
                }, "groups"))]), T2(!nt && _(Le2.parser, Le2.originalText) && Me2 && ne(Le2) ? "," : ""), d4, se.close ? qe2("close") : ""], { shouldBreak: O2 });
                return fe2 ? w2(Te2) : Te2;
              }
              case "value-func":
                return [se.value, E(be2, "supports") && ae2(se) ? " " : "", qe2("group")];
              case "value-paren":
                return se.value;
              case "value-number":
                return [Re2(se.value), J2(se.unit)];
              case "value-operator":
                return se.value;
              case "value-word":
                return se.isColor && se.isHex || x2(se.value) ? se.value.toLowerCase() : se.value;
              case "value-colon": {
                let He2 = be2.getParentNode(), Me2 = He2 && He2.groups.indexOf(se), ze = Me2 && He2.groups[Me2 - 1];
                return [se.value, ze && typeof ze.value == "string" && t(ze.value) === "\\" || F(be2, "url") ? "" : v];
              }
              case "value-comma":
                return [se.value, " "];
              case "value-string":
                return a3(se.raws.quote + se.value + se.raws.quote, Le2);
              case "value-atword":
                return ["@", se.value];
              case "value-unicode-range":
                return se.value;
              case "value-unknown":
                return se.value;
              default:
                throw new Error("Unknown postcss type ".concat(JSON.stringify(se.type)));
            }
          }
          function We2(be2, Le2, qe2) {
            let se = [];
            return be2.each((He2, Me2, ze) => {
              let nt = ze[Me2 - 1];
              if (nt && nt.type === "css-comment" && nt.text.trim() === "prettier-ignore") {
                let tt = He2.getValue();
                se.push(Le2.originalText.slice(Ie2(tt), Fe2(tt)));
              } else
                se.push(qe2());
              Me2 !== ze.length - 1 && (ze[Me2 + 1].type === "css-comment" && !r(Le2.originalText, Ie2(ze[Me2 + 1]), { backwards: true }) && !u(ze[Me2]) || ze[Me2 + 1].type === "css-atrule" && ze[Me2 + 1].name === "else" && ze[Me2].type !== "css-comment" ? se.push(" ") : (se.push(Le2.__isHTMLStyleAttribute ? v : m2), i2(Le2.originalText, He2.getValue(), Fe2) && !u(ze[Me2]) && se.push(m2)));
            }, "nodes"), se;
          }
          var Be = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, Pe2 = /(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g, Se2 = /[A-Za-z]+/g, Qe = /[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g, xe2 = new RegExp(Be.source + "|(".concat(Qe.source, ")?(").concat(Pe2.source, ")(").concat(Se2.source, ")?"), "g");
          function Xe2(be2, Le2) {
            return be2.replace(Be, (qe2) => a3(qe2, Le2));
          }
          function _e2(be2, Le2) {
            let qe2 = Le2.singleQuote ? "'" : '"';
            return be2.includes('"') || be2.includes("'") ? be2 : qe2 + be2 + qe2;
          }
          function je2(be2) {
            return be2.replace(xe2, (Le2, qe2, se, He2, Me2) => !se && He2 ? Re2(He2) + g2(Me2 || "") : Le2);
          }
          function Re2(be2) {
            return s2(be2).replace(/\.0(?=$|e)/, "");
          }
          n.exports = { print: Ee, embed: k2, insertPragma: P, massageAstNode: I2 };
        } }), hd2 = Z3({ "src/language-css/options.js"(e, n) {
          re2();
          var t = Ot2();
          n.exports = { singleQuote: t.singleQuote };
        } }), vd2 = Z3({ "src/language-css/parsers.js"() {
          re2();
        } }), Cd2 = Z3({ "node_modules/linguist-languages/data/CSS.json"(e, n) {
          n.exports = { name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css"], languageId: 50 };
        } }), Ed2 = Z3({ "node_modules/linguist-languages/data/PostCSS.json"(e, n) {
          n.exports = { name: "PostCSS", type: "markup", color: "#dc3a0c", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", languageId: 262764437 };
        } }), Fd2 = Z3({ "node_modules/linguist-languages/data/Less.json"(e, n) {
          n.exports = { name: "Less", type: "markup", color: "#1d365d", aliases: ["less-css"], extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198 };
        } }), Ad2 = Z3({ "node_modules/linguist-languages/data/SCSS.json"(e, n) {
          n.exports = { name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], languageId: 329 };
        } }), Sd2 = Z3({ "src/language-css/index.js"(e, n) {
          re2();
          var t = Bt(), s2 = yd2(), a3 = hd2(), r = vd2(), u = [t(Cd2(), (o) => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"], extensions: [...o.extensions, ".wxss"] })), t(Ed2(), () => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"] })), t(Fd2(), () => ({ since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"] })), t(Ad2(), () => ({ since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"] }))], i2 = { postcss: s2 };
          n.exports = { languages: u, options: a3, printers: i2, parsers: r };
        } }), xd2 = Z3({ "src/language-handlebars/loc.js"(e, n) {
          re2();
          function t(a3) {
            return a3.loc.start.offset;
          }
          function s2(a3) {
            return a3.loc.end.offset;
          }
          n.exports = { locStart: t, locEnd: s2 };
        } }), bd2 = Z3({ "src/language-handlebars/clean.js"(e, n) {
          re2();
          function t(s2, a3) {
            if (s2.type === "TextNode") {
              let r = s2.chars.trim();
              if (!r)
                return null;
              a3.chars = r.replace(/[\t\n\f\r ]+/g, " ");
            }
            s2.type === "AttrNode" && s2.name.toLowerCase() === "class" && delete a3.value;
          }
          t.ignoredProperties = /* @__PURE__ */ new Set(["loc", "selfClosing"]), n.exports = t;
        } }), Td2 = Z3({ "vendors/html-void-elements.json"(e, n) {
          n.exports = { htmlVoidElements: ["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "isindex", "keygen", "link", "menuitem", "meta", "nextid", "param", "source", "track", "wbr"] };
        } }), Bd2 = Z3({ "src/language-handlebars/utils.js"(e, n) {
          re2();
          var { htmlVoidElements: t } = Td2(), s2 = it2();
          function a3(S2) {
            let B = S2.getValue(), I2 = S2.getParentNode(0);
            return !!(m2(S2, ["ElementNode"]) && s2(I2.children) === B || m2(S2, ["Block"]) && s2(I2.body) === B);
          }
          function r(S2) {
            return S2.toUpperCase() === S2;
          }
          function u(S2) {
            return v(S2, ["ElementNode"]) && typeof S2.tag == "string" && !S2.tag.startsWith(":") && (r(S2.tag[0]) || S2.tag.includes("."));
          }
          var i2 = new Set(t);
          function o(S2) {
            return i2.has(S2.tag) || u(S2) && S2.children.every((B) => c(B));
          }
          function c(S2) {
            return v(S2, ["TextNode"]) && !/\S/.test(S2.chars);
          }
          function v(S2, B) {
            return S2 && B.includes(S2.type);
          }
          function m2(S2, B) {
            let I2 = S2.getParentNode(0);
            return v(I2, B);
          }
          function d4(S2, B) {
            let I2 = h2(S2);
            return v(I2, B);
          }
          function p(S2, B) {
            let I2 = w2(S2);
            return v(I2, B);
          }
          function f(S2, B) {
            var I2, k2, P, C2;
            let D2 = S2.getValue(), g2 = (I2 = S2.getParentNode(0)) !== null && I2 !== void 0 ? I2 : {}, F = (k2 = (P = (C2 = g2.children) !== null && C2 !== void 0 ? C2 : g2.body) !== null && P !== void 0 ? P : g2.parts) !== null && k2 !== void 0 ? k2 : [], l = F.indexOf(D2);
            return l !== -1 && F[l + B];
          }
          function h2(S2) {
            let B = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
            return f(S2, -B);
          }
          function w2(S2) {
            return f(S2, 1);
          }
          function T2(S2) {
            return v(S2, ["MustacheCommentStatement"]) && typeof S2.value == "string" && S2.value.trim() === "prettier-ignore";
          }
          function A2(S2) {
            let B = S2.getValue(), I2 = h2(S2, 2);
            return T2(B) || T2(I2);
          }
          n.exports = { getNextNode: w2, getPreviousNode: h2, hasPrettierIgnore: A2, isLastNodeOfSiblings: a3, isNextNodeOfSomeType: p, isNodeOfSomeType: v, isParentOfSomeType: m2, isPreviousNodeOfSomeType: d4, isVoid: o, isWhitespaceNode: c };
        } }), Nd2 = Z3({ "src/language-handlebars/printer-glimmer.js"(e, n) {
          re2();
          var { builders: { dedent: t, fill: s2, group: a3, hardline: r, ifBreak: u, indent: i2, join: o, line: c, softline: v }, utils: { getDocParts: m2, replaceTextEndOfLine: d4 } } = Oe2(), { getPreferredQuote: p, isNonEmptyArray: f } = Ue2(), { locStart: h2, locEnd: w2 } = xd2(), T2 = bd2(), { getNextNode: A2, getPreviousNode: S2, hasPrettierIgnore: B, isLastNodeOfSiblings: I2, isNextNodeOfSomeType: k2, isNodeOfSomeType: P, isParentOfSomeType: C2, isPreviousNodeOfSomeType: D2, isVoid: g2, isWhitespaceNode: F } = Bd2(), l = 2;
          function E(K, he2, ye2) {
            let Ce2 = K.getValue();
            if (!Ce2)
              return "";
            if (B(K))
              return he2.originalText.slice(h2(Ce2), w2(Ce2));
            let Ie2 = he2.singleQuote ? "'" : '"';
            switch (Ce2.type) {
              case "Block":
              case "Program":
              case "Template":
                return a3(K.map(ye2, "body"));
              case "ElementNode": {
                let Fe2 = a3(N(K, ye2)), me2 = he2.htmlWhitespaceSensitivity === "ignore" && k2(K, ["ElementNode"]) ? v : "";
                if (g2(Ce2))
                  return [Fe2, me2];
                let _ = ["</", Ce2.tag, ">"];
                return Ce2.children.length === 0 ? [Fe2, i2(_), me2] : he2.htmlWhitespaceSensitivity === "ignore" ? [Fe2, i2(x2(K, he2, ye2)), r, i2(_), me2] : [Fe2, i2(a3(x2(K, he2, ye2))), i2(_), me2];
              }
              case "BlockStatement": {
                let Fe2 = K.getParentNode(1);
                return Fe2 && Fe2.inverse && Fe2.inverse.body.length === 1 && Fe2.inverse.body[0] === Ce2 && Fe2.inverse.body[0].path.parts[0] === "if" ? [ee2(K, ye2), ue2(K, ye2, he2), De2(K, ye2, he2)] : [R(K, ye2), a3([ue2(K, ye2, he2), De2(K, ye2, he2), te2(K, ye2, he2)])];
              }
              case "ElementModifierStatement":
                return a3(["{{", pe(K, ye2), "}}"]);
              case "MustacheStatement":
                return a3([L(Ce2), pe(K, ye2), M2(Ce2)]);
              case "SubExpression":
                return a3(["(", ce(K, ye2), v, ")"]);
              case "AttrNode": {
                let Fe2 = Ce2.value.type === "TextNode";
                if (Fe2 && Ce2.value.chars === "" && h2(Ce2.value) === w2(Ce2.value))
                  return Ce2.name;
                let _ = Fe2 ? p(Ce2.value.chars, Ie2).quote : Ce2.value.type === "ConcatStatement" ? p(Ce2.value.parts.filter((ne) => ne.type === "TextNode").map((ne) => ne.chars).join(""), Ie2).quote : "", J2 = ye2("value");
                return [Ce2.name, "=", _, Ce2.name === "class" && _ ? a3(i2(J2)) : J2, _];
              }
              case "ConcatStatement":
                return K.map(ye2, "parts");
              case "Hash":
                return o(c, K.map(ye2, "pairs"));
              case "HashPair":
                return [Ce2.key, "=", ye2("value")];
              case "TextNode": {
                let Fe2 = Ce2.chars.replace(/{{/g, "\\{{"), me2 = z(K);
                if (me2) {
                  if (me2 === "class") {
                    let xe2 = Fe2.trim().split(/\s+/).join(" "), Xe2 = false, _e2 = false;
                    return C2(K, ["ConcatStatement"]) && (D2(K, ["MustacheStatement"]) && /^\s/.test(Fe2) && (Xe2 = true), k2(K, ["MustacheStatement"]) && /\s$/.test(Fe2) && xe2 !== "" && (_e2 = true)), [Xe2 ? c : "", xe2, _e2 ? c : ""];
                  }
                  return d4(Fe2);
                }
                let J2 = /^[\t\n\f\r ]*$/.test(Fe2), ne = !S2(K), Ee = !A2(K);
                if (he2.htmlWhitespaceSensitivity !== "ignore") {
                  let xe2 = /^[\t\n\f\r ]*/, Xe2 = /[\t\n\f\r ]*$/, _e2 = Ee && C2(K, ["Template"]), je2 = ne && C2(K, ["Template"]);
                  if (J2) {
                    if (je2 || _e2)
                      return "";
                    let se = [c], He2 = U(Fe2);
                    return He2 && (se = Ae2(He2)), I2(K) && (se = se.map((Me2) => t(Me2))), se;
                  }
                  let [Re2] = Fe2.match(xe2), [be2] = Fe2.match(Xe2), Le2 = [];
                  if (Re2) {
                    Le2 = [c];
                    let se = U(Re2);
                    se && (Le2 = Ae2(se)), Fe2 = Fe2.replace(xe2, "");
                  }
                  let qe2 = [];
                  if (be2) {
                    if (!_e2) {
                      qe2 = [c];
                      let se = U(be2);
                      se && (qe2 = Ae2(se)), I2(K) && (qe2 = qe2.map((He2) => t(He2)));
                    }
                    Fe2 = Fe2.replace(Xe2, "");
                  }
                  return [...Le2, s2(ie(Fe2)), ...qe2];
                }
                let We2 = U(Fe2), Be = le2(Fe2), Pe2 = ge2(Fe2);
                if ((ne || Ee) && J2 && C2(K, ["Block", "ElementNode", "Template"]))
                  return "";
                J2 && We2 ? (Be = Math.min(We2, l), Pe2 = 0) : (k2(K, ["BlockStatement", "ElementNode"]) && (Pe2 = Math.max(Pe2, 1)), D2(K, ["BlockStatement", "ElementNode"]) && (Be = Math.max(Be, 1)));
                let Se2 = "", Qe = "";
                return Pe2 === 0 && k2(K, ["MustacheStatement"]) && (Qe = " "), Be === 0 && D2(K, ["MustacheStatement"]) && (Se2 = " "), ne && (Be = 0, Se2 = ""), Ee && (Pe2 = 0, Qe = ""), Fe2 = Fe2.replace(/^[\t\n\f\r ]+/g, Se2).replace(/[\t\n\f\r ]+$/, Qe), [...Ae2(Be), s2(ie(Fe2)), ...Ae2(Pe2)];
              }
              case "MustacheCommentStatement": {
                let Fe2 = h2(Ce2), me2 = w2(Ce2), _ = he2.originalText.charAt(Fe2 + 2) === "~", J2 = he2.originalText.charAt(me2 - 3) === "~", ne = Ce2.value.includes("}}") ? "--" : "";
                return ["{{", _ ? "~" : "", "!", ne, Ce2.value, ne, J2 ? "~" : "", "}}"];
              }
              case "PathExpression":
                return Ce2.original;
              case "BooleanLiteral":
                return String(Ce2.value);
              case "CommentStatement":
                return ["<!--", Ce2.value, "-->"];
              case "StringLiteral": {
                if (ke2(K)) {
                  let Fe2 = he2.singleQuote ? '"' : "'";
                  return Ne2(Ce2.value, Fe2);
                }
                return Ne2(Ce2.value, Ie2);
              }
              case "NumberLiteral":
                return String(Ce2.value);
              case "UndefinedLiteral":
                return "undefined";
              case "NullLiteral":
                return "null";
              default:
                throw new Error("unknown glimmer type: " + JSON.stringify(Ce2.type));
            }
          }
          function y(K, he2) {
            return h2(K) - h2(he2);
          }
          function N(K, he2) {
            let ye2 = K.getValue(), Ce2 = ["attributes", "modifiers", "comments"].filter((Fe2) => f(ye2[Fe2])), Ie2 = Ce2.flatMap((Fe2) => ye2[Fe2]).sort(y);
            for (let Fe2 of Ce2)
              K.each((me2) => {
                let _ = Ie2.indexOf(me2.getValue());
                Ie2.splice(_, 1, [c, he2()]);
              }, Fe2);
            return f(ye2.blockParams) && Ie2.push(c, ve2(ye2)), ["<", ye2.tag, i2(Ie2), b2(ye2)];
          }
          function x2(K, he2, ye2) {
            let Ie2 = K.getValue().children.every((Fe2) => F(Fe2));
            return he2.htmlWhitespaceSensitivity === "ignore" && Ie2 ? "" : K.map((Fe2, me2) => {
              let _ = ye2();
              return me2 === 0 && he2.htmlWhitespaceSensitivity === "ignore" ? [v, _] : _;
            }, "children");
          }
          function b2(K) {
            return g2(K) ? u([v, "/>"], [" />", v]) : u([v, ">"], ">");
          }
          function L(K) {
            let he2 = K.escaped === false ? "{{{" : "{{", ye2 = K.strip && K.strip.open ? "~" : "";
            return [he2, ye2];
          }
          function M2(K) {
            let he2 = K.escaped === false ? "}}}" : "}}";
            return [K.strip && K.strip.close ? "~" : "", he2];
          }
          function j(K) {
            let he2 = L(K), ye2 = K.openStrip.open ? "~" : "";
            return [he2, ye2, "#"];
          }
          function $(K) {
            let he2 = M2(K);
            return [K.openStrip.close ? "~" : "", he2];
          }
          function V(K) {
            let he2 = L(K), ye2 = K.closeStrip.open ? "~" : "";
            return [he2, ye2, "/"];
          }
          function q(K) {
            let he2 = M2(K);
            return [K.closeStrip.close ? "~" : "", he2];
          }
          function Y3(K) {
            let he2 = L(K), ye2 = K.inverseStrip.open ? "~" : "";
            return [he2, ye2];
          }
          function H3(K) {
            let he2 = M2(K);
            return [K.inverseStrip.close ? "~" : "", he2];
          }
          function R(K, he2) {
            let ye2 = K.getValue(), Ce2 = j(ye2), Ie2 = $(ye2), Fe2 = [de2(K, he2)], me2 = ae2(K, he2);
            if (me2 && Fe2.push(c, me2), f(ye2.program.blockParams)) {
              let _ = ve2(ye2.program);
              Fe2.push(c, _);
            }
            return a3([Ce2, i2(Fe2), v, Ie2]);
          }
          function Q(K, he2) {
            return [he2.htmlWhitespaceSensitivity === "ignore" ? r : "", Y3(K), "else", H3(K)];
          }
          function ee2(K, he2) {
            let ye2 = K.getParentNode(1);
            return [Y3(ye2), "else if ", ae2(K, he2), H3(ye2)];
          }
          function te2(K, he2, ye2) {
            let Ce2 = K.getValue();
            return ye2.htmlWhitespaceSensitivity === "ignore" ? [oe2(Ce2) ? v : r, V(Ce2), he2("path"), q(Ce2)] : [V(Ce2), he2("path"), q(Ce2)];
          }
          function oe2(K) {
            return P(K, ["BlockStatement"]) && K.program.body.every((he2) => F(he2));
          }
          function W2(K) {
            return X3(K) && K.inverse.body.length === 1 && P(K.inverse.body[0], ["BlockStatement"]) && K.inverse.body[0].path.parts[0] === "if";
          }
          function X3(K) {
            return P(K, ["BlockStatement"]) && K.inverse;
          }
          function ue2(K, he2, ye2) {
            let Ce2 = K.getValue();
            if (oe2(Ce2))
              return "";
            let Ie2 = he2("program");
            return ye2.htmlWhitespaceSensitivity === "ignore" ? i2([r, Ie2]) : i2(Ie2);
          }
          function De2(K, he2, ye2) {
            let Ce2 = K.getValue(), Ie2 = he2("inverse"), Fe2 = ye2.htmlWhitespaceSensitivity === "ignore" ? [r, Ie2] : Ie2;
            return W2(Ce2) ? Fe2 : X3(Ce2) ? [Q(Ce2, ye2), i2(Fe2)] : "";
          }
          function ie(K) {
            return m2(o(c, G(K)));
          }
          function G(K) {
            return K.split(/[\t\n\f\r ]+/);
          }
          function z(K) {
            for (let he2 = 0; he2 < 2; he2++) {
              let ye2 = K.getParentNode(he2);
              if (ye2 && ye2.type === "AttrNode")
                return ye2.name.toLowerCase();
            }
          }
          function U(K) {
            return K = typeof K == "string" ? K : "", K.split(`
`).length - 1;
          }
          function le2(K) {
            K = typeof K == "string" ? K : "";
            let he2 = (K.match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "";
            return U(he2);
          }
          function ge2(K) {
            K = typeof K == "string" ? K : "";
            let he2 = (K.match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "";
            return U(he2);
          }
          function Ae2() {
            let K = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            return Array.from({ length: Math.min(K, l) }).fill(r);
          }
          function Ne2(K, he2) {
            let { quote: ye2, regex: Ce2 } = p(K, he2);
            return [ye2, K.replace(Ce2, "\\".concat(ye2)), ye2];
          }
          function ke2(K) {
            let he2 = 0, ye2 = K.getParentNode(he2);
            for (; ye2 && P(ye2, ["SubExpression"]); )
              he2++, ye2 = K.getParentNode(he2);
            return !!(ye2 && P(K.getParentNode(he2 + 1), ["ConcatStatement"]) && P(K.getParentNode(he2 + 2), ["AttrNode"]));
          }
          function ce(K, he2) {
            let ye2 = de2(K, he2), Ce2 = ae2(K, he2);
            return Ce2 ? i2([ye2, c, a3(Ce2)]) : ye2;
          }
          function pe(K, he2) {
            let ye2 = de2(K, he2), Ce2 = ae2(K, he2);
            return Ce2 ? [i2([ye2, c, Ce2]), v] : ye2;
          }
          function de2(K, he2) {
            return he2("path");
          }
          function ae2(K, he2) {
            let ye2 = K.getValue(), Ce2 = [];
            if (ye2.params.length > 0) {
              let Ie2 = K.map(he2, "params");
              Ce2.push(...Ie2);
            }
            if (ye2.hash && ye2.hash.pairs.length > 0) {
              let Ie2 = he2("hash");
              Ce2.push(Ie2);
            }
            return Ce2.length === 0 ? "" : o(c, Ce2);
          }
          function ve2(K) {
            return ["as |", K.blockParams.join(" "), "|"];
          }
          n.exports = { print: E, massageAstNode: T2 };
        } }), wd2 = Z3({ "src/language-handlebars/parsers.js"() {
          re2();
        } }), _d2 = Z3({ "node_modules/linguist-languages/data/Handlebars.json"(e, n) {
          n.exports = { name: "Handlebars", type: "markup", color: "#f7931e", aliases: ["hbs", "htmlbars"], extensions: [".handlebars", ".hbs"], tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155 };
        } }), Pd2 = Z3({ "src/language-handlebars/index.js"(e, n) {
          re2();
          var t = Bt(), s2 = Nd2(), a3 = wd2(), r = [t(_d2(), () => ({ since: "2.3.0", parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"] }))], u = { glimmer: s2 };
          n.exports = { languages: r, printers: u, parsers: a3 };
        } }), kd2 = Z3({ "src/language-graphql/pragma.js"(e, n) {
          re2();
          function t(a3) {
            return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(a3);
          }
          function s2(a3) {
            return `# @format

` + a3;
          }
          n.exports = { hasPragma: t, insertPragma: s2 };
        } }), Id2 = Z3({ "src/language-graphql/loc.js"(e, n) {
          re2();
          function t(a3) {
            return typeof a3.start == "number" ? a3.start : a3.loc && a3.loc.start;
          }
          function s2(a3) {
            return typeof a3.end == "number" ? a3.end : a3.loc && a3.loc.end;
          }
          n.exports = { locStart: t, locEnd: s2 };
        } }), Ld2 = Z3({ "src/language-graphql/printer-graphql.js"(e, n) {
          re2();
          var { builders: { join: t, hardline: s2, line: a3, softline: r, group: u, indent: i2, ifBreak: o } } = Oe2(), { isNextLineEmpty: c, isNonEmptyArray: v } = Ue2(), { insertPragma: m2 } = kd2(), { locStart: d4, locEnd: p } = Id2();
          function f(k2, P, C2) {
            let D2 = k2.getValue();
            if (!D2)
              return "";
            if (typeof D2 == "string")
              return D2;
            switch (D2.kind) {
              case "Document": {
                let g2 = [];
                return k2.each((F, l, E) => {
                  g2.push(C2()), l !== E.length - 1 && (g2.push(s2), c(P.originalText, F.getValue(), p) && g2.push(s2));
                }, "definitions"), [...g2, s2];
              }
              case "OperationDefinition": {
                let g2 = P.originalText[d4(D2)] !== "{", F = Boolean(D2.name);
                return [g2 ? D2.operation : "", g2 && F ? [" ", C2("name")] : "", g2 && !F && v(D2.variableDefinitions) ? " " : "", v(D2.variableDefinitions) ? u(["(", i2([r, t([o("", ", "), r], k2.map(C2, "variableDefinitions"))]), r, ")"]) : "", h2(k2, C2, D2), D2.selectionSet ? !g2 && !F ? "" : " " : "", C2("selectionSet")];
              }
              case "FragmentDefinition":
                return ["fragment ", C2("name"), v(D2.variableDefinitions) ? u(["(", i2([r, t([o("", ", "), r], k2.map(C2, "variableDefinitions"))]), r, ")"]) : "", " on ", C2("typeCondition"), h2(k2, C2, D2), " ", C2("selectionSet")];
              case "SelectionSet":
                return ["{", i2([s2, t(s2, w2(k2, P, C2, "selections"))]), s2, "}"];
              case "Field":
                return u([D2.alias ? [C2("alias"), ": "] : "", C2("name"), D2.arguments.length > 0 ? u(["(", i2([r, t([o("", ", "), r], w2(k2, P, C2, "arguments"))]), r, ")"]) : "", h2(k2, C2, D2), D2.selectionSet ? " " : "", C2("selectionSet")]);
              case "Name":
                return D2.value;
              case "StringValue": {
                if (D2.block) {
                  let g2 = D2.value.replace(/"""/g, "\\$&").split(`
`);
                  return g2.length === 1 && (g2[0] = g2[0].trim()), g2.every((F) => F === "") && (g2.length = 0), t(s2, ['"""', ...g2, '"""']);
                }
                return ['"', D2.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
              }
              case "IntValue":
              case "FloatValue":
              case "EnumValue":
                return D2.value;
              case "BooleanValue":
                return D2.value ? "true" : "false";
              case "NullValue":
                return "null";
              case "Variable":
                return ["$", C2("name")];
              case "ListValue":
                return u(["[", i2([r, t([o("", ", "), r], k2.map(C2, "values"))]), r, "]"]);
              case "ObjectValue":
                return u(["{", P.bracketSpacing && D2.fields.length > 0 ? " " : "", i2([r, t([o("", ", "), r], k2.map(C2, "fields"))]), r, o("", P.bracketSpacing && D2.fields.length > 0 ? " " : ""), "}"]);
              case "ObjectField":
              case "Argument":
                return [C2("name"), ": ", C2("value")];
              case "Directive":
                return ["@", C2("name"), D2.arguments.length > 0 ? u(["(", i2([r, t([o("", ", "), r], w2(k2, P, C2, "arguments"))]), r, ")"]) : ""];
              case "NamedType":
                return C2("name");
              case "VariableDefinition":
                return [C2("variable"), ": ", C2("type"), D2.defaultValue ? [" = ", C2("defaultValue")] : "", h2(k2, C2, D2)];
              case "ObjectTypeExtension":
              case "ObjectTypeDefinition":
                return [C2("description"), D2.description ? s2 : "", D2.kind === "ObjectTypeExtension" ? "extend " : "", "type ", C2("name"), D2.interfaces.length > 0 ? [" implements ", ...S2(k2, P, C2)] : "", h2(k2, C2, D2), D2.fields.length > 0 ? [" {", i2([s2, t(s2, w2(k2, P, C2, "fields"))]), s2, "}"] : ""];
              case "FieldDefinition":
                return [C2("description"), D2.description ? s2 : "", C2("name"), D2.arguments.length > 0 ? u(["(", i2([r, t([o("", ", "), r], w2(k2, P, C2, "arguments"))]), r, ")"]) : "", ": ", C2("type"), h2(k2, C2, D2)];
              case "DirectiveDefinition":
                return [C2("description"), D2.description ? s2 : "", "directive ", "@", C2("name"), D2.arguments.length > 0 ? u(["(", i2([r, t([o("", ", "), r], w2(k2, P, C2, "arguments"))]), r, ")"]) : "", D2.repeatable ? " repeatable" : "", " on ", t(" | ", k2.map(C2, "locations"))];
              case "EnumTypeExtension":
              case "EnumTypeDefinition":
                return [C2("description"), D2.description ? s2 : "", D2.kind === "EnumTypeExtension" ? "extend " : "", "enum ", C2("name"), h2(k2, C2, D2), D2.values.length > 0 ? [" {", i2([s2, t(s2, w2(k2, P, C2, "values"))]), s2, "}"] : ""];
              case "EnumValueDefinition":
                return [C2("description"), D2.description ? s2 : "", C2("name"), h2(k2, C2, D2)];
              case "InputValueDefinition":
                return [C2("description"), D2.description ? D2.description.block ? s2 : a3 : "", C2("name"), ": ", C2("type"), D2.defaultValue ? [" = ", C2("defaultValue")] : "", h2(k2, C2, D2)];
              case "InputObjectTypeExtension":
              case "InputObjectTypeDefinition":
                return [C2("description"), D2.description ? s2 : "", D2.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", C2("name"), h2(k2, C2, D2), D2.fields.length > 0 ? [" {", i2([s2, t(s2, w2(k2, P, C2, "fields"))]), s2, "}"] : ""];
              case "SchemaExtension":
                return ["extend schema", h2(k2, C2, D2), ...D2.operationTypes.length > 0 ? [" {", i2([s2, t(s2, w2(k2, P, C2, "operationTypes"))]), s2, "}"] : []];
              case "SchemaDefinition":
                return [C2("description"), D2.description ? s2 : "", "schema", h2(k2, C2, D2), " {", D2.operationTypes.length > 0 ? i2([s2, t(s2, w2(k2, P, C2, "operationTypes"))]) : "", s2, "}"];
              case "OperationTypeDefinition":
                return [C2("operation"), ": ", C2("type")];
              case "InterfaceTypeExtension":
              case "InterfaceTypeDefinition":
                return [C2("description"), D2.description ? s2 : "", D2.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", C2("name"), D2.interfaces.length > 0 ? [" implements ", ...S2(k2, P, C2)] : "", h2(k2, C2, D2), D2.fields.length > 0 ? [" {", i2([s2, t(s2, w2(k2, P, C2, "fields"))]), s2, "}"] : ""];
              case "FragmentSpread":
                return ["...", C2("name"), h2(k2, C2, D2)];
              case "InlineFragment":
                return ["...", D2.typeCondition ? [" on ", C2("typeCondition")] : "", h2(k2, C2, D2), " ", C2("selectionSet")];
              case "UnionTypeExtension":
              case "UnionTypeDefinition":
                return u([C2("description"), D2.description ? s2 : "", u([D2.kind === "UnionTypeExtension" ? "extend " : "", "union ", C2("name"), h2(k2, C2, D2), D2.types.length > 0 ? [" =", o("", " "), i2([o([a3, "  "]), t([a3, "| "], k2.map(C2, "types"))])] : ""])]);
              case "ScalarTypeExtension":
              case "ScalarTypeDefinition":
                return [C2("description"), D2.description ? s2 : "", D2.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", C2("name"), h2(k2, C2, D2)];
              case "NonNullType":
                return [C2("type"), "!"];
              case "ListType":
                return ["[", C2("type"), "]"];
              default:
                throw new Error("unknown graphql type: " + JSON.stringify(D2.kind));
            }
          }
          function h2(k2, P, C2) {
            if (C2.directives.length === 0)
              return "";
            let D2 = t(a3, k2.map(P, "directives"));
            return C2.kind === "FragmentDefinition" || C2.kind === "OperationDefinition" ? u([a3, D2]) : [" ", u(i2([r, D2]))];
          }
          function w2(k2, P, C2, D2) {
            return k2.map((g2, F, l) => {
              let E = C2();
              return F < l.length - 1 && c(P.originalText, g2.getValue(), p) ? [E, s2] : E;
            }, D2);
          }
          function T2(k2) {
            return k2.kind && k2.kind !== "Comment";
          }
          function A2(k2) {
            let P = k2.getValue();
            if (P.kind === "Comment")
              return "#" + P.value.trimEnd();
            throw new Error("Not a comment: " + JSON.stringify(P));
          }
          function S2(k2, P, C2) {
            let D2 = k2.getNode(), g2 = [], { interfaces: F } = D2, l = k2.map((E) => C2(E), "interfaces");
            for (let E = 0; E < F.length; E++) {
              let y = F[E];
              g2.push(l[E]);
              let N = F[E + 1];
              if (N) {
                let x2 = P.originalText.slice(y.loc.end, N.loc.start), b2 = x2.includes("#"), L = x2.replace(/#.*/g, "").trim();
                g2.push(L === "," ? "," : " &", b2 ? a3 : " ");
              }
            }
            return g2;
          }
          function B(k2, P) {
            k2.kind === "StringValue" && k2.block && !k2.value.includes(`
`) && (P.value = P.value.trim());
          }
          B.ignoredProperties = /* @__PURE__ */ new Set(["loc", "comments"]);
          function I2(k2) {
            var P;
            let C2 = k2.getValue();
            return C2 == null || (P = C2.comments) === null || P === void 0 ? void 0 : P.some((D2) => D2.value.trim() === "prettier-ignore");
          }
          n.exports = { print: f, massageAstNode: B, hasPrettierIgnore: I2, insertPragma: m2, printComment: A2, canAttachComment: T2 };
        } }), jd2 = Z3({ "src/language-graphql/options.js"(e, n) {
          re2();
          var t = Ot2();
          n.exports = { bracketSpacing: t.bracketSpacing };
        } }), Od2 = Z3({ "src/language-graphql/parsers.js"() {
          re2();
        } }), qd2 = Z3({ "node_modules/linguist-languages/data/GraphQL.json"(e, n) {
          n.exports = { name: "GraphQL", type: "data", color: "#e10098", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", aceMode: "text", languageId: 139 };
        } }), Md2 = Z3({ "src/language-graphql/index.js"(e, n) {
          re2();
          var t = Bt(), s2 = Ld2(), a3 = jd2(), r = Od2(), u = [t(qd2(), () => ({ since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"] }))], i2 = { graphql: s2 };
          n.exports = { languages: u, options: a3, printers: i2, parsers: r };
        } }), go2 = Z3({ "src/language-markdown/loc.js"(e, n) {
          re2();
          function t(a3) {
            return a3.position.start.offset;
          }
          function s2(a3) {
            return a3.position.end.offset;
          }
          n.exports = { locStart: t, locEnd: s2 };
        } }), Rd2 = Z3({ "src/language-markdown/constants.evaluate.js"(e, n) {
          n.exports = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" };
        } }), Kn2 = Z3({ "src/language-markdown/utils.js"(e, n) {
          re2();
          var { getLast: t } = Ue2(), { locStart: s2, locEnd: a3 } = go2(), { cjkPattern: r, kPattern: u, punctuationPattern: i2 } = Rd2(), o = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], c = [...o, "tableCell", "paragraph", "heading"], v = new RegExp(u), m2 = new RegExp(i2);
          function d4(A2, S2) {
            let B = "non-cjk", I2 = "cj-letter", k2 = "k-letter", P = "cjk-punctuation", C2 = [], D2 = (S2.proseWrap === "preserve" ? A2 : A2.replace(new RegExp("(".concat(r, `)
(`).concat(r, ")"), "g"), "$1$2")).split(/([\t\n ]+)/);
            for (let [F, l] of D2.entries()) {
              if (F % 2 === 1) {
                C2.push({ type: "whitespace", value: /\n/.test(l) ? `
` : " " });
                continue;
              }
              if ((F === 0 || F === D2.length - 1) && l === "")
                continue;
              let E = l.split(new RegExp("(".concat(r, ")")));
              for (let [y, N] of E.entries())
                if (!((y === 0 || y === E.length - 1) && N === "")) {
                  if (y % 2 === 0) {
                    N !== "" && g2({ type: "word", value: N, kind: B, hasLeadingPunctuation: m2.test(N[0]), hasTrailingPunctuation: m2.test(t(N)) });
                    continue;
                  }
                  g2(m2.test(N) ? { type: "word", value: N, kind: P, hasLeadingPunctuation: true, hasTrailingPunctuation: true } : { type: "word", value: N, kind: v.test(N) ? k2 : I2, hasLeadingPunctuation: false, hasTrailingPunctuation: false });
                }
            }
            return C2;
            function g2(F) {
              let l = t(C2);
              l && l.type === "word" && (l.kind === B && F.kind === I2 && !l.hasTrailingPunctuation || l.kind === I2 && F.kind === B && !F.hasLeadingPunctuation ? C2.push({ type: "whitespace", value: " " }) : !E(B, P) && ![l.value, F.value].some((y) => /\u3000/.test(y)) && C2.push({ type: "whitespace", value: "" })), C2.push(F);
              function E(y, N) {
                return l.kind === y && F.kind === N || l.kind === N && F.kind === y;
              }
            }
          }
          function p(A2, S2) {
            let [, B, I2, k2] = S2.slice(A2.position.start.offset, A2.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
            return { numberText: B, marker: I2, leadingSpaces: k2 };
          }
          function f(A2, S2) {
            if (!A2.ordered || A2.children.length < 2)
              return false;
            let B = Number(p(A2.children[0], S2.originalText).numberText), I2 = Number(p(A2.children[1], S2.originalText).numberText);
            if (B === 0 && A2.children.length > 2) {
              let k2 = Number(p(A2.children[2], S2.originalText).numberText);
              return I2 === 1 && k2 === 1;
            }
            return I2 === 1;
          }
          function h2(A2, S2) {
            let { value: B } = A2;
            return A2.position.end.offset === S2.length && B.endsWith(`
`) && S2.endsWith(`
`) ? B.slice(0, -1) : B;
          }
          function w2(A2, S2) {
            return function B(I2, k2, P) {
              let C2 = Object.assign({}, S2(I2, k2, P));
              return C2.children && (C2.children = C2.children.map((D2, g2) => B(D2, g2, [C2, ...P]))), C2;
            }(A2, null, []);
          }
          function T2(A2) {
            if ((A2 == null ? void 0 : A2.type) !== "link" || A2.children.length !== 1)
              return false;
            let [S2] = A2.children;
            return s2(A2) === s2(S2) && a3(A2) === a3(S2);
          }
          n.exports = { mapAst: w2, splitText: d4, punctuationPattern: i2, getFencedCodeBlockValue: h2, getOrderedListItemInfo: p, hasGitDiffFriendlyOrderedList: f, INLINE_NODE_TYPES: o, INLINE_NODE_WRAPPER_TYPES: c, isAutolink: T2 };
        } }), Vd2 = Z3({ "src/language-markdown/embed.js"(e, n) {
          re2();
          var { inferParserByLanguage: t, getMaxContinuousCount: s2 } = Ue2(), { builders: { hardline: a3, markAsRoot: r }, utils: { replaceEndOfLine: u } } = Oe2(), i2 = Xn2(), { getFencedCodeBlockValue: o } = Kn2();
          function c(v, m2, d4, p) {
            let f = v.getValue();
            if (f.type === "code" && f.lang !== null) {
              let h2 = t(f.lang, p);
              if (h2) {
                let w2 = p.__inJsTemplate ? "~" : "`", T2 = w2.repeat(Math.max(3, s2(f.value, w2) + 1)), A2 = { parser: h2 };
                f.lang === "tsx" && (A2.filepath = "dummy.tsx");
                let S2 = d4(o(f, p.originalText), A2, { stripTrailingHardline: true });
                return r([T2, f.lang, f.meta ? " " + f.meta : "", a3, u(S2), a3, T2]);
              }
            }
            switch (f.type) {
              case "front-matter":
                return i2(f, d4);
              case "importExport":
                return [d4(f.value, { parser: "babel" }, { stripTrailingHardline: true }), a3];
              case "jsx":
                return d4("<$>".concat(f.value, "</$>"), { parser: "__js_expression", rootMarker: "mdx" }, { stripTrailingHardline: true });
            }
            return null;
          }
          n.exports = c;
        } }), yo2 = Z3({ "src/language-markdown/pragma.js"(e, n) {
          re2();
          var t = mo2(), s2 = ["format", "prettier"];
          function a3(r) {
            let u = "@(".concat(s2.join("|"), ")"), i2 = new RegExp(["<!--\\s*".concat(u, "\\s*-->"), "{\\s*\\/\\*\\s*".concat(u, "\\s*\\*\\/\\s*}"), `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*`.concat(u, `[^\\S
]*($|
)[\\s\\S]*
.*-->`)].join("|"), "m"), o = r.match(i2);
            return (o == null ? void 0 : o.index) === 0;
          }
          n.exports = { startWithPragma: a3, hasPragma: (r) => a3(t(r).content.trimStart()), insertPragma: (r) => {
            let u = t(r), i2 = "<!-- @".concat(s2[0], " -->");
            return u.frontMatter ? "".concat(u.frontMatter.raw, `

`).concat(i2, `

`).concat(u.content) : "".concat(i2, `

`).concat(u.content);
          } };
        } }), Wd2 = Z3({ "src/language-markdown/print-preprocess.js"(e, n) {
          re2();
          var t = it2(), { getOrderedListItemInfo: s2, mapAst: a3, splitText: r } = Kn2(), u = /^.$/su;
          function i2(T2, A2) {
            return T2 = v(T2, A2), T2 = p(T2), T2 = c(T2), T2 = h2(T2, A2), T2 = w2(T2, A2), T2 = f(T2, A2), T2 = o(T2), T2 = m2(T2), T2;
          }
          function o(T2) {
            return a3(T2, (A2) => A2.type !== "import" && A2.type !== "export" ? A2 : Object.assign(Object.assign({}, A2), {}, { type: "importExport" }));
          }
          function c(T2) {
            return a3(T2, (A2) => A2.type !== "inlineCode" ? A2 : Object.assign(Object.assign({}, A2), {}, { value: A2.value.replace(/\s+/g, " ") }));
          }
          function v(T2, A2) {
            return a3(T2, (S2) => S2.type !== "text" || S2.value === "*" || S2.value === "_" || !u.test(S2.value) || S2.position.end.offset - S2.position.start.offset === S2.value.length ? S2 : Object.assign(Object.assign({}, S2), {}, { value: A2.originalText.slice(S2.position.start.offset, S2.position.end.offset) }));
          }
          function m2(T2) {
            return d4(T2, (A2, S2) => A2.type === "importExport" && S2.type === "importExport", (A2, S2) => ({ type: "importExport", value: A2.value + `

` + S2.value, position: { start: A2.position.start, end: S2.position.end } }));
          }
          function d4(T2, A2, S2) {
            return a3(T2, (B) => {
              if (!B.children)
                return B;
              let I2 = B.children.reduce((k2, P) => {
                let C2 = t(k2);
                return C2 && A2(C2, P) ? k2.splice(-1, 1, S2(C2, P)) : k2.push(P), k2;
              }, []);
              return Object.assign(Object.assign({}, B), {}, { children: I2 });
            });
          }
          function p(T2) {
            return d4(T2, (A2, S2) => A2.type === "text" && S2.type === "text", (A2, S2) => ({ type: "text", value: A2.value + S2.value, position: { start: A2.position.start, end: S2.position.end } }));
          }
          function f(T2, A2) {
            return a3(T2, (S2, B, I2) => {
              let [k2] = I2;
              if (S2.type !== "text")
                return S2;
              let { value: P } = S2;
              return k2.type === "paragraph" && (B === 0 && (P = P.trimStart()), B === k2.children.length - 1 && (P = P.trimEnd())), { type: "sentence", position: S2.position, children: r(P, A2) };
            });
          }
          function h2(T2, A2) {
            return a3(T2, (S2, B, I2) => {
              if (S2.type === "code") {
                let k2 = /^\n?(?: {4,}|\t)/.test(A2.originalText.slice(S2.position.start.offset, S2.position.end.offset));
                if (S2.isIndented = k2, k2)
                  for (let P = 0; P < I2.length; P++) {
                    let C2 = I2[P];
                    if (C2.hasIndentedCodeblock)
                      break;
                    C2.type === "list" && (C2.hasIndentedCodeblock = true);
                  }
              }
              return S2;
            });
          }
          function w2(T2, A2) {
            return a3(T2, (I2, k2, P) => {
              if (I2.type === "list" && I2.children.length > 0) {
                for (let C2 = 0; C2 < P.length; C2++) {
                  let D2 = P[C2];
                  if (D2.type === "list" && !D2.isAligned)
                    return I2.isAligned = false, I2;
                }
                I2.isAligned = B(I2);
              }
              return I2;
            });
            function S2(I2) {
              return I2.children.length === 0 ? -1 : I2.children[0].position.start.column - 1;
            }
            function B(I2) {
              if (!I2.ordered)
                return true;
              let [k2, P] = I2.children;
              if (s2(k2, A2.originalText).leadingSpaces.length > 1)
                return true;
              let D2 = S2(k2);
              if (D2 === -1)
                return false;
              if (I2.children.length === 1)
                return D2 % A2.tabWidth === 0;
              let g2 = S2(P);
              return D2 !== g2 ? false : D2 % A2.tabWidth === 0 ? true : s2(P, A2.originalText).leadingSpaces.length > 1;
            }
          }
          n.exports = i2;
        } }), $d2 = Z3({ "src/language-markdown/clean.js"(e, n) {
          re2();
          var { isFrontMatterNode: t } = Ue2(), { startWithPragma: s2 } = yo2(), a3 = /* @__PURE__ */ new Set(["position", "raw"]);
          function r(u, i2, o) {
            if ((u.type === "front-matter" || u.type === "code" || u.type === "yaml" || u.type === "import" || u.type === "export" || u.type === "jsx") && delete i2.value, u.type === "list" && delete i2.isAligned, (u.type === "list" || u.type === "listItem") && (delete i2.spread, delete i2.loose), u.type === "text" || (u.type === "inlineCode" && (i2.value = u.value.replace(/[\t\n ]+/g, " ")), u.type === "wikiLink" && (i2.value = u.value.trim().replace(/[\t\n]+/g, " ")), (u.type === "definition" || u.type === "linkReference") && (i2.label = u.label.trim().replace(/[\t\n ]+/g, " ").toLowerCase()), (u.type === "definition" || u.type === "link" || u.type === "image") && u.title && (i2.title = u.title.replace(/\\(["')])/g, "$1")), o && o.type === "root" && o.children.length > 0 && (o.children[0] === u || t(o.children[0]) && o.children[1] === u) && u.type === "html" && s2(u.value)))
              return null;
          }
          r.ignoredProperties = a3, n.exports = r;
        } }), Hd2 = Z3({ "src/language-markdown/printer-markdown.js"(e, n) {
          re2();
          var { getLast: t, getMinNotPresentContinuousCount: s2, getMaxContinuousCount: a3, getStringWidth: r, isNonEmptyArray: u } = Ue2(), { builders: { breakParent: i2, join: o, line: c, literalline: v, markAsRoot: m2, hardline: d4, softline: p, ifBreak: f, fill: h2, align: w2, indent: T2, group: A2, hardlineWithoutBreakParent: S2 }, utils: { normalizeDoc: B, replaceTextEndOfLine: I2 }, printer: { printDocToString: k2 } } = Oe2(), P = Vd2(), { insertPragma: C2 } = yo2(), { locStart: D2, locEnd: g2 } = go2(), F = Wd2(), l = $d2(), { getFencedCodeBlockValue: E, hasGitDiffFriendlyOrderedList: y, splitText: N, punctuationPattern: x2, INLINE_NODE_TYPES: b2, INLINE_NODE_WRAPPER_TYPES: L, isAutolink: M2 } = Kn2(), j = /* @__PURE__ */ new Set(["importExport"]), $ = ["heading", "tableCell", "link", "wikiLink"], V = /* @__PURE__ */ new Set(["listItem", "definition", "footnoteDefinition"]);
          function q(ce, pe, de2) {
            let ae2 = ce.getValue();
            if (le2(ce))
              return N(pe.originalText.slice(ae2.position.start.offset, ae2.position.end.offset), pe).map((ve2) => ve2.type === "word" ? ve2.value : ve2.value === "" ? "" : oe2(ce, ve2.value, pe));
            switch (ae2.type) {
              case "front-matter":
                return pe.originalText.slice(ae2.position.start.offset, ae2.position.end.offset);
              case "root":
                return ae2.children.length === 0 ? "" : [B(X3(ce, pe, de2)), j.has(De2(ae2).type) ? "" : d4];
              case "paragraph":
                return ue2(ce, pe, de2, { postprocessor: h2 });
              case "sentence":
                return ue2(ce, pe, de2);
              case "word": {
                let ve2 = ae2.value.replace(/\*/g, "\\$&").replace(new RegExp(["(^|".concat(x2, ")(_+)"), "(_+)(".concat(x2, "|$)")].join("|"), "g"), (ye2, Ce2, Ie2, Fe2, me2) => (Ie2 ? "".concat(Ce2).concat(Ie2) : "".concat(Fe2).concat(me2)).replace(/_/g, "\\_")), K = (ye2, Ce2, Ie2) => ye2.type === "sentence" && Ie2 === 0, he2 = (ye2, Ce2, Ie2) => M2(ye2.children[Ie2 - 1]);
                return ve2 !== ae2.value && (ce.match(void 0, K, he2) || ce.match(void 0, K, (ye2, Ce2, Ie2) => ye2.type === "emphasis" && Ie2 === 0, he2)) && (ve2 = ve2.replace(/^(\\?[*_])+/, (ye2) => ye2.replace(/\\/g, ""))), ve2;
              }
              case "whitespace": {
                let ve2 = ce.getParentNode(), K = ve2.children.indexOf(ae2), he2 = ve2.children[K + 1], ye2 = he2 && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(he2.value) ? "never" : pe.proseWrap;
                return oe2(ce, ae2.value, { proseWrap: ye2 });
              }
              case "emphasis": {
                let ve2;
                if (M2(ae2.children[0]))
                  ve2 = pe.originalText[ae2.position.start.offset];
                else {
                  let K = ce.getParentNode(), he2 = K.children.indexOf(ae2), ye2 = K.children[he2 - 1], Ce2 = K.children[he2 + 1];
                  ve2 = ye2 && ye2.type === "sentence" && ye2.children.length > 0 && t(ye2.children).type === "word" && !t(ye2.children).hasTrailingPunctuation || Ce2 && Ce2.type === "sentence" && Ce2.children.length > 0 && Ce2.children[0].type === "word" && !Ce2.children[0].hasLeadingPunctuation || te2(ce, "emphasis") ? "*" : "_";
                }
                return [ve2, ue2(ce, pe, de2), ve2];
              }
              case "strong":
                return ["**", ue2(ce, pe, de2), "**"];
              case "delete":
                return ["~~", ue2(ce, pe, de2), "~~"];
              case "inlineCode": {
                let ve2 = s2(ae2.value, "`"), K = "`".repeat(ve2 || 1), he2 = ve2 && !/^\s/.test(ae2.value) ? " " : "";
                return [K, he2, ae2.value, he2, K];
              }
              case "wikiLink": {
                let ve2 = "";
                return pe.proseWrap === "preserve" ? ve2 = ae2.value : ve2 = ae2.value.replace(/[\t\n]+/g, " "), ["[[", ve2, "]]"];
              }
              case "link":
                switch (pe.originalText[ae2.position.start.offset]) {
                  case "<": {
                    let ve2 = "mailto:", K = ae2.url.startsWith(ve2) && pe.originalText.slice(ae2.position.start.offset + 1, ae2.position.start.offset + 1 + ve2.length) !== ve2 ? ae2.url.slice(ve2.length) : ae2.url;
                    return ["<", K, ">"];
                  }
                  case "[":
                    return ["[", ue2(ce, pe, de2), "](", ge2(ae2.url, ")"), Ae2(ae2.title, pe), ")"];
                  default:
                    return pe.originalText.slice(ae2.position.start.offset, ae2.position.end.offset);
                }
              case "image":
                return ["![", ae2.alt || "", "](", ge2(ae2.url, ")"), Ae2(ae2.title, pe), ")"];
              case "blockquote":
                return ["> ", w2("> ", ue2(ce, pe, de2))];
              case "heading":
                return ["#".repeat(ae2.depth) + " ", ue2(ce, pe, de2)];
              case "code": {
                if (ae2.isIndented) {
                  let he2 = " ".repeat(4);
                  return w2(he2, [he2, ...I2(ae2.value, d4)]);
                }
                let ve2 = pe.__inJsTemplate ? "~" : "`", K = ve2.repeat(Math.max(3, a3(ae2.value, ve2) + 1));
                return [K, ae2.lang || "", ae2.meta ? " " + ae2.meta : "", d4, ...I2(E(ae2, pe.originalText), d4), d4, K];
              }
              case "html": {
                let ve2 = ce.getParentNode(), K = ve2.type === "root" && t(ve2.children) === ae2 ? ae2.value.trimEnd() : ae2.value, he2 = /^<!--.*-->$/s.test(K);
                return I2(K, he2 ? d4 : m2(v));
              }
              case "list": {
                let ve2 = R(ae2, ce.getParentNode()), K = y(ae2, pe);
                return ue2(ce, pe, de2, { processor: (he2, ye2) => {
                  let Ce2 = Fe2(), Ie2 = he2.getValue();
                  if (Ie2.children.length === 2 && Ie2.children[1].type === "html" && Ie2.children[0].position.start.column !== Ie2.children[1].position.start.column)
                    return [Ce2, Y3(he2, pe, de2, Ce2)];
                  return [Ce2, w2(" ".repeat(Ce2.length), Y3(he2, pe, de2, Ce2))];
                  function Fe2() {
                    let me2 = ae2.ordered ? (ye2 === 0 ? ae2.start : K ? 1 : ae2.start + ye2) + (ve2 % 2 === 0 ? ". " : ") ") : ve2 % 2 === 0 ? "- " : "* ";
                    return ae2.isAligned || ae2.hasIndentedCodeblock ? H3(me2, pe) : me2;
                  }
                } });
              }
              case "thematicBreak": {
                let ve2 = ee2(ce, "list");
                return ve2 === -1 ? "---" : R(ce.getParentNode(ve2), ce.getParentNode(ve2 + 1)) % 2 === 0 ? "***" : "---";
              }
              case "linkReference":
                return ["[", ue2(ce, pe, de2), "]", ae2.referenceType === "full" ? ["[", ae2.identifier, "]"] : ae2.referenceType === "collapsed" ? "[]" : ""];
              case "imageReference":
                switch (ae2.referenceType) {
                  case "full":
                    return ["![", ae2.alt || "", "][", ae2.identifier, "]"];
                  default:
                    return ["![", ae2.alt, "]", ae2.referenceType === "collapsed" ? "[]" : ""];
                }
              case "definition": {
                let ve2 = pe.proseWrap === "always" ? c : " ";
                return A2(["[", ae2.identifier, "]:", T2([ve2, ge2(ae2.url), ae2.title === null ? "" : [ve2, Ae2(ae2.title, pe, false)]])]);
              }
              case "footnote":
                return ["[^", ue2(ce, pe, de2), "]"];
              case "footnoteReference":
                return ["[^", ae2.identifier, "]"];
              case "footnoteDefinition": {
                let ve2 = ce.getParentNode().children[ce.getName() + 1], K = ae2.children.length === 1 && ae2.children[0].type === "paragraph" && (pe.proseWrap === "never" || pe.proseWrap === "preserve" && ae2.children[0].position.start.line === ae2.children[0].position.end.line);
                return ["[^", ae2.identifier, "]: ", K ? ue2(ce, pe, de2) : A2([w2(" ".repeat(4), ue2(ce, pe, de2, { processor: (he2, ye2) => ye2 === 0 ? A2([p, de2()]) : de2() })), ve2 && ve2.type === "footnoteDefinition" ? p : ""])];
              }
              case "table":
                return W2(ce, pe, de2);
              case "tableCell":
                return ue2(ce, pe, de2);
              case "break":
                return /\s/.test(pe.originalText[ae2.position.start.offset]) ? ["  ", m2(v)] : ["\\", d4];
              case "liquidNode":
                return I2(ae2.value, d4);
              case "importExport":
                return [ae2.value, d4];
              case "esComment":
                return ["{/* ", ae2.value, " */}"];
              case "jsx":
                return ae2.value;
              case "math":
                return ["$$", d4, ae2.value ? [...I2(ae2.value, d4), d4] : "", "$$"];
              case "inlineMath":
                return pe.originalText.slice(D2(ae2), g2(ae2));
              case "tableRow":
              case "listItem":
              default:
                throw new Error("Unknown markdown type ".concat(JSON.stringify(ae2.type)));
            }
          }
          function Y3(ce, pe, de2, ae2) {
            let ve2 = ce.getValue(), K = ve2.checked === null ? "" : ve2.checked ? "[x] " : "[ ] ";
            return [K, ue2(ce, pe, de2, { processor: (he2, ye2) => {
              if (ye2 === 0 && he2.getValue().type !== "list")
                return w2(" ".repeat(K.length), de2());
              let Ce2 = " ".repeat(Ne2(pe.tabWidth - ae2.length, 0, 3));
              return [Ce2, w2(Ce2, de2())];
            } })];
          }
          function H3(ce, pe) {
            let de2 = ae2();
            return ce + " ".repeat(de2 >= 4 ? 0 : de2);
            function ae2() {
              let ve2 = ce.length % pe.tabWidth;
              return ve2 === 0 ? 0 : pe.tabWidth - ve2;
            }
          }
          function R(ce, pe) {
            return Q(ce, pe, (de2) => de2.ordered === ce.ordered);
          }
          function Q(ce, pe, de2) {
            let ae2 = -1;
            for (let ve2 of pe.children)
              if (ve2.type === ce.type && de2(ve2) ? ae2++ : ae2 = -1, ve2 === ce)
                return ae2;
          }
          function ee2(ce, pe) {
            let de2 = Array.isArray(pe) ? pe : [pe], ae2 = -1, ve2;
            for (; ve2 = ce.getParentNode(++ae2); )
              if (de2.includes(ve2.type))
                return ae2;
            return -1;
          }
          function te2(ce, pe) {
            let de2 = ee2(ce, pe);
            return de2 === -1 ? null : ce.getParentNode(de2);
          }
          function oe2(ce, pe, de2) {
            if (de2.proseWrap === "preserve" && pe === `
`)
              return d4;
            let ae2 = de2.proseWrap === "always" && !te2(ce, $);
            return pe !== "" ? ae2 ? c : " " : ae2 ? p : "";
          }
          function W2(ce, pe, de2) {
            let ae2 = ce.getValue(), ve2 = [], K = ce.map((me2) => me2.map((_, J2) => {
              let ne = k2(de2(), pe).formatted, Ee = r(ne);
              return ve2[J2] = Math.max(ve2[J2] || 3, Ee), { text: ne, width: Ee };
            }, "children"), "children"), he2 = Ce2(false);
            if (pe.proseWrap !== "never")
              return [i2, he2];
            let ye2 = Ce2(true);
            return [i2, A2(f(ye2, he2))];
            function Ce2(me2) {
              let _ = [Fe2(K[0], me2), Ie2(me2)];
              return K.length > 1 && _.push(o(S2, K.slice(1).map((J2) => Fe2(J2, me2)))), o(S2, _);
            }
            function Ie2(me2) {
              let _ = ve2.map((J2, ne) => {
                let Ee = ae2.align[ne], We2 = Ee === "center" || Ee === "left" ? ":" : "-", Be = Ee === "center" || Ee === "right" ? ":" : "-", Pe2 = me2 ? "-" : "-".repeat(J2 - 2);
                return "".concat(We2).concat(Pe2).concat(Be);
              });
              return "| ".concat(_.join(" | "), " |");
            }
            function Fe2(me2, _) {
              let J2 = me2.map((ne, Ee) => {
                let { text: We2, width: Be } = ne;
                if (_)
                  return We2;
                let Pe2 = ve2[Ee] - Be, Se2 = ae2.align[Ee], Qe = 0;
                Se2 === "right" ? Qe = Pe2 : Se2 === "center" && (Qe = Math.floor(Pe2 / 2));
                let xe2 = Pe2 - Qe;
                return "".concat(" ".repeat(Qe)).concat(We2).concat(" ".repeat(xe2));
              });
              return "| ".concat(J2.join(" | "), " |");
            }
          }
          function X3(ce, pe, de2) {
            let ae2 = [], ve2 = null, { children: K } = ce.getValue();
            for (let [he2, ye2] of K.entries())
              switch (ie(ye2)) {
                case "start":
                  ve2 === null && (ve2 = { index: he2, offset: ye2.position.end.offset });
                  break;
                case "end":
                  ve2 !== null && (ae2.push({ start: ve2, end: { index: he2, offset: ye2.position.start.offset } }), ve2 = null);
                  break;
              }
            return ue2(ce, pe, de2, { processor: (he2, ye2) => {
              if (ae2.length > 0) {
                let Ce2 = ae2[0];
                if (ye2 === Ce2.start.index)
                  return [K[Ce2.start.index].value, pe.originalText.slice(Ce2.start.offset, Ce2.end.offset), K[Ce2.end.index].value];
                if (Ce2.start.index < ye2 && ye2 < Ce2.end.index)
                  return false;
                if (ye2 === Ce2.end.index)
                  return ae2.shift(), false;
              }
              return de2();
            } });
          }
          function ue2(ce, pe, de2) {
            let ae2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, { postprocessor: ve2 } = ae2, K = ae2.processor || (() => de2()), he2 = ce.getValue(), ye2 = [], Ce2;
            return ce.each((Ie2, Fe2) => {
              let me2 = Ie2.getValue(), _ = K(Ie2, Fe2);
              if (_ !== false) {
                let J2 = { parts: ye2, prevNode: Ce2, parentNode: he2, options: pe };
                G(me2, J2) && (ye2.push(d4), Ce2 && j.has(Ce2.type) || (z(me2, J2) || U(me2, J2)) && ye2.push(d4), U(me2, J2) && ye2.push(d4)), ye2.push(_), Ce2 = me2;
              }
            }, "children"), ve2 ? ve2(ye2) : ye2;
          }
          function De2(ce) {
            let pe = ce;
            for (; u(pe.children); )
              pe = t(pe.children);
            return pe;
          }
          function ie(ce) {
            let pe;
            if (ce.type === "html")
              pe = ce.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
            else {
              let de2;
              ce.type === "esComment" ? de2 = ce : ce.type === "paragraph" && ce.children.length === 1 && ce.children[0].type === "esComment" && (de2 = ce.children[0]), de2 && (pe = de2.value.match(/^prettier-ignore(?:-(start|end))?$/));
            }
            return pe ? pe[1] || "next" : false;
          }
          function G(ce, pe) {
            let de2 = pe.parts.length === 0, ae2 = b2.includes(ce.type), ve2 = ce.type === "html" && L.includes(pe.parentNode.type);
            return !de2 && !ae2 && !ve2;
          }
          function z(ce, pe) {
            var de2, ae2, ve2;
            let he2 = (pe.prevNode && pe.prevNode.type) === ce.type && V.has(ce.type), ye2 = pe.parentNode.type === "listItem" && !pe.parentNode.loose, Ce2 = ((de2 = pe.prevNode) === null || de2 === void 0 ? void 0 : de2.type) === "listItem" && pe.prevNode.loose, Ie2 = ie(pe.prevNode) === "next", Fe2 = ce.type === "html" && ((ae2 = pe.prevNode) === null || ae2 === void 0 ? void 0 : ae2.type) === "html" && pe.prevNode.position.end.line + 1 === ce.position.start.line, me2 = ce.type === "html" && pe.parentNode.type === "listItem" && ((ve2 = pe.prevNode) === null || ve2 === void 0 ? void 0 : ve2.type) === "paragraph" && pe.prevNode.position.end.line + 1 === ce.position.start.line;
            return Ce2 || !(he2 || ye2 || Ie2 || Fe2 || me2);
          }
          function U(ce, pe) {
            let de2 = pe.prevNode && pe.prevNode.type === "list", ae2 = ce.type === "code" && ce.isIndented;
            return de2 && ae2;
          }
          function le2(ce) {
            let pe = te2(ce, ["linkReference", "imageReference"]);
            return pe && (pe.type !== "linkReference" || pe.referenceType !== "full");
          }
          function ge2(ce) {
            let pe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], de2 = [" ", ...Array.isArray(pe) ? pe : [pe]];
            return new RegExp(de2.map((ae2) => "\\".concat(ae2)).join("|")).test(ce) ? "<".concat(ce, ">") : ce;
          }
          function Ae2(ce, pe) {
            let de2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
            if (!ce)
              return "";
            if (de2)
              return " " + Ae2(ce, pe, false);
            if (ce = ce.replace(/\\(["')])/g, "$1"), ce.includes('"') && ce.includes("'") && !ce.includes(")"))
              return "(".concat(ce, ")");
            let ae2 = ce.split("'").length - 1, ve2 = ce.split('"').length - 1, K = ae2 > ve2 ? '"' : ve2 > ae2 || pe.singleQuote ? "'" : '"';
            return ce = ce.replace(/\\/, "\\\\"), ce = ce.replace(new RegExp("(".concat(K, ")"), "g"), "\\$1"), "".concat(K).concat(ce).concat(K);
          }
          function Ne2(ce, pe, de2) {
            return ce < pe ? pe : ce > de2 ? de2 : ce;
          }
          function ke2(ce) {
            let pe = Number(ce.getName());
            if (pe === 0)
              return false;
            let de2 = ce.getParentNode().children[pe - 1];
            return ie(de2) === "next";
          }
          n.exports = { preprocess: F, print: q, embed: P, massageAstNode: l, hasPrettierIgnore: ke2, insertPragma: C2 };
        } }), Gd2 = Z3({ "src/language-markdown/options.js"(e, n) {
          re2();
          var t = Ot2();
          n.exports = { proseWrap: t.proseWrap, singleQuote: t.singleQuote };
        } }), Jd2 = Z3({ "src/language-markdown/parsers.js"() {
          re2();
        } }), da2 = Z3({ "node_modules/linguist-languages/data/Markdown.json"(e, n) {
          n.exports = { name: "Markdown", type: "prose", color: "#083fa1", aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: [".md", ".livemd", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"], filenames: ["contents.lr"], tmScope: "source.gfm", languageId: 222 };
        } }), Ud2 = Z3({ "src/language-markdown/index.js"(e, n) {
          re2();
          var t = Bt(), s2 = Hd2(), a3 = Gd2(), r = Jd2(), u = [t(da2(), (o) => ({ since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: [...o.filenames, "README"], extensions: o.extensions.filter((c) => c !== ".mdx") })), t(da2(), () => ({ name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"] }))], i2 = { mdast: s2 };
          n.exports = { languages: u, options: a3, printers: i2, parsers: r };
        } }), zd2 = Z3({ "src/language-html/clean.js"(e, n) {
          re2();
          var { isFrontMatterNode: t } = Ue2(), s2 = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]);
          function a3(r, u) {
            if (r.type === "text" || r.type === "comment" || t(r) || r.type === "yaml" || r.type === "toml")
              return null;
            r.type === "attribute" && delete u.value, r.type === "docType" && delete u.value;
          }
          a3.ignoredProperties = s2, n.exports = a3;
        } }), Xd2 = Z3({ "src/language-html/constants.evaluate.js"(e, n) {
          n.exports = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" };
        } }), Kd2 = Z3({ "src/language-html/utils/is-unknown-namespace.js"(e, n) {
          re2();
          function t(s2) {
            return s2.type === "element" && !s2.hasExplicitNamespace && !["html", "svg"].includes(s2.namespace);
          }
          n.exports = t;
        } }), qt2 = Z3({ "src/language-html/utils/index.js"(e, n) {
          re2();
          var { inferParserByLanguage: t, isFrontMatterNode: s2 } = Ue2(), { builders: { line: a3, hardline: r, join: u }, utils: { getDocParts: i2, replaceTextEndOfLine: o } } = Oe2(), { CSS_DISPLAY_TAGS: c, CSS_DISPLAY_DEFAULT: v, CSS_WHITE_SPACE_TAGS: m2, CSS_WHITE_SPACE_DEFAULT: d4 } = Xd2(), p = Kd2(), f = /* @__PURE__ */ new Set(["	", `
`, "\f", "\r", " "]), h2 = (_) => _.replace(/^[\t\n\f\r ]+/, ""), w2 = (_) => _.replace(/[\t\n\f\r ]+$/, ""), T2 = (_) => h2(w2(_)), A2 = (_) => _.replace(/^[\t\f\r ]*\n/g, ""), S2 = (_) => A2(w2(_)), B = (_) => _.split(/[\t\n\f\r ]+/), I2 = (_) => _.match(/^[\t\n\f\r ]*/)[0], k2 = (_) => {
            let [, J2, ne, Ee] = _.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
            return { leadingWhitespace: J2, trailingWhitespace: Ee, text: ne };
          }, P = (_) => /[\t\n\f\r ]/.test(_);
          function C2(_, J2) {
            return !!(_.type === "ieConditionalComment" && _.lastChild && !_.lastChild.isSelfClosing && !_.lastChild.endSourceSpan || _.type === "ieConditionalComment" && !_.complete || le2(_) && _.children.some((ne) => ne.type !== "text" && ne.type !== "interpolation") || ye2(_, J2) && !l(_) && _.type !== "interpolation");
          }
          function D2(_) {
            return _.type === "attribute" || !_.parent || !_.prev ? false : g2(_.prev);
          }
          function g2(_) {
            return _.type === "comment" && _.value.trim() === "prettier-ignore";
          }
          function F(_) {
            return _.type === "text" || _.type === "comment";
          }
          function l(_) {
            return _.type === "element" && (_.fullName === "script" || _.fullName === "style" || _.fullName === "svg:style" || p(_) && (_.name === "script" || _.name === "style"));
          }
          function E(_) {
            return _.children && !l(_);
          }
          function y(_) {
            return l(_) || _.type === "interpolation" || N(_);
          }
          function N(_) {
            return ke2(_).startsWith("pre");
          }
          function x2(_, J2) {
            let ne = Ee();
            if (ne && !_.prev && _.parent && _.parent.tagDefinition && _.parent.tagDefinition.ignoreFirstLf)
              return _.type === "interpolation";
            return ne;
            function Ee() {
              return s2(_) ? false : (_.type === "text" || _.type === "interpolation") && _.prev && (_.prev.type === "text" || _.prev.type === "interpolation") ? true : !_.parent || _.parent.cssDisplay === "none" ? false : le2(_.parent) ? true : !(!_.prev && (_.parent.type === "root" || le2(_) && _.parent || l(_.parent) || K(_.parent, J2) || !De2(_.parent.cssDisplay)) || _.prev && !z(_.prev.cssDisplay));
            }
          }
          function b2(_, J2) {
            return s2(_) ? false : (_.type === "text" || _.type === "interpolation") && _.next && (_.next.type === "text" || _.next.type === "interpolation") ? true : !_.parent || _.parent.cssDisplay === "none" ? false : le2(_.parent) ? true : !(!_.next && (_.parent.type === "root" || le2(_) && _.parent || l(_.parent) || K(_.parent, J2) || !ie(_.parent.cssDisplay)) || _.next && !G(_.next.cssDisplay));
          }
          function L(_) {
            return U(_.cssDisplay) && !l(_);
          }
          function M2(_) {
            return s2(_) || _.next && _.sourceSpan.end && _.sourceSpan.end.line + 1 < _.next.sourceSpan.start.line;
          }
          function j(_) {
            return $(_) || _.type === "element" && _.children.length > 0 && (["body", "script", "style"].includes(_.name) || _.children.some((J2) => te2(J2))) || _.firstChild && _.firstChild === _.lastChild && _.firstChild.type !== "text" && H3(_.firstChild) && (!_.lastChild.isTrailingSpaceSensitive || R(_.lastChild));
          }
          function $(_) {
            return _.type === "element" && _.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(_.name) || _.cssDisplay.startsWith("table") && _.cssDisplay !== "table-cell");
          }
          function V(_) {
            return Q(_) || _.prev && q(_.prev) || Y3(_);
          }
          function q(_) {
            return Q(_) || _.type === "element" && _.fullName === "br" || Y3(_);
          }
          function Y3(_) {
            return H3(_) && R(_);
          }
          function H3(_) {
            return _.hasLeadingSpaces && (_.prev ? _.prev.sourceSpan.end.line < _.sourceSpan.start.line : _.parent.type === "root" || _.parent.startSourceSpan.end.line < _.sourceSpan.start.line);
          }
          function R(_) {
            return _.hasTrailingSpaces && (_.next ? _.next.sourceSpan.start.line > _.sourceSpan.end.line : _.parent.type === "root" || _.parent.endSourceSpan && _.parent.endSourceSpan.start.line > _.sourceSpan.end.line);
          }
          function Q(_) {
            switch (_.type) {
              case "ieConditionalComment":
              case "comment":
              case "directive":
                return true;
              case "element":
                return ["script", "select"].includes(_.name);
            }
            return false;
          }
          function ee2(_) {
            return _.lastChild ? ee2(_.lastChild) : _;
          }
          function te2(_) {
            return _.children && _.children.some((J2) => J2.type !== "text");
          }
          function oe2(_) {
            let { type: J2, lang: ne } = _.attrMap;
            if (J2 === "module" || J2 === "text/javascript" || J2 === "text/babel" || J2 === "application/javascript" || ne === "jsx")
              return "babel";
            if (J2 === "application/x-typescript" || ne === "ts" || ne === "tsx")
              return "typescript";
            if (J2 === "text/markdown")
              return "markdown";
            if (J2 === "text/html")
              return "html";
            if (J2 && (J2.endsWith("json") || J2.endsWith("importmap")) || J2 === "speculationrules")
              return "json";
            if (J2 === "text/x-handlebars-template")
              return "glimmer";
          }
          function W2(_, J2) {
            let { lang: ne } = _.attrMap;
            if (!ne || ne === "postcss" || ne === "css")
              return "css";
            if (ne === "scss")
              return "scss";
            if (ne === "less")
              return "less";
            if (ne === "stylus")
              return t("stylus", J2);
          }
          function X3(_, J2) {
            if (_.name === "script" && !_.attrMap.src)
              return !_.attrMap.lang && !_.attrMap.type ? "babel" : oe2(_);
            if (_.name === "style")
              return W2(_, J2);
            if (J2 && ye2(_, J2))
              return oe2(_) || !("src" in _.attrMap) && t(_.attrMap.lang, J2);
          }
          function ue2(_) {
            return _ === "block" || _ === "list-item" || _.startsWith("table");
          }
          function De2(_) {
            return !ue2(_) && _ !== "inline-block";
          }
          function ie(_) {
            return !ue2(_) && _ !== "inline-block";
          }
          function G(_) {
            return !ue2(_);
          }
          function z(_) {
            return !ue2(_);
          }
          function U(_) {
            return !ue2(_) && _ !== "inline-block";
          }
          function le2(_) {
            return ke2(_).startsWith("pre");
          }
          function ge2(_, J2) {
            let ne = 0;
            for (let Ee = _.stack.length - 1; Ee >= 0; Ee--) {
              let We2 = _.stack[Ee];
              We2 && typeof We2 == "object" && !Array.isArray(We2) && J2(We2) && ne++;
            }
            return ne;
          }
          function Ae2(_, J2) {
            let ne = _;
            for (; ne; ) {
              if (J2(ne))
                return true;
              ne = ne.parent;
            }
            return false;
          }
          function Ne2(_, J2) {
            if (_.prev && _.prev.type === "comment") {
              let Ee = _.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
              if (Ee)
                return Ee[1];
            }
            let ne = false;
            if (_.type === "element" && _.namespace === "svg")
              if (Ae2(_, (Ee) => Ee.fullName === "svg:foreignObject"))
                ne = true;
              else
                return _.name === "svg" ? "inline-block" : "block";
            switch (J2.htmlWhitespaceSensitivity) {
              case "strict":
                return "inline";
              case "ignore":
                return "block";
              default:
                return J2.parser === "vue" && _.parent && _.parent.type === "root" ? "block" : _.type === "element" && (!_.namespace || ne || p(_)) && c[_.name] || v;
            }
          }
          function ke2(_) {
            return _.type === "element" && (!_.namespace || p(_)) && m2[_.name] || d4;
          }
          function ce(_) {
            let J2 = Number.POSITIVE_INFINITY;
            for (let ne of _.split(`
`)) {
              if (ne.length === 0)
                continue;
              if (!f.has(ne[0]))
                return 0;
              let Ee = I2(ne).length;
              ne.length !== Ee && Ee < J2 && (J2 = Ee);
            }
            return J2 === Number.POSITIVE_INFINITY ? 0 : J2;
          }
          function pe(_) {
            let J2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ce(_);
            return J2 === 0 ? _ : _.split(`
`).map((ne) => ne.slice(J2)).join(`
`);
          }
          function de2(_, J2) {
            let ne = 0;
            for (let Ee = 0; Ee < _.length; Ee++)
              _[Ee] === J2 && ne++;
            return ne;
          }
          function ae2(_) {
            return _.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
          }
          var ve2 = /* @__PURE__ */ new Set(["template", "style", "script"]);
          function K(_, J2) {
            return he2(_, J2) && !ve2.has(_.fullName);
          }
          function he2(_, J2) {
            return J2.parser === "vue" && _.type === "element" && _.parent.type === "root" && _.fullName.toLowerCase() !== "html";
          }
          function ye2(_, J2) {
            return he2(_, J2) && (K(_, J2) || _.attrMap.lang && _.attrMap.lang !== "html");
          }
          function Ce2(_) {
            let J2 = _.fullName;
            return J2.charAt(0) === "#" || J2 === "slot-scope" || J2 === "v-slot" || J2.startsWith("v-slot:");
          }
          function Ie2(_, J2) {
            let ne = _.parent;
            if (!he2(ne, J2))
              return false;
            let Ee = ne.fullName, We2 = _.fullName;
            return Ee === "script" && We2 === "setup" || Ee === "style" && We2 === "vars";
          }
          function Fe2(_) {
            let J2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _.value;
            return _.parent.isWhitespaceSensitive ? _.parent.isIndentationSensitive ? o(J2) : o(pe(S2(J2)), r) : i2(u(a3, B(J2)));
          }
          function me2(_, J2) {
            return he2(_, J2) && _.name === "script";
          }
          n.exports = { htmlTrim: T2, htmlTrimPreserveIndentation: S2, hasHtmlWhitespace: P, getLeadingAndTrailingHtmlWhitespace: k2, canHaveInterpolation: E, countChars: de2, countParents: ge2, dedentString: pe, forceBreakChildren: $, forceBreakContent: j, forceNextEmptyLine: M2, getLastDescendant: ee2, getNodeCssStyleDisplay: Ne2, getNodeCssStyleWhiteSpace: ke2, hasPrettierIgnore: D2, inferScriptParser: X3, isVueCustomBlock: K, isVueNonHtmlBlock: ye2, isVueScriptTag: me2, isVueSlotAttribute: Ce2, isVueSfcBindingsAttribute: Ie2, isVueSfcBlock: he2, isDanglingSpaceSensitiveNode: L, isIndentationSensitiveNode: N, isLeadingSpaceSensitiveNode: x2, isPreLikeNode: le2, isScriptLikeTag: l, isTextLikeNode: F, isTrailingSpaceSensitiveNode: b2, isWhitespaceSensitiveNode: y, isUnknownNamespace: p, preferHardlineAsLeadingSpaces: V, preferHardlineAsTrailingSpaces: q, shouldPreserveContent: C2, unescapeQuoteEntities: ae2, getTextValueParts: Fe2 };
        } }), Yd2 = Z3({ "node_modules/angular-html-parser/lib/compiler/src/chars.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true }), e.$EOF = 0, e.$BSPACE = 8, e.$TAB = 9, e.$LF = 10, e.$VTAB = 11, e.$FF = 12, e.$CR = 13, e.$SPACE = 32, e.$BANG = 33, e.$DQ = 34, e.$HASH = 35, e.$$ = 36, e.$PERCENT = 37, e.$AMPERSAND = 38, e.$SQ = 39, e.$LPAREN = 40, e.$RPAREN = 41, e.$STAR = 42, e.$PLUS = 43, e.$COMMA = 44, e.$MINUS = 45, e.$PERIOD = 46, e.$SLASH = 47, e.$COLON = 58, e.$SEMICOLON = 59, e.$LT = 60, e.$EQ = 61, e.$GT = 62, e.$QUESTION = 63, e.$0 = 48, e.$7 = 55, e.$9 = 57, e.$A = 65, e.$E = 69, e.$F = 70, e.$X = 88, e.$Z = 90, e.$LBRACKET = 91, e.$BACKSLASH = 92, e.$RBRACKET = 93, e.$CARET = 94, e.$_ = 95, e.$a = 97, e.$b = 98, e.$e = 101, e.$f = 102, e.$n = 110, e.$r = 114, e.$t = 116, e.$u = 117, e.$v = 118, e.$x = 120, e.$z = 122, e.$LBRACE = 123, e.$BAR = 124, e.$RBRACE = 125, e.$NBSP = 160, e.$PIPE = 124, e.$TILDA = 126, e.$AT = 64, e.$BT = 96;
          function n(i2) {
            return i2 >= e.$TAB && i2 <= e.$SPACE || i2 == e.$NBSP;
          }
          e.isWhitespace = n;
          function t(i2) {
            return e.$0 <= i2 && i2 <= e.$9;
          }
          e.isDigit = t;
          function s2(i2) {
            return i2 >= e.$a && i2 <= e.$z || i2 >= e.$A && i2 <= e.$Z;
          }
          e.isAsciiLetter = s2;
          function a3(i2) {
            return i2 >= e.$a && i2 <= e.$f || i2 >= e.$A && i2 <= e.$F || t(i2);
          }
          e.isAsciiHexDigit = a3;
          function r(i2) {
            return i2 === e.$LF || i2 === e.$CR;
          }
          e.isNewLine = r;
          function u(i2) {
            return e.$0 <= i2 && i2 <= e.$7;
          }
          e.isOctalDigit = u;
        } }), Qd2 = Z3({ "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true });
          var n = class {
            constructor(s2, a3, r) {
              this.filePath = s2, this.name = a3, this.members = r;
            }
            assertNoMembers() {
              if (this.members.length)
                throw new Error("Illegal state: symbol without members expected, but got ".concat(JSON.stringify(this), "."));
            }
          };
          e.StaticSymbol = n;
          var t = class {
            constructor() {
              this.cache = /* @__PURE__ */ new Map();
            }
            get(s2, a3, r) {
              r = r || [];
              let u = r.length ? ".".concat(r.join(".")) : "", i2 = '"'.concat(s2, '".').concat(a3).concat(u), o = this.cache.get(i2);
              return o || (o = new n(s2, a3, r), this.cache.set(i2, o)), o;
            }
          };
          e.StaticSymbolCache = t;
        } }), Zd2 = Z3({ "node_modules/angular-html-parser/lib/compiler/src/util.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true });
          var n = /-+([a-z0-9])/g;
          function t(l) {
            return l.replace(n, function() {
              for (var E = arguments.length, y = new Array(E), N = 0; N < E; N++)
                y[N] = arguments[N];
              return y[1].toUpperCase();
            });
          }
          e.dashCaseToCamelCase = t;
          function s2(l, E) {
            return r(l, ":", E);
          }
          e.splitAtColon = s2;
          function a3(l, E) {
            return r(l, ".", E);
          }
          e.splitAtPeriod = a3;
          function r(l, E, y) {
            let N = l.indexOf(E);
            return N == -1 ? y : [l.slice(0, N).trim(), l.slice(N + 1).trim()];
          }
          function u(l, E, y) {
            return Array.isArray(l) ? E.visitArray(l, y) : A2(l) ? E.visitStringMap(l, y) : l == null || typeof l == "string" || typeof l == "number" || typeof l == "boolean" ? E.visitPrimitive(l, y) : E.visitOther(l, y);
          }
          e.visitValue = u;
          function i2(l) {
            return l != null;
          }
          e.isDefined = i2;
          function o(l) {
            return l === void 0 ? null : l;
          }
          e.noUndefined = o;
          var c = class {
            visitArray(l, E) {
              return l.map((y) => u(y, this, E));
            }
            visitStringMap(l, E) {
              let y = {};
              return Object.keys(l).forEach((N) => {
                y[N] = u(l[N], this, E);
              }), y;
            }
            visitPrimitive(l, E) {
              return l;
            }
            visitOther(l, E) {
              return l;
            }
          };
          e.ValueTransformer = c, e.SyncAsync = { assertSync: (l) => {
            if (k2(l))
              throw new Error("Illegal state: value cannot be a promise");
            return l;
          }, then: (l, E) => k2(l) ? l.then(E) : E(l), all: (l) => l.some(k2) ? Promise.all(l) : l };
          function v(l) {
            throw new Error("Internal Error: ".concat(l));
          }
          e.error = v;
          function m2(l, E) {
            let y = Error(l);
            return y[d4] = true, E && (y[p] = E), y;
          }
          e.syntaxError = m2;
          var d4 = "ngSyntaxError", p = "ngParseErrors";
          function f(l) {
            return l[d4];
          }
          e.isSyntaxError = f;
          function h2(l) {
            return l[p] || [];
          }
          e.getParseErrors = h2;
          function w2(l) {
            return l.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
          }
          e.escapeRegExp = w2;
          var T2 = Object.getPrototypeOf({});
          function A2(l) {
            return typeof l == "object" && l !== null && Object.getPrototypeOf(l) === T2;
          }
          function S2(l) {
            let E = "";
            for (let y = 0; y < l.length; y++) {
              let N = l.charCodeAt(y);
              if (N >= 55296 && N <= 56319 && l.length > y + 1) {
                let x2 = l.charCodeAt(y + 1);
                x2 >= 56320 && x2 <= 57343 && (y++, N = (N - 55296 << 10) + x2 - 56320 + 65536);
              }
              N <= 127 ? E += String.fromCharCode(N) : N <= 2047 ? E += String.fromCharCode(N >> 6 & 31 | 192, N & 63 | 128) : N <= 65535 ? E += String.fromCharCode(N >> 12 | 224, N >> 6 & 63 | 128, N & 63 | 128) : N <= 2097151 && (E += String.fromCharCode(N >> 18 & 7 | 240, N >> 12 & 63 | 128, N >> 6 & 63 | 128, N & 63 | 128));
            }
            return E;
          }
          e.utf8Encode = S2;
          function B(l) {
            if (typeof l == "string")
              return l;
            if (l instanceof Array)
              return "[" + l.map(B).join(", ") + "]";
            if (l == null)
              return "" + l;
            if (l.overriddenName)
              return "".concat(l.overriddenName);
            if (l.name)
              return "".concat(l.name);
            if (!l.toString)
              return "object";
            let E = l.toString();
            if (E == null)
              return "" + E;
            let y = E.indexOf(`
`);
            return y === -1 ? E : E.substring(0, y);
          }
          e.stringify = B;
          function I2(l) {
            return typeof l == "function" && l.hasOwnProperty("__forward_ref__") ? l() : l;
          }
          e.resolveForwardRef = I2;
          function k2(l) {
            return !!l && typeof l.then == "function";
          }
          e.isPromise = k2;
          var P = class {
            constructor(l) {
              this.full = l;
              let E = l.split(".");
              this.major = E[0], this.minor = E[1], this.patch = E.slice(2).join(".");
            }
          };
          e.Version = P;
          var C2 = typeof window < "u" && window, D2 = typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self, g2 = typeof globalThis < "u" && globalThis, F = g2 || C2 || D2;
          e.global = F;
        } }), eg2 = Z3({ "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true });
          var n = Qd2(), t = Zd2(), s2 = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
          function a3(y) {
            return y.replace(/\W/g, "_");
          }
          e.sanitizeIdentifier = a3;
          var r = 0;
          function u(y) {
            if (!y || !y.reference)
              return null;
            let N = y.reference;
            if (N instanceof n.StaticSymbol)
              return N.name;
            if (N.__anonymousType)
              return N.__anonymousType;
            let x2 = t.stringify(N);
            return x2.indexOf("(") >= 0 ? (x2 = "anonymous_".concat(r++), N.__anonymousType = x2) : x2 = a3(x2), x2;
          }
          e.identifierName = u;
          function i2(y) {
            let N = y.reference;
            return N instanceof n.StaticSymbol ? N.filePath : "./".concat(t.stringify(N));
          }
          e.identifierModuleUrl = i2;
          function o(y, N) {
            return "View_".concat(u({ reference: y }), "_").concat(N);
          }
          e.viewClassName = o;
          function c(y) {
            return "RenderType_".concat(u({ reference: y }));
          }
          e.rendererTypeName = c;
          function v(y) {
            return "HostView_".concat(u({ reference: y }));
          }
          e.hostViewClassName = v;
          function m2(y) {
            return "".concat(u({ reference: y }), "NgFactory");
          }
          e.componentFactoryName = m2;
          var d4;
          (function(y) {
            y[y.Pipe = 0] = "Pipe", y[y.Directive = 1] = "Directive", y[y.NgModule = 2] = "NgModule", y[y.Injectable = 3] = "Injectable";
          })(d4 = e.CompileSummaryKind || (e.CompileSummaryKind = {}));
          function p(y) {
            return y.value != null ? a3(y.value) : u(y.identifier);
          }
          e.tokenName = p;
          function f(y) {
            return y.identifier != null ? y.identifier.reference : y.value;
          }
          e.tokenReference = f;
          var h2 = class {
            constructor() {
              let { moduleUrl: y, styles: N, styleUrls: x2 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              this.moduleUrl = y || null, this.styles = k2(N), this.styleUrls = k2(x2);
            }
          };
          e.CompileStylesheetMetadata = h2;
          var w2 = class {
            constructor(y) {
              let { encapsulation: N, template: x2, templateUrl: b2, htmlAst: L, styles: M2, styleUrls: j, externalStylesheets: $, animations: V, ngContentSelectors: q, interpolation: Y3, isInline: H3, preserveWhitespaces: R } = y;
              if (this.encapsulation = N, this.template = x2, this.templateUrl = b2, this.htmlAst = L, this.styles = k2(M2), this.styleUrls = k2(j), this.externalStylesheets = k2($), this.animations = V ? C2(V) : [], this.ngContentSelectors = q || [], Y3 && Y3.length != 2)
                throw new Error("'interpolation' should have a start and an end symbol.");
              this.interpolation = Y3, this.isInline = H3, this.preserveWhitespaces = R;
            }
            toSummary() {
              return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
            }
          };
          e.CompileTemplateMetadata = w2;
          var T2 = class {
            static create(y) {
              let { isHost: N, type: x2, isComponent: b2, selector: L, exportAs: M2, changeDetection: j, inputs: $, outputs: V, host: q, providers: Y3, viewProviders: H3, queries: R, guards: Q, viewQueries: ee2, entryComponents: te2, template: oe2, componentViewType: W2, rendererType: X3, componentFactory: ue2 } = y, De2 = {}, ie = {}, G = {};
              q != null && Object.keys(q).forEach((le2) => {
                let ge2 = q[le2], Ae2 = le2.match(s2);
                Ae2 === null ? G[le2] = ge2 : Ae2[1] != null ? ie[Ae2[1]] = ge2 : Ae2[2] != null && (De2[Ae2[2]] = ge2);
              });
              let z = {};
              $ != null && $.forEach((le2) => {
                let ge2 = t.splitAtColon(le2, [le2, le2]);
                z[ge2[0]] = ge2[1];
              });
              let U = {};
              return V != null && V.forEach((le2) => {
                let ge2 = t.splitAtColon(le2, [le2, le2]);
                U[ge2[0]] = ge2[1];
              }), new T2({ isHost: N, type: x2, isComponent: !!b2, selector: L, exportAs: M2, changeDetection: j, inputs: z, outputs: U, hostListeners: De2, hostProperties: ie, hostAttributes: G, providers: Y3, viewProviders: H3, queries: R, guards: Q, viewQueries: ee2, entryComponents: te2, template: oe2, componentViewType: W2, rendererType: X3, componentFactory: ue2 });
            }
            constructor(y) {
              let { isHost: N, type: x2, isComponent: b2, selector: L, exportAs: M2, changeDetection: j, inputs: $, outputs: V, hostListeners: q, hostProperties: Y3, hostAttributes: H3, providers: R, viewProviders: Q, queries: ee2, guards: te2, viewQueries: oe2, entryComponents: W2, template: X3, componentViewType: ue2, rendererType: De2, componentFactory: ie } = y;
              this.isHost = !!N, this.type = x2, this.isComponent = b2, this.selector = L, this.exportAs = M2, this.changeDetection = j, this.inputs = $, this.outputs = V, this.hostListeners = q, this.hostProperties = Y3, this.hostAttributes = H3, this.providers = k2(R), this.viewProviders = k2(Q), this.queries = k2(ee2), this.guards = te2, this.viewQueries = k2(oe2), this.entryComponents = k2(W2), this.template = X3, this.componentViewType = ue2, this.rendererType = De2, this.componentFactory = ie;
            }
            toSummary() {
              return { summaryKind: d4.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
            }
          };
          e.CompileDirectiveMetadata = T2;
          var A2 = class {
            constructor(y) {
              let { type: N, name: x2, pure: b2 } = y;
              this.type = N, this.name = x2, this.pure = !!b2;
            }
            toSummary() {
              return { summaryKind: d4.Pipe, type: this.type, name: this.name, pure: this.pure };
            }
          };
          e.CompilePipeMetadata = A2;
          var S2 = class {
          };
          e.CompileShallowModuleMetadata = S2;
          var B = class {
            constructor(y) {
              let { type: N, providers: x2, declaredDirectives: b2, exportedDirectives: L, declaredPipes: M2, exportedPipes: j, entryComponents: $, bootstrapComponents: V, importedModules: q, exportedModules: Y3, schemas: H3, transitiveModule: R, id: Q } = y;
              this.type = N || null, this.declaredDirectives = k2(b2), this.exportedDirectives = k2(L), this.declaredPipes = k2(M2), this.exportedPipes = k2(j), this.providers = k2(x2), this.entryComponents = k2($), this.bootstrapComponents = k2(V), this.importedModules = k2(q), this.exportedModules = k2(Y3), this.schemas = k2(H3), this.id = Q || null, this.transitiveModule = R || null;
            }
            toSummary() {
              let y = this.transitiveModule;
              return { summaryKind: d4.NgModule, type: this.type, entryComponents: y.entryComponents, providers: y.providers, modules: y.modules, exportedDirectives: y.exportedDirectives, exportedPipes: y.exportedPipes };
            }
          };
          e.CompileNgModuleMetadata = B;
          var I2 = class {
            constructor() {
              this.directivesSet = /* @__PURE__ */ new Set(), this.directives = [], this.exportedDirectivesSet = /* @__PURE__ */ new Set(), this.exportedDirectives = [], this.pipesSet = /* @__PURE__ */ new Set(), this.pipes = [], this.exportedPipesSet = /* @__PURE__ */ new Set(), this.exportedPipes = [], this.modulesSet = /* @__PURE__ */ new Set(), this.modules = [], this.entryComponentsSet = /* @__PURE__ */ new Set(), this.entryComponents = [], this.providers = [];
            }
            addProvider(y, N) {
              this.providers.push({ provider: y, module: N });
            }
            addDirective(y) {
              this.directivesSet.has(y.reference) || (this.directivesSet.add(y.reference), this.directives.push(y));
            }
            addExportedDirective(y) {
              this.exportedDirectivesSet.has(y.reference) || (this.exportedDirectivesSet.add(y.reference), this.exportedDirectives.push(y));
            }
            addPipe(y) {
              this.pipesSet.has(y.reference) || (this.pipesSet.add(y.reference), this.pipes.push(y));
            }
            addExportedPipe(y) {
              this.exportedPipesSet.has(y.reference) || (this.exportedPipesSet.add(y.reference), this.exportedPipes.push(y));
            }
            addModule(y) {
              this.modulesSet.has(y.reference) || (this.modulesSet.add(y.reference), this.modules.push(y));
            }
            addEntryComponent(y) {
              this.entryComponentsSet.has(y.componentType) || (this.entryComponentsSet.add(y.componentType), this.entryComponents.push(y));
            }
          };
          e.TransitiveCompileNgModuleMetadata = I2;
          function k2(y) {
            return y || [];
          }
          var P = class {
            constructor(y, N) {
              let { useClass: x2, useValue: b2, useExisting: L, useFactory: M2, deps: j, multi: $ } = N;
              this.token = y, this.useClass = x2 || null, this.useValue = b2, this.useExisting = L, this.useFactory = M2 || null, this.dependencies = j || null, this.multi = !!$;
            }
          };
          e.ProviderMeta = P;
          function C2(y) {
            return y.reduce((N, x2) => {
              let b2 = Array.isArray(x2) ? C2(x2) : x2;
              return N.concat(b2);
            }, []);
          }
          e.flatten = C2;
          function D2(y) {
            return y.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
          }
          function g2(y, N, x2) {
            let b2;
            return x2.isInline ? N.type.reference instanceof n.StaticSymbol ? b2 = "".concat(N.type.reference.filePath, ".").concat(N.type.reference.name, ".html") : b2 = "".concat(u(y), "/").concat(u(N.type), ".html") : b2 = x2.templateUrl, N.type.reference instanceof n.StaticSymbol ? b2 : D2(b2);
          }
          e.templateSourceUrl = g2;
          function F(y, N) {
            let x2 = y.moduleUrl.split(/\/\\/g), b2 = x2[x2.length - 1];
            return D2("css/".concat(N).concat(b2, ".ngstyle.js"));
          }
          e.sharedStylesheetJitUrl = F;
          function l(y) {
            return D2("".concat(u(y.type), "/module.ngfactory.js"));
          }
          e.ngModuleJitUrl = l;
          function E(y, N) {
            return D2("".concat(u(y), "/").concat(u(N.type), ".ngfactory.js"));
          }
          e.templateJitUrl = E;
        } }), tg2 = Z3({ "node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(e) {
          re2(), Object.defineProperty(e, "__esModule", { value: true });
          var n = Yd2(), t = eg2(), s2 = class {
            constructor(v, m2, d4, p) {
              this.file = v, this.offset = m2, this.line = d4, this.col = p;
            }
            toString() {
              return this.offset != null ? "".concat(this.file.url, "@").concat(this.line, ":").concat(this.col) : this.file.url;
            }
            moveBy(v) {
              let m2 = this.file.content, d4 = m2.length, p = this.offset, f = this.line, h2 = this.col;
              for (; p > 0 && v < 0; )
                if (p--, v++, m2.charCodeAt(p) == n.$LF) {
                  f--;
                  let T2 = m2.substr(0, p - 1).lastIndexOf(String.fromCharCode(n.$LF));
                  h2 = T2 > 0 ? p - T2 : p;
                } else
                  h2--;
              for (; p < d4 && v > 0; ) {
                let w2 = m2.charCodeAt(p);
                p++, v--, w2 == n.$LF ? (f++, h2 = 0) : h2++;
              }
              return new s2(this.file, p, f, h2);
            }
            getContext(v, m2) {
              let d4 = this.file.content, p = this.offset;
              if (p != null) {
                p > d4.length - 1 && (p = d4.length - 1);
                let f = p, h2 = 0, w2 = 0;
                for (; h2 < v && p > 0 && (p--, h2++, !(d4[p] == `
` && ++w2 == m2)); )
                  ;
                for (h2 = 0, w2 = 0; h2 < v && f < d4.length - 1 && (f++, h2++, !(d4[f] == `
` && ++w2 == m2)); )
                  ;
                return { before: d4.substring(p, this.offset), after: d4.substring(this.offset, f + 1) };
              }
              return null;
            }
          };
          e.ParseLocation = s2;
          var a3 = class {
            constructor(v, m2) {
              this.content = v, this.url = m2;
            }
          };
          e.ParseSourceFile = a3;
          var r = class {
            constructor(v, m2) {
              let d4 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
              this.start = v, this.end = m2, this.details = d4;
            }
            toString() {
              return this.start.file.content.substring(this.start.offset, this.end.offset);
            }
          };
          e.ParseSourceSpan = r, e.EMPTY_PARSE_LOCATION = new s2(new a3("", ""), 0, 0, 0), e.EMPTY_SOURCE_SPAN = new r(e.EMPTY_PARSE_LOCATION, e.EMPTY_PARSE_LOCATION);
          var u;
          (function(v) {
            v[v.WARNING = 0] = "WARNING", v[v.ERROR = 1] = "ERROR";
          })(u = e.ParseErrorLevel || (e.ParseErrorLevel = {}));
          var i2 = class {
            constructor(v, m2) {
              let d4 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : u.ERROR;
              this.span = v, this.msg = m2, this.level = d4;
            }
            contextualMessage() {
              let v = this.span.start.getContext(100, 3);
              return v ? "".concat(this.msg, ' ("').concat(v.before, "[").concat(u[this.level], " ->]").concat(v.after, '")') : this.msg;
            }
            toString() {
              let v = this.span.details ? ", ".concat(this.span.details) : "";
              return "".concat(this.contextualMessage(), ": ").concat(this.span.start).concat(v);
            }
          };
          e.ParseError = i2;
          function o(v, m2) {
            let d4 = t.identifierModuleUrl(m2), p = d4 != null ? "in ".concat(v, " ").concat(t.identifierName(m2), " in ").concat(d4) : "in ".concat(v, " ").concat(t.identifierName(m2)), f = new a3("", p);
            return new r(new s2(f, -1, -1, -1), new s2(f, -1, -1, -1));
          }
          e.typeSourceSpan = o;
          function c(v, m2, d4) {
            let p = "in ".concat(v, " ").concat(m2, " in ").concat(d4), f = new a3("", p);
            return new r(new s2(f, -1, -1, -1), new s2(f, -1, -1, -1));
          }
          e.r3JitTypeSourceSpan = c;
        } }), rg2 = Z3({ "src/language-html/print-preprocess.js"(e, n) {
          re2();
          var { ParseSourceSpan: t } = tg2(), { htmlTrim: s2, getLeadingAndTrailingHtmlWhitespace: a3, hasHtmlWhitespace: r, canHaveInterpolation: u, getNodeCssStyleDisplay: i2, isDanglingSpaceSensitiveNode: o, isIndentationSensitiveNode: c, isLeadingSpaceSensitiveNode: v, isTrailingSpaceSensitiveNode: m2, isWhitespaceSensitiveNode: d4, isVueScriptTag: p } = qt2(), f = [w2, T2, S2, I2, k2, D2, P, C2, g2, B, F];
          function h2(l, E) {
            for (let y of f)
              y(l, E);
            return l;
          }
          function w2(l) {
            l.walk((E) => {
              if (E.type === "element" && E.tagDefinition.ignoreFirstLf && E.children.length > 0 && E.children[0].type === "text" && E.children[0].value[0] === `
`) {
                let y = E.children[0];
                y.value.length === 1 ? E.removeChild(y) : y.value = y.value.slice(1);
              }
            });
          }
          function T2(l) {
            let E = (y) => y.type === "element" && y.prev && y.prev.type === "ieConditionalStartComment" && y.prev.sourceSpan.end.offset === y.startSourceSpan.start.offset && y.firstChild && y.firstChild.type === "ieConditionalEndComment" && y.firstChild.sourceSpan.start.offset === y.startSourceSpan.end.offset;
            l.walk((y) => {
              if (y.children)
                for (let N = 0; N < y.children.length; N++) {
                  let x2 = y.children[N];
                  if (!E(x2))
                    continue;
                  let b2 = x2.prev, L = x2.firstChild;
                  y.removeChild(b2), N--;
                  let M2 = new t(b2.sourceSpan.start, L.sourceSpan.end), j = new t(M2.start, x2.sourceSpan.end);
                  x2.condition = b2.condition, x2.sourceSpan = j, x2.startSourceSpan = M2, x2.removeChild(L);
                }
            });
          }
          function A2(l, E, y) {
            l.walk((N) => {
              if (N.children)
                for (let x2 = 0; x2 < N.children.length; x2++) {
                  let b2 = N.children[x2];
                  if (b2.type !== "text" && !E(b2))
                    continue;
                  b2.type !== "text" && (b2.type = "text", b2.value = y(b2));
                  let L = b2.prev;
                  !L || L.type !== "text" || (L.value += b2.value, L.sourceSpan = new t(L.sourceSpan.start, b2.sourceSpan.end), N.removeChild(b2), x2--);
                }
            });
          }
          function S2(l) {
            return A2(l, (E) => E.type === "cdata", (E) => "<![CDATA[".concat(E.value, "]]>"));
          }
          function B(l) {
            let E = (y) => y.type === "element" && y.attrs.length === 0 && y.children.length === 1 && y.firstChild.type === "text" && !r(y.children[0].value) && !y.firstChild.hasLeadingSpaces && !y.firstChild.hasTrailingSpaces && y.isLeadingSpaceSensitive && !y.hasLeadingSpaces && y.isTrailingSpaceSensitive && !y.hasTrailingSpaces && y.prev && y.prev.type === "text" && y.next && y.next.type === "text";
            l.walk((y) => {
              if (y.children)
                for (let N = 0; N < y.children.length; N++) {
                  let x2 = y.children[N];
                  if (!E(x2))
                    continue;
                  let b2 = x2.prev, L = x2.next;
                  b2.value += "<".concat(x2.rawName, ">") + x2.firstChild.value + "</".concat(x2.rawName, ">") + L.value, b2.sourceSpan = new t(b2.sourceSpan.start, L.sourceSpan.end), b2.isTrailingSpaceSensitive = L.isTrailingSpaceSensitive, b2.hasTrailingSpaces = L.hasTrailingSpaces, y.removeChild(x2), N--, y.removeChild(L);
                }
            });
          }
          function I2(l, E) {
            if (E.parser === "html")
              return;
            let y = /{{(.+?)}}/s;
            l.walk((N) => {
              if (!!u(N))
                for (let x2 of N.children) {
                  if (x2.type !== "text")
                    continue;
                  let b2 = x2.sourceSpan.start, L = null, M2 = x2.value.split(y);
                  for (let j = 0; j < M2.length; j++, b2 = L) {
                    let $ = M2[j];
                    if (j % 2 === 0) {
                      L = b2.moveBy($.length), $.length > 0 && N.insertChildBefore(x2, { type: "text", value: $, sourceSpan: new t(b2, L) });
                      continue;
                    }
                    L = b2.moveBy($.length + 4), N.insertChildBefore(x2, { type: "interpolation", sourceSpan: new t(b2, L), children: $.length === 0 ? [] : [{ type: "text", value: $, sourceSpan: new t(b2.moveBy(2), L.moveBy(-2)) }] });
                  }
                  N.removeChild(x2);
                }
            });
          }
          function k2(l) {
            l.walk((E) => {
              if (!E.children)
                return;
              if (E.children.length === 0 || E.children.length === 1 && E.children[0].type === "text" && s2(E.children[0].value).length === 0) {
                E.hasDanglingSpaces = E.children.length > 0, E.children = [];
                return;
              }
              let y = d4(E), N = c(E);
              if (!y)
                for (let x2 = 0; x2 < E.children.length; x2++) {
                  let b2 = E.children[x2];
                  if (b2.type !== "text")
                    continue;
                  let { leadingWhitespace: L, text: M2, trailingWhitespace: j } = a3(b2.value), $ = b2.prev, V = b2.next;
                  M2 ? (b2.value = M2, b2.sourceSpan = new t(b2.sourceSpan.start.moveBy(L.length), b2.sourceSpan.end.moveBy(-j.length)), L && ($ && ($.hasTrailingSpaces = true), b2.hasLeadingSpaces = true), j && (b2.hasTrailingSpaces = true, V && (V.hasLeadingSpaces = true))) : (E.removeChild(b2), x2--, (L || j) && ($ && ($.hasTrailingSpaces = true), V && (V.hasLeadingSpaces = true)));
                }
              E.isWhitespaceSensitive = y, E.isIndentationSensitive = N;
            });
          }
          function P(l) {
            l.walk((E) => {
              E.isSelfClosing = !E.children || E.type === "element" && (E.tagDefinition.isVoid || E.startSourceSpan === E.endSourceSpan);
            });
          }
          function C2(l, E) {
            l.walk((y) => {
              y.type === "element" && (y.hasHtmComponentClosingTag = y.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(E.originalText.slice(y.endSourceSpan.start.offset, y.endSourceSpan.end.offset)));
            });
          }
          function D2(l, E) {
            l.walk((y) => {
              y.cssDisplay = i2(y, E);
            });
          }
          function g2(l, E) {
            l.walk((y) => {
              let { children: N } = y;
              if (!!N) {
                if (N.length === 0) {
                  y.isDanglingSpaceSensitive = o(y);
                  return;
                }
                for (let x2 of N)
                  x2.isLeadingSpaceSensitive = v(x2, E), x2.isTrailingSpaceSensitive = m2(x2, E);
                for (let x2 = 0; x2 < N.length; x2++) {
                  let b2 = N[x2];
                  b2.isLeadingSpaceSensitive = (x2 === 0 || b2.prev.isTrailingSpaceSensitive) && b2.isLeadingSpaceSensitive, b2.isTrailingSpaceSensitive = (x2 === N.length - 1 || b2.next.isLeadingSpaceSensitive) && b2.isTrailingSpaceSensitive;
                }
              }
            });
          }
          function F(l, E) {
            if (E.parser === "vue") {
              let y = l.children.find((x2) => p(x2, E));
              if (!y)
                return;
              let { lang: N } = y.attrMap;
              (N === "ts" || N === "typescript") && (E.__should_parse_vue_template_with_ts = true);
            }
          }
          n.exports = h2;
        } }), ng2 = Z3({ "src/language-html/pragma.js"(e, n) {
          re2();
          function t(a3) {
            return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(a3);
          }
          function s2(a3) {
            return `<!-- @format -->

` + a3.replace(/^\s*\n/, "");
          }
          n.exports = { hasPragma: t, insertPragma: s2 };
        } }), Yn2 = Z3({ "src/language-html/loc.js"(e, n) {
          re2();
          function t(a3) {
            return a3.sourceSpan.start.offset;
          }
          function s2(a3) {
            return a3.sourceSpan.end.offset;
          }
          n.exports = { locStart: t, locEnd: s2 };
        } }), er2 = Z3({ "src/language-html/print/tag.js"(e, n) {
          re2();
          var t = Xt2(), { isNonEmptyArray: s2 } = Ue2(), { builders: { indent: a3, join: r, line: u, softline: i2, hardline: o }, utils: { replaceTextEndOfLine: c } } = Oe2(), { locStart: v, locEnd: m2 } = Yn2(), { isTextLikeNode: d4, getLastDescendant: p, isPreLikeNode: f, hasPrettierIgnore: h2, shouldPreserveContent: w2, isVueSfcBlock: T2 } = qt2();
          function A2(q, Y3) {
            return [q.isSelfClosing ? "" : S2(q, Y3), B(q, Y3)];
          }
          function S2(q, Y3) {
            return q.lastChild && l(q.lastChild) ? "" : [I2(q, Y3), P(q, Y3)];
          }
          function B(q, Y3) {
            return (q.next ? g2(q.next) : F(q.parent)) ? "" : [C2(q, Y3), k2(q, Y3)];
          }
          function I2(q, Y3) {
            return F(q) ? C2(q.lastChild, Y3) : "";
          }
          function k2(q, Y3) {
            return l(q) ? P(q.parent, Y3) : E(q) ? $(q.next) : "";
          }
          function P(q, Y3) {
            if (t(!q.isSelfClosing), D2(q, Y3))
              return "";
            switch (q.type) {
              case "ieConditionalComment":
                return "<!";
              case "element":
                if (q.hasHtmComponentClosingTag)
                  return "<//";
              default:
                return "</".concat(q.rawName);
            }
          }
          function C2(q, Y3) {
            if (D2(q, Y3))
              return "";
            switch (q.type) {
              case "ieConditionalComment":
              case "ieConditionalEndComment":
                return "[endif]-->";
              case "ieConditionalStartComment":
                return "]><!-->";
              case "interpolation":
                return "}}";
              case "element":
                if (q.isSelfClosing)
                  return "/>";
              default:
                return ">";
            }
          }
          function D2(q, Y3) {
            return !q.isSelfClosing && !q.endSourceSpan && (h2(q) || w2(q.parent, Y3));
          }
          function g2(q) {
            return q.prev && q.prev.type !== "docType" && !d4(q.prev) && q.isLeadingSpaceSensitive && !q.hasLeadingSpaces;
          }
          function F(q) {
            return q.lastChild && q.lastChild.isTrailingSpaceSensitive && !q.lastChild.hasTrailingSpaces && !d4(p(q.lastChild)) && !f(q);
          }
          function l(q) {
            return !q.next && !q.hasTrailingSpaces && q.isTrailingSpaceSensitive && d4(p(q));
          }
          function E(q) {
            return q.next && !d4(q.next) && d4(q) && q.isTrailingSpaceSensitive && !q.hasTrailingSpaces;
          }
          function y(q) {
            let Y3 = q.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
            return Y3 ? Y3[1] ? Y3[1].split(/\s+/) : true : false;
          }
          function N(q) {
            return !q.prev && q.isLeadingSpaceSensitive && !q.hasLeadingSpaces;
          }
          function x2(q, Y3, H3) {
            let R = q.getValue();
            if (!s2(R.attrs))
              return R.isSelfClosing ? " " : "";
            let Q = R.prev && R.prev.type === "comment" && y(R.prev.value), ee2 = typeof Q == "boolean" ? () => Q : Array.isArray(Q) ? (De2) => Q.includes(De2.rawName) : () => false, te2 = q.map((De2) => {
              let ie = De2.getValue();
              return ee2(ie) ? c(Y3.originalText.slice(v(ie), m2(ie))) : H3();
            }, "attrs"), oe2 = R.type === "element" && R.fullName === "script" && R.attrs.length === 1 && R.attrs[0].fullName === "src" && R.children.length === 0, X3 = Y3.singleAttributePerLine && R.attrs.length > 1 && !T2(R, Y3) ? o : u, ue2 = [a3([oe2 ? " " : u, r(X3, te2)])];
            return R.firstChild && N(R.firstChild) || R.isSelfClosing && F(R.parent) || oe2 ? ue2.push(R.isSelfClosing ? " " : "") : ue2.push(Y3.bracketSameLine ? R.isSelfClosing ? " " : "" : R.isSelfClosing ? u : i2), ue2;
          }
          function b2(q) {
            return q.firstChild && N(q.firstChild) ? "" : V(q);
          }
          function L(q, Y3, H3) {
            let R = q.getValue();
            return [M2(R, Y3), x2(q, Y3, H3), R.isSelfClosing ? "" : b2(R)];
          }
          function M2(q, Y3) {
            return q.prev && E(q.prev) ? "" : [j(q, Y3), $(q)];
          }
          function j(q, Y3) {
            return N(q) ? V(q.parent) : g2(q) ? C2(q.prev, Y3) : "";
          }
          function $(q) {
            switch (q.type) {
              case "ieConditionalComment":
              case "ieConditionalStartComment":
                return "<!--[if ".concat(q.condition);
              case "ieConditionalEndComment":
                return "<!--<!";
              case "interpolation":
                return "{{";
              case "docType":
                return "<!DOCTYPE";
              case "element":
                if (q.condition)
                  return "<!--[if ".concat(q.condition, "]><!--><").concat(q.rawName);
              default:
                return "<".concat(q.rawName);
            }
          }
          function V(q) {
            switch (t(!q.isSelfClosing), q.type) {
              case "ieConditionalComment":
                return "]>";
              case "element":
                if (q.condition)
                  return "><!--<![endif]-->";
              default:
                return ">";
            }
          }
          n.exports = { printClosingTag: A2, printClosingTagStart: S2, printClosingTagStartMarker: P, printClosingTagEndMarker: C2, printClosingTagSuffix: k2, printClosingTagEnd: B, needsToBorrowLastChildClosingTagEndMarker: F, needsToBorrowParentClosingTagStartMarker: l, needsToBorrowPrevClosingTagEndMarker: g2, printOpeningTag: L, printOpeningTagStart: M2, printOpeningTagPrefix: j, printOpeningTagStartMarker: $, printOpeningTagEndMarker: V, needsToBorrowNextOpeningTagStartMarker: E, needsToBorrowParentOpeningTagEndMarker: N };
        } }), ug2 = Z3({ "node_modules/parse-srcset/src/parse-srcset.js"(e, n) {
          re2(), function(t, s2) {
            typeof n == "object" && n.exports ? n.exports = s2() : t.parseSrcset = s2();
          }(e, function() {
            return function(t, s2) {
              var a3 = s2 && s2.logger || console;
              function r(P) {
                return P === " " || P === "	" || P === `
` || P === "\f" || P === "\r";
              }
              function u(P) {
                var C2, D2 = P.exec(t.substring(S2));
                if (D2)
                  return C2 = D2[0], S2 += C2.length, C2;
              }
              for (var i2 = t.length, o = /^[ \t\n\r\u000c]+/, c = /^[, \t\n\r\u000c]+/, v = /^[^ \t\n\r\u000c]+/, m2 = /[,]+$/, d4 = /^\d+$/, p = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, f, h2, w2, T2, A2, S2 = 0, B = []; ; ) {
                if (u(c), S2 >= i2)
                  return B;
                f = u(v), h2 = [], f.slice(-1) === "," ? (f = f.replace(m2, ""), k2()) : I2();
              }
              function I2() {
                for (u(o), w2 = "", T2 = "in descriptor"; ; ) {
                  if (A2 = t.charAt(S2), T2 === "in descriptor")
                    if (r(A2))
                      w2 && (h2.push(w2), w2 = "", T2 = "after descriptor");
                    else if (A2 === ",") {
                      S2 += 1, w2 && h2.push(w2), k2();
                      return;
                    } else if (A2 === "(")
                      w2 = w2 + A2, T2 = "in parens";
                    else if (A2 === "") {
                      w2 && h2.push(w2), k2();
                      return;
                    } else
                      w2 = w2 + A2;
                  else if (T2 === "in parens")
                    if (A2 === ")")
                      w2 = w2 + A2, T2 = "in descriptor";
                    else if (A2 === "") {
                      h2.push(w2), k2();
                      return;
                    } else
                      w2 = w2 + A2;
                  else if (T2 === "after descriptor" && !r(A2))
                    if (A2 === "") {
                      k2();
                      return;
                    } else
                      T2 = "in descriptor", S2 -= 1;
                  S2 += 1;
                }
              }
              function k2() {
                var P = false, C2, D2, g2, F, l = {}, E, y, N, x2, b2;
                for (F = 0; F < h2.length; F++)
                  E = h2[F], y = E[E.length - 1], N = E.substring(0, E.length - 1), x2 = parseInt(N, 10), b2 = parseFloat(N), d4.test(N) && y === "w" ? ((C2 || D2) && (P = true), x2 === 0 ? P = true : C2 = x2) : p.test(N) && y === "x" ? ((C2 || D2 || g2) && (P = true), b2 < 0 ? P = true : D2 = b2) : d4.test(N) && y === "h" ? ((g2 || D2) && (P = true), x2 === 0 ? P = true : g2 = x2) : P = true;
                P ? a3 && a3.error && a3.error("Invalid srcset descriptor found in '" + t + "' at '" + E + "'.") : (l.url = f, C2 && (l.w = C2), D2 && (l.d = D2), g2 && (l.h = g2), B.push(l));
              }
            };
          });
        } }), sg2 = Z3({ "src/language-html/syntax-attribute.js"(e, n) {
          re2();
          var t = ug2(), { builders: { ifBreak: s2, join: a3, line: r } } = Oe2();
          function u(o) {
            let c = t(o, { logger: { error(I2) {
              throw new Error(I2);
            } } }), v = c.some((I2) => {
              let { w: k2 } = I2;
              return k2;
            }), m2 = c.some((I2) => {
              let { h: k2 } = I2;
              return k2;
            }), d4 = c.some((I2) => {
              let { d: k2 } = I2;
              return k2;
            });
            if (v + m2 + d4 > 1)
              throw new Error("Mixed descriptor in srcset is not supported");
            let p = v ? "w" : m2 ? "h" : "d", f = v ? "w" : m2 ? "h" : "x", h2 = (I2) => Math.max(...I2), w2 = c.map((I2) => I2.url), T2 = h2(w2.map((I2) => I2.length)), A2 = c.map((I2) => I2[p]).map((I2) => I2 ? I2.toString() : ""), S2 = A2.map((I2) => {
              let k2 = I2.indexOf(".");
              return k2 === -1 ? I2.length : k2;
            }), B = h2(S2);
            return a3([",", r], w2.map((I2, k2) => {
              let P = [I2], C2 = A2[k2];
              if (C2) {
                let D2 = T2 - I2.length + 1, g2 = B - S2[k2], F = " ".repeat(D2 + g2);
                P.push(s2(F, " "), C2 + f);
              }
              return P;
            }));
          }
          function i2(o) {
            return o.trim().split(/\s+/).join(" ");
          }
          n.exports = { printImgSrcset: u, printClassNames: i2 };
        } }), ig2 = Z3({ "src/language-html/syntax-vue.js"(e, n) {
          re2();
          var { builders: { group: t } } = Oe2();
          function s2(i2, o) {
            let { left: c, operator: v, right: m2 } = a3(i2);
            return [t(o("function _(".concat(c, ") {}"), { parser: "babel", __isVueForBindingLeft: true })), " ", v, " ", o(m2, { parser: "__js_expression" }, { stripTrailingHardline: true })];
          }
          function a3(i2) {
            let o = /(.*?)\s+(in|of)\s+(.*)/s, c = /,([^,\]}]*)(?:,([^,\]}]*))?$/, v = /^\(|\)$/g, m2 = i2.match(o);
            if (!m2)
              return;
            let d4 = {};
            if (d4.for = m2[3].trim(), !d4.for)
              return;
            let p = m2[1].trim().replace(v, ""), f = p.match(c);
            f ? (d4.alias = p.replace(c, ""), d4.iterator1 = f[1].trim(), f[2] && (d4.iterator2 = f[2].trim())) : d4.alias = p;
            let h2 = [d4.alias, d4.iterator1, d4.iterator2];
            if (!h2.some((w2, T2) => !w2 && (T2 === 0 || h2.slice(T2 + 1).some(Boolean))))
              return { left: h2.filter(Boolean).join(","), operator: m2[2], right: d4.for };
          }
          function r(i2, o) {
            return o("function _(".concat(i2, ") {}"), { parser: "babel", __isVueBindings: true });
          }
          function u(i2) {
            let o = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/, c = /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/, v = i2.trim();
            return o.test(v) || c.test(v);
          }
          n.exports = { isVueEventBindingExpression: u, printVueFor: s2, printVueBindings: r };
        } }), ho2 = Z3({ "src/language-html/get-node-content.js"(e, n) {
          re2();
          var { needsToBorrowParentClosingTagStartMarker: t, printClosingTagStartMarker: s2, needsToBorrowLastChildClosingTagEndMarker: a3, printClosingTagEndMarker: r, needsToBorrowParentOpeningTagEndMarker: u, printOpeningTagEndMarker: i2 } = er2();
          function o(c, v) {
            let m2 = c.startSourceSpan.end.offset;
            c.firstChild && u(c.firstChild) && (m2 -= i2(c).length);
            let d4 = c.endSourceSpan.start.offset;
            return c.lastChild && t(c.lastChild) ? d4 += s2(c, v).length : a3(c) && (d4 -= r(c.lastChild, v).length), v.originalText.slice(m2, d4);
          }
          n.exports = o;
        } }), ag2 = Z3({ "src/language-html/embed.js"(e, n) {
          re2();
          var { builders: { breakParent: t, group: s2, hardline: a3, indent: r, line: u, fill: i2, softline: o }, utils: { mapDoc: c, replaceTextEndOfLine: v } } = Oe2(), m2 = Xn2(), { printClosingTag: d4, printClosingTagSuffix: p, needsToBorrowPrevClosingTagEndMarker: f, printOpeningTagPrefix: h2, printOpeningTag: w2 } = er2(), { printImgSrcset: T2, printClassNames: A2 } = sg2(), { printVueFor: S2, printVueBindings: B, isVueEventBindingExpression: I2 } = ig2(), { isScriptLikeTag: k2, isVueNonHtmlBlock: P, inferScriptParser: C2, htmlTrimPreserveIndentation: D2, dedentString: g2, unescapeQuoteEntities: F, isVueSlotAttribute: l, isVueSfcBindingsAttribute: E, getTextValueParts: y } = qt2(), N = ho2();
          function x2(L, M2, j) {
            let $ = (te2) => new RegExp(te2.join("|")).test(L.fullName), V = () => F(L.value), q = false, Y3 = (te2, oe2) => {
              let W2 = te2.type === "NGRoot" ? te2.node.type === "NGMicrosyntax" && te2.node.body.length === 1 && te2.node.body[0].type === "NGMicrosyntaxExpression" ? te2.node.body[0].expression : te2.node : te2.type === "JsExpressionRoot" ? te2.node : te2;
              W2 && (W2.type === "ObjectExpression" || W2.type === "ArrayExpression" || oe2.parser === "__vue_expression" && (W2.type === "TemplateLiteral" || W2.type === "StringLiteral")) && (q = true);
            }, H3 = (te2) => s2(te2), R = function(te2) {
              let oe2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
              return s2([r([o, te2]), oe2 ? o : ""]);
            }, Q = (te2) => q ? H3(te2) : R(te2), ee2 = (te2, oe2) => M2(te2, Object.assign({ __onHtmlBindingRoot: Y3, __embeddedInHtml: true }, oe2));
            if (L.fullName === "srcset" && (L.parent.fullName === "img" || L.parent.fullName === "source"))
              return R(T2(V()));
            if (L.fullName === "class" && !j.parentParser) {
              let te2 = V();
              if (!te2.includes("{{"))
                return A2(te2);
            }
            if (L.fullName === "style" && !j.parentParser) {
              let te2 = V();
              if (!te2.includes("{{"))
                return R(ee2(te2, { parser: "css", __isHTMLStyleAttribute: true }));
            }
            if (j.parser === "vue") {
              if (L.fullName === "v-for")
                return S2(V(), ee2);
              if (l(L) || E(L, j))
                return B(V(), ee2);
              let te2 = ["^@", "^v-on:"], oe2 = ["^:", "^v-bind:"], W2 = ["^v-"];
              if ($(te2)) {
                let X3 = V(), ue2 = I2(X3) ? "__js_expression" : j.__should_parse_vue_template_with_ts ? "__vue_ts_event_binding" : "__vue_event_binding";
                return Q(ee2(X3, { parser: ue2 }));
              }
              if ($(oe2))
                return Q(ee2(V(), { parser: "__vue_expression" }));
              if ($(W2))
                return Q(ee2(V(), { parser: "__js_expression" }));
            }
            if (j.parser === "angular") {
              let te2 = (G, z) => ee2(G, Object.assign(Object.assign({}, z), {}, { trailingComma: "none" })), oe2 = ["^\\*"], W2 = ["^\\(.+\\)$", "^on-"], X3 = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], ue2 = ["^i18n(-.+)?$"];
              if ($(W2))
                return Q(te2(V(), { parser: "__ng_action" }));
              if ($(X3))
                return Q(te2(V(), { parser: "__ng_binding" }));
              if ($(ue2)) {
                let G = V().trim();
                return R(i2(y(L, G)), !G.includes("@@"));
              }
              if ($(oe2))
                return Q(te2(V(), { parser: "__ng_directive" }));
              let De2 = /{{(.+?)}}/s, ie = V();
              if (De2.test(ie)) {
                let G = [];
                for (let [z, U] of ie.split(De2).entries())
                  if (z % 2 === 0)
                    G.push(v(U));
                  else
                    try {
                      G.push(s2(["{{", r([u, te2(U, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), u, "}}"]));
                    } catch {
                      G.push("{{", v(U), "}}");
                    }
                return s2(G);
              }
            }
            return null;
          }
          function b2(L, M2, j, $) {
            let V = L.getValue();
            switch (V.type) {
              case "element": {
                if (k2(V) || V.type === "interpolation")
                  return;
                if (!V.isSelfClosing && P(V, $)) {
                  let q = C2(V, $);
                  if (!q)
                    return;
                  let Y3 = N(V, $), H3 = /^\s*$/.test(Y3), R = "";
                  return H3 || (R = j(D2(Y3), { parser: q, __embeddedInHtml: true }, { stripTrailingHardline: true }), H3 = R === ""), [h2(V, $), s2(w2(L, $, M2)), H3 ? "" : a3, R, H3 ? "" : a3, d4(V, $), p(V, $)];
                }
                break;
              }
              case "text": {
                if (k2(V.parent)) {
                  let q = C2(V.parent, $);
                  if (q) {
                    let Y3 = q === "markdown" ? g2(V.value.replace(/^[^\S\n]*\n/, "")) : V.value, H3 = { parser: q, __embeddedInHtml: true };
                    if ($.parser === "html" && q === "babel") {
                      let R = "script", { attrMap: Q } = V.parent;
                      Q && (Q.type === "module" || Q.type === "text/babel" && Q["data-type"] === "module") && (R = "module"), H3.__babelSourceType = R;
                    }
                    return [t, h2(V, $), j(Y3, H3, { stripTrailingHardline: true }), p(V, $)];
                  }
                } else if (V.parent.type === "interpolation") {
                  let q = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
                  return $.parser === "angular" ? (q.parser = "__ng_interpolation", q.trailingComma = "none") : $.parser === "vue" ? q.parser = $.__should_parse_vue_template_with_ts ? "__vue_ts_expression" : "__vue_expression" : q.parser = "__js_expression", [r([u, j(V.value, q, { stripTrailingHardline: true })]), V.parent.next && f(V.parent.next) ? " " : u];
                }
                break;
              }
              case "attribute": {
                if (!V.value)
                  break;
                if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test($.originalText.slice(V.valueSpan.start.offset, V.valueSpan.end.offset)))
                  return [V.rawName, "=", V.value];
                if ($.parser === "lwc" && /^{.*}$/s.test($.originalText.slice(V.valueSpan.start.offset, V.valueSpan.end.offset)))
                  return [V.rawName, "=", V.value];
                let q = x2(V, (Y3, H3) => j(Y3, Object.assign({ __isInHtmlAttribute: true, __embeddedInHtml: true }, H3), { stripTrailingHardline: true }), $);
                if (q)
                  return [V.rawName, '="', s2(c(q, (Y3) => typeof Y3 == "string" ? Y3.replace(/"/g, "&quot;") : Y3)), '"'];
                break;
              }
              case "front-matter":
                return m2(V, j);
            }
          }
          n.exports = b2;
        } }), vo2 = Z3({ "src/language-html/print/children.js"(e, n) {
          re2();
          var { builders: { breakParent: t, group: s2, ifBreak: a3, line: r, softline: u, hardline: i2 }, utils: { replaceTextEndOfLine: o } } = Oe2(), { locStart: c, locEnd: v } = Yn2(), { forceBreakChildren: m2, forceNextEmptyLine: d4, isTextLikeNode: p, hasPrettierIgnore: f, preferHardlineAsLeadingSpaces: h2 } = qt2(), { printOpeningTagPrefix: w2, needsToBorrowNextOpeningTagStartMarker: T2, printOpeningTagStartMarker: A2, needsToBorrowPrevClosingTagEndMarker: S2, printClosingTagEndMarker: B, printClosingTagSuffix: I2, needsToBorrowParentClosingTagStartMarker: k2 } = er2();
          function P(g2, F, l) {
            let E = g2.getValue();
            return f(E) ? [w2(E, F), ...o(F.originalText.slice(c(E) + (E.prev && T2(E.prev) ? A2(E).length : 0), v(E) - (E.next && S2(E.next) ? B(E, F).length : 0))), I2(E, F)] : l();
          }
          function C2(g2, F) {
            return p(g2) && p(F) ? g2.isTrailingSpaceSensitive ? g2.hasTrailingSpaces ? h2(F) ? i2 : r : "" : h2(F) ? i2 : u : T2(g2) && (f(F) || F.firstChild || F.isSelfClosing || F.type === "element" && F.attrs.length > 0) || g2.type === "element" && g2.isSelfClosing && S2(F) ? "" : !F.isLeadingSpaceSensitive || h2(F) || S2(F) && g2.lastChild && k2(g2.lastChild) && g2.lastChild.lastChild && k2(g2.lastChild.lastChild) ? i2 : F.hasLeadingSpaces ? r : u;
          }
          function D2(g2, F, l) {
            let E = g2.getValue();
            if (m2(E))
              return [t, ...g2.map((N) => {
                let x2 = N.getValue(), b2 = x2.prev ? C2(x2.prev, x2) : "";
                return [b2 ? [b2, d4(x2.prev) ? i2 : ""] : "", P(N, F, l)];
              }, "children")];
            let y = E.children.map(() => Symbol(""));
            return g2.map((N, x2) => {
              let b2 = N.getValue();
              if (p(b2)) {
                if (b2.prev && p(b2.prev)) {
                  let Y3 = C2(b2.prev, b2);
                  if (Y3)
                    return d4(b2.prev) ? [i2, i2, P(N, F, l)] : [Y3, P(N, F, l)];
                }
                return P(N, F, l);
              }
              let L = [], M2 = [], j = [], $ = [], V = b2.prev ? C2(b2.prev, b2) : "", q = b2.next ? C2(b2, b2.next) : "";
              return V && (d4(b2.prev) ? L.push(i2, i2) : V === i2 ? L.push(i2) : p(b2.prev) ? M2.push(V) : M2.push(a3("", u, { groupId: y[x2 - 1] }))), q && (d4(b2) ? p(b2.next) && $.push(i2, i2) : q === i2 ? p(b2.next) && $.push(i2) : j.push(q)), [...L, s2([...M2, s2([P(N, F, l), ...j], { id: y[x2] })]), ...$];
            }, "children");
          }
          n.exports = { printChildren: D2 };
        } }), og2 = Z3({ "src/language-html/print/element.js"(e, n) {
          re2();
          var { builders: { breakParent: t, dedentToRoot: s2, group: a3, ifBreak: r, indentIfBreak: u, indent: i2, line: o, softline: c }, utils: { replaceTextEndOfLine: v } } = Oe2(), m2 = ho2(), { shouldPreserveContent: d4, isScriptLikeTag: p, isVueCustomBlock: f, countParents: h2, forceBreakContent: w2 } = qt2(), { printOpeningTagPrefix: T2, printOpeningTag: A2, printClosingTagSuffix: S2, printClosingTag: B, needsToBorrowPrevClosingTagEndMarker: I2, needsToBorrowLastChildClosingTagEndMarker: k2 } = er2(), { printChildren: P } = vo2();
          function C2(D2, g2, F) {
            let l = D2.getValue();
            if (d4(l, g2))
              return [T2(l, g2), a3(A2(D2, g2, F)), ...v(m2(l, g2)), ...B(l, g2), S2(l, g2)];
            let E = l.children.length === 1 && l.firstChild.type === "interpolation" && l.firstChild.isLeadingSpaceSensitive && !l.firstChild.hasLeadingSpaces && l.lastChild.isTrailingSpaceSensitive && !l.lastChild.hasTrailingSpaces, y = Symbol("element-attr-group-id"), N = (M2) => a3([a3(A2(D2, g2, F), { id: y }), M2, B(l, g2)]), x2 = (M2) => E ? u(M2, { groupId: y }) : (p(l) || f(l, g2)) && l.parent.type === "root" && g2.parser === "vue" && !g2.vueIndentScriptAndStyle ? M2 : i2(M2), b2 = () => E ? r(c, "", { groupId: y }) : l.firstChild.hasLeadingSpaces && l.firstChild.isLeadingSpaceSensitive ? o : l.firstChild.type === "text" && l.isWhitespaceSensitive && l.isIndentationSensitive ? s2(c) : c, L = () => (l.next ? I2(l.next) : k2(l.parent)) ? l.lastChild.hasTrailingSpaces && l.lastChild.isTrailingSpaceSensitive ? " " : "" : E ? r(c, "", { groupId: y }) : l.lastChild.hasTrailingSpaces && l.lastChild.isTrailingSpaceSensitive ? o : (l.lastChild.type === "comment" || l.lastChild.type === "text" && l.isWhitespaceSensitive && l.isIndentationSensitive) && new RegExp("\\n[\\t ]{".concat(g2.tabWidth * h2(D2, (j) => j.parent && j.parent.type !== "root"), "}$")).test(l.lastChild.value) ? "" : c;
            return l.children.length === 0 ? N(l.hasDanglingSpaces && l.isDanglingSpaceSensitive ? o : "") : N([w2(l) ? t : "", x2([b2(), P(D2, g2, F)]), L()]);
          }
          n.exports = { printElement: C2 };
        } }), lg2 = Z3({ "src/language-html/printer-html.js"(e, n) {
          re2();
          var { builders: { fill: t, group: s2, hardline: a3, literalline: r }, utils: { cleanDoc: u, getDocParts: i2, isConcat: o, replaceTextEndOfLine: c } } = Oe2(), v = zd2(), { countChars: m2, unescapeQuoteEntities: d4, getTextValueParts: p } = qt2(), f = rg2(), { insertPragma: h2 } = ng2(), { locStart: w2, locEnd: T2 } = Yn2(), A2 = ag2(), { printClosingTagSuffix: S2, printClosingTagEnd: B, printOpeningTagPrefix: I2, printOpeningTagStart: k2 } = er2(), { printElement: P } = og2(), { printChildren: C2 } = vo2();
          function D2(g2, F, l) {
            let E = g2.getValue();
            switch (E.type) {
              case "front-matter":
                return c(E.raw);
              case "root":
                return F.__onHtmlRoot && F.__onHtmlRoot(E), [s2(C2(g2, F, l)), a3];
              case "element":
              case "ieConditionalComment":
                return P(g2, F, l);
              case "ieConditionalStartComment":
              case "ieConditionalEndComment":
                return [k2(E), B(E)];
              case "interpolation":
                return [k2(E, F), ...g2.map(l, "children"), B(E, F)];
              case "text": {
                if (E.parent.type === "interpolation") {
                  let N = /\n[^\S\n]*$/, x2 = N.test(E.value), b2 = x2 ? E.value.replace(N, "") : E.value;
                  return [...c(b2), x2 ? a3 : ""];
                }
                let y = u([I2(E, F), ...p(E), S2(E, F)]);
                return o(y) || y.type === "fill" ? t(i2(y)) : y;
              }
              case "docType":
                return [s2([k2(E, F), " ", E.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), B(E, F)];
              case "comment":
                return [I2(E, F), ...c(F.originalText.slice(w2(E), T2(E)), r), S2(E, F)];
              case "attribute": {
                if (E.value === null)
                  return E.rawName;
                let y = d4(E.value), N = m2(y, "'"), x2 = m2(y, '"'), b2 = N < x2 ? "'" : '"';
                return [E.rawName, "=", b2, ...c(b2 === '"' ? y.replace(/"/g, "&quot;") : y.replace(/'/g, "&apos;")), b2];
              }
              default:
                throw new Error("Unexpected node type ".concat(E.type));
            }
          }
          n.exports = { preprocess: f, print: D2, insertPragma: h2, massageAstNode: v, embed: A2 };
        } }), cg2 = Z3({ "src/language-html/options.js"(e, n) {
          re2();
          var t = Ot2(), s2 = "HTML";
          n.exports = { bracketSameLine: t.bracketSameLine, htmlWhitespaceSensitivity: { since: "1.15.0", category: s2, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: t.singleAttributePerLine, vueIndentScriptAndStyle: { since: "1.19.0", category: s2, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } };
        } }), pg2 = Z3({ "src/language-html/parsers.js"() {
          re2();
        } }), xn2 = Z3({ "node_modules/linguist-languages/data/HTML.json"(e, n) {
          n.exports = { name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], languageId: 146 };
        } }), fg2 = Z3({ "node_modules/linguist-languages/data/Vue.json"(e, n) {
          n.exports = { name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", languageId: 391 };
        } }), Dg2 = Z3({ "src/language-html/index.js"(e, n) {
          re2();
          var t = Bt(), s2 = lg2(), a3 = cg2(), r = pg2(), u = [t(xn2(), () => ({ name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: [] })), t(xn2(), (o) => ({ since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: [...o.extensions, ".mjml"] })), t(xn2(), () => ({ name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: [] })), t(fg2(), () => ({ since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"] }))], i2 = { html: s2 };
          n.exports = { languages: u, printers: i2, options: a3, parsers: r };
        } }), mg2 = Z3({ "src/language-yaml/pragma.js"(e, n) {
          re2();
          function t(r) {
            return /^\s*@(?:prettier|format)\s*$/.test(r);
          }
          function s2(r) {
            return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(r);
          }
          function a3(r) {
            return `# @format

`.concat(r);
          }
          n.exports = { isPragma: t, hasPragma: s2, insertPragma: a3 };
        } }), dg2 = Z3({ "src/language-yaml/loc.js"(e, n) {
          re2();
          function t(a3) {
            return a3.position.start.offset;
          }
          function s2(a3) {
            return a3.position.end.offset;
          }
          n.exports = { locStart: t, locEnd: s2 };
        } }), gg2 = Z3({ "src/language-yaml/embed.js"(e, n) {
          re2();
          function t(s2, a3, r, u) {
            if (s2.getValue().type === "root" && u.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint)rc$/.test(u.filepath))
              return r(u.originalText, Object.assign(Object.assign({}, u), {}, { parser: "json" }));
          }
          n.exports = t;
        } }), Mt2 = Z3({ "src/language-yaml/utils.js"(e, n) {
          re2();
          var { getLast: t, isNonEmptyArray: s2 } = Ue2();
          function a3(C2, D2) {
            let g2 = 0, F = C2.stack.length - 1;
            for (let l = 0; l < F; l++) {
              let E = C2.stack[l];
              r(E) && D2(E) && g2++;
            }
            return g2;
          }
          function r(C2, D2) {
            return C2 && typeof C2.type == "string" && (!D2 || D2.includes(C2.type));
          }
          function u(C2, D2, g2) {
            return D2("children" in C2 ? Object.assign(Object.assign({}, C2), {}, { children: C2.children.map((F) => u(F, D2, C2)) }) : C2, g2);
          }
          function i2(C2, D2, g2) {
            Object.defineProperty(C2, D2, { get: g2, enumerable: false });
          }
          function o(C2, D2) {
            let g2 = 0, F = D2.length;
            for (let l = C2.position.end.offset - 1; l < F; l++) {
              let E = D2[l];
              if (E === `
` && g2++, g2 === 1 && /\S/.test(E))
                return false;
              if (g2 === 2)
                return true;
            }
            return false;
          }
          function c(C2) {
            switch (C2.getValue().type) {
              case "tag":
              case "anchor":
              case "comment":
                return false;
            }
            let g2 = C2.stack.length;
            for (let F = 1; F < g2; F++) {
              let l = C2.stack[F], E = C2.stack[F - 1];
              if (Array.isArray(E) && typeof l == "number" && l !== E.length - 1)
                return false;
            }
            return true;
          }
          function v(C2) {
            return s2(C2.children) ? v(t(C2.children)) : C2;
          }
          function m2(C2) {
            return C2.value.trim() === "prettier-ignore";
          }
          function d4(C2) {
            let D2 = C2.getValue();
            if (D2.type === "documentBody") {
              let g2 = C2.getParentNode();
              return S2(g2.head) && m2(t(g2.head.endComments));
            }
            return h2(D2) && m2(t(D2.leadingComments));
          }
          function p(C2) {
            return !s2(C2.children) && !f(C2);
          }
          function f(C2) {
            return h2(C2) || w2(C2) || T2(C2) || A2(C2) || S2(C2);
          }
          function h2(C2) {
            return s2(C2 == null ? void 0 : C2.leadingComments);
          }
          function w2(C2) {
            return s2(C2 == null ? void 0 : C2.middleComments);
          }
          function T2(C2) {
            return C2 == null ? void 0 : C2.indicatorComment;
          }
          function A2(C2) {
            return C2 == null ? void 0 : C2.trailingComment;
          }
          function S2(C2) {
            return s2(C2 == null ? void 0 : C2.endComments);
          }
          function B(C2) {
            let D2 = [], g2;
            for (let F of C2.split(/( +)/))
              F !== " " ? g2 === " " ? D2.push(F) : D2.push((D2.pop() || "") + F) : g2 === void 0 && D2.unshift(""), g2 = F;
            return g2 === " " && D2.push((D2.pop() || "") + " "), D2[0] === "" && (D2.shift(), D2.unshift(" " + (D2.shift() || ""))), D2;
          }
          function I2(C2, D2, g2) {
            let F = D2.split(`
`).map((l, E, y) => E === 0 && E === y.length - 1 ? l : E !== 0 && E !== y.length - 1 ? l.trim() : E === 0 ? l.trimEnd() : l.trimStart());
            return g2.proseWrap === "preserve" ? F.map((l) => l.length === 0 ? [] : [l]) : F.map((l) => l.length === 0 ? [] : B(l)).reduce((l, E, y) => y !== 0 && F[y - 1].length > 0 && E.length > 0 && !(C2 === "quoteDouble" && t(t(l)).endsWith("\\")) ? [...l.slice(0, -1), [...t(l), ...E]] : [...l, E], []).map((l) => g2.proseWrap === "never" ? [l.join(" ")] : l);
          }
          function k2(C2, D2) {
            let { parentIndent: g2, isLastDescendant: F, options: l } = D2, E = C2.position.start.line === C2.position.end.line ? "" : l.originalText.slice(C2.position.start.offset, C2.position.end.offset).match(/^[^\n]*\n(.*)$/s)[1], y;
            if (C2.indent === null) {
              let b2 = E.match(/^(?<leadingSpace> *)[^\n\r ]/m);
              y = b2 ? b2.groups.leadingSpace.length : Number.POSITIVE_INFINITY;
            } else
              y = C2.indent - 1 + g2;
            let N = E.split(`
`).map((b2) => b2.slice(y));
            if (l.proseWrap === "preserve" || C2.type === "blockLiteral")
              return x2(N.map((b2) => b2.length === 0 ? [] : [b2]));
            return x2(N.map((b2) => b2.length === 0 ? [] : B(b2)).reduce((b2, L, M2) => M2 !== 0 && N[M2 - 1].length > 0 && L.length > 0 && !/^\s/.test(L[0]) && !/^\s|\s$/.test(t(b2)) ? [...b2.slice(0, -1), [...t(b2), ...L]] : [...b2, L], []).map((b2) => b2.reduce((L, M2) => L.length > 0 && /\s$/.test(t(L)) ? [...L.slice(0, -1), t(L) + " " + M2] : [...L, M2], [])).map((b2) => l.proseWrap === "never" ? [b2.join(" ")] : b2));
            function x2(b2) {
              if (C2.chomping === "keep")
                return t(b2).length === 0 ? b2.slice(0, -1) : b2;
              let L = 0;
              for (let M2 = b2.length - 1; M2 >= 0 && b2[M2].length === 0; M2--)
                L++;
              return L === 0 ? b2 : L >= 2 && !F ? b2.slice(0, -(L - 1)) : b2.slice(0, -L);
            }
          }
          function P(C2) {
            if (!C2)
              return true;
            switch (C2.type) {
              case "plain":
              case "quoteDouble":
              case "quoteSingle":
              case "alias":
              case "flowMapping":
              case "flowSequence":
                return true;
              default:
                return false;
            }
          }
          n.exports = { getLast: t, getAncestorCount: a3, isNode: r, isEmptyNode: p, isInlineNode: P, mapNode: u, defineShortcut: i2, isNextLineEmpty: o, isLastDescendantNode: c, getBlockValueLineContents: k2, getFlowScalarLineContents: I2, getLastDescendantNode: v, hasPrettierIgnore: d4, hasLeadingComments: h2, hasMiddleComments: w2, hasIndicatorComment: T2, hasTrailingComment: A2, hasEndComments: S2 };
        } }), yg2 = Z3({ "src/language-yaml/print-preprocess.js"(e, n) {
          re2();
          var { defineShortcut: t, mapNode: s2 } = Mt2();
          function a3(u) {
            return s2(u, r);
          }
          function r(u) {
            switch (u.type) {
              case "document":
                t(u, "head", () => u.children[0]), t(u, "body", () => u.children[1]);
                break;
              case "documentBody":
              case "sequenceItem":
              case "flowSequenceItem":
              case "mappingKey":
              case "mappingValue":
                t(u, "content", () => u.children[0]);
                break;
              case "mappingItem":
              case "flowMappingItem":
                t(u, "key", () => u.children[0]), t(u, "value", () => u.children[1]);
                break;
            }
            return u;
          }
          n.exports = a3;
        } }), jr2 = Z3({ "src/language-yaml/print/misc.js"(e, n) {
          re2();
          var { builders: { softline: t, align: s2 } } = Oe2(), { hasEndComments: a3, isNextLineEmpty: r, isNode: u } = Mt2(), i2 = /* @__PURE__ */ new WeakMap();
          function o(m2, d4) {
            let p = m2.getValue(), f = m2.stack[0], h2;
            return i2.has(f) ? h2 = i2.get(f) : (h2 = /* @__PURE__ */ new Set(), i2.set(f, h2)), !h2.has(p.position.end.line) && (h2.add(p.position.end.line), r(p, d4) && !c(m2.getParentNode())) ? t : "";
          }
          function c(m2) {
            return a3(m2) && !u(m2, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
          }
          function v(m2, d4) {
            return s2(" ".repeat(m2), d4);
          }
          n.exports = { alignWithSpaces: v, shouldPrintEndComments: c, printNextEmptyLine: o };
        } }), hg2 = Z3({ "src/language-yaml/print/flow-mapping-sequence.js"(e, n) {
          re2();
          var { builders: { ifBreak: t, line: s2, softline: a3, hardline: r, join: u } } = Oe2(), { isEmptyNode: i2, getLast: o, hasEndComments: c } = Mt2(), { printNextEmptyLine: v, alignWithSpaces: m2 } = jr2();
          function d4(f, h2, w2) {
            let T2 = f.getValue(), A2 = T2.type === "flowMapping", S2 = A2 ? "{" : "[", B = A2 ? "}" : "]", I2 = a3;
            A2 && T2.children.length > 0 && w2.bracketSpacing && (I2 = s2);
            let k2 = o(T2.children), P = k2 && k2.type === "flowMappingItem" && i2(k2.key) && i2(k2.value);
            return [S2, m2(w2.tabWidth, [I2, p(f, h2, w2), w2.trailingComma === "none" ? "" : t(","), c(T2) ? [r, u(r, f.map(h2, "endComments"))] : ""]), P ? "" : I2, B];
          }
          function p(f, h2, w2) {
            let T2 = f.getValue();
            return f.map((S2, B) => [h2(), B === T2.children.length - 1 ? "" : [",", s2, T2.children[B].position.start.line !== T2.children[B + 1].position.start.line ? v(S2, w2.originalText) : ""]], "children");
          }
          n.exports = { printFlowMapping: d4, printFlowSequence: d4 };
        } }), vg2 = Z3({ "src/language-yaml/print/mapping-item.js"(e, n) {
          re2();
          var { builders: { conditionalGroup: t, group: s2, hardline: a3, ifBreak: r, join: u, line: i2 } } = Oe2(), { hasLeadingComments: o, hasMiddleComments: c, hasTrailingComment: v, hasEndComments: m2, isNode: d4, isEmptyNode: p, isInlineNode: f } = Mt2(), { alignWithSpaces: h2 } = jr2();
          function w2(B, I2, k2, P, C2) {
            let { key: D2, value: g2 } = B, F = p(D2), l = p(g2);
            if (F && l)
              return ": ";
            let E = P("key"), y = A2(B) ? " " : "";
            if (l)
              return B.type === "flowMappingItem" && I2.type === "flowMapping" ? E : B.type === "mappingItem" && T2(D2.content, C2) && !v(D2.content) && (!I2.tag || I2.tag.value !== "tag:yaml.org,2002:set") ? [E, y, ":"] : ["? ", h2(2, E)];
            let N = P("value");
            if (F)
              return [": ", h2(2, N)];
            if (o(g2) || !f(D2.content))
              return ["? ", h2(2, E), a3, u("", k2.map(P, "value", "leadingComments").map(($) => [$, a3])), ": ", h2(2, N)];
            if (S2(D2.content) && !o(D2.content) && !c(D2.content) && !v(D2.content) && !m2(D2) && !o(g2.content) && !c(g2.content) && !m2(g2) && T2(g2.content, C2))
              return [E, y, ": ", N];
            let x2 = Symbol("mappingKey"), b2 = s2([r("? "), s2(h2(2, E), { id: x2 })]), L = [a3, ": ", h2(2, N)], M2 = [y, ":"];
            o(g2.content) || m2(g2) && g2.content && !d4(g2.content, ["mapping", "sequence"]) || I2.type === "mapping" && v(D2.content) && f(g2.content) || d4(g2.content, ["mapping", "sequence"]) && g2.content.tag === null && g2.content.anchor === null ? M2.push(a3) : g2.content && M2.push(i2), M2.push(N);
            let j = h2(C2.tabWidth, M2);
            return T2(D2.content, C2) && !o(D2.content) && !c(D2.content) && !m2(D2) ? t([[E, j]]) : t([[b2, r(L, j, { groupId: x2 })]]);
          }
          function T2(B, I2) {
            if (!B)
              return true;
            switch (B.type) {
              case "plain":
              case "quoteSingle":
              case "quoteDouble":
                break;
              case "alias":
                return true;
              default:
                return false;
            }
            if (I2.proseWrap === "preserve")
              return B.position.start.line === B.position.end.line;
            if (/\\$/m.test(I2.originalText.slice(B.position.start.offset, B.position.end.offset)))
              return false;
            switch (I2.proseWrap) {
              case "never":
                return !B.value.includes(`
`);
              case "always":
                return !/[\n ]/.test(B.value);
              default:
                return false;
            }
          }
          function A2(B) {
            return B.key.content && B.key.content.type === "alias";
          }
          function S2(B) {
            if (!B)
              return true;
            switch (B.type) {
              case "plain":
              case "quoteDouble":
              case "quoteSingle":
                return B.position.start.line === B.position.end.line;
              case "alias":
                return true;
              default:
                return false;
            }
          }
          n.exports = w2;
        } }), Cg = Z3({ "src/language-yaml/print/block.js"(e, n) {
          re2();
          var { builders: { dedent: t, dedentToRoot: s2, fill: a3, hardline: r, join: u, line: i2, literalline: o, markAsRoot: c }, utils: { getDocParts: v } } = Oe2(), { getAncestorCount: m2, getBlockValueLineContents: d4, hasIndicatorComment: p, isLastDescendantNode: f, isNode: h2 } = Mt2(), { alignWithSpaces: w2 } = jr2();
          function T2(A2, S2, B) {
            let I2 = A2.getValue(), k2 = m2(A2, (F) => h2(F, ["sequence", "mapping"])), P = f(A2), C2 = [I2.type === "blockFolded" ? ">" : "|"];
            I2.indent !== null && C2.push(I2.indent.toString()), I2.chomping !== "clip" && C2.push(I2.chomping === "keep" ? "+" : "-"), p(I2) && C2.push(" ", S2("indicatorComment"));
            let D2 = d4(I2, { parentIndent: k2, isLastDescendant: P, options: B }), g2 = [];
            for (let [F, l] of D2.entries())
              F === 0 && g2.push(r), g2.push(a3(v(u(i2, l)))), F !== D2.length - 1 ? g2.push(l.length === 0 ? r : c(o)) : I2.chomping === "keep" && P && g2.push(s2(l.length === 0 ? r : o));
            return I2.indent === null ? C2.push(t(w2(B.tabWidth, g2))) : C2.push(s2(w2(I2.indent - 1 + k2, g2))), C2;
          }
          n.exports = T2;
        } }), Eg = Z3({ "src/language-yaml/printer-yaml.js"(e, n) {
          re2();
          var { builders: { breakParent: t, fill: s2, group: a3, hardline: r, join: u, line: i2, lineSuffix: o, literalline: c }, utils: { getDocParts: v, replaceTextEndOfLine: m2 } } = Oe2(), { isPreviousLineEmpty: d4 } = Ue2(), { insertPragma: p, isPragma: f } = mg2(), { locStart: h2 } = dg2(), w2 = gg2(), { getFlowScalarLineContents: T2, getLastDescendantNode: A2, hasLeadingComments: S2, hasMiddleComments: B, hasTrailingComment: I2, hasEndComments: k2, hasPrettierIgnore: P, isLastDescendantNode: C2, isNode: D2, isInlineNode: g2 } = Mt2(), F = yg2(), { alignWithSpaces: l, printNextEmptyLine: E, shouldPrintEndComments: y } = jr2(), { printFlowMapping: N, printFlowSequence: x2 } = hg2(), b2 = vg2(), L = Cg();
          function M2(R, Q, ee2) {
            let te2 = R.getValue(), oe2 = [];
            te2.type !== "mappingValue" && S2(te2) && oe2.push([u(r, R.map(ee2, "leadingComments")), r]);
            let { tag: W2, anchor: X3 } = te2;
            W2 && oe2.push(ee2("tag")), W2 && X3 && oe2.push(" "), X3 && oe2.push(ee2("anchor"));
            let ue2 = "";
            D2(te2, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !C2(R) && (ue2 = E(R, Q.originalText)), (W2 || X3) && (D2(te2, ["sequence", "mapping"]) && !B(te2) ? oe2.push(r) : oe2.push(" ")), B(te2) && oe2.push([te2.middleComments.length === 1 ? "" : r, u(r, R.map(ee2, "middleComments")), r]);
            let De2 = R.getParentNode();
            return P(R) ? oe2.push(m2(Q.originalText.slice(te2.position.start.offset, te2.position.end.offset).trimEnd(), c)) : oe2.push(a3(j(te2, De2, R, Q, ee2))), I2(te2) && !D2(te2, ["document", "documentHead"]) && oe2.push(o([te2.type === "mappingValue" && !te2.content ? "" : " ", De2.type === "mappingKey" && R.getParentNode(2).type === "mapping" && g2(te2) ? "" : t, ee2("trailingComment")])), y(te2) && oe2.push(l(te2.type === "sequenceItem" ? 2 : 0, [r, u(r, R.map((ie) => [d4(Q.originalText, ie.getValue(), h2) ? r : "", ee2()], "endComments"))])), oe2.push(ue2), oe2;
          }
          function j(R, Q, ee2, te2, oe2) {
            switch (R.type) {
              case "root": {
                let { children: W2 } = R, X3 = [];
                ee2.each((De2, ie) => {
                  let G = W2[ie], z = W2[ie + 1];
                  ie !== 0 && X3.push(r), X3.push(oe2()), V(G, z) ? (X3.push(r, "..."), I2(G) && X3.push(" ", oe2("trailingComment"))) : z && !I2(z.head) && X3.push(r, "---");
                }, "children");
                let ue2 = A2(R);
                return (!D2(ue2, ["blockLiteral", "blockFolded"]) || ue2.chomping !== "keep") && X3.push(r), X3;
              }
              case "document": {
                let W2 = Q.children[ee2.getName() + 1], X3 = [];
                return q(R, W2, Q, te2) === "head" && ((R.head.children.length > 0 || R.head.endComments.length > 0) && X3.push(oe2("head")), I2(R.head) ? X3.push(["---", " ", oe2(["head", "trailingComment"])]) : X3.push("---")), $(R) && X3.push(oe2("body")), u(r, X3);
              }
              case "documentHead":
                return u(r, [...ee2.map(oe2, "children"), ...ee2.map(oe2, "endComments")]);
              case "documentBody": {
                let { children: W2, endComments: X3 } = R, ue2 = "";
                if (W2.length > 0 && X3.length > 0) {
                  let De2 = A2(R);
                  D2(De2, ["blockFolded", "blockLiteral"]) ? De2.chomping !== "keep" && (ue2 = [r, r]) : ue2 = r;
                }
                return [u(r, ee2.map(oe2, "children")), ue2, u(r, ee2.map(oe2, "endComments"))];
              }
              case "directive":
                return ["%", u(" ", [R.name, ...R.parameters])];
              case "comment":
                return ["#", R.value];
              case "alias":
                return ["*", R.value];
              case "tag":
                return te2.originalText.slice(R.position.start.offset, R.position.end.offset);
              case "anchor":
                return ["&", R.value];
              case "plain":
                return Y3(R.type, te2.originalText.slice(R.position.start.offset, R.position.end.offset), te2);
              case "quoteDouble":
              case "quoteSingle": {
                let W2 = "'", X3 = '"', ue2 = te2.originalText.slice(R.position.start.offset + 1, R.position.end.offset - 1);
                if (R.type === "quoteSingle" && ue2.includes("\\") || R.type === "quoteDouble" && /\\[^"]/.test(ue2)) {
                  let ie = R.type === "quoteDouble" ? X3 : W2;
                  return [ie, Y3(R.type, ue2, te2), ie];
                }
                if (ue2.includes(X3))
                  return [W2, Y3(R.type, R.type === "quoteDouble" ? ue2.replace(/\\"/g, X3).replace(/'/g, W2.repeat(2)) : ue2, te2), W2];
                if (ue2.includes(W2))
                  return [X3, Y3(R.type, R.type === "quoteSingle" ? ue2.replace(/''/g, W2) : ue2, te2), X3];
                let De2 = te2.singleQuote ? W2 : X3;
                return [De2, Y3(R.type, ue2, te2), De2];
              }
              case "blockFolded":
              case "blockLiteral":
                return L(ee2, oe2, te2);
              case "mapping":
              case "sequence":
                return u(r, ee2.map(oe2, "children"));
              case "sequenceItem":
                return ["- ", l(2, R.content ? oe2("content") : "")];
              case "mappingKey":
              case "mappingValue":
                return R.content ? oe2("content") : "";
              case "mappingItem":
              case "flowMappingItem":
                return b2(R, Q, ee2, oe2, te2);
              case "flowMapping":
                return N(ee2, oe2, te2);
              case "flowSequence":
                return x2(ee2, oe2, te2);
              case "flowSequenceItem":
                return oe2("content");
              default:
                throw new Error("Unexpected node type ".concat(R.type));
            }
          }
          function $(R) {
            return R.body.children.length > 0 || k2(R.body);
          }
          function V(R, Q) {
            return I2(R) || Q && (Q.head.children.length > 0 || k2(Q.head));
          }
          function q(R, Q, ee2, te2) {
            return ee2.children[0] === R && /---(?:\s|$)/.test(te2.originalText.slice(h2(R), h2(R) + 4)) || R.head.children.length > 0 || k2(R.head) || I2(R.head) ? "head" : V(R, Q) ? false : Q ? "root" : false;
          }
          function Y3(R, Q, ee2) {
            let te2 = T2(R, Q, ee2);
            return u(r, te2.map((oe2) => s2(v(u(i2, oe2)))));
          }
          function H3(R, Q) {
            if (D2(Q))
              switch (delete Q.position, Q.type) {
                case "comment":
                  if (f(Q.value))
                    return null;
                  break;
                case "quoteDouble":
                case "quoteSingle":
                  Q.type = "quote";
                  break;
              }
          }
          n.exports = { preprocess: F, embed: w2, print: M2, massageAstNode: H3, insertPragma: p };
        } }), Fg = Z3({ "src/language-yaml/options.js"(e, n) {
          re2();
          var t = Ot2();
          n.exports = { bracketSpacing: t.bracketSpacing, singleQuote: t.singleQuote, proseWrap: t.proseWrap };
        } }), Ag = Z3({ "src/language-yaml/parsers.js"() {
          re2();
        } }), Sg = Z3({ "node_modules/linguist-languages/data/YAML.json"(e, n) {
          n.exports = { name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "CITATION.cff", "glide.lock", "yarn.lock"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407 };
        } }), xg = Z3({ "src/language-yaml/index.js"(e, n) {
          re2();
          var t = Bt(), s2 = Eg(), a3 = Fg(), r = Ag(), u = [t(Sg(), (i2) => ({ since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: [...i2.filenames.filter((o) => o !== "yarn.lock"), ".prettierrc", ".stylelintrc"] }))];
          n.exports = { languages: u, printers: { yaml: s2 }, options: a3, parsers: r };
        } }), bg = Z3({ "src/languages.js"(e, n) {
          re2(), n.exports = [id2(), Sd2(), Pd2(), Md2(), Ud2(), Dg2(), xg()];
        } });
        re2();
        var { version: Tg } = ya2(), kt2 = Sm2(), { getSupportInfo: Bg } = Mn2(), Ng = xm2(), wg = bg(), _g = Oe2();
        function bt2(e) {
          let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return function() {
            for (var t = arguments.length, s2 = new Array(t), a3 = 0; a3 < t; a3++)
              s2[a3] = arguments[a3];
            let r = s2[n] || {}, u = r.plugins || [];
            return s2[n] = Object.assign(Object.assign({}, r), {}, { plugins: [...wg, ...Array.isArray(u) ? u : Object.values(u)] }), e(...s2);
          };
        }
        var bn2 = bt2(kt2.formatWithCursor);
        Co2.exports = { formatWithCursor: bn2, format(e, n) {
          return bn2(e, n).formatted;
        }, check(e, n) {
          let { formatted: t } = bn2(e, n);
          return t === e;
        }, doc: _g, getSupportInfo: bt2(Bg, 0), version: Tg, util: Ng, __debug: { parse: bt2(kt2.parse), formatAST: bt2(kt2.formatAST), formatDoc: bt2(kt2.formatDoc), printToDoc: bt2(kt2.printToDoc), printDocToString: bt2(kt2.printDocToString) } };
      });
      return Pg();
    });
  })(standalone);
  return standalone.exports;
}
(function(module, exports) {
  !function(t, e) {
    e(exports, requireStandalone());
  }(commonjsGlobal, function(t, e) {
    function i2(t2) {
      return t2 && "object" == typeof t2 && "default" in t2 ? t2 : { default: t2 };
    }
    var n = i2(e);
    function s2(t2, e2) {
      var i3 = Object.keys(t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(t2);
        e2 && (n2 = n2.filter(function(e3) {
          return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function r(t2) {
      for (var e2 = 1; e2 < arguments.length; e2++) {
        var i3 = null != arguments[e2] ? arguments[e2] : {};
        e2 % 2 ? s2(Object(i3), true).forEach(function(e3) {
          h2(t2, e3, i3[e3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(i3)) : s2(Object(i3)).forEach(function(e3) {
          Object.defineProperty(t2, e3, Object.getOwnPropertyDescriptor(i3, e3));
        });
      }
      return t2;
    }
    function o() {
      /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
      /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
      o = function() {
        return t2;
      };
      var t2 = {}, e2 = Object.prototype, i3 = e2.hasOwnProperty, n2 = "function" == typeof Symbol ? Symbol : {}, s3 = n2.iterator || "@@iterator", r2 = n2.asyncIterator || "@@asyncIterator", a4 = n2.toStringTag || "@@toStringTag";
      function h3(t3, e3, i4) {
        return Object.defineProperty(t3, e3, { value: i4, enumerable: true, configurable: true, writable: true }), t3[e3];
      }
      try {
        h3({}, "");
      } catch (t3) {
        h3 = function(t4, e3, i4) {
          return t4[e3] = i4;
        };
      }
      function l2(t3, e3, i4, n3) {
        var s4 = e3 && e3.prototype instanceof _2 ? e3 : _2, r3 = Object.create(s4.prototype), o2 = new g3(n3 || []);
        return r3._invoke = function(t4, e4, i5) {
          var n4 = "suspendedStart";
          return function(s5, r4) {
            if ("executing" === n4)
              throw new Error("Generator is already running");
            if ("completed" === n4) {
              if ("throw" === s5)
                throw r4;
              return L2();
            }
            for (i5.method = s5, i5.arg = r4; ; ) {
              var o3 = i5.delegate;
              if (o3) {
                var a5 = y2(o3, i5);
                if (a5) {
                  if (a5 === u2)
                    continue;
                  return a5;
                }
              }
              if ("next" === i5.method)
                i5.sent = i5._sent = i5.arg;
              else if ("throw" === i5.method) {
                if ("suspendedStart" === n4)
                  throw n4 = "completed", i5.arg;
                i5.dispatchException(i5.arg);
              } else
                "return" === i5.method && i5.abrupt("return", i5.arg);
              n4 = "executing";
              var h4 = c2(t4, e4, i5);
              if ("normal" === h4.type) {
                if (n4 = i5.done ? "completed" : "suspendedYield", h4.arg === u2)
                  continue;
                return { value: h4.arg, done: i5.done };
              }
              "throw" === h4.type && (n4 = "completed", i5.method = "throw", i5.arg = h4.arg);
            }
          };
        }(t3, i4, o2), r3;
      }
      function c2(t3, e3, i4) {
        try {
          return { type: "normal", arg: t3.call(e3, i4) };
        } catch (t4) {
          return { type: "throw", arg: t4 };
        }
      }
      t2.wrap = l2;
      var u2 = {};
      function _2() {
      }
      function d5() {
      }
      function p2() {
      }
      var f2 = {};
      h3(f2, s3, function() {
        return this;
      });
      var T3 = Object.getPrototypeOf, k3 = T3 && T3(T3(N2([])));
      k3 && k3 !== e2 && i3.call(k3, s3) && (f2 = k3);
      var E2 = p2.prototype = _2.prototype = Object.create(f2);
      function m3(t3) {
        ["next", "throw", "return"].forEach(function(e3) {
          h3(t3, e3, function(t4) {
            return this._invoke(e3, t4);
          });
        });
      }
      function x3(t3, e3) {
        function n3(s5, r3, o2, a5) {
          var h4 = c2(t3[s5], t3, r3);
          if ("throw" !== h4.type) {
            var l3 = h4.arg, u3 = l3.value;
            return u3 && "object" == typeof u3 && i3.call(u3, "__await") ? e3.resolve(u3.__await).then(function(t4) {
              n3("next", t4, o2, a5);
            }, function(t4) {
              n3("throw", t4, o2, a5);
            }) : e3.resolve(u3).then(function(t4) {
              l3.value = t4, o2(l3);
            }, function(t4) {
              return n3("throw", t4, o2, a5);
            });
          }
          a5(h4.arg);
        }
        var s4;
        this._invoke = function(t4, i4) {
          function r3() {
            return new e3(function(e4, s5) {
              n3(t4, i4, e4, s5);
            });
          }
          return s4 = s4 ? s4.then(r3, r3) : r3();
        };
      }
      function y2(t3, e3) {
        var i4 = t3.iterator[e3.method];
        if (void 0 === i4) {
          if (e3.delegate = null, "throw" === e3.method) {
            if (t3.iterator.return && (e3.method = "return", e3.arg = void 0, y2(t3, e3), "throw" === e3.method))
              return u2;
            e3.method = "throw", e3.arg = new TypeError("The iterator does not provide a 'throw' method");
          }
          return u2;
        }
        var n3 = c2(i4, t3.iterator, e3.arg);
        if ("throw" === n3.type)
          return e3.method = "throw", e3.arg = n3.arg, e3.delegate = null, u2;
        var s4 = n3.arg;
        return s4 ? s4.done ? (e3[t3.resultName] = s4.value, e3.next = t3.nextLoc, "return" !== e3.method && (e3.method = "next", e3.arg = void 0), e3.delegate = null, u2) : s4 : (e3.method = "throw", e3.arg = new TypeError("iterator result is not an object"), e3.delegate = null, u2);
      }
      function v2(t3) {
        var e3 = { tryLoc: t3[0] };
        1 in t3 && (e3.catchLoc = t3[1]), 2 in t3 && (e3.finallyLoc = t3[2], e3.afterLoc = t3[3]), this.tryEntries.push(e3);
      }
      function A3(t3) {
        var e3 = t3.completion || {};
        e3.type = "normal", delete e3.arg, t3.completion = e3;
      }
      function g3(t3) {
        this.tryEntries = [{ tryLoc: "root" }], t3.forEach(v2, this), this.reset(true);
      }
      function N2(t3) {
        if (t3) {
          var e3 = t3[s3];
          if (e3)
            return e3.call(t3);
          if ("function" == typeof t3.next)
            return t3;
          if (!isNaN(t3.length)) {
            var n3 = -1, r3 = function e4() {
              for (; ++n3 < t3.length; )
                if (i3.call(t3, n3))
                  return e4.value = t3[n3], e4.done = false, e4;
              return e4.value = void 0, e4.done = true, e4;
            };
            return r3.next = r3;
          }
        }
        return { next: L2 };
      }
      function L2() {
        return { value: void 0, done: true };
      }
      return d5.prototype = p2, h3(E2, "constructor", p2), h3(p2, "constructor", d5), d5.displayName = h3(p2, a4, "GeneratorFunction"), t2.isGeneratorFunction = function(t3) {
        var e3 = "function" == typeof t3 && t3.constructor;
        return !!e3 && (e3 === d5 || "GeneratorFunction" === (e3.displayName || e3.name));
      }, t2.mark = function(t3) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t3, p2) : (t3.__proto__ = p2, h3(t3, a4, "GeneratorFunction")), t3.prototype = Object.create(E2), t3;
      }, t2.awrap = function(t3) {
        return { __await: t3 };
      }, m3(x3.prototype), h3(x3.prototype, r2, function() {
        return this;
      }), t2.AsyncIterator = x3, t2.async = function(e3, i4, n3, s4, r3) {
        void 0 === r3 && (r3 = Promise);
        var o2 = new x3(l2(e3, i4, n3, s4), r3);
        return t2.isGeneratorFunction(i4) ? o2 : o2.next().then(function(t3) {
          return t3.done ? t3.value : o2.next();
        });
      }, m3(E2), h3(E2, a4, "Generator"), h3(E2, s3, function() {
        return this;
      }), h3(E2, "toString", function() {
        return "[object Generator]";
      }), t2.keys = function(t3) {
        var e3 = [];
        for (var i4 in t3)
          e3.push(i4);
        return e3.reverse(), function i5() {
          for (; e3.length; ) {
            var n3 = e3.pop();
            if (n3 in t3)
              return i5.value = n3, i5.done = false, i5;
          }
          return i5.done = true, i5;
        };
      }, t2.values = N2, g3.prototype = { constructor: g3, reset: function(t3) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(A3), !t3)
          for (var e3 in this)
            "t" === e3.charAt(0) && i3.call(this, e3) && !isNaN(+e3.slice(1)) && (this[e3] = void 0);
      }, stop: function() {
        this.done = true;
        var t3 = this.tryEntries[0].completion;
        if ("throw" === t3.type)
          throw t3.arg;
        return this.rval;
      }, dispatchException: function(t3) {
        if (this.done)
          throw t3;
        var e3 = this;
        function n3(i4, n4) {
          return o2.type = "throw", o2.arg = t3, e3.next = i4, n4 && (e3.method = "next", e3.arg = void 0), !!n4;
        }
        for (var s4 = this.tryEntries.length - 1; s4 >= 0; --s4) {
          var r3 = this.tryEntries[s4], o2 = r3.completion;
          if ("root" === r3.tryLoc)
            return n3("end");
          if (r3.tryLoc <= this.prev) {
            var a5 = i3.call(r3, "catchLoc"), h4 = i3.call(r3, "finallyLoc");
            if (a5 && h4) {
              if (this.prev < r3.catchLoc)
                return n3(r3.catchLoc, true);
              if (this.prev < r3.finallyLoc)
                return n3(r3.finallyLoc);
            } else if (a5) {
              if (this.prev < r3.catchLoc)
                return n3(r3.catchLoc, true);
            } else {
              if (!h4)
                throw new Error("try statement without catch or finally");
              if (this.prev < r3.finallyLoc)
                return n3(r3.finallyLoc);
            }
          }
        }
      }, abrupt: function(t3, e3) {
        for (var n3 = this.tryEntries.length - 1; n3 >= 0; --n3) {
          var s4 = this.tryEntries[n3];
          if (s4.tryLoc <= this.prev && i3.call(s4, "finallyLoc") && this.prev < s4.finallyLoc) {
            var r3 = s4;
            break;
          }
        }
        r3 && ("break" === t3 || "continue" === t3) && r3.tryLoc <= e3 && e3 <= r3.finallyLoc && (r3 = null);
        var o2 = r3 ? r3.completion : {};
        return o2.type = t3, o2.arg = e3, r3 ? (this.method = "next", this.next = r3.finallyLoc, u2) : this.complete(o2);
      }, complete: function(t3, e3) {
        if ("throw" === t3.type)
          throw t3.arg;
        return "break" === t3.type || "continue" === t3.type ? this.next = t3.arg : "return" === t3.type ? (this.rval = this.arg = t3.arg, this.method = "return", this.next = "end") : "normal" === t3.type && e3 && (this.next = e3), u2;
      }, finish: function(t3) {
        for (var e3 = this.tryEntries.length - 1; e3 >= 0; --e3) {
          var i4 = this.tryEntries[e3];
          if (i4.finallyLoc === t3)
            return this.complete(i4.completion, i4.afterLoc), A3(i4), u2;
        }
      }, catch: function(t3) {
        for (var e3 = this.tryEntries.length - 1; e3 >= 0; --e3) {
          var i4 = this.tryEntries[e3];
          if (i4.tryLoc === t3) {
            var n3 = i4.completion;
            if ("throw" === n3.type) {
              var s4 = n3.arg;
              A3(i4);
            }
            return s4;
          }
        }
        throw new Error("illegal catch attempt");
      }, delegateYield: function(t3, e3, i4) {
        return this.delegate = { iterator: N2(t3), resultName: e3, nextLoc: i4 }, "next" === this.method && (this.arg = void 0), u2;
      } }, t2;
    }
    function a3(t2) {
      return a3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
        return typeof t3;
      } : function(t3) {
        return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
      }, a3(t2);
    }
    function h2(t2, e2, i3) {
      return e2 in t2 ? Object.defineProperty(t2, e2, { value: i3, enumerable: true, configurable: true, writable: true }) : t2[e2] = i3, t2;
    }
    function l(t2, e2) {
      return function(t3) {
        if (Array.isArray(t3))
          return t3;
      }(t2) || function(t3, e3) {
        var i3 = null == t3 ? null : "undefined" != typeof Symbol && t3[Symbol.iterator] || t3["@@iterator"];
        if (null == i3)
          return;
        var n2, s3, r2 = [], o2 = true, a4 = false;
        try {
          for (i3 = i3.call(t3); !(o2 = (n2 = i3.next()).done) && (r2.push(n2.value), !e3 || r2.length !== e3); o2 = true)
            ;
        } catch (t4) {
          a4 = true, s3 = t4;
        } finally {
          try {
            o2 || null == i3.return || i3.return();
          } finally {
            if (a4)
              throw s3;
          }
        }
        return r2;
      }(t2, e2) || u(t2, e2) || function() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }();
    }
    function c(t2) {
      return function(t3) {
        if (Array.isArray(t3))
          return _(t3);
      }(t2) || function(t3) {
        if ("undefined" != typeof Symbol && null != t3[Symbol.iterator] || null != t3["@@iterator"])
          return Array.from(t3);
      }(t2) || u(t2) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }();
    }
    function u(t2, e2) {
      if (t2) {
        if ("string" == typeof t2)
          return _(t2, e2);
        var i3 = Object.prototype.toString.call(t2).slice(8, -1);
        return "Object" === i3 && t2.constructor && (i3 = t2.constructor.name), "Map" === i3 || "Set" === i3 ? Array.from(t2) : "Arguments" === i3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i3) ? _(t2, e2) : void 0;
      }
    }
    function _(t2, e2) {
      (null == e2 || e2 > t2.length) && (e2 = t2.length);
      for (var i3 = 0, n2 = new Array(e2); i3 < e2; i3++)
        n2[i3] = t2[i3];
      return n2;
    }
    function d4(t2, e2) {
      var i3 = "undefined" != typeof Symbol && t2[Symbol.iterator] || t2["@@iterator"];
      if (!i3) {
        if (Array.isArray(t2) || (i3 = u(t2)) || e2 && t2 && "number" == typeof t2.length) {
          i3 && (t2 = i3);
          var n2 = 0, s3 = function() {
          };
          return { s: s3, n: function() {
            return n2 >= t2.length ? { done: true } : { done: false, value: t2[n2++] };
          }, e: function(t3) {
            throw t3;
          }, f: s3 };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var r2, o2 = true, a4 = false;
      return { s: function() {
        i3 = i3.call(t2);
      }, n: function() {
        var t3 = i3.next();
        return o2 = t3.done, t3;
      }, e: function(t3) {
        a4 = true, r2 = t3;
      }, f: function() {
        try {
          o2 || null == i3.return || i3.return();
        } finally {
          if (a4)
            throw r2;
        }
      } };
    }
    var p = { attributeIndex: 0, attributeListDepth: {}, matchST_ATTRIBUTE: function() {
      var t2 = this.input();
      if (this.is_WHITESPACE()) {
        do {
          t2 = this.input();
        } while (this.is_WHITESPACE());
        return this.unput(1), null;
      }
      switch (t2) {
        case "]":
          return 0 === this.attributeListDepth[this.attributeIndex] ? (delete this.attributeListDepth[this.attributeIndex], this.attributeIndex--, this.popState()) : this.attributeListDepth[this.attributeIndex]--, "]";
        case "(":
        case ")":
        case ":":
        case "=":
        case "|":
        case "&":
        case "^":
        case "-":
        case "+":
        case "*":
        case "%":
        case "~":
        case "<":
        case ">":
        case "!":
          return this.consume_TOKEN();
        case "[":
          return this.attributeListDepth[this.attributeIndex]++, "[";
        case ",":
          return ",";
        case '"':
          return this.ST_DOUBLE_QUOTES();
        case "'":
          return this.T_CONSTANT_ENCAPSED_STRING();
        case "/":
          return "/" === this._input[this.offset] ? this.T_COMMENT() : "*" === this._input[this.offset] ? (this.input(), this.T_DOC_COMMENT()) : this.consume_TOKEN();
      }
      if (this.is_LABEL_START() || "\\" === t2) {
        for (; this.offset < this.size; ) {
          var e2 = this.input();
          if (!this.is_LABEL() && "\\" !== e2) {
            e2 && this.unput(1);
            break;
          }
        }
        return this.T_STRING();
      }
      if (this.is_NUM())
        return this.consume_NUM();
      throw new Error('Bad terminal sequence "'.concat(t2, '" at line ').concat(this.yylineno, " (offset ").concat(this.offset, ")"));
    } };
    p.attributeIndex, p.attributeListDepth, p.matchST_ATTRIBUTE;
    var f = { T_COMMENT: function() {
      for (; this.offset < this.size; ) {
        var t2 = this.input();
        if ("\n" === t2 || "\r" === t2)
          return this.tok.T_COMMENT;
        if ("?" === t2 && !this.aspTagMode && ">" === this._input[this.offset])
          return this.unput(1), this.tok.T_COMMENT;
        if ("%" === t2 && this.aspTagMode && ">" === this._input[this.offset])
          return this.unput(1), this.tok.T_COMMENT;
      }
      return this.tok.T_COMMENT;
    }, T_DOC_COMMENT: function() {
      var t2 = this.input(), e2 = this.tok.T_COMMENT;
      if ("*" === t2) {
        if (t2 = this.input(), this.is_WHITESPACE() && (e2 = this.tok.T_DOC_COMMENT), "/" === t2)
          return e2;
        this.unput(1);
      }
      for (; this.offset < this.size; )
        if ("*" === (t2 = this.input()) && "/" === this._input[this.offset]) {
          this.input();
          break;
        }
      return e2;
    } };
    f.T_COMMENT, f.T_DOC_COMMENT;
    var T2 = { nextINITIAL: function() {
      return this.conditionStack.length > 1 && "INITIAL" === this.conditionStack[this.conditionStack.length - 1] ? this.popState() : this.begin("ST_IN_SCRIPTING"), this;
    }, matchINITIAL: function() {
      for (; this.offset < this.size; ) {
        var t2 = this.input();
        if ("<" == t2) {
          if ("?" == (t2 = this.ahead(1))) {
            if (this.tryMatch("?=")) {
              this.unput(1).appendToken(this.tok.T_OPEN_TAG_WITH_ECHO, 3).nextINITIAL();
              break;
            }
            if (this.tryMatchCaseless("?php") && (" " === (t2 = this._input[this.offset + 4]) || "	" === t2 || "\n" === t2 || "\r" === t2)) {
              this.unput(1).appendToken(this.tok.T_OPEN_TAG, 6).nextINITIAL();
              break;
            }
            if (this.short_tags) {
              this.unput(1).appendToken(this.tok.T_OPEN_TAG, 2).nextINITIAL();
              break;
            }
          } else if (this.asp_tags && "%" == t2) {
            if (this.tryMatch("%=")) {
              this.aspTagMode = true, this.unput(1).appendToken(this.tok.T_OPEN_TAG_WITH_ECHO, 3).nextINITIAL();
              break;
            }
            this.aspTagMode = true, this.unput(1).appendToken(this.tok.T_OPEN_TAG, 2).nextINITIAL();
            break;
          }
        }
      }
      return this.yytext.length > 0 && this.tok.T_INLINE_HTML;
    } };
    T2.nextINITIAL, T2.matchINITIAL;
    var k2 = { consume_NUM: function() {
      var t2 = this.yytext[0], e2 = "." === t2;
      if ("0" === t2)
        if ("x" === (t2 = this.input()) || "X" === t2) {
          if ("_" !== (t2 = this.input()) && this.is_HEX())
            return this.consume_HNUM();
          this.unput(t2 ? 2 : 1);
        } else if ("b" === t2 || "B" === t2) {
          if ("_" !== (t2 = this.input()) && "0" === t2 || "1" === t2)
            return this.consume_BNUM();
          this.unput(t2 ? 2 : 1);
        } else if ("o" === t2 || "O" === t2) {
          if ("_" !== (t2 = this.input()) && this.is_OCTAL())
            return this.consume_ONUM();
          this.unput(t2 ? 2 : 1);
        } else
          this.is_NUM() || t2 && this.unput(1);
      for (; this.offset < this.size; ) {
        var i3 = t2;
        if ("_" === (t2 = this.input())) {
          if ("_" === i3) {
            this.unput(2);
            break;
          }
          if ("." === i3) {
            this.unput(1);
            break;
          }
          if ("e" === i3 || "E" === i3) {
            this.unput(2);
            break;
          }
        } else {
          if ("." === t2) {
            if (e2) {
              this.unput(1);
              break;
            }
            if ("_" === i3) {
              this.unput(2);
              break;
            }
            e2 = true;
            continue;
          }
          if ("e" === t2 || "E" === t2) {
            if ("_" === i3) {
              this.unput(1);
              break;
            }
            var n2 = 2;
            if ("+" !== (t2 = this.input()) && "-" !== t2 || (n2 = 3, t2 = this.input()), this.is_NUM_START())
              return this.consume_LNUM(), this.tok.T_DNUMBER;
            this.unput(t2 ? n2 : n2 - 1);
            break;
          }
        }
        if (!this.is_NUM()) {
          t2 && this.unput(1);
          break;
        }
      }
      return e2 ? this.tok.T_DNUMBER : this.yytext.length < 9 || this.yytext.length < 10 || 10 == this.yytext.length && this.yytext < "2147483648" ? this.tok.T_LNUMBER : this.tok.T_DNUMBER;
    }, consume_HNUM: function() {
      for (; this.offset < this.size; ) {
        var t2 = this.input();
        if (!this.is_HEX()) {
          t2 && this.unput(1);
          break;
        }
      }
      return this.tok.T_LNUMBER;
    }, consume_LNUM: function() {
      for (; this.offset < this.size; ) {
        var t2 = this.input();
        if (!this.is_NUM()) {
          t2 && this.unput(1);
          break;
        }
      }
      return this.tok.T_LNUMBER;
    }, consume_BNUM: function() {
      for (var t2; this.offset < this.size; )
        if ("0" !== (t2 = this.input()) && "1" !== t2 && "_" !== t2) {
          t2 && this.unput(1);
          break;
        }
      return this.tok.T_LNUMBER;
    }, consume_ONUM: function() {
      for (; this.offset < this.size; ) {
        var t2 = this.input();
        if (!this.is_OCTAL()) {
          t2 && this.unput(1);
          break;
        }
      }
      return this.tok.T_LNUMBER;
    } };
    k2.consume_NUM, k2.consume_HNUM, k2.consume_LNUM, k2.consume_BNUM, k2.consume_ONUM;
    var E = { matchST_LOOKING_FOR_PROPERTY: function() {
      var t2 = this.input();
      if ("-" === t2) {
        if (">" === (t2 = this.input()))
          return this.tok.T_OBJECT_OPERATOR;
        t2 && this.unput(1);
      } else {
        if (this.is_WHITESPACE())
          return this.tok.T_WHITESPACE;
        if (this.is_LABEL_START())
          return this.consume_LABEL(), this.popState(), this.tok.T_STRING;
      }
      return this.popState(), t2 && this.unput(1), false;
    }, matchST_LOOKING_FOR_VARNAME: function() {
      var t2 = this.input();
      if (this.popState(), this.begin("ST_IN_SCRIPTING"), this.is_LABEL_START()) {
        if (this.consume_LABEL(), "[" === (t2 = this.input()) || "}" === t2)
          return this.unput(1), this.tok.T_STRING_VARNAME;
        this.unput(this.yytext.length);
      } else
        t2 && this.unput(1);
      return false;
    }, matchST_VAR_OFFSET: function() {
      var t2 = this.input();
      if (this.is_NUM_START())
        return this.consume_NUM(), this.tok.T_NUM_STRING;
      if ("]" === t2)
        return this.popState(), "]";
      if ("$" === t2) {
        if (this.input(), this.is_LABEL_START())
          return this.consume_LABEL(), this.tok.T_VARIABLE;
        throw new Error("Unexpected terminal");
      }
      if (this.is_LABEL_START())
        return this.consume_LABEL(), this.tok.T_STRING;
      if (this.is_WHITESPACE() || "\\" === t2 || "'" === t2 || "#" === t2)
        return this.tok.T_ENCAPSED_AND_WHITESPACE;
      if ("[" === t2 || "{" === t2 || "}" === t2 || '"' === t2 || "`" === t2 || this.is_TOKEN())
        return t2;
      throw new Error("Unexpected terminal");
    } };
    E.matchST_LOOKING_FOR_PROPERTY, E.matchST_LOOKING_FOR_VARNAME, E.matchST_VAR_OFFSET;
    var m2 = { matchST_IN_SCRIPTING: function() {
      var t2 = this.input();
      switch (t2) {
        case " ":
        case "	":
        case "\n":
        case "\r":
        case "\r\n":
          return this.T_WHITESPACE();
        case "#":
          return this.version >= 800 && "[" === this._input[this.offset] ? (this.input(), this.attributeListDepth[++this.attributeIndex] = 0, this.begin("ST_ATTRIBUTE"), this.tok.T_ATTRIBUTE) : this.T_COMMENT();
        case "/":
          return "/" === this._input[this.offset] ? this.T_COMMENT() : "*" === this._input[this.offset] ? (this.input(), this.T_DOC_COMMENT()) : this.consume_TOKEN();
        case "'":
          return this.T_CONSTANT_ENCAPSED_STRING();
        case '"':
          return this.ST_DOUBLE_QUOTES();
        case "`":
          return this.begin("ST_BACKQUOTE"), "`";
        case "?":
          if (!this.aspTagMode && this.tryMatch(">")) {
            this.input();
            var e2 = this._input[this.offset];
            return "\n" !== e2 && "\r" !== e2 || this.input(), this.conditionStack.length > 1 && this.begin("INITIAL"), this.tok.T_CLOSE_TAG;
          }
          return this.consume_TOKEN();
        case "%":
          return this.aspTagMode && ">" === this._input[this.offset] ? (this.input(), "\n" !== (t2 = this._input[this.offset]) && "\r" !== t2 || this.input(), this.aspTagMode = false, this.conditionStack.length > 1 && this.begin("INITIAL"), this.tok.T_CLOSE_TAG) : this.consume_TOKEN();
        case "{":
          return this.begin("ST_IN_SCRIPTING"), "{";
        case "}":
          return this.conditionStack.length > 2 && this.popState(), "}";
        default:
          if ("." === t2) {
            if (t2 = this.input(), this.is_NUM_START())
              return this.consume_NUM();
            t2 && this.unput(1);
          }
          if (this.is_NUM_START())
            return this.consume_NUM();
          if (this.is_LABEL_START())
            return this.consume_LABEL().T_STRING();
          if (this.is_TOKEN())
            return this.consume_TOKEN();
      }
      throw new Error('Bad terminal sequence "' + t2 + '" at line ' + this.yylineno + " (offset " + this.offset + ")");
    }, T_WHITESPACE: function() {
      for (; this.offset < this.size; ) {
        var t2 = this.input();
        if (" " !== t2 && "	" !== t2 && "\n" !== t2 && "\r" !== t2) {
          t2 && this.unput(1);
          break;
        }
      }
      return this.tok.T_WHITESPACE;
    } };
    m2.matchST_IN_SCRIPTING, m2.T_WHITESPACE;
    var x2 = ["\n", "\r"], y = ["\n", "\r", ";"], v = y.concat(["	", " ", ",", "]", ")", "/", "=", "!"]), A2 = { T_CONSTANT_ENCAPSED_STRING: function() {
      for (var t2; this.offset < this.size; )
        if ("\\" == (t2 = this.input()))
          this.input();
        else if ("'" == t2)
          break;
      return this.tok.T_CONSTANT_ENCAPSED_STRING;
    }, is_HEREDOC: function() {
      var t2 = this.offset;
      if ("<" === this._input[this.offset - 1] && "<" === this._input[this.offset] && "<" === this._input[this.offset + 1]) {
        if (this.offset += 3, this.is_TABSPACE())
          for (; this.offset < this.size && (this.offset++, this.is_TABSPACE()); )
            ;
        var e2 = this._input[this.offset - 1];
        if ("'" === e2 || '"' === e2 ? this.offset++ : e2 = null, this.is_LABEL_START()) {
          for (var i3 = this.offset - 1; this.offset < this.size && (this.offset++, this.is_LABEL()); )
            ;
          var n2 = this._input.substring(i3, this.offset - 1);
          if ((!e2 || e2 === this._input[this.offset - 1]) && (e2 && this.offset++, x2.includes(this._input[this.offset - 1])))
            return this.heredoc_label.label = n2, this.heredoc_label.length = n2.length, this.heredoc_label.finished = false, i3 = this.offset - t2, this.offset = t2, this.consume(i3), "'" === e2 ? this.begin("ST_NOWDOC") : this.begin("ST_HEREDOC"), this.prematch_ENDOFDOC(), this.tok.T_START_HEREDOC;
        }
      }
      return this.offset = t2, false;
    }, ST_DOUBLE_QUOTES: function() {
      for (var t2; this.offset < this.size; )
        if ("\\" == (t2 = this.input()))
          this.input();
        else {
          if ('"' == t2)
            break;
          if ("$" == t2) {
            if ("{" == (t2 = this.input()) || this.is_LABEL_START()) {
              this.unput(2);
              break;
            }
            t2 && this.unput(1);
          } else if ("{" == t2) {
            if ("$" == (t2 = this.input())) {
              this.unput(2);
              break;
            }
            t2 && this.unput(1);
          }
        }
      if ('"' == t2)
        return this.tok.T_CONSTANT_ENCAPSED_STRING;
      var e2 = 1;
      return "b" !== this.yytext[0] && "B" !== this.yytext[0] || (e2 = 2), this.yytext.length > 2 && this.appendToken(this.tok.T_ENCAPSED_AND_WHITESPACE, this.yytext.length - e2), this.unput(this.yytext.length - e2), this.begin("ST_DOUBLE_QUOTES"), this.yytext;
    }, isDOC_MATCH: function(t2, e2) {
      var i3 = this._input[t2 - 2];
      if (!x2.includes(i3))
        return false;
      var n2 = false, s3 = false, r2 = 0, o2 = this._input[t2 - 1];
      if (this.version >= 703) {
        for (; "	" === o2 || " " === o2; )
          " " === o2 ? n2 = true : "	" === o2 && (s3 = true), o2 = this._input[t2 + r2], r2++;
        if (t2 += r2, x2.includes(this._input[t2 - 1]))
          return false;
      }
      if (this._input.substring(t2 - 1, t2 - 1 + this.heredoc_label.length) === this.heredoc_label.label) {
        var a4 = this._input[t2 - 1 + this.heredoc_label.length];
        if ((this.version >= 703 ? v : y).includes(a4)) {
          if (e2) {
            if (this.consume(r2), n2 && s3)
              throw new Error("Parse error:  mixing spaces and tabs in ending marker at line " + this.yylineno + " (offset " + this.offset + ")");
          } else
            this.heredoc_label.indentation = r2, this.heredoc_label.indentation_uses_spaces = n2, this.heredoc_label.first_encaps_node = true;
          return true;
        }
      }
      return false;
    }, prematch_ENDOFDOC: function() {
      this.heredoc_label.indentation_uses_spaces = false, this.heredoc_label.indentation = 0, this.heredoc_label.first_encaps_node = true;
      for (var t2 = this.offset + 1; t2 < this._input.length; ) {
        if (this.isDOC_MATCH(t2, false))
          return;
        if (!x2.includes(this._input[t2 - 1]))
          for (; !x2.includes(this._input[t2++]) && t2 < this._input.length; )
            ;
        t2++;
      }
    }, matchST_NOWDOC: function() {
      if (this.isDOC_MATCH(this.offset, true))
        return this.consume(this.heredoc_label.length), this.popState(), this.tok.T_END_HEREDOC;
      for (var t2 = this._input[this.offset - 1]; this.offset < this.size; )
        if (x2.includes(t2)) {
          if (t2 = this.input(), this.isDOC_MATCH(this.offset, true))
            return this.unput(1).popState(), this.appendToken(this.tok.T_END_HEREDOC, this.heredoc_label.length), this.tok.T_ENCAPSED_AND_WHITESPACE;
        } else
          t2 = this.input();
      return this.tok.T_ENCAPSED_AND_WHITESPACE;
    }, matchST_HEREDOC: function() {
      var t2 = this.input();
      if (this.isDOC_MATCH(this.offset, true))
        return this.consume(this.heredoc_label.length - 1), this.popState(), this.tok.T_END_HEREDOC;
      for (; this.offset < this.size; )
        if ("\\" === t2 && (t2 = this.input(), x2.includes(t2) || (t2 = this.input())), x2.includes(t2)) {
          if (t2 = this.input(), this.isDOC_MATCH(this.offset, true))
            return this.unput(1).popState(), this.appendToken(this.tok.T_END_HEREDOC, this.heredoc_label.length), this.tok.T_ENCAPSED_AND_WHITESPACE;
        } else if ("$" === t2) {
          if ("{" === (t2 = this.input()))
            return this.begin("ST_LOOKING_FOR_VARNAME"), this.yytext.length > 2 ? (this.appendToken(this.tok.T_DOLLAR_OPEN_CURLY_BRACES, 2), this.unput(2), this.tok.T_ENCAPSED_AND_WHITESPACE) : this.tok.T_DOLLAR_OPEN_CURLY_BRACES;
          if (this.is_LABEL_START()) {
            var e2 = this.offset, i3 = this.consume_VARIABLE();
            return this.yytext.length > this.offset - e2 + 2 ? (this.appendToken(i3, this.offset - e2 + 2), this.unput(this.offset - e2 + 2), this.tok.T_ENCAPSED_AND_WHITESPACE) : i3;
          }
        } else if ("{" === t2) {
          if ("$" === (t2 = this.input()))
            return this.begin("ST_IN_SCRIPTING"), this.yytext.length > 2 ? (this.appendToken(this.tok.T_CURLY_OPEN, 1), this.unput(2), this.tok.T_ENCAPSED_AND_WHITESPACE) : (this.unput(1), this.tok.T_CURLY_OPEN);
        } else
          t2 = this.input();
      return this.tok.T_ENCAPSED_AND_WHITESPACE;
    }, consume_VARIABLE: function() {
      this.consume_LABEL();
      var t2 = this.input();
      if ("[" == t2)
        return this.unput(1), this.begin("ST_VAR_OFFSET"), this.tok.T_VARIABLE;
      if ("-" === t2) {
        if (">" === this.input())
          return this.input(), this.is_LABEL_START() && this.begin("ST_LOOKING_FOR_PROPERTY"), this.unput(3), this.tok.T_VARIABLE;
        this.unput(2);
      } else
        t2 && this.unput(1);
      return this.tok.T_VARIABLE;
    }, matchST_BACKQUOTE: function() {
      var t2 = this.input();
      if ("$" === t2) {
        if ("{" === (t2 = this.input()))
          return this.begin("ST_LOOKING_FOR_VARNAME"), this.tok.T_DOLLAR_OPEN_CURLY_BRACES;
        if (this.is_LABEL_START())
          return this.consume_VARIABLE();
      } else if ("{" === t2) {
        if ("$" === this._input[this.offset])
          return this.begin("ST_IN_SCRIPTING"), this.tok.T_CURLY_OPEN;
      } else if ("`" === t2)
        return this.popState(), "`";
      for (; this.offset < this.size; ) {
        if ("\\" === t2)
          this.input();
        else {
          if ("`" === t2) {
            this.unput(1), this.popState(), this.appendToken("`", 1);
            break;
          }
          if ("$" === t2) {
            if ("{" === (t2 = this.input()))
              return this.begin("ST_LOOKING_FOR_VARNAME"), this.yytext.length > 2 ? (this.appendToken(this.tok.T_DOLLAR_OPEN_CURLY_BRACES, 2), this.unput(2), this.tok.T_ENCAPSED_AND_WHITESPACE) : this.tok.T_DOLLAR_OPEN_CURLY_BRACES;
            if (this.is_LABEL_START()) {
              var e2 = this.offset, i3 = this.consume_VARIABLE();
              return this.yytext.length > this.offset - e2 + 2 ? (this.appendToken(i3, this.offset - e2 + 2), this.unput(this.offset - e2 + 2), this.tok.T_ENCAPSED_AND_WHITESPACE) : i3;
            }
            continue;
          }
          if ("{" === t2) {
            if ("$" === (t2 = this.input()))
              return this.begin("ST_IN_SCRIPTING"), this.yytext.length > 2 ? (this.appendToken(this.tok.T_CURLY_OPEN, 1), this.unput(2), this.tok.T_ENCAPSED_AND_WHITESPACE) : (this.unput(1), this.tok.T_CURLY_OPEN);
            continue;
          }
        }
        t2 = this.input();
      }
      return this.tok.T_ENCAPSED_AND_WHITESPACE;
    }, matchST_DOUBLE_QUOTES: function() {
      var t2 = this.input();
      if ("$" === t2) {
        if ("{" === (t2 = this.input()))
          return this.begin("ST_LOOKING_FOR_VARNAME"), this.tok.T_DOLLAR_OPEN_CURLY_BRACES;
        if (this.is_LABEL_START())
          return this.consume_VARIABLE();
      } else if ("{" === t2) {
        if ("$" === this._input[this.offset])
          return this.begin("ST_IN_SCRIPTING"), this.tok.T_CURLY_OPEN;
      } else if ('"' === t2)
        return this.popState(), '"';
      for (; this.offset < this.size; ) {
        if ("\\" === t2)
          this.input();
        else {
          if ('"' === t2) {
            this.unput(1), this.popState(), this.appendToken('"', 1);
            break;
          }
          if ("$" === t2) {
            if ("{" === (t2 = this.input()))
              return this.begin("ST_LOOKING_FOR_VARNAME"), this.yytext.length > 2 ? (this.appendToken(this.tok.T_DOLLAR_OPEN_CURLY_BRACES, 2), this.unput(2), this.tok.T_ENCAPSED_AND_WHITESPACE) : this.tok.T_DOLLAR_OPEN_CURLY_BRACES;
            if (this.is_LABEL_START()) {
              var e2 = this.offset, i3 = this.consume_VARIABLE();
              return this.yytext.length > this.offset - e2 + 2 ? (this.appendToken(i3, this.offset - e2 + 2), this.unput(this.offset - e2 + 2), this.tok.T_ENCAPSED_AND_WHITESPACE) : i3;
            }
            t2 && this.unput(1);
          } else if ("{" === t2) {
            if ("$" === (t2 = this.input()))
              return this.begin("ST_IN_SCRIPTING"), this.yytext.length > 2 ? (this.appendToken(this.tok.T_CURLY_OPEN, 1), this.unput(2), this.tok.T_ENCAPSED_AND_WHITESPACE) : (this.unput(1), this.tok.T_CURLY_OPEN);
            t2 && this.unput(1);
          }
        }
        t2 = this.input();
      }
      return this.tok.T_ENCAPSED_AND_WHITESPACE;
    } };
    A2.T_CONSTANT_ENCAPSED_STRING, A2.is_HEREDOC, A2.ST_DOUBLE_QUOTES, A2.isDOC_MATCH, A2.prematch_ENDOFDOC, A2.matchST_NOWDOC, A2.matchST_HEREDOC, A2.consume_VARIABLE, A2.matchST_BACKQUOTE, A2.matchST_DOUBLE_QUOTES;
    var g2 = { T_STRING: function() {
      var t2 = this.yytext.toLowerCase(), e2 = this.keywords[t2];
      if ("number" != typeof e2) {
        if ("yield" === t2)
          this.version >= 700 && this.tryMatch(" from") ? (this.consume(5), e2 = this.tok.T_YIELD_FROM) : e2 = this.tok.T_YIELD;
        else if (e2 = this.tok.T_STRING, "b" === t2 || "B" === t2) {
          var i3 = this.input();
          if ('"' === i3)
            return this.ST_DOUBLE_QUOTES();
          if ("'" === i3)
            return this.T_CONSTANT_ENCAPSED_STRING();
          i3 && this.unput(1);
        }
      }
      if (e2 === this.tok.T_ENUM) {
        if (this.version < 801)
          return this.tok.T_STRING;
        for (var n2 = this.offset, s3 = this.input(); " " == s3; )
          s3 = this.input();
        var r2 = false;
        if (this.is_LABEL_START()) {
          for (; this.is_LABEL(); )
            s3 += this.input();
          var o2 = s3.slice(0, -1).toLowerCase();
          r2 = "extends" !== o2 && "implements" !== o2;
        }
        return this.unput(this.offset - n2), r2 ? this.tok.T_ENUM : this.tok.T_STRING;
      }
      if (this.offset < this.size && e2 !== this.tok.T_YIELD_FROM) {
        var a4 = this.input();
        if ("\\" === a4) {
          e2 = "namespace" === t2 ? this.tok.T_NAME_RELATIVE : this.tok.T_NAME_QUALIFIED;
          do {
            if ("{" === this._input[this.offset]) {
              this.input();
              break;
            }
            this.consume_LABEL(), a4 = this.input();
          } while ("\\" === a4);
        }
        a4 && this.unput(1);
      }
      return e2;
    }, consume_TOKEN: function() {
      var t2 = this._input[this.offset - 1], e2 = this.tokenTerminals[t2];
      return e2 ? e2.apply(this, []) : this.yytext;
    }, tokenTerminals: { $: function() {
      return this.offset++, this.is_LABEL_START() ? (this.offset--, this.consume_LABEL(), this.tok.T_VARIABLE) : (this.offset--, "$");
    }, "-": function() {
      var t2 = this._input[this.offset];
      return ">" === t2 ? (this.begin("ST_LOOKING_FOR_PROPERTY").input(), this.tok.T_OBJECT_OPERATOR) : "-" === t2 ? (this.input(), this.tok.T_DEC) : "=" === t2 ? (this.input(), this.tok.T_MINUS_EQUAL) : "-";
    }, "\\": function() {
      if (this.offset < this.size) {
        if (this.input(), this.is_LABEL_START()) {
          var t2;
          do {
            if ("{" === this._input[this.offset]) {
              this.input();
              break;
            }
            this.consume_LABEL(), t2 = this.input();
          } while ("\\" === t2);
          return this.unput(1), this.tok.T_NAME_FULLY_QUALIFIED;
        }
        this.unput(1);
      }
      return this.tok.T_NS_SEPARATOR;
    }, "/": function() {
      return "=" === this._input[this.offset] ? (this.input(), this.tok.T_DIV_EQUAL) : "/";
    }, ":": function() {
      return ":" === this._input[this.offset] ? (this.input(), this.tok.T_DOUBLE_COLON) : ":";
    }, "(": function() {
      var t2 = this.offset;
      if (this.input(), this.is_TABSPACE() && this.consume_TABSPACE().input(), this.is_LABEL_START()) {
        var e2 = this.yytext.length;
        this.consume_LABEL();
        var i3 = this.yytext.substring(e2 - 1).toLowerCase(), n2 = this.castKeywords[i3];
        if ("number" == typeof n2 && (this.input(), this.is_TABSPACE() && this.consume_TABSPACE().input(), ")" === this._input[this.offset - 1]))
          return n2;
      }
      return this.unput(this.offset - t2), "(";
    }, "=": function() {
      var t2 = this._input[this.offset];
      return ">" === t2 ? (this.input(), this.tok.T_DOUBLE_ARROW) : "=" === t2 ? "=" === this._input[this.offset + 1] ? (this.consume(2), this.tok.T_IS_IDENTICAL) : (this.input(), this.tok.T_IS_EQUAL) : "=";
    }, "+": function() {
      var t2 = this._input[this.offset];
      return "+" === t2 ? (this.input(), this.tok.T_INC) : "=" === t2 ? (this.input(), this.tok.T_PLUS_EQUAL) : "+";
    }, "!": function() {
      return "=" === this._input[this.offset] ? "=" === this._input[this.offset + 1] ? (this.consume(2), this.tok.T_IS_NOT_IDENTICAL) : (this.input(), this.tok.T_IS_NOT_EQUAL) : "!";
    }, "?": function() {
      return this.version >= 700 && "?" === this._input[this.offset] ? this.version >= 704 && "=" === this._input[this.offset + 1] ? (this.consume(2), this.tok.T_COALESCE_EQUAL) : (this.input(), this.tok.T_COALESCE) : this.version >= 800 && "-" === this._input[this.offset] && ">" === this._input[this.offset + 1] ? (this.consume(2), this.tok.T_NULLSAFE_OBJECT_OPERATOR) : "?";
    }, "<": function() {
      var t2 = this._input[this.offset];
      return "<" === t2 ? "=" === (t2 = this._input[this.offset + 1]) ? (this.consume(2), this.tok.T_SL_EQUAL) : "<" === t2 && this.is_HEREDOC() ? this.tok.T_START_HEREDOC : (this.input(), this.tok.T_SL) : "=" === t2 ? (this.input(), this.version >= 700 && ">" === this._input[this.offset] ? (this.input(), this.tok.T_SPACESHIP) : this.tok.T_IS_SMALLER_OR_EQUAL) : ">" === t2 ? (this.input(), this.tok.T_IS_NOT_EQUAL) : "<";
    }, ">": function() {
      var t2 = this._input[this.offset];
      return "=" === t2 ? (this.input(), this.tok.T_IS_GREATER_OR_EQUAL) : ">" === t2 ? "=" === (t2 = this._input[this.offset + 1]) ? (this.consume(2), this.tok.T_SR_EQUAL) : (this.input(), this.tok.T_SR) : ">";
    }, "*": function() {
      var t2 = this._input[this.offset];
      return "=" === t2 ? (this.input(), this.tok.T_MUL_EQUAL) : "*" === t2 ? (this.input(), "=" === this._input[this.offset] ? (this.input(), this.tok.T_POW_EQUAL) : this.tok.T_POW) : "*";
    }, ".": function() {
      var t2 = this._input[this.offset];
      return "=" === t2 ? (this.input(), this.tok.T_CONCAT_EQUAL) : "." === t2 && "." === this._input[this.offset + 1] ? (this.consume(2), this.tok.T_ELLIPSIS) : ".";
    }, "%": function() {
      return "=" === this._input[this.offset] ? (this.input(), this.tok.T_MOD_EQUAL) : "%";
    }, "&": function() {
      var t2 = this._input[this.offset];
      return "=" === t2 ? (this.input(), this.tok.T_AND_EQUAL) : "&" === t2 ? (this.input(), this.tok.T_BOOLEAN_AND) : "&";
    }, "|": function() {
      var t2 = this._input[this.offset];
      return "=" === t2 ? (this.input(), this.tok.T_OR_EQUAL) : "|" === t2 ? (this.input(), this.tok.T_BOOLEAN_OR) : "|";
    }, "^": function() {
      return "=" === this._input[this.offset] ? (this.input(), this.tok.T_XOR_EQUAL) : "^";
    } } };
    g2.T_STRING, g2.consume_TOKEN, g2.tokenTerminals;
    var N = { is_NUM: function() {
      var t2 = this._input.charCodeAt(this.offset - 1);
      return t2 > 47 && t2 < 58 || 95 === t2;
    }, is_NUM_START: function() {
      var t2 = this._input.charCodeAt(this.offset - 1);
      return t2 > 47 && t2 < 58;
    }, is_LABEL: function() {
      var t2 = this._input.charCodeAt(this.offset - 1);
      return t2 > 96 && t2 < 123 || t2 > 64 && t2 < 91 || 95 === t2 || t2 > 47 && t2 < 58 || t2 > 126;
    }, is_LABEL_START: function() {
      var t2 = this._input.charCodeAt(this.offset - 1);
      return t2 > 64 && t2 < 91 || (t2 > 96 && t2 < 123 || (95 === t2 || t2 > 126));
    }, consume_LABEL: function() {
      for (; this.offset < this.size; ) {
        var t2 = this.input();
        if (!this.is_LABEL()) {
          t2 && this.unput(1);
          break;
        }
      }
      return this;
    }, is_TOKEN: function() {
      var t2 = this._input[this.offset - 1];
      return -1 !== ";:,.\\[]()|^&+-/*=%!~$<>?@".indexOf(t2);
    }, is_WHITESPACE: function() {
      var t2 = this._input[this.offset - 1];
      return " " === t2 || "	" === t2 || "\n" === t2 || "\r" === t2;
    }, is_TABSPACE: function() {
      var t2 = this._input[this.offset - 1];
      return " " === t2 || "	" === t2;
    }, consume_TABSPACE: function() {
      for (; this.offset < this.size; ) {
        var t2 = this.input();
        if (!this.is_TABSPACE()) {
          t2 && this.unput(1);
          break;
        }
      }
      return this;
    }, is_HEX: function() {
      var t2 = this._input.charCodeAt(this.offset - 1);
      return t2 > 47 && t2 < 58 || (t2 > 64 && t2 < 71 || (t2 > 96 && t2 < 103 || 95 === t2));
    }, is_OCTAL: function() {
      var t2 = this._input.charCodeAt(this.offset - 1);
      return t2 > 47 && t2 < 56 || 95 === t2;
    } };
    N.is_NUM, N.is_NUM_START, N.is_LABEL, N.is_LABEL_START, N.consume_LABEL, N.is_TOKEN, N.is_WHITESPACE, N.is_TABSPACE, N.consume_TABSPACE, N.is_HEX, N.is_OCTAL;
    var L = function(t2) {
      this.engine = t2, this.tok = this.engine.tokens.names, this.EOF = 1, this.debug = false, this.all_tokens = true, this.comment_tokens = false, this.mode_eval = false, this.asp_tags = false, this.short_tags = false, this.version = 801, this.yyprevcol = 0, this.keywords = { __class__: this.tok.T_CLASS_C, __trait__: this.tok.T_TRAIT_C, __function__: this.tok.T_FUNC_C, __method__: this.tok.T_METHOD_C, __line__: this.tok.T_LINE, __file__: this.tok.T_FILE, __dir__: this.tok.T_DIR, __namespace__: this.tok.T_NS_C, exit: this.tok.T_EXIT, die: this.tok.T_EXIT, function: this.tok.T_FUNCTION, const: this.tok.T_CONST, return: this.tok.T_RETURN, try: this.tok.T_TRY, catch: this.tok.T_CATCH, finally: this.tok.T_FINALLY, throw: this.tok.T_THROW, if: this.tok.T_IF, elseif: this.tok.T_ELSEIF, endif: this.tok.T_ENDIF, else: this.tok.T_ELSE, while: this.tok.T_WHILE, endwhile: this.tok.T_ENDWHILE, do: this.tok.T_DO, for: this.tok.T_FOR, endfor: this.tok.T_ENDFOR, foreach: this.tok.T_FOREACH, endforeach: this.tok.T_ENDFOREACH, declare: this.tok.T_DECLARE, enddeclare: this.tok.T_ENDDECLARE, instanceof: this.tok.T_INSTANCEOF, as: this.tok.T_AS, switch: this.tok.T_SWITCH, endswitch: this.tok.T_ENDSWITCH, case: this.tok.T_CASE, default: this.tok.T_DEFAULT, break: this.tok.T_BREAK, continue: this.tok.T_CONTINUE, goto: this.tok.T_GOTO, echo: this.tok.T_ECHO, print: this.tok.T_PRINT, class: this.tok.T_CLASS, interface: this.tok.T_INTERFACE, trait: this.tok.T_TRAIT, enum: this.tok.T_ENUM, extends: this.tok.T_EXTENDS, implements: this.tok.T_IMPLEMENTS, new: this.tok.T_NEW, clone: this.tok.T_CLONE, var: this.tok.T_VAR, eval: this.tok.T_EVAL, include: this.tok.T_INCLUDE, include_once: this.tok.T_INCLUDE_ONCE, require: this.tok.T_REQUIRE, require_once: this.tok.T_REQUIRE_ONCE, namespace: this.tok.T_NAMESPACE, use: this.tok.T_USE, insteadof: this.tok.T_INSTEADOF, global: this.tok.T_GLOBAL, isset: this.tok.T_ISSET, empty: this.tok.T_EMPTY, __halt_compiler: this.tok.T_HALT_COMPILER, static: this.tok.T_STATIC, abstract: this.tok.T_ABSTRACT, final: this.tok.T_FINAL, private: this.tok.T_PRIVATE, protected: this.tok.T_PROTECTED, public: this.tok.T_PUBLIC, unset: this.tok.T_UNSET, list: this.tok.T_LIST, array: this.tok.T_ARRAY, callable: this.tok.T_CALLABLE, or: this.tok.T_LOGICAL_OR, and: this.tok.T_LOGICAL_AND, xor: this.tok.T_LOGICAL_XOR, match: this.tok.T_MATCH, readonly: this.tok.T_READ_ONLY }, this.castKeywords = { int: this.tok.T_INT_CAST, integer: this.tok.T_INT_CAST, real: this.tok.T_DOUBLE_CAST, double: this.tok.T_DOUBLE_CAST, float: this.tok.T_DOUBLE_CAST, string: this.tok.T_STRING_CAST, binary: this.tok.T_STRING_CAST, array: this.tok.T_ARRAY_CAST, object: this.tok.T_OBJECT_CAST, bool: this.tok.T_BOOL_CAST, boolean: this.tok.T_BOOL_CAST, unset: this.tok.T_UNSET_CAST };
    };
    L.prototype.setInput = function(t2) {
      return this._input = t2, this.size = t2.length, this.yylineno = 1, this.offset = 0, this.yyprevcol = 0, this.yytext = "", this.yylloc = { first_offset: 0, first_line: 1, first_column: 0, prev_offset: 0, prev_line: 1, prev_column: 0, last_line: 1, last_column: 0 }, this.tokens = [], this.version > 703 ? this.keywords.fn = this.tok.T_FN : delete this.keywords.fn, this.done = this.offset >= this.size, !this.all_tokens && this.mode_eval ? (this.conditionStack = ["INITIAL"], this.begin("ST_IN_SCRIPTING")) : (this.conditionStack = [], this.begin("INITIAL")), this.heredoc_label = { label: "", length: 0, indentation: 0, indentation_uses_spaces: false, finished: false, first_encaps_node: false, toString: function() {
        this.label;
      } }, this;
    }, L.prototype.input = function() {
      var t2 = this._input[this.offset];
      return t2 ? (this.yytext += t2, this.offset++, "\r" === t2 && "\n" === this._input[this.offset] && (this.yytext += "\n", this.offset++), "\n" === t2 || "\r" === t2 ? (this.yylloc.last_line = ++this.yylineno, this.yyprevcol = this.yylloc.last_column, this.yylloc.last_column = 0) : this.yylloc.last_column++, t2) : "";
    }, L.prototype.unput = function(t2) {
      if (1 === t2)
        this.offset--, "\n" === this._input[this.offset] && "\r" === this._input[this.offset - 1] && (this.offset--, t2++), "\r" === this._input[this.offset] || "\n" === this._input[this.offset] ? (this.yylloc.last_line--, this.yylineno--, this.yylloc.last_column = this.yyprevcol) : this.yylloc.last_column--, this.yytext = this.yytext.substring(0, this.yytext.length - t2);
      else if (t2 > 0)
        if (this.offset -= t2, t2 < this.yytext.length) {
          this.yytext = this.yytext.substring(0, this.yytext.length - t2), this.yylloc.last_line = this.yylloc.first_line, this.yylloc.last_column = this.yyprevcol = this.yylloc.first_column;
          for (var e2 = 0; e2 < this.yytext.length; e2++) {
            var i3 = this.yytext[e2];
            "\r" === i3 ? (i3 = this.yytext[++e2], this.yyprevcol = this.yylloc.last_column, this.yylloc.last_line++, this.yylloc.last_column = 0, "\n" !== i3 && ("\r" === i3 ? this.yylloc.last_line++ : this.yylloc.last_column++)) : "\n" === i3 ? (this.yyprevcol = this.yylloc.last_column, this.yylloc.last_line++, this.yylloc.last_column = 0) : this.yylloc.last_column++;
          }
          this.yylineno = this.yylloc.last_line;
        } else
          this.yytext = "", this.yylloc.last_line = this.yylineno = this.yylloc.first_line, this.yylloc.last_column = this.yylloc.first_column;
      return this;
    }, L.prototype.tryMatch = function(t2) {
      return t2 === this.ahead(t2.length);
    }, L.prototype.tryMatchCaseless = function(t2) {
      return t2 === this.ahead(t2.length).toLowerCase();
    }, L.prototype.ahead = function(t2) {
      var e2 = this._input.substring(this.offset, this.offset + t2);
      return "\r" === e2[e2.length - 1] && "\n" === this._input[this.offset + t2 + 1] && (e2 += "\n"), e2;
    }, L.prototype.consume = function(t2) {
      for (var e2 = 0; e2 < t2; e2++) {
        var i3 = this._input[this.offset];
        if (!i3)
          break;
        this.yytext += i3, this.offset++, "\r" === i3 && "\n" === this._input[this.offset] && (this.yytext += "\n", this.offset++, e2++), "\n" === i3 || "\r" === i3 ? (this.yylloc.last_line = ++this.yylineno, this.yyprevcol = this.yylloc.last_column, this.yylloc.last_column = 0) : this.yylloc.last_column++;
      }
      return this;
    }, L.prototype.getState = function() {
      return { yytext: this.yytext, offset: this.offset, yylineno: this.yylineno, yyprevcol: this.yyprevcol, yylloc: { first_offset: this.yylloc.first_offset, first_line: this.yylloc.first_line, first_column: this.yylloc.first_column, last_line: this.yylloc.last_line, last_column: this.yylloc.last_column }, heredoc_label: this.heredoc_label };
    }, L.prototype.setState = function(t2) {
      return this.yytext = t2.yytext, this.offset = t2.offset, this.yylineno = t2.yylineno, this.yyprevcol = t2.yyprevcol, this.yylloc = t2.yylloc, t2.heredoc_label && (this.heredoc_label = t2.heredoc_label), this;
    }, L.prototype.appendToken = function(t2, e2) {
      return this.tokens.push([t2, e2]), this;
    }, L.prototype.lex = function() {
      this.yylloc.prev_offset = this.offset, this.yylloc.prev_line = this.yylloc.last_line, this.yylloc.prev_column = this.yylloc.last_column;
      var t2 = this.next() || this.lex();
      if (!this.all_tokens) {
        for (; t2 === this.tok.T_WHITESPACE || !this.comment_tokens && (t2 === this.tok.T_COMMENT || t2 === this.tok.T_DOC_COMMENT) || t2 === this.tok.T_OPEN_TAG; )
          t2 = this.next() || this.lex();
        if (t2 == this.tok.T_OPEN_TAG_WITH_ECHO)
          return this.tok.T_ECHO;
        if (t2 === this.tok.T_CLOSE_TAG)
          return ";";
      }
      return this.yylloc.prev_offset || (this.yylloc.prev_offset = this.yylloc.first_offset, this.yylloc.prev_line = this.yylloc.first_line, this.yylloc.prev_column = this.yylloc.first_column), t2;
    }, L.prototype.begin = function(t2) {
      if (this.conditionStack.push(t2), this.curCondition = t2, this.stateCb = this["match" + t2], "function" != typeof this.stateCb)
        throw new Error('Undefined condition state "' + t2 + '"');
      return this;
    }, L.prototype.popState = function() {
      var t2 = this.conditionStack.length - 1 > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      if (this.curCondition = this.conditionStack[this.conditionStack.length - 1], this.stateCb = this["match" + this.curCondition], "function" != typeof this.stateCb)
        throw new Error('Undefined condition state "' + this.curCondition + '"');
      return t2;
    }, L.prototype.next = function() {
      var t2;
      if (this._input || (this.done = true), this.yylloc.first_offset = this.offset, this.yylloc.first_line = this.yylloc.last_line, this.yylloc.first_column = this.yylloc.last_column, this.yytext = "", this.done)
        return this.yylloc.prev_offset = this.yylloc.first_offset, this.yylloc.prev_line = this.yylloc.first_line, this.yylloc.prev_column = this.yylloc.first_column, this.EOF;
      if (this.tokens.length > 0 ? ("object" === a3((t2 = this.tokens.shift())[1]) ? this.setState(t2[1]) : this.consume(t2[1]), t2 = t2[0]) : t2 = this.stateCb.apply(this, []), this.offset >= this.size && 0 === this.tokens.length && (this.done = true), this.debug) {
        var e2 = t2;
        e2 = "number" == typeof e2 ? this.engine.tokens.values[e2] : '"' + e2 + '"';
        var i3 = new Error(e2 + "	from " + this.yylloc.first_line + "," + this.yylloc.first_column + "	 - to " + this.yylloc.last_line + "," + this.yylloc.last_column + '	"' + this.yytext + '"');
        console.error(i3.stack);
      }
      return t2;
    }, [p, f, T2, k2, E, m2, A2, g2, N].forEach(function(t2) {
      for (var e2 in t2)
        L.prototype[e2] = t2[e2];
    });
    var C2 = L, b2 = function(t2, e2, i3) {
      this.line = t2, this.column = e2, this.offset = i3;
    }, I2 = { read_array: function() {
      var t2 = null, e2 = false, i3 = this.node("array");
      this.token === this.tok.T_ARRAY ? (this.next().expect("("), t2 = ")") : (e2 = true, t2 = "]");
      var n2 = [];
      return this.next().token !== t2 && (n2 = this.read_array_pair_list(e2)), this.expect(t2), this.next(), i3(e2, n2);
    }, read_array_pair_list: function(t2) {
      var e2 = this;
      return this.read_list(function() {
        return e2.read_array_pair(t2);
      }, ",", true);
    }, read_array_pair: function(t2) {
      if (!(!t2 && ")" === this.token || t2 && "]" === this.token)) {
        if ("," === this.token)
          return this.node("noop")();
        var e2 = this.node("entry"), i3 = null, n2 = null, s3 = false, r2 = false;
        if ("&" === this.token)
          this.next(), s3 = true, n2 = this.read_variable(true, false);
        else if (this.token === this.tok.T_ELLIPSIS && this.version >= 704)
          this.next(), "&" === this.token && this.error(), r2 = true, n2 = this.read_expr();
        else {
          var o2 = this.read_expr();
          this.token === this.tok.T_DOUBLE_ARROW ? (this.next(), i3 = o2, "&" === this.token ? (this.next(), s3 = true, n2 = this.read_variable(true, false)) : n2 = this.read_expr()) : n2 = o2;
        }
        return e2(i3, n2, s3, r2);
      }
    } };
    I2.read_array, I2.read_array_pair_list, I2.read_array_pair;
    var S2 = { read_class_declaration_statement: function(t2) {
      var e2 = this.node("class"), i3 = this.read_class_modifiers();
      if (this.token !== this.tok.T_CLASS)
        return this.error(this.tok.T_CLASS), this.next(), null;
      this.next().expect(this.tok.T_STRING);
      var n2 = this.node("identifier"), s3 = this.text();
      this.next(), n2 = n2(s3);
      var r2 = this.read_extends_from(), o2 = this.read_implements_list();
      this.expect("{");
      var a4 = e2(n2, r2, o2, this.next().read_class_body(true, false), i3);
      return t2 && (a4.attrGroups = t2), a4;
    }, read_class_modifiers: function() {
      return [0, 0, this.read_class_modifier()];
    }, read_class_modifier: function() {
      return this.token === this.tok.T_ABSTRACT ? (this.next(), 1) : this.token === this.tok.T_FINAL ? (this.next(), 2) : 0;
    }, read_class_body: function(t2, e2) {
      for (var i3 = [], n2 = []; this.token !== this.EOF && "}" !== this.token; )
        if (this.token !== this.tok.T_COMMENT)
          if (this.token !== this.tok.T_DOC_COMMENT)
            if (this.token !== this.tok.T_USE)
              if (e2 && this.token === this.tok.T_CASE) {
                var s3 = this.read_enum_case();
                this.expect(";") && this.next(), i3 = i3.concat(s3);
              } else {
                this.token === this.tok.T_ATTRIBUTE && (n2 = this.read_attr_list());
                var r2 = this.position(), o2 = this.read_member_flags(false);
                if (this.token !== this.tok.T_CONST)
                  if (t2 && this.token === this.tok.T_VAR && (this.next().expect(this.tok.T_VARIABLE), o2[0] = null, o2[1] = 0), this.token === this.tok.T_FUNCTION)
                    i3.push(this.read_function(false, o2, n2, r2)), n2 = [];
                  else if (t2 && (this.token === this.tok.T_VARIABLE || this.version >= 801 && this.token === this.tok.T_READ_ONLY || this.version >= 704 && ("?" === this.token || this.token === this.tok.T_ARRAY || this.token === this.tok.T_CALLABLE || this.token === this.tok.T_NAMESPACE || this.token === this.tok.T_NAME_FULLY_QUALIFIED || this.token === this.tok.T_NAME_QUALIFIED || this.token === this.tok.T_NAME_RELATIVE || this.token === this.tok.T_NS_SEPARATOR || this.token === this.tok.T_STRING))) {
                    var a4 = this.read_variable_list(o2, n2);
                    n2 = [], this.expect(";"), this.next(), i3 = i3.concat(a4);
                  } else
                    this.error([this.tok.T_CONST].concat(c(t2 ? [this.tok.T_VARIABLE] : []), c(e2 ? [this.tok.T_CASE] : []), [this.tok.T_FUNCTION])), this.next();
                else {
                  var h3 = this.read_constant_list(o2, n2);
                  this.expect(";") && this.next(), i3 = i3.concat(h3);
                }
              }
            else
              i3 = i3.concat(this.read_trait_use_statement());
          else
            i3.push(this.read_doc_comment());
        else
          i3.push(this.read_comment());
      return this.expect("}"), this.next(), i3;
    }, read_variable_list: function(t2, e2) {
      var i3 = this.node("propertystatement"), n2 = this.read_list(function() {
        var t3 = this.node("property"), i4 = false;
        this.token === this.tok.T_READ_ONLY && (i4 = true, this.next());
        var n3 = l(this.read_optional_type(), 2), s3 = n3[0], r2 = n3[1];
        this.expect(this.tok.T_VARIABLE);
        var o2 = this.node("identifier"), a4 = this.text().substring(1);
        return this.next(), o2 = o2(a4), ";" === this.token || "," === this.token ? t3(o2, null, i4, s3, r2, e2 || []) : "=" === this.token ? t3(o2, this.next().read_expr(), i4, s3, r2, e2 || []) : (this.expect([",", ";", "="]), t3(o2, null, s3, r2, e2 || []));
      }, ",");
      return i3(null, n2, t2);
    }, read_constant_list: function(t2, e2) {
      this.expect(this.tok.T_CONST) && this.next();
      var i3 = this.node("classconstant"), n2 = this.read_list(function() {
        var t3 = this.node("constant"), e3 = null, i4 = null;
        if (this.token === this.tok.T_STRING || this.version >= 700 && this.is("IDENTIFIER")) {
          e3 = this.node("identifier");
          var n3 = this.text();
          this.next(), e3 = e3(n3);
        } else
          this.expect("IDENTIFIER");
        return this.expect("=") && (i4 = this.next().read_expr()), t3(e3, i4);
      }, ",");
      return i3(null, n2, t2, e2 || []);
    }, read_member_flags: function(t2) {
      var e2 = [-1, -1, -1];
      if (this.is("T_MEMBER_FLAGS")) {
        var i3 = 0, n2 = 0;
        do {
          switch (this.token) {
            case this.tok.T_PUBLIC:
              i3 = 0, n2 = 0;
              break;
            case this.tok.T_PROTECTED:
              i3 = 0, n2 = 1;
              break;
            case this.tok.T_PRIVATE:
              i3 = 0, n2 = 2;
              break;
            case this.tok.T_STATIC:
              i3 = 1, n2 = 1;
              break;
            case this.tok.T_ABSTRACT:
              i3 = 2, n2 = 1;
              break;
            case this.tok.T_FINAL:
              i3 = 2, n2 = 2;
          }
          t2 && (0 == i3 && 2 == n2 ? (this.expect([this.tok.T_PUBLIC, this.tok.T_PROTECTED]), n2 = -1) : 2 == i3 && 1 == n2 && (this.error(), n2 = -1)), -1 !== e2[i3] ? this.error() : -1 !== n2 && (e2[i3] = n2);
        } while (this.next().is("T_MEMBER_FLAGS"));
      }
      return -1 == e2[1] && (e2[1] = 0), -1 == e2[2] && (e2[2] = 0), e2;
    }, read_optional_type: function() {
      var t2 = false;
      "?" === this.token && (t2 = true, this.next());
      var e2 = this.read_types();
      if (t2 && !e2 && this.raiseError("Expecting a type definition combined with nullable operator"), !t2 && !e2)
        return [false, null];
      if ("|" === this.token) {
        e2 = [e2];
        do {
          this.next();
          var i3 = this.read_type();
          if (!i3) {
            this.raiseError("Expecting a type definition");
            break;
          }
          e2.push(i3);
        } while ("|" === this.token);
      }
      return [t2, e2];
    }, read_interface_declaration_statement: function(t2) {
      var e2 = this.node("interface");
      if (this.token !== this.tok.T_INTERFACE)
        return this.error(this.tok.T_INTERFACE), this.next(), null;
      this.next().expect(this.tok.T_STRING);
      var i3 = this.node("identifier"), n2 = this.text();
      this.next(), i3 = i3(n2);
      var s3 = this.read_interface_extends_list();
      return this.expect("{"), e2(i3, s3, this.next().read_interface_body(), t2 || []);
    }, read_interface_body: function() {
      for (var t2 = [], e2 = []; this.token !== this.EOF && "}" !== this.token; )
        if (this.token !== this.tok.T_COMMENT)
          if (this.token !== this.tok.T_DOC_COMMENT) {
            var i3 = this.position();
            e2 = this.read_attr_list();
            var n2 = this.read_member_flags(true);
            if (this.token == this.tok.T_CONST) {
              var s3 = this.read_constant_list(n2, e2);
              this.expect(";") && this.next(), t2 = t2.concat(s3), e2 = [];
            } else if (this.token === this.tok.T_FUNCTION) {
              var r2 = this.read_function_declaration(2, n2, e2, i3);
              r2.parseFlags(n2), t2.push(r2), this.expect(";") && this.next(), e2 = [];
            } else
              this.error([this.tok.T_CONST, this.tok.T_FUNCTION]), this.next();
          } else
            t2.push(this.read_doc_comment());
        else
          t2.push(this.read_comment());
      return this.expect("}") && this.next(), t2;
    }, read_trait_declaration_statement: function() {
      var t2 = this.node("trait");
      if (this.token !== this.tok.T_TRAIT)
        return this.error(this.tok.T_TRAIT), this.next(), null;
      this.next().expect(this.tok.T_STRING);
      var e2 = this.node("identifier"), i3 = this.text();
      return this.next(), e2 = e2(i3), this.expect("{"), t2(e2, this.next().read_class_body(true, false));
    }, read_trait_use_statement: function() {
      var t2 = this.node("traituse");
      this.expect(this.tok.T_USE) && this.next();
      for (var e2 = [this.read_namespace_name()], i3 = null; "," === this.token; )
        e2.push(this.next().read_namespace_name());
      if ("{" === this.token) {
        for (i3 = []; this.next().token !== this.EOF && "}" !== this.token; )
          i3.push(this.read_trait_use_alias()), this.expect(";");
        this.expect("}") && this.next();
      } else
        this.expect(";") && this.next();
      return t2(e2, i3);
    }, read_trait_use_alias: function() {
      var t2, e2 = this.node(), i3 = null;
      if (this.is("IDENTIFIER")) {
        t2 = this.node("identifier");
        var n2 = this.text();
        this.next(), t2 = t2(n2);
      } else if (t2 = this.read_namespace_name(), this.token === this.tok.T_DOUBLE_COLON)
        if (this.next(), this.token === this.tok.T_STRING || this.version >= 700 && this.is("IDENTIFIER")) {
          i3 = t2, t2 = this.node("identifier");
          var s3 = this.text();
          this.next(), t2 = t2(s3);
        } else
          this.expect(this.tok.T_STRING);
      else
        t2 = t2.name;
      if (this.token === this.tok.T_INSTEADOF)
        return e2("traitprecedence", i3, t2, this.next().read_name_list());
      if (this.token === this.tok.T_AS) {
        var r2 = null, o2 = null;
        if (this.next().is("T_MEMBER_FLAGS") && (r2 = this.read_member_flags()), this.token === this.tok.T_STRING || this.version >= 700 && this.is("IDENTIFIER")) {
          o2 = this.node("identifier");
          var a4 = this.text();
          this.next(), o2 = o2(a4);
        } else
          false === r2 && this.expect(this.tok.T_STRING);
        return e2("traitalias", i3, t2, o2, r2);
      }
      return this.expect([this.tok.T_AS, this.tok.T_INSTEADOF]), e2("traitalias", i3, t2, null, null);
    } };
    S2.read_class_declaration_statement, S2.read_class_modifiers, S2.read_class_modifier, S2.read_class_body, S2.read_variable_list, S2.read_constant_list, S2.read_member_flags, S2.read_optional_type, S2.read_interface_declaration_statement, S2.read_interface_body, S2.read_trait_declaration_statement, S2.read_trait_use_statement, S2.read_trait_use_alias;
    var O2 = { read_comment: function() {
      var t2 = this.text(), e2 = this.ast.prepare("/*" === t2.substring(0, 2) ? "commentblock" : "commentline", null, this), i3 = this.lexer.yylloc.first_offset, n2 = this.prev;
      return this.prev = [this.lexer.yylloc.last_line, this.lexer.yylloc.last_column, this.lexer.offset], this.lex(), (e2 = e2(t2)).offset = i3, this.prev = n2, e2;
    }, read_doc_comment: function() {
      var t2 = this.ast.prepare("commentblock", null, this), e2 = this.lexer.yylloc.first_offset, i3 = this.text(), n2 = this.prev;
      return this.prev = [this.lexer.yylloc.last_line, this.lexer.yylloc.last_column, this.lexer.offset], this.lex(), (t2 = t2(i3)).offset = e2, this.prev = n2, t2;
    } };
    O2.read_comment, O2.read_doc_comment;
    var R = { read_expr: function(t2) {
      var e2 = this.node();
      if ("@" === this.token)
        return t2 || (t2 = this.next().read_expr()), e2("silent", t2);
      if (t2 || (t2 = this.read_expr_item()), "|" === this.token)
        return e2("bin", "|", t2, this.next().read_expr());
      if ("&" === this.token)
        return e2("bin", "&", t2, this.next().read_expr());
      if ("^" === this.token)
        return e2("bin", "^", t2, this.next().read_expr());
      if ("." === this.token)
        return e2("bin", ".", t2, this.next().read_expr());
      if ("+" === this.token)
        return e2("bin", "+", t2, this.next().read_expr());
      if ("-" === this.token)
        return e2("bin", "-", t2, this.next().read_expr());
      if ("*" === this.token)
        return e2("bin", "*", t2, this.next().read_expr());
      if ("/" === this.token)
        return e2("bin", "/", t2, this.next().read_expr());
      if ("%" === this.token)
        return e2("bin", "%", t2, this.next().read_expr());
      if (this.token === this.tok.T_POW)
        return e2("bin", "**", t2, this.next().read_expr());
      if (this.token === this.tok.T_SL)
        return e2("bin", "<<", t2, this.next().read_expr());
      if (this.token === this.tok.T_SR)
        return e2("bin", ">>", t2, this.next().read_expr());
      if (this.token === this.tok.T_BOOLEAN_OR)
        return e2("bin", "||", t2, this.next().read_expr());
      if (this.token === this.tok.T_LOGICAL_OR)
        return e2("bin", "or", t2, this.next().read_expr());
      if (this.token === this.tok.T_BOOLEAN_AND)
        return e2("bin", "&&", t2, this.next().read_expr());
      if (this.token === this.tok.T_LOGICAL_AND)
        return e2("bin", "and", t2, this.next().read_expr());
      if (this.token === this.tok.T_LOGICAL_XOR)
        return e2("bin", "xor", t2, this.next().read_expr());
      if (this.token === this.tok.T_IS_IDENTICAL)
        return e2("bin", "===", t2, this.next().read_expr());
      if (this.token === this.tok.T_IS_NOT_IDENTICAL)
        return e2("bin", "!==", t2, this.next().read_expr());
      if (this.token === this.tok.T_IS_EQUAL)
        return e2("bin", "==", t2, this.next().read_expr());
      if (this.token === this.tok.T_IS_NOT_EQUAL)
        return e2("bin", "!=", t2, this.next().read_expr());
      if ("<" === this.token)
        return e2("bin", "<", t2, this.next().read_expr());
      if (">" === this.token)
        return e2("bin", ">", t2, this.next().read_expr());
      if (this.token === this.tok.T_IS_SMALLER_OR_EQUAL)
        return e2("bin", "<=", t2, this.next().read_expr());
      if (this.token === this.tok.T_IS_GREATER_OR_EQUAL)
        return e2("bin", ">=", t2, this.next().read_expr());
      if (this.token === this.tok.T_SPACESHIP)
        return e2("bin", "<=>", t2, this.next().read_expr());
      if (this.token === this.tok.T_INSTANCEOF && (t2 = e2("bin", "instanceof", t2, this.next().read_class_name_reference()), ";" !== this.token && this.token !== this.tok.T_INLINE_HTML && this.token !== this.EOF && (t2 = this.read_expr(t2))), this.token === this.tok.T_COALESCE)
        return e2("bin", "??", t2, this.next().read_expr());
      if ("?" === this.token) {
        var i3 = null;
        return ":" !== this.next().token && (i3 = this.read_expr()), this.expect(":") && this.next(), e2("retif", t2, i3, this.read_expr());
      }
      return e2.destroy(t2), t2;
    }, read_expr_cast: function(t2) {
      return this.node("cast")(t2, this.text(), this.next().read_expr());
    }, read_isset_variable: function() {
      return this.read_expr();
    }, read_isset_variables: function() {
      return this.read_function_list(this.read_isset_variable, ",");
    }, read_internal_functions_in_yacc: function() {
      var t2 = null;
      switch (this.token) {
        case this.tok.T_ISSET:
          t2 = this.node("isset"), this.next().expect("(") && this.next();
          var e2 = this.read_isset_variables();
          this.expect(")") && this.next(), t2 = t2(e2);
          break;
        case this.tok.T_EMPTY:
          t2 = this.node("empty"), this.next().expect("(") && this.next();
          var i3 = this.read_expr();
          this.expect(")") && this.next(), t2 = t2(i3);
          break;
        case this.tok.T_INCLUDE:
          t2 = this.node("include")(false, false, this.next().read_expr());
          break;
        case this.tok.T_INCLUDE_ONCE:
          t2 = this.node("include")(true, false, this.next().read_expr());
          break;
        case this.tok.T_EVAL:
          t2 = this.node("eval"), this.next().expect("(") && this.next();
          var n2 = this.read_expr();
          this.expect(")") && this.next(), t2 = t2(n2);
          break;
        case this.tok.T_REQUIRE:
          t2 = this.node("include")(false, true, this.next().read_expr());
          break;
        case this.tok.T_REQUIRE_ONCE:
          t2 = this.node("include")(true, true, this.next().read_expr());
      }
      return t2;
    }, read_optional_expr: function(t2) {
      return this.token !== t2 ? this.read_expr() : null;
    }, read_exit_expr: function() {
      var t2 = null;
      return "(" === this.token && (this.next(), t2 = this.read_optional_expr(")"), this.expect(")") && this.next()), t2;
    }, read_expr_item: function() {
      var t2, e2, i3 = [];
      if ("+" === this.token)
        return this.node("unary")("+", this.next().read_expr());
      if ("-" === this.token)
        return this.node("unary")("-", this.next().read_expr());
      if ("!" === this.token)
        return this.node("unary")("!", this.next().read_expr());
      if ("~" === this.token)
        return this.node("unary")("~", this.next().read_expr());
      if ("(" === this.token)
        return (e2 = this.next().read_expr()).parenthesizedExpression = true, this.expect(")") && this.next(), this.handleDereferencable(e2);
      if ("`" === this.token)
        return this.read_encapsed_string("`");
      if (this.token === this.tok.T_LIST) {
        var n2 = null, s3 = this.innerList;
        t2 = this.node("list"), s3 || (n2 = this.node("assign")), this.next().expect("(") && this.next(), this.innerList || (this.innerList = true);
        var r2 = this.read_array_pair_list(false);
        this.expect(")") && this.next();
        for (var o2 = false, a4 = 0; a4 < r2.length; a4++)
          if (null !== r2[a4] && "noop" !== r2[a4].kind) {
            o2 = true;
            break;
          }
        return o2 || this.raiseError("Fatal Error :  Cannot use empty list on line " + this.lexer.yylloc.first_line), s3 ? t2(r2, false) : (this.innerList = false, this.expect("=") ? n2(t2(r2, false), this.next().read_expr(), "=") : t2(r2, false));
      }
      if (this.token === this.tok.T_ATTRIBUTE && (i3 = this.read_attr_list()), this.token === this.tok.T_CLONE)
        return this.node("clone")(this.next().read_expr());
      switch (this.token) {
        case this.tok.T_INC:
          return this.node("pre")("+", this.next().read_variable(false, false));
        case this.tok.T_DEC:
          return this.node("pre")("-", this.next().read_variable(false, false));
        case this.tok.T_NEW:
          return this.read_new_expr();
        case this.tok.T_ISSET:
        case this.tok.T_EMPTY:
        case this.tok.T_INCLUDE:
        case this.tok.T_INCLUDE_ONCE:
        case this.tok.T_EVAL:
        case this.tok.T_REQUIRE:
        case this.tok.T_REQUIRE_ONCE:
          return this.read_internal_functions_in_yacc();
        case this.tok.T_MATCH:
          return this.read_match_expression();
        case this.tok.T_INT_CAST:
          return this.read_expr_cast("int");
        case this.tok.T_DOUBLE_CAST:
          return this.read_expr_cast("float");
        case this.tok.T_STRING_CAST:
          return this.read_expr_cast(-1 !== this.text().indexOf("binary") ? "binary" : "string");
        case this.tok.T_ARRAY_CAST:
          return this.read_expr_cast("array");
        case this.tok.T_OBJECT_CAST:
          return this.read_expr_cast("object");
        case this.tok.T_BOOL_CAST:
          return this.read_expr_cast("bool");
        case this.tok.T_UNSET_CAST:
          return this.read_expr_cast("unset");
        case this.tok.T_THROW:
          return this.version < 800 && this.raiseError("PHP 8+ is required to use throw as an expression"), this.node("throw")(this.next().read_expr());
        case this.tok.T_EXIT:
          var h3 = "die" === this.lexer.yytext.toLowerCase();
          return t2 = this.node("exit"), this.next(), t2(this.read_exit_expr(), h3);
        case this.tok.T_PRINT:
          return this.node("print")(this.next().read_expr());
        case this.tok.T_YIELD:
          var l2 = null, c2 = null;
          return t2 = this.node("yield"), this.next().is("EXPR") && (l2 = this.read_expr(), this.token === this.tok.T_DOUBLE_ARROW && (c2 = l2, l2 = this.next().read_expr())), t2(l2, c2);
        case this.tok.T_YIELD_FROM:
          return (t2 = this.node("yieldfrom"))(e2 = this.next().read_expr());
        case this.tok.T_FN:
        case this.tok.T_FUNCTION:
          return this.read_inline_function(void 0, i3);
        case this.tok.T_STATIC:
          var u2 = [this.token, this.lexer.getState()];
          if (this.next(), this.token === this.tok.T_FUNCTION || this.version >= 704 && this.token === this.tok.T_FN)
            return this.read_inline_function([0, 1, 0], i3);
          this.lexer.tokens.push(u2), this.next();
      }
      if (this.is("VARIABLE")) {
        t2 = this.node();
        var _2 = "identifier" === (e2 = this.read_variable(false, false)).kind || "staticlookup" === e2.kind && "identifier" === e2.offset.kind;
        switch (this.token) {
          case "=":
            return _2 && this.error("VARIABLE"), "&" == this.next().token ? this.read_assignref(t2, e2) : t2("assign", e2, this.read_expr(), "=");
          case this.tok.T_PLUS_EQUAL:
            return _2 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "+=");
          case this.tok.T_MINUS_EQUAL:
            return _2 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "-=");
          case this.tok.T_MUL_EQUAL:
            return _2 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "*=");
          case this.tok.T_POW_EQUAL:
            return _2 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "**=");
          case this.tok.T_DIV_EQUAL:
            return _2 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "/=");
          case this.tok.T_CONCAT_EQUAL:
            return _2 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), ".=");
          case this.tok.T_MOD_EQUAL:
            return _2 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "%=");
          case this.tok.T_AND_EQUAL:
            return _2 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "&=");
          case this.tok.T_OR_EQUAL:
            return _2 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "|=");
          case this.tok.T_XOR_EQUAL:
            return _2 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "^=");
          case this.tok.T_SL_EQUAL:
            return _2 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "<<=");
          case this.tok.T_SR_EQUAL:
            return _2 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), ">>=");
          case this.tok.T_COALESCE_EQUAL:
            return _2 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "??=");
          case this.tok.T_INC:
            return _2 && this.error("VARIABLE"), this.next(), t2("post", "+", e2);
          case this.tok.T_DEC:
            return _2 && this.error("VARIABLE"), this.next(), t2("post", "-", e2);
          default:
            t2.destroy(e2);
        }
      } else {
        if (this.is("SCALAR")) {
          if (t2 = this.node(), "array" === (e2 = this.read_scalar()).kind && e2.shortForm && "=" === this.token) {
            var d5 = this.convertToList(e2);
            return e2.loc && (d5.loc = e2.loc), t2("assign", d5, this.next().read_expr(), "=");
          }
          return t2.destroy(e2), this.handleDereferencable(e2);
        }
        this.error("EXPR"), this.next();
      }
      return e2;
    }, convertToList: function(t2) {
      var e2 = this, i3 = t2.items.map(function(t3) {
        return t3.value && "array" === t3.value.kind && t3.value.shortForm && (t3.value = e2.convertToList(t3.value)), t3;
      }), n2 = this.node("list")(i3, true);
      return t2.loc && (n2.loc = t2.loc), t2.leadingComments && (n2.leadingComments = t2.leadingComments), t2.trailingComments && (n2.trailingComments = t2.trailingComments), n2;
    }, read_assignref: function(t2, e2) {
      var i3;
      return this.next(), this.token === this.tok.T_NEW ? (this.version >= 700 && this.error(), i3 = this.read_new_expr()) : i3 = this.read_variable(false, false), t2("assignref", e2, i3);
    }, read_inline_function: function(t2, e2) {
      if (this.token === this.tok.T_FUNCTION) {
        var i3 = this.read_function(true, t2, e2);
        return i3.attrGroups = e2, i3;
      }
      !this.version >= 704 && this.raiseError("Arrow Functions are not allowed");
      var n2 = this.node("arrowfunc");
      this.expect(this.tok.T_FN) && this.next();
      var s3 = this.is_reference();
      this.expect("(") && this.next();
      var r2 = this.read_parameter_list();
      this.expect(")") && this.next();
      var o2 = false, a4 = null;
      ":" === this.token && ("?" === this.next().token && (o2 = true, this.next()), a4 = this.read_types()), this.expect(this.tok.T_DOUBLE_ARROW) && this.next();
      var h3 = n2(r2, s3, this.read_expr(), a4, o2, !!t2);
      return h3.attrGroups = e2, h3;
    }, read_match_expression: function() {
      var t2 = this.node("match");
      this.expect(this.tok.T_MATCH) && this.next(), this.version < 800 && this.raiseError("Match statements are not allowed before PHP 8");
      var e2, i3;
      return this.expect("(") && this.next(), e2 = this.read_expr(), this.expect(")") && this.next(), this.expect("{") && this.next(), i3 = this.read_match_arms(), this.expect("}") && this.next(), t2(e2, i3);
    }, read_match_arms: function() {
      var t2 = this;
      return this.read_list(function() {
        return t2.read_match_arm();
      }, ",", true);
    }, read_match_arm: function() {
      if ("}" !== this.token)
        return this.node("matcharm")(this.read_match_arm_conds(), this.read_expr());
    }, read_match_arm_conds: function() {
      var t2 = [];
      if (this.token === this.tok.T_DEFAULT)
        t2 = null, this.next();
      else
        for (t2.push(this.read_expr()); "," === this.token; ) {
          if (this.next(), this.token === this.tok.T_DOUBLE_ARROW)
            return this.next(), t2;
          t2.push(this.read_expr());
        }
      return this.expect(this.tok.T_DOUBLE_ARROW) && this.next(), t2;
    }, read_attribute: function() {
      var t2 = this.text(), e2 = [];
      return this.next(), "(" === this.token && (e2 = this.read_argument_list()), this.node("attribute")(t2, e2);
    }, read_attr_list: function() {
      var t2 = [];
      if (this.token === this.tok.T_ATTRIBUTE)
        do {
          var e2 = this.node("attrgroup")([]);
          for (this.next(), e2.attrs.push(this.read_attribute()); "," === this.token; )
            this.next(), "]" !== this.token && e2.attrs.push(this.read_attribute());
          t2.push(e2), this.expect("]"), this.next();
        } while (this.token === this.tok.T_ATTRIBUTE);
      return t2;
    }, read_new_expr: function() {
      var t2 = this.node("new");
      this.expect(this.tok.T_NEW) && this.next();
      var e2 = [], i3 = this.read_attr_list();
      if (this.token === this.tok.T_CLASS) {
        var n2 = this.node("class");
        "(" === this.next().token && (e2 = this.read_argument_list());
        var s3 = this.read_extends_from(), r2 = this.read_implements_list(), o2 = null;
        this.expect("{") && (o2 = this.next().read_class_body(true, false));
        var a4 = n2(null, s3, r2, o2, [0, 0, 0]);
        return a4.attrGroups = i3, t2(a4, e2);
      }
      for (var h3 = this.read_new_class_name(); "[" === this.token; ) {
        var l2 = this.node("offsetlookup"), c2 = this.next().read_encaps_var_offset();
        this.expect("]") && this.next(), h3 = l2(h3, c2);
      }
      return "(" === this.token && (e2 = this.read_argument_list()), t2(h3, e2);
    }, read_new_class_name: function() {
      if (this.token === this.tok.T_NS_SEPARATOR || this.token === this.tok.T_NAME_RELATIVE || this.token === this.tok.T_NAME_QUALIFIED || this.token === this.tok.T_NAME_FULLY_QUALIFIED || this.token === this.tok.T_STRING || this.token === this.tok.T_NAMESPACE) {
        var t2 = this.read_namespace_name(true);
        return this.token === this.tok.T_DOUBLE_COLON && (t2 = this.read_static_getter(t2)), t2;
      }
      if (this.is("VARIABLE"))
        return this.read_variable(true, false);
      this.expect([this.tok.T_STRING, "VARIABLE"]);
    }, handleDereferencable: function(t2) {
      for (; this.token !== this.EOF; )
        if (this.token === this.tok.T_OBJECT_OPERATOR || this.token === this.tok.T_DOUBLE_COLON)
          t2 = this.recursive_variable_chain_scan(t2, false, false, true);
        else if (this.token === this.tok.T_CURLY_OPEN || "[" === this.token)
          t2 = this.read_dereferencable(t2);
        else {
          if ("(" !== this.token)
            return t2;
          t2 = this.node("call")(t2, this.read_argument_list());
        }
      return t2;
    } };
    R.read_expr, R.read_expr_cast, R.read_isset_variable, R.read_isset_variables, R.read_internal_functions_in_yacc, R.read_optional_expr, R.read_exit_expr, R.read_expr_item, R.convertToList, R.read_assignref, R.read_inline_function, R.read_match_expression, R.read_match_arms, R.read_match_arm, R.read_match_arm_conds, R.read_attribute, R.read_attr_list, R.read_new_expr, R.read_new_class_name, R.handleDereferencable;
    var w2 = { read_enum_declaration_statement: function(t2) {
      var e2 = this.node("enum");
      if (!this.expect(this.tok.T_ENUM))
        return null;
      this.next().expect(this.tok.T_STRING);
      var i3 = this.node("identifier"), n2 = this.text();
      this.next(), i3 = i3(n2);
      var s3 = this.read_enum_value_type(), r2 = this.read_implements_list();
      this.expect("{");
      var o2 = e2(i3, s3, r2, this.next().read_class_body(false, true));
      return t2 && (o2.attrGroups = t2), o2;
    }, read_enum_value_type: function() {
      return ":" === this.token ? this.next().read_namespace_name() : null;
    }, read_enum_case: function() {
      this.expect(this.tok.T_CASE);
      var t2 = this.node("enumcase"), e2 = this.node("identifier"), i3 = this.next().text();
      this.next(), e2 = e2(i3);
      var n2 = "=" === this.token ? this.next().read_expr() : null;
      return this.expect(";"), t2(e2, n2);
    } };
    w2.read_enum_declaration_statement, w2.read_enum_value_type, w2.read_enum_case;
    var D2 = { is_reference: function() {
      return "&" === this.token && (this.next(), true);
    }, is_variadic: function() {
      return this.token === this.tok.T_ELLIPSIS && (this.next(), true);
    }, read_function: function(t2, e2, i3, n2) {
      var s3 = this.read_function_declaration(t2 ? 1 : e2 ? 2 : 0, e2 && 1 === e2[1], i3 || [], n2);
      return e2 && 1 == e2[2] ? (s3.parseFlags(e2), this.expect(";") && this.next()) : (this.expect("{") && (s3.body = this.read_code_block(false), s3.loc && s3.body.loc && (s3.loc.end = s3.body.loc.end)), !t2 && e2 && s3.parseFlags(e2)), s3;
    }, read_function_declaration: function(t2, e2, i3, n2) {
      var s3 = this, r2 = "function";
      1 === t2 ? r2 = "closure" : 2 === t2 && (r2 = "method");
      var o2 = this.node(r2);
      this.expect(this.tok.T_FUNCTION) && this.next();
      var a4 = this.is_reference(), h3 = false, l2 = [], c2 = null, u2 = false;
      if (1 !== t2) {
        var _2 = this.node("identifier");
        2 === t2 ? this.version >= 700 ? this.token === this.tok.T_STRING || this.is("IDENTIFIER") ? (h3 = this.text(), this.next()) : this.version < 704 && this.error("IDENTIFIER") : this.token === this.tok.T_STRING ? (h3 = this.text(), this.next()) : this.error("IDENTIFIER") : this.version >= 700 ? this.token === this.tok.T_STRING ? (h3 = this.text(), this.next()) : this.version >= 704 ? this.expect("(") || this.next() : (this.error(this.tok.T_STRING), this.next()) : (this.expect(this.tok.T_STRING) && (h3 = this.text()), this.next()), h3 = _2(h3);
      }
      this.expect("(") && this.next();
      var d5 = this.read_parameter_list("__construct" === h3.name);
      this.expect(")") && this.next(), 1 === t2 && (l2 = this.read_lexical_vars()), ":" === this.token && ("?" === this.next().token && (u2 = true, this.next()), c2 = this.read_types());
      var p2 = function(t3) {
        return t3.attrGroups = i3 || [], n2 && t3.loc && (t3.loc.start = n2, t3.loc.source && (t3.loc.source = s3.lexer._input.substr(t3.loc.start.offset, t3.loc.end.offset - t3.loc.start.offset))), t3;
      };
      return p2(1 === t2 ? o2(d5, a4, l2, c2, u2, e2) : o2(h3, d5, a4, c2, u2));
    }, read_lexical_vars: function() {
      var t2 = [];
      return this.token === this.tok.T_USE && (this.next(), this.expect("(") && this.next(), t2 = this.read_lexical_var_list(), this.expect(")") && this.next()), t2;
    }, read_list_with_dangling_comma: function(t2) {
      for (var e2 = []; this.token != this.EOF; ) {
        if (e2.push(t2()), "," != this.token) {
          if (")" == this.token)
            break;
          this.error([",", ")"]);
          break;
        }
        if (this.next(), this.version >= 800 && ")" === this.token)
          return e2;
      }
      return e2;
    }, read_lexical_var_list: function() {
      return this.read_list_with_dangling_comma(this.read_lexical_var.bind(this));
    }, read_lexical_var: function() {
      if ("&" === this.token)
        return this.read_byref(this.read_lexical_var.bind(this));
      var t2 = this.node("variable");
      this.expect(this.tok.T_VARIABLE);
      var e2 = this.text().substring(1);
      return this.next(), t2(e2, false);
    }, read_parameter_list: function(t2) {
      if (")" !== this.token) {
        var e2 = false;
        return this.read_list_with_dangling_comma(function() {
          var i3 = this.read_parameter(t2);
          return i3 && (e2 && this.raiseError("Unexpected parameter after a variadic parameter"), i3.variadic && (e2 = true)), i3;
        }.bind(this), ",");
      }
      return [];
    }, read_parameter: function(t2) {
      var e2, i3 = this.node("parameter"), n2 = null, s3 = null, r2 = false, o2 = false, a4 = [];
      this.token === this.tok.T_ATTRIBUTE && (a4 = this.read_attr_list());
      var h3 = this.read_promoted();
      this.version >= 801 && this.token === this.tok.T_READ_ONLY && (t2 ? (this.next(), o2 = true) : this.raiseError("readonly properties can be used only on class constructor")), "?" === this.token && (this.next(), r2 = true), e2 = this.read_types(), r2 && !e2 && this.raiseError("Expecting a type definition combined with nullable operator");
      var l2 = this.is_reference(), c2 = this.is_variadic();
      if (this.expect(this.tok.T_VARIABLE)) {
        n2 = this.node("identifier");
        var u2 = this.text().substring(1);
        this.next(), n2 = n2(u2);
      }
      "=" == this.token && (s3 = this.next().read_expr());
      var _2 = i3(n2, e2, s3, l2, c2, o2, r2, h3);
      return a4 && (_2.attrGroups = a4), _2;
    }, read_types: function() {
      var t2 = "unset", e2 = "union", i3 = "intersection", n2 = [], s3 = t2, r2 = this.read_type();
      if (!r2)
        return null;
      for (n2.push(r2); "|" === this.token || this.version >= 801 && "&" === this.token; ) {
        var o2 = this.peek();
        if (o2 === this.tok.T_ELLIPSIS || o2 === this.tok.T_VARIABLE)
          break;
        s3 === t2 ? s3 = "|" === this.token ? e2 : i3 : (s3 === e2 && "|" !== this.token || s3 === i3 && "&" !== this.token) && this.raiseError('Unexpect token "' + this.token + '", "|" and "&" can not be mixed'), this.next(), n2.push(this.read_type());
      }
      return 1 === n2.length ? n2[0] : s3 === i3 ? this.node("intersectiontype")(n2) : this.node("uniontype")(n2);
    }, read_promoted: function() {
      return this.token === this.tok.T_PUBLIC ? (this.next(), 1) : this.token === this.tok.T_PROTECTED ? (this.next(), 2) : this.token === this.tok.T_PRIVATE ? (this.next(), 4) : 0;
    }, read_argument_list: function() {
      var t2 = [];
      return this.expect("(") && this.next(), this.version >= 801 && this.token === this.tok.T_ELLIPSIS && ")" === this.peek() ? (t2.push(this.node("variadicplaceholder")()), this.next()) : ")" !== this.token && (t2 = this.read_non_empty_argument_list()), this.expect(")") && this.next(), t2;
    }, read_non_empty_argument_list: function() {
      var t2 = false;
      return this.read_function_list(function() {
        var e2 = this.read_argument();
        if (e2) {
          var i3 = "variadic" === e2.kind;
          t2 && !i3 && this.raiseError("Unexpected non-variadic argument after a variadic argument"), i3 && (t2 = true);
        }
        return e2;
      }.bind(this), ",");
    }, read_argument: function() {
      if (this.token === this.tok.T_ELLIPSIS)
        return this.node("variadic")(this.next().read_expr());
      if ((this.token === this.tok.T_STRING || Object.values(this.lexer.keywords).includes(this.token)) && ":" === this.peek())
        return this.version < 800 && this.raiseError("PHP 8+ is required to use named arguments"), this.node("namedargument")(this.text(), this.next().next().read_expr());
      return this.read_expr();
    }, read_type: function() {
      var t2 = this.node();
      if (this.token === this.tok.T_ARRAY || this.token === this.tok.T_CALLABLE) {
        var e2 = this.text();
        return this.next(), t2("typereference", e2.toLowerCase(), e2);
      }
      if (this.token === this.tok.T_NAME_RELATIVE || this.token === this.tok.T_NAME_QUALIFIED || this.token === this.tok.T_NAME_FULLY_QUALIFIED || this.token === this.tok.T_STRING || this.token === this.tok.T_STATIC) {
        var i3 = this.text(), n2 = [this.token, this.lexer.getState()];
        return this.next(), this.token !== this.tok.T_NS_SEPARATOR && this.ast.typereference.types.indexOf(i3.toLowerCase()) > -1 ? t2("typereference", i3.toLowerCase(), i3) : (this.lexer.tokens.push(n2), this.next(), t2.destroy(), this.read_namespace_name());
      }
      return t2.destroy(), null;
    } };
    D2.is_reference, D2.is_variadic, D2.read_function, D2.read_function_declaration, D2.read_lexical_vars, D2.read_list_with_dangling_comma, D2.read_lexical_var_list, D2.read_lexical_var, D2.read_parameter_list, D2.read_parameter, D2.read_types, D2.read_promoted, D2.read_argument_list, D2.read_non_empty_argument_list, D2.read_argument, D2.read_type;
    var P = { read_if: function() {
      var t2 = this.node("if"), e2 = this.next().read_if_expr(), i3 = null, n2 = null, s3 = false;
      if (":" === this.token) {
        s3 = true, this.next(), i3 = this.node("block");
        for (var r2 = []; this.token !== this.EOF && this.token !== this.tok.T_ENDIF; ) {
          if (this.token === this.tok.T_ELSEIF) {
            n2 = this.read_elseif_short();
            break;
          }
          if (this.token === this.tok.T_ELSE) {
            n2 = this.read_else_short();
            break;
          }
          r2.push(this.read_inner_statement());
        }
        i3 = i3(null, r2), this.expect(this.tok.T_ENDIF) && this.next(), this.expectEndOfStatement();
      } else
        i3 = this.read_statement(), this.token === this.tok.T_ELSEIF ? n2 = this.read_if() : this.token === this.tok.T_ELSE && (n2 = this.next().read_statement());
      return t2(e2, i3, n2, s3);
    }, read_if_expr: function() {
      this.expect("(") && this.next();
      var t2 = this.read_expr();
      return this.expect(")") && this.next(), t2;
    }, read_elseif_short: function() {
      var t2 = null, e2 = this.node("if"), i3 = this.next().read_if_expr();
      this.expect(":") && this.next();
      for (var n2 = this.node("block"), s3 = []; this.token != this.EOF && this.token !== this.tok.T_ENDIF; ) {
        if (this.token === this.tok.T_ELSEIF) {
          t2 = this.read_elseif_short();
          break;
        }
        if (this.token === this.tok.T_ELSE) {
          t2 = this.read_else_short();
          break;
        }
        s3.push(this.read_inner_statement());
      }
      return e2(i3, n2(null, s3), t2, true);
    }, read_else_short: function() {
      this.next().expect(":") && this.next();
      for (var t2 = this.node("block"), e2 = []; this.token != this.EOF && this.token !== this.tok.T_ENDIF; )
        e2.push(this.read_inner_statement());
      return t2(null, e2);
    } };
    P.read_if, P.read_if_expr, P.read_elseif_short, P.read_else_short;
    var U = { read_while: function() {
      var t2 = this.node("while");
      this.expect(this.tok.T_WHILE) && this.next();
      var e2, i3 = null, n2 = false;
      return this.expect("(") && this.next(), e2 = this.read_expr(), this.expect(")") && this.next(), ":" === this.token ? (n2 = true, i3 = this.read_short_form(this.tok.T_ENDWHILE)) : i3 = this.read_statement(), t2(e2, i3, n2);
    }, read_do: function() {
      var t2 = this.node("do");
      this.expect(this.tok.T_DO) && this.next();
      var e2, i3 = null;
      return e2 = this.read_statement(), this.expect(this.tok.T_WHILE) && (this.next().expect("(") && this.next(), i3 = this.read_expr(), this.expect(")") && this.next(), this.expect(";") && this.next()), t2(i3, e2);
    }, read_for: function() {
      var t2 = this.node("for");
      this.expect(this.tok.T_FOR) && this.next();
      var e2 = [], i3 = [], n2 = [], s3 = null, r2 = false;
      return this.expect("(") && this.next(), ";" !== this.token ? (e2 = this.read_list(this.read_expr, ","), this.expect(";") && this.next()) : this.next(), ";" !== this.token ? (i3 = this.read_list(this.read_expr, ","), this.expect(";") && this.next()) : this.next(), ")" !== this.token ? (n2 = this.read_list(this.read_expr, ","), this.expect(")") && this.next()) : this.next(), ":" === this.token ? (r2 = true, s3 = this.read_short_form(this.tok.T_ENDFOR)) : s3 = this.read_statement(), t2(e2, i3, n2, s3, r2);
    }, read_foreach: function() {
      var t2 = this.node("foreach");
      this.expect(this.tok.T_FOREACH) && this.next();
      var e2, i3 = null, n2 = null, s3 = null, r2 = false;
      return this.expect("(") && this.next(), e2 = this.read_expr(), this.expect(this.tok.T_AS) && (this.next(), n2 = this.read_foreach_variable(), this.token === this.tok.T_DOUBLE_ARROW && (i3 = n2, n2 = this.next().read_foreach_variable())), i3 && "list" === i3.kind && this.raiseError("Fatal Error : Cannot use list as key element"), this.expect(")") && this.next(), ":" === this.token ? (r2 = true, s3 = this.read_short_form(this.tok.T_ENDFOREACH)) : s3 = this.read_statement(), t2(e2, i3, n2, s3, r2);
    }, read_foreach_variable: function() {
      if (this.token === this.tok.T_LIST || "[" === this.token) {
        var t2 = "[" === this.token, e2 = this.node("list");
        this.next(), !t2 && this.expect("(") && this.next();
        var i3 = this.read_array_pair_list(t2);
        return this.expect(t2 ? "]" : ")") && this.next(), e2(i3, t2);
      }
      return this.read_variable(false, false);
    } };
    U.read_while, U.read_do, U.read_for, U.read_foreach, U.read_foreach_variable;
    var M2 = { read_start: function() {
      return this.token == this.tok.T_NAMESPACE ? this.read_namespace() : this.read_top_statement();
    } };
    M2.read_start;
    var F = { read_namespace: function() {
      var t2, e2, i3 = this.node("namespace");
      return this.expect(this.tok.T_NAMESPACE) && this.next(), e2 = "{" === this.token ? { name: [""] } : this.read_namespace_name(), this.currentNamespace = e2, ";" === this.token ? (this.currentNamespace = e2, t2 = this.next().read_top_statements(), this.expect(this.EOF), i3(e2.name, t2, false)) : "{" === this.token ? (this.currentNamespace = e2, t2 = this.next().read_top_statements(), this.expect("}") && this.next(), 0 === t2.length && this.extractDoc && this._docs.length > this._docIndex && t2.push(this.node("noop")()), i3(e2.name, t2, true)) : (this.error(["{", ";"]), this.currentNamespace = e2, t2 = this.read_top_statements(), this.expect(this.EOF), i3(e2, t2, false));
    }, read_namespace_name: function(t2) {
      var e2, i3 = this.node(), n2 = this.text();
      switch (this.token) {
        case this.tok.T_NAME_RELATIVE:
          e2 = this.ast.name.RELATIVE_NAME, n2 = n2.replace(/^namespace\\/, "");
          break;
        case this.tok.T_NAME_QUALIFIED:
          e2 = this.ast.name.QUALIFIED_NAME;
          break;
        case this.tok.T_NAME_FULLY_QUALIFIED:
          e2 = this.ast.name.FULL_QUALIFIED_NAME;
          break;
        default:
          if (e2 = this.ast.name.UNQUALIFIED_NAME, !this.expect(this.tok.T_STRING))
            return i3("name", "", this.ast.name.FULL_QUALIFIED_NAME);
      }
      if (this.next(), t2 || "(" !== this.token) {
        if ("parent" === n2.toLowerCase())
          return i3("parentreference", n2);
        if ("self" === n2.toLowerCase())
          return i3("selfreference", n2);
      }
      return i3("name", n2, e2);
    }, read_use_statement: function() {
      var t2 = this.node("usegroup"), e2 = [], i3 = null;
      this.expect(this.tok.T_USE) && this.next();
      var n2 = this.read_use_type();
      return e2.push(this.read_use_declaration(false)), "," === this.token ? e2 = e2.concat(this.next().read_use_declarations(false)) : "{" === this.token && (i3 = e2[0].name, e2 = this.next().read_use_declarations(null === n2), this.expect("}") && this.next()), t2 = t2(i3, n2, e2), this.expect(";") && this.next(), t2;
    }, read_class_name_reference: function() {
      return this.read_variable(true, false);
    }, read_use_declaration: function(t2) {
      var e2 = this.node("useitem"), i3 = null;
      t2 && (i3 = this.read_use_type());
      var n2 = this.read_namespace_name(), s3 = this.read_use_alias();
      return e2(n2.name, s3, i3);
    }, read_use_declarations: function(t2) {
      for (var e2 = [this.read_use_declaration(t2)]; "," === this.token; ) {
        if (this.next(), t2) {
          if (this.token !== this.tok.T_NAME_RELATIVE && this.token !== this.tok.T_NAME_QUALIFIED && this.token !== this.tok.T_NAME_FULLY_QUALIFIED && this.token !== this.tok.T_FUNCTION && this.token !== this.tok.T_CONST && this.token !== this.tok.T_STRING)
            break;
        } else if (this.token !== this.tok.T_NAME_RELATIVE && this.token !== this.tok.T_NAME_QUALIFIED && this.token !== this.tok.T_NAME_FULLY_QUALIFIED && this.token !== this.tok.T_STRING && this.token !== this.tok.T_NS_SEPARATOR)
          break;
        e2.push(this.read_use_declaration(t2));
      }
      return e2;
    }, read_use_alias: function() {
      var t2 = null;
      if (this.token === this.tok.T_AS && this.next().expect(this.tok.T_STRING)) {
        var e2 = this.node("identifier"), i3 = this.text();
        this.next(), t2 = e2(i3);
      }
      return t2;
    }, read_use_type: function() {
      return this.token === this.tok.T_FUNCTION ? (this.next(), this.ast.useitem.TYPE_FUNCTION) : this.token === this.tok.T_CONST ? (this.next(), this.ast.useitem.TYPE_CONST) : null;
    } };
    F.read_namespace, F.read_namespace_name, F.read_use_statement, F.read_class_name_reference, F.read_use_declaration, F.read_use_declarations, F.read_use_alias, F.read_use_type;
    var B = { "\\": "\\", $: "$", n: "\n", r: "\r", t: "	", f: String.fromCharCode(12), v: String.fromCharCode(11), e: String.fromCharCode(27) }, H3 = { resolve_special_chars: function(t2, e2) {
      return e2 ? t2.replace(/\\"/, '"').replace(/\\([\\$nrtfve]|[xX][0-9a-fA-F]{1,2}|[0-7]{1,3}|u{([0-9a-fA-F]+)})/g, function(t3, e3, i3) {
        return B[e3] ? B[e3] : "x" === e3[0] || "X" === e3[0] ? String.fromCodePoint(parseInt(e3.substr(1), 16)) : "u" === e3[0] ? String.fromCodePoint(parseInt(i3, 16)) : String.fromCodePoint(parseInt(e3, 8));
      }) : t2.replace(/\\\\/g, "\\").replace(/\\'/g, "'");
    }, remove_heredoc_leading_whitespace_chars: function(t2, e2, i3, n2) {
      if (0 === e2)
        return t2;
      this.check_heredoc_indentation_level(t2, e2, i3, n2);
      var s3 = i3 ? " " : "	", r2 = new RegExp("\\n".concat(s3, "{").concat(e2, "}"), "g"), o2 = new RegExp("^".concat(s3, "{").concat(e2, "}"));
      return n2 && (t2 = t2.replace(o2, "")), t2.replace(r2, "\n");
    }, check_heredoc_indentation_level: function(t2, e2, i3, n2) {
      var s3 = t2.length, r2 = 0, o2 = 0, a4 = true, h3 = i3 ? " " : "	", l2 = false;
      if (!n2) {
        if (-1 === (r2 = t2.indexOf("\n")))
          return;
        r2++;
      }
      for (; r2 < s3; )
        a4 ? t2[r2] === h3 ? o2++ : l2 = true : a4 = false, "\n" !== t2[r2] && l2 && o2 < e2 ? this.raiseError("Invalid body indentation level (expecting an indentation at least ".concat(e2, ")")) : l2 = false, "\n" === t2[r2] && (a4 = true, o2 = 0), r2++;
    }, read_dereferencable_scalar: function() {
      var t2 = null;
      switch (this.token) {
        case this.tok.T_CONSTANT_ENCAPSED_STRING:
          var e2 = this.node("string"), i3 = this.text(), n2 = 0;
          "b" !== i3[0] && "B" !== i3[0] || (n2 = 1);
          var s3 = '"' === i3[n2];
          this.next(), e2 = e2(s3, this.resolve_special_chars(i3.substring(n2 + 1, i3.length - 1), s3), 1 === n2, i3), t2 = this.token === this.tok.T_DOUBLE_COLON ? this.read_static_getter(e2) : e2;
          break;
        case this.tok.T_ARRAY:
        case "[":
          t2 = this.read_array();
      }
      return t2;
    }, read_scalar: function() {
      if (this.is("T_MAGIC_CONST"))
        return this.get_magic_constant();
      var t2, e2;
      switch (this.token) {
        case this.tok.T_LNUMBER:
        case this.tok.T_DNUMBER:
          var i3 = this.node("number");
          return t2 = this.text(), this.next(), i3(t2, null);
        case this.tok.T_START_HEREDOC:
          if ("ST_NOWDOC" === this.lexer.curCondition) {
            var n2 = this.lexer.yylloc.first_offset;
            e2 = this.node("nowdoc"), t2 = this.next().text(), this.lexer.heredoc_label.indentation > 0 && (t2 = t2.substring(0, t2.length - this.lexer.heredoc_label.indentation));
            var s3 = t2[t2.length - 1];
            "\n" === s3 ? t2 = "\r" === t2[t2.length - 2] ? t2.substring(0, t2.length - 2) : t2.substring(0, t2.length - 1) : "\r" === s3 && (t2 = t2.substring(0, t2.length - 1)), this.expect(this.tok.T_ENCAPSED_AND_WHITESPACE) && this.next(), this.expect(this.tok.T_END_HEREDOC) && this.next();
            var r2 = this.lexer._input.substring(n2, this.lexer.yylloc.first_offset);
            return e2 = e2(this.remove_heredoc_leading_whitespace_chars(t2, this.lexer.heredoc_label.indentation, this.lexer.heredoc_label.indentation_uses_spaces, this.lexer.heredoc_label.first_encaps_node), r2, this.lexer.heredoc_label.label), this.lexer.heredoc_label.finished = true, e2;
          }
          return this.read_encapsed_string(this.tok.T_END_HEREDOC);
        case '"':
          return this.read_encapsed_string('"');
        case 'b"':
        case 'B"':
          return this.read_encapsed_string('"', true);
        case this.tok.T_CONSTANT_ENCAPSED_STRING:
        case this.tok.T_ARRAY:
        case "[":
          return this.read_dereferencable_scalar();
        default:
          var o2 = this.error("SCALAR");
          return this.next(), o2;
      }
    }, read_dereferencable: function(t2) {
      var e2, i3, n2 = this.node("offsetlookup");
      return "[" === this.token ? (i3 = this.next().read_expr(), this.expect("]") && this.next(), e2 = n2(t2, i3)) : this.token === this.tok.T_DOLLAR_OPEN_CURLY_BRACES && (e2 = n2(t2, i3 = this.read_encapsed_string_item(false))), e2;
    }, read_encapsed_string_item: function(t2) {
      var e2, i3, n2, s3 = this.node("encapsedpart"), r2 = null, o2 = false, a4 = this.node();
      if (this.token === this.tok.T_ENCAPSED_AND_WHITESPACE) {
        var h3 = this.text();
        this.next(), a4 = a4("string", false, this.version >= 703 && !this.lexer.heredoc_label.finished ? this.remove_heredoc_leading_whitespace_chars(this.resolve_special_chars(h3, t2), this.lexer.heredoc_label.indentation, this.lexer.heredoc_label.indentation_uses_spaces, this.lexer.heredoc_label.first_encaps_node) : h3, false, h3);
      } else if (this.token === this.tok.T_DOLLAR_OPEN_CURLY_BRACES) {
        if (r2 = "simple", o2 = true, n2 = null, this.next().token === this.tok.T_STRING_VARNAME) {
          n2 = this.node("variable");
          var l2 = this.text();
          this.next(), a4.destroy(), "[" === this.token ? (n2 = n2(l2, false), i3 = this.node("offsetlookup"), e2 = this.next().read_expr(), this.expect("]") && this.next(), a4 = i3(n2, e2)) : a4 = n2(l2, false);
        } else
          a4 = a4("variable", this.read_expr(), false);
        this.expect("}") && this.next();
      } else if (this.token === this.tok.T_CURLY_OPEN)
        r2 = "complex", a4.destroy(), a4 = this.next().read_variable(false, false), this.expect("}") && this.next();
      else if (this.token === this.tok.T_VARIABLE) {
        if (r2 = "simple", a4.destroy(), a4 = this.read_simple_variable(), "[" === this.token && (i3 = this.node("offsetlookup"), e2 = this.next().read_encaps_var_offset(), this.expect("]") && this.next(), a4 = i3(a4, e2)), this.token === this.tok.T_OBJECT_OPERATOR) {
          i3 = this.node("propertylookup"), this.next().expect(this.tok.T_STRING);
          var c2 = this.node("identifier");
          n2 = this.text(), this.next(), a4 = i3(a4, c2(n2));
        }
      } else {
        this.expect(this.tok.T_ENCAPSED_AND_WHITESPACE);
        var u2 = this.text();
        this.next(), a4.destroy(), a4 = a4("string", false, u2, false, u2);
      }
      return this.lexer.heredoc_label.first_encaps_node = false, s3(a4, r2, o2);
    }, read_encapsed_string: function(t2) {
      var e2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i3 = this.lexer.yylloc.first_offset, n2 = this.node("encapsed");
      this.next();
      var s3 = this.lexer.yylloc.prev_offset - (e2 ? 1 : 0), r2 = [], o2 = null;
      for (o2 = "`" === t2 ? this.ast.encapsed.TYPE_SHELL : '"' === t2 ? this.ast.encapsed.TYPE_STRING : this.ast.encapsed.TYPE_HEREDOC; this.token !== t2 && this.token !== this.EOF; )
        r2.push(this.read_encapsed_string_item(true));
      if (r2.length > 0 && "encapsedpart" === r2[r2.length - 1].kind && "string" === r2[r2.length - 1].expression.kind) {
        var a4 = r2[r2.length - 1].expression, h3 = a4.value[a4.value.length - 1];
        "\n" === h3 ? "\r" === a4.value[a4.value.length - 2] ? a4.value = a4.value.substring(0, a4.value.length - 2) : a4.value = a4.value.substring(0, a4.value.length - 1) : "\r" === h3 && (a4.value = a4.value.substring(0, a4.value.length - 1));
      }
      this.expect(t2) && this.next();
      var l2 = this.lexer._input.substring("heredoc" === o2 ? i3 : s3 - 1, this.lexer.yylloc.first_offset);
      return n2 = n2(r2, l2, o2), t2 === this.tok.T_END_HEREDOC && (n2.label = this.lexer.heredoc_label.label, this.lexer.heredoc_label.finished = true), n2;
    }, get_magic_constant: function() {
      var t2 = this.node("magic"), e2 = this.text();
      return this.next(), t2(e2.toUpperCase(), e2);
    } };
    H3.resolve_special_chars, H3.remove_heredoc_leading_whitespace_chars, H3.check_heredoc_indentation_level, H3.read_dereferencable_scalar, H3.read_scalar, H3.read_dereferencable, H3.read_encapsed_string_item, H3.read_encapsed_string, H3.get_magic_constant;
    var G = { read_top_statements: function() {
      for (var t2 = []; this.token !== this.EOF && "}" !== this.token; ) {
        var e2 = this.read_top_statement();
        e2 && (Array.isArray(e2) ? t2 = t2.concat(e2) : t2.push(e2));
      }
      return t2;
    }, read_top_statement: function() {
      var t2 = [];
      switch (this.token === this.tok.T_ATTRIBUTE && (t2 = this.read_attr_list()), this.token) {
        case this.tok.T_FUNCTION:
          return this.read_function(false, false, t2);
        case this.tok.T_ABSTRACT:
        case this.tok.T_FINAL:
        case this.tok.T_CLASS:
          return this.read_class_declaration_statement(t2);
        case this.tok.T_INTERFACE:
          return this.read_interface_declaration_statement(t2);
        case this.tok.T_TRAIT:
          return this.read_trait_declaration_statement();
        case this.tok.T_ENUM:
          return this.read_enum_declaration_statement(t2);
        case this.tok.T_USE:
          return this.read_use_statement();
        case this.tok.T_CONST:
          var e2 = this.node("constantstatement"), i3 = this.next().read_const_list();
          return this.expectEndOfStatement(), e2(null, i3);
        case this.tok.T_NAMESPACE:
          return this.read_namespace();
        case this.tok.T_HALT_COMPILER:
          var n2 = this.node("halt");
          return this.next().expect("(") && this.next(), this.expect(")") && this.next(), this.expect(";"), this.lexer.done = true, n2(this.lexer._input.substring(this.lexer.offset));
        default:
          return this.read_statement();
      }
    }, read_inner_statements: function() {
      for (var t2 = []; this.token != this.EOF && "}" !== this.token; ) {
        var e2 = this.read_inner_statement();
        e2 && (Array.isArray(e2) ? t2 = t2.concat(e2) : t2.push(e2));
      }
      return t2;
    }, read_const_list: function() {
      return this.read_list(function() {
        this.expect(this.tok.T_STRING);
        var t2 = this.node("constant"), e2 = this.node("identifier"), i3 = this.text();
        return this.next(), e2 = e2(i3), this.expect("=") ? t2(e2, this.next().read_expr()) : t2(e2, null);
      }, ",", false);
    }, read_declare_list: function() {
      for (var t2 = []; this.token != this.EOF && ")" !== this.token; ) {
        this.expect(this.tok.T_STRING);
        var e2 = this.node("declaredirective"), i3 = this.node("identifier"), n2 = this.text();
        this.next(), i3 = i3(n2);
        var s3 = null;
        if (this.expect("=") && (s3 = this.next().read_expr()), t2.push(e2(i3, s3)), "," !== this.token)
          break;
        this.next();
      }
      return t2;
    }, read_inner_statement: function() {
      var t2 = [];
      switch (this.token === this.tok.T_ATTRIBUTE && (t2 = this.read_attr_list()), this.token) {
        case this.tok.T_FUNCTION:
          var e2 = this.read_function(false, false);
          return e2.attrGroups = t2, e2;
        case this.tok.T_ABSTRACT:
        case this.tok.T_FINAL:
        case this.tok.T_CLASS:
          return this.read_class_declaration_statement();
        case this.tok.T_INTERFACE:
          return this.read_interface_declaration_statement();
        case this.tok.T_TRAIT:
          return this.read_trait_declaration_statement();
        case this.tok.T_ENUM:
          return this.read_enum_declaration_statement();
        case this.tok.T_HALT_COMPILER:
          this.raiseError("__HALT_COMPILER() can only be used from the outermost scope");
          var i3 = this.node("halt");
          return this.next().expect("(") && this.next(), this.expect(")") && this.next(), i3 = i3(this.lexer._input.substring(this.lexer.offset)), this.expect(";") && this.next(), i3;
        default:
          return this.read_statement();
      }
    }, read_statement: function() {
      switch (this.token) {
        case "{":
          return this.read_code_block(false);
        case this.tok.T_IF:
          return this.read_if();
        case this.tok.T_SWITCH:
          return this.read_switch();
        case this.tok.T_FOR:
          return this.read_for();
        case this.tok.T_FOREACH:
          return this.read_foreach();
        case this.tok.T_WHILE:
          return this.read_while();
        case this.tok.T_DO:
          return this.read_do();
        case this.tok.T_COMMENT:
          return this.read_comment();
        case this.tok.T_DOC_COMMENT:
          return this.read_doc_comment();
        case this.tok.T_RETURN:
          var t2 = this.node("return");
          this.next();
          var e2 = this.read_optional_expr(";");
          return this.expectEndOfStatement(), t2(e2);
        case this.tok.T_BREAK:
        case this.tok.T_CONTINUE:
          var i3 = this.node(this.token === this.tok.T_CONTINUE ? "continue" : "break");
          this.next();
          var n2 = this.read_optional_expr(";");
          return this.expectEndOfStatement(), i3(n2);
        case this.tok.T_GLOBAL:
          var s3 = this.node("global"), r2 = this.next().read_list(this.read_simple_variable, ",");
          return this.expectEndOfStatement(), s3(r2);
        case this.tok.T_STATIC:
          var o2 = [this.token, this.lexer.getState()], a4 = this.node();
          if (this.next().token === this.tok.T_DOUBLE_COLON) {
            this.lexer.tokens.push(o2);
            var h3 = this.next().read_expr();
            return this.expectEndOfStatement(h3), a4("expressionstatement", h3);
          }
          if (this.token === this.tok.T_FUNCTION)
            return this.read_function(true, [0, 1, 0]);
          var l2 = this.read_variable_declarations();
          return this.expectEndOfStatement(), a4("static", l2);
        case this.tok.T_ECHO:
          var c2 = this.node("echo"), u2 = this.text(), _2 = "<?=" === u2 || "<%=" === u2, d5 = this.next().read_function_list(this.read_expr, ",");
          return this.expectEndOfStatement(), c2(d5, _2);
        case this.tok.T_INLINE_HTML:
          var p2 = this.text(), f2 = this.lexer.yylloc.first_offset > 0 ? this.lexer._input[this.lexer.yylloc.first_offset - 1] : null, T3 = "\r" === f2 || "\n" === f2;
          T3 && "\n" === f2 && this.lexer.yylloc.first_offset > 1 && "\r" === this.lexer._input[this.lexer.yylloc.first_offset - 2] && (f2 = "\r\n");
          var k3 = this.node("inline");
          return this.next(), k3(p2, T3 ? f2 + p2 : p2);
        case this.tok.T_UNSET:
          var E2 = this.node("unset");
          this.next().expect("(") && this.next();
          var m3 = this.read_function_list(this.read_variable, ",");
          return this.expect(")") && this.next(), this.expect(";") && this.next(), E2(m3);
        case this.tok.T_DECLARE:
          var x3, y2 = this.node("declare"), v2 = [];
          this.next().expect("(") && this.next();
          var A3 = this.read_declare_list();
          if (this.expect(")") && this.next(), ":" === this.token) {
            for (this.next(); this.token != this.EOF && this.token !== this.tok.T_ENDDECLARE; )
              v2.push(this.read_top_statement());
            0 === v2.length && this.extractDoc && this._docs.length > this._docIndex && v2.push(this.node("noop")()), this.expect(this.tok.T_ENDDECLARE) && this.next(), this.expectEndOfStatement(), x3 = this.ast.declare.MODE_SHORT;
          } else if ("{" === this.token) {
            for (this.next(); this.token != this.EOF && "}" !== this.token; )
              v2.push(this.read_top_statement());
            0 === v2.length && this.extractDoc && this._docs.length > this._docIndex && v2.push(this.node("noop")()), this.expect("}") && this.next(), x3 = this.ast.declare.MODE_BLOCK;
          } else
            this.expect(";") && this.next(), x3 = this.ast.declare.MODE_NONE;
          return y2(A3, v2, x3);
        case this.tok.T_TRY:
          return this.read_try();
        case this.tok.T_THROW:
          var g3 = this.node("throw"), N2 = this.next().read_expr();
          return this.expectEndOfStatement(), g3(N2);
        case ";":
          return this.next(), null;
        case this.tok.T_STRING:
          var L2 = this.node(), C3 = [this.token, this.lexer.getState()], b3 = this.text(), I3 = this.node("identifier");
          if (":" === this.next().token)
            return I3 = I3(b3), this.next(), L2("label", I3);
          I3.destroy(), L2.destroy(), this.lexer.tokens.push(C3);
          var S3 = this.node("expressionstatement"), O3 = this.next().read_expr();
          return this.expectEndOfStatement(O3), S3(O3);
        case this.tok.T_GOTO:
          var R2 = this.node("goto"), w3 = null;
          if (this.next().expect(this.tok.T_STRING)) {
            w3 = this.node("identifier");
            var D3 = this.text();
            this.next(), w3 = w3(D3), this.expectEndOfStatement();
          }
          return R2(w3);
        default:
          var P2 = this.node("expressionstatement"), U2 = this.read_expr();
          return this.expectEndOfStatement(U2), P2(U2);
      }
    }, read_code_block: function(t2) {
      var e2 = this.node("block");
      this.expect("{") && this.next();
      var i3 = t2 ? this.read_top_statements() : this.read_inner_statements();
      return 0 === i3.length && this.extractDoc && this._docs.length > this._docIndex && i3.push(this.node("noop")()), this.expect("}") && this.next(), e2(null, i3);
    } };
    G.read_top_statements, G.read_top_statement, G.read_inner_statements, G.read_const_list, G.read_declare_list, G.read_inner_statement, G.read_statement, G.read_code_block;
    var V = { read_switch: function() {
      var t2 = this.node("switch");
      this.expect(this.tok.T_SWITCH) && this.next(), this.expect("(") && this.next();
      var e2 = this.read_expr();
      this.expect(")") && this.next();
      var i3 = ":" === this.token;
      return t2(e2, this.read_switch_case_list(), i3);
    }, read_switch_case_list: function() {
      var t2 = null, e2 = this.node("block"), i3 = [];
      for ("{" === this.token ? t2 = "}" : ":" === this.token ? t2 = this.tok.T_ENDSWITCH : this.expect(["{", ":"]), this.next(), ";" === this.token && this.next(); this.token !== this.EOF && this.token !== t2; )
        i3.push(this.read_case_list(t2));
      return 0 === i3.length && this.extractDoc && this._docs.length > this._docIndex && i3.push(this.node("noop")()), this.expect(t2) && this.next(), t2 === this.tok.T_ENDSWITCH && this.expectEndOfStatement(), e2(null, i3);
    }, read_case_list: function(t2) {
      var e2 = this.node("case"), i3 = null;
      this.token === this.tok.T_CASE ? i3 = this.next().read_expr() : this.token === this.tok.T_DEFAULT ? this.next() : this.expect([this.tok.T_CASE, this.tok.T_DEFAULT]), this.expect([":", ";"]) && this.next();
      for (var n2 = this.node("block"), s3 = []; this.token !== this.EOF && this.token !== t2 && this.token !== this.tok.T_CASE && this.token !== this.tok.T_DEFAULT; )
        s3.push(this.read_inner_statement());
      return e2(i3, n2(null, s3));
    } };
    V.read_switch, V.read_switch_case_list, V.read_case_list;
    var Q = { read_try: function() {
      this.expect(this.tok.T_TRY);
      for (var t2 = this.node("try"), e2 = null, i3 = [], n2 = this.next().read_statement(); this.token === this.tok.T_CATCH; ) {
        var s3 = this.node("catch");
        this.next().expect("(") && this.next();
        var r2 = this.read_list(this.read_namespace_name, "|", false), o2 = null;
        (this.version < 800 || this.token === this.tok.T_VARIABLE) && (o2 = this.read_variable(true, false)), this.expect(")"), i3.push(s3(this.next().read_statement(), r2, o2));
      }
      return this.token === this.tok.T_FINALLY && (e2 = this.next().read_statement()), t2(n2, i3, e2);
    } };
    Q.read_try;
    var W2 = { read_short_form: function(t2) {
      var e2 = this.node("block"), i3 = [];
      for (this.expect(":") && this.next(); this.token != this.EOF && this.token !== t2; )
        i3.push(this.read_inner_statement());
      return 0 === i3.length && this.extractDoc && this._docs.length > this._docIndex && i3.push(this.node("noop")()), this.expect(t2) && this.next(), this.expectEndOfStatement(), e2(null, i3);
    }, read_function_list: function(t2, e2) {
      var i3 = [];
      do {
        if (this.token == e2 && this.version >= 703 && i3.length > 0) {
          i3.push(this.node("noop")());
          break;
        }
        if (i3.push(t2.apply(this, [])), this.token != e2)
          break;
        if (")" == this.next().token && this.version >= 703)
          break;
      } while (this.token != this.EOF);
      return i3;
    }, read_list: function(t2, e2, i3) {
      var n2 = [];
      if (this.token == e2 && (i3 && n2.push("function" == typeof t2 ? this.node("noop")() : null), this.next()), "function" == typeof t2)
        do {
          var s3 = t2.apply(this, []);
          if (s3 && n2.push(s3), this.token != e2)
            break;
        } while (this.next().token != this.EOF);
      else {
        if (!this.expect(t2))
          return [];
        for (n2.push(this.text()); this.next().token != this.EOF && this.token == e2 && this.next().token == t2; )
          n2.push(this.text());
      }
      return n2;
    }, read_name_list: function() {
      return this.read_list(this.read_namespace_name, ",", false);
    }, read_byref: function(t2) {
      var e2 = this.node("byref");
      this.next(), e2 = e2(null);
      var i3 = t2();
      return i3 && (this.ast.swapLocations(i3, e2, i3, this), i3.byref = true), i3;
    }, read_variable_declarations: function() {
      return this.read_list(function() {
        var t2 = this.node("staticvariable"), e2 = this.node("variable");
        if (this.expect(this.tok.T_VARIABLE)) {
          var i3 = this.text().substring(1);
          this.next(), e2 = e2(i3, false);
        } else
          e2 = e2("#ERR", false);
        return "=" === this.token ? t2(e2, this.next().read_expr()) : e2;
      }, ",");
    }, read_extends_from: function() {
      return this.token === this.tok.T_EXTENDS ? this.next().read_namespace_name() : null;
    }, read_interface_extends_list: function() {
      return this.token === this.tok.T_EXTENDS ? this.next().read_name_list() : null;
    }, read_implements_list: function() {
      return this.token === this.tok.T_IMPLEMENTS ? this.next().read_name_list() : null;
    } };
    W2.read_short_form, W2.read_function_list, W2.read_list, W2.read_name_list, W2.read_byref, W2.read_variable_declarations, W2.read_extends_from, W2.read_interface_extends_list, W2.read_implements_list;
    var Y3 = { read_variable: function(t2, e2) {
      var i3;
      if ("&" === this.token)
        return this.read_byref(this.read_variable.bind(this, t2, e2));
      if (this.is([this.tok.T_VARIABLE, "$"]))
        i3 = this.read_reference_variable(e2);
      else if (this.is([this.tok.T_NS_SEPARATOR, this.tok.T_STRING, this.tok.T_NAME_RELATIVE, this.tok.T_NAME_QUALIFIED, this.tok.T_NAME_FULLY_QUALIFIED, this.tok.T_NAMESPACE])) {
        i3 = this.node();
        var n2 = this.read_namespace_name();
        if (this.token != this.tok.T_DOUBLE_COLON && "(" != this.token && -1 === ["parentreference", "selfreference"].indexOf(n2.kind)) {
          var s3 = n2.name.toLowerCase();
          "true" === s3 ? i3 = n2.destroy(i3("boolean", true, n2.name)) : "false" === s3 ? i3 = n2.destroy(i3("boolean", false, n2.name)) : "null" === s3 ? i3 = n2.destroy(i3("nullkeyword", n2.name)) : (i3.destroy(n2), i3 = n2);
        } else
          i3.destroy(n2), i3 = n2;
      } else if (this.token === this.tok.T_STATIC) {
        i3 = this.node("staticreference");
        var r2 = this.text();
        this.next(), i3 = i3(r2);
      } else
        this.expect("VARIABLE");
      return this.token === this.tok.T_DOUBLE_COLON && (i3 = this.read_static_getter(i3, e2)), this.recursive_variable_chain_scan(i3, t2, e2);
    }, read_static_getter: function(t2, e2) {
      var i3, n2, s3 = this.node("staticlookup");
      return this.next().is([this.tok.T_VARIABLE, "$"]) ? i3 = this.read_reference_variable(e2) : this.token === this.tok.T_STRING || this.token === this.tok.T_CLASS || this.version >= 700 && this.is("IDENTIFIER") ? (i3 = this.node("identifier"), n2 = this.text(), this.next(), i3 = i3(n2)) : "{" === this.token ? (i3 = this.node("literal"), n2 = this.next().read_expr(), this.expect("}") && this.next(), i3 = i3("literal", n2, null), this.expect("(")) : (this.error([this.tok.T_VARIABLE, this.tok.T_STRING]), i3 = this.node("identifier"), n2 = this.text(), this.next(), i3 = i3(n2)), s3(t2, i3);
    }, read_what: function() {
      var t2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], e2 = null, i3 = null;
      switch (this.next().token) {
        case this.tok.T_STRING:
          e2 = this.node("identifier"), i3 = this.text(), this.next(), e2 = e2(i3), t2 && this.token === this.tok.T_OBJECT_OPERATOR && this.error();
          break;
        case this.tok.T_VARIABLE:
          e2 = this.node("variable"), i3 = this.text().substring(1), this.next(), e2 = e2(i3, false);
          break;
        case "$":
          e2 = this.node(), this.next().expect(["$", "{", this.tok.T_VARIABLE]), "{" === this.token ? (i3 = this.next().read_expr(), this.expect("}") && this.next(), e2 = e2("variable", i3, true)) : e2 = e2("variable", i3 = this.read_expr(), false);
          break;
        case "{":
          e2 = this.node("encapsedpart"), i3 = this.next().read_expr(), this.expect("}") && this.next(), e2 = e2(i3, "complex", false);
          break;
        default:
          this.error([this.tok.T_STRING, this.tok.T_VARIABLE, "$", "{"]), e2 = this.node("identifier"), i3 = this.text(), this.next(), e2 = e2(i3);
      }
      return e2;
    }, recursive_variable_chain_scan: function(t2, e2, i3) {
      var n2, s3;
      t:
        for (; this.token != this.EOF; )
          switch (this.token) {
            case "(":
              if (e2)
                return t2;
              t2 = this.node("call")(t2, this.read_argument_list());
              break;
            case "[":
            case "{":
              var r2 = "[" === this.token;
              if (n2 = this.node("offsetlookup"), this.next(), s3 = false, i3)
                s3 = this.read_encaps_var_offset(), this.expect(r2 ? "]" : "}") && this.next();
              else
                (r2 ? "]" !== this.token : "}" !== this.token) ? (s3 = this.read_expr(), this.expect(r2 ? "]" : "}") && this.next()) : this.next();
              t2 = n2(t2, s3);
              break;
            case this.tok.T_DOUBLE_COLON:
              "staticlookup" === t2.kind && "identifier" === t2.offset.kind && this.error(), t2 = (n2 = this.node("staticlookup"))(t2, this.read_what(true));
              break;
            case this.tok.T_OBJECT_OPERATOR:
              t2 = (n2 = this.node("propertylookup"))(t2, this.read_what());
              break;
            case this.tok.T_NULLSAFE_OBJECT_OPERATOR:
              t2 = (n2 = this.node("nullsafepropertylookup"))(t2, this.read_what());
              break;
            default:
              break t;
          }
      return t2;
    }, read_encaps_var_offset: function() {
      var t2 = this.node();
      if (this.token === this.tok.T_STRING) {
        var e2 = this.text();
        this.next(), t2 = t2("identifier", e2);
      } else if (this.token === this.tok.T_NUM_STRING) {
        var i3 = this.text();
        this.next(), t2 = t2("number", i3, null);
      } else if ("-" === this.token) {
        this.next();
        var n2 = -1 * this.text();
        this.expect(this.tok.T_NUM_STRING) && this.next(), t2 = t2("number", n2, null);
      } else if (this.token === this.tok.T_VARIABLE) {
        var s3 = this.text().substring(1);
        this.next(), t2 = t2("variable", s3, false);
      } else {
        this.expect([this.tok.T_STRING, this.tok.T_NUM_STRING, "-", this.tok.T_VARIABLE]);
        var r2 = this.text();
        this.next(), t2 = t2("identifier", r2);
      }
      return t2;
    }, read_reference_variable: function(t2) {
      for (var e2, i3 = this.read_simple_variable(); this.token != this.EOF; ) {
        var n2 = this.node();
        if ("{" != this.token || t2) {
          n2.destroy();
          break;
        }
        e2 = this.next().read_expr(), this.expect("}") && this.next(), i3 = n2("offsetlookup", i3, e2);
      }
      return i3;
    }, read_simple_variable: function() {
      var t2, e2 = this.node("variable");
      if (this.expect([this.tok.T_VARIABLE, "$"]) && this.token === this.tok.T_VARIABLE)
        t2 = this.text().substring(1), this.next(), e2 = e2(t2, false);
      else
        switch ("$" === this.token && this.next(), this.token) {
          case "{":
            var i3 = this.next().read_expr();
            this.expect("}") && this.next(), e2 = e2(i3, true);
            break;
          case "$":
            e2 = e2(this.read_simple_variable(), false);
            break;
          case this.tok.T_VARIABLE:
            t2 = this.text().substring(1);
            var n2 = this.node("variable");
            this.next(), e2 = e2(n2(t2, false), false);
            break;
          default:
            this.error(["{", "$", this.tok.T_VARIABLE]), t2 = this.text(), this.next(), e2 = e2(t2, false);
        }
      return e2;
    } };
    function j(t2) {
      return "." != t2 && "," != t2 && !isNaN(parseFloat(t2)) && isFinite(t2);
    }
    Y3.read_variable, Y3.read_static_getter, Y3.read_what, Y3.recursive_variable_chain_scan, Y3.read_encaps_var_offset, Y3.read_reference_variable, Y3.read_simple_variable;
    var $ = function(t2, e2) {
      this.lexer = t2, this.ast = e2, this.tok = t2.tok, this.EOF = t2.EOF, this.token = null, this.prev = null, this.debug = false, this.version = 801, this.extractDoc = false, this.extractTokens = false, this.suppressErrors = false;
      var i3 = function(t3) {
        return [t3, null];
      };
      this.entries = { IDENTIFIER: new Map([this.tok.T_ABSTRACT, this.tok.T_ARRAY, this.tok.T_AS, this.tok.T_BREAK, this.tok.T_CALLABLE, this.tok.T_CASE, this.tok.T_CATCH, this.tok.T_CLASS, this.tok.T_CLASS_C, this.tok.T_CLONE, this.tok.T_CONST, this.tok.T_CONTINUE, this.tok.T_DECLARE, this.tok.T_DEFAULT, this.tok.T_DIR, this.tok.T_DO, this.tok.T_ECHO, this.tok.T_ELSE, this.tok.T_ELSEIF, this.tok.T_EMPTY, this.tok.T_ENDDECLARE, this.tok.T_ENDFOR, this.tok.T_ENDFOREACH, this.tok.T_ENDIF, this.tok.T_ENDSWITCH, this.tok.T_ENDWHILE, this.tok.T_ENUM, this.tok.T_EVAL, this.tok.T_EXIT, this.tok.T_EXTENDS, this.tok.T_FILE, this.tok.T_FINAL, this.tok.T_FINALLY, this.tok.T_FN, this.tok.T_FOR, this.tok.T_FOREACH, this.tok.T_FUNC_C, this.tok.T_FUNCTION, this.tok.T_GLOBAL, this.tok.T_GOTO, this.tok.T_IF, this.tok.T_IMPLEMENTS, this.tok.T_INCLUDE, this.tok.T_INCLUDE_ONCE, this.tok.T_INSTANCEOF, this.tok.T_INSTEADOF, this.tok.T_INTERFACE, this.tok.T_ISSET, this.tok.T_LINE, this.tok.T_LIST, this.tok.T_LOGICAL_AND, this.tok.T_LOGICAL_OR, this.tok.T_LOGICAL_XOR, this.tok.T_MATCH, this.tok.T_METHOD_C, this.tok.T_NAMESPACE, this.tok.T_NEW, this.tok.T_NS_C, this.tok.T_PRINT, this.tok.T_PRIVATE, this.tok.T_PROTECTED, this.tok.T_PUBLIC, this.tok.T_READ_ONLY, this.tok.T_REQUIRE, this.tok.T_REQUIRE_ONCE, this.tok.T_RETURN, this.tok.T_STATIC, this.tok.T_SWITCH, this.tok.T_THROW, this.tok.T_TRAIT, this.tok.T_TRY, this.tok.T_UNSET, this.tok.T_USE, this.tok.T_VAR, this.tok.T_WHILE, this.tok.T_YIELD].map(i3)), VARIABLE: new Map([this.tok.T_VARIABLE, "$", "&", this.tok.T_STRING, this.tok.T_NAME_RELATIVE, this.tok.T_NAME_QUALIFIED, this.tok.T_NAME_FULLY_QUALIFIED, this.tok.T_NAMESPACE, this.tok.T_STATIC].map(i3)), SCALAR: new Map([this.tok.T_CONSTANT_ENCAPSED_STRING, this.tok.T_START_HEREDOC, this.tok.T_LNUMBER, this.tok.T_DNUMBER, this.tok.T_ARRAY, "[", this.tok.T_CLASS_C, this.tok.T_TRAIT_C, this.tok.T_FUNC_C, this.tok.T_METHOD_C, this.tok.T_LINE, this.tok.T_FILE, this.tok.T_DIR, this.tok.T_NS_C, '"', 'b"', 'B"', "-", this.tok.T_NS_SEPARATOR].map(i3)), T_MAGIC_CONST: new Map([this.tok.T_CLASS_C, this.tok.T_TRAIT_C, this.tok.T_FUNC_C, this.tok.T_METHOD_C, this.tok.T_LINE, this.tok.T_FILE, this.tok.T_DIR, this.tok.T_NS_C].map(i3)), T_MEMBER_FLAGS: new Map([this.tok.T_PUBLIC, this.tok.T_PRIVATE, this.tok.T_PROTECTED, this.tok.T_STATIC, this.tok.T_ABSTRACT, this.tok.T_FINAL].map(i3)), EOS: new Map([";", this.EOF, this.tok.T_INLINE_HTML].map(i3)), EXPR: new Map(["@", "-", "+", "!", "~", "(", "`", this.tok.T_LIST, this.tok.T_CLONE, this.tok.T_INC, this.tok.T_DEC, this.tok.T_NEW, this.tok.T_ISSET, this.tok.T_EMPTY, this.tok.T_MATCH, this.tok.T_INCLUDE, this.tok.T_INCLUDE_ONCE, this.tok.T_REQUIRE, this.tok.T_REQUIRE_ONCE, this.tok.T_EVAL, this.tok.T_INT_CAST, this.tok.T_DOUBLE_CAST, this.tok.T_STRING_CAST, this.tok.T_ARRAY_CAST, this.tok.T_OBJECT_CAST, this.tok.T_BOOL_CAST, this.tok.T_UNSET_CAST, this.tok.T_EXIT, this.tok.T_PRINT, this.tok.T_YIELD, this.tok.T_STATIC, this.tok.T_FUNCTION, this.tok.T_FN, this.tok.T_VARIABLE, "$", this.tok.T_NS_SEPARATOR, this.tok.T_STRING, this.tok.T_NAME_RELATIVE, this.tok.T_NAME_QUALIFIED, this.tok.T_NAME_FULLY_QUALIFIED, this.tok.T_STRING, this.tok.T_CONSTANT_ENCAPSED_STRING, this.tok.T_START_HEREDOC, this.tok.T_LNUMBER, this.tok.T_DNUMBER, this.tok.T_ARRAY, "[", this.tok.T_CLASS_C, this.tok.T_TRAIT_C, this.tok.T_FUNC_C, this.tok.T_METHOD_C, this.tok.T_LINE, this.tok.T_FILE, this.tok.T_DIR, this.tok.T_NS_C, '"', 'b"', 'B"', "-", this.tok.T_NS_SEPARATOR].map(i3)) };
    };
    $.prototype.getTokenName = function(t2) {
      return j(t2) ? t2 == this.EOF ? "the end of file (EOF)" : this.lexer.engine.tokens.values[t2] : "'" + t2 + "'";
    }, $.prototype.parse = function(t2, e2) {
      this._errors = [], this.filename = e2 || "eval", this.currentNamespace = [""], this.extractDoc ? this._docs = [] : this._docs = null, this.extractTokens ? this._tokens = [] : this._tokens = null, this._docIndex = 0, this._lastNode = null, this.lexer.setInput(t2), this.lexer.all_tokens = this.extractTokens, this.lexer.comment_tokens = this.extractDoc, this.length = this.lexer._input.length, this.innerList = false, this.innerListForm = false;
      var i3 = this.node("program"), n2 = [];
      for (this.next(); this.token != this.EOF; )
        n2.push(this.read_start());
      0 === n2.length && this.extractDoc && this._docs.length > this._docIndex && n2.push(this.node("noop")()), this.prev = [this.lexer.yylloc.last_line, this.lexer.yylloc.last_column, this.lexer.offset];
      var s3 = i3(n2, this._errors, this._docs, this._tokens);
      if (this.debug) {
        var r2 = this.ast.checkNodes();
        if (r2.length > 0)
          throw r2.forEach(function(t3) {
            t3.position && console.log("Node at line " + t3.position.line + ", column " + t3.position.column), console.log(t3.stack.join("\n"));
          }), new Error("Some nodes are not closed");
      }
      return s3;
    }, $.prototype.raiseError = function(t2, e2, i3, n2) {
      if (t2 += " on line " + this.lexer.yylloc.first_line, !this.suppressErrors) {
        var s3 = new SyntaxError(t2, this.filename, this.lexer.yylloc.first_line);
        throw s3.lineNumber = this.lexer.yylloc.first_line, s3.fileName = this.filename, s3.columnNumber = this.lexer.yylloc.first_column, s3;
      }
      var r2 = this.ast.prepare("error", null, this)(t2, n2, this.lexer.yylloc.first_line, i3);
      return this._errors.push(r2), r2;
    }, $.prototype.error = function(t2) {
      var e2 = "Parse Error : syntax error", i3 = this.getTokenName(this.token), n2 = "";
      if (this.token !== this.EOF) {
        if (j(this.token)) {
          var s3 = this.text();
          s3.length > 10 && (s3 = s3.substring(0, 7) + "..."), i3 = "'" + s3 + "' (" + i3 + ")";
        }
        e2 += ", unexpected " + i3;
      }
      return t2 && !Array.isArray(t2) && ((j(t2) || 1 === t2.length) && (n2 = ", expecting " + this.getTokenName(t2)), e2 += n2), this.raiseError(e2, n2, t2, i3);
    }, $.prototype.position = function() {
      return new b2(this.lexer.yylloc.first_line, this.lexer.yylloc.first_column, this.lexer.yylloc.first_offset);
    }, $.prototype.node = function(t2) {
      if (this.extractDoc) {
        var e2 = null;
        this._docIndex < this._docs.length && (e2 = this._docs.slice(this._docIndex), this._docIndex = this._docs.length, this.debug && (console.log(new Error("Append docs on " + t2)), console.log(e2)));
        var i3 = this.ast.prepare(t2, e2, this);
        return i3.postBuild = function(t3) {
          if (this._docIndex < this._docs.length)
            if (this._lastNode) {
              for (var e3 = this.prev[2], i4 = this._docIndex; i4 < this._docs.length && !(this._docs[i4].offset > e3); i4++)
                ;
              i4 > this._docIndex && (this._lastNode.setTrailingComments(this._docs.slice(this._docIndex, i4)), this._docIndex = i4);
            } else
              this.token === this.EOF && (t3.setTrailingComments(this._docs.slice(this._docIndex)), this._docIndex = this._docs.length);
          this._lastNode = t3;
        }.bind(this), i3;
      }
      return this.ast.prepare(t2, null, this);
    }, $.prototype.expectEndOfStatement = function(t2) {
      if (";" === this.token)
        t2 && ";" === this.lexer.yytext && t2.includeToken(this);
      else if (this.token !== this.tok.T_INLINE_HTML && this.token !== this.EOF)
        return this.error(";"), false;
      return this.next(), true;
    };
    var z = ["parser.next", "parser.node", "parser.showlog"];
    $.prototype.showlog = function() {
      for (var t2, e2 = new Error().stack.split("\n"), i3 = 2; i3 < e2.length; i3++) {
        t2 = e2[i3].trim();
        for (var n2 = false, s3 = 0; s3 < z.length; s3++)
          if (t2.substring(3, 3 + z[s3].length) === z[s3]) {
            n2 = true;
            break;
          }
        if (!n2)
          break;
      }
      return console.log("Line " + this.lexer.yylloc.first_line + " : " + this.getTokenName(this.token) + ">" + this.lexer.yytext + "< @-->" + t2), this;
    }, $.prototype.expect = function(t2) {
      if (Array.isArray(t2)) {
        if (-1 === t2.indexOf(this.token))
          return this.error(t2), false;
      } else if (this.token != t2)
        return this.error(t2), false;
      return true;
    }, $.prototype.text = function() {
      return this.lexer.yytext;
    }, $.prototype.next = function() {
      if (";" === this.token && ";" !== this.lexer.yytext || (this.prev = [this.lexer.yylloc.last_line, this.lexer.yylloc.last_column, this.lexer.offset]), this.lex(), this.debug && this.showlog(), this.extractDoc)
        for (; this.token === this.tok.T_COMMENT || this.token === this.tok.T_DOC_COMMENT; )
          this.token === this.tok.T_COMMENT ? this._docs.push(this.read_comment()) : this._docs.push(this.read_doc_comment());
      return this;
    }, $.prototype.peek = function() {
      var t2 = this.lexer.getState(), e2 = this.lexer.lex();
      return this.lexer.setState(t2), e2;
    }, $.prototype.lex = function() {
      if (this.extractTokens)
        do {
          if (this.token = this.lexer.lex() || this.EOF, this.token === this.EOF)
            return this;
          var t2 = this.lexer.yytext;
          if (t2 = Object.prototype.hasOwnProperty.call(this.lexer.engine.tokens.values, this.token) ? [this.lexer.engine.tokens.values[this.token], t2, this.lexer.yylloc.first_line, this.lexer.yylloc.first_offset, this.lexer.offset] : [null, t2, this.lexer.yylloc.first_line, this.lexer.yylloc.first_offset, this.lexer.offset], this._tokens.push(t2), this.token === this.tok.T_CLOSE_TAG)
            return this.token = ";", this;
          if (this.token === this.tok.T_OPEN_TAG_WITH_ECHO)
            return this.token = this.tok.T_ECHO, this;
        } while (this.token === this.tok.T_WHITESPACE || !this.extractDoc && (this.token === this.tok.T_COMMENT || this.token === this.tok.T_DOC_COMMENT) || this.token === this.tok.T_OPEN_TAG);
      else
        this.token = this.lexer.lex() || this.EOF;
      return this;
    }, $.prototype.is = function(t2) {
      return Array.isArray(t2) ? -1 !== t2.indexOf(this.token) : this.entries[t2].has(this.token);
    }, [I2, S2, O2, R, w2, D2, P, U, M2, F, H3, G, V, Q, W2, Y3].forEach(function(t2) {
      for (var e2 in t2) {
        if (Object.prototype.hasOwnProperty.call($.prototype, e2))
          throw new Error("Function " + e2 + " is already defined - collision");
        $.prototype[e2] = t2[e2];
      }
    });
    var K = $, X3 = Object.freeze({ values: { 101: "T_HALT_COMPILER", 102: "T_USE", 103: "T_ENCAPSED_AND_WHITESPACE", 104: "T_OBJECT_OPERATOR", 105: "T_STRING", 106: "T_DOLLAR_OPEN_CURLY_BRACES", 107: "T_STRING_VARNAME", 108: "T_CURLY_OPEN", 109: "T_NUM_STRING", 110: "T_ISSET", 111: "T_EMPTY", 112: "T_INCLUDE", 113: "T_INCLUDE_ONCE", 114: "T_EVAL", 115: "T_REQUIRE", 116: "T_REQUIRE_ONCE", 117: "T_NAMESPACE", 118: "T_NS_SEPARATOR", 119: "T_AS", 120: "T_IF", 121: "T_ENDIF", 122: "T_WHILE", 123: "T_DO", 124: "T_FOR", 125: "T_SWITCH", 126: "T_BREAK", 127: "T_CONTINUE", 128: "T_RETURN", 129: "T_GLOBAL", 130: "T_STATIC", 131: "T_ECHO", 132: "T_INLINE_HTML", 133: "T_UNSET", 134: "T_FOREACH", 135: "T_DECLARE", 136: "T_TRY", 137: "T_THROW", 138: "T_GOTO", 139: "T_FINALLY", 140: "T_CATCH", 141: "T_ENDDECLARE", 142: "T_LIST", 143: "T_CLONE", 144: "T_PLUS_EQUAL", 145: "T_MINUS_EQUAL", 146: "T_MUL_EQUAL", 147: "T_DIV_EQUAL", 148: "T_CONCAT_EQUAL", 149: "T_MOD_EQUAL", 150: "T_AND_EQUAL", 151: "T_OR_EQUAL", 152: "T_XOR_EQUAL", 153: "T_SL_EQUAL", 154: "T_SR_EQUAL", 155: "T_INC", 156: "T_DEC", 157: "T_BOOLEAN_OR", 158: "T_BOOLEAN_AND", 159: "T_LOGICAL_OR", 160: "T_LOGICAL_AND", 161: "T_LOGICAL_XOR", 162: "T_SL", 163: "T_SR", 164: "T_IS_IDENTICAL", 165: "T_IS_NOT_IDENTICAL", 166: "T_IS_EQUAL", 167: "T_IS_NOT_EQUAL", 168: "T_IS_SMALLER_OR_EQUAL", 169: "T_IS_GREATER_OR_EQUAL", 170: "T_INSTANCEOF", 171: "T_INT_CAST", 172: "T_DOUBLE_CAST", 173: "T_STRING_CAST", 174: "T_ARRAY_CAST", 175: "T_OBJECT_CAST", 176: "T_BOOL_CAST", 177: "T_UNSET_CAST", 178: "T_EXIT", 179: "T_PRINT", 180: "T_YIELD", 181: "T_YIELD_FROM", 182: "T_FUNCTION", 183: "T_DOUBLE_ARROW", 184: "T_DOUBLE_COLON", 185: "T_ARRAY", 186: "T_CALLABLE", 187: "T_CLASS", 188: "T_ABSTRACT", 189: "T_TRAIT", 190: "T_FINAL", 191: "T_EXTENDS", 192: "T_INTERFACE", 193: "T_IMPLEMENTS", 194: "T_VAR", 195: "T_PUBLIC", 196: "T_PROTECTED", 197: "T_PRIVATE", 198: "T_CONST", 199: "T_NEW", 200: "T_INSTEADOF", 201: "T_ELSEIF", 202: "T_ELSE", 203: "T_ENDSWITCH", 204: "T_CASE", 205: "T_DEFAULT", 206: "T_ENDFOR", 207: "T_ENDFOREACH", 208: "T_ENDWHILE", 209: "T_CONSTANT_ENCAPSED_STRING", 210: "T_LNUMBER", 211: "T_DNUMBER", 212: "T_LINE", 213: "T_FILE", 214: "T_DIR", 215: "T_TRAIT_C", 216: "T_METHOD_C", 217: "T_FUNC_C", 218: "T_NS_C", 219: "T_START_HEREDOC", 220: "T_END_HEREDOC", 221: "T_CLASS_C", 222: "T_VARIABLE", 223: "T_OPEN_TAG", 224: "T_OPEN_TAG_WITH_ECHO", 225: "T_CLOSE_TAG", 226: "T_WHITESPACE", 227: "T_COMMENT", 228: "T_DOC_COMMENT", 229: "T_ELLIPSIS", 230: "T_COALESCE", 231: "T_POW", 232: "T_POW_EQUAL", 233: "T_SPACESHIP", 234: "T_COALESCE_EQUAL", 235: "T_FN", 236: "T_NULLSAFE_OBJECT_OPERATOR", 237: "T_MATCH", 238: "T_ATTRIBUTE", 239: "T_ENUM", 240: "T_READ_ONLY", 241: "T_NAME_RELATIVE", 242: "T_NAME_QUALIFIED", 243: "T_NAME_FULLY_QUALIFIED" }, names: { T_HALT_COMPILER: 101, T_USE: 102, T_ENCAPSED_AND_WHITESPACE: 103, T_OBJECT_OPERATOR: 104, T_STRING: 105, T_DOLLAR_OPEN_CURLY_BRACES: 106, T_STRING_VARNAME: 107, T_CURLY_OPEN: 108, T_NUM_STRING: 109, T_ISSET: 110, T_EMPTY: 111, T_INCLUDE: 112, T_INCLUDE_ONCE: 113, T_EVAL: 114, T_REQUIRE: 115, T_REQUIRE_ONCE: 116, T_NAMESPACE: 117, T_NS_SEPARATOR: 118, T_AS: 119, T_IF: 120, T_ENDIF: 121, T_WHILE: 122, T_DO: 123, T_FOR: 124, T_SWITCH: 125, T_BREAK: 126, T_CONTINUE: 127, T_RETURN: 128, T_GLOBAL: 129, T_STATIC: 130, T_ECHO: 131, T_INLINE_HTML: 132, T_UNSET: 133, T_FOREACH: 134, T_DECLARE: 135, T_TRY: 136, T_THROW: 137, T_GOTO: 138, T_FINALLY: 139, T_CATCH: 140, T_ENDDECLARE: 141, T_LIST: 142, T_CLONE: 143, T_PLUS_EQUAL: 144, T_MINUS_EQUAL: 145, T_MUL_EQUAL: 146, T_DIV_EQUAL: 147, T_CONCAT_EQUAL: 148, T_MOD_EQUAL: 149, T_AND_EQUAL: 150, T_OR_EQUAL: 151, T_XOR_EQUAL: 152, T_SL_EQUAL: 153, T_SR_EQUAL: 154, T_INC: 155, T_DEC: 156, T_BOOLEAN_OR: 157, T_BOOLEAN_AND: 158, T_LOGICAL_OR: 159, T_LOGICAL_AND: 160, T_LOGICAL_XOR: 161, T_SL: 162, T_SR: 163, T_IS_IDENTICAL: 164, T_IS_NOT_IDENTICAL: 165, T_IS_EQUAL: 166, T_IS_NOT_EQUAL: 167, T_IS_SMALLER_OR_EQUAL: 168, T_IS_GREATER_OR_EQUAL: 169, T_INSTANCEOF: 170, T_INT_CAST: 171, T_DOUBLE_CAST: 172, T_STRING_CAST: 173, T_ARRAY_CAST: 174, T_OBJECT_CAST: 175, T_BOOL_CAST: 176, T_UNSET_CAST: 177, T_EXIT: 178, T_PRINT: 179, T_YIELD: 180, T_YIELD_FROM: 181, T_FUNCTION: 182, T_DOUBLE_ARROW: 183, T_DOUBLE_COLON: 184, T_ARRAY: 185, T_CALLABLE: 186, T_CLASS: 187, T_ABSTRACT: 188, T_TRAIT: 189, T_FINAL: 190, T_EXTENDS: 191, T_INTERFACE: 192, T_IMPLEMENTS: 193, T_VAR: 194, T_PUBLIC: 195, T_PROTECTED: 196, T_PRIVATE: 197, T_CONST: 198, T_NEW: 199, T_INSTEADOF: 200, T_ELSEIF: 201, T_ELSE: 202, T_ENDSWITCH: 203, T_CASE: 204, T_DEFAULT: 205, T_ENDFOR: 206, T_ENDFOREACH: 207, T_ENDWHILE: 208, T_CONSTANT_ENCAPSED_STRING: 209, T_LNUMBER: 210, T_DNUMBER: 211, T_LINE: 212, T_FILE: 213, T_DIR: 214, T_TRAIT_C: 215, T_METHOD_C: 216, T_FUNC_C: 217, T_NS_C: 218, T_START_HEREDOC: 219, T_END_HEREDOC: 220, T_CLASS_C: 221, T_VARIABLE: 222, T_OPEN_TAG: 223, T_OPEN_TAG_WITH_ECHO: 224, T_CLOSE_TAG: 225, T_WHITESPACE: 226, T_COMMENT: 227, T_DOC_COMMENT: 228, T_ELLIPSIS: 229, T_COALESCE: 230, T_POW: 231, T_POW_EQUAL: 232, T_SPACESHIP: 233, T_COALESCE_EQUAL: 234, T_FN: 235, T_NULLSAFE_OBJECT_OPERATOR: 236, T_MATCH: 237, T_ATTRIBUTE: 238, T_ENUM: 239, T_READ_ONLY: 240, T_NAME_RELATIVE: 241, T_NAME_QUALIFIED: 242, T_NAME_FULLY_QUALIFIED: 243 } }), J2 = function(t2, e2, i3) {
      this.source = t2, this.start = e2, this.end = i3;
    }, q = function(t2, e2, i3) {
      this.kind = t2, e2 && (this.leadingComments = e2), i3 && (this.loc = i3);
    };
    q.prototype.setTrailingComments = function(t2) {
      this.trailingComments = t2;
    }, q.prototype.destroy = function(t2) {
      if (!t2)
        throw new Error("Node already initialized, you must swap with another node");
      return this.leadingComments && (t2.leadingComments ? t2.leadingComments = Array.concat(this.leadingComments, t2.leadingComments) : t2.leadingComments = this.leadingComments), this.trailingComments && (t2.trailingComments ? t2.trailingComments = Array.concat(this.trailingComments, t2.trailingComments) : t2.trailingComments = this.trailingComments), t2;
    }, q.prototype.includeToken = function(t2) {
      return this.loc && (this.loc.end && (this.loc.end.line = t2.lexer.yylloc.last_line, this.loc.end.column = t2.lexer.yylloc.last_column, this.loc.end.offset = t2.lexer.offset), t2.ast.withSource && (this.loc.source = t2.lexer._input.substring(this.loc.start.offset, t2.lexer.offset))), this;
    }, q.extends = function(t2, e2) {
      return e2.prototype = Object.create(this.prototype), e2.extends = this.extends, e2.prototype.constructor = e2, e2.kind = t2, e2;
    };
    var Z3 = q, tt = "expression", et2 = Z3.extends(tt, function(t2, e2, i3) {
      Z3.apply(this, [t2 || tt, e2, i3]);
    }), it2 = "array", nt = et2.extends(it2, function(t2, e2, i3, n2) {
      et2.apply(this, [it2, i3, n2]), this.items = e2, this.shortForm = t2;
    }), st2 = "arrowfunc", rt2 = et2.extends(st2, function(t2, e2, i3, n2, s3, r2, o2, a4) {
      et2.apply(this, [st2, o2, a4]), this.arguments = t2, this.byref = e2, this.body = i3, this.type = n2, this.nullable = s3, this.isStatic = r2 || false;
    }), ot2 = "assign", at2 = et2.extends(ot2, function(t2, e2, i3, n2, s3) {
      et2.apply(this, [ot2, n2, s3]), this.left = t2, this.right = e2, this.operator = i3;
    }), ht2 = "assignref", lt2 = et2.extends(ht2, function(t2, e2, i3, n2) {
      et2.apply(this, [ht2, i3, n2]), this.left = t2, this.right = e2;
    }), ct2 = "attribute", ut2 = Z3.extends(ct2, function(t2, e2, i3, n2) {
      Z3.apply(this, [ct2, i3, n2]), this.name = t2, this.args = e2;
    }), _t2 = "attrgroup", dt2 = Z3.extends(_t2, function(t2, e2, i3) {
      Z3.apply(this, [_t2, e2, i3]), this.attrs = t2 || [];
    }), pt2 = "operation", ft2 = et2.extends(pt2, function(t2, e2, i3) {
      et2.apply(this, [t2 || pt2, e2, i3]);
    }), Tt2 = ft2.extends("bin", function(t2, e2, i3, n2, s3) {
      ft2.apply(this, ["bin", n2, s3]), this.type = t2, this.left = e2, this.right = i3;
    }), kt2 = "statement", Et2 = Z3.extends(kt2, function(t2, e2, i3) {
      Z3.apply(this, [t2 || kt2, e2, i3]);
    }), mt2 = "block", xt2 = Et2.extends(mt2, function(t2, e2, i3, n2) {
      Et2.apply(this, [t2 || mt2, i3, n2]), this.children = e2.filter(Boolean);
    }), yt2 = "literal", vt2 = et2.extends(yt2, function(t2, e2, i3, n2, s3) {
      et2.apply(this, [t2 || yt2, n2, s3]), this.value = e2, i3 && (this.raw = i3);
    }), At2 = "boolean", gt2 = vt2.extends(At2, function(t2, e2, i3, n2) {
      vt2.apply(this, [At2, t2, e2, i3, n2]);
    }), Nt2 = "break", Lt2 = Et2.extends(Nt2, function(t2, e2, i3) {
      Et2.apply(this, [Nt2, e2, i3]), this.level = t2;
    }), Ct2 = "byref", bt2 = et2.extends(Ct2, function(t2, e2, i3) {
      et2.apply(this, [Ct2, e2, i3]), this.what = t2;
    }), It2 = "call", St2 = et2.extends(It2, function(t2, e2, i3, n2) {
      et2.apply(this, [It2, i3, n2]), this.what = t2, this.arguments = e2;
    }), Ot2 = "case", Rt2 = Et2.extends(Ot2, function(t2, e2, i3, n2) {
      Et2.apply(this, [Ot2, i3, n2]), this.test = t2, this.body = e2;
    }), wt2 = "cast", Dt2 = ft2.extends(wt2, function(t2, e2, i3, n2, s3) {
      ft2.apply(this, [wt2, n2, s3]), this.type = t2, this.raw = e2, this.expr = i3;
    }), Pt2 = "catch", Ut2 = Et2.extends(Pt2, function(t2, e2, i3, n2, s3) {
      Et2.apply(this, [Pt2, n2, s3]), this.body = t2, this.what = e2, this.variable = i3;
    }), Mt2 = "declaration", Ft2 = Et2.extends(Mt2, function(t2, e2, i3, n2) {
      Et2.apply(this, [t2 || Mt2, i3, n2]), this.name = e2;
    });
    Ft2.prototype.parseFlags = function(t2) {
      this.isAbstract = 1 === t2[2], this.isFinal = 2 === t2[2], "class" !== this.kind && (-1 === t2[0] ? this.visibility = "" : null === t2[0] ? this.visibility = null : 0 === t2[0] ? this.visibility = "public" : 1 === t2[0] ? this.visibility = "protected" : 2 === t2[0] && (this.visibility = "private"), this.isStatic = 1 === t2[1]);
    };
    var Bt = Ft2, Ht2 = "class", Gt2 = Bt.extends(Ht2, function(t2, e2, i3, n2, s3, r2, o2) {
      Bt.apply(this, [Ht2, t2, r2, o2]), this.isAnonymous = !t2, this.extends = e2, this.implements = i3, this.body = n2, this.attrGroups = [], this.parseFlags(s3);
    }), Vt = "constantstatement", Qt2 = Et2.extends(Vt, function(t2, e2, i3, n2) {
      Et2.apply(this, [t2 || Vt, i3, n2]), this.constants = e2;
    }), Wt2 = "classconstant", Yt2 = Qt2.extends(Wt2, function(t2, e2, i3, n2, s3, r2) {
      Qt2.apply(this, [t2 || Wt2, e2, s3, r2]), this.parseFlags(i3), this.attrGroups = n2;
    });
    Yt2.prototype.parseFlags = function(t2) {
      -1 === t2[0] ? this.visibility = "" : null === t2[0] ? this.visibility = null : 0 === t2[0] ? this.visibility = "public" : 1 === t2[0] ? this.visibility = "protected" : 2 === t2[0] && (this.visibility = "private");
    };
    var jt2 = Yt2, $t = "clone", zt2 = et2.extends($t, function(t2, e2, i3) {
      et2.apply(this, [$t, e2, i3]), this.what = t2;
    }), Kt2 = "closure", Xt2 = et2.extends(Kt2, function(t2, e2, i3, n2, s3, r2, o2, a4) {
      et2.apply(this, [Kt2, o2, a4]), this.uses = i3, this.arguments = t2, this.byref = e2, this.type = n2, this.nullable = s3, this.isStatic = r2 || false, this.body = null, this.attrGroups = [];
    }), Jt2 = Z3.extends("comment", function(t2, e2, i3, n2) {
      Z3.apply(this, [t2, i3, n2]), this.value = e2;
    }), qt2 = "commentblock", Zt = Jt2.extends(qt2, function(t2, e2, i3) {
      Jt2.apply(this, [qt2, t2, e2, i3]);
    }), te2 = "commentline", ee2 = Jt2.extends(te2, function(t2, e2, i3) {
      Jt2.apply(this, [te2, t2, e2, i3]);
    }), ie = "constant", ne = Z3.extends(ie, function(t2, e2, i3, n2) {
      Z3.apply(this, [ie, i3, n2]), this.name = t2, this.value = e2;
    }), se = "continue", re2 = Et2.extends(se, function(t2, e2, i3) {
      Et2.apply(this, [se, e2, i3]), this.level = t2;
    }), oe2 = "declare", ae2 = xt2.extends(oe2, function(t2, e2, i3, n2, s3) {
      xt2.apply(this, [oe2, e2, n2, s3]), this.directives = t2, this.mode = i3;
    });
    ae2.MODE_SHORT = "short", ae2.MODE_BLOCK = "block", ae2.MODE_NONE = "none";
    var he2 = ae2, le2 = "declaredirective", ce = Z3.extends(le2, function(t2, e2, i3, n2) {
      Z3.apply(this, [le2, i3, n2]), this.key = t2, this.value = e2;
    }), ue2 = Et2.extends("do", function(t2, e2, i3, n2) {
      Et2.apply(this, ["do", i3, n2]), this.test = t2, this.body = e2;
    }), _e2 = "echo", de2 = Et2.extends(_e2, function(t2, e2, i3, n2) {
      Et2.apply(this, [_e2, i3, n2]), this.shortForm = e2, this.expressions = t2;
    }), pe = "empty", fe2 = et2.extends(pe, function(t2, e2, i3) {
      et2.apply(this, [pe, e2, i3]), this.expression = t2;
    }), Te2 = "encapsed", ke2 = vt2.extends(Te2, function(t2, e2, i3, n2, s3) {
      vt2.apply(this, [Te2, t2, e2, n2, s3]), this.type = i3;
    });
    ke2.TYPE_STRING = "string", ke2.TYPE_SHELL = "shell", ke2.TYPE_HEREDOC = "heredoc", ke2.TYPE_OFFSET = "offset";
    var Ee = ke2, me2 = "encapsedpart", xe2 = et2.extends(me2, function(t2, e2, i3, n2, s3) {
      et2.apply(this, [me2, n2, s3]), this.expression = t2, this.syntax = e2, this.curly = i3;
    }), ye2 = "entry", ve2 = et2.extends(ye2, function(t2, e2, i3, n2, s3, r2) {
      et2.apply(this, [ye2, s3, r2]), this.key = t2, this.value = e2, this.byRef = i3, this.unpack = n2;
    }), Ae2 = "enum", ge2 = Bt.extends(Ae2, function(t2, e2, i3, n2, s3, r2) {
      Bt.apply(this, [Ae2, t2, s3, r2]), this.valueType = e2, this.implements = i3, this.body = n2, this.attrGroups = [];
    }), Ne2 = "enumcase", Le2 = Z3.extends(Ne2, function(t2, e2, i3, n2) {
      Z3.apply(this, [Ne2, i3, n2]), this.name = t2, this.value = e2;
    }), Ce2 = "error", be2 = Z3.extends(Ce2, function(t2, e2, i3, n2, s3, r2) {
      Z3.apply(this, [Ce2, s3, r2]), this.message = t2, this.token = e2, this.line = i3, this.expected = n2;
    }), Ie2 = "eval", Se2 = et2.extends(Ie2, function(t2, e2, i3) {
      et2.apply(this, [Ie2, e2, i3]), this.source = t2;
    }), Oe2 = "exit", Re2 = et2.extends(Oe2, function(t2, e2, i3, n2) {
      et2.apply(this, [Oe2, i3, n2]), this.expression = t2, this.useDie = e2;
    }), we2 = "expressionstatement", De2 = Et2.extends(we2, function(t2, e2, i3) {
      Et2.apply(this, [we2, e2, i3]), this.expression = t2;
    }), Pe2 = Et2.extends("for", function(t2, e2, i3, n2, s3, r2, o2) {
      Et2.apply(this, ["for", r2, o2]), this.init = t2, this.test = e2, this.increment = i3, this.shortForm = s3, this.body = n2;
    }), Ue2 = "foreach", Me2 = Et2.extends(Ue2, function(t2, e2, i3, n2, s3, r2, o2) {
      Et2.apply(this, [Ue2, r2, o2]), this.source = t2, this.key = e2, this.value = i3, this.shortForm = s3, this.body = n2;
    }), Fe2 = "function", Be = Bt.extends(Fe2, function(t2, e2, i3, n2, s3, r2, o2) {
      Bt.apply(this, [Fe2, t2, r2, o2]), this.arguments = e2, this.byref = i3, this.type = n2, this.nullable = s3, this.body = null, this.attrGroups = [];
    }), He2 = "global", Ge2 = Et2.extends(He2, function(t2, e2, i3) {
      Et2.apply(this, [He2, e2, i3]), this.items = t2;
    }), Ve2 = "goto", Qe = Et2.extends(Ve2, function(t2, e2, i3) {
      Et2.apply(this, [Ve2, e2, i3]), this.label = t2;
    }), We2 = "halt", Ye2 = Et2.extends(We2, function(t2, e2, i3) {
      Et2.apply(this, [We2, e2, i3]), this.after = t2;
    }), je2 = "identifier", $e2 = Z3.extends(je2, function(t2, e2, i3) {
      Z3.apply(this, [je2, e2, i3]), this.name = t2;
    }), ze = $e2, Ke2 = Et2.extends("if", function(t2, e2, i3, n2, s3, r2) {
      Et2.apply(this, ["if", s3, r2]), this.test = t2, this.body = e2, this.alternate = i3, this.shortForm = n2;
    }), Xe2 = "include", Je2 = et2.extends(Xe2, function(t2, e2, i3, n2, s3) {
      et2.apply(this, [Xe2, n2, s3]), this.once = t2, this.require = e2, this.target = i3;
    }), qe2 = "inline", Ze2 = vt2.extends(qe2, function(t2, e2, i3, n2) {
      vt2.apply(this, [qe2, t2, e2, i3, n2]);
    }), ti2 = "interface", ei = Bt.extends(ti2, function(t2, e2, i3, n2, s3, r2) {
      Bt.apply(this, [ti2, t2, s3, r2]), this.extends = e2, this.body = i3, this.attrGroups = n2;
    }), ii = "intersectiontype", ni2 = Bt.extends(ii, function(t2, e2, i3) {
      Bt.apply(this, [ii, null, e2, i3]), this.types = t2;
    }), si2 = "isset", ri = et2.extends(si2, function(t2, e2, i3) {
      et2.apply(this, [si2, e2, i3]), this.variables = t2;
    }), oi = "label", ai2 = Et2.extends(oi, function(t2, e2, i3) {
      Et2.apply(this, [oi, e2, i3]), this.name = t2;
    }), hi = "list", li2 = et2.extends(hi, function(t2, e2, i3, n2) {
      et2.apply(this, [hi, i3, n2]), this.items = t2, this.shortForm = e2;
    }), ci2 = "lookup", ui = et2.extends(ci2, function(t2, e2, i3, n2, s3) {
      et2.apply(this, [t2 || ci2, n2, s3]), this.what = e2, this.offset = i3;
    }), _i = "magic", di2 = vt2.extends(_i, function(t2, e2, i3, n2) {
      vt2.apply(this, [_i, t2, e2, i3, n2]);
    }), pi = "match", fi2 = et2.extends(pi, function(t2, e2, i3, n2) {
      et2.apply(this, [pi, i3, n2]), this.cond = t2, this.arms = e2;
    }), Ti = "matcharm", ki = et2.extends(Ti, function(t2, e2, i3, n2) {
      et2.apply(this, [Ti, i3, n2]), this.conds = t2, this.body = e2;
    }), Ei2 = "method", mi = Be.extends(Ei2, function() {
      Be.apply(this, arguments), this.kind = Ei2;
    }), xi = "reference", yi2 = Z3.extends(xi, function(t2, e2, i3) {
      Z3.apply(this, [t2 || xi, e2, i3]);
    }), vi2 = "name", Ai2 = yi2.extends(vi2, function(t2, e2, i3, n2) {
      yi2.apply(this, [vi2, i3, n2]), this.name = t2.replace(/\\$/, ""), this.resolution = e2;
    });
    Ai2.UNQUALIFIED_NAME = "uqn", Ai2.QUALIFIED_NAME = "qn", Ai2.FULL_QUALIFIED_NAME = "fqn", Ai2.RELATIVE_NAME = "rn";
    var gi2 = Ai2, Ni2 = "namespace", Li = xt2.extends(Ni2, function(t2, e2, i3, n2, s3) {
      xt2.apply(this, [Ni2, e2, n2, s3]), this.name = t2, this.withBrackets = i3 || false;
    }), Ci = "namedargument", bi2 = et2.extends(Ci, function(t2, e2, i3, n2) {
      et2.apply(this, [Ci, i3, n2]), this.name = t2, this.value = e2;
    }), Ii2 = et2.extends("new", function(t2, e2, i3, n2) {
      et2.apply(this, ["new", i3, n2]), this.what = t2, this.arguments = e2;
    }), Si2 = "noop", Oi2 = Z3.extends(Si2, function(t2, e2) {
      Z3.apply(this, [Si2, t2, e2]);
    }), Ri2 = "nowdoc", wi = vt2.extends(Ri2, function(t2, e2, i3, n2, s3) {
      vt2.apply(this, [Ri2, t2, e2, n2, s3]), this.label = i3;
    }), Di2 = "nullkeyword", Pi2 = Z3.extends(Di2, function(t2, e2, i3) {
      Z3.apply(this, [Di2, e2, i3]), this.raw = t2;
    }), Ui2 = "nullsafepropertylookup", Mi2 = ui.extends(Ui2, function(t2, e2, i3, n2) {
      ui.apply(this, [Ui2, t2, e2, i3, n2]);
    }), Fi = "number", Bi2 = vt2.extends(Fi, function(t2, e2, i3, n2) {
      vt2.apply(this, [Fi, t2, e2, i3, n2]);
    }), Hi = "offsetlookup", Gi2 = ui.extends(Hi, function(t2, e2, i3, n2) {
      ui.apply(this, [Hi, t2, e2, i3, n2]);
    }), Vi = "parameter", Qi2 = Bt.extends(Vi, function(t2, e2, i3, n2, s3, r2, o2, a4, h3, l2) {
      Bt.apply(this, [Vi, t2, h3, l2]), this.value = i3, this.type = e2, this.byref = n2, this.variadic = s3, this.readonly = r2, this.nullable = o2, this.flags = a4 || 0, this.attrGroups = [];
    }), Wi = "parentreference", Yi2 = yi2.extends(Wi, function(t2, e2, i3) {
      yi2.apply(this, [Wi, e2, i3]), this.raw = t2;
    }), ji2 = "post", $i2 = ft2.extends(ji2, function(t2, e2, i3, n2) {
      ft2.apply(this, [ji2, i3, n2]), this.type = t2, this.what = e2;
    }), zi2 = ft2.extends("pre", function(t2, e2, i3, n2) {
      ft2.apply(this, ["pre", i3, n2]), this.type = t2, this.what = e2;
    }), Ki2 = "print", Xi = et2.extends(Ki2, function(t2, e2, i3) {
      et2.apply(this, [Ki2, e2, i3]), this.expression = t2;
    }), Ji2 = "program", qi = xt2.extends(Ji2, function(t2, e2, i3, n2, s3, r2) {
      xt2.apply(this, [Ji2, t2, s3, r2]), this.errors = e2, i3 && (this.comments = i3), n2 && (this.tokens = n2);
    }), Zi2 = "property", tn = Et2.extends(Zi2, function(t2, e2, i3, n2, s3, r2, o2, a4) {
      Et2.apply(this, [Zi2, o2, a4]), this.name = t2, this.value = e2, this.readonly = i3, this.nullable = n2, this.type = s3, this.attrGroups = r2;
    }), en2 = "propertylookup", nn2 = ui.extends(en2, function(t2, e2, i3, n2) {
      ui.apply(this, [en2, t2, e2, i3, n2]);
    }), sn2 = "propertystatement", rn2 = Et2.extends(sn2, function(t2, e2, i3, n2, s3) {
      Et2.apply(this, [sn2, n2, s3]), this.properties = e2, this.parseFlags(i3);
    });
    rn2.prototype.parseFlags = function(t2) {
      -1 === t2[0] ? this.visibility = "" : null === t2[0] ? this.visibility = null : 0 === t2[0] ? this.visibility = "public" : 1 === t2[0] ? this.visibility = "protected" : 2 === t2[0] && (this.visibility = "private"), this.isStatic = 1 === t2[1];
    };
    var on2 = rn2, an2 = "retif", hn2 = et2.extends(an2, function(t2, e2, i3, n2, s3) {
      et2.apply(this, [an2, n2, s3]), this.test = t2, this.trueExpr = e2, this.falseExpr = i3;
    }), ln = "return", cn = Et2.extends(ln, function(t2, e2, i3) {
      Et2.apply(this, [ln, e2, i3]), this.expr = t2;
    }), un2 = "selfreference", _n2 = yi2.extends(un2, function(t2, e2, i3) {
      yi2.apply(this, [un2, e2, i3]), this.raw = t2;
    }), dn2 = "silent", pn2 = et2.extends(dn2, function(t2, e2, i3) {
      et2.apply(this, [dn2, e2, i3]), this.expr = t2;
    }), fn2 = "static", Tn2 = Et2.extends(fn2, function(t2, e2, i3) {
      Et2.apply(this, [fn2, e2, i3]), this.variables = t2;
    }), kn2 = "staticvariable", En2 = Z3.extends(kn2, function(t2, e2, i3, n2) {
      Z3.apply(this, [kn2, i3, n2]), this.variable = t2, this.defaultValue = e2;
    }), mn2 = "staticlookup", xn2 = ui.extends(mn2, function(t2, e2, i3, n2) {
      ui.apply(this, [mn2, t2, e2, i3, n2]);
    }), yn2 = "staticreference", vn2 = yi2.extends(yn2, function(t2, e2, i3) {
      yi2.apply(this, [yn2, e2, i3]), this.raw = t2;
    }), An2 = "string", gn2 = vt2.extends(An2, function(t2, e2, i3, n2, s3, r2) {
      vt2.apply(this, [An2, e2, n2, s3, r2]), this.unicode = i3, this.isDoubleQuote = t2;
    }), Nn2 = "switch", Ln2 = Et2.extends(Nn2, function(t2, e2, i3, n2, s3) {
      Et2.apply(this, [Nn2, n2, s3]), this.test = t2, this.body = e2, this.shortForm = i3;
    }), Cn2 = "throw", bn2 = Et2.extends(Cn2, function(t2, e2, i3) {
      Et2.apply(this, [Cn2, e2, i3]), this.what = t2;
    }), In2 = "trait", Sn2 = Bt.extends(In2, function(t2, e2, i3, n2) {
      Bt.apply(this, [In2, t2, i3, n2]), this.body = e2;
    }), On2 = "traitalias", Rn2 = Z3.extends(On2, function(t2, e2, i3, n2, s3, r2) {
      Z3.apply(this, [On2, s3, r2]), this.trait = t2, this.method = e2, this.as = i3, this.visibility = "", n2 && (0 === n2[0] ? this.visibility = "public" : 1 === n2[0] ? this.visibility = "protected" : 2 === n2[0] && (this.visibility = "private"));
    }), wn2 = "traitprecedence", Dn = Z3.extends(wn2, function(t2, e2, i3, n2, s3) {
      Z3.apply(this, [wn2, n2, s3]), this.trait = t2, this.method = e2, this.instead = i3;
    }), Pn2 = "traituse", Un2 = Z3.extends(Pn2, function(t2, e2, i3, n2) {
      Z3.apply(this, [Pn2, i3, n2]), this.traits = t2, this.adaptations = e2;
    }), Mn2 = Et2.extends("try", function(t2, e2, i3, n2, s3) {
      Et2.apply(this, ["try", n2, s3]), this.body = t2, this.catches = e2, this.always = i3;
    }), Fn2 = "typereference", Bn2 = yi2.extends(Fn2, function(t2, e2, i3, n2) {
      yi2.apply(this, [Fn2, i3, n2]), this.name = t2, this.raw = e2;
    });
    Bn2.types = ["int", "float", "string", "bool", "object", "array", "callable", "iterable", "void", "static"];
    var Hn2 = Bn2, Gn2 = "unary", Vn2 = ft2.extends(Gn2, function(t2, e2, i3, n2) {
      ft2.apply(this, [Gn2, i3, n2]), this.type = t2, this.what = e2;
    }), Qn2 = "uniontype", Wn2 = Bt.extends(Qn2, function(t2, e2, i3) {
      Bt.apply(this, [Qn2, null, e2, i3]), this.types = t2;
    }), Yn2 = "unset", jn2 = Et2.extends(Yn2, function(t2, e2, i3) {
      Et2.apply(this, [Yn2, e2, i3]), this.variables = t2;
    }), $n2 = "usegroup", zn2 = Et2.extends($n2, function(t2, e2, i3, n2, s3) {
      Et2.apply(this, [$n2, n2, s3]), this.name = t2, this.type = e2, this.items = i3;
    }), Kn2 = "useitem", Xn2 = Et2.extends(Kn2, function(t2, e2, i3, n2, s3) {
      Et2.apply(this, [Kn2, n2, s3]), this.name = t2, this.alias = e2, this.type = i3;
    });
    Xn2.TYPE_CONST = "const", Xn2.TYPE_FUNCTION = "function";
    var Jn2 = Xn2, qn2 = "variable", Zn2 = et2.extends(qn2, function(t2, e2, i3, n2) {
      et2.apply(this, [qn2, i3, n2]), this.name = t2, this.curly = e2 || false;
    }), ts2 = "variadic", es2 = et2.extends(ts2, function(t2, e2, i3) {
      et2.apply(this, [ts2, e2, i3]), this.what = t2;
    }), is2 = "variadicplaceholder", ns2 = Z3.extends(is2, function(t2, e2) {
      Z3.apply(this, [is2, t2, e2]);
    }), ss3 = "while", rs2 = Et2.extends(ss3, function(t2, e2, i3, n2, s3) {
      Et2.apply(this, [ss3, n2, s3]), this.test = t2, this.body = e2, this.shortForm = i3;
    }), os2 = "yield", as2 = et2.extends(os2, function(t2, e2, i3, n2) {
      et2.apply(this, [os2, i3, n2]), this.value = t2, this.key = e2;
    }), hs2 = "yieldfrom", ls2 = et2.extends(hs2, function(t2, e2, i3) {
      et2.apply(this, [hs2, e2, i3]), this.value = t2;
    }), cs2 = function(t2, e2) {
      this.withPositions = t2, this.withSource = e2;
    };
    cs2.precedence = {}, [["or"], ["xor"], ["and"], ["="], ["?"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "!=", "===", "!==", "<=>"], ["<", "<=", ">", ">="], ["<<", ">>"], ["+", "-", "."], ["*", "/", "%"], ["!"], ["instanceof"], ["cast", "silent"], ["**"]].forEach(function(t2, e2) {
      t2.forEach(function(t3) {
        cs2.precedence[t3] = e2 + 1;
      });
    }), cs2.prototype.isRightAssociative = function(t2) {
      return "**" === t2 || "??" === t2;
    }, cs2.prototype.swapLocations = function(t2, e2, i3, n2) {
      this.withPositions && (t2.loc.start = e2.loc.start, t2.loc.end = i3.loc.end, this.withSource && (t2.loc.source = n2.lexer._input.substring(t2.loc.start.offset, t2.loc.end.offset)));
    }, cs2.prototype.resolveLocations = function(t2, e2, i3, n2) {
      this.withPositions && (t2.loc.start.offset > e2.loc.start.offset && (t2.loc.start = e2.loc.start), t2.loc.end.offset < i3.loc.end.offset && (t2.loc.end = i3.loc.end), this.withSource && (t2.loc.source = n2.lexer._input.substring(t2.loc.start.offset, t2.loc.end.offset)));
    }, cs2.prototype.resolvePrecedence = function(t2, e2) {
      var i3, n2, s3;
      return "call" === t2.kind ? this.resolveLocations(t2, t2.what, t2, e2) : "propertylookup" === t2.kind || "staticlookup" === t2.kind || "offsetlookup" === t2.kind && t2.offset ? this.resolveLocations(t2, t2.what, t2.offset, e2) : "bin" === t2.kind ? t2.right && !t2.right.parenthesizedExpression && ("bin" === t2.right.kind ? (n2 = cs2.precedence[t2.type], s3 = cs2.precedence[t2.right.type], n2 && s3 && s3 <= n2 && (t2.type !== t2.right.type || !this.isRightAssociative(t2.type)) && (i3 = t2.right, t2.right = t2.right.left, this.swapLocations(t2, t2.left, t2.right, e2), i3.left = this.resolvePrecedence(t2, e2), this.swapLocations(i3, i3.left, i3.right, e2), t2 = i3)) : "retif" === t2.right.kind && (n2 = cs2.precedence[t2.type], s3 = cs2.precedence["?"], n2 && s3 && s3 <= n2 && (i3 = t2.right, t2.right = t2.right.test, this.swapLocations(t2, t2.left, t2.right, e2), i3.test = this.resolvePrecedence(t2, e2), this.swapLocations(i3, i3.test, i3.falseExpr, e2), t2 = i3))) : "silent" !== t2.kind && "cast" !== t2.kind || !t2.expr || t2.expr.parenthesizedExpression ? "unary" === t2.kind ? t2.what && !t2.what.parenthesizedExpression && ("bin" === t2.what.kind ? (i3 = t2.what, t2.what = t2.what.left, this.swapLocations(t2, t2, t2.what, e2), i3.left = this.resolvePrecedence(t2, e2), this.swapLocations(i3, i3.left, i3.right, e2), t2 = i3) : "retif" === t2.what.kind && (i3 = t2.what, t2.what = t2.what.test, this.swapLocations(t2, t2, t2.what, e2), i3.test = this.resolvePrecedence(t2, e2), this.swapLocations(i3, i3.test, i3.falseExpr, e2), t2 = i3)) : "retif" === t2.kind ? t2.falseExpr && "retif" === t2.falseExpr.kind && !t2.falseExpr.parenthesizedExpression && (i3 = t2.falseExpr, t2.falseExpr = i3.test, this.swapLocations(t2, t2.test, t2.falseExpr, e2), i3.test = this.resolvePrecedence(t2, e2), this.swapLocations(i3, i3.test, i3.falseExpr, e2), t2 = i3) : "assign" === t2.kind ? t2.right && "bin" === t2.right.kind && !t2.right.parenthesizedExpression && (n2 = cs2.precedence["="], s3 = cs2.precedence[t2.right.type], n2 && s3 && s3 < n2 && (i3 = t2.right, t2.right = t2.right.left, i3.left = t2, this.swapLocations(i3, i3.left, t2.right, e2), t2 = i3)) : "expressionstatement" === t2.kind && this.swapLocations(t2, t2.expression, t2, e2) : "bin" === t2.expr.kind ? (i3 = t2.expr, t2.expr = t2.expr.left, this.swapLocations(t2, t2, t2.expr, e2), i3.left = this.resolvePrecedence(t2, e2), this.swapLocations(i3, i3.left, i3.right, e2), t2 = i3) : "retif" === t2.expr.kind && (i3 = t2.expr, t2.expr = t2.expr.test, this.swapLocations(t2, t2, t2.expr, e2), i3.test = this.resolvePrecedence(t2, e2), this.swapLocations(i3, i3.test, i3.falseExpr, e2), t2 = i3), t2;
    }, cs2.prototype.prepare = function(t2, e2, i3) {
      var n2 = null;
      (this.withPositions || this.withSource) && (n2 = i3.position());
      var s3 = this, r2 = function r3() {
        var o2 = null, a4 = Array.prototype.slice.call(arguments);
        if (a4.push(e2), s3.withPositions || s3.withSource) {
          var h3 = null;
          s3.withSource && (h3 = i3.lexer._input.substring(n2.offset, i3.prev[2])), o2 = new J2(h3, n2, new b2(i3.prev[0], i3.prev[1], i3.prev[2])), a4.push(o2);
        }
        t2 || (t2 = a4.shift());
        var l2 = s3[t2];
        if ("function" != typeof l2)
          throw new Error('Undefined node "' + t2 + '"');
        var c2 = Object.create(l2.prototype);
        return l2.apply(c2, a4), r3.instance = c2, r3.trailingComments && (c2.trailingComments = r3.trailingComments), "function" == typeof r3.postBuild && r3.postBuild(c2), i3.debug && delete s3.stack[r3.stackUid], s3.resolvePrecedence(c2, i3);
      };
      return i3.debug && (this.stack || (this.stack = {}, this.stackUid = 1), this.stack[++this.stackUid] = { position: n2, stack: new Error().stack.split("\n").slice(3, 5) }, r2.stackUid = this.stackUid), r2.setTrailingComments = function(t3) {
        r2.instance ? r2.instance.setTrailingComments(t3) : r2.trailingComments = t3;
      }, r2.destroy = function(t3) {
        e2 && (t3 ? t3.leadingComments ? t3.leadingComments = e2.concat(t3.leadingComments) : t3.leadingComments = e2 : i3._docIndex = i3._docs.length - e2.length), i3.debug && delete s3.stack[r2.stackUid];
      }, r2;
    }, cs2.prototype.checkNodes = function() {
      var t2 = [];
      for (var e2 in this.stack)
        Object.prototype.hasOwnProperty.call(this.stack, e2) && (this.stack[e2].key = e2, t2.push(this.stack[e2]));
      return this.stack = {}, t2;
    }, [nt, rt2, at2, lt2, ut2, dt2, Tt2, xt2, gt2, Lt2, bt2, St2, Rt2, Dt2, Ut2, Gt2, jt2, zt2, Xt2, Jt2, Zt, ee2, ne, Qt2, re2, Bt, he2, ce, ue2, de2, fe2, Ee, xe2, ve2, ge2, Le2, be2, Se2, Re2, et2, De2, Pe2, Me2, Be, Ge2, Qe, Ye2, ze, Ke2, Je2, Ze2, ei, ni2, ri, ai2, li2, vt2, ui, di2, fi2, ki, mi, gi2, Li, bi2, Ii2, Z3, Oi2, wi, Pi2, Mi2, Bi2, Gi2, ft2, Qi2, Yi2, $i2, zi2, Xi, qi, tn, nn2, on2, yi2, hn2, cn, _n2, pn2, Et2, Tn2, En2, xn2, vn2, gn2, Ln2, bn2, Sn2, Rn2, Dn, Un2, Mn2, Hn2, Vn2, Wn2, jn2, zn2, Jn2, Zn2, es2, ns2, rs2, as2, ls2].forEach(function(t2) {
      cs2.prototype[t2.kind] = t2;
    });
    var us2 = cs2;
    function _s2(t2, e2) {
      for (var i3 = Object.keys(t2), n2 = i3.length; n2--; ) {
        var s3 = i3[n2], r2 = t2[s3];
        null === r2 ? delete e2[s3] : "function" == typeof r2 ? e2[s3] = r2.bind(e2) : Array.isArray(r2) ? e2[s3] = Array.isArray(e2[s3]) ? e2[s3].concat(r2) : r2 : "object" === a3(r2) ? e2[s3] = "object" === a3(e2[s3]) ? _s2(r2, e2[s3]) : r2 : e2[s3] = r2;
      }
      return e2;
    }
    var ds2 = function(t2) {
      if ("function" == typeof this)
        return new this(t2);
      if (this.tokens = X3, this.lexer = new C2(this), this.ast = new us2(), this.parser = new K(this.lexer, this.ast), t2 && "object" === a3(t2)) {
        if (t2.parser && (t2.lexer || (t2.lexer = {}), t2.parser.version)) {
          if ("string" == typeof t2.parser.version) {
            var e2 = t2.parser.version.split(".");
            if (e2 = 100 * parseInt(e2[0]) + parseInt(e2[1]), isNaN(e2))
              throw new Error("Bad version number : " + t2.parser.version);
            t2.parser.version = e2;
          } else if ("number" != typeof t2.parser.version)
            throw new Error("Expecting a number for version");
          if (t2.parser.version < 500 || t2.parser.version > 900)
            throw new Error("Can only handle versions between 5.x to 8.x");
        }
        _s2(t2, this), this.lexer.version = this.parser.version;
      }
    }, ps2 = function(t2) {
      return "function" == typeof t2.write ? t2.toString() : t2;
    };
    ds2.create = function(t2) {
      return new ds2(t2);
    }, ds2.parseEval = function(t2, e2) {
      return new ds2(e2).parseEval(t2);
    }, ds2.prototype.parseEval = function(t2) {
      return this.lexer.mode_eval = true, this.lexer.all_tokens = false, t2 = ps2(t2), this.parser.parse(t2, "eval");
    }, ds2.parseCode = function(t2, e2, i3) {
      return "object" !== a3(e2) || i3 || (i3 = e2, e2 = "unknown"), new ds2(i3).parseCode(t2, e2);
    }, ds2.prototype.parseCode = function(t2, e2) {
      return this.lexer.mode_eval = false, this.lexer.all_tokens = false, t2 = ps2(t2), this.parser.parse(t2, e2);
    }, ds2.tokenGetAll = function(t2, e2) {
      return new ds2(e2).tokenGetAll(t2);
    }, ds2.prototype.tokenGetAll = function(t2) {
      this.lexer.mode_eval = false, this.lexer.all_tokens = true, t2 = ps2(t2);
      var e2 = this.lexer.EOF, i3 = this.tokens.values;
      this.lexer.setInput(t2);
      for (var n2 = this.lexer.lex() || e2, s3 = []; n2 != e2; ) {
        var r2 = this.lexer.yytext;
        Object.prototype.hasOwnProperty.call(i3, n2) && (r2 = [i3[n2], r2, this.lexer.yylloc.first_line]), s3.push(r2), n2 = this.lexer.lex() || e2;
      }
      return s3;
    };
    var fs2 = ds2, Ts2 = X3, ks2 = C2, Es2 = us2, ms2 = K, xs2 = _s2, ys2 = ds2, vs2 = ds2;
    fs2.tokens = Ts2, fs2.lexer = ks2, fs2.AST = Es2, fs2.parser = ms2, fs2.combine = xs2, fs2.Engine = ys2, fs2.default = vs2;
    var As2 = function(t2, e2, i3) {
      var n2 = i3 && "markdown" === i3.parentParser;
      if (!t2 && n2)
        return "";
      t2 = t2.replace(/\?>\r?\n<\?/g, "?>\n___PSEUDO_INLINE_PLACEHOLDER___<?");
      var s3, r2 = new fs2({ parser: { extractDoc: true }, ast: { withPositions: true, withSource: true } }), o2 = -1 !== t2.indexOf("<?php"), a4 = n2 && !o2;
      try {
        s3 = a4 ? r2.parseEval(t2) : r2.parseCode(t2);
      } catch (t3) {
        throw t3 instanceof SyntaxError && "lineNumber" in t3 && (t3.loc = { start: { line: t3.lineNumber, column: t3.columnNumber } }, delete t3.lineNumber, delete t3.columnNumber), t3;
      }
      return s3.extra = { parseAsEval: a4 }, s3.comments.forEach(function(t3) {
        "\r" === t3.value[t3.value.length - 1] && (t3.value = t3.value.slice(0, -1), t3.loc.end.offset = t3.loc.end.offset - 1), "\n" === t3.value[t3.value.length - 1] && (t3.value = t3.value.slice(0, -1), t3.loc.end.offset = t3.loc.end.offset - 1);
      }), s3;
    }, gs2 = n.default.util, Ns2 = gs2.hasNewline, Ls2 = gs2.skipEverythingButNewLine, Cs2 = gs2.skipNewline, bs2 = gs2.isNextLineEmpty, Is2 = gs2.isPreviousLineEmpty, Ss2 = gs2.getNextNonSpaceNonCommentCharacterIndex, Os2 = n.default.version;
    function Rs2(t2, e2) {
      return parseInt(Os2[0]) > 1 ? t2[e2] : t2;
    }
    var ws2 = {};
    function Ds2(t2) {
      return ws2[t2];
    }
    [["or"], ["xor"], ["and"], ["=", "+=", "-=", "*=", "**=", "/=", ".=", "%=", "&=", "|=", "^=", "<<=", ">>="], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!==", "<>", "<=>"], ["<", ">", "<=", ">="], [">>", "<<"], ["+", "-", "."], ["*", "/", "%"], ["!"], ["instanceof"], ["++", "--", "~"], ["**"]].forEach(function(t2, e2) {
      t2.forEach(function(t3) {
        ws2[t3] = e2;
      });
    });
    var Ps2 = ["==", "!=", "===", "!==", "<>", "<=>"], Us2 = ["*", "/", "%"], Ms2 = [">>", "<<"];
    function Fs2(t2) {
      return ["block", "program", "namespace", "class", "enum", "interface", "trait", "traituse", "declare"].includes(t2.kind);
    }
    function Bs2(t2) {
      var e2 = t2.body;
      return e2 ? ("block" === e2.kind && (e2 = e2.children), e2[0]) : null;
    }
    function Hs2(t2) {
      var e2 = t2.children || t2.body || t2.adaptations;
      return Array.isArray(e2) ? e2 : null;
    }
    function Gs2(t2) {
      var e2 = t2.getParentNode();
      return e2 ? Hs2(e2) : null;
    }
    function Vs2(t2) {
      return t2.length > 0 ? t2[t2.length - 1] : null;
    }
    function Qs2(t2) {
      var e2 = t2.getValue();
      if ("program" === e2.kind) {
        var i3 = Hs2(e2);
        return !(!i3 || 0 === i3.length) && "inline" === i3[0].kind;
      }
      if ("switch" === e2.kind) {
        if (!e2.body)
          return false;
        var n2 = Hs2(e2.body);
        if (0 === n2.length)
          return false;
        var s3 = l(n2, 1)[0];
        if (!s3.body)
          return false;
        var r2 = Hs2(s3.body);
        return 0 !== r2.length && "inline" === r2[0].kind;
      }
      var o2 = Bs2(e2);
      return !!o2 && "inline" === o2.kind;
    }
    var Ws2 = ["__construct", "__destruct", "__call", "__callStatic", "__get", "__set", "__isset", "__unset", "__sleep", "__wakeup", "__toString", "__invoke", "__set_state", "__clone", "__debugInfo"].reduce(function(t2, e2) {
      return t2[e2.toLowerCase()] = e2, t2;
    }, {});
    var Ys2 = { printNumber: function(t2) {
      return t2.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e)/, "");
    }, getPrecedence: Ds2, isBitwiseOperator: function(t2) {
      return !!Ms2[t2] || "|" === t2 || "^" === t2 || "&" === t2;
    }, shouldFlatten: function(t2, e2) {
      return Ds2(e2) === Ds2(t2) && ("**" !== t2 && ((!Ps2.includes(t2) || !Ps2.includes(e2)) && (!("%" === e2 && Us2.includes(t2) || "%" === t2 && Us2.includes(e2)) && ((e2 === t2 || !Us2.includes(e2) || !Us2.includes(t2)) && (!Ms2.includes(t2) || !Ms2.includes(e2))))));
    }, nodeHasStatement: Fs2, getNodeListProperty: Hs2, getParentNodeListProperty: Gs2, getLast: Vs2, getPenultimate: function(t2) {
      return t2.length > 1 ? t2[t2.length - 2] : null;
    }, isLastStatement: function(t2) {
      var e2 = Gs2(t2);
      if (!e2)
        return true;
      var i3 = t2.getValue();
      return e2[e2.length - 1] === i3;
    }, getBodyFirstChild: Bs2, lineShouldEndWithSemicolon: function(t2) {
      var e2 = t2.getValue(), i3 = t2.getParentNode();
      if (!i3)
        return false;
      if (["for", "foreach", "while", "do", "if", "switch"].includes(i3.kind) && "block" !== e2.kind && "if" !== e2.kind && (i3.body === e2 || i3.alternate === e2))
        return true;
      if (!Fs2(i3))
        return false;
      if ("echo" === e2.kind && e2.shortForm)
        return false;
      if ("traituse" === e2.kind)
        return !e2.adaptations;
      if ("method" === e2.kind && e2.isAbstract)
        return true;
      if ("method" === e2.kind) {
        var n2 = t2.getParentNode();
        if (n2 && "interface" === n2.kind)
          return true;
      }
      return ["expressionstatement", "do", "usegroup", "classconstant", "propertystatement", "traitprecedence", "traitalias", "goto", "constantstatement", "enumcase", "global", "static", "echo", "unset", "return", "break", "continue", "throw"].includes(e2.kind);
    }, fileShouldEndWithHardline: function(t2) {
      var e2 = t2.getValue(), i3 = "program" === e2.kind, n2 = e2.children && Vs2(e2.children);
      if (!i3)
        return false;
      if (n2 && ["halt", "inline"].includes(n2.kind))
        return false;
      if (n2 && ("declare" === n2.kind || "namespace" === n2.kind)) {
        var s3 = n2.children.length > 0 && Vs2(n2.children);
        if (s3 && ["halt", "inline"].includes(s3.kind))
          return false;
      }
      return true;
    }, maybeStripLeadingSlashFromUse: function(t2) {
      var e2 = t2.replace(/^\\/, "");
      return -1 !== e2.indexOf("\\") ? e2 : t2;
    }, hasDanglingComments: function(t2) {
      return t2.comments && t2.comments.some(function(t3) {
        return !t3.leading && !t3.trailing;
      });
    }, hasLeadingComment: function(t2) {
      return t2.comments && t2.comments.some(function(t3) {
        return t3.leading;
      });
    }, hasTrailingComment: function(t2) {
      return t2.comments && t2.comments.some(function(t3) {
        return t3.trailing;
      });
    }, docShouldHaveTrailingNewline: function t2(e2) {
      var i3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n2 = e2.getNode(i3), s3 = e2.getNode(i3 + 1), r2 = e2.getNode(i3 + 2);
      if (!s3)
        return false;
      if (r2 && ["call", "new", "echo"].includes(r2.kind) && !["call", "array"].includes(s3.kind) || "parameter" === s3.kind) {
        var o2 = r2.arguments.length - 1, a4 = r2.arguments.indexOf(s3);
        return a4 !== o2;
      }
      if (r2 && "for" === r2.kind) {
        var h3 = r2.init.indexOf(s3);
        if (-1 !== h3)
          return h3 !== r2.init.length - 1;
        var l2 = r2.test.indexOf(s3);
        if (-1 !== l2)
          return l2 !== r2.test.length - 1;
        var c2 = r2.increment.indexOf(s3);
        if (-1 !== c2)
          return c2 !== r2.increment.length - 1;
      }
      if ("bin" === s3.kind)
        return s3.left === n2 || t2(e2, i3 + 1);
      if ("case" === s3.kind && s3.test === n2)
        return true;
      if ("staticvariable" === s3.kind) {
        var u2 = r2.variables.length - 1, _2 = r2.variables.indexOf(s3);
        return _2 !== u2;
      }
      if ("entry" === s3.kind) {
        if (s3.key === n2)
          return true;
        var d5 = r2.items.length - 1, p2 = r2.items.indexOf(s3);
        return p2 !== d5;
      }
      if (["call", "new"].includes(s3.kind)) {
        var f2 = s3.arguments.length - 1, T3 = s3.arguments.indexOf(n2);
        return T3 !== f2;
      }
      if ("echo" === s3.kind) {
        var k3 = s3.expressions.length - 1, E2 = s3.expressions.indexOf(n2);
        return E2 !== k3;
      }
      if ("array" === s3.kind) {
        var m3 = s3.items.length - 1, x3 = s3.items.indexOf(n2);
        return x3 !== m3;
      }
      return "retif" === s3.kind && t2(e2, i3 + 1);
    }, isLookupNode: function(t2) {
      return "propertylookup" === t2.kind || "nullsafepropertylookup" === t2.kind || "staticlookup" === t2.kind || "offsetlookup" === t2.kind;
    }, isFirstChildrenInlineNode: Qs2, shouldPrintHardLineAfterStartInControlStructure: function(t2) {
      var e2 = t2.getValue();
      return !["try", "catch"].includes(e2.kind) && Qs2(t2);
    }, shouldPrintHardLineBeforeEndInControlStructure: function(t2) {
      var e2 = t2.getValue();
      if (["try", "catch"].includes(e2.kind))
        return true;
      if ("switch" === e2.kind) {
        var i3 = Hs2(e2.body);
        if (0 === i3.length)
          return true;
        var n2 = Vs2(i3);
        if (!n2.body)
          return true;
        var s3 = Hs2(n2.body);
        return 0 === s3.length || "inline" !== s3[0].kind;
      }
      return !Qs2(t2);
    }, getAlignment: function(t2) {
      var e2 = t2.split("\n").pop();
      return e2.length - e2.trimLeft().length + 1;
    }, isProgramLikeNode: function(t2) {
      return ["program", "declare", "namespace"].includes(t2.kind);
    }, isReferenceLikeNode: function(t2) {
      return ["name", "parentreference", "selfreference", "staticreference"].includes(t2.kind);
    }, getNodeKindIncludingLogical: function(t2) {
      return "bin" === t2.kind && ["||", "&&"].includes(t2.type) ? "logical" : t2.kind;
    }, useDoubleQuote: function(t2, e2) {
      if (t2.isDoubleQuote === e2.singleQuote) {
        var i3 = t2.raw.slice("b" === t2.raw[0] ? 2 : 1, -1).match(/\\([$nrtfve]|[xX][0-9a-fA-F]{1,2}|[0-7]{1,3}|u{([0-9a-fA-F]+)})|\r?\n|'|"|\$/);
        return t2.isDoubleQuote ? i3 : !i3;
      }
      return t2.isDoubleQuote;
    }, hasEmptyBody: function(t2) {
      var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "body", i3 = t2.getValue();
      return i3[e2] && i3[e2].children && 0 === i3[e2].children.length && (!i3[e2].comments || 0 === i3[e2].comments.length);
    }, isNextLineEmptyAfterNamespace: function(t2, e2, i3) {
      var n2 = i3(e2);
      return n2 = Ls2(t2, n2), n2 = Cs2(t2, n2), Ns2(t2, n2);
    }, shouldPrintHardlineBeforeTrailingComma: function(t2) {
      return "nowdoc" === t2.kind || "encapsed" === t2.kind && "heredoc" === t2.type || "entry" === t2.kind && ("nowdoc" === t2.value.kind || "encapsed" === t2.value.kind && "heredoc" === t2.value.type);
    }, isDocNode: function(t2) {
      return "nowdoc" === t2.kind || "encapsed" === t2.kind && "heredoc" === t2.type;
    }, getAncestorNode: function(t2, e2) {
      var i3 = function(t3, e3) {
        for (var i4, n2 = [].concat(e3), s3 = -1; i4 = t3.getParentNode(++s3); )
          if (-1 !== n2.indexOf(i4.kind))
            return s3;
        return -1;
      }(t2, e2);
      return -1 === i3 ? null : t2.getParentNode(i3);
    }, getNextNode: function(t2, e2) {
      var i3 = t2.getParentNode(), n2 = Hs2(i3);
      if (!n2)
        return null;
      var s3 = n2.indexOf(e2);
      return -1 === s3 ? null : i3.children[s3 + 1];
    }, normalizeMagicMethodName: function(t2) {
      var e2 = t2.toLowerCase();
      return Ws2[e2] ? Ws2[e2] : t2;
    }, isPreviousLineEmpty: function(t2, e2, i3) {
      return Is2(t2, e2, Rs2(i3, "locStart"));
    }, isNextLineEmpty: function(t2, e2, i3) {
      return bs2(t2, e2, Rs2(i3, "locEnd"));
    }, getNextNonSpaceNonCommentCharacterIndex: function(t2, e2, i3) {
      return Ss2(t2, e2, Rs2(i3, "locEnd"));
    } }, js2 = n.default.util, $s2 = js2.addLeadingComment, zs2 = js2.addDanglingComment, Ks2 = js2.addTrailingComment, Xs2 = js2.skipNewline, Js2 = js2.hasNewline, qs2 = js2.hasNewlineInRange, Zs2 = n.default.doc.builders, tr2 = Zs2.concat, er2 = Zs2.join, ir2 = Zs2.indent, nr2 = Zs2.hardline, sr2 = Zs2.cursor, rr2 = Zs2.lineSuffix, or2 = Zs2.breakParent, ar2 = Ys2.getNextNonSpaceNonCommentCharacterIndex, hr2 = Ys2.isNextLineEmpty, lr2 = Ys2.isPreviousLineEmpty, cr2 = Ys2.isLookupNode;
    function ur2(t2, e2) {
      var i3 = t2.children;
      0 === i3.length ? zs2(t2, e2) : $s2(i3[0], e2);
    }
    function _r2(t2, e2) {
      "block" === t2.kind ? ur2(t2, e2) : $s2(t2, e2);
    }
    function dr2(t2, e2, i3, n2, s3, r2) {
      var o2 = ar2(t2, s3, r2), a4 = t2.charAt(o2);
      return e2 && "identifier" === e2.kind && i3 && ("function" === i3.kind || "method" === i3.kind) && ")" === a4 ? (Ks2(i3, s3), true) : !(!i3 || "function" !== i3.kind && "method" !== i3.kind || !n2 || "block" !== n2.kind) && (ur2(n2, s3), true);
    }
    function pr2(t2, e2, i3, n2, s3, r2) {
      if (!i3 || "if" !== i3.kind || !n2)
        return false;
      var o2 = ar2(t2, s3, r2);
      return ")" === t2.charAt(o2) ? (Ks2(e2, s3), true) : e2 === i3.body && n2 === i3.alternate ? (zs2(i3, s3), true) : "if" === n2.kind ? (_r2(n2.body, s3), true) : i3.body === n2 && ($s2(n2, s3), true);
    }
    function fr2(t2, e2, i3) {
      if (t2 && ["class", "interface", "trait"].includes(t2.kind)) {
        if (e2 && t2.extends) {
          if (Array.isArray(t2.extends)) {
            if (t2.extends.some(function(t3) {
              if (e2 && e2 === t3)
                return zs2(e2, i3), true;
            }))
              return true;
          } else if (e2 === t2.extends)
            return zs2(e2, i3), true;
        }
        if (e2 && t2.implements && t2.implements.some(function(t3) {
          if (e2 && e2 === t3)
            return zs2(e2, i3), true;
        }))
          return true;
        if (!(t2.body && t2.body.length > 0))
          return zs2(t2, i3), true;
      }
      return !!(e2 && "class" === e2.kind && e2.isAnonymous && e2.leadingComments && "commentblock" === i3.kind);
    }
    function Tr2(t2, e2, i3, n2, s3) {
      if (e2 && ("function" === e2.kind || "method" === e2.kind)) {
        for (var r2 = 0, o2 = 0; o2 < e2.arguments.length; o2++)
          r2 = s3.locEnd(e2.arguments[o2]) > r2 ? s3.locEnd(e2.arguments[o2]) : r2;
        var a4 = e2.body && s3.locStart(n2) > r2 && s3.locEnd(n2) < s3.locStart(e2.body), h3 = ar2(t2, n2, s3);
        if (e2.type && a4 && ")" !== t2.charAt(h3))
          return s3.locEnd(n2) < s3.locStart(e2.type) ? (zs2(e2.type, n2), true) : (Ks2(e2.type, n2), true);
      }
      return false;
    }
    function kr2(t2, e2, i3, n2, s3) {
      return !(!i3 || !["function", "method", "parameter"].includes(i3.kind)) && ("typereference" === e2.kind && "identifier" === n2.kind && (Ks2(e2, s3), true));
    }
    function Er2(t2, e2) {
      return !(!t2 || !["label", "goto"].includes(t2.kind)) && (Ks2(t2, e2), true);
    }
    function mr2(t2, e2, i3, n2) {
      return i3 && "inline" === i3.kind ? (i3.leadingComments || (i3.leadingComments = []), i3.leadingComments.includes(n2) || i3.leadingComments.push(n2), true) : !(t2 || i3 || !e2 || "inline" !== e2.kind) && (zs2(e2, n2), true);
    }
    function xr2(t2, e2, i3) {
      return !(!t2 || "try" !== t2.kind || !e2) && ("block" === e2.kind ? (ur2(e2, i3), true) : "try" === e2.kind ? (_r2(e2.always, i3), true) : "catch" === e2.kind && (_r2(e2.body, i3), true));
    }
    function yr2(t2, e2, i3, n2) {
      return i3 || e2 || !t2 || "namespace" !== t2.kind || t2.withBrackets ? !(e2 || !t2 || "namespace" !== t2.kind || t2.withBrackets) && (zs2(t2, n2), true) : (Ks2(t2, n2), true);
    }
    function vr2(t2, e2, i3, n2) {
      return !(!t2 || "declare" !== t2.kind) && ((!e2 || "noop" !== e2.kind) && (i3 && t2.directives[0] !== i3 ? !(!i3 || !e2) && ($s2(i3, n2), true) : ("none" === t2.mode ? Ks2(t2, n2) : zs2(t2, n2), true)));
    }
    function Ar2(t2, e2, i3, n2, s3, r2) {
      if (!i3 || "while" !== i3.kind || !n2)
        return false;
      var o2 = ar2(t2, s3, r2);
      return ")" === t2.charAt(o2) ? (Ks2(e2, s3), true) : "block" === n2.kind && (ur2(n2, s3), true);
    }
    function gr2(t2, e2) {
      return t2.getValue().printed = true, e2.printer.printComment(t2, e2);
    }
    function Nr2(t2, e2, i3) {
      return t2.getNode() === e2.cursorNode && t2.getValue() ? tr2([sr2, i3, sr2]) : i3;
    }
    var Lr2 = { handleOwnLineComment: function(t2, e2, i3) {
      var n2 = t2.precedingNode, s3 = t2.enclosingNode, r2 = t2.followingNode;
      return dr2(e2, n2, s3, r2, t2, i3) || function(t3, e3, i4) {
        if (t3 && cr2(t3) && e3 && ["identifier", "variable", "encapsed"].includes(e3.kind))
          return $s2(t3, i4), true;
        return false;
      }(s3, r2, t2) || pr2(e2, n2, s3, r2, t2, i3) || Ar2(e2, n2, s3, r2, t2, i3) || xr2(s3, r2, t2) || fr2(s3, r2, t2) || kr2(e2, n2, s3, r2, t2) || Tr2(e2, s3, r2, t2, i3) || function(t3, e3, i4, n3) {
        if (!i4 && t3 && ("for" === t3.kind || "foreach" === t3.kind))
          return t3.body && "block" !== t3.body.kind ? $s2(i4, n3) : $s2(t3, n3), true;
        return false;
      }(s3, 0, r2, t2) || mr2(s3, n2, r2, t2) || vr2(s3, n2, r2, t2);
    }, handleEndOfLineComment: function(t2, e2, i3) {
      var n2 = t2.precedingNode, s3 = t2.enclosingNode, r2 = t2.followingNode;
      return function(t3, e3, i4, n3, s4) {
        if (!e3 && !n3 && i4 && "array" === i4.kind)
          return Ks2(i4, s4), true;
        return false;
      }(0, n2, s3, r2, t2) || function(t3, e3, i4, n3, s4) {
        if (i4 && "return" === i4.kind && !i4.expr)
          return Ks2(i4, s4), true;
        return false;
      }(0, 0, s3, 0, t2) || dr2(e2, n2, s3, r2, t2, i3) || function(t3, e3, i4, n3, s4, r3) {
        var o2 = e3 && !qs2(s4, r3.locEnd(e3), r3.locStart(n3));
        if ((!e3 || !o2) && t3 && "retif" === t3.kind && i4)
          return $s2(i4, n3), true;
        return false;
      }(s3, n2, r2, t2, e2, i3) || pr2(e2, n2, s3, r2, t2, i3) || Ar2(e2, n2, s3, r2, t2, i3) || xr2(s3, r2, t2) || fr2(s3, r2, t2) || kr2(e2, n2, s3, r2, t2) || Tr2(e2, s3, r2, t2, i3) || function(t3, e3) {
        if (t3 && "entry" === t3.kind)
          return $s2(t3, e3), true;
        return false;
      }(s3, t2) || function(t3, e3, i4) {
        if (e3 && "call" === e3.kind && t3 && e3.what === t3 && e3.arguments.length > 0)
          return $s2(e3.arguments[0], i4), true;
        return false;
      }(n2, s3, t2) || function(t3, e3, i4) {
        if (t3 && "assign" === t3.kind && e3) {
          var n3 = t3.loc.start.offset + t3.loc.source.indexOf("=");
          if (i4.loc.start.offset > n3)
            return $s2(e3, i4), true;
        }
        return false;
      }(s3, r2, t2) || mr2(s3, n2, r2, t2) || yr2(s3, n2, r2, t2) || vr2(s3, n2, r2, t2) || Er2(s3, t2);
    }, handleRemainingComment: function(t2, e2, i3) {
      var n2 = t2.precedingNode, s3 = t2.enclosingNode, r2 = t2.followingNode;
      return pr2(e2, n2, s3, r2, t2, i3) || Ar2(e2, n2, s3, r2, t2, i3) || function(t3, e3, i4, n3) {
        var s4 = ar2(t3, i4, n3);
        if (")" !== t3.charAt(s4))
          return false;
        if (e3 && ("function" === e3.kind || "closure" === e3.kind || "method" === e3.kind || "call" === e3.kind || "new" === e3.kind) && 0 === e3.arguments.length)
          return zs2(e3, i4), true;
        return false;
      }(e2, s3, t2, i3) || fr2(s3, r2, t2) || function(t3, e3, i4) {
        if (t3 && "traituse" === t3.kind && t3.adaptations && !t3.adaptations.length)
          return zs2(t3, i4), true;
        return false;
      }(s3, 0, t2) || kr2(e2, n2, s3, r2, t2) || Tr2(e2, s3, r2, t2, i3) || Er2(s3, t2) || function(t3, e3, i4, n3) {
        if (e3 && "halt" === e3.kind)
          return zs2(e3, n3), true;
        if (t3 && "halt" === t3.kind)
          return zs2(t3, n3), true;
        return false;
      }(n2, s3, 0, t2) || function(t3, e3) {
        if (t3 && ("continue" === t3.kind || "break" === t3.kind) && !t3.label)
          return Ks2(t3, e3), true;
        return false;
      }(s3, t2) || mr2(s3, n2, r2, t2) || yr2(s3, n2, r2, t2);
    }, getCommentChildNodes: function(t2) {
      return "object" !== a3(t2) ? [] : function(t3) {
        return Object.keys(t3).filter(function(t4) {
          return "kind" !== t4 && "loc" !== t4 && "errors" !== t4 && "extra" !== t4 && "comments" !== t4 && "leadingComments" !== t4 && "enclosingNode" !== t4 && "precedingNode" !== t4 && "followingNode" !== t4;
        }).map(function(e2) {
          return t3[e2];
        });
      }(t2);
    }, canAttachComment: function(t2) {
      return t2.kind && "commentblock" !== t2.kind && "commentline" !== t2.kind;
    }, isBlockComment: function(t2) {
      return "commentblock" === t2.kind;
    }, printDanglingComments: function(t2, e2, i3, n2) {
      var s3 = [], r2 = t2.getValue();
      return r2 && r2.comments ? (t2.each(function(t3) {
        var i4 = t3.getValue();
        !i4 || i4.leading || i4.trailing || n2 && !n2(i4) || s3.push(gr2(t3, e2));
      }, "comments"), 0 === s3.length ? "" : i3 ? er2(nr2, s3) : ir2(tr2([nr2, er2(nr2, s3)]))) : "";
    }, hasLeadingComment: function(t2) {
      return t2.comments && t2.comments.some(function(t3) {
        return t3.leading;
      });
    }, hasTrailingComment: function(t2) {
      return t2.comments && t2.comments.some(function(t3) {
        return t3.trailing;
      });
    }, hasLeadingOwnLineComment: function(t2, e2, i3) {
      return e2.comments && e2.comments.some(function(e3) {
        return e3.leading && Js2(t2, i3.locEnd(e3));
      });
    }, printComments: function(t2, e2) {
      var i3 = [];
      return t2.forEach(function(t3, n2, s3) {
        t3.printed = true;
        var r2 = s3.length === n2 + 1;
        i3.push(t3.value), r2 || i3.push(nr2), hr2(e2.originalText, t3, e2) && !r2 && i3.push(nr2);
      }), tr2(i3);
    }, printAllComments: function(t2, e2, i3, n2) {
      var s3 = t2.getValue(), r2 = e2(t2), o2 = s3 && s3.comments;
      if (!o2 || 0 === o2.length)
        return Nr2(t2, i3, r2);
      var a4 = [], h3 = [n2 ? ";" : "", r2];
      return t2.each(function(t3) {
        var e3 = t3.getValue(), n3 = e3.leading, s4 = e3.trailing;
        if (n3) {
          var r3 = function(t4, e4, i4) {
            var n4 = t4.getValue(), s5 = gr2(t4, i4);
            if (!s5)
              return "";
            var r4 = i4.printer.isBlockComment && i4.printer.isBlockComment(n4);
            return tr2(r4 ? [s5, Js2(i4.originalText, i4.locEnd(n4)) ? nr2 : " "] : [s5, nr2]);
          }(t3, 0, i3);
          if (!r3)
            return;
          a4.push(r3);
          var o3 = i3.originalText;
          Js2(o3, Xs2(o3, i3.locEnd(e3))) && a4.push(nr2);
        } else
          s4 && h3.push(function(t4, e4, i4) {
            var n4 = t4.getValue(), s5 = gr2(t4, i4);
            if (!s5)
              return "";
            var r4 = i4.printer.isBlockComment && i4.printer.isBlockComment(n4);
            if (Js2(i4.originalText, i4.locStart(n4), { backwards: true })) {
              var o4 = lr2(i4.originalText, n4, i4);
              return rr2(tr2([nr2, o4 ? nr2 : "", s5]));
            }
            return tr2(r4 ? [" ", s5] : [rr2(tr2([" ", s5])), r4 ? "" : or2]);
          }(t3, 0, i3));
      }, "comments"), Nr2(t2, i3, tr2(a4.concat(h3)));
    } };
    function Cr2() {
    }
    Cr2.strictEqual = function() {
    };
    var br2 = Cr2, Ir2 = Ys2.getPrecedence, Sr2 = Ys2.shouldFlatten, Or2 = Ys2.isBitwiseOperator;
    var Rr = function(t2) {
      var e2 = t2.getParentNode();
      if (!e2)
        return false;
      var i3 = t2.getName(), n2 = t2.getNode();
      if (["program", "expressionstatement", "namespace", "declare", "block", "include", "print", "return", "echo"].includes(e2.kind))
        return false;
      switch (n2.kind) {
        case "pre":
        case "post":
          if ("unary" === e2.kind)
            return "pre" === n2.kind && ("+" === n2.type && "+" === e2.type || "-" === n2.type && "-" === e2.type);
        case "unary":
          switch (e2.kind) {
            case "unary":
              return n2.type === e2.type && ("+" === n2.type || "-" === n2.type);
            case "propertylookup":
            case "nullsafepropertylookup":
            case "staticlookup":
            case "offsetlookup":
            case "call":
              return "what" === i3 && e2.what === n2;
            case "bin":
              return "**" === e2.type && "left" === i3;
            default:
              return false;
          }
        case "bin":
          switch (e2.kind) {
            case "assign":
            case "retif":
              return ["and", "xor", "or"].includes(n2.type);
            case "silent":
            case "cast":
              return n2.parenthesizedExpression;
            case "pre":
            case "post":
            case "unary":
              return true;
            case "call":
            case "propertylookup":
            case "nullsafepropertylookup":
            case "staticlookup":
            case "offsetlookup":
              return "what" === i3 && e2.what === n2;
            case "bin":
              var s3 = e2.type, r2 = Ir2(s3), o2 = n2.type, a4 = Ir2(o2);
              return r2 > a4 || ("||" === s3 && "&&" === o2 || (r2 === a4 && "right" === i3 ? (br2.strictEqual(e2.right, n2), true) : r2 === a4 && !Sr2(s3, o2) || (r2 < a4 && "%" === o2 ? "+" === s3 || "-" === s3 : !!Or2(s3))));
            default:
              return false;
          }
        case "propertylookup":
        case "nullsafepropertylookup":
        case "staticlookup":
          return "call" === e2.kind && ("what" === i3 && e2.what === n2 && n2.parenthesizedExpression);
        case "clone":
        case "new":
          switch (e2.kind) {
            case "propertylookup":
            case "nullsafepropertylookup":
            case "staticlookup":
            case "offsetlookup":
            case "call":
              return "what" === i3 && e2.what === n2;
            default:
              return false;
          }
        case "yield":
          switch (e2.kind) {
            case "propertylookup":
            case "nullsafepropertylookup":
            case "staticlookup":
            case "offsetlookup":
            case "call":
              return "what" === i3 && e2.what === n2;
            case "retif":
              return e2.test === n2;
            default:
              return !(!n2.key && !n2.value);
          }
        case "assign":
          return ("for" !== e2.kind || !e2.init.includes(n2) && !e2.increment.includes(n2)) && ("assign" !== e2.kind && ("static" !== e2.kind && (!["if", "do", "while", "foreach", "switch"].includes(e2.kind) && ("silent" !== e2.kind && "call" !== e2.kind))));
        case "retif":
          switch (e2.kind) {
            case "cast":
              return true;
            case "unary":
            case "bin":
            case "retif":
              return !("test" === i3 && !e2.trueExpr);
            case "propertylookup":
            case "nullsafepropertylookup":
            case "staticlookup":
            case "offsetlookup":
            case "call":
              return "what" === i3 && e2.what === n2;
            default:
              return false;
          }
        case "closure":
          switch (e2.kind) {
            case "call":
              return "what" === i3 && e2.what === n2;
            case "propertylookup":
            case "nullsafepropertylookup":
              return true;
            default:
              return false;
          }
        case "silence":
        case "cast":
          return n2.parenthesizedExpression;
        case "string":
        case "array":
          switch (e2.kind) {
            case "propertylookup":
            case "nullsafepropertylookup":
            case "staticlookup":
            case "offsetlookup":
            case "call":
              return (!["string", "array"].includes(n2.kind) || "offsetlookup" !== e2.kind) && ("what" === i3 && e2.what === n2);
            default:
              return false;
          }
        case "print":
        case "include":
          return "bin" === e2.kind;
      }
      return false;
    }, wr2 = n.default.doc.builders, Dr2 = wr2.breakParent, Pr2 = wr2.concat, Ur2 = wr2.join, Mr2 = wr2.line, Fr2 = wr2.lineSuffix, Br2 = wr2.group, Hr2 = wr2.conditionalGroup, Gr2 = wr2.indent, Vr2 = wr2.dedent, Qr = wr2.ifBreak, Wr2 = wr2.hardline, Yr2 = wr2.softline, jr2 = wr2.literalline, $r2 = wr2.align, zr2 = wr2.dedentToRoot, Kr2 = n.default.doc.utils.willBreak, Xr = n.default.util, Jr2 = Xr.isNextLineEmptyAfterIndex, qr2 = Xr.hasNewline, Zr = Xr.hasNewlineInRange, to2 = Ys2.getLast, eo2 = Ys2.getPenultimate, io2 = Ys2.isLastStatement, no2 = Ys2.lineShouldEndWithSemicolon, so2 = Ys2.printNumber, ro2 = Ys2.shouldFlatten, oo2 = Ys2.maybeStripLeadingSlashFromUse, ao2 = Ys2.fileShouldEndWithHardline, ho2 = Ys2.hasDanglingComments, lo2 = Ys2.hasLeadingComment, co2 = Ys2.hasTrailingComment, uo2 = Ys2.docShouldHaveTrailingNewline, _o2 = Ys2.isLookupNode, po2 = Ys2.isFirstChildrenInlineNode, fo2 = Ys2.shouldPrintHardLineAfterStartInControlStructure, To2 = Ys2.shouldPrintHardLineBeforeEndInControlStructure, ko2 = Ys2.getAlignment, Eo2 = Ys2.isProgramLikeNode, mo2 = Ys2.getNodeKindIncludingLogical, xo2 = Ys2.useDoubleQuote, yo2 = Ys2.hasEmptyBody, vo2 = Ys2.isNextLineEmptyAfterNamespace, Ao2 = Ys2.shouldPrintHardlineBeforeTrailingComma, go2 = Ys2.isDocNode, No2 = Ys2.getAncestorNode, Lo2 = Ys2.isReferenceLikeNode, Co2 = Ys2.getNextNode, bo2 = Ys2.normalizeMagicMethodName, Io2 = Ys2.getNextNonSpaceNonCommentCharacterIndex, So2 = Ys2.isNextLineEmpty;
    function Oo2(t2, e2) {
      return parseFloat(t2) >= parseFloat(e2);
    }
    function Ro2(t2, e2) {
      return !!t2.trailingCommaPHP && Oo2(t2.phpVersion, e2);
    }
    function wo2(t2) {
      return "1tbs" !== t2.braceStyle;
    }
    function Do2(t2, e2, i3) {
      var n2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
      return Pr2([n2 ? "?" : "", "->", t2.call(i3, "offset")]);
    }
    function Po2(t2, e2, i3) {
      return Do2(t2, e2, i3, true);
    }
    function Uo2(t2, e2, i3) {
      var n2 = t2.getValue(), s3 = !["variable", "identifier"].includes(n2.offset.kind);
      return Pr2(["::", s3 ? "{" : "", t2.call(i3, "offset"), s3 ? "}" : ""]);
    }
    function Mo2(t2, e2, i3) {
      var n2 = t2.getValue(), s3 = n2.offset && "number" === n2.offset.kind || No2(t2, "encapsed");
      return Pr2(["[", n2.offset ? Br2(Pr2([Gr2(Pr2([s3 ? "" : Yr2, t2.call(i3, "offset")])), s3 ? "" : Yr2])) : "", "]"]);
    }
    function Fo2(t2) {
      return "array" === t2.kind && (t2.items.length > 0 || t2.comments) || "function" === t2.kind || "method" === t2.kind || "closure" === t2.kind;
    }
    function Bo2(t2) {
      var e2 = to2(t2), i3 = eo2(t2);
      return !lo2(e2) && !co2(e2) && Fo2(e2) && (!i3 || i3.kind !== e2.kind);
    }
    function Ho2(t2) {
      if (2 !== t2.length)
        return false;
      var e2 = l(t2, 2), i3 = e2[0], n2 = e2[1];
      return !(i3.comments && i3.comments.length || "function" !== i3.kind && "method" !== i3.kind && "closure" !== i3.kind || "retif" === n2.kind || Fo2(n2));
    }
    function Go2(t2, e2, i3) {
      var n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "arguments", s3 = t2.getValue()[n2];
      if (0 === s3.length)
        return Pr2(["(", Lr2.printDanglingComments(t2, e2, true), ")"]);
      var r2 = false, o2 = false, a4 = s3.length - 1, h3 = t2.map(function(t3, n3) {
        var s4 = t3.getNode(), h4 = [i3(t3)];
        return n3 === a4 || (So2(e2.originalText, s4, e2) ? (0 === n3 && (o2 = true), r2 = true, h4.push(",", Wr2, Wr2)) : h4.push(",", Mr2)), Pr2(h4);
      }, n2), l2 = t2.getValue(), c2 = to2(s3), u2 = Ro2(e2, "7.3") && ["call", "new", "unset", "isset"].includes(l2.kind) || Ro2(e2, "8.0") && ["function", "closure", "method", "arrowfunc", "attribute"].includes(l2.kind) ? Gr2(Pr2([c2 && Ao2(c2) ? Wr2 : "", ","])) : "";
      function _2() {
        return Br2(Pr2(["(", Gr2(Pr2([Mr2, Pr2(h3)])), u2, Mr2, ")"]), { shouldBreak: true });
      }
      var d5 = Ho2(s3), p2 = Bo2(s3);
      if (d5 || p2) {
        var f2, T3 = (d5 ? h3.slice(1).some(Kr2) : h3.slice(0, -1).some(Kr2)) || r2, k3 = 0;
        t2.each(function(t3) {
          d5 && 0 === k3 && (f2 = [Pr2([t3.call(function(t4) {
            return i3(t4, { expandFirstArg: true });
          }), h3.length > 1 ? "," : "", o2 ? Wr2 : Mr2, o2 ? Wr2 : ""])].concat(h3.slice(1))), p2 && k3 === s3.length - 1 && (f2 = h3.slice(0, -1).concat(t3.call(function(t4) {
            return i3(t4, { expandLastArg: true });
          }))), k3++;
        }, n2);
        var E2 = h3.some(Kr2), m3 = Pr2(["(", Pr2(f2), ")"]);
        return Pr2([E2 ? Dr2 : "", Hr2([E2 ? Qr(_2(), m3) : m3, Pr2(d5 ? ["(", Br2(f2[0], { shouldBreak: true }), Pr2(f2.slice(1)), ")"] : ["(", Pr2(h3.slice(0, -1)), Br2(to2(f2), { shouldBreak: true }), ")"]), Br2(Pr2(["(", Gr2(Pr2([Mr2, Pr2(h3)])), Qr(u2), Mr2, ")"]), { shouldBreak: true })], { shouldBreak: T3 })]);
      }
      return Br2(Pr2(["(", Gr2(Pr2([Yr2, Pr2(h3)])), Qr(u2), Yr2, ")"]), { shouldBreak: h3.some(Kr2) || r2 });
    }
    function Vo2(t2) {
      return "array" === t2.kind && 0 !== t2.items.length;
    }
    function Qo(t2) {
      return "array" === t2.right.kind && 0 !== t2.right.items.length;
    }
    function Wo2(t2, e2, i3, n2, s3) {
      var r2 = [], o2 = t2.getValue();
      if ("bin" === o2.kind) {
        ro2(o2.type, o2.left.type) ? r2 = r2.concat(t2.call(function(t3) {
          return Wo2(t3, e2, i3, true, s3);
        }, "left")) : r2.push(t2.call(e2, "left"));
        var a4 = Qo(o2), h3 = Pr2(a4 ? [o2.type, " ", t2.call(e2, "right")] : [o2.type, Mr2, t2.call(e2, "right")]), l2 = t2.getParentNode(), c2 = !(s3 && ["||", "&&"].includes(o2.type)) && mo2(l2) !== mo2(o2) && mo2(o2.left) !== mo2(o2) && mo2(o2.right) !== mo2(o2), u2 = go2(o2.left) || "bin" === o2.left.kind && go2(o2.left.right);
        r2.push(u2 ? "" : " ", c2 ? Br2(h3) : h3), n2 && o2.comments && (r2 = Lr2.printAllComments(t2, function() {
          return Pr2(r2);
        }, i3));
      } else
        r2.push(t2.call(e2));
      return r2;
    }
    function Yo(t2, e2, i3) {
      var n2 = t2.getValue();
      switch (n2.kind) {
        case "propertylookup":
          return Do2(t2, e2, i3);
        case "nullsafepropertylookup":
          return Po2(t2, e2, i3);
        case "staticlookup":
          return Uo2(t2, 0, i3);
        case "offsetlookup":
          return Mo2(t2, 0, i3);
        default:
          return "Have not implemented lookup kind ".concat(n2.kind, " yet.");
      }
    }
    function jo2(t2) {
      var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i3 = e2.opening, n2 = void 0 === i3 || i3;
      if ("heredoc" === t2.type)
        return n2 ? "<<<".concat(t2.label) : t2.label;
      var s3 = { string: '"', shell: "`" };
      return s3[t2.type] ? s3[t2.type] : "Unimplemented encapsed type ".concat(t2.type);
    }
    function $o2(t2, e2, i3) {
      var n2 = [], s3 = [];
      return t2.each(function(t3) {
        n2.push(Pr2(s3)), n2.push(Br2(i3(t3))), s3 = [",", Mr2], t3.getValue() && So2(e2.originalText, t3.getValue(), e2) && s3.push(Yr2);
      }, "items"), Pr2(n2);
    }
    function zo2(t2, e2) {
      if (0 === e2.length)
        return t2;
      var i3 = 0;
      return e2.reduce(function(e3, n2) {
        var s3 = n2.start, r2 = n2.end, o2 = n2.alignment, a4 = n2.before, h3 = n2.after, l2 = Pr2([a4 || "", Pr2(t2.slice(s3, r2)), h3 || ""]), c2 = e3.concat(t2.slice(i3, s3), o2 ? zr2(Br2(Pr2([$r2(new Array(o2).join(" "), l2)]))) : Br2(l2), r2 === t2.length - 1 ? t2.slice(r2) : "");
        return i3 = r2, c2;
      }, []);
    }
    function Ko(t2, e2, i3) {
      var n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "children", s3 = t2.getValue(), r2 = t2.getParentNode(), o2 = -1, a4 = [], h3 = [];
      t2.map(function(l2, c3) {
        var u3 = l2.getValue(), _3 = "inline" === u3.kind, d6 = i3(l2), p3 = s3[n2], f3 = p3[c3 + 1], T4 = !io2(l2) && !_3 && (f3 && "case" === f3.kind ? !po2(t2) : f3 && "inline" !== f3.kind), k4 = Pr2([d6, T4 ? Wr2 : "", T4 && So2(e2.originalText, u3, e2) ? Wr2 : ""]), E3 = 0 === c3, m4 = p3.length - 1 === c3, x4 = "block" === s3.kind && r2 && ["function", "closure", "method", "try", "catch"].includes(r2.kind), y2 = x4 && E3 ? "" : " ";
        if (_3 || !_3 && m4 && o2 >= 0) {
          var v2 = o2;
          if (_3 && (o2 = c3), _3 && !E3 || !_3 && m4) {
            var A3 = (_3 ? v2 : o2) + 1, g3 = m4 && !_3 ? c3 + 1 : c3, N2 = p3[_3 ? v2 : o2], L2 = N2 ? ko2(N2.raw) : "", C3 = g3 - A3 > 1, b3 = C3 ? x4 && !N2 || Eo2(s3) && 0 === A3 ? "" : Wr2 : "", I3 = C3 && "halt" !== u3.kind ? x4 && m4 ? "" : Wr2 : "";
            C3 && (y2 = ""), h3.push({ start: A3, end: g3, alignment: L2, before: b3, after: I3 });
          }
        }
        if (_3) {
          var S3 = f3 && "echo" === f3.kind && f3.shortForm ? "<?=" : "<?php", O3 = u3.leadingComments && u3.leadingComments.length ? Pr2([E3 && "namespace" !== s3.kind && !x4 ? "<?php" : "", "namespace" !== s3.kind && x4 ? "" : Wr2, Lr2.printComments(u3.leadingComments, e2), Wr2, "?>"]) : Eo2(s3) && E3 && "namespace" !== s3.kind ? "" : Pr2([y2, "?>"]), R2 = t2.getNode(c3 + 1), w3 = R2 && R2.children && R2.children.length, D3 = u3.comments && u3.comments.length ? Pr2([S3, Wr2, w3 ? Lr2.printComments(u3.comments, e2) : "", Wr2, w3 ? "?>" : ""]) : Eo2(s3) && m4 ? "" : Pr2([S3, " "]);
          k4 = Pr2([O3, k4, D3]);
        }
        a4.push(k4);
      }, n2);
      var c2 = zo2(a4, h3);
      if ("program" === s3.kind && !s3.extra.parseAsEval) {
        var u2 = [], _2 = l(s3.children, 1), d5 = _2[0], p2 = !d5 || "inline" !== d5.kind;
        if (p2) {
          var f2 = e2.originalText.trim().match(/^<\?(php|=)(\s+)?\S/), T3 = Pr2([f2 && f2[2] && f2[2].includes("\n") ? Pr2([Wr2, f2[2].split("\n").length > 2 ? Wr2 : ""]) : " ", s3.comments ? Lr2.printComments(s3.comments, e2) : ""]), k3 = d5 && "echo" === d5.kind && d5.shortForm;
          u2.push(Pr2([k3 ? "<?=" : "<?php", T3]));
        }
        u2.push(Pr2(c2));
        var E2 = e2.originalText.trim().endsWith("?>");
        if (E2) {
          var m3 = to2(s3.children), x3 = m3 ? Pr2([Zr(e2.originalText.trimEnd(), e2.locEnd(m3), e2.locEnd(s3)) ? Wr2 : " ", So2(e2.originalText, m3, e2) ? Wr2 : ""]) : s3.comments ? Wr2 : "";
          u2.push(Fr2(Pr2([x3, "?>"])));
        }
        return Pr2(u2);
      }
      return Pr2(c2);
    }
    function Xo(t2, e2, i3, n2) {
      return Pr2(t2.map(function(t3) {
        var n3 = [];
        return n3.push(i3(t3)), io2(t3) || (n3.push(Wr2), So2(e2.originalText, t3.getValue(), e2) && n3.push(Wr2)), Pr2(n3);
      }, n2));
    }
    function Jo2(t2, e2, i3) {
      var n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "extends", s3 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : " ", r2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : " ", o2 = t2.getValue(), a4 = ho2(o2[n2]) ? Pr2([Wr2, t2.call(function(t3) {
        return Lr2.printDanglingComments(t3, e2, true);
      }, n2), Wr2]) : s3, h3 = Array.isArray(o2[n2]) ? Br2(Pr2([Ur2(",", t2.map(function(t3) {
        var n3 = i3(t3);
        return ho2(t3.getValue()) ? Pr2([Wr2, Lr2.printDanglingComments(t3, e2, true), Wr2, n3]) : Pr2([r2, n3]);
      }, n2))])) : Pr2([r2, t2.call(i3, n2)]);
      return Gr2(Pr2([a4, n2, Kr2(a4) ? Gr2(h3) : h3]));
    }
    function qo2(t2, e2, i3) {
      var n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, s3 = n2.inline, r2 = void 0 !== s3 && s3, o2 = [];
      return t2.getValue().attrGroups ? (t2.each(function(t3) {
        var n3 = ["#["];
        !r2 && o2.length > 0 && o2.push(Wr2), n3.push(Yr2), t3.each(function(t4) {
          var s4 = t4.getValue();
          n3.length > 2 && n3.push(",", Mr2);
          var r3 = [s4.name];
          s4.args.length > 0 && r3.push(Go2(t4, e2, i3, "args")), n3.push(Br2(Pr2(r3)));
        }, "attrs"), o2.push(Br2(Pr2([Gr2(Pr2(n3)), Qr(Ro2(e2, "8.0") ? "," : ""), Yr2, "]", r2 ? Qr(Yr2, " ") : ""])));
      }, "attrGroups"), 0 === o2.length ? [] : [Pr2([].concat(o2, [r2 ? "" : Wr2]))]) : [];
    }
    function Zo(t2, e2, i3) {
      var n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "body", s3 = t2.getValue();
      if (!s3[n2])
        return ";";
      var r2 = t2.call(i3, n2);
      return Pr2([s3.shortForm ? ":" : " {", Gr2(Pr2(["block" !== s3[n2].kind || s3[n2].children && s3[n2].children.length > 0 || s3[n2].comments && s3[n2].comments.length > 0 ? Pr2([fo2(t2) ? "switch" === s3.kind ? " " : "" : Wr2, r2]) : ""])), "if" === s3.kind && "body" === n2 ? "" : Pr2([To2(t2) ? Wr2 : "", s3.shortForm ? Pr2(["end", s3.kind, ";"]) : "}"])]);
    }
    function ta2(t2, e2, i3, n2, s3, r2, o2) {
      if (!n2)
        return e2;
      var a4 = ia2(t2, n2, s3, r2, o2);
      return Br2(Pr2([e2, i3, a4]));
    }
    function ea2(t2) {
      return !!_o2(t2) && (!("variable" !== t2.what.kind && !Lo2(t2.what)) || ea2(t2.what));
    }
    function ia2(t2, e2, i3, n2, s3) {
      var r2 = n2 ? "&" : "";
      if (Lr2.hasLeadingOwnLineComment(s3.originalText, e2, s3))
        return Gr2(Pr2([Wr2, r2, i3]));
      var o2 = "cast" === e2.kind ? e2.expr : e2;
      return "bin" === o2.kind && !Qo(o2) || "retif" === o2.kind && (!o2.trueExpr && !Vo2(o2.falseExpr) || "bin" === o2.test.kind && !Qo(o2.test)) || ("variable" === t2.kind || "string" === t2.kind || _o2(t2)) && ("string" === o2.kind && !na2(o2) || ea2(o2)) ? Br2(Gr2(Pr2([Mr2, r2, i3]))) : Pr2([" ", r2, i3]);
    }
    function na2(t2) {
      return t2.raw.includes("\n");
    }
    function sa2(t2, e2, i3) {
      return ("string" === t2.kind || "encapsed" === t2.kind && ("string" === t2.type || "shell" === t2.type)) && na2(t2) && !qr2(e2, i3.locStart(t2), { backwards: true });
    }
    function ra2(t2, e2, i3) {
      return Br2(Pr2(t2.map(function(n2, s3) {
        return Pr2(0 === s3 ? [t2.call(e2)] : [i3, t2.call(e2)]);
      }, "types")));
    }
    var oa2 = function(t2, e2, i3) {
      var n2 = t2.getValue();
      if (!n2)
        return "";
      if ("string" == typeof n2)
        return n2;
      var s3 = function(t3, e3, i4) {
        var n3 = t3.getValue();
        switch (n3.kind) {
          case "program":
            return Br2(Pr2([Ko(t3, e3, i4), Lr2.printDanglingComments(t3, e3, true, function(t4) {
              return !t4.printed;
            })]));
          case "expressionstatement":
            return t3.call(i4, "expression");
          case "block":
            return Pr2([Ko(t3, e3, i4), Lr2.printDanglingComments(t3, e3, true)]);
          case "declare":
            var s4 = function(t4) {
              return Ur2(", ", t4.map(function(t5) {
                return Pr2([i4(t5)]);
              }, "directives"));
            };
            if (["block", "short"].includes(n3.mode))
              return Pr2(["declare(", s4(t3), ")", "block" === n3.mode ? " {" : ":", n3.children.length > 0 ? Gr2(Pr2([Wr2, Ko(t3, e3, i4)])) : "", Lr2.printDanglingComments(t3, e3), Wr2, "block" === n3.mode ? "}" : "enddeclare;"]);
            var r3 = Co2(t3, n3);
            return Pr2(["declare(", s4(t3), ")", r3 && "inline" === r3.kind ? "" : ";"]);
          case "declaredirective":
            return Pr2([t3.call(i4, "key"), "=", t3.call(i4, "value")]);
          case "namespace":
            return Pr2(["namespace ", n3.name && "string" == typeof n3.name ? Pr2([n3.name, n3.withBrackets ? " " : ""]) : "", n3.withBrackets ? "{" : ";", ho2(n3) ? Pr2([" ", Lr2.printDanglingComments(t3, e3, true)]) : "", n3.children.length > 0 ? n3.withBrackets ? Gr2(Pr2([Wr2, Ko(t3, e3, i4)])) : Pr2(["inline" === n3.children[0].kind ? "" : Pr2([Wr2, vo2(e3.originalText, n3, e3.locStart) ? Wr2 : ""]), Ko(t3, e3, i4)]) : "", n3.withBrackets ? Pr2([Wr2, "}"]) : ""]);
          case "usegroup":
            return Br2(Pr2(["use ", n3.type ? Pr2([n3.type, " "]) : "", Gr2(Pr2([n3.name ? Pr2([oo2(n3.name), "\\{", Yr2]) : "", Ur2(Pr2([",", Mr2]), t3.map(function(t4) {
              return Pr2([i4(t4)]);
            }, "items"))])), n3.name ? Pr2([Qr(Ro2(e3, "7.2") ? "," : ""), Yr2, "}"]) : ""]));
          case "useitem":
            return Pr2([n3.type ? Pr2([n3.type, " "]) : "", oo2(n3.name), ho2(n3) ? Pr2([" ", Lr2.printDanglingComments(t3, e3, true)]) : "", n3.alias ? Pr2([" as ", t3.call(i4, "alias")]) : ""]);
          case "class":
          case "enum":
          case "interface":
          case "trait":
            return function(t4, e4, i5) {
              var n4 = t4.getValue(), s5 = "class" === n4.kind && n4.isAnonymous, r4 = qo2(t4, e4, i5, { inline: s5 }), o4 = s5 ? [] : c(r4);
              n4.isFinal && o4.push("final ");
              n4.isAbstract && o4.push("abstract ");
              o4.push(s5 ? "" : n4.kind), n4.name && o4.push(" ", t4.call(i5, "name"));
              "enum" === n4.kind && n4.valueType && o4.push(": ", t4.call(i5, "valueType"));
              n4.extends && n4.implements ? o4.push(Hr2([Pr2([Jo2(t4, e4, i5, "extends"), Jo2(t4, e4, i5, "implements")]), Pr2([Jo2(t4, e4, i5, "extends"), Jo2(t4, e4, i5, "implements", " ", Wr2)]), Pr2([Jo2(t4, e4, i5, "extends", Wr2, " "), Jo2(t4, e4, i5, "implements", Wr2, n4.implements.length > 1 ? Wr2 : " ")])], { shouldBreak: ho2(n4.extends) })) : (n4.extends && o4.push(Hr2([Jo2(t4, e4, i5, "extends"), Jo2(t4, e4, i5, "extends", " ", Wr2), Jo2(t4, e4, i5, "extends", Wr2, n4.extends.length > 1 ? Wr2 : " ")])), n4.implements && o4.push(Hr2([Jo2(t4, e4, i5, "implements"), Jo2(t4, e4, i5, "implements", " ", Wr2), Jo2(t4, e4, i5, "implements", Wr2, n4.implements.length > 1 ? Wr2 : " ")])));
              var a5 = Br2(Pr2([Br2(Pr2(o4)), wo2(e4) ? s5 ? Mr2 : Wr2 : " "])), h4 = n4.body && 0 === n4.body.length && !ho2(n4), l2 = Pr2(["{", Gr2(Pr2([h4 ? "" : Wr2, Xo(t4, e4, i5, "body")])), Lr2.printDanglingComments(t4, e4, true), s5 && h4 ? Yr2 : Wr2, "}"]);
              return Pr2([a5, l2]);
            }(t3, e3, i4);
          case "traitprecedence":
            return Pr2([t3.call(i4, "trait"), "::", t3.call(i4, "method"), " insteadof ", Ur2(", ", t3.map(i4, "instead"))]);
          case "traitalias":
            return Pr2([n3.trait ? Pr2([t3.call(i4, "trait"), "::"]) : "", n3.method ? t3.call(i4, "method") : "", " as ", Ur2(" ", [].concat(c(n3.visibility ? [n3.visibility] : []), c(n3.as ? [t3.call(i4, "as")] : [])))]);
          case "traituse":
            return Br2(Pr2(["use ", Gr2(Br2(Ur2(Pr2([",", Mr2]), t3.map(i4, "traits")))), n3.adaptations ? Pr2([" {", n3.adaptations.length > 0 ? Pr2([Gr2(Pr2([Wr2, Xo(t3, e3, i4, "adaptations")])), Wr2]) : ho2(n3) ? Pr2([Mr2, Lr2.printDanglingComments(t3, e3, true), Mr2]) : "", "}"]) : ""]));
          case "function":
          case "closure":
          case "method":
            return function(t4, e4, i5) {
              var n4 = t4.getValue(), s5 = c(qo2(t4, e4, i5, { inline: "closure" === n4.kind }));
              n4.isFinal && s5.push("final ");
              n4.isAbstract && s5.push("abstract ");
              n4.visibility && s5.push(n4.visibility, " ");
              n4.isStatic && s5.push("static ");
              s5.push("function "), n4.byref && s5.push("&");
              n4.name && s5.push(t4.call(i5, "name"));
              s5.push(Go2(t4, e4, i5)), n4.uses && n4.uses.length > 0 && s5.push(Br2(Pr2([" use ", Go2(t4, e4, i5, "uses")])));
              n4.type && s5.push(Pr2([": ", ho2(n4.type) ? Pr2([t4.call(function(t5) {
                return Lr2.printDanglingComments(t5, e4, true);
              }, "type"), " "]) : "", n4.nullable ? "?" : "", t4.call(i5, "type")]));
              var r4 = Pr2(s5);
              if (!n4.body)
                return r4;
              var o4 = "closure" === n4.kind, a5 = Pr2(["{", Gr2(Pr2([yo2(t4) ? "" : Wr2, t4.call(i5, "body")])), o4 && yo2(t4) ? "" : Wr2, "}"]);
              if (o4)
                return Pr2([r4, " ", a5]);
              if (0 === n4.arguments.length)
                return Pr2([r4, wo2(e4) ? Wr2 : " ", a5]);
              if (s5.some(Kr2))
                return Pr2([r4, " ", a5]);
              return Hr2([Pr2([r4, wo2(e4) ? Wr2 : " ", a5]), Pr2([r4, " ", a5])]);
            }(t3, e3, i4);
          case "arrowfunc":
            return Pr2([].concat(c(qo2(t3, e3, i4, { inline: true })), [n3.isStatic ? "static " : "", "fn", Go2(t3, e3, i4), n3.type ? Pr2([": ", n3.nullable ? "?" : "", t3.call(i4, "type")]) : "", " => ", t3.call(i4, "body")]));
          case "parameter":
            var o3 = "";
            1 === n3.flags ? o3 = "public " : 2 === n3.flags ? o3 = "protected " : 4 === n3.flags && (o3 = "private ");
            var a4 = Pr2([].concat(c(qo2(t3, e3, i4, { inline: true })), [o3, n3.readonly ? "readonly " : "", n3.nullable ? "?" : "", n3.type ? Pr2([t3.call(i4, "type"), " "]) : "", n3.byref ? "&" : "", n3.variadic ? "..." : "", "$", t3.call(i4, "name")]));
            return n3.value ? Br2(Pr2([a4, ho2(n3) ? " " : "", Lr2.printDanglingComments(t3, e3, true), Pr2([" =", ia2(n3.name, n3.value, t3.call(i4, "value"), false, e3)])])) : a4;
          case "variadic":
            return Pr2(["...", t3.call(i4, "what")]);
          case "property":
            return Br2(Pr2([n3.readonly ? "readonly " : "", n3.type ? Pr2([n3.nullable ? "?" : "", t3.call(i4, "type"), " "]) : "", "$", t3.call(i4, "name"), n3.value ? Pr2([" =", ia2(n3.name, n3.value, t3.call(i4, "value"), false, e3)]) : ""]));
          case "propertystatement":
            var h3 = [];
            t3.map(function(t4) {
              return h3.push.apply(h3, c(qo2(t4, e3, i4)));
            }, "properties");
            var u2, _2 = t3.map(function(t4) {
              return i4(t4);
            }, "properties"), d5 = n3.properties.some(function(t4) {
              return t4.value;
            });
            if (1 !== _2.length || n3.properties[0].comments)
              _2.length > 0 && (u2 = Gr2(_2[0]));
            else
              u2 = l(_2, 1)[0];
            var p2 = n3.visibility || null === n3.visibility;
            return Br2(Pr2([].concat(h3, [p2 ? Pr2([null === n3.visibility ? "var" : n3.visibility, ""]) : "", n3.isStatic ? Pr2([p2 ? " " : "", "static"]) : "", u2 ? Pr2([" ", u2]) : "", Gr2(Pr2(_2.slice(1).map(function(t4) {
              return Pr2([",", d5 ? Wr2 : Mr2, t4]);
            })))])));
          case "if":
            var f2 = [], T3 = Zo(t3, e3, i4, "body"), k3 = Br2(Pr2(["if (", Br2(Pr2([Gr2(Pr2([Yr2, t3.call(i4, "test")])), Yr2])), ")", T3]));
            if (f2.push(k3, po2(t3) || !n3.body ? "" : Wr2), n3.alternate) {
              f2.push(n3.shortForm ? "" : "} ");
              var E2 = co2(n3.body) && n3.body.comments.some(function(t4) {
                return t4.trailing && !Lr2.isBlockComment(t4);
              }) || function(t4) {
                if (!t4.comments)
                  return false;
                var e4 = to2(t4.comments.filter(function(t5) {
                  return !t5.leading && !t5.trailing;
                }));
                return e4 && !Lr2.isBlockComment(e4);
              }(n3), m3 = !E2;
              f2.push(m3 ? "" : Wr2), ho2(n3) && f2.push(So2(e3.originalText, n3.body, e3) ? Wr2 : "", Lr2.printDanglingComments(t3, e3, true), E2 ? Wr2 : " "), f2.push("else", Br2("if" === n3.alternate.kind ? t3.call(i4, "alternate") : Zo(t3, e3, i4, "alternate")));
            } else
              f2.push(n3.body ? n3.shortForm ? "endif;" : "}" : "");
            return Pr2(f2);
          case "do":
            return Pr2(["do", Zo(t3, e3, i4, "body"), " while (", Br2(Pr2([Gr2(Pr2([Yr2, t3.call(i4, "test")])), Yr2])), ")"]);
          case "while":
          case "switch":
            return Br2(Pr2([n3.kind, " (", Br2(Pr2([Gr2(Pr2([Yr2, t3.call(i4, "test")])), Yr2])), ")", Zo(t3, e3, i4, "body")]));
          case "for":
            var x3 = Zo(t3, e3, i4, "body"), y2 = Lr2.printDanglingComments(t3, e3, true), v2 = y2 ? Pr2([y2, Yr2]) : "";
            return n3.init.length || n3.test.length || n3.increment.length ? Pr2([v2, Br2(Pr2(["for (", Br2(Pr2([Gr2(Pr2([Yr2, Br2(Pr2([Ur2(Pr2([",", Mr2]), t3.map(i4, "init"))])), ";", Mr2, Br2(Pr2([Ur2(Pr2([",", Mr2]), t3.map(i4, "test"))])), ";", Mr2, Br2(Ur2(Pr2([",", Mr2]), t3.map(i4, "increment")))])), Yr2])), ")", x3]))]) : Pr2([v2, Br2(Pr2(["for (;;)", x3]))]);
          case "foreach":
            var A3 = Zo(t3, e3, i4, "body"), g3 = Lr2.printDanglingComments(t3, e3, true), N2 = g3 ? Pr2([g3, Yr2]) : "";
            return Pr2([N2, Br2(Pr2(["foreach (", Br2(Pr2([Gr2(Pr2([Yr2, t3.call(i4, "source"), Mr2, "as ", Br2(n3.key ? Gr2(Ur2(Pr2([" =>", Mr2]), [t3.call(i4, "key"), t3.call(i4, "value")])) : t3.call(i4, "value"))])), Yr2])), ")", A3]))]);
          case "try":
            var L2 = [];
            return L2.push("try", Zo(t3, e3, i4, "body")), n3.catches && L2.push(Pr2(t3.map(i4, "catches"))), n3.always && L2.push(" finally", Zo(t3, e3, i4, "always")), Pr2(L2);
          case "catch":
            return Pr2([" catch", n3.what ? Pr2([" (", Ur2(" | ", t3.map(i4, "what")), n3.variable ? Pr2([" ", t3.call(i4, "variable")]) : "", ")"]) : "", Zo(t3, e3, i4, "body")]);
          case "case":
            return Pr2([n3.test ? Pr2(["case ", n3.test.comments ? Gr2(t3.call(i4, "test")) : t3.call(i4, "test"), ":"]) : "default:", n3.body && n3.body.children && n3.body.children.length ? Gr2(Pr2([po2(t3) ? "" : Wr2, t3.call(i4, "body")])) : ""]);
          case "break":
          case "continue":
            return n3.level && ("number" === n3.level.kind && "1" !== n3.level.value) ? Pr2(["".concat(n3.kind, " "), t3.call(i4, "level")]) : n3.kind;
          case "call":
            return 1 === n3.arguments.length && sa2(n3.arguments[0], e3.originalText, e3) ? Pr2([t3.call(i4, "what"), Pr2(["(", Ur2(", ", t3.map(i4, "arguments")), ")"])]) : _o2(n3.what) ? function(t4, e4, i5) {
              var n4 = [];
              function s5(t5) {
                var i6 = e4.originalText, n5 = Io2(i6, t5, e4);
                return ")" === i6.charAt(n5) ? Jr2(i6, n5 + 1, e4) : So2(i6, t5, e4);
              }
              function r4(t5) {
                var o5 = t5.getValue();
                if ("call" !== o5.kind || !_o2(o5.what) && "call" !== o5.what.kind)
                  if (_o2(o5)) {
                    var a6 = null;
                    a6 = "propertylookup" === o5.kind ? Do2(t5, e4, i5) : "nullsafepropertylookup" === o5.kind ? Po2(t5, e4, i5) : "staticlookup" === o5.kind ? Uo2(t5, e4, i5) : Mo2(t5, e4, i5), n4.unshift({ node: o5, needsParens: Rr(t5), printed: Lr2.printAllComments(t5, function() {
                      return a6;
                    }, e4) }), t5.call(function(t6) {
                      return r4(t6);
                    }, "what");
                  } else
                    n4.unshift({ node: o5, printed: t5.call(i5) });
                else
                  n4.unshift({ node: o5, printed: Pr2([Lr2.printAllComments(t5, function() {
                    return Pr2([Go2(t5, e4, i5)]);
                  }, e4), s5(o5) ? Wr2 : ""]) }), t5.call(function(t6) {
                    return r4(t6);
                  }, "what");
              }
              var o4 = t4.getValue();
              n4.unshift({ node: o4, printed: Go2(t4, e4, i5) }), t4.call(function(t5) {
                return r4(t5);
              }, "what");
              for (var a5 = 0; a5 < n4.length; ++a5)
                "call" === n4[a5].node.kind && n4[a5 - 1] && ["propertylookup", "nullsafepropertylookup", "staticlookup"].includes(n4[a5 - 1].node.kind) && n4[a5 - 1].needsParens && (n4[0].printed = Pr2(["(", n4[0].printed]), n4[a5 - 1].printed = Pr2([n4[a5 - 1].printed, ")"]));
              for (var h4 = [], l2 = [n4[0]], c2 = 1; c2 < n4.length && ("call" === n4[c2].node.kind || _o2(n4[c2].node) && n4[c2].node.offset && "number" === n4[c2].node.offset.kind); ++c2)
                l2.push(n4[c2]);
              if ("call" !== n4[0].node.kind)
                for (; c2 + 1 < n4.length && (_o2(n4[c2].node) && _o2(n4[c2 + 1].node)); ++c2)
                  l2.push(n4[c2]);
              h4.push(l2), l2 = [];
              for (var u3 = false; c2 < n4.length; ++c2) {
                if (u3 && _o2(n4[c2].node)) {
                  if ("offsetlookup" === n4[c2].node.kind && n4[c2].node.offset && "number" === n4[c2].node.offset.kind) {
                    l2.push(n4[c2]);
                    continue;
                  }
                  h4.push(l2), l2 = [], u3 = false;
                }
                "call" === n4[c2].node.kind && (u3 = true), l2.push(n4[c2]), n4[c2].node.comments && Lr2.hasTrailingComment(n4[c2].node) && (h4.push(l2), l2 = [], u3 = false);
              }
              l2.length > 0 && h4.push(l2);
              function _3(t5) {
                var i6 = t5[1].length && "offsetlookup" === t5[1][0].node.kind;
                if (1 === t5[0].length) {
                  var n5 = t5[0][0].node;
                  return "variable" === n5.kind && ("this" === n5.name || d6 && s6(n5.name)) || Lo2(n5);
                }
                function s6(t6) {
                  return t6.length < e4.tabWidth;
                }
                var r5 = to2(t5[0]).node;
                return _o2(r5) && ("identifier" === r5.offset.kind || "variable" === r5.offset.kind) && i6;
              }
              var d6 = "expressionstatement" === t4.getParentNode().kind, p3 = h4.length >= 2 && !h4[1][0].node.comments && _3(h4);
              function f3(t5) {
                for (var e5 = [], i6 = 0; i6 < t5.length; i6++)
                  t5[i6 + 1] && t5[i6 + 1].needsParens ? (e5.push("(", t5[i6].printed, t5[i6 + 1].printed, ")"), i6++) : e5.push(t5[i6].printed);
                return Pr2(e5);
              }
              function T4(t5) {
                return 0 === t5.length ? "" : Gr2(Br2(Pr2([Wr2, Ur2(Wr2, t5.map(f3))])));
              }
              var k4 = h4.map(f3), E3 = Pr2(k4), m4 = p3 ? 3 : 2, x4 = h4.slice(0, m4).reduce(function(t5, e5) {
                return t5.concat(e5);
              }, []), y3 = x4.slice(1, -1).some(function(t5) {
                return Lr2.hasLeadingComment(t5.node);
              }) || x4.slice(0, -1).some(function(t5) {
                return Lr2.hasTrailingComment(t5.node);
              }) || h4[m4] && Lr2.hasLeadingComment(h4[m4][0].node), v3 = No2(t4, "encapsed");
              if (h4.length <= m4 && !y3 || v3)
                return Br2(E3);
              var A4 = to2(p3 ? h4.slice(1, 2)[0] : h4[0]).node, g4 = "call" !== A4.kind && s5(A4), N3 = Pr2([f3(h4[0]), p3 ? Pr2(h4.slice(1, 2).map(f3)) : "", g4 ? Wr2 : "", T4(h4.slice(p3 ? 2 : 1))]), L3 = n4.filter(function(t5) {
                return "call" === t5.node.kind;
              }).length;
              if (y3 || L3 >= 3 || k4.slice(0, -1).some(Kr2))
                return Br2(N3);
              return Pr2([Kr2(E3) || g4 ? Dr2 : "", Hr2([E3, N3])]);
            }(t3, e3, i4) : Pr2([t3.call(i4, "what"), Go2(t3, e3, i4)]);
          case "new":
            var C3 = n3.what && "class" === n3.what.kind && n3.what.isAnonymous;
            if (!C3 && 1 === n3.arguments.length && sa2(n3.arguments[0], e3.originalText, e3))
              return Pr2(["new "].concat(c(t3.call(qo2, "what")), [t3.call(i4, "what"), "(", Ur2(", ", t3.map(i4, "arguments")), ")"]));
            var b3 = [];
            if (b3.push("new "), C3)
              b3.push.apply(b3, [n3.what.leadingComments && "commentblock" === n3.what.leadingComments[0].kind ? Pr2([Lr2.printComments(n3.what.leadingComments, e3), " "]) : ""].concat(c(t3.call(function(t4) {
                return qo2(t4, e3, i4, { inline: true });
              }, "what")), ["class", n3.arguments.length > 0 ? Pr2([" ", Go2(t3, e3, i4)]) : "", Br2(t3.call(i4, "what"))]));
            else {
              var I3 = Pr2([t3.call(i4, "what"), Go2(t3, e3, i4)]);
              b3.push(lo2(n3.what) ? Gr2(I3) : I3);
            }
            return Pr2(b3);
          case "clone":
            return Pr2(["clone ", n3.what.comments ? Gr2(t3.call(i4, "what")) : t3.call(i4, "what")]);
          case "propertylookup":
          case "nullsafepropertylookup":
          case "staticlookup":
          case "offsetlookup":
            var S3, O3 = t3.getParentNode(), R2 = 0;
            do {
              S3 = t3.getParentNode(R2), R2++;
            } while (S3 && _o2(S3));
            var w3 = No2(t3, "encapsed") || S3 && ("new" === S3.kind || "assign" === S3.kind && "variable" !== S3.left.kind) || "offsetlookup" === n3.kind || (Lo2(n3.what) || "variable" === n3.what.kind) && ["identifier", "variable", "encapsedpart"].includes(n3.offset.kind) && O3 && !_o2(O3);
            return Pr2([t3.call(i4, "what"), w3 ? Yo(t3, e3, i4) : Br2(Gr2(Pr2([Yr2, Yo(t3, e3, i4)])))]);
          case "exit":
            return Br2(Pr2([n3.useDie ? "die" : "exit", "(", n3.expression ? sa2(n3.expression, e3.originalText, e3) ? t3.call(i4, "expression") : Pr2([Gr2(Pr2([Yr2, t3.call(i4, "expression")])), Yr2]) : Lr2.printDanglingComments(t3, e3), ")"]));
          case "global":
            return Br2(Pr2(["global ", Gr2(Pr2([Ur2(Pr2([",", Mr2]), t3.map(i4, "items"))]))]));
          case "include":
            return Pr2([n3.require ? "require" : "include", n3.once ? "_once" : "", " ", n3.target.comments ? Gr2(t3.call(i4, "target")) : t3.call(i4, "target")]);
          case "label":
            return Pr2([t3.call(i4, "name"), ":"]);
          case "goto":
            return Pr2(["goto ", t3.call(i4, "label")]);
          case "throw":
            return Pr2(["throw ", n3.what.comments ? Gr2(t3.call(i4, "what")) : t3.call(i4, "what")]);
          case "silent":
            return Pr2(["@", t3.call(i4, "expr")]);
          case "halt":
            return Pr2([ho2(n3) ? Pr2([Lr2.printDanglingComments(t3, e3, true), Wr2]) : "", "__halt_compiler();", n3.after]);
          case "eval":
            return Br2(Pr2(["eval(", sa2(n3.source, e3.originalText, e3) ? t3.call(i4, "source") : Pr2([Gr2(Pr2([Yr2, t3.call(i4, "source")])), Yr2]), ")"]));
          case "echo":
            var D3, P2 = t3.map(function(t4) {
              return i4(t4);
            }, "expressions");
            if (1 !== P2.length || n3.expressions[0].comments)
              P2.length > 0 && (D3 = go2(n3.expressions[0]) || n3.expressions[0].comments ? Gr2(P2[0]) : Vr2(P2[0]));
            else
              D3 = l(P2, 1)[0];
            return Br2(Pr2([n3.shortForm ? "" : "echo ", D3 || "", Gr2(Pr2(P2.slice(1).map(function(t4) {
              return Pr2([",", Mr2, t4]);
            })))]));
          case "print":
            return Pr2(["print ", n3.expression.comments ? Gr2(t3.call(i4, "expression")) : t3.call(i4, "expression")]);
          case "return":
            var U2 = [];
            if (U2.push("return"), n3.expr) {
              var M3 = t3.call(i4, "expr");
              U2.push(" ", n3.expr.comments ? Gr2(M3) : M3);
            }
            return ho2(n3) && U2.push(" ", Lr2.printDanglingComments(t3, e3, true)), Pr2(U2);
          case "isset":
          case "unset":
            return Br2(Pr2([n3.kind, Go2(t3, e3, i4, "variables")]));
          case "empty":
            return Br2(Pr2(["empty(", Gr2(Pr2([Yr2, t3.call(i4, "expression")])), Yr2, ")"]));
          case "variable":
            var F2 = t3.getParentNode(), B2 = t3.getParentNode(1), H4 = "assign" === F2.kind ? "" : n3.byref ? "&" : "", G2 = "encapsedpart" === F2.kind && "simple" === F2.syntax && F2.curly || B2 && "offsetlookup" === F2.kind && "encapsedpart" === B2.kind && "simple" === B2.syntax && B2.curly ? "" : "$", V2 = n3.curly ? "{" : "", Q2 = n3.curly ? "}" : "";
            return Pr2([H4, G2, V2, t3.call(i4, "name"), Q2]);
          case "constantstatement":
          case "classconstant":
            var W3, Y4 = qo2(t3, e3, i4), j2 = t3.map(function(t4) {
              return i4(t4);
            }, "constants");
            if (1 !== j2.length || n3.constants[0].comments)
              j2.length > 0 && (W3 = Gr2(j2[0]));
            else
              W3 = l(j2, 1)[0];
            return Br2(Pr2([].concat(c(Y4), [n3.visibility ? Pr2([n3.visibility, " "]) : "", "const", W3 ? Pr2([" ", W3]) : "", Gr2(Pr2(j2.slice(1).map(function(t4) {
              return Pr2([",", Wr2, t4]);
            })))])));
          case "constant":
            return ta2(n3.name, t3.call(i4, "name"), " =", n3.value, t3.call(i4, "value"), false, e3);
          case "static":
            var $2, z2 = t3.map(function(t4) {
              return i4(t4);
            }, "variables"), K2 = n3.variables.some(function(t4) {
              return t4.defaultValue;
            });
            if (1 !== z2.length || n3.variables[0].comments)
              z2.length > 0 && ($2 = Gr2(z2[0]));
            else
              $2 = l(z2, 1)[0];
            return Br2(Pr2(["static", $2 ? Pr2([" ", $2]) : "", Gr2(Pr2(z2.slice(1).map(function(t4) {
              return Pr2([",", K2 ? Wr2 : Mr2, t4]);
            })))]));
          case "staticvariable":
            return ta2(n3.variable, t3.call(i4, "variable"), " =", n3.defaultValue, t3.call(i4, "defaultValue"), false, e3);
          case "list":
          case "array":
            var X4 = "array" === n3.kind && Oo2(e3.phpVersion, "5.4") || "list" === n3.kind && (n3.shortForm || Oo2(e3.phpVersion, "7.1")), J3 = X4 ? "[" : Pr2([n3.kind, "("]), q2 = X4 ? "]" : ")";
            if (0 === n3.items.length)
              return ho2(n3) ? Br2(Pr2([J3, Lr2.printDanglingComments(t3, e3), Yr2, q2])) : Pr2([J3, q2]);
            var Z4 = to2(n3.items), tt2 = Z4 && "noop" === Z4.kind, et3 = l(n3.items.filter(function(t4) {
              return "noop" !== t4.kind;
            }).sort(function(t4, i5) {
              return e3.locStart(t4) - e3.locStart(i5);
            }), 1)[0], it3 = !(!et3 || !et3.key) && et3 && Zr(e3.originalText, e3.locStart(n3), e3.locStart(et3));
            return Br2(Pr2([J3, Gr2(Pr2([Yr2, $o2(t3, e3, i4)])), tt2 ? "," : "", Qr(!tt2 && Ro2(e3, "5.0") ? Pr2([Z4 && Ao2(Z4) ? Wr2 : "", ","]) : ""), Lr2.printDanglingComments(t3, e3, true), Yr2, q2]), { shouldBreak: it3 });
          case "entry":
            var nt2 = n3.byRef ? "&" : "", st3 = n3.unpack ? "..." : "";
            return n3.key ? ta2(n3.key, t3.call(i4, "key"), " =>", n3.value, t3.call(i4, "value"), nt2, e3) : Pr2([nt2, st3, t3.call(i4, "value")]);
          case "yield":
            var rt3 = Pr2([n3.key ? Pr2([t3.call(i4, "key"), " => "]) : "", t3.call(i4, "value")]);
            return Pr2(["yield", n3.key || n3.value ? " " : "", n3.value && n3.value.comments ? Gr2(rt3) : rt3]);
          case "yieldfrom":
            return Pr2(["yield from ", n3.value.comments ? Gr2(t3.call(i4, "value")) : t3.call(i4, "value")]);
          case "unary":
            return Pr2([n3.type, t3.call(i4, "what")]);
          case "pre":
            return Pr2([n3.type + n3.type, t3.call(i4, "what")]);
          case "post":
            return Pr2([t3.call(i4, "what"), n3.type + n3.type]);
          case "cast":
            return Pr2(["(", n3.type, ") ", n3.expr.comments ? Gr2(t3.call(i4, "expr")) : t3.call(i4, "expr")]);
          case "assignref":
          case "assign":
            var ot3 = "assignref" === n3.kind;
            return ta2(n3.left, t3.call(i4, "left"), Pr2([" ", ot3 ? "=" : n3.operator]), n3.right, t3.call(i4, "right"), ot3, e3);
          case "bin":
            var at3 = t3.getParentNode(), ht3 = t3.getParentNode(1), lt3 = n3 !== at3.body && ("if" === at3.kind || "while" === at3.kind || "switch" === at3.kind || "do" === at3.kind), ct3 = Wo2(t3, i4, e3, false, lt3);
            if (lt3)
              return Pr2(ct3);
            if ("unary" === at3.kind || _o2(at3) && "offsetlookup" !== at3.kind)
              return Br2(Pr2([Gr2(Pr2([Yr2, Pr2(ct3)])), Yr2]));
            var ut3 = n3 !== at3.body && "for" === at3.kind || "retif" === at3.kind && ht3 && "return" !== ht3.kind, _t3 = ["assign", "property", "constant", "staticvariable", "entry"].includes(at3.kind), dt3 = "bin" === n3.left.kind && ro2(n3.type, n3.left.type);
            if (ut3 || Qo(n3) && !dt3 || !Qo(n3) && _t3)
              return Br2(Pr2(ct3));
            var pt3 = Pr2(ct3.slice(1));
            return Br2(Pr2([ct3.length > 0 ? ct3[0] : "", Gr2(pt3)]));
          case "retif":
            var ft3, Tt3 = [], kt3 = t3.getParentNode(), Et3 = 0;
            do {
              ft3 = t3.getParentNode(Et3), Et3++;
            } while (ft3 && "retif" === ft3.kind);
            var mt3 = ft3 || kt3, xt3 = "bin" === n3.falseExpr.kind ? Gr2(t3.call(i4, "falseExpr")) : t3.call(i4, "falseExpr"), yt3 = Pr2([n3.trueExpr ? Mr2 : " ", "?", n3.trueExpr ? Pr2([" ", "bin" === n3.trueExpr.kind ? Gr2(t3.call(i4, "trueExpr")) : t3.call(i4, "trueExpr"), Mr2]) : "", ":", n3.trueExpr ? Pr2([" ", xt3]) : Pr2([Vo2(n3.falseExpr) ? " " : Mr2, xt3])]);
            Tt3.push(yt3);
            var vt3 = function(t4) {
              return kt3 === mt3 ? Br2(t4) : t4;
            }, At3 = t3.getParentNode(1), gt3 = "cast" === kt3.kind && At3 ? At3 : kt3, Nt3 = ["propertylookup", "nullsafepropertylookup", "staticlookup"].includes(gt3.kind), Lt3 = t3.call(i4, "test");
            if (!n3.trueExpr) {
              var Ct3 = Pr2([Lt3, "bin" === gt3.kind || ["print", "echo", "return", "include"].includes(mt3.kind) ? Gr2(Pr2(Tt3)) : Pr2(Tt3)]);
              return "call" === gt3.kind && gt3.what === n3 || "unary" === gt3.kind || _o2(gt3) && "offsetlookup" !== gt3.kind ? Br2(Pr2([Gr2(Pr2([Yr2, Ct3])), Yr2])) : vt3(Ct3);
            }
            return vt3(Pr2(["retif" === n3.test.kind ? Gr2(Lt3) : Lt3, Gr2(Pr2(Tt3)), Nt3 ? Yr2 : ""]));
          case "boolean":
            return n3.value ? "true" : "false";
          case "number":
            return so2(n3.value);
          case "string":
            if ("encapsedpart" === t3.getParentNode().kind) {
              var bt3 = t3.getParentNode(1), It3 = 0, St3 = Oo2(e3.phpVersion, "7.3"), Ot3 = jr2;
              if ("heredoc" === bt3.type) {
                Ot3 = St3 ? Wr2 : jr2;
                var Rt3 = bt3.raw.split(/\r?\n/g);
                -1 === (It3 = Rt3[Rt3.length - 1].search(/\S/)) && (It3 = Rt3[Rt3.length - 2].search(/\S/));
              }
              return Ur2(Ot3, n3.raw.split(/\r?\n/g).map(function(t4, e4) {
                return e4 > 0 || 0 === n3.loc.start.column ? t4.substring(It3) : t4;
              }));
            }
            var wt3 = xo2(n3, e3) ? '"' : "'", Dt3 = n3.raw;
            return "b" === n3.raw[0] && (Dt3 = Dt3.slice(1)), ['"', "'"].includes(Dt3[0]) && (Dt3 = Dt3.substr(1)), ['"', "'"].includes(Dt3[Dt3.length - 1]) && (Dt3 = Dt3.substr(0, Dt3.length - 1)), Pr2(["b" === n3.raw[0] ? "b" : "", wt3, Ur2(jr2, Dt3.split(/\r?\n/g)), wt3]);
          case "intersectiontype":
            return ra2(t3, i4, "&");
          case "uniontype":
            return ra2(t3, i4, "|");
          case "encapsedpart":
            var Pt3 = "simple" === n3.syntax && n3.curly || "complex" === n3.syntax ? Pr2([n3.curly ? "$" : "", "{"]) : "", Ut3 = "simple" === n3.syntax && n3.curly || "complex" === n3.syntax ? "}" : "";
            return Pr2([Pt3, t3.call(i4, "expression"), Ut3]);
          case "encapsed":
            switch (n3.type) {
              case "string":
              case "shell":
              case "heredoc":
                var Mt3 = Oo2(e3.phpVersion, "7.3") ? Wr2 : jr2;
                return Pr2([jo2(n3), "heredoc" === n3.type ? Mt3 : "", Pr2(t3.map(i4, "value")), jo2(n3, { opening: false }), "heredoc" === n3.type && uo2(t3) ? Wr2 : ""]);
              default:
                return "Have not implemented kind ".concat(n3.type, " yet.");
            }
          case "inline":
            return Ur2(jr2, n3.raw.replace("___PSEUDO_INLINE_PLACEHOLDER___", "").split(/\r?\n/g));
          case "magic":
            return n3.value;
          case "nowdoc":
            var Ft3 = Oo2(e3.phpVersion, "7.3") ? Wr2 : jr2;
            return Pr2(["<<<'", n3.label, "'", Ft3, Ur2(Ft3, n3.value.split(/\r?\n/g)), Ft3, n3.label, uo2(t3) ? Wr2 : ""]);
          case "name":
            return Pr2(["rn" === n3.resolution ? "namespace\\" : "", n3.name]);
          case "literal":
            return t3.call(i4, "value");
          case "parentreference":
            return "parent";
          case "selfreference":
            return "self";
          case "staticreference":
            return "static";
          case "typereference":
            return n3.name;
          case "nullkeyword":
            return "null";
          case "identifier":
            return "method" === t3.getParentNode().kind && (n3.name = bo2(n3.name)), t3.call(i4, "name");
          case "match":
            var Bt2 = t3.map(function(t4, e4) {
              var n4 = null === t4.getValue().conds ? "default" : Pr2(t4.map(function(t5, e5) {
                return Br2(Pr2(e5 > 0 ? [",", Mr2, i4(t5)] : [i4(t5)]));
              }, "conds")), s5 = t4.call(i4, "body");
              return Pr2(e4 > 0 ? [", ", Wr2, n4, " => ", s5] : [Wr2, n4, " => ", s5]);
            }, "arms");
            return Br2(Pr2(["match (", Br2(Pr2([Yr2, Gr2(Pr2([t3.call(i4, "cond")])), Yr2])), ") {", Br2(Gr2(Pr2([].concat(c(Bt2), [e3.trailingCommaPHP ? Qr(",") : ""])))), " ", Yr2, "}"]));
          case "noop":
            return n3.comments ? Lr2.printComments(t3.getValue().comments, e3) : "";
          case "namedargument":
            return Pr2([n3.name, ": ", t3.call(i4, "value")]);
          case "enumcase":
            return Br2(Pr2(["case ", t3.call(i4, "name"), n3.value ? Pr2([" =", ia2(n3.name, n3.value, t3.call(i4, "value"), false, e3)]) : ""]));
          case "variadicplaceholder":
            return "...";
          default:
            return "Have not implemented kind ".concat(n3.kind, " yet.");
        }
      }(t2, e2, i3), r2 = [], o2 = Rr(t2);
      return o2 && r2.unshift("("), r2.push(s3), o2 && r2.push(")"), no2(t2) && r2.push(";"), ao2(t2) && r2.push(Wr2), Pr2(r2);
    };
    var aa2 = function(t2, e2) {
      if (["loc", "range", "raw", "comments", "leadingComments", "trailingComments", "parenthesizedExpression", "parent", "prev", "start", "end", "tokens", "errors", "extra"].forEach(function(t3) {
        delete e2[t3];
      }), "string" === t2.kind && delete e2.isDoubleQuote, ["array", "list"].includes(t2.kind) && delete e2.shortForm, "inline" === t2.kind) {
        if (t2.value.includes("___PSEUDO_INLINE_PLACEHOLDER___"))
          return null;
        e2.value = e2.value.replace(/\r\n?|\n/g, "");
      }
      if (("continue" === t2.kind || "break" === t2.kind) && t2.level) {
        var i3 = e2.level;
        "number" === i3.kind && (e2.level = "1" === i3.value ? null : i3);
      }
      if ("block" === t2.kind && 1 === t2.children.length && "block" === t2.children[0].kind)
        for (; "block" === e2.children[0].kind; )
          e2.children = e2.children[0].children;
      if ("number" === t2.kind && (e2.value = Ys2.printNumber(t2.value)), ["foreach", "for", "if", "while", "do"].includes(t2.kind) && (t2.body && "block" !== t2.body.kind ? e2.body = { kind: "block", children: [e2.body] } : e2.body = e2.body ? e2.body : null, t2.alternate && "block" !== t2.alternate.kind ? e2.alternate = { kind: "block", children: [e2.alternate] } : e2.alternate = e2.alternate ? e2.alternate : null), "usegroup" === t2.kind && "string" == typeof t2.name && (e2.name = e2.name.replace(/^\\/, "")), "useitem" === t2.kind && (e2.name = e2.name.replace(/^\\/, "")), "method" === t2.kind && "identifier" === t2.name.kind && (e2.name.name = Ys2.normalizeMagicMethodName(e2.name.name)), "noop" === t2.kind)
        return null;
    }, ha2 = "PHP", la2 = { phpVersion: { since: "0.13.0", category: ha2, type: "choice", default: "7.0", description: "Minimum target PHP version.", choices: [{ value: "5.0" }, { value: "5.1" }, { value: "5.2" }, { value: "5.3" }, { value: "5.4" }, { value: "5.5" }, { value: "5.6" }, { value: "7.0" }, { value: "7.1" }, { value: "7.2" }, { value: "7.3" }, { value: "7.4" }, { value: "8.0" }, { value: "8.1" }] }, trailingCommaPHP: { since: "0.0.0", category: ha2, type: "boolean", default: true, description: "Print trailing commas wherever possible when multi-line." }, braceStyle: { since: "0.10.0", category: ha2, type: "choice", default: "psr-2", description: "Print one space or newline for code blocks (classes and functions).", choices: [{ value: "psr-2", description: "Use PSR-2 brace style." }, { value: "1tbs", description: "Use 1tbs brace style." }] } }, ca2 = function(t2, e2, i3, n2) {
      if ("length" !== i3 && "prototype" !== i3 && "arguments" !== i3 && "caller" !== i3) {
        var s3 = Object.getOwnPropertyDescriptor(t2, i3), r2 = Object.getOwnPropertyDescriptor(e2, i3);
        !ua2(s3, r2) && n2 || Object.defineProperty(t2, i3, r2);
      }
    }, ua2 = function(t2, e2) {
      return void 0 === t2 || t2.configurable || t2.writable === e2.writable && t2.enumerable === e2.enumerable && t2.configurable === e2.configurable && (t2.writable || t2.value === e2.value);
    }, _a3 = function(t2, e2) {
      var i3 = Object.getPrototypeOf(e2);
      i3 !== Object.getPrototypeOf(t2) && Object.setPrototypeOf(t2, i3);
    }, da2 = function(t2, e2) {
      return "/* Wrapped ".concat(t2, "*/\n").concat(e2);
    }, pa2 = Object.getOwnPropertyDescriptor(Function.prototype, "toString"), fa2 = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name"), Ta2 = function(t2, e2, i3) {
      var n2 = "" === i3 ? "" : "with ".concat(i3.trim(), "() "), s3 = da2.bind(null, n2, e2.toString());
      Object.defineProperty(s3, "name", fa2), Object.defineProperty(t2, "toString", r(r({}, pa2), {}, { value: s3 }));
    }, ka2 = function(t2, e2) {
      var i3, n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, s3 = n2.ignoreNonConfigurable, r2 = void 0 !== s3 && s3, o2 = t2.name, a4 = d4(Reflect.ownKeys(e2));
      try {
        for (a4.s(); !(i3 = a4.n()).done; ) {
          var h3 = i3.value;
          ca2(t2, e2, h3, r2);
        }
      } catch (t3) {
        a4.e(t3);
      } finally {
        a4.f();
      }
      return _a3(t2, e2), Ta2(t2, e2, o2), t2;
    }, Ea2 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : {};
    function ma2(t2) {
      return t2 && t2.default || t2;
    }
    var xa2, ya2 = function() {
      var t2 = {};
      return t2.promise = new Promise(function(e2, i3) {
        t2.resolve = e2, t2.reject = i3;
      }), t2;
    }, va2 = function(t2, e2) {
      return t2(e2 = { exports: {} }, e2.exports), e2.exports;
    }(function(t2, e2) {
      var i3 = Ea2 && Ea2.__awaiter || function(t3, e3, i4, n3) {
        return new (i4 || (i4 = Promise))(function(s4, r3) {
          function o2(t4) {
            try {
              h3(n3.next(t4));
            } catch (t5) {
              r3(t5);
            }
          }
          function a4(t4) {
            try {
              h3(n3.throw(t4));
            } catch (t5) {
              r3(t5);
            }
          }
          function h3(t4) {
            t4.done ? s4(t4.value) : new i4(function(e4) {
              e4(t4.value);
            }).then(o2, a4);
          }
          h3((n3 = n3.apply(t3, e3 || [])).next());
        });
      }, n2 = Ea2 && Ea2.__importDefault || function(t3) {
        return t3 && t3.__esModule ? t3 : { default: t3 };
      };
      Object.defineProperty(e2, "__esModule", { value: true });
      var s3 = n2(ya2);
      function r2(t3) {
        var e3, n3, r3, a4 = this, h3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "maxAge", l2 = function() {
          return i3(a4, void 0, void 0, o().mark(function a5() {
            var l3, c3, u3, _2, p2 = this;
            return o().wrap(function(a6) {
              for (; ; )
                switch (a6.prev = a6.next) {
                  case 0:
                    if (void 0 === e3) {
                      a6.next = 2;
                      break;
                    }
                    return a6.abrupt("return");
                  case 2:
                    l3 = function(a7) {
                      return i3(p2, void 0, void 0, o().mark(function i4() {
                        var l4;
                        return o().wrap(function(i5) {
                          for (; ; )
                            switch (i5.prev = i5.next) {
                              case 0:
                                if (r3 = s3.default(), !((l4 = a7[1][h3] - Date.now()) <= 0)) {
                                  i5.next = 6;
                                  break;
                                }
                                return t3.delete(a7[0]), r3.resolve(), i5.abrupt("return");
                              case 6:
                                return e3 = a7[0], "function" == typeof (n3 = setTimeout(function() {
                                  t3.delete(a7[0]), r3 && r3.resolve();
                                }, l4)).unref && n3.unref(), i5.abrupt("return", r3.promise);
                              case 10:
                              case "end":
                                return i5.stop();
                            }
                        }, i4);
                      }));
                    }, a6.prev = 3, c3 = d4(t3), a6.prev = 5, c3.s();
                  case 7:
                    if ((u3 = c3.n()).done) {
                      a6.next = 13;
                      break;
                    }
                    return _2 = u3.value, a6.next = 11, l3(_2);
                  case 11:
                    a6.next = 7;
                    break;
                  case 13:
                    a6.next = 18;
                    break;
                  case 15:
                    a6.prev = 15, a6.t0 = a6.catch(5), c3.e(a6.t0);
                  case 18:
                    return a6.prev = 18, c3.f(), a6.finish(18);
                  case 21:
                    a6.next = 25;
                    break;
                  case 23:
                    a6.prev = 23, a6.t1 = a6.catch(3);
                  case 25:
                    e3 = void 0;
                  case 26:
                  case "end":
                    return a6.stop();
                }
            }, a5, null, [[3, 23], [5, 15, 18, 21]]);
          }));
        }, c2 = function() {
          e3 = void 0, void 0 !== n3 && (clearTimeout(n3), n3 = void 0), void 0 !== r3 && (r3.reject(void 0), r3 = void 0);
        }, u2 = t3.set.bind(t3);
        return t3.set = function(i4, n4) {
          t3.has(i4) && t3.delete(i4);
          var s4 = u2(i4, n4);
          return e3 && e3 === i4 && c2(), l2(), s4;
        }, l2(), t3;
      }
      e2.default = r2, t2.exports = r2, t2.exports.default = r2;
    });
    (xa2 = va2) && xa2.__esModule && Object.prototype.hasOwnProperty.call(xa2, "default") && xa2.default;
    var Aa2 = va2, ga2 = /* @__PURE__ */ new WeakMap(), Na2 = /* @__PURE__ */ new WeakMap(), La2 = function(t2) {
      var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i3 = e2.cacheKey, n2 = e2.cache, s3 = void 0 === n2 ? /* @__PURE__ */ new Map() : n2, r2 = e2.maxAge;
      "number" == typeof r2 && Aa2(s3);
      var o2 = function() {
        for (var e3 = arguments.length, n3 = new Array(e3), o3 = 0; o3 < e3; o3++)
          n3[o3] = arguments[o3];
        var a4 = i3 ? i3(n3) : n3[0], h3 = s3.get(a4);
        if (h3)
          return h3.data;
        var l2 = t2.apply(this, n3);
        return s3.set(a4, { data: l2, maxAge: r2 ? Date.now() + r2 : Number.POSITIVE_INFINITY }), l2;
      };
      return ka2(o2, t2, { ignoreNonConfigurable: true }), Na2.set(o2, s3), o2;
    };
    La2.decorator = function() {
      var t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      return function(e2, i3, n2) {
        var s3 = e2[i3];
        if ("function" != typeof s3)
          throw new TypeError("The decorated value must be a function");
        delete n2.value, delete n2.writable, n2.get = function() {
          if (!ga2.has(this)) {
            var e3 = La2(s3, t2);
            return ga2.set(this, e3), e3;
          }
          return ga2.get(this);
        };
      };
    }, La2.clear = function(t2) {
      var e2 = Na2.get(t2);
      if (!e2)
        throw new TypeError("Can't clear a function that was not memoized!");
      if ("function" != typeof e2.clear)
        throw new TypeError("The cache Map can't be cleared!");
      e2.clear();
    };
    var Ca2 = /@prettier|@format/, ba2 = La2(function(t2) {
      var e2 = As2(t2), i3 = l(e2.children, 1)[0], n2 = l(e2.comments.filter(function(t3) {
        return "commentblock" === t3.kind;
      }), 1)[0];
      if (i3 && n2 && n2.loc.start.line < i3.loc.start.line)
        return n2;
    });
    var Ia2 = function(t2) {
      if (!Ca2.test(t2))
        return false;
      var e2 = ba2(t2);
      if (e2) {
        var i3 = e2.value;
        return Ca2.test(i3);
      }
      return false;
    }, Sa2 = function(t2) {
      var e2 = ba2(t2);
      if (e2) {
        var i3 = e2.loc, n2 = i3.start.offset, s3 = i3.end.offset, r2 = t2.substring(0, n2), o2 = t2.substring(s3);
        return "".concat(r2).concat(function(t3, e3) {
          var i4 = t3.split(/\r?\n/g);
          if (1 === i4.length) {
            var n3 = l(/\/*\*\*(.*)\*\//.exec(i4[0]), 2)[1];
            i4 = ["/**", " * ".concat(n3.trim()), " */"];
          }
          var s4 = i4.findIndex(function(t4) {
            return /@\S/.test(t4);
          }) || 1;
          return i4.splice(s4, 0, " * @format"), i4.join(function(t4) {
            var e4 = t4.indexOf("\n");
            return e4 >= 0 && "\r" === t4.charAt(e4 - 1) ? "\r\n" : "\n";
          }(e3));
        }(e2.value, t2)).concat(o2);
      }
      var a4 = "<?php";
      if (!t2.startsWith(a4))
        return t2;
      var h3 = a4.length, c2 = t2.substring(0, h3), u2 = t2.substring(h3);
      return "".concat(c2, "\n/** \n * @format \n */\n").concat(u2);
    }, Oa2 = "programming", Ra2 = "text.html.php", wa2 = "application/x-httpd-php", Da2 = "#4F5D95", Pa2 = [".php", ".aw", ".ctp", ".fcgi", ".inc", ".php3", ".php4", ".php5", ".phps", ".phpt"], Ua2 = [".php", ".php_cs", ".php_cs.dist", "Phakefile"], Ma2 = ["php"], Fa2 = ["inc"], Ba2 = { name: "PHP", type: Oa2, tmScope: Ra2, aceMode: "php", codemirrorMode: "php", codemirrorMimeType: wa2, color: Da2, extensions: Pa2, filenames: Ua2, interpreters: Ma2, aliases: Fa2, languageId: 272 }, Ha2 = Object.freeze({ __proto__: null, name: "PHP", type: Oa2, tmScope: Ra2, aceMode: "php", codemirrorMode: "php", codemirrorMimeType: wa2, color: Da2, extensions: Pa2, filenames: Ua2, interpreters: Ma2, aliases: Fa2, languageId: 272, default: Ba2 }), Ga2 = "HTML+PHP", Va2 = "markup", Qa2 = "#4f5d95", Wa2 = "text.html.php", Ya2 = "HTML", ja2 = [".phtml"], $a2 = "application/x-httpd-php", za2 = { name: Ga2, type: Va2, color: Qa2, tmScope: Wa2, group: Ya2, extensions: ja2, aceMode: "php", codemirrorMode: "php", codemirrorMimeType: $a2, languageId: 151 }, Ka2 = Object.freeze({ __proto__: null, name: Ga2, type: Va2, color: Qa2, tmScope: Wa2, group: Ya2, extensions: ja2, aceMode: "php", codemirrorMode: "php", codemirrorMimeType: $a2, languageId: 151, default: za2 }), Xa2 = ma2(Ha2), Ja2 = ma2(Ka2), qa2 = n.default.doc.builders, Za2 = qa2.join, th = qa2.hardline, eh = Ia2, ih = Sa2;
    function nh(t2, e2) {
      var i3 = e2.extend, n2 = e2.override, s3 = {};
      for (var r2 in t2) {
        s3["languageId" === r2 ? "linguistLanguageId" : r2] = t2[r2];
      }
      if (i3)
        for (var o2 in i3)
          s3[o2] = (s3[o2] || []).concat(i3[o2]);
      for (var a4 in n2)
        s3[a4] = n2[a4];
      return s3;
    }
    var sh = [nh(Xa2, { override: { parsers: ["php"], vscodeLanguageIds: ["php"] } }), nh(Ja2, { override: { parsers: ["php"], vscodeLanguageIds: ["php"] } })], rh = function(t2) {
      return function(e2) {
        return e2.loc && e2.loc[t2] && e2.loc[t2].offset;
      };
    }, oh = { php: { parse: As2, astFormat: "php", locStart: rh("start"), locEnd: rh("end"), hasPragma: eh } }, ah = { php: { print: oa2, insertPragma: ih, massageAstNode: aa2, getCommentChildNodes: Lr2.getCommentChildNodes, canAttachComment: Lr2.canAttachComment, isBlockComment: Lr2.isBlockComment, handleComments: { ownLine: Lr2.handleOwnLineComment, endOfLine: Lr2.handleEndOfLineComment, remaining: Lr2.handleRemainingComment }, willPrintOwnComments: function(t2) {
      var e2 = t2.getValue();
      return e2 && "noop" === e2.kind;
    }, printComment: function(t2) {
      var e2 = t2.getValue();
      switch (e2.kind) {
        case "commentblock":
          if (!e2.value.includes("\n"))
            return e2.value;
          var i3 = e2.value.split(/\r?\n/g);
          return i3.slice(1, i3.length - 1).every(function(t3) {
            return "*" === t3.trim()[0];
          }) ? Za2(th, i3.map(function(t3, e3) {
            return (e3 > 0 ? " " : "") + (e3 < i3.length - 1 ? t3.trim() : t3.trimLeft());
          })) : e2.value;
        case "commentline":
          return e2.value.trimRight();
        default:
          throw new Error("Not a comment: ".concat(JSON.stringify(e2)));
      }
    }, hasPrettierIgnore: function(t2) {
      var e2 = function(t3) {
        return t3.value.includes("prettier-ignore") && !t3.value.includes("prettier-ignore-start") && !t3.value.includes("prettier-ignore-end");
      }, i3 = t2.getParentNode(), n2 = t2.getNode();
      return n2 && "classconstant" !== n2.kind && n2.comments && n2.comments.length > 0 && n2.comments.some(e2) || n2 && "constant" === n2.kind && i3 && "classconstant" === i3.kind && i3.comments && i3.comments.length > 0 && i3.comments.some(e2);
    } } }, hh2 = { languages: sh, printers: ah, parsers: oh, options: la2, defaultOptions: { tabWidth: 4 } }, lh = hh2.languages, ch = hh2.printers, uh = hh2.parsers, _h = hh2.options, dh = hh2.defaultOptions;
    t.default = hh2, t.defaultOptions = dh, t.languages = lh, t.options = _h, t.parsers = uh, t.printers = ch, Object.defineProperty(t, "__esModule", { value: true });
  });
})(standalone$1, standalone$1.exports);
const __prettierPhp = /* @__PURE__ */ getDefaultExportFromCjs(standalone$1.exports);
var Y = (r, i2) => () => (i2 || r((i2 = { exports: {} }).exports, i2), i2.exports);
var ee = Y((Rf2, Ct2) => {
  var Ye2 = function(r) {
    return r && r.Math == Math && r;
  };
  Ct2.exports = Ye2(typeof globalThis == "object" && globalThis) || Ye2(typeof window == "object" && window) || Ye2(typeof self == "object" && self) || Ye2(typeof global == "object" && global) || function() {
    return this;
  }() || Function("return this")();
});
var ke = Y((If2, Nt2) => {
  Nt2.exports = function(r) {
    try {
      return !!r();
    } catch {
      return true;
    }
  };
});
var Te = Y((Cf, jt2) => {
  var Ko = ke();
  jt2.exports = !Ko(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] != 7;
  });
});
var _r = Y((Nf, Mt2) => {
  var Qo = ke();
  Mt2.exports = !Qo(function() {
    var r = function() {
    }.bind();
    return typeof r != "function" || r.hasOwnProperty("prototype");
  });
});
var Ze = Y((jf, Dt2) => {
  var Yo = _r(), Xe2 = Function.prototype.call;
  Dt2.exports = Yo ? Xe2.bind(Xe2) : function() {
    return Xe2.apply(Xe2, arguments);
  };
});
var Ft = Y((Bt) => {
  var Lt2 = {}.propertyIsEnumerable, zt2 = Object.getOwnPropertyDescriptor, Xo = zt2 && !Lt2.call({ 1: 2 }, 1);
  Bt.f = Xo ? function(i2) {
    var s2 = zt2(this, i2);
    return !!s2 && s2.enumerable;
  } : Lt2;
});
var br = Y((Df, Ut2) => {
  Ut2.exports = function(r, i2) {
    return { enumerable: !(r & 1), configurable: !(r & 2), writable: !(r & 4), value: i2 };
  };
});
var de = Y((Lf, Vt) => {
  var Wt2 = _r(), $t = Function.prototype, Zo = $t.bind, xr2 = $t.call, ea2 = Wt2 && Zo.bind(xr2, xr2);
  Vt.exports = Wt2 ? function(r) {
    return r && ea2(r);
  } : function(r) {
    return r && function() {
      return xr2.apply(r, arguments);
    };
  };
});
var Jt = Y((zf2, Ht2) => {
  var Gt2 = de(), ra2 = Gt2({}.toString), ta2 = Gt2("".slice);
  Ht2.exports = function(r) {
    return ta2(ra2(r), 8, -1);
  };
});
var Qt = Y((Bf, Kt2) => {
  var na2 = ee(), ia2 = de(), sa2 = ke(), oa2 = Jt(), kr2 = na2.Object, aa2 = ia2("".split);
  Kt2.exports = sa2(function() {
    return !kr2("z").propertyIsEnumerable(0);
  }) ? function(r) {
    return oa2(r) == "String" ? aa2(r, "") : kr2(r);
  } : kr2;
});
var Sr = Y((Ff, Yt2) => {
  var ua2 = ee(), ca2 = ua2.TypeError;
  Yt2.exports = function(r) {
    if (r == null)
      throw ca2("Can't call method on " + r);
    return r;
  };
});
var er = Y((Uf2, Xt2) => {
  var la2 = Qt(), fa2 = Sr();
  Xt2.exports = function(r) {
    return la2(fa2(r));
  };
});
var ve = Y((Wf2, Zt) => {
  Zt.exports = function(r) {
    return typeof r == "function";
  };
});
var Ne = Y(($f2, en2) => {
  var pa2 = ve();
  en2.exports = function(r) {
    return typeof r == "object" ? r !== null : pa2(r);
  };
});
var rr = Y((Vf2, rn2) => {
  var Or2 = ee(), ha2 = ve(), da2 = function(r) {
    return ha2(r) ? r : void 0;
  };
  rn2.exports = function(r, i2) {
    return arguments.length < 2 ? da2(Or2[r]) : Or2[r] && Or2[r][i2];
  };
});
var nn = Y((Gf2, tn) => {
  var va2 = de();
  tn.exports = va2({}.isPrototypeOf);
});
var on = Y((Hf2, sn2) => {
  var ma2 = rr();
  sn2.exports = ma2("navigator", "userAgent") || "";
});
var hn = Y((Jf2, pn2) => {
  var fn2 = ee(), Tr2 = on(), an2 = fn2.process, un2 = fn2.Deno, cn = an2 && an2.versions || un2 && un2.version, ln = cn && cn.v8, he2, tr2;
  ln && (he2 = ln.split("."), tr2 = he2[0] > 0 && he2[0] < 4 ? 1 : +(he2[0] + he2[1]));
  !tr2 && Tr2 && (he2 = Tr2.match(/Edge\/(\d+)/), (!he2 || he2[1] >= 74) && (he2 = Tr2.match(/Chrome\/(\d+)/), he2 && (tr2 = +he2[1])));
  pn2.exports = tr2;
});
var Er = Y((Kf2, vn2) => {
  var dn2 = hn(), ga2 = ke();
  vn2.exports = !!Object.getOwnPropertySymbols && !ga2(function() {
    var r = Symbol();
    return !String(r) || !(Object(r) instanceof Symbol) || !Symbol.sham && dn2 && dn2 < 41;
  });
});
var qr = Y((Qf2, mn2) => {
  var ya2 = Er();
  mn2.exports = ya2 && !Symbol.sham && typeof Symbol.iterator == "symbol";
});
var Ar = Y((Yf2, gn2) => {
  var wa2 = ee(), _a3 = rr(), ba2 = ve(), xa2 = nn(), ka2 = qr(), Sa2 = wa2.Object;
  gn2.exports = ka2 ? function(r) {
    return typeof r == "symbol";
  } : function(r) {
    var i2 = _a3("Symbol");
    return ba2(i2) && xa2(i2.prototype, Sa2(r));
  };
});
var wn = Y((Xf2, yn2) => {
  var Oa2 = ee(), Ta2 = Oa2.String;
  yn2.exports = function(r) {
    try {
      return Ta2(r);
    } catch {
      return "Object";
    }
  };
});
var bn = Y((Zf2, _n2) => {
  var Ea2 = ee(), qa2 = ve(), Aa2 = wn(), Pa2 = Ea2.TypeError;
  _n2.exports = function(r) {
    if (qa2(r))
      return r;
    throw Pa2(Aa2(r) + " is not a function");
  };
});
var kn = Y((ep, xn2) => {
  var Ra2 = bn();
  xn2.exports = function(r, i2) {
    var s2 = r[i2];
    return s2 == null ? void 0 : Ra2(s2);
  };
});
var On = Y((rp, Sn2) => {
  var Ia2 = ee(), Pr2 = Ze(), Rr = ve(), Ir2 = Ne(), Ca2 = Ia2.TypeError;
  Sn2.exports = function(r, i2) {
    var s2, l;
    if (i2 === "string" && Rr(s2 = r.toString) && !Ir2(l = Pr2(s2, r)) || Rr(s2 = r.valueOf) && !Ir2(l = Pr2(s2, r)) || i2 !== "string" && Rr(s2 = r.toString) && !Ir2(l = Pr2(s2, r)))
      return l;
    throw Ca2("Can't convert object to primitive value");
  };
});
var En = Y((tp, Tn2) => {
  Tn2.exports = false;
});
var nr = Y((np, An2) => {
  var qn2 = ee(), Na2 = Object.defineProperty;
  An2.exports = function(r, i2) {
    try {
      Na2(qn2, r, { value: i2, configurable: true, writable: true });
    } catch {
      qn2[r] = i2;
    }
    return i2;
  };
});
var ir = Y((ip, Rn2) => {
  var ja2 = ee(), Ma2 = nr(), Pn2 = "__core-js_shared__", Da2 = ja2[Pn2] || Ma2(Pn2, {});
  Rn2.exports = Da2;
});
var Cr = Y((sp, Cn2) => {
  var La2 = En(), In2 = ir();
  (Cn2.exports = function(r, i2) {
    return In2[r] || (In2[r] = i2 !== void 0 ? i2 : {});
  })("versions", []).push({ version: "3.22.2", mode: La2 ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.22.2/LICENSE", source: "https://github.com/zloirock/core-js" });
});
var jn = Y((op, Nn2) => {
  var za2 = ee(), Ba2 = Sr(), Fa2 = za2.Object;
  Nn2.exports = function(r) {
    return Fa2(Ba2(r));
  };
});
var Se = Y((ap, Mn2) => {
  var Ua2 = de(), Wa2 = jn(), $a2 = Ua2({}.hasOwnProperty);
  Mn2.exports = Object.hasOwn || function(i2, s2) {
    return $a2(Wa2(i2), s2);
  };
});
var Nr = Y((up, Dn) => {
  var Va2 = de(), Ga2 = 0, Ha2 = Math.random(), Ja2 = Va2(1 .toString);
  Dn.exports = function(r) {
    return "Symbol(" + (r === void 0 ? "" : r) + ")_" + Ja2(++Ga2 + Ha2, 36);
  };
});
var Wn = Y((cp, Un2) => {
  var Ka2 = ee(), Qa2 = Cr(), Ln2 = Se(), Ya2 = Nr(), zn2 = Er(), Fn2 = qr(), je2 = Qa2("wks"), Ee = Ka2.Symbol, Bn2 = Ee && Ee.for, Xa2 = Fn2 ? Ee : Ee && Ee.withoutSetter || Ya2;
  Un2.exports = function(r) {
    if (!Ln2(je2, r) || !(zn2 || typeof je2[r] == "string")) {
      var i2 = "Symbol." + r;
      zn2 && Ln2(Ee, r) ? je2[r] = Ee[r] : Fn2 && Bn2 ? je2[r] = Bn2(i2) : je2[r] = Xa2(i2);
    }
    return je2[r];
  };
});
var Hn = Y((lp, Gn2) => {
  var Za2 = ee(), eu2 = Ze(), $n2 = Ne(), Vn2 = Ar(), ru = kn(), tu = On(), nu = Wn(), iu = Za2.TypeError, su2 = nu("toPrimitive");
  Gn2.exports = function(r, i2) {
    if (!$n2(r) || Vn2(r))
      return r;
    var s2 = ru(r, su2), l;
    if (s2) {
      if (i2 === void 0 && (i2 = "default"), l = eu2(s2, r, i2), !$n2(l) || Vn2(l))
        return l;
      throw iu("Can't convert object to primitive value");
    }
    return i2 === void 0 && (i2 = "number"), tu(r, i2);
  };
});
var jr = Y((fp, Jn2) => {
  var ou = Hn(), au2 = Ar();
  Jn2.exports = function(r) {
    var i2 = ou(r, "string");
    return au2(i2) ? i2 : i2 + "";
  };
});
var Yn = Y((pp, Qn2) => {
  var uu = ee(), Kn2 = Ne(), Mr2 = uu.document, cu = Kn2(Mr2) && Kn2(Mr2.createElement);
  Qn2.exports = function(r) {
    return cu ? Mr2.createElement(r) : {};
  };
});
var Dr = Y((hp, Xn2) => {
  var lu = Te(), fu2 = ke(), pu = Yn();
  Xn2.exports = !lu && !fu2(function() {
    return Object.defineProperty(pu("div"), "a", { get: function() {
      return 7;
    } }).a != 7;
  });
});
var Lr = Y((ei) => {
  var hu = Te(), du2 = Ze(), vu = Ft(), mu = br(), gu = er(), yu = jr(), wu2 = Se(), _u = Dr(), Zn2 = Object.getOwnPropertyDescriptor;
  ei.f = hu ? Zn2 : function(i2, s2) {
    if (i2 = gu(i2), s2 = yu(s2), _u)
      try {
        return Zn2(i2, s2);
      } catch {
      }
    if (wu2(i2, s2))
      return mu(!du2(vu.f, i2, s2), i2[s2]);
  };
});
var ti = Y((vp, ri) => {
  var bu = Te(), xu2 = ke();
  ri.exports = bu && xu2(function() {
    return Object.defineProperty(function() {
    }, "prototype", { value: 42, writable: false }).prototype != 42;
  });
});
var zr = Y((mp, ii) => {
  var ni2 = ee(), ku2 = Ne(), Su2 = ni2.String, Ou = ni2.TypeError;
  ii.exports = function(r) {
    if (ku2(r))
      return r;
    throw Ou(Su2(r) + " is not an object");
  };
});
var $r = Y((oi) => {
  var Tu = ee(), Eu = Te(), qu2 = Dr(), Au2 = ti(), sr2 = zr(), si2 = jr(), Pu = Tu.TypeError, Br2 = Object.defineProperty, Ru = Object.getOwnPropertyDescriptor, Fr2 = "enumerable", Ur2 = "configurable", Wr2 = "writable";
  oi.f = Eu ? Au2 ? function(i2, s2, l) {
    if (sr2(i2), s2 = si2(s2), sr2(l), typeof i2 == "function" && s2 === "prototype" && "value" in l && Wr2 in l && !l[Wr2]) {
      var o = Ru(i2, s2);
      o && o[Wr2] && (i2[s2] = l.value, l = { configurable: Ur2 in l ? l[Ur2] : o[Ur2], enumerable: Fr2 in l ? l[Fr2] : o[Fr2], writable: false });
    }
    return Br2(i2, s2, l);
  } : Br2 : function(i2, s2, l) {
    if (sr2(i2), s2 = si2(s2), sr2(l), qu2)
      try {
        return Br2(i2, s2, l);
      } catch {
      }
    if ("get" in l || "set" in l)
      throw Pu("Accessors not supported");
    return "value" in l && (i2[s2] = l.value), i2;
  };
});
var or = Y((yp, ai2) => {
  var Iu = Te(), Cu2 = $r(), Nu = br();
  ai2.exports = Iu ? function(r, i2, s2) {
    return Cu2.f(r, i2, Nu(1, s2));
  } : function(r, i2, s2) {
    return r[i2] = s2, r;
  };
});
var Gr = Y((wp, ui) => {
  var ju = de(), Mu2 = ve(), Vr2 = ir(), Du = ju(Function.toString);
  Mu2(Vr2.inspectSource) || (Vr2.inspectSource = function(r) {
    return Du(r);
  });
  ui.exports = Vr2.inspectSource;
});
var fi = Y((_p2, li2) => {
  var Lu = ee(), zu = ve(), Bu2 = Gr(), ci2 = Lu.WeakMap;
  li2.exports = zu(ci2) && /native code/.test(Bu2(ci2));
});
var di = Y((bp, hi) => {
  var Fu = Cr(), Uu = Nr(), pi = Fu("keys");
  hi.exports = function(r) {
    return pi[r] || (pi[r] = Uu(r));
  };
});
var Hr = Y((xp, vi2) => {
  vi2.exports = {};
});
var bi = Y((kp, _i) => {
  var Wu2 = fi(), wi = ee(), Jr2 = de(), $u2 = Ne(), Vu2 = or(), Kr2 = Se(), Qr = ir(), Gu = di(), Hu2 = Hr(), mi = "Object already initialized", Xr = wi.TypeError, Ju2 = wi.WeakMap, ar2, ze, ur2, Ku = function(r) {
    return ur2(r) ? ze(r) : ar2(r, {});
  }, Qu2 = function(r) {
    return function(i2) {
      var s2;
      if (!$u2(i2) || (s2 = ze(i2)).type !== r)
        throw Xr("Incompatible receiver, " + r + " required");
      return s2;
    };
  };
  Wu2 || Qr.state ? (Oe2 = Qr.state || (Qr.state = new Ju2()), gi2 = Jr2(Oe2.get), Yr2 = Jr2(Oe2.has), yi2 = Jr2(Oe2.set), ar2 = function(r, i2) {
    if (Yr2(Oe2, r))
      throw new Xr(mi);
    return i2.facade = r, yi2(Oe2, r, i2), i2;
  }, ze = function(r) {
    return gi2(Oe2, r) || {};
  }, ur2 = function(r) {
    return Yr2(Oe2, r);
  }) : (qe2 = Gu("state"), Hu2[qe2] = true, ar2 = function(r, i2) {
    if (Kr2(r, qe2))
      throw new Xr(mi);
    return i2.facade = r, Vu2(r, qe2, i2), i2;
  }, ze = function(r) {
    return Kr2(r, qe2) ? r[qe2] : {};
  }, ur2 = function(r) {
    return Kr2(r, qe2);
  });
  var Oe2, gi2, Yr2, yi2, qe2;
  _i.exports = { set: ar2, get: ze, has: ur2, enforce: Ku, getterFor: Qu2 };
});
var Si = Y((Sp, ki) => {
  var Zr = Te(), Yu = Se(), xi = Function.prototype, Xu = Zr && Object.getOwnPropertyDescriptor, et2 = Yu(xi, "name"), Zu = et2 && function() {
  }.name === "something", ec2 = et2 && (!Zr || Zr && Xu(xi, "name").configurable);
  ki.exports = { EXISTS: et2, PROPER: Zu, CONFIGURABLE: ec2 };
});
var Ai = Y((Op2, qi) => {
  var rc2 = ee(), Oi2 = ve(), tc2 = Se(), Ti = or(), nc2 = nr(), ic = Gr(), Ei2 = bi(), sc2 = Si().CONFIGURABLE, oc = Ei2.get, ac = Ei2.enforce, uc2 = String(String).split("String");
  (qi.exports = function(r, i2, s2, l) {
    var o = l ? !!l.unsafe : false, h2 = l ? !!l.enumerable : false, f = l ? !!l.noTargetGet : false, p = l && l.name !== void 0 ? l.name : i2, g2;
    if (Oi2(s2) && (String(p).slice(0, 7) === "Symbol(" && (p = "[" + String(p).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!tc2(s2, "name") || sc2 && s2.name !== p) && Ti(s2, "name", p), g2 = ac(s2), g2.source || (g2.source = uc2.join(typeof p == "string" ? p : ""))), r === rc2) {
      h2 ? r[i2] = s2 : nc2(i2, s2);
      return;
    } else
      o ? !f && r[i2] && (h2 = true) : delete r[i2];
    h2 ? r[i2] = s2 : Ti(r, i2, s2);
  })(Function.prototype, "toString", function() {
    return Oi2(this) && oc(this).source || ic(this);
  });
});
var rt = Y((Tp, Pi2) => {
  var cc = Math.ceil, lc = Math.floor;
  Pi2.exports = function(r) {
    var i2 = +r;
    return i2 !== i2 || i2 === 0 ? 0 : (i2 > 0 ? lc : cc)(i2);
  };
});
var Ii = Y((Ep, Ri2) => {
  var fc = rt(), pc = Math.max, hc = Math.min;
  Ri2.exports = function(r, i2) {
    var s2 = fc(r);
    return s2 < 0 ? pc(s2 + i2, 0) : hc(s2, i2);
  };
});
var Ni = Y((qp2, Ci) => {
  var dc = rt(), vc = Math.min;
  Ci.exports = function(r) {
    return r > 0 ? vc(dc(r), 9007199254740991) : 0;
  };
});
var Mi = Y((Ap, ji2) => {
  var mc = Ni();
  ji2.exports = function(r) {
    return mc(r.length);
  };
});
var zi = Y((Pp, Li) => {
  var gc = er(), yc = Ii(), wc = Mi(), Di2 = function(r) {
    return function(i2, s2, l) {
      var o = gc(i2), h2 = wc(o), f = yc(l, h2), p;
      if (r && s2 != s2) {
        for (; h2 > f; )
          if (p = o[f++], p != p)
            return true;
      } else
        for (; h2 > f; f++)
          if ((r || f in o) && o[f] === s2)
            return r || f || 0;
      return !r && -1;
    };
  };
  Li.exports = { includes: Di2(true), indexOf: Di2(false) };
});
var Ui = Y((Rp2, Fi) => {
  var _c2 = de(), tt = Se(), bc = er(), xc = zi().indexOf, kc2 = Hr(), Bi2 = _c2([].push);
  Fi.exports = function(r, i2) {
    var s2 = bc(r), l = 0, o = [], h2;
    for (h2 in s2)
      !tt(kc2, h2) && tt(s2, h2) && Bi2(o, h2);
    for (; i2.length > l; )
      tt(s2, h2 = i2[l++]) && (~xc(o, h2) || Bi2(o, h2));
    return o;
  };
});
var $i = Y((Ip, Wi) => {
  Wi.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
});
var Gi = Y((Vi) => {
  var Sc = Ui(), Oc = $i(), Tc = Oc.concat("length", "prototype");
  Vi.f = Object.getOwnPropertyNames || function(i2) {
    return Sc(i2, Tc);
  };
});
var Ji = Y((Hi) => {
  Hi.f = Object.getOwnPropertySymbols;
});
var Qi = Y((jp2, Ki2) => {
  var Ec = rr(), qc = de(), Ac = Gi(), Pc2 = Ji(), Rc = zr(), Ic = qc([].concat);
  Ki2.exports = Ec("Reflect", "ownKeys") || function(i2) {
    var s2 = Ac.f(Rc(i2)), l = Pc2.f;
    return l ? Ic(s2, l(i2)) : s2;
  };
});
var Zi = Y((Mp2, Xi) => {
  var Yi2 = Se(), Cc = Qi(), Nc = Lr(), jc2 = $r();
  Xi.exports = function(r, i2, s2) {
    for (var l = Cc(i2), o = jc2.f, h2 = Nc.f, f = 0; f < l.length; f++) {
      var p = l[f];
      !Yi2(r, p) && !(s2 && Yi2(s2, p)) && o(r, p, h2(i2, p));
    }
  };
});
var rs = Y((Dp2, es2) => {
  var Mc2 = ke(), Dc = ve(), Lc2 = /#|\.prototype\./, Be = function(r, i2) {
    var s2 = Bc[zc2(r)];
    return s2 == Uc2 ? true : s2 == Fc ? false : Dc(i2) ? Mc2(i2) : !!i2;
  }, zc2 = Be.normalize = function(r) {
    return String(r).replace(Lc2, ".").toLowerCase();
  }, Bc = Be.data = {}, Fc = Be.NATIVE = "N", Uc2 = Be.POLYFILL = "P";
  es2.exports = Be;
});
var ns = Y((Lp2, ts2) => {
  var nt = ee(), Wc2 = Lr().f, $c2 = or(), Vc2 = Ai(), Gc2 = nr(), Hc2 = Zi(), Jc2 = rs();
  ts2.exports = function(r, i2) {
    var s2 = r.target, l = r.global, o = r.stat, h2, f, p, g2, c, t;
    if (l ? f = nt : o ? f = nt[s2] || Gc2(s2, {}) : f = (nt[s2] || {}).prototype, f)
      for (p in i2) {
        if (c = i2[p], r.noTargetGet ? (t = Wc2(f, p), g2 = t && t.value) : g2 = f[p], h2 = Jc2(l ? p : s2 + (o ? "." : "#") + p, r.forced), !h2 && g2 !== void 0) {
          if (typeof c == typeof g2)
            continue;
          Hc2(c, g2);
        }
        (r.sham || g2 && g2.sham) && $c2(c, "sham", true), Vc2(f, p, c, r);
      }
  };
});
var is = Y(() => {
  var Kc2 = ns(), Qc2 = ee();
  Kc2({ global: true }, { globalThis: Qc2 });
});
is();
var dt = Object.defineProperty, Yc = Object.getOwnPropertyDescriptor, vt = Object.getOwnPropertyNames, Xc = Object.prototype.hasOwnProperty, Me = (r, i2) => function() {
  return r && (i2 = (0, r[vt(r)[0]])(r = 0)), i2;
}, C = (r, i2) => function() {
  return i2 || (0, r[vt(r)[0]])((i2 = { exports: {} }).exports, i2), i2.exports;
}, mt = (r, i2) => {
  for (var s2 in i2)
    dt(r, s2, { get: i2[s2], enumerable: true });
}, Zc = (r, i2, s2, l) => {
  if (i2 && typeof i2 == "object" || typeof i2 == "function")
    for (let o of vt(i2))
      !Xc.call(r, o) && o !== s2 && dt(r, o, { get: () => i2[o], enumerable: !(l = Yc(i2, o)) || l.enumerable });
  return r;
}, gt = (r) => Zc(dt({}, "__esModule", { value: true }), r), I = Me({ "<define:process>"() {
} }), el = C({ "src/common/parser-create-error.js"(r, i2) {
  I();
  function s2(l, o) {
    let h2 = new SyntaxError(l + " (" + o.start.line + ":" + o.start.column + ")");
    return h2.loc = o, h2;
  }
  i2.exports = s2;
} }), Ss = C({ "src/utils/get-last.js"(r, i2) {
  I();
  var s2 = (l) => l[l.length - 1];
  i2.exports = s2;
} }), Os = C({ "src/utils/front-matter/parse.js"(r, i2) {
  I();
  var s2 = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
  function l(o) {
    let h2 = o.match(s2);
    if (!h2)
      return { content: o };
    let { startDelimiter: f, language: p, value: g2 = "", endDelimiter: c } = h2.groups, t = p.trim() || "yaml";
    if (f === "+++" && (t = "toml"), t !== "yaml" && f !== c)
      return { content: o };
    let [e] = h2;
    return { frontMatter: { type: "front-matter", lang: t, value: g2, startDelimiter: f, endDelimiter: c, raw: e.replace(/\n$/, "") }, content: e.replace(/[^\n]/g, " ") + o.slice(e.length) };
  }
  i2.exports = l;
} }), Ts = {};
mt(Ts, { EOL: () => lt, arch: () => rl, cpus: () => Cs, default: () => Ls, endianness: () => Es, freemem: () => Rs, getNetworkInterfaces: () => Ds, hostname: () => qs, loadavg: () => As, networkInterfaces: () => Ms, platform: () => tl, release: () => js, tmpDir: () => ut, tmpdir: () => ct, totalmem: () => Is, type: () => Ns, uptime: () => Ps });
function Es() {
  if (typeof cr > "u") {
    var r = new ArrayBuffer(2), i2 = new Uint8Array(r), s2 = new Uint16Array(r);
    if (i2[0] = 1, i2[1] = 2, s2[0] === 258)
      cr = "BE";
    else if (s2[0] === 513)
      cr = "LE";
    else
      throw new Error("unable to figure out endianess");
  }
  return cr;
}
function qs() {
  return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
}
function As() {
  return [];
}
function Ps() {
  return 0;
}
function Rs() {
  return Number.MAX_VALUE;
}
function Is() {
  return Number.MAX_VALUE;
}
function Cs() {
  return [];
}
function Ns() {
  return "Browser";
}
function js() {
  return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
}
function Ms() {
}
function Ds() {
}
function rl() {
  return "javascript";
}
function tl() {
  return "browser";
}
function ut() {
  return "/tmp";
}
var cr, ct, lt, Ls, nl = Me({ "node-modules-polyfills:os"() {
  I(), ct = ut, lt = `
`, Ls = { EOL: lt, tmpdir: ct, tmpDir: ut, networkInterfaces: Ms, getNetworkInterfaces: Ds, release: js, type: Ns, cpus: Cs, totalmem: Is, freemem: Rs, uptime: Ps, loadavg: As, hostname: qs, endianness: Es };
} }), il = C({ "node-modules-polyfills-commonjs:os"(r, i2) {
  I();
  var s2 = (nl(), gt(Ts));
  if (s2 && s2.default) {
    i2.exports = s2.default;
    for (let l in s2)
      i2.exports[l] = s2[l];
  } else
    s2 && (i2.exports = s2);
} }), sl = C({ "node_modules/detect-newline/index.js"(r, i2) {
  I();
  var s2 = (l) => {
    if (typeof l != "string")
      throw new TypeError("Expected a string");
    let o = l.match(/(?:\r?\n)/g) || [];
    if (o.length === 0)
      return;
    let h2 = o.filter((p) => p === `\r
`).length, f = o.length - h2;
    return h2 > f ? `\r
` : `
`;
  };
  i2.exports = s2, i2.exports.graceful = (l) => typeof l == "string" && s2(l) || `
`;
} }), ol = C({ "node_modules/jest-docblock/build/index.js"(r) {
  I(), Object.defineProperty(r, "__esModule", { value: true }), r.extract = n, r.parse = m2, r.parseWithComments = v, r.print = y, r.strip = u;
  function i2() {
    let d4 = il();
    return i2 = function() {
      return d4;
    }, d4;
  }
  function s2() {
    let d4 = l(sl());
    return s2 = function() {
      return d4;
    }, d4;
  }
  function l(d4) {
    return d4 && d4.__esModule ? d4 : { default: d4 };
  }
  var o = /\*\/$/, h2 = /^\/\*\*/, f = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, p = /(^|\s+)\/\/([^\r\n]*)/g, g2 = /^(\r?\n)+/, c = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, t = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, e = /(\r?\n|^) *\* ?/g, a3 = [];
  function n(d4) {
    let _ = d4.match(f);
    return _ ? _[0].trimLeft() : "";
  }
  function u(d4) {
    let _ = d4.match(f);
    return _ && _[0] ? d4.substring(_[0].length) : d4;
  }
  function m2(d4) {
    return v(d4).pragmas;
  }
  function v(d4) {
    let _ = (0, s2().default)(d4) || i2().EOL;
    d4 = d4.replace(h2, "").replace(o, "").replace(e, "$1");
    let O2 = "";
    for (; O2 !== d4; )
      O2 = d4, d4 = d4.replace(c, "".concat(_, "$1 $2").concat(_));
    d4 = d4.replace(g2, "").trimRight();
    let S2 = /* @__PURE__ */ Object.create(null), M2 = d4.replace(t, "").replace(g2, "").trimRight(), R;
    for (; R = t.exec(d4); ) {
      let $ = R[2].replace(p, "");
      typeof S2[R[1]] == "string" || Array.isArray(S2[R[1]]) ? S2[R[1]] = a3.concat(S2[R[1]], $) : S2[R[1]] = $;
    }
    return { comments: M2, pragmas: S2 };
  }
  function y(d4) {
    let { comments: _ = "", pragmas: O2 = {} } = d4, S2 = (0, s2().default)(_) || i2().EOL, M2 = "/**", R = " *", $ = " */", J2 = Object.keys(O2), X3 = J2.map((K) => w2(K, O2[K])).reduce((K, W2) => K.concat(W2), []).map((K) => R + " " + K + S2).join("");
    if (!_) {
      if (J2.length === 0)
        return "";
      if (J2.length === 1 && !Array.isArray(O2[J2[0]])) {
        let K = O2[J2[0]];
        return "".concat(M2, " ").concat(w2(J2[0], K)[0]).concat($);
      }
    }
    let F = _.split(S2).map((K) => "".concat(R, " ").concat(K)).join(S2) + S2;
    return M2 + S2 + (_ ? F : "") + (_ && J2.length ? R + S2 : "") + X3 + $;
  }
  function w2(d4, _) {
    return a3.concat(_).map((O2) => "@".concat(d4, " ").concat(O2).trim());
  }
} }), al = C({ "src/common/end-of-line.js"(r, i2) {
  I();
  function s2(f) {
    let p = f.indexOf("\r");
    return p >= 0 ? f.charAt(p + 1) === `
` ? "crlf" : "cr" : "lf";
  }
  function l(f) {
    switch (f) {
      case "cr":
        return "\r";
      case "crlf":
        return `\r
`;
      default:
        return `
`;
    }
  }
  function o(f, p) {
    let g2;
    switch (p) {
      case `
`:
        g2 = /\n/g;
        break;
      case "\r":
        g2 = /\r/g;
        break;
      case `\r
`:
        g2 = /\r\n/g;
        break;
      default:
        throw new Error('Unexpected "eol" '.concat(JSON.stringify(p), "."));
    }
    let c = f.match(g2);
    return c ? c.length : 0;
  }
  function h2(f) {
    return f.replace(/\r\n?/g, `
`);
  }
  i2.exports = { guessEndOfLine: s2, convertEndOfLineToChars: l, countEndOfLineChars: o, normalizeEndOfLine: h2 };
} }), ul = C({ "src/language-js/utils/get-shebang.js"(r, i2) {
  I();
  function s2(l) {
    if (!l.startsWith("#!"))
      return "";
    let o = l.indexOf(`
`);
    return o === -1 ? l : l.slice(0, o);
  }
  i2.exports = s2;
} }), cl = C({ "src/language-js/pragma.js"(r, i2) {
  I();
  var { parseWithComments: s2, strip: l, extract: o, print: h2 } = ol(), { normalizeEndOfLine: f } = al(), p = ul();
  function g2(e) {
    let a3 = p(e);
    a3 && (e = e.slice(a3.length + 1));
    let n = o(e), { pragmas: u, comments: m2 } = s2(n);
    return { shebang: a3, text: e, pragmas: u, comments: m2 };
  }
  function c(e) {
    let a3 = Object.keys(g2(e).pragmas);
    return a3.includes("prettier") || a3.includes("format");
  }
  function t(e) {
    let { shebang: a3, text: n, pragmas: u, comments: m2 } = g2(e), v = l(n), y = h2({ pragmas: Object.assign({ format: "" }, u), comments: m2.trimStart() });
    return (a3 ? "".concat(a3, `
`) : "") + f(y) + (v.startsWith(`
`) ? `
` : `

`) + v;
  }
  i2.exports = { hasPragma: c, insertPragma: t };
} }), ll = C({ "src/language-css/pragma.js"(r, i2) {
  I();
  var s2 = cl(), l = Os();
  function o(f) {
    return s2.hasPragma(l(f).content);
  }
  function h2(f) {
    let { frontMatter: p, content: g2 } = l(f);
    return (p ? p.raw + `

` : "") + s2.insertPragma(g2);
  }
  i2.exports = { hasPragma: o, insertPragma: h2 };
} }), fl = C({ "src/utils/text/skip.js"(r, i2) {
  I();
  function s2(p) {
    return (g2, c, t) => {
      let e = t && t.backwards;
      if (c === false)
        return false;
      let { length: a3 } = g2, n = c;
      for (; n >= 0 && n < a3; ) {
        let u = g2.charAt(n);
        if (p instanceof RegExp) {
          if (!p.test(u))
            return n;
        } else if (!p.includes(u))
          return n;
        e ? n-- : n++;
      }
      return n === -1 || n === a3 ? n : false;
    };
  }
  var l = s2(/\s/), o = s2(" 	"), h2 = s2(",; 	"), f = s2(/[^\n\r]/);
  i2.exports = { skipWhitespace: l, skipSpaces: o, skipToLineEnd: h2, skipEverythingButNewLine: f };
} }), pl = C({ "src/utils/line-column-to-index.js"(r, i2) {
  I(), i2.exports = function(s2, l) {
    let o = 0;
    for (let h2 = 0; h2 < s2.line - 1; ++h2)
      o = l.indexOf(`
`, o) + 1;
    return o + s2.column;
  };
} }), ss = C({ "src/language-css/loc.js"(r, i2) {
  I();
  var { skipEverythingButNewLine: s2 } = fl(), l = Ss(), o = pl();
  function h2(n, u) {
    return typeof n.sourceIndex == "number" ? n.sourceIndex : n.source ? o(n.source.start, u) - 1 : null;
  }
  function f(n, u) {
    if (n.type === "css-comment" && n.inline)
      return s2(u, n.source.startOffset);
    let m2 = n.nodes && l(n.nodes);
    return m2 && n.source && !n.source.end && (n = m2), n.source && n.source.end ? o(n.source.end, u) : null;
  }
  function p(n, u) {
    n.source && (n.source.startOffset = h2(n, u), n.source.endOffset = f(n, u));
    for (let m2 in n) {
      let v = n[m2];
      m2 === "source" || !v || typeof v != "object" || (v.type === "value-root" || v.type === "value-unknown" ? g2(v, c(n), v.text || v.value) : p(v, u));
    }
  }
  function g2(n, u, m2) {
    n.source && (n.source.startOffset = h2(n, m2) + u, n.source.endOffset = f(n, m2) + u);
    for (let v in n) {
      let y = n[v];
      v === "source" || !y || typeof y != "object" || g2(y, u, m2);
    }
  }
  function c(n) {
    let u = n.source.startOffset;
    return typeof n.prop == "string" && (u += n.prop.length), n.type === "css-atrule" && typeof n.name == "string" && (u += 1 + n.name.length + n.raws.afterName.match(/^\s*:?\s*/)[0].length), n.type !== "css-atrule" && n.raws && typeof n.raws.between == "string" && (u += n.raws.between.length), u;
  }
  function t(n) {
    let u = "initial", m2 = "initial", v, y = false, w2 = [];
    for (let d4 = 0; d4 < n.length; d4++) {
      let _ = n[d4];
      switch (u) {
        case "initial":
          if (_ === "'") {
            u = "single-quotes";
            continue;
          }
          if (_ === '"') {
            u = "double-quotes";
            continue;
          }
          if ((_ === "u" || _ === "U") && n.slice(d4, d4 + 4).toLowerCase() === "url(") {
            u = "url", d4 += 3;
            continue;
          }
          if (_ === "*" && n[d4 - 1] === "/") {
            u = "comment-block";
            continue;
          }
          if (_ === "/" && n[d4 - 1] === "/") {
            u = "comment-inline", v = d4 - 1;
            continue;
          }
          continue;
        case "single-quotes":
          if (_ === "'" && n[d4 - 1] !== "\\" && (u = m2, m2 = "initial"), _ === `
` || _ === "\r")
            return n;
          continue;
        case "double-quotes":
          if (_ === '"' && n[d4 - 1] !== "\\" && (u = m2, m2 = "initial"), _ === `
` || _ === "\r")
            return n;
          continue;
        case "url":
          if (_ === ")" && (u = "initial"), _ === `
` || _ === "\r")
            return n;
          if (_ === "'") {
            u = "single-quotes", m2 = "url";
            continue;
          }
          if (_ === '"') {
            u = "double-quotes", m2 = "url";
            continue;
          }
          continue;
        case "comment-block":
          _ === "/" && n[d4 - 1] === "*" && (u = "initial");
          continue;
        case "comment-inline":
          (_ === '"' || _ === "'" || _ === "*") && (y = true), (_ === `
` || _ === "\r") && (y && w2.push([v, d4]), u = "initial", y = false);
          continue;
      }
    }
    for (let [d4, _] of w2)
      n = n.slice(0, d4) + n.slice(d4, _).replace(/["'*]/g, " ") + n.slice(_);
    return n;
  }
  function e(n) {
    return n.source.startOffset;
  }
  function a3(n) {
    return n.source.endOffset;
  }
  i2.exports = { locStart: e, locEnd: a3, calculateLoc: p, replaceQuotesInInlineComments: t };
} }), hl = C({ "src/utils/is-non-empty-array.js"(r, i2) {
  I();
  function s2(l) {
    return Array.isArray(l) && l.length > 0;
  }
  i2.exports = s2;
} }), dl = C({ "src/language-css/utils/has-scss-interpolation.js"(r, i2) {
  I();
  var s2 = hl();
  function l(o) {
    if (s2(o)) {
      for (let h2 = o.length - 1; h2 > 0; h2--)
        if (o[h2].type === "word" && o[h2].value === "{" && o[h2 - 1].type === "word" && o[h2 - 1].value.endsWith("#"))
          return true;
    }
    return false;
  }
  i2.exports = l;
} }), vl = C({ "src/language-css/utils/has-string-or-function.js"(r, i2) {
  I();
  function s2(l) {
    return l.some((o) => o.type === "string" || o.type === "func");
  }
  i2.exports = s2;
} }), ml = C({ "src/language-css/utils/is-less-parser.js"(r, i2) {
  I();
  function s2(l) {
    return l.parser === "css" || l.parser === "less";
  }
  i2.exports = s2;
} }), gl = C({ "src/language-css/utils/is-scss.js"(r, i2) {
  I();
  function s2(l, o) {
    return l === "less" || l === "scss" ? l === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(o);
  }
  i2.exports = s2;
} }), yl = C({ "src/language-css/utils/is-scss-nested-property-node.js"(r, i2) {
  I();
  function s2(l) {
    return l.selector ? l.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*\n/, "").trim().endsWith(":") : false;
  }
  i2.exports = s2;
} }), wl = C({ "src/language-css/utils/is-scss-variable.js"(r, i2) {
  I();
  function s2(l) {
    return Boolean((l == null ? void 0 : l.type) === "word" && l.value.startsWith("$"));
  }
  i2.exports = s2;
} }), _l = C({ "src/language-css/utils/stringify-node.js"(r, i2) {
  I();
  function s2(l) {
    var o, h2, f;
    if (l.groups) {
      var p, g2, c;
      let y = ((p = l.open) === null || p === void 0 ? void 0 : p.value) || "", w2 = l.groups.map((_) => s2(_)).join(((g2 = l.groups[0]) === null || g2 === void 0 ? void 0 : g2.type) === "comma_group" ? "," : ""), d4 = ((c = l.close) === null || c === void 0 ? void 0 : c.value) || "";
      return y + w2 + d4;
    }
    let t = ((o = l.raws) === null || o === void 0 ? void 0 : o.before) || "", e = ((h2 = l.raws) === null || h2 === void 0 ? void 0 : h2.quote) || "", a3 = l.type === "atword" ? "@" : "", n = l.value || "", u = l.unit || "", m2 = l.group ? s2(l.group) : "", v = ((f = l.raws) === null || f === void 0 ? void 0 : f.after) || "";
    return t + e + a3 + n + e + u + m2 + v;
  }
  i2.exports = s2;
} }), bl = C({ "src/language-css/utils/is-module-rule-name.js"(r, i2) {
  I();
  var s2 = /* @__PURE__ */ new Set(["import", "use", "forward"]);
  function l(o) {
    return s2.has(o);
  }
  i2.exports = l;
} }), we = C({ "node_modules/postcss-values-parser/lib/node.js"(r, i2) {
  I();
  var s2 = function(l, o) {
    let h2 = new l.constructor();
    for (let f in l) {
      if (!l.hasOwnProperty(f))
        continue;
      let p = l[f], g2 = typeof p;
      f === "parent" && g2 === "object" ? o && (h2[f] = o) : f === "source" ? h2[f] = p : p instanceof Array ? h2[f] = p.map((c) => s2(c, h2)) : f !== "before" && f !== "after" && f !== "between" && f !== "semicolon" && (g2 === "object" && p !== null && (p = s2(p)), h2[f] = p);
    }
    return h2;
  };
  i2.exports = class {
    constructor(o) {
      o = o || {}, this.raws = { before: "", after: "" };
      for (let h2 in o)
        this[h2] = o[h2];
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }
    toString() {
      return [this.raws.before, String(this.value), this.raws.after].join("");
    }
    clone(o) {
      o = o || {};
      let h2 = s2(this);
      for (let f in o)
        h2[f] = o[f];
      return h2;
    }
    cloneBefore(o) {
      o = o || {};
      let h2 = this.clone(o);
      return this.parent.insertBefore(this, h2), h2;
    }
    cloneAfter(o) {
      o = o || {};
      let h2 = this.clone(o);
      return this.parent.insertAfter(this, h2), h2;
    }
    replaceWith() {
      let o = Array.prototype.slice.call(arguments);
      if (this.parent) {
        for (let h2 of o)
          this.parent.insertBefore(this, h2);
        this.remove();
      }
      return this;
    }
    moveTo(o) {
      return this.cleanRaws(this.root() === o.root()), this.remove(), o.append(this), this;
    }
    moveBefore(o) {
      return this.cleanRaws(this.root() === o.root()), this.remove(), o.parent.insertBefore(o, this), this;
    }
    moveAfter(o) {
      return this.cleanRaws(this.root() === o.root()), this.remove(), o.parent.insertAfter(o, this), this;
    }
    next() {
      let o = this.parent.index(this);
      return this.parent.nodes[o + 1];
    }
    prev() {
      let o = this.parent.index(this);
      return this.parent.nodes[o - 1];
    }
    toJSON() {
      let o = {};
      for (let h2 in this) {
        if (!this.hasOwnProperty(h2) || h2 === "parent")
          continue;
        let f = this[h2];
        f instanceof Array ? o[h2] = f.map((p) => typeof p == "object" && p.toJSON ? p.toJSON() : p) : typeof f == "object" && f.toJSON ? o[h2] = f.toJSON() : o[h2] = f;
      }
      return o;
    }
    root() {
      let o = this;
      for (; o.parent; )
        o = o.parent;
      return o;
    }
    cleanRaws(o) {
      delete this.raws.before, delete this.raws.after, o || delete this.raws.between;
    }
    positionInside(o) {
      let h2 = this.toString(), f = this.source.start.column, p = this.source.start.line;
      for (let g2 = 0; g2 < o; g2++)
        h2[g2] === `
` ? (f = 1, p += 1) : f += 1;
      return { line: p, column: f };
    }
    positionBy(o) {
      let h2 = this.source.start;
      if (Object(o).index)
        h2 = this.positionInside(o.index);
      else if (Object(o).word) {
        let f = this.toString().indexOf(o.word);
        f !== -1 && (h2 = this.positionInside(f));
      }
      return h2;
    }
  };
} }), ue = C({ "node_modules/postcss-values-parser/lib/container.js"(r, i2) {
  I();
  var s2 = we(), l = class extends s2 {
    constructor(o) {
      super(o), this.nodes || (this.nodes = []);
    }
    push(o) {
      return o.parent = this, this.nodes.push(o), this;
    }
    each(o) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let h2 = this.lastEach, f, p;
      if (this.indexes[h2] = 0, !!this.nodes) {
        for (; this.indexes[h2] < this.nodes.length && (f = this.indexes[h2], p = o(this.nodes[f], f), p !== false); )
          this.indexes[h2] += 1;
        return delete this.indexes[h2], p;
      }
    }
    walk(o) {
      return this.each((h2, f) => {
        let p = o(h2, f);
        return p !== false && h2.walk && (p = h2.walk(o)), p;
      });
    }
    walkType(o, h2) {
      if (!o || !h2)
        throw new Error("Parameters {type} and {callback} are required.");
      let f = typeof o == "function";
      return this.walk((p, g2) => {
        if (f && p instanceof o || !f && p.type === o)
          return h2.call(this, p, g2);
      });
    }
    append(o) {
      return o.parent = this, this.nodes.push(o), this;
    }
    prepend(o) {
      return o.parent = this, this.nodes.unshift(o), this;
    }
    cleanRaws(o) {
      if (super.cleanRaws(o), this.nodes)
        for (let h2 of this.nodes)
          h2.cleanRaws(o);
    }
    insertAfter(o, h2) {
      let f = this.index(o), p;
      this.nodes.splice(f + 1, 0, h2);
      for (let g2 in this.indexes)
        p = this.indexes[g2], f <= p && (this.indexes[g2] = p + this.nodes.length);
      return this;
    }
    insertBefore(o, h2) {
      let f = this.index(o), p;
      this.nodes.splice(f, 0, h2);
      for (let g2 in this.indexes)
        p = this.indexes[g2], f <= p && (this.indexes[g2] = p + this.nodes.length);
      return this;
    }
    removeChild(o) {
      o = this.index(o), this.nodes[o].parent = void 0, this.nodes.splice(o, 1);
      let h2;
      for (let f in this.indexes)
        h2 = this.indexes[f], h2 >= o && (this.indexes[f] = h2 - 1);
      return this;
    }
    removeAll() {
      for (let o of this.nodes)
        o.parent = void 0;
      return this.nodes = [], this;
    }
    every(o) {
      return this.nodes.every(o);
    }
    some(o) {
      return this.nodes.some(o);
    }
    index(o) {
      return typeof o == "number" ? o : this.nodes.indexOf(o);
    }
    get first() {
      if (!!this.nodes)
        return this.nodes[0];
    }
    get last() {
      if (!!this.nodes)
        return this.nodes[this.nodes.length - 1];
    }
    toString() {
      let o = this.nodes.map(String).join("");
      return this.value && (o = this.value + o), this.raws.before && (o = this.raws.before + o), this.raws.after && (o += this.raws.after), o;
    }
  };
  l.registerWalker = (o) => {
    let h2 = "walk" + o.name;
    h2.lastIndexOf("s") !== h2.length - 1 && (h2 += "s"), !l.prototype[h2] && (l.prototype[h2] = function(f) {
      return this.walkType(o, f);
    });
  }, i2.exports = l;
} }), xl = C({ "node_modules/postcss-values-parser/lib/root.js"(r, i2) {
  I();
  var s2 = ue();
  i2.exports = class extends s2 {
    constructor(o) {
      super(o), this.type = "root";
    }
  };
} }), zs = C({ "node_modules/postcss-values-parser/lib/value.js"(r, i2) {
  I();
  var s2 = ue();
  i2.exports = class extends s2 {
    constructor(o) {
      super(o), this.type = "value", this.unbalanced = 0;
    }
  };
} }), Bs = C({ "node_modules/postcss-values-parser/lib/atword.js"(r, i2) {
  I();
  var s2 = ue(), l = class extends s2 {
    constructor(o) {
      super(o), this.type = "atword";
    }
    toString() {
      this.quoted ? this.raws.quote : "";
      return [this.raws.before, "@", String.prototype.toString.call(this.value), this.raws.after].join("");
    }
  };
  s2.registerWalker(l), i2.exports = l;
} }), Fs = C({ "node_modules/postcss-values-parser/lib/colon.js"(r, i2) {
  I();
  var s2 = ue(), l = we(), o = class extends l {
    constructor(h2) {
      super(h2), this.type = "colon";
    }
  };
  s2.registerWalker(o), i2.exports = o;
} }), Us = C({ "node_modules/postcss-values-parser/lib/comma.js"(r, i2) {
  I();
  var s2 = ue(), l = we(), o = class extends l {
    constructor(h2) {
      super(h2), this.type = "comma";
    }
  };
  s2.registerWalker(o), i2.exports = o;
} }), Ws = C({ "node_modules/postcss-values-parser/lib/comment.js"(r, i2) {
  I();
  var s2 = ue(), l = we(), o = class extends l {
    constructor(h2) {
      super(h2), this.type = "comment", this.inline = Object(h2).inline || false;
    }
    toString() {
      return [this.raws.before, this.inline ? "//" : "/*", String(this.value), this.inline ? "" : "*/", this.raws.after].join("");
    }
  };
  s2.registerWalker(o), i2.exports = o;
} }), $s = C({ "node_modules/postcss-values-parser/lib/function.js"(r, i2) {
  I();
  var s2 = ue(), l = class extends s2 {
    constructor(o) {
      super(o), this.type = "func", this.unbalanced = -1;
    }
  };
  s2.registerWalker(l), i2.exports = l;
} }), Vs = C({ "node_modules/postcss-values-parser/lib/number.js"(r, i2) {
  I();
  var s2 = ue(), l = we(), o = class extends l {
    constructor(h2) {
      super(h2), this.type = "number", this.unit = Object(h2).unit || "";
    }
    toString() {
      return [this.raws.before, String(this.value), this.unit, this.raws.after].join("");
    }
  };
  s2.registerWalker(o), i2.exports = o;
} }), Gs = C({ "node_modules/postcss-values-parser/lib/operator.js"(r, i2) {
  I();
  var s2 = ue(), l = we(), o = class extends l {
    constructor(h2) {
      super(h2), this.type = "operator";
    }
  };
  s2.registerWalker(o), i2.exports = o;
} }), Hs = C({ "node_modules/postcss-values-parser/lib/paren.js"(r, i2) {
  I();
  var s2 = ue(), l = we(), o = class extends l {
    constructor(h2) {
      super(h2), this.type = "paren", this.parenType = "";
    }
  };
  s2.registerWalker(o), i2.exports = o;
} }), Js = C({ "node_modules/postcss-values-parser/lib/string.js"(r, i2) {
  I();
  var s2 = ue(), l = we(), o = class extends l {
    constructor(h2) {
      super(h2), this.type = "string";
    }
    toString() {
      let h2 = this.quoted ? this.raws.quote : "";
      return [this.raws.before, h2, this.value + "", h2, this.raws.after].join("");
    }
  };
  s2.registerWalker(o), i2.exports = o;
} }), Ks = C({ "node_modules/postcss-values-parser/lib/word.js"(r, i2) {
  I();
  var s2 = ue(), l = we(), o = class extends l {
    constructor(h2) {
      super(h2), this.type = "word";
    }
  };
  s2.registerWalker(o), i2.exports = o;
} }), Qs = C({ "node_modules/postcss-values-parser/lib/unicode-range.js"(r, i2) {
  I();
  var s2 = ue(), l = we(), o = class extends l {
    constructor(h2) {
      super(h2), this.type = "unicode-range";
    }
  };
  s2.registerWalker(o), i2.exports = o;
} });
function Ys() {
  throw new Error("setTimeout has not been defined");
}
function Xs() {
  throw new Error("clearTimeout has not been defined");
}
function Zs(r) {
  if (be === setTimeout)
    return setTimeout(r, 0);
  if ((be === Ys || !be) && setTimeout)
    return be = setTimeout, setTimeout(r, 0);
  try {
    return be(r, 0);
  } catch {
    try {
      return be.call(null, r, 0);
    } catch {
      return be.call(this, r, 0);
    }
  }
}
function kl(r) {
  if (xe === clearTimeout)
    return clearTimeout(r);
  if ((xe === Xs || !xe) && clearTimeout)
    return xe = clearTimeout, clearTimeout(r);
  try {
    return xe(r);
  } catch {
    try {
      return xe.call(null, r);
    } catch {
      return xe.call(this, r);
    }
  }
}
function Sl() {
  !Ie || !Re || (Ie = false, Re.length ? me = Re.concat(me) : Ue = -1, me.length && eo());
}
function eo() {
  if (!Ie) {
    var r = Zs(Sl);
    Ie = true;
    for (var i2 = me.length; i2; ) {
      for (Re = me, me = []; ++Ue < i2; )
        Re && Re[Ue].run();
      Ue = -1, i2 = me.length;
    }
    Re = null, Ie = false, kl(r);
  }
}
function Ol(r) {
  var i2 = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var s2 = 1; s2 < arguments.length; s2++)
      i2[s2 - 1] = arguments[s2];
  me.push(new ro(r, i2)), me.length === 1 && !Ie && Zs(eo);
}
function ro(r, i2) {
  this.fun = r, this.array = i2;
}
function Ae() {
}
function Tl(r) {
  throw new Error("process.binding is not supported");
}
function El() {
  return "/";
}
function ql(r) {
  throw new Error("process.chdir is not supported");
}
function Al() {
  return 0;
}
function Pl(r) {
  var i2 = to.call(Pe) * 1e-3, s2 = Math.floor(i2), l = Math.floor(i2 % 1 * 1e9);
  return r && (s2 = s2 - r[0], l = l - r[1], l < 0 && (s2--, l += 1e9)), [s2, l];
}
function Rl() {
  var r = new Date(), i2 = r - no;
  return i2 / 1e3;
}
var be, xe, me, Ie, Re, Ue, os, as, us, cs, ls, fs, ps, hs, ds, vs, ms, gs, ys, ws, _s, bs, Pe, to, no, xs, We, Il = Me({ "node-modules-polyfills:process"() {
  I(), be = Ys, xe = Xs, typeof globalThis.setTimeout == "function" && (be = setTimeout), typeof globalThis.clearTimeout == "function" && (xe = clearTimeout), me = [], Ie = false, Ue = -1, ro.prototype.run = function() {
    this.fun.apply(null, this.array);
  }, os = "browser", as = "browser", us = true, cs = {}, ls = [], fs = "", ps = {}, hs = {}, ds = {}, vs = Ae, ms = Ae, gs = Ae, ys = Ae, ws = Ae, _s = Ae, bs = Ae, Pe = globalThis.performance || {}, to = Pe.now || Pe.mozNow || Pe.msNow || Pe.oNow || Pe.webkitNow || function() {
    return new Date().getTime();
  }, no = new Date(), xs = { nextTick: Ol, title: os, browser: us, env: cs, argv: ls, version: fs, versions: ps, on: vs, addListener: ms, once: gs, off: ys, removeListener: ws, removeAllListeners: _s, emit: bs, binding: Tl, cwd: El, chdir: ql, umask: Al, hrtime: Pl, platform: as, release: hs, config: ds, uptime: Rl }, We = xs;
} }), it, yt, Cl = Me({ "node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js"() {
  I(), typeof Object.create == "function" ? it = function(i2, s2) {
    i2.super_ = s2, i2.prototype = Object.create(s2.prototype, { constructor: { value: i2, enumerable: false, writable: true, configurable: true } });
  } : it = function(i2, s2) {
    i2.super_ = s2;
    var l = function() {
    };
    l.prototype = s2.prototype, i2.prototype = new l(), i2.prototype.constructor = i2;
  }, yt = it;
} }), io = {};
mt(io, { _extend: () => kt, debuglog: () => so, default: () => vo, deprecate: () => wt, format: () => hr, inherits: () => yt, inspect: () => ye, isArray: () => _t, isBoolean: () => dr, isBuffer: () => co, isDate: () => fr, isError: () => Ve, isFunction: () => Ge, isNull: () => He, isNullOrUndefined: () => oo, isNumber: () => bt, isObject: () => Ce, isPrimitive: () => uo, isRegExp: () => $e, isString: () => Je, isSymbol: () => ao, isUndefined: () => ge, log: () => lo });
function hr(r) {
  if (!Je(r)) {
    for (var i2 = [], s2 = 0; s2 < arguments.length; s2++)
      i2.push(ye(arguments[s2]));
    return i2.join(" ");
  }
  for (var s2 = 1, l = arguments, o = l.length, h2 = String(r).replace(po, function(p) {
    if (p === "%%")
      return "%";
    if (s2 >= o)
      return p;
    switch (p) {
      case "%s":
        return String(l[s2++]);
      case "%d":
        return Number(l[s2++]);
      case "%j":
        try {
          return JSON.stringify(l[s2++]);
        } catch {
          return "[Circular]";
        }
      default:
        return p;
    }
  }), f = l[s2]; s2 < o; f = l[++s2])
    He(f) || !Ce(f) ? h2 += " " + f : h2 += " " + ye(f);
  return h2;
}
function wt(r, i2) {
  if (ge(globalThis.process))
    return function() {
      return wt(r, i2).apply(this, arguments);
    };
  if (We.noDeprecation === true)
    return r;
  var s2 = false;
  function l() {
    if (!s2) {
      if (We.throwDeprecation)
        throw new Error(i2);
      We.traceDeprecation ? console.trace(i2) : console.error(i2), s2 = true;
    }
    return r.apply(this, arguments);
  }
  return l;
}
function so(r) {
  if (ge(at) && (at = We.env.NODE_DEBUG || ""), r = r.toUpperCase(), !Fe[r])
    if (new RegExp("\\b" + r + "\\b", "i").test(at)) {
      var i2 = 0;
      Fe[r] = function() {
        var s2 = hr.apply(null, arguments);
        console.error("%s %d: %s", r, i2, s2);
      };
    } else
      Fe[r] = function() {
      };
  return Fe[r];
}
function ye(r, i2) {
  var s2 = { seen: [], stylize: jl };
  return arguments.length >= 3 && (s2.depth = arguments[2]), arguments.length >= 4 && (s2.colors = arguments[3]), dr(i2) ? s2.showHidden = i2 : i2 && kt(s2, i2), ge(s2.showHidden) && (s2.showHidden = false), ge(s2.depth) && (s2.depth = 2), ge(s2.colors) && (s2.colors = false), ge(s2.customInspect) && (s2.customInspect = true), s2.colors && (s2.stylize = Nl), lr(s2, r, s2.depth);
}
function Nl(r, i2) {
  var s2 = ye.styles[i2];
  return s2 ? "\x1B[" + ye.colors[s2][0] + "m" + r + "\x1B[" + ye.colors[s2][1] + "m" : r;
}
function jl(r, i2) {
  return r;
}
function Ml(r) {
  var i2 = {};
  return r.forEach(function(s2, l) {
    i2[s2] = true;
  }), i2;
}
function lr(r, i2, s2) {
  if (r.customInspect && i2 && Ge(i2.inspect) && i2.inspect !== ye && !(i2.constructor && i2.constructor.prototype === i2)) {
    var l = i2.inspect(s2, r);
    return Je(l) || (l = lr(r, l, s2)), l;
  }
  var o = Dl(r, i2);
  if (o)
    return o;
  var h2 = Object.keys(i2), f = Ml(h2);
  if (r.showHidden && (h2 = Object.getOwnPropertyNames(i2)), Ve(i2) && (h2.indexOf("message") >= 0 || h2.indexOf("description") >= 0))
    return st(i2);
  if (h2.length === 0) {
    if (Ge(i2)) {
      var p = i2.name ? ": " + i2.name : "";
      return r.stylize("[Function" + p + "]", "special");
    }
    if ($e(i2))
      return r.stylize(RegExp.prototype.toString.call(i2), "regexp");
    if (fr(i2))
      return r.stylize(Date.prototype.toString.call(i2), "date");
    if (Ve(i2))
      return st(i2);
  }
  var g2 = "", c = false, t = ["{", "}"];
  if (_t(i2) && (c = true, t = ["[", "]"]), Ge(i2)) {
    var e = i2.name ? ": " + i2.name : "";
    g2 = " [Function" + e + "]";
  }
  if ($e(i2) && (g2 = " " + RegExp.prototype.toString.call(i2)), fr(i2) && (g2 = " " + Date.prototype.toUTCString.call(i2)), Ve(i2) && (g2 = " " + st(i2)), h2.length === 0 && (!c || i2.length == 0))
    return t[0] + g2 + t[1];
  if (s2 < 0)
    return $e(i2) ? r.stylize(RegExp.prototype.toString.call(i2), "regexp") : r.stylize("[Object]", "special");
  r.seen.push(i2);
  var a3;
  return c ? a3 = Ll(r, i2, s2, f, h2) : a3 = h2.map(function(n) {
    return ft(r, i2, s2, f, n, c);
  }), r.seen.pop(), zl(a3, g2, t);
}
function Dl(r, i2) {
  if (ge(i2))
    return r.stylize("undefined", "undefined");
  if (Je(i2)) {
    var s2 = "'" + JSON.stringify(i2).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return r.stylize(s2, "string");
  }
  if (bt(i2))
    return r.stylize("" + i2, "number");
  if (dr(i2))
    return r.stylize("" + i2, "boolean");
  if (He(i2))
    return r.stylize("null", "null");
}
function st(r) {
  return "[" + Error.prototype.toString.call(r) + "]";
}
function Ll(r, i2, s2, l, o) {
  for (var h2 = [], f = 0, p = i2.length; f < p; ++f)
    fo(i2, String(f)) ? h2.push(ft(r, i2, s2, l, String(f), true)) : h2.push("");
  return o.forEach(function(g2) {
    g2.match(/^\d+$/) || h2.push(ft(r, i2, s2, l, g2, true));
  }), h2;
}
function ft(r, i2, s2, l, o, h2) {
  var f, p, g2;
  if (g2 = Object.getOwnPropertyDescriptor(i2, o) || { value: i2[o] }, g2.get ? g2.set ? p = r.stylize("[Getter/Setter]", "special") : p = r.stylize("[Getter]", "special") : g2.set && (p = r.stylize("[Setter]", "special")), fo(l, o) || (f = "[" + o + "]"), p || (r.seen.indexOf(g2.value) < 0 ? (He(s2) ? p = lr(r, g2.value, null) : p = lr(r, g2.value, s2 - 1), p.indexOf(`
`) > -1 && (h2 ? p = p.split(`
`).map(function(c) {
    return "  " + c;
  }).join(`
`).substr(2) : p = `
` + p.split(`
`).map(function(c) {
    return "   " + c;
  }).join(`
`))) : p = r.stylize("[Circular]", "special")), ge(f)) {
    if (h2 && o.match(/^\d+$/))
      return p;
    f = JSON.stringify("" + o), f.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (f = f.substr(1, f.length - 2), f = r.stylize(f, "name")) : (f = f.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), f = r.stylize(f, "string"));
  }
  return f + ": " + p;
}
function zl(r, i2, s2) {
  var l = 0, o = r.reduce(function(h2, f) {
    return l++, f.indexOf(`
`) >= 0 && l++, h2 + f.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  return o > 60 ? s2[0] + (i2 === "" ? "" : i2 + `
 `) + " " + r.join(`,
  `) + " " + s2[1] : s2[0] + i2 + " " + r.join(", ") + " " + s2[1];
}
function _t(r) {
  return Array.isArray(r);
}
function dr(r) {
  return typeof r == "boolean";
}
function He(r) {
  return r === null;
}
function oo(r) {
  return r == null;
}
function bt(r) {
  return typeof r == "number";
}
function Je(r) {
  return typeof r == "string";
}
function ao(r) {
  return typeof r == "symbol";
}
function ge(r) {
  return r === void 0;
}
function $e(r) {
  return Ce(r) && xt(r) === "[object RegExp]";
}
function Ce(r) {
  return typeof r == "object" && r !== null;
}
function fr(r) {
  return Ce(r) && xt(r) === "[object Date]";
}
function Ve(r) {
  return Ce(r) && (xt(r) === "[object Error]" || r instanceof Error);
}
function Ge(r) {
  return typeof r == "function";
}
function uo(r) {
  return r === null || typeof r == "boolean" || typeof r == "number" || typeof r == "string" || typeof r == "symbol" || typeof r > "u";
}
function co(r) {
  return Buffer.isBuffer(r);
}
function xt(r) {
  return Object.prototype.toString.call(r);
}
function ot(r) {
  return r < 10 ? "0" + r.toString(10) : r.toString(10);
}
function Bl() {
  var r = new Date(), i2 = [ot(r.getHours()), ot(r.getMinutes()), ot(r.getSeconds())].join(":");
  return [r.getDate(), ho[r.getMonth()], i2].join(" ");
}
function lo() {
  console.log("%s - %s", Bl(), hr.apply(null, arguments));
}
function kt(r, i2) {
  if (!i2 || !Ce(i2))
    return r;
  for (var s2 = Object.keys(i2), l = s2.length; l--; )
    r[s2[l]] = i2[s2[l]];
  return r;
}
function fo(r, i2) {
  return Object.prototype.hasOwnProperty.call(r, i2);
}
var po, Fe, at, ho, vo, Fl = Me({ "node-modules-polyfills:util"() {
  I(), Il(), Cl(), po = /%[sdj%]/g, Fe = {}, ye.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, ye.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, ho = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], vo = { inherits: yt, _extend: kt, log: lo, isBuffer: co, isPrimitive: uo, isFunction: Ge, isError: Ve, isDate: fr, isObject: Ce, isRegExp: $e, isUndefined: ge, isSymbol: ao, isString: Je, isNumber: bt, isNullOrUndefined: oo, isNull: He, isBoolean: dr, isArray: _t, inspect: ye, deprecate: wt, format: hr, debuglog: so };
} }), Ul = C({ "node-modules-polyfills-commonjs:util"(r, i2) {
  I();
  var s2 = (Fl(), gt(io));
  if (s2 && s2.default) {
    i2.exports = s2.default;
    for (let l in s2)
      i2.exports[l] = s2[l];
  } else
    s2 && (i2.exports = s2);
} }), Wl = C({ "node_modules/postcss-values-parser/lib/errors/TokenizeError.js"(r, i2) {
  I();
  var s2 = class extends Error {
    constructor(l) {
      super(l), this.name = this.constructor.name, this.message = l || "An error ocurred while tokzenizing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(l).stack;
    }
  };
  i2.exports = s2;
} }), $l = C({ "node_modules/postcss-values-parser/lib/tokenize.js"(r, i2) {
  I();
  var s2 = "{".charCodeAt(0), l = "}".charCodeAt(0), o = "(".charCodeAt(0), h2 = ")".charCodeAt(0), f = "'".charCodeAt(0), p = '"'.charCodeAt(0), g2 = "\\".charCodeAt(0), c = "/".charCodeAt(0), t = ".".charCodeAt(0), e = ",".charCodeAt(0), a3 = ":".charCodeAt(0), n = "*".charCodeAt(0), u = "-".charCodeAt(0), m2 = "+".charCodeAt(0), v = "#".charCodeAt(0), y = `
`.charCodeAt(0), w2 = " ".charCodeAt(0), d4 = "\f".charCodeAt(0), _ = "	".charCodeAt(0), O2 = "\r".charCodeAt(0), S2 = "@".charCodeAt(0), M2 = "e".charCodeAt(0), R = "E".charCodeAt(0), $ = "0".charCodeAt(0), J2 = "9".charCodeAt(0), X3 = "u".charCodeAt(0), F = "U".charCodeAt(0), K = /[ \n\t\r\{\(\)'"\\;,/]/g, W2 = /[ \n\t\r\(\)\{\}\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g, T2 = /[ \n\t\r\(\)\{\}\*:;@!&'"\-\+\|~>,\[\]\\]|\//g, D2 = /^[a-z0-9]/i, j = /^[a-f0-9?\-]/i, N = Ul(), b2 = Wl();
  i2.exports = function(G, L) {
    L = L || {};
    let B = [], P = G.valueOf(), Z3 = P.length, V = -1, q = 1, x2 = 0, k2 = 0, z = null, A2, E, H3, U, re2, ne, fe2, te2, ie, ae2, se;
    function le2(Qe) {
      let _e2 = N.format("Unclosed %s at line: %d, column: %d, token: %d", Qe, q, x2 - V, x2);
      throw new b2(_e2);
    }
    for (; x2 < Z3; ) {
      switch (A2 = P.charCodeAt(x2), A2 === y && (V = x2, q += 1), A2) {
        case y:
        case w2:
        case _:
        case O2:
        case d4:
          E = x2;
          do
            E += 1, A2 = P.charCodeAt(E), A2 === y && (V = E, q += 1);
          while (A2 === w2 || A2 === y || A2 === _ || A2 === O2 || A2 === d4);
          B.push(["space", P.slice(x2, E), q, x2 - V, q, E - V, x2]), x2 = E - 1;
          break;
        case a3:
          E = x2 + 1, B.push(["colon", P.slice(x2, E), q, x2 - V, q, E - V, x2]), x2 = E - 1;
          break;
        case e:
          E = x2 + 1, B.push(["comma", P.slice(x2, E), q, x2 - V, q, E - V, x2]), x2 = E - 1;
          break;
        case s2:
          B.push(["{", "{", q, x2 - V, q, E - V, x2]);
          break;
        case l:
          B.push(["}", "}", q, x2 - V, q, E - V, x2]);
          break;
        case o:
          k2++, z = !z && k2 === 1 && B.length > 0 && B[B.length - 1][0] === "word" && B[B.length - 1][1] === "url", B.push(["(", "(", q, x2 - V, q, E - V, x2]);
          break;
        case h2:
          k2--, z = z && k2 > 0, B.push([")", ")", q, x2 - V, q, E - V, x2]);
          break;
        case f:
        case p:
          H3 = A2 === f ? "'" : '"', E = x2;
          do
            for (ie = false, E = P.indexOf(H3, E + 1), E === -1 && le2("quote"), ae2 = E; P.charCodeAt(ae2 - 1) === g2; )
              ae2 -= 1, ie = !ie;
          while (ie);
          B.push(["string", P.slice(x2, E + 1), q, x2 - V, q, E - V, x2]), x2 = E;
          break;
        case S2:
          K.lastIndex = x2 + 1, K.test(P), K.lastIndex === 0 ? E = P.length - 1 : E = K.lastIndex - 2, B.push(["atword", P.slice(x2, E + 1), q, x2 - V, q, E - V, x2]), x2 = E;
          break;
        case g2:
          E = x2, A2 = P.charCodeAt(E + 1), B.push(["word", P.slice(x2, E + 1), q, x2 - V, q, E - V, x2]), x2 = E;
          break;
        case m2:
        case u:
        case n:
          E = x2 + 1, se = P.slice(x2 + 1, E + 1);
          P.slice(x2 - 1, x2);
          if (A2 === u && se.charCodeAt(0) === u) {
            E++, B.push(["word", P.slice(x2, E), q, x2 - V, q, E - V, x2]), x2 = E - 1;
            break;
          }
          B.push(["operator", P.slice(x2, E), q, x2 - V, q, E - V, x2]), x2 = E - 1;
          break;
        default:
          if (A2 === c && (P.charCodeAt(x2 + 1) === n || L.loose && !z && P.charCodeAt(x2 + 1) === c)) {
            if (P.charCodeAt(x2 + 1) === n)
              E = P.indexOf("*/", x2 + 2) + 1, E === 0 && le2("comment");
            else {
              let Le2 = P.indexOf(`
`, x2 + 2);
              E = Le2 !== -1 ? Le2 - 1 : Z3;
            }
            ne = P.slice(x2, E + 1), U = ne.split(`
`), re2 = U.length - 1, re2 > 0 ? (fe2 = q + re2, te2 = E - U[re2].length) : (fe2 = q, te2 = V), B.push(["comment", ne, q, x2 - V, fe2, E - te2, x2]), V = te2, q = fe2, x2 = E;
          } else if (A2 === v && !D2.test(P.slice(x2 + 1, x2 + 2)))
            E = x2 + 1, B.push(["#", P.slice(x2, E), q, x2 - V, q, E - V, x2]), x2 = E - 1;
          else if ((A2 === X3 || A2 === F) && P.charCodeAt(x2 + 1) === m2) {
            E = x2 + 2;
            do
              E += 1, A2 = P.charCodeAt(E);
            while (E < Z3 && j.test(P.slice(E, E + 1)));
            B.push(["unicoderange", P.slice(x2, E), q, x2 - V, q, E - V, x2]), x2 = E - 1;
          } else if (A2 === c)
            E = x2 + 1, B.push(["operator", P.slice(x2, E), q, x2 - V, q, E - V, x2]), x2 = E - 1;
          else {
            let _e2 = W2;
            if (A2 >= $ && A2 <= J2 && (_e2 = T2), _e2.lastIndex = x2 + 1, _e2.test(P), _e2.lastIndex === 0 ? E = P.length - 1 : E = _e2.lastIndex - 2, _e2 === T2 || A2 === t) {
              let Le2 = P.charCodeAt(E), Rt2 = P.charCodeAt(E + 1), It2 = P.charCodeAt(E + 2);
              (Le2 === M2 || Le2 === R) && (Rt2 === u || Rt2 === m2) && It2 >= $ && It2 <= J2 && (T2.lastIndex = E + 2, T2.test(P), T2.lastIndex === 0 ? E = P.length - 1 : E = T2.lastIndex - 2);
            }
            B.push(["word", P.slice(x2, E + 1), q, x2 - V, q, E - V, x2]), x2 = E;
          }
          break;
      }
      x2++;
    }
    return B;
  };
} }), mo = C({ "node_modules/flatten/index.js"(r, i2) {
  I(), i2.exports = function(l, o) {
    if (o = typeof o == "number" ? o : 1 / 0, !o)
      return Array.isArray(l) ? l.map(function(f) {
        return f;
      }) : l;
    return h2(l, 1);
    function h2(f, p) {
      return f.reduce(function(g2, c) {
        return Array.isArray(c) && p < o ? g2.concat(h2(c, p + 1)) : g2.concat(c);
      }, []);
    }
  };
} }), go = C({ "node_modules/indexes-of/index.js"(r, i2) {
  I(), i2.exports = function(s2, l) {
    for (var o = -1, h2 = []; (o = s2.indexOf(l, o + 1)) !== -1; )
      h2.push(o);
    return h2;
  };
} }), yo = C({ "node_modules/uniq/uniq.js"(r, i2) {
  I();
  function s2(h2, f) {
    for (var p = 1, g2 = h2.length, c = h2[0], t = h2[0], e = 1; e < g2; ++e)
      if (t = c, c = h2[e], f(c, t)) {
        if (e === p) {
          p++;
          continue;
        }
        h2[p++] = c;
      }
    return h2.length = p, h2;
  }
  function l(h2) {
    for (var f = 1, p = h2.length, g2 = h2[0], c = h2[0], t = 1; t < p; ++t, c = g2)
      if (c = g2, g2 = h2[t], g2 !== c) {
        if (t === f) {
          f++;
          continue;
        }
        h2[f++] = g2;
      }
    return h2.length = f, h2;
  }
  function o(h2, f, p) {
    return h2.length === 0 ? h2 : f ? (p || h2.sort(f), s2(h2, f)) : (p || h2.sort(), l(h2));
  }
  i2.exports = o;
} }), Vl = C({ "node_modules/postcss-values-parser/lib/errors/ParserError.js"(r, i2) {
  I();
  var s2 = class extends Error {
    constructor(l) {
      super(l), this.name = this.constructor.name, this.message = l || "An error ocurred while parsing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(l).stack;
    }
  };
  i2.exports = s2;
} }), Gl = C({ "node_modules/postcss-values-parser/lib/parser.js"(r, i2) {
  I();
  var s2 = xl(), l = zs(), o = Bs(), h2 = Fs(), f = Us(), p = Ws(), g2 = $s(), c = Vs(), t = Gs(), e = Hs(), a3 = Js(), n = Ks(), u = Qs(), m2 = $l(), v = mo(), y = go(), w2 = yo(), d4 = Vl();
  function _(O2) {
    return O2.sort((S2, M2) => S2 - M2);
  }
  i2.exports = class {
    constructor(S2, M2) {
      let R = { loose: false };
      this.cache = [], this.input = S2, this.options = Object.assign({}, R, M2), this.position = 0, this.unbalanced = 0, this.root = new s2();
      let $ = new l();
      this.root.append($), this.current = $, this.tokens = m2(S2, this.options);
    }
    parse() {
      return this.loop();
    }
    colon() {
      let S2 = this.currToken;
      this.newNode(new h2({ value: S2[1], source: { start: { line: S2[2], column: S2[3] }, end: { line: S2[4], column: S2[5] } }, sourceIndex: S2[6] })), this.position++;
    }
    comma() {
      let S2 = this.currToken;
      this.newNode(new f({ value: S2[1], source: { start: { line: S2[2], column: S2[3] }, end: { line: S2[4], column: S2[5] } }, sourceIndex: S2[6] })), this.position++;
    }
    comment() {
      let S2 = false, M2 = this.currToken[1].replace(/\/\*|\*\//g, ""), R;
      this.options.loose && M2.startsWith("//") && (M2 = M2.substring(2), S2 = true), R = new p({ value: M2, inline: S2, source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] }), this.newNode(R), this.position++;
    }
    error(S2, M2) {
      throw new d4(S2 + " at line: ".concat(M2[2], ", column ").concat(M2[3]));
    }
    loop() {
      for (; this.position < this.tokens.length; )
        this.parseTokens();
      return !this.current.last && this.spaces ? this.current.raws.before += this.spaces : this.spaces && (this.current.last.raws.after += this.spaces), this.spaces = "", this.root;
    }
    operator() {
      let S2 = this.currToken[1], M2;
      if (S2 === "+" || S2 === "-") {
        if (this.options.loose || this.position > 0 && (this.current.type === "func" && this.current.value === "calc" ? this.prevToken[0] !== "space" && this.prevToken[0] !== "(" ? this.error("Syntax Error", this.currToken) : this.nextToken[0] !== "space" && this.nextToken[0] !== "word" ? this.error("Syntax Error", this.currToken) : this.nextToken[0] === "word" && this.current.last.type !== "operator" && this.current.last.value !== "(" && this.error("Syntax Error", this.currToken) : (this.nextToken[0] === "space" || this.nextToken[0] === "operator" || this.prevToken[0] === "operator") && this.error("Syntax Error", this.currToken)), this.options.loose) {
          if ((!this.current.nodes.length || this.current.last && this.current.last.type === "operator") && this.nextToken[0] === "word")
            return this.word();
        } else if (this.nextToken[0] === "word")
          return this.word();
      }
      return M2 = new t({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), this.position++, this.newNode(M2);
    }
    parseTokens() {
      switch (this.currToken[0]) {
        case "space":
          this.space();
          break;
        case "colon":
          this.colon();
          break;
        case "comma":
          this.comma();
          break;
        case "comment":
          this.comment();
          break;
        case "(":
          this.parenOpen();
          break;
        case ")":
          this.parenClose();
          break;
        case "atword":
        case "word":
          this.word();
          break;
        case "operator":
          this.operator();
          break;
        case "string":
          this.string();
          break;
        case "unicoderange":
          this.unicodeRange();
          break;
        default:
          this.word();
          break;
      }
    }
    parenOpen() {
      let S2 = 1, M2 = this.position + 1, R = this.currToken, $;
      for (; M2 < this.tokens.length && S2; ) {
        let J2 = this.tokens[M2];
        J2[0] === "(" && S2++, J2[0] === ")" && S2--, M2++;
      }
      if (S2 && this.error("Expected closing parenthesis", R), $ = this.current.last, $ && $.type === "func" && $.unbalanced < 0 && ($.unbalanced = 0, this.current = $), this.current.unbalanced++, this.newNode(new e({ value: R[1], source: { start: { line: R[2], column: R[3] }, end: { line: R[4], column: R[5] } }, sourceIndex: R[6] })), this.position++, this.current.type === "func" && this.current.unbalanced && this.current.value === "url" && this.currToken[0] !== "string" && this.currToken[0] !== ")" && !this.options.loose) {
        let J2 = this.nextToken, X3 = this.currToken[1], F = { line: this.currToken[2], column: this.currToken[3] };
        for (; J2 && J2[0] !== ")" && this.current.unbalanced; )
          this.position++, X3 += this.currToken[1], J2 = this.nextToken;
        this.position !== this.tokens.length - 1 && (this.position++, this.newNode(new n({ value: X3, source: { start: F, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] })));
      }
    }
    parenClose() {
      let S2 = this.currToken;
      this.newNode(new e({ value: S2[1], source: { start: { line: S2[2], column: S2[3] }, end: { line: S2[4], column: S2[5] } }, sourceIndex: S2[6] })), this.position++, !(this.position >= this.tokens.length - 1 && !this.current.unbalanced) && (this.current.unbalanced--, this.current.unbalanced < 0 && this.error("Expected opening parenthesis", S2), !this.current.unbalanced && this.cache.length && (this.current = this.cache.pop()));
    }
    space() {
      let S2 = this.currToken;
      this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.raws.after += S2[1], this.position++) : (this.spaces = S2[1], this.position++);
    }
    unicodeRange() {
      let S2 = this.currToken;
      this.newNode(new u({ value: S2[1], source: { start: { line: S2[2], column: S2[3] }, end: { line: S2[4], column: S2[5] } }, sourceIndex: S2[6] })), this.position++;
    }
    splitWord() {
      let S2 = this.nextToken, M2 = this.currToken[1], R = /^[\+\-]?((\d+(\.\d*)?)|(\.\d+))([eE][\+\-]?\d+)?/, $ = /^(?!\#([a-z0-9]+))[\#\{\}]/gi, J2, X3;
      if (!$.test(M2))
        for (; S2 && S2[0] === "word"; )
          this.position++, M2 += this.currToken[1], S2 = this.nextToken;
      J2 = y(M2, "@"), X3 = _(w2(v([[0], J2]))), X3.forEach((F, K) => {
        let W2 = X3[K + 1] || M2.length, T2 = M2.slice(F, W2), D2;
        if (~J2.indexOf(F))
          D2 = new o({ value: T2.slice(1), source: { start: { line: this.currToken[2], column: this.currToken[3] + F }, end: { line: this.currToken[4], column: this.currToken[3] + (W2 - 1) } }, sourceIndex: this.currToken[6] + X3[K] });
        else if (R.test(this.currToken[1])) {
          let j = T2.replace(R, "");
          D2 = new c({ value: T2.replace(j, ""), source: { start: { line: this.currToken[2], column: this.currToken[3] + F }, end: { line: this.currToken[4], column: this.currToken[3] + (W2 - 1) } }, sourceIndex: this.currToken[6] + X3[K], unit: j });
        } else
          D2 = new (S2 && S2[0] === "(" ? g2 : n)({ value: T2, source: { start: { line: this.currToken[2], column: this.currToken[3] + F }, end: { line: this.currToken[4], column: this.currToken[3] + (W2 - 1) } }, sourceIndex: this.currToken[6] + X3[K] }), D2.type === "word" ? (D2.isHex = /^#(.+)/.test(T2), D2.isColor = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(T2)) : this.cache.push(this.current);
        this.newNode(D2);
      }), this.position++;
    }
    string() {
      let S2 = this.currToken, M2 = this.currToken[1], R = /^(\"|\')/, $ = R.test(M2), J2 = "", X3;
      $ && (J2 = M2.match(R)[0], M2 = M2.slice(1, M2.length - 1)), X3 = new a3({ value: M2, source: { start: { line: S2[2], column: S2[3] }, end: { line: S2[4], column: S2[5] } }, sourceIndex: S2[6], quoted: $ }), X3.raws.quote = J2, this.newNode(X3), this.position++;
    }
    word() {
      return this.splitWord();
    }
    newNode(S2) {
      return this.spaces && (S2.raws.before += this.spaces, this.spaces = ""), this.current.append(S2);
    }
    get currToken() {
      return this.tokens[this.position];
    }
    get nextToken() {
      return this.tokens[this.position + 1];
    }
    get prevToken() {
      return this.tokens[this.position - 1];
    }
  };
} }), Hl = C({ "node_modules/postcss-values-parser/lib/index.js"(r, i2) {
  I();
  var s2 = Gl(), l = Bs(), o = Fs(), h2 = Us(), f = Ws(), p = $s(), g2 = Vs(), c = Gs(), t = Hs(), e = Js(), a3 = Qs(), n = zs(), u = Ks(), m2 = function(v, y) {
    return new s2(v, y);
  };
  m2.atword = function(v) {
    return new l(v);
  }, m2.colon = function(v) {
    return new o(Object.assign({ value: ":" }, v));
  }, m2.comma = function(v) {
    return new h2(Object.assign({ value: "," }, v));
  }, m2.comment = function(v) {
    return new f(v);
  }, m2.func = function(v) {
    return new p(v);
  }, m2.number = function(v) {
    return new g2(v);
  }, m2.operator = function(v) {
    return new c(v);
  }, m2.paren = function(v) {
    return new t(Object.assign({ value: "(" }, v));
  }, m2.string = function(v) {
    return new e(Object.assign({ quote: "'" }, v));
  }, m2.value = function(v) {
    return new n(v);
  }, m2.word = function(v) {
    return new u(v);
  }, m2.unicodeRange = function(v) {
    return new a3(v);
  }, i2.exports = m2;
} }), De = C({ "node_modules/postcss-selector-parser/dist/selectors/node.js"(r, i2) {
  I(), r.__esModule = true;
  var s2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(f) {
    return typeof f;
  } : function(f) {
    return f && typeof Symbol == "function" && f.constructor === Symbol && f !== Symbol.prototype ? "symbol" : typeof f;
  };
  function l(f, p) {
    if (!(f instanceof p))
      throw new TypeError("Cannot call a class as a function");
  }
  var o = function f(p, g2) {
    if ((typeof p > "u" ? "undefined" : s2(p)) !== "object")
      return p;
    var c = new p.constructor();
    for (var t in p)
      if (!!p.hasOwnProperty(t)) {
        var e = p[t], a3 = typeof e > "u" ? "undefined" : s2(e);
        t === "parent" && a3 === "object" ? g2 && (c[t] = g2) : e instanceof Array ? c[t] = e.map(function(n) {
          return f(n, c);
        }) : c[t] = f(e, c);
      }
    return c;
  }, h2 = function() {
    function f() {
      var p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      l(this, f);
      for (var g2 in p)
        this[g2] = p[g2];
      var c = p.spaces;
      c = c === void 0 ? {} : c;
      var t = c.before, e = t === void 0 ? "" : t, a3 = c.after, n = a3 === void 0 ? "" : a3;
      this.spaces = { before: e, after: n };
    }
    return f.prototype.remove = function() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }, f.prototype.replaceWith = function() {
      if (this.parent) {
        for (var g2 in arguments)
          this.parent.insertBefore(this, arguments[g2]);
        this.remove();
      }
      return this;
    }, f.prototype.next = function() {
      return this.parent.at(this.parent.index(this) + 1);
    }, f.prototype.prev = function() {
      return this.parent.at(this.parent.index(this) - 1);
    }, f.prototype.clone = function() {
      var g2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, c = o(this);
      for (var t in g2)
        c[t] = g2[t];
      return c;
    }, f.prototype.toString = function() {
      return [this.spaces.before, String(this.value), this.spaces.after].join("");
    }, f;
  }();
  r.default = h2, i2.exports = r.default;
} }), oe = C({ "node_modules/postcss-selector-parser/dist/selectors/types.js"(r) {
  I(), r.__esModule = true;
  r.TAG = "tag";
  r.STRING = "string";
  r.SELECTOR = "selector";
  r.ROOT = "root";
  r.PSEUDO = "pseudo";
  r.NESTING = "nesting";
  r.ID = "id";
  r.COMMENT = "comment";
  r.COMBINATOR = "combinator";
  r.CLASS = "class";
  r.ATTRIBUTE = "attribute";
  r.UNIVERSAL = "universal";
} }), St = C({ "node_modules/postcss-selector-parser/dist/selectors/container.js"(r, i2) {
  I(), r.__esModule = true;
  var s2 = function() {
    function n(u, m2) {
      for (var v = 0; v < m2.length; v++) {
        var y = m2[v];
        y.enumerable = y.enumerable || false, y.configurable = true, "value" in y && (y.writable = true), Object.defineProperty(u, y.key, y);
      }
    }
    return function(u, m2, v) {
      return m2 && n(u.prototype, m2), v && n(u, v), u;
    };
  }(), l = De(), o = g2(l), h2 = oe(), f = p(h2);
  function p(n) {
    if (n && n.__esModule)
      return n;
    var u = {};
    if (n != null)
      for (var m2 in n)
        Object.prototype.hasOwnProperty.call(n, m2) && (u[m2] = n[m2]);
    return u.default = n, u;
  }
  function g2(n) {
    return n && n.__esModule ? n : { default: n };
  }
  function c(n, u) {
    if (!(n instanceof u))
      throw new TypeError("Cannot call a class as a function");
  }
  function t(n, u) {
    if (!n)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return u && (typeof u == "object" || typeof u == "function") ? u : n;
  }
  function e(n, u) {
    if (typeof u != "function" && u !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof u);
    n.prototype = Object.create(u && u.prototype, { constructor: { value: n, enumerable: false, writable: true, configurable: true } }), u && (Object.setPrototypeOf ? Object.setPrototypeOf(n, u) : n.__proto__ = u);
  }
  var a3 = function(n) {
    e(u, n);
    function u(m2) {
      c(this, u);
      var v = t(this, n.call(this, m2));
      return v.nodes || (v.nodes = []), v;
    }
    return u.prototype.append = function(v) {
      return v.parent = this, this.nodes.push(v), this;
    }, u.prototype.prepend = function(v) {
      return v.parent = this, this.nodes.unshift(v), this;
    }, u.prototype.at = function(v) {
      return this.nodes[v];
    }, u.prototype.index = function(v) {
      return typeof v == "number" ? v : this.nodes.indexOf(v);
    }, u.prototype.removeChild = function(v) {
      v = this.index(v), this.at(v).parent = void 0, this.nodes.splice(v, 1);
      var y = void 0;
      for (var w2 in this.indexes)
        y = this.indexes[w2], y >= v && (this.indexes[w2] = y - 1);
      return this;
    }, u.prototype.removeAll = function() {
      for (var w2 = this.nodes, v = Array.isArray(w2), y = 0, w2 = v ? w2 : w2[Symbol.iterator](); ; ) {
        var d4;
        if (v) {
          if (y >= w2.length)
            break;
          d4 = w2[y++];
        } else {
          if (y = w2.next(), y.done)
            break;
          d4 = y.value;
        }
        var _ = d4;
        _.parent = void 0;
      }
      return this.nodes = [], this;
    }, u.prototype.empty = function() {
      return this.removeAll();
    }, u.prototype.insertAfter = function(v, y) {
      var w2 = this.index(v);
      this.nodes.splice(w2 + 1, 0, y);
      var d4 = void 0;
      for (var _ in this.indexes)
        d4 = this.indexes[_], w2 <= d4 && (this.indexes[_] = d4 + this.nodes.length);
      return this;
    }, u.prototype.insertBefore = function(v, y) {
      var w2 = this.index(v);
      this.nodes.splice(w2, 0, y);
      var d4 = void 0;
      for (var _ in this.indexes)
        d4 = this.indexes[_], w2 <= d4 && (this.indexes[_] = d4 + this.nodes.length);
      return this;
    }, u.prototype.each = function(v) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
      var y = this.lastEach;
      if (this.indexes[y] = 0, !!this.length) {
        for (var w2 = void 0, d4 = void 0; this.indexes[y] < this.length && (w2 = this.indexes[y], d4 = v(this.at(w2), w2), d4 !== false); )
          this.indexes[y] += 1;
        if (delete this.indexes[y], d4 === false)
          return false;
      }
    }, u.prototype.walk = function(v) {
      return this.each(function(y, w2) {
        var d4 = v(y, w2);
        if (d4 !== false && y.length && (d4 = y.walk(v)), d4 === false)
          return false;
      });
    }, u.prototype.walkAttributes = function(v) {
      var y = this;
      return this.walk(function(w2) {
        if (w2.type === f.ATTRIBUTE)
          return v.call(y, w2);
      });
    }, u.prototype.walkClasses = function(v) {
      var y = this;
      return this.walk(function(w2) {
        if (w2.type === f.CLASS)
          return v.call(y, w2);
      });
    }, u.prototype.walkCombinators = function(v) {
      var y = this;
      return this.walk(function(w2) {
        if (w2.type === f.COMBINATOR)
          return v.call(y, w2);
      });
    }, u.prototype.walkComments = function(v) {
      var y = this;
      return this.walk(function(w2) {
        if (w2.type === f.COMMENT)
          return v.call(y, w2);
      });
    }, u.prototype.walkIds = function(v) {
      var y = this;
      return this.walk(function(w2) {
        if (w2.type === f.ID)
          return v.call(y, w2);
      });
    }, u.prototype.walkNesting = function(v) {
      var y = this;
      return this.walk(function(w2) {
        if (w2.type === f.NESTING)
          return v.call(y, w2);
      });
    }, u.prototype.walkPseudos = function(v) {
      var y = this;
      return this.walk(function(w2) {
        if (w2.type === f.PSEUDO)
          return v.call(y, w2);
      });
    }, u.prototype.walkTags = function(v) {
      var y = this;
      return this.walk(function(w2) {
        if (w2.type === f.TAG)
          return v.call(y, w2);
      });
    }, u.prototype.walkUniversals = function(v) {
      var y = this;
      return this.walk(function(w2) {
        if (w2.type === f.UNIVERSAL)
          return v.call(y, w2);
      });
    }, u.prototype.split = function(v) {
      var y = this, w2 = [];
      return this.reduce(function(d4, _, O2) {
        var S2 = v.call(y, _);
        return w2.push(_), S2 ? (d4.push(w2), w2 = []) : O2 === y.length - 1 && d4.push(w2), d4;
      }, []);
    }, u.prototype.map = function(v) {
      return this.nodes.map(v);
    }, u.prototype.reduce = function(v, y) {
      return this.nodes.reduce(v, y);
    }, u.prototype.every = function(v) {
      return this.nodes.every(v);
    }, u.prototype.some = function(v) {
      return this.nodes.some(v);
    }, u.prototype.filter = function(v) {
      return this.nodes.filter(v);
    }, u.prototype.sort = function(v) {
      return this.nodes.sort(v);
    }, u.prototype.toString = function() {
      return this.map(String).join("");
    }, s2(u, [{ key: "first", get: function() {
      return this.at(0);
    } }, { key: "last", get: function() {
      return this.at(this.length - 1);
    } }, { key: "length", get: function() {
      return this.nodes.length;
    } }]), u;
  }(o.default);
  r.default = a3, i2.exports = r.default;
} }), wo = C({ "node_modules/postcss-selector-parser/dist/selectors/root.js"(r, i2) {
  I(), r.__esModule = true;
  var s2 = St(), l = h2(s2), o = oe();
  function h2(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function f(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function p(t, e) {
    if (!t)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function g2(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var c = function(t) {
    g2(e, t);
    function e(a3) {
      f(this, e);
      var n = p(this, t.call(this, a3));
      return n.type = o.ROOT, n;
    }
    return e.prototype.toString = function() {
      var n = this.reduce(function(u, m2) {
        var v = String(m2);
        return v ? u + v + "," : "";
      }, "").slice(0, -1);
      return this.trailingComma ? n + "," : n;
    }, e;
  }(l.default);
  r.default = c, i2.exports = r.default;
} }), _o = C({ "node_modules/postcss-selector-parser/dist/selectors/selector.js"(r, i2) {
  I(), r.__esModule = true;
  var s2 = St(), l = h2(s2), o = oe();
  function h2(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function f(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function p(t, e) {
    if (!t)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function g2(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var c = function(t) {
    g2(e, t);
    function e(a3) {
      f(this, e);
      var n = p(this, t.call(this, a3));
      return n.type = o.SELECTOR, n;
    }
    return e;
  }(l.default);
  r.default = c, i2.exports = r.default;
} }), Ke = C({ "node_modules/postcss-selector-parser/dist/selectors/namespace.js"(r, i2) {
  I(), r.__esModule = true;
  var s2 = function() {
    function t(e, a3) {
      for (var n = 0; n < a3.length; n++) {
        var u = a3[n];
        u.enumerable = u.enumerable || false, u.configurable = true, "value" in u && (u.writable = true), Object.defineProperty(e, u.key, u);
      }
    }
    return function(e, a3, n) {
      return a3 && t(e.prototype, a3), n && t(e, n), e;
    };
  }(), l = De(), o = h2(l);
  function h2(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function f(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function p(t, e) {
    if (!t)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function g2(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var c = function(t) {
    g2(e, t);
    function e() {
      return f(this, e), p(this, t.apply(this, arguments));
    }
    return e.prototype.toString = function() {
      return [this.spaces.before, this.ns, String(this.value), this.spaces.after].join("");
    }, s2(e, [{ key: "ns", get: function() {
      var n = this.namespace;
      return n ? (typeof n == "string" ? n : "") + "|" : "";
    } }]), e;
  }(o.default);
  r.default = c, i2.exports = r.default;
} }), bo = C({ "node_modules/postcss-selector-parser/dist/selectors/className.js"(r, i2) {
  I(), r.__esModule = true;
  var s2 = Ke(), l = h2(s2), o = oe();
  function h2(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function f(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function p(t, e) {
    if (!t)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function g2(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var c = function(t) {
    g2(e, t);
    function e(a3) {
      f(this, e);
      var n = p(this, t.call(this, a3));
      return n.type = o.CLASS, n;
    }
    return e.prototype.toString = function() {
      return [this.spaces.before, this.ns, String("." + this.value), this.spaces.after].join("");
    }, e;
  }(l.default);
  r.default = c, i2.exports = r.default;
} }), xo = C({ "node_modules/postcss-selector-parser/dist/selectors/comment.js"(r, i2) {
  I(), r.__esModule = true;
  var s2 = De(), l = h2(s2), o = oe();
  function h2(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function f(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function p(t, e) {
    if (!t)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function g2(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var c = function(t) {
    g2(e, t);
    function e(a3) {
      f(this, e);
      var n = p(this, t.call(this, a3));
      return n.type = o.COMMENT, n;
    }
    return e;
  }(l.default);
  r.default = c, i2.exports = r.default;
} }), ko = C({ "node_modules/postcss-selector-parser/dist/selectors/id.js"(r, i2) {
  I(), r.__esModule = true;
  var s2 = Ke(), l = h2(s2), o = oe();
  function h2(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function f(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function p(t, e) {
    if (!t)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function g2(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var c = function(t) {
    g2(e, t);
    function e(a3) {
      f(this, e);
      var n = p(this, t.call(this, a3));
      return n.type = o.ID, n;
    }
    return e.prototype.toString = function() {
      return [this.spaces.before, this.ns, String("#" + this.value), this.spaces.after].join("");
    }, e;
  }(l.default);
  r.default = c, i2.exports = r.default;
} }), So = C({ "node_modules/postcss-selector-parser/dist/selectors/tag.js"(r, i2) {
  I(), r.__esModule = true;
  var s2 = Ke(), l = h2(s2), o = oe();
  function h2(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function f(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function p(t, e) {
    if (!t)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function g2(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var c = function(t) {
    g2(e, t);
    function e(a3) {
      f(this, e);
      var n = p(this, t.call(this, a3));
      return n.type = o.TAG, n;
    }
    return e;
  }(l.default);
  r.default = c, i2.exports = r.default;
} }), Oo = C({ "node_modules/postcss-selector-parser/dist/selectors/string.js"(r, i2) {
  I(), r.__esModule = true;
  var s2 = De(), l = h2(s2), o = oe();
  function h2(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function f(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function p(t, e) {
    if (!t)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function g2(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var c = function(t) {
    g2(e, t);
    function e(a3) {
      f(this, e);
      var n = p(this, t.call(this, a3));
      return n.type = o.STRING, n;
    }
    return e;
  }(l.default);
  r.default = c, i2.exports = r.default;
} }), To = C({ "node_modules/postcss-selector-parser/dist/selectors/pseudo.js"(r, i2) {
  I(), r.__esModule = true;
  var s2 = St(), l = h2(s2), o = oe();
  function h2(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function f(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function p(t, e) {
    if (!t)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function g2(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var c = function(t) {
    g2(e, t);
    function e(a3) {
      f(this, e);
      var n = p(this, t.call(this, a3));
      return n.type = o.PSEUDO, n;
    }
    return e.prototype.toString = function() {
      var n = this.length ? "(" + this.map(String).join(",") + ")" : "";
      return [this.spaces.before, String(this.value), n, this.spaces.after].join("");
    }, e;
  }(l.default);
  r.default = c, i2.exports = r.default;
} }), Eo = C({ "node_modules/postcss-selector-parser/dist/selectors/attribute.js"(r, i2) {
  I(), r.__esModule = true;
  var s2 = Ke(), l = h2(s2), o = oe();
  function h2(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function f(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function p(t, e) {
    if (!t)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function g2(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var c = function(t) {
    g2(e, t);
    function e(a3) {
      f(this, e);
      var n = p(this, t.call(this, a3));
      return n.type = o.ATTRIBUTE, n.raws = {}, n;
    }
    return e.prototype.toString = function() {
      var n = [this.spaces.before, "[", this.ns, this.attribute];
      return this.operator && n.push(this.operator), this.value && n.push(this.value), this.raws.insensitive ? n.push(this.raws.insensitive) : this.insensitive && n.push(" i"), n.push("]"), n.concat(this.spaces.after).join("");
    }, e;
  }(l.default);
  r.default = c, i2.exports = r.default;
} }), qo = C({ "node_modules/postcss-selector-parser/dist/selectors/universal.js"(r, i2) {
  I(), r.__esModule = true;
  var s2 = Ke(), l = h2(s2), o = oe();
  function h2(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function f(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function p(t, e) {
    if (!t)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function g2(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var c = function(t) {
    g2(e, t);
    function e(a3) {
      f(this, e);
      var n = p(this, t.call(this, a3));
      return n.type = o.UNIVERSAL, n.value = "*", n;
    }
    return e;
  }(l.default);
  r.default = c, i2.exports = r.default;
} }), Ao = C({ "node_modules/postcss-selector-parser/dist/selectors/combinator.js"(r, i2) {
  I(), r.__esModule = true;
  var s2 = De(), l = h2(s2), o = oe();
  function h2(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function f(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function p(t, e) {
    if (!t)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function g2(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var c = function(t) {
    g2(e, t);
    function e(a3) {
      f(this, e);
      var n = p(this, t.call(this, a3));
      return n.type = o.COMBINATOR, n;
    }
    return e;
  }(l.default);
  r.default = c, i2.exports = r.default;
} }), Po = C({ "node_modules/postcss-selector-parser/dist/selectors/nesting.js"(r, i2) {
  I(), r.__esModule = true;
  var s2 = De(), l = h2(s2), o = oe();
  function h2(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function f(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function p(t, e) {
    if (!t)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function g2(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var c = function(t) {
    g2(e, t);
    function e(a3) {
      f(this, e);
      var n = p(this, t.call(this, a3));
      return n.type = o.NESTING, n.value = "&", n;
    }
    return e;
  }(l.default);
  r.default = c, i2.exports = r.default;
} }), Jl = C({ "node_modules/postcss-selector-parser/dist/sortAscending.js"(r, i2) {
  I(), r.__esModule = true, r.default = s2;
  function s2(l) {
    return l.sort(function(o, h2) {
      return o - h2;
    });
  }
  i2.exports = r.default;
} }), Kl = C({ "node_modules/postcss-selector-parser/dist/tokenize.js"(r, i2) {
  I(), r.__esModule = true, r.default = X3;
  var s2 = 39, l = 34, o = 92, h2 = 47, f = 10, p = 32, g2 = 12, c = 9, t = 13, e = 43, a3 = 62, n = 126, u = 124, m2 = 44, v = 40, y = 41, w2 = 91, d4 = 93, _ = 59, O2 = 42, S2 = 58, M2 = 38, R = 64, $ = /[ \n\t\r\{\(\)'"\\;/]/g, J2 = /[ \n\t\r\(\)\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g;
  function X3(F) {
    for (var K = [], W2 = F.css.valueOf(), T2 = void 0, D2 = void 0, j = void 0, N = void 0, b2 = void 0, Q = void 0, G = void 0, L = void 0, B = void 0, P = void 0, Z3 = void 0, V = W2.length, q = -1, x2 = 1, k2 = 0, z = function(E, H3) {
      if (F.safe)
        W2 += H3, D2 = W2.length - 1;
      else
        throw F.error("Unclosed " + E, x2, k2 - q, k2);
    }; k2 < V; ) {
      switch (T2 = W2.charCodeAt(k2), T2 === f && (q = k2, x2 += 1), T2) {
        case f:
        case p:
        case c:
        case t:
        case g2:
          D2 = k2;
          do
            D2 += 1, T2 = W2.charCodeAt(D2), T2 === f && (q = D2, x2 += 1);
          while (T2 === p || T2 === f || T2 === c || T2 === t || T2 === g2);
          K.push(["space", W2.slice(k2, D2), x2, k2 - q, k2]), k2 = D2 - 1;
          break;
        case e:
        case a3:
        case n:
        case u:
          D2 = k2;
          do
            D2 += 1, T2 = W2.charCodeAt(D2);
          while (T2 === e || T2 === a3 || T2 === n || T2 === u);
          K.push(["combinator", W2.slice(k2, D2), x2, k2 - q, k2]), k2 = D2 - 1;
          break;
        case O2:
          K.push(["*", "*", x2, k2 - q, k2]);
          break;
        case M2:
          K.push(["&", "&", x2, k2 - q, k2]);
          break;
        case m2:
          K.push([",", ",", x2, k2 - q, k2]);
          break;
        case w2:
          K.push(["[", "[", x2, k2 - q, k2]);
          break;
        case d4:
          K.push(["]", "]", x2, k2 - q, k2]);
          break;
        case S2:
          K.push([":", ":", x2, k2 - q, k2]);
          break;
        case _:
          K.push([";", ";", x2, k2 - q, k2]);
          break;
        case v:
          K.push(["(", "(", x2, k2 - q, k2]);
          break;
        case y:
          K.push([")", ")", x2, k2 - q, k2]);
          break;
        case s2:
        case l:
          j = T2 === s2 ? "'" : '"', D2 = k2;
          do
            for (P = false, D2 = W2.indexOf(j, D2 + 1), D2 === -1 && z("quote", j), Z3 = D2; W2.charCodeAt(Z3 - 1) === o; )
              Z3 -= 1, P = !P;
          while (P);
          K.push(["string", W2.slice(k2, D2 + 1), x2, k2 - q, x2, D2 - q, k2]), k2 = D2;
          break;
        case R:
          $.lastIndex = k2 + 1, $.test(W2), $.lastIndex === 0 ? D2 = W2.length - 1 : D2 = $.lastIndex - 2, K.push(["at-word", W2.slice(k2, D2 + 1), x2, k2 - q, x2, D2 - q, k2]), k2 = D2;
          break;
        case o:
          for (D2 = k2, G = true; W2.charCodeAt(D2 + 1) === o; )
            D2 += 1, G = !G;
          T2 = W2.charCodeAt(D2 + 1), G && T2 !== h2 && T2 !== p && T2 !== f && T2 !== c && T2 !== t && T2 !== g2 && (D2 += 1), K.push(["word", W2.slice(k2, D2 + 1), x2, k2 - q, x2, D2 - q, k2]), k2 = D2;
          break;
        default:
          T2 === h2 && W2.charCodeAt(k2 + 1) === O2 ? (D2 = W2.indexOf("*/", k2 + 2) + 1, D2 === 0 && z("comment", "*/"), Q = W2.slice(k2, D2 + 1), N = Q.split(`
`), b2 = N.length - 1, b2 > 0 ? (L = x2 + b2, B = D2 - N[b2].length) : (L = x2, B = q), K.push(["comment", Q, x2, k2 - q, L, D2 - B, k2]), q = B, x2 = L, k2 = D2) : (J2.lastIndex = k2 + 1, J2.test(W2), J2.lastIndex === 0 ? D2 = W2.length - 1 : D2 = J2.lastIndex - 2, K.push(["word", W2.slice(k2, D2 + 1), x2, k2 - q, x2, D2 - q, k2]), k2 = D2);
          break;
      }
      k2++;
    }
    return K;
  }
  i2.exports = r.default;
} }), Ql = C({ "node_modules/postcss-selector-parser/dist/parser.js"(r, i2) {
  I(), r.__esModule = true;
  var s2 = function() {
    function q(x2, k2) {
      for (var z = 0; z < k2.length; z++) {
        var A2 = k2[z];
        A2.enumerable = A2.enumerable || false, A2.configurable = true, "value" in A2 && (A2.writable = true), Object.defineProperty(x2, A2.key, A2);
      }
    }
    return function(x2, k2, z) {
      return k2 && q(x2.prototype, k2), z && q(x2, z), x2;
    };
  }(), l = mo(), o = P(l), h2 = go(), f = P(h2), p = yo(), g2 = P(p), c = wo(), t = P(c), e = _o(), a3 = P(e), n = bo(), u = P(n), m2 = xo(), v = P(m2), y = ko(), w2 = P(y), d4 = So(), _ = P(d4), O2 = Oo(), S2 = P(O2), M2 = To(), R = P(M2), $ = Eo(), J2 = P($), X3 = qo(), F = P(X3), K = Ao(), W2 = P(K), T2 = Po(), D2 = P(T2), j = Jl(), N = P(j), b2 = Kl(), Q = P(b2), G = oe(), L = B(G);
  function B(q) {
    if (q && q.__esModule)
      return q;
    var x2 = {};
    if (q != null)
      for (var k2 in q)
        Object.prototype.hasOwnProperty.call(q, k2) && (x2[k2] = q[k2]);
    return x2.default = q, x2;
  }
  function P(q) {
    return q && q.__esModule ? q : { default: q };
  }
  function Z3(q, x2) {
    if (!(q instanceof x2))
      throw new TypeError("Cannot call a class as a function");
  }
  var V = function() {
    function q(x2) {
      Z3(this, q), this.input = x2, this.lossy = x2.options.lossless === false, this.position = 0, this.root = new t.default();
      var k2 = new a3.default();
      return this.root.append(k2), this.current = k2, this.lossy ? this.tokens = (0, Q.default)({ safe: x2.safe, css: x2.css.trim() }) : this.tokens = (0, Q.default)(x2), this.loop();
    }
    return q.prototype.attribute = function() {
      var k2 = "", z = void 0, A2 = this.currToken;
      for (this.position++; this.position < this.tokens.length && this.currToken[0] !== "]"; )
        k2 += this.tokens[this.position][1], this.position++;
      this.position === this.tokens.length && !~k2.indexOf("]") && this.error("Expected a closing square bracket.");
      var E = k2.split(/((?:[*~^$|]?=))([^]*)/), H3 = E[0].split(/(\|)/g), U = { operator: E[1], value: E[2], source: { start: { line: A2[2], column: A2[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: A2[4] };
      if (H3.length > 1 ? (H3[0] === "" && (H3[0] = true), U.attribute = this.parseValue(H3[2]), U.namespace = this.parseNamespace(H3[0])) : U.attribute = this.parseValue(E[0]), z = new J2.default(U), E[2]) {
        var re2 = E[2].split(/(\s+i\s*?)$/), ne = re2[0].trim();
        z.value = this.lossy ? ne : re2[0], re2[1] && (z.insensitive = true, this.lossy || (z.raws.insensitive = re2[1])), z.quoted = ne[0] === "'" || ne[0] === '"', z.raws.unquoted = z.quoted ? ne.slice(1, -1) : ne;
      }
      this.newNode(z), this.position++;
    }, q.prototype.combinator = function() {
      if (this.currToken[1] === "|")
        return this.namespace();
      for (var k2 = new W2.default({ value: "", source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }); this.position < this.tokens.length && this.currToken && (this.currToken[0] === "space" || this.currToken[0] === "combinator"); )
        this.nextToken && this.nextToken[0] === "combinator" ? (k2.spaces.before = this.parseSpace(this.currToken[1]), k2.source.start.line = this.nextToken[2], k2.source.start.column = this.nextToken[3], k2.source.end.column = this.nextToken[3], k2.source.end.line = this.nextToken[2], k2.sourceIndex = this.nextToken[4]) : this.prevToken && this.prevToken[0] === "combinator" ? k2.spaces.after = this.parseSpace(this.currToken[1]) : this.currToken[0] === "combinator" ? k2.value = this.currToken[1] : this.currToken[0] === "space" && (k2.value = this.parseSpace(this.currToken[1], " ")), this.position++;
      return this.newNode(k2);
    }, q.prototype.comma = function() {
      if (this.position === this.tokens.length - 1) {
        this.root.trailingComma = true, this.position++;
        return;
      }
      var k2 = new a3.default();
      this.current.parent.append(k2), this.current = k2, this.position++;
    }, q.prototype.comment = function() {
      var k2 = new v.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] });
      this.newNode(k2), this.position++;
    }, q.prototype.error = function(k2) {
      throw new this.input.error(k2);
    }, q.prototype.missingBackslash = function() {
      return this.error("Expected a backslash preceding the semicolon.");
    }, q.prototype.missingParenthesis = function() {
      return this.error("Expected opening parenthesis.");
    }, q.prototype.missingSquareBracket = function() {
      return this.error("Expected opening square bracket.");
    }, q.prototype.namespace = function() {
      var k2 = this.prevToken && this.prevToken[1] || true;
      if (this.nextToken[0] === "word")
        return this.position++, this.word(k2);
      if (this.nextToken[0] === "*")
        return this.position++, this.universal(k2);
    }, q.prototype.nesting = function() {
      this.newNode(new D2.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] })), this.position++;
    }, q.prototype.parentheses = function() {
      var k2 = this.current.last;
      if (k2 && k2.type === L.PSEUDO) {
        var z = new a3.default(), A2 = this.current;
        k2.append(z), this.current = z;
        var E = 1;
        for (this.position++; this.position < this.tokens.length && E; )
          this.currToken[0] === "(" && E++, this.currToken[0] === ")" && E--, E ? this.parse() : (z.parent.source.end.line = this.currToken[2], z.parent.source.end.column = this.currToken[3], this.position++);
        E && this.error("Expected closing parenthesis."), this.current = A2;
      } else {
        var H3 = 1;
        for (this.position++, k2.value += "("; this.position < this.tokens.length && H3; )
          this.currToken[0] === "(" && H3++, this.currToken[0] === ")" && H3--, k2.value += this.parseParenthesisToken(this.currToken), this.position++;
        H3 && this.error("Expected closing parenthesis.");
      }
    }, q.prototype.pseudo = function() {
      for (var k2 = this, z = "", A2 = this.currToken; this.currToken && this.currToken[0] === ":"; )
        z += this.currToken[1], this.position++;
      if (!this.currToken)
        return this.error("Expected pseudo-class or pseudo-element");
      if (this.currToken[0] === "word") {
        var E = void 0;
        this.splitWord(false, function(H3, U) {
          z += H3, E = new R.default({ value: z, source: { start: { line: A2[2], column: A2[3] }, end: { line: k2.currToken[4], column: k2.currToken[5] } }, sourceIndex: A2[4] }), k2.newNode(E), U > 1 && k2.nextToken && k2.nextToken[0] === "(" && k2.error("Misplaced parenthesis.");
        });
      } else
        this.error('Unexpected "' + this.currToken[0] + '" found.');
    }, q.prototype.space = function() {
      var k2 = this.currToken;
      this.position === 0 || this.prevToken[0] === "," || this.prevToken[0] === "(" ? (this.spaces = this.parseSpace(k2[1]), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.spaces.after = this.parseSpace(k2[1]), this.position++) : this.combinator();
    }, q.prototype.string = function() {
      var k2 = this.currToken;
      this.newNode(new S2.default({ value: this.currToken[1], source: { start: { line: k2[2], column: k2[3] }, end: { line: k2[4], column: k2[5] } }, sourceIndex: k2[6] })), this.position++;
    }, q.prototype.universal = function(k2) {
      var z = this.nextToken;
      if (z && z[1] === "|")
        return this.position++, this.namespace();
      this.newNode(new F.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), k2), this.position++;
    }, q.prototype.splitWord = function(k2, z) {
      for (var A2 = this, E = this.nextToken, H3 = this.currToken[1]; E && E[0] === "word"; ) {
        this.position++;
        var U = this.currToken[1];
        if (H3 += U, U.lastIndexOf("\\") === U.length - 1) {
          var re2 = this.nextToken;
          re2 && re2[0] === "space" && (H3 += this.parseSpace(re2[1], " "), this.position++);
        }
        E = this.nextToken;
      }
      var ne = (0, f.default)(H3, "."), ce = (0, f.default)(H3, "#"), fe2 = (0, f.default)(H3, "#{");
      fe2.length && (ce = ce.filter(function(ie) {
        return !~fe2.indexOf(ie);
      }));
      var te2 = (0, N.default)((0, g2.default)((0, o.default)([[0], ne, ce])));
      te2.forEach(function(ie, ae2) {
        var se = te2[ae2 + 1] || H3.length, le2 = H3.slice(ie, se);
        if (ae2 === 0 && z)
          return z.call(A2, le2, te2.length);
        var pe = void 0;
        ~ne.indexOf(ie) ? pe = new u.default({ value: le2.slice(1), source: { start: { line: A2.currToken[2], column: A2.currToken[3] + ie }, end: { line: A2.currToken[4], column: A2.currToken[3] + (se - 1) } }, sourceIndex: A2.currToken[6] + te2[ae2] }) : ~ce.indexOf(ie) ? pe = new w2.default({ value: le2.slice(1), source: { start: { line: A2.currToken[2], column: A2.currToken[3] + ie }, end: { line: A2.currToken[4], column: A2.currToken[3] + (se - 1) } }, sourceIndex: A2.currToken[6] + te2[ae2] }) : pe = new _.default({ value: le2, source: { start: { line: A2.currToken[2], column: A2.currToken[3] + ie }, end: { line: A2.currToken[4], column: A2.currToken[3] + (se - 1) } }, sourceIndex: A2.currToken[6] + te2[ae2] }), A2.newNode(pe, k2);
      }), this.position++;
    }, q.prototype.word = function(k2) {
      var z = this.nextToken;
      return z && z[1] === "|" ? (this.position++, this.namespace()) : this.splitWord(k2);
    }, q.prototype.loop = function() {
      for (; this.position < this.tokens.length; )
        this.parse(true);
      return this.root;
    }, q.prototype.parse = function(k2) {
      switch (this.currToken[0]) {
        case "space":
          this.space();
          break;
        case "comment":
          this.comment();
          break;
        case "(":
          this.parentheses();
          break;
        case ")":
          k2 && this.missingParenthesis();
          break;
        case "[":
          this.attribute();
          break;
        case "]":
          this.missingSquareBracket();
          break;
        case "at-word":
        case "word":
          this.word();
          break;
        case ":":
          this.pseudo();
          break;
        case ";":
          this.missingBackslash();
          break;
        case ",":
          this.comma();
          break;
        case "*":
          this.universal();
          break;
        case "&":
          this.nesting();
          break;
        case "combinator":
          this.combinator();
          break;
        case "string":
          this.string();
          break;
      }
    }, q.prototype.parseNamespace = function(k2) {
      if (this.lossy && typeof k2 == "string") {
        var z = k2.trim();
        return z.length ? z : true;
      }
      return k2;
    }, q.prototype.parseSpace = function(k2, z) {
      return this.lossy ? z || "" : k2;
    }, q.prototype.parseValue = function(k2) {
      return this.lossy && k2 && typeof k2 == "string" ? k2.trim() : k2;
    }, q.prototype.parseParenthesisToken = function(k2) {
      return this.lossy ? k2[0] === "space" ? this.parseSpace(k2[1], " ") : this.parseValue(k2[1]) : k2[1];
    }, q.prototype.newNode = function(k2, z) {
      return z && (k2.namespace = this.parseNamespace(z)), this.spaces && (k2.spaces.before = this.spaces, this.spaces = ""), this.current.append(k2);
    }, s2(q, [{ key: "currToken", get: function() {
      return this.tokens[this.position];
    } }, { key: "nextToken", get: function() {
      return this.tokens[this.position + 1];
    } }, { key: "prevToken", get: function() {
      return this.tokens[this.position - 1];
    } }]), q;
  }();
  r.default = V, i2.exports = r.default;
} }), Yl = C({ "node_modules/postcss-selector-parser/dist/processor.js"(r, i2) {
  I(), r.__esModule = true;
  var s2 = function() {
    function g2(c, t) {
      for (var e = 0; e < t.length; e++) {
        var a3 = t[e];
        a3.enumerable = a3.enumerable || false, a3.configurable = true, "value" in a3 && (a3.writable = true), Object.defineProperty(c, a3.key, a3);
      }
    }
    return function(c, t, e) {
      return t && g2(c.prototype, t), e && g2(c, e), c;
    };
  }(), l = Ql(), o = h2(l);
  function h2(g2) {
    return g2 && g2.__esModule ? g2 : { default: g2 };
  }
  function f(g2, c) {
    if (!(g2 instanceof c))
      throw new TypeError("Cannot call a class as a function");
  }
  var p = function() {
    function g2(c) {
      return f(this, g2), this.func = c || function() {
      }, this;
    }
    return g2.prototype.process = function(t) {
      var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a3 = new o.default({ css: t, error: function(u) {
        throw new Error(u);
      }, options: e });
      return this.res = a3, this.func(a3), this;
    }, s2(g2, [{ key: "result", get: function() {
      return String(this.res);
    } }]), g2;
  }();
  r.default = p, i2.exports = r.default;
} }), Xl = C({ "node_modules/postcss-selector-parser/dist/index.js"(r, i2) {
  I(), r.__esModule = true;
  var s2 = Yl(), l = T2(s2), o = Eo(), h2 = T2(o), f = bo(), p = T2(f), g2 = Ao(), c = T2(g2), t = xo(), e = T2(t), a3 = ko(), n = T2(a3), u = Po(), m2 = T2(u), v = To(), y = T2(v), w2 = wo(), d4 = T2(w2), _ = _o(), O2 = T2(_), S2 = Oo(), M2 = T2(S2), R = So(), $ = T2(R), J2 = qo(), X3 = T2(J2), F = oe(), K = W2(F);
  function W2(j) {
    if (j && j.__esModule)
      return j;
    var N = {};
    if (j != null)
      for (var b2 in j)
        Object.prototype.hasOwnProperty.call(j, b2) && (N[b2] = j[b2]);
    return N.default = j, N;
  }
  function T2(j) {
    return j && j.__esModule ? j : { default: j };
  }
  var D2 = function(N) {
    return new l.default(N);
  };
  D2.attribute = function(j) {
    return new h2.default(j);
  }, D2.className = function(j) {
    return new p.default(j);
  }, D2.combinator = function(j) {
    return new c.default(j);
  }, D2.comment = function(j) {
    return new e.default(j);
  }, D2.id = function(j) {
    return new n.default(j);
  }, D2.nesting = function(j) {
    return new m2.default(j);
  }, D2.pseudo = function(j) {
    return new y.default(j);
  }, D2.root = function(j) {
    return new d4.default(j);
  }, D2.selector = function(j) {
    return new O2.default(j);
  }, D2.string = function(j) {
    return new M2.default(j);
  }, D2.tag = function(j) {
    return new $.default(j);
  }, D2.universal = function(j) {
    return new X3.default(j);
  }, Object.keys(K).forEach(function(j) {
    j !== "__esModule" && (D2[j] = K[j]);
  }), r.default = D2, i2.exports = r.default;
} }), Ro = C({ "node_modules/postcss-media-query-parser/dist/nodes/Node.js"(r) {
  I(), Object.defineProperty(r, "__esModule", { value: true });
  function i2(s2) {
    this.after = s2.after, this.before = s2.before, this.type = s2.type, this.value = s2.value, this.sourceIndex = s2.sourceIndex;
  }
  r.default = i2;
} }), Io = C({ "node_modules/postcss-media-query-parser/dist/nodes/Container.js"(r) {
  I(), Object.defineProperty(r, "__esModule", { value: true });
  var i2 = Ro(), s2 = l(i2);
  function l(h2) {
    return h2 && h2.__esModule ? h2 : { default: h2 };
  }
  function o(h2) {
    var f = this;
    this.constructor(h2), this.nodes = h2.nodes, this.after === void 0 && (this.after = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : ""), this.before === void 0 && (this.before = this.nodes.length > 0 ? this.nodes[0].before : ""), this.sourceIndex === void 0 && (this.sourceIndex = this.before.length), this.nodes.forEach(function(p) {
      p.parent = f;
    });
  }
  o.prototype = Object.create(s2.default.prototype), o.constructor = s2.default, o.prototype.walk = function(f, p) {
    for (var g2 = typeof f == "string" || f instanceof RegExp, c = g2 ? p : f, t = typeof f == "string" ? new RegExp(f) : f, e = 0; e < this.nodes.length; e++) {
      var a3 = this.nodes[e], n = g2 ? t.test(a3.type) : true;
      if (n && c && c(a3, e, this.nodes) === false || a3.nodes && a3.walk(f, p) === false)
        return false;
    }
    return true;
  }, o.prototype.each = function() {
    for (var f = arguments.length <= 0 || arguments[0] === void 0 ? function() {
    } : arguments[0], p = 0; p < this.nodes.length; p++) {
      var g2 = this.nodes[p];
      if (f(g2, p, this.nodes) === false)
        return false;
    }
    return true;
  }, r.default = o;
} }), Zl = C({ "node_modules/postcss-media-query-parser/dist/parsers.js"(r) {
  I(), Object.defineProperty(r, "__esModule", { value: true }), r.parseMediaFeature = f, r.parseMediaQuery = p, r.parseMediaList = g2;
  var i2 = Ro(), s2 = h2(i2), l = Io(), o = h2(l);
  function h2(c) {
    return c && c.__esModule ? c : { default: c };
  }
  function f(c) {
    var t = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], e = [{ mode: "normal", character: null }], a3 = [], n = 0, u = "", m2 = null, v = null, y = t, w2 = c;
    c[0] === "(" && c[c.length - 1] === ")" && (w2 = c.substring(1, c.length - 1), y++);
    for (var d4 = 0; d4 < w2.length; d4++) {
      var _ = w2[d4];
      if ((_ === "'" || _ === '"') && (e[n].isCalculationEnabled === true ? (e.push({ mode: "string", isCalculationEnabled: false, character: _ }), n++) : e[n].mode === "string" && e[n].character === _ && w2[d4 - 1] !== "\\" && (e.pop(), n--)), _ === "{" ? (e.push({ mode: "interpolation", isCalculationEnabled: true }), n++) : _ === "}" && (e.pop(), n--), e[n].mode === "normal" && _ === ":") {
        var O2 = w2.substring(d4 + 1);
        v = { type: "value", before: /^(\s*)/.exec(O2)[1], after: /(\s*)$/.exec(O2)[1], value: O2.trim() }, v.sourceIndex = v.before.length + d4 + 1 + y, m2 = { type: "colon", sourceIndex: d4 + y, after: v.before, value: ":" };
        break;
      }
      u += _;
    }
    return u = { type: "media-feature", before: /^(\s*)/.exec(u)[1], after: /(\s*)$/.exec(u)[1], value: u.trim() }, u.sourceIndex = u.before.length + y, a3.push(u), m2 !== null && (m2.before = u.after, a3.push(m2)), v !== null && a3.push(v), a3;
  }
  function p(c) {
    var t = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], e = [], a3 = 0, n = false, u = void 0;
    function m2() {
      return { before: "", after: "", value: "" };
    }
    u = m2();
    for (var v = 0; v < c.length; v++) {
      var y = c[v];
      n ? (u.value += y, (y === "{" || y === "(") && a3++, (y === ")" || y === "}") && a3--) : y.search(/\s/) !== -1 ? u.before += y : (y === "(" && (u.type = "media-feature-expression", a3++), u.value = y, u.sourceIndex = t + v, n = true), n && a3 === 0 && (y === ")" || v === c.length - 1 || c[v + 1].search(/\s/) !== -1) && (["not", "only", "and"].indexOf(u.value) !== -1 && (u.type = "keyword"), u.type === "media-feature-expression" && (u.nodes = f(u.value, u.sourceIndex)), e.push(Array.isArray(u.nodes) ? new o.default(u) : new s2.default(u)), u = m2(), n = false);
    }
    for (var w2 = 0; w2 < e.length; w2++)
      if (u = e[w2], w2 > 0 && (e[w2 - 1].after = u.before), u.type === void 0) {
        if (w2 > 0) {
          if (e[w2 - 1].type === "media-feature-expression") {
            u.type = "keyword";
            continue;
          }
          if (e[w2 - 1].value === "not" || e[w2 - 1].value === "only") {
            u.type = "media-type";
            continue;
          }
          if (e[w2 - 1].value === "and") {
            u.type = "media-feature-expression";
            continue;
          }
          e[w2 - 1].type === "media-type" && (e[w2 + 1] ? u.type = e[w2 + 1].type === "media-feature-expression" ? "keyword" : "media-feature-expression" : u.type = "media-feature-expression");
        }
        if (w2 === 0) {
          if (!e[w2 + 1]) {
            u.type = "media-type";
            continue;
          }
          if (e[w2 + 1] && (e[w2 + 1].type === "media-feature-expression" || e[w2 + 1].type === "keyword")) {
            u.type = "media-type";
            continue;
          }
          if (e[w2 + 2]) {
            if (e[w2 + 2].type === "media-feature-expression") {
              u.type = "media-type", e[w2 + 1].type = "keyword";
              continue;
            }
            if (e[w2 + 2].type === "keyword") {
              u.type = "keyword", e[w2 + 1].type = "media-type";
              continue;
            }
          }
          if (e[w2 + 3] && e[w2 + 3].type === "media-feature-expression") {
            u.type = "keyword", e[w2 + 1].type = "media-type", e[w2 + 2].type = "keyword";
            continue;
          }
        }
      }
    return e;
  }
  function g2(c) {
    var t = [], e = 0, a3 = 0, n = /^(\s*)url\s*\(/.exec(c);
    if (n !== null) {
      for (var u = n[0].length, m2 = 1; m2 > 0; ) {
        var v = c[u];
        v === "(" && m2++, v === ")" && m2--, u++;
      }
      t.unshift(new s2.default({ type: "url", value: c.substring(0, u).trim(), sourceIndex: n[1].length, before: n[1], after: /^(\s*)/.exec(c.substring(u))[1] })), e = u;
    }
    for (var y = e; y < c.length; y++) {
      var w2 = c[y];
      if (w2 === "(" && a3++, w2 === ")" && a3--, a3 === 0 && w2 === ",") {
        var d4 = c.substring(e, y), _ = /^(\s*)/.exec(d4)[1];
        t.push(new o.default({ type: "media-query", value: d4.trim(), sourceIndex: e + _.length, nodes: p(d4, e), before: _, after: /(\s*)$/.exec(d4)[1] })), e = y + 1;
      }
    }
    var O2 = c.substring(e), S2 = /^(\s*)/.exec(O2)[1];
    return t.push(new o.default({ type: "media-query", value: O2.trim(), sourceIndex: e + S2.length, nodes: p(O2, e), before: S2, after: /(\s*)$/.exec(O2)[1] })), t;
  }
} }), ef = C({ "node_modules/postcss-media-query-parser/dist/index.js"(r) {
  I(), Object.defineProperty(r, "__esModule", { value: true }), r.default = h2;
  var i2 = Io(), s2 = o(i2), l = Zl();
  function o(f) {
    return f && f.__esModule ? f : { default: f };
  }
  function h2(f) {
    return new s2.default({ nodes: (0, l.parseMediaList)(f), type: "media-query-list", value: f.trim() });
  }
} }), Co = {};
mt(Co, { basename: () => Lo, default: () => Bo, delimiter: () => ht, dirname: () => Do, extname: () => zo, isAbsolute: () => Tt, join: () => jo, normalize: () => Ot, relative: () => Mo, resolve: () => pr, sep: () => pt });
function No(r, i2) {
  for (var s2 = 0, l = r.length - 1; l >= 0; l--) {
    var o = r[l];
    o === "." ? r.splice(l, 1) : o === ".." ? (r.splice(l, 1), s2++) : s2 && (r.splice(l, 1), s2--);
  }
  if (i2)
    for (; s2--; s2)
      r.unshift("..");
  return r;
}
function pr() {
  for (var r = "", i2 = false, s2 = arguments.length - 1; s2 >= -1 && !i2; s2--) {
    var l = s2 >= 0 ? arguments[s2] : "/";
    if (typeof l != "string")
      throw new TypeError("Arguments to path.resolve must be strings");
    if (!l)
      continue;
    r = l + "/" + r, i2 = l.charAt(0) === "/";
  }
  return r = No(Et(r.split("/"), function(o) {
    return !!o;
  }), !i2).join("/"), (i2 ? "/" : "") + r || ".";
}
function Ot(r) {
  var i2 = Tt(r), s2 = Fo(r, -1) === "/";
  return r = No(Et(r.split("/"), function(l) {
    return !!l;
  }), !i2).join("/"), !r && !i2 && (r = "."), r && s2 && (r += "/"), (i2 ? "/" : "") + r;
}
function Tt(r) {
  return r.charAt(0) === "/";
}
function jo() {
  var r = Array.prototype.slice.call(arguments, 0);
  return Ot(Et(r, function(i2, s2) {
    if (typeof i2 != "string")
      throw new TypeError("Arguments to path.join must be strings");
    return i2;
  }).join("/"));
}
function Mo(r, i2) {
  r = pr(r).substr(1), i2 = pr(i2).substr(1);
  function s2(c) {
    for (var t = 0; t < c.length && c[t] === ""; t++)
      ;
    for (var e = c.length - 1; e >= 0 && c[e] === ""; e--)
      ;
    return t > e ? [] : c.slice(t, e - t + 1);
  }
  for (var l = s2(r.split("/")), o = s2(i2.split("/")), h2 = Math.min(l.length, o.length), f = h2, p = 0; p < h2; p++)
    if (l[p] !== o[p]) {
      f = p;
      break;
    }
  for (var g2 = [], p = f; p < l.length; p++)
    g2.push("..");
  return g2 = g2.concat(o.slice(f)), g2.join("/");
}
function Do(r) {
  var i2 = vr(r), s2 = i2[0], l = i2[1];
  return !s2 && !l ? "." : (l && (l = l.substr(0, l.length - 1)), s2 + l);
}
function Lo(r, i2) {
  var s2 = vr(r)[2];
  return i2 && s2.substr(-1 * i2.length) === i2 && (s2 = s2.substr(0, s2.length - i2.length)), s2;
}
function zo(r) {
  return vr(r)[3];
}
function Et(r, i2) {
  if (r.filter)
    return r.filter(i2);
  for (var s2 = [], l = 0; l < r.length; l++)
    i2(r[l], l, r) && s2.push(r[l]);
  return s2;
}
var ks, vr, pt, ht, Bo, Fo, rf = Me({ "node-modules-polyfills:path"() {
  I(), ks = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, vr = function(r) {
    return ks.exec(r).slice(1);
  }, pt = "/", ht = ":", Bo = { extname: zo, basename: Lo, dirname: Do, sep: pt, delimiter: ht, relative: Mo, join: jo, isAbsolute: Tt, normalize: Ot, resolve: pr }, Fo = "ab".substr(-1) === "b" ? function(r, i2, s2) {
    return r.substr(i2, s2);
  } : function(r, i2, s2) {
    return i2 < 0 && (i2 = r.length + i2), r.substr(i2, s2);
  };
} }), tf = C({ "node-modules-polyfills-commonjs:path"(r, i2) {
  I();
  var s2 = (rf(), gt(Co));
  if (s2 && s2.default) {
    i2.exports = s2.default;
    for (let l in s2)
      i2.exports[l] = s2[l];
  } else
    s2 && (i2.exports = s2);
} }), nf = C({ "node_modules/picocolors/picocolors.browser.js"(r, i2) {
  I();
  var s2 = String, l = function() {
    return { isColorSupported: false, reset: s2, bold: s2, dim: s2, italic: s2, underline: s2, inverse: s2, hidden: s2, strikethrough: s2, black: s2, red: s2, green: s2, yellow: s2, blue: s2, magenta: s2, cyan: s2, white: s2, gray: s2, bgBlack: s2, bgRed: s2, bgGreen: s2, bgYellow: s2, bgBlue: s2, bgMagenta: s2, bgCyan: s2, bgWhite: s2 };
  };
  i2.exports = l(), i2.exports.createColors = l;
} }), sf = C({ "(disabled):node_modules/postcss/lib/terminal-highlight"() {
  I();
} }), Uo = C({ "node_modules/postcss/lib/css-syntax-error.js"(r, i2) {
  I(), r.__esModule = true, r.default = void 0;
  var s2 = o(nf()), l = o(sf());
  function o(m2) {
    return m2 && m2.__esModule ? m2 : { default: m2 };
  }
  function h2(m2) {
    if (m2 === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return m2;
  }
  function f(m2, v) {
    m2.prototype = Object.create(v.prototype), m2.prototype.constructor = m2, m2.__proto__ = v;
  }
  function p(m2) {
    var v = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
    return p = function(w2) {
      if (w2 === null || !t(w2))
        return w2;
      if (typeof w2 != "function")
        throw new TypeError("Super expression must either be null or a function");
      if (typeof v < "u") {
        if (v.has(w2))
          return v.get(w2);
        v.set(w2, d4);
      }
      function d4() {
        return g2(w2, arguments, a3(this).constructor);
      }
      return d4.prototype = Object.create(w2.prototype, { constructor: { value: d4, enumerable: false, writable: true, configurable: true } }), e(d4, w2);
    }, p(m2);
  }
  function g2(m2, v, y) {
    return c() ? g2 = Reflect.construct : g2 = function(d4, _, O2) {
      var S2 = [null];
      S2.push.apply(S2, _);
      var M2 = Function.bind.apply(d4, S2), R = new M2();
      return O2 && e(R, O2.prototype), R;
    }, g2.apply(null, arguments);
  }
  function c() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return false;
    if (typeof Proxy == "function")
      return true;
    try {
      return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      })), true;
    } catch {
      return false;
    }
  }
  function t(m2) {
    return Function.toString.call(m2).indexOf("[native code]") !== -1;
  }
  function e(m2, v) {
    return e = Object.setPrototypeOf || function(w2, d4) {
      return w2.__proto__ = d4, w2;
    }, e(m2, v);
  }
  function a3(m2) {
    return a3 = Object.setPrototypeOf ? Object.getPrototypeOf : function(y) {
      return y.__proto__ || Object.getPrototypeOf(y);
    }, a3(m2);
  }
  var n = function(m2) {
    f(v, m2);
    function v(w2, d4, _, O2, S2, M2) {
      var R;
      return R = m2.call(this, w2) || this, R.name = "CssSyntaxError", R.reason = w2, S2 && (R.file = S2), O2 && (R.source = O2), M2 && (R.plugin = M2), typeof d4 < "u" && typeof _ < "u" && (R.line = d4, R.column = _), R.setMessage(), Error.captureStackTrace && Error.captureStackTrace(h2(R), v), R;
    }
    var y = v.prototype;
    return y.setMessage = function() {
      this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
    }, y.showSourceCode = function(d4) {
      var _ = this;
      if (!this.source)
        return "";
      var O2 = this.source;
      l.default && (typeof d4 > "u" && (d4 = s2.default.isColorSupported), d4 && (O2 = (0, l.default)(O2)));
      var S2 = O2.split(/\r?\n/), M2 = Math.max(this.line - 3, 0), R = Math.min(this.line + 2, S2.length), $ = String(R).length;
      function J2(F) {
        return d4 && s2.default.red ? s2.default.red(s2.default.bold(F)) : F;
      }
      function X3(F) {
        return d4 && s2.default.gray ? s2.default.gray(F) : F;
      }
      return S2.slice(M2, R).map(function(F, K) {
        var W2 = M2 + 1 + K, T2 = " " + (" " + W2).slice(-$) + " | ";
        if (W2 === _.line) {
          var D2 = X3(T2.replace(/\d/g, " ")) + F.slice(0, _.column - 1).replace(/[^\t]/g, " ");
          return J2(">") + X3(T2) + F + `
 ` + D2 + J2("^");
        }
        return " " + X3(T2) + F;
      }).join(`
`);
    }, y.toString = function() {
      var d4 = this.showSourceCode();
      return d4 && (d4 = `

` + d4 + `
`), this.name + ": " + this.message + d4;
    }, v;
  }(p(Error)), u = n;
  r.default = u, i2.exports = r.default;
} }), of = C({ "node_modules/postcss/lib/previous-map.js"(r, i2) {
  I(), i2.exports = class {
  };
} }), mr = C({ "node_modules/postcss/lib/input.js"(r, i2) {
  I(), r.__esModule = true, r.default = void 0;
  var s2 = h2(tf()), l = h2(Uo()), o = h2(of());
  function h2(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function f(e, a3) {
    for (var n = 0; n < a3.length; n++) {
      var u = a3[n];
      u.enumerable = u.enumerable || false, u.configurable = true, "value" in u && (u.writable = true), Object.defineProperty(e, u.key, u);
    }
  }
  function p(e, a3, n) {
    return a3 && f(e.prototype, a3), n && f(e, n), e;
  }
  var g2 = 0, c = function() {
    function e(n, u) {
      if (u === void 0 && (u = {}), n === null || typeof n > "u" || typeof n == "object" && !n.toString)
        throw new Error("PostCSS received " + n + " instead of CSS string");
      this.css = n.toString(), this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE" ? (this.hasBOM = true, this.css = this.css.slice(1)) : this.hasBOM = false, u.from && (/^\w+:\/\//.test(u.from) || s2.default.isAbsolute(u.from) ? this.file = u.from : this.file = s2.default.resolve(u.from));
      var m2 = new o.default(this.css, u);
      if (m2.text) {
        this.map = m2;
        var v = m2.consumer().file;
        !this.file && v && (this.file = this.mapResolve(v));
      }
      this.file || (g2 += 1, this.id = "<input css " + g2 + ">"), this.map && (this.map.file = this.from);
    }
    var a3 = e.prototype;
    return a3.error = function(u, m2, v, y) {
      y === void 0 && (y = {});
      var w2, d4 = this.origin(m2, v);
      return d4 ? w2 = new l.default(u, d4.line, d4.column, d4.source, d4.file, y.plugin) : w2 = new l.default(u, m2, v, this.css, this.file, y.plugin), w2.input = { line: m2, column: v, source: this.css }, this.file && (w2.input.file = this.file), w2;
    }, a3.origin = function(u, m2) {
      if (!this.map)
        return false;
      var v = this.map.consumer(), y = v.originalPositionFor({ line: u, column: m2 });
      if (!y.source)
        return false;
      var w2 = { file: this.mapResolve(y.source), line: y.line, column: y.column }, d4 = v.sourceContentFor(y.source);
      return d4 && (w2.source = d4), w2;
    }, a3.mapResolve = function(u) {
      return /^\w+:\/\//.test(u) ? u : s2.default.resolve(this.map.consumer().sourceRoot || ".", u);
    }, p(e, [{ key: "from", get: function() {
      return this.file || this.id;
    } }]), e;
  }(), t = c;
  r.default = t, i2.exports = r.default;
} }), gr = C({ "node_modules/postcss/lib/stringifier.js"(r, i2) {
  I(), r.__esModule = true, r.default = void 0;
  var s2 = { colon: ": ", indent: "    ", beforeDecl: `
`, beforeRule: `
`, beforeOpen: " ", beforeClose: `
`, beforeComment: `
`, after: `
`, emptyBody: "", commentLeft: " ", commentRight: " ", semicolon: false };
  function l(f) {
    return f[0].toUpperCase() + f.slice(1);
  }
  var o = function() {
    function f(g2) {
      this.builder = g2;
    }
    var p = f.prototype;
    return p.stringify = function(c, t) {
      this[c.type](c, t);
    }, p.root = function(c) {
      this.body(c), c.raws.after && this.builder(c.raws.after);
    }, p.comment = function(c) {
      var t = this.raw(c, "left", "commentLeft"), e = this.raw(c, "right", "commentRight");
      this.builder("/*" + t + c.text + e + "*/", c);
    }, p.decl = function(c, t) {
      var e = this.raw(c, "between", "colon"), a3 = c.prop + e + this.rawValue(c, "value");
      c.important && (a3 += c.raws.important || " !important"), t && (a3 += ";"), this.builder(a3, c);
    }, p.rule = function(c) {
      this.block(c, this.rawValue(c, "selector")), c.raws.ownSemicolon && this.builder(c.raws.ownSemicolon, c, "end");
    }, p.atrule = function(c, t) {
      var e = "@" + c.name, a3 = c.params ? this.rawValue(c, "params") : "";
      if (typeof c.raws.afterName < "u" ? e += c.raws.afterName : a3 && (e += " "), c.nodes)
        this.block(c, e + a3);
      else {
        var n = (c.raws.between || "") + (t ? ";" : "");
        this.builder(e + a3 + n, c);
      }
    }, p.body = function(c) {
      for (var t = c.nodes.length - 1; t > 0 && c.nodes[t].type === "comment"; )
        t -= 1;
      for (var e = this.raw(c, "semicolon"), a3 = 0; a3 < c.nodes.length; a3++) {
        var n = c.nodes[a3], u = this.raw(n, "before");
        u && this.builder(u), this.stringify(n, t !== a3 || e);
      }
    }, p.block = function(c, t) {
      var e = this.raw(c, "between", "beforeOpen");
      this.builder(t + e + "{", c, "start");
      var a3;
      c.nodes && c.nodes.length ? (this.body(c), a3 = this.raw(c, "after")) : a3 = this.raw(c, "after", "emptyBody"), a3 && this.builder(a3), this.builder("}", c, "end");
    }, p.raw = function(c, t, e) {
      var a3;
      if (e || (e = t), t && (a3 = c.raws[t], typeof a3 < "u"))
        return a3;
      var n = c.parent;
      if (e === "before" && (!n || n.type === "root" && n.first === c))
        return "";
      if (!n)
        return s2[e];
      var u = c.root();
      if (u.rawCache || (u.rawCache = {}), typeof u.rawCache[e] < "u")
        return u.rawCache[e];
      if (e === "before" || e === "after")
        return this.beforeAfter(c, e);
      var m2 = "raw" + l(e);
      return this[m2] ? a3 = this[m2](u, c) : u.walk(function(v) {
        if (a3 = v.raws[t], typeof a3 < "u")
          return false;
      }), typeof a3 > "u" && (a3 = s2[e]), u.rawCache[e] = a3, a3;
    }, p.rawSemicolon = function(c) {
      var t;
      return c.walk(function(e) {
        if (e.nodes && e.nodes.length && e.last.type === "decl" && (t = e.raws.semicolon, typeof t < "u"))
          return false;
      }), t;
    }, p.rawEmptyBody = function(c) {
      var t;
      return c.walk(function(e) {
        if (e.nodes && e.nodes.length === 0 && (t = e.raws.after, typeof t < "u"))
          return false;
      }), t;
    }, p.rawIndent = function(c) {
      if (c.raws.indent)
        return c.raws.indent;
      var t;
      return c.walk(function(e) {
        var a3 = e.parent;
        if (a3 && a3 !== c && a3.parent && a3.parent === c && typeof e.raws.before < "u") {
          var n = e.raws.before.split(`
`);
          return t = n[n.length - 1], t = t.replace(/[^\s]/g, ""), false;
        }
      }), t;
    }, p.rawBeforeComment = function(c, t) {
      var e;
      return c.walkComments(function(a3) {
        if (typeof a3.raws.before < "u")
          return e = a3.raws.before, e.indexOf(`
`) !== -1 && (e = e.replace(/[^\n]+$/, "")), false;
      }), typeof e > "u" ? e = this.raw(t, null, "beforeDecl") : e && (e = e.replace(/[^\s]/g, "")), e;
    }, p.rawBeforeDecl = function(c, t) {
      var e;
      return c.walkDecls(function(a3) {
        if (typeof a3.raws.before < "u")
          return e = a3.raws.before, e.indexOf(`
`) !== -1 && (e = e.replace(/[^\n]+$/, "")), false;
      }), typeof e > "u" ? e = this.raw(t, null, "beforeRule") : e && (e = e.replace(/[^\s]/g, "")), e;
    }, p.rawBeforeRule = function(c) {
      var t;
      return c.walk(function(e) {
        if (e.nodes && (e.parent !== c || c.first !== e) && typeof e.raws.before < "u")
          return t = e.raws.before, t.indexOf(`
`) !== -1 && (t = t.replace(/[^\n]+$/, "")), false;
      }), t && (t = t.replace(/[^\s]/g, "")), t;
    }, p.rawBeforeClose = function(c) {
      var t;
      return c.walk(function(e) {
        if (e.nodes && e.nodes.length > 0 && typeof e.raws.after < "u")
          return t = e.raws.after, t.indexOf(`
`) !== -1 && (t = t.replace(/[^\n]+$/, "")), false;
      }), t && (t = t.replace(/[^\s]/g, "")), t;
    }, p.rawBeforeOpen = function(c) {
      var t;
      return c.walk(function(e) {
        if (e.type !== "decl" && (t = e.raws.between, typeof t < "u"))
          return false;
      }), t;
    }, p.rawColon = function(c) {
      var t;
      return c.walkDecls(function(e) {
        if (typeof e.raws.between < "u")
          return t = e.raws.between.replace(/[^\s:]/g, ""), false;
      }), t;
    }, p.beforeAfter = function(c, t) {
      var e;
      c.type === "decl" ? e = this.raw(c, null, "beforeDecl") : c.type === "comment" ? e = this.raw(c, null, "beforeComment") : t === "before" ? e = this.raw(c, null, "beforeRule") : e = this.raw(c, null, "beforeClose");
      for (var a3 = c.parent, n = 0; a3 && a3.type !== "root"; )
        n += 1, a3 = a3.parent;
      if (e.indexOf(`
`) !== -1) {
        var u = this.raw(c, null, "indent");
        if (u.length)
          for (var m2 = 0; m2 < n; m2++)
            e += u;
      }
      return e;
    }, p.rawValue = function(c, t) {
      var e = c[t], a3 = c.raws[t];
      return a3 && a3.value === e ? a3.raw : e;
    }, f;
  }(), h2 = o;
  r.default = h2, i2.exports = r.default;
} }), Wo = C({ "node_modules/postcss/lib/stringify.js"(r, i2) {
  I(), r.__esModule = true, r.default = void 0;
  var s2 = l(gr());
  function l(f) {
    return f && f.__esModule ? f : { default: f };
  }
  function o(f, p) {
    var g2 = new s2.default(p);
    g2.stringify(f);
  }
  var h2 = o;
  r.default = h2, i2.exports = r.default;
} }), qt = C({ "node_modules/postcss/lib/node.js"(r, i2) {
  I(), r.__esModule = true, r.default = void 0;
  var s2 = h2(Uo()), l = h2(gr()), o = h2(Wo());
  function h2(c) {
    return c && c.__esModule ? c : { default: c };
  }
  function f(c, t) {
    var e = new c.constructor();
    for (var a3 in c)
      if (!!c.hasOwnProperty(a3)) {
        var n = c[a3], u = typeof n;
        a3 === "parent" && u === "object" ? t && (e[a3] = t) : a3 === "source" ? e[a3] = n : n instanceof Array ? e[a3] = n.map(function(m2) {
          return f(m2, e);
        }) : (u === "object" && n !== null && (n = f(n)), e[a3] = n);
      }
    return e;
  }
  var p = function() {
    function c(e) {
      e === void 0 && (e = {}), this.raws = {};
      for (var a3 in e)
        this[a3] = e[a3];
    }
    var t = c.prototype;
    return t.error = function(a3, n) {
      if (n === void 0 && (n = {}), this.source) {
        var u = this.positionBy(n);
        return this.source.input.error(a3, u.line, u.column, n);
      }
      return new s2.default(a3);
    }, t.warn = function(a3, n, u) {
      var m2 = { node: this };
      for (var v in u)
        m2[v] = u[v];
      return a3.warn(n, m2);
    }, t.remove = function() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }, t.toString = function(a3) {
      a3 === void 0 && (a3 = o.default), a3.stringify && (a3 = a3.stringify);
      var n = "";
      return a3(this, function(u) {
        n += u;
      }), n;
    }, t.clone = function(a3) {
      a3 === void 0 && (a3 = {});
      var n = f(this);
      for (var u in a3)
        n[u] = a3[u];
      return n;
    }, t.cloneBefore = function(a3) {
      a3 === void 0 && (a3 = {});
      var n = this.clone(a3);
      return this.parent.insertBefore(this, n), n;
    }, t.cloneAfter = function(a3) {
      a3 === void 0 && (a3 = {});
      var n = this.clone(a3);
      return this.parent.insertAfter(this, n), n;
    }, t.replaceWith = function() {
      if (this.parent) {
        for (var a3 = arguments.length, n = new Array(a3), u = 0; u < a3; u++)
          n[u] = arguments[u];
        for (var m2 = 0, v = n; m2 < v.length; m2++) {
          var y = v[m2];
          this.parent.insertBefore(this, y);
        }
        this.remove();
      }
      return this;
    }, t.next = function() {
      if (!!this.parent) {
        var a3 = this.parent.index(this);
        return this.parent.nodes[a3 + 1];
      }
    }, t.prev = function() {
      if (!!this.parent) {
        var a3 = this.parent.index(this);
        return this.parent.nodes[a3 - 1];
      }
    }, t.before = function(a3) {
      return this.parent.insertBefore(this, a3), this;
    }, t.after = function(a3) {
      return this.parent.insertAfter(this, a3), this;
    }, t.toJSON = function() {
      var a3 = {};
      for (var n in this)
        if (!!this.hasOwnProperty(n) && n !== "parent") {
          var u = this[n];
          u instanceof Array ? a3[n] = u.map(function(m2) {
            return typeof m2 == "object" && m2.toJSON ? m2.toJSON() : m2;
          }) : typeof u == "object" && u.toJSON ? a3[n] = u.toJSON() : a3[n] = u;
        }
      return a3;
    }, t.raw = function(a3, n) {
      var u = new l.default();
      return u.raw(this, a3, n);
    }, t.root = function() {
      for (var a3 = this; a3.parent; )
        a3 = a3.parent;
      return a3;
    }, t.cleanRaws = function(a3) {
      delete this.raws.before, delete this.raws.after, a3 || delete this.raws.between;
    }, t.positionInside = function(a3) {
      for (var n = this.toString(), u = this.source.start.column, m2 = this.source.start.line, v = 0; v < a3; v++)
        n[v] === `
` ? (u = 1, m2 += 1) : u += 1;
      return { line: m2, column: u };
    }, t.positionBy = function(a3) {
      var n = this.source.start;
      if (a3.index)
        n = this.positionInside(a3.index);
      else if (a3.word) {
        var u = this.toString().indexOf(a3.word);
        u !== -1 && (n = this.positionInside(u));
      }
      return n;
    }, c;
  }(), g2 = p;
  r.default = g2, i2.exports = r.default;
} }), yr = C({ "node_modules/postcss/lib/comment.js"(r, i2) {
  I(), r.__esModule = true, r.default = void 0;
  var s2 = l(qt());
  function l(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function o(p, g2) {
    p.prototype = Object.create(g2.prototype), p.prototype.constructor = p, p.__proto__ = g2;
  }
  var h2 = function(p) {
    o(g2, p);
    function g2(c) {
      var t;
      return t = p.call(this, c) || this, t.type = "comment", t;
    }
    return g2;
  }(s2.default), f = h2;
  r.default = f, i2.exports = r.default;
} }), $o = C({ "node_modules/postcss/lib/declaration.js"(r, i2) {
  I(), r.__esModule = true, r.default = void 0;
  var s2 = l(qt());
  function l(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function o(p, g2) {
    p.prototype = Object.create(g2.prototype), p.prototype.constructor = p, p.__proto__ = g2;
  }
  var h2 = function(p) {
    o(g2, p);
    function g2(c) {
      var t;
      return t = p.call(this, c) || this, t.type = "decl", t;
    }
    return g2;
  }(s2.default), f = h2;
  r.default = f, i2.exports = r.default;
} }), At = C({ "node_modules/postcss/lib/tokenize.js"(r, i2) {
  I(), r.__esModule = true, r.default = $;
  var s2 = "'".charCodeAt(0), l = '"'.charCodeAt(0), o = "\\".charCodeAt(0), h2 = "/".charCodeAt(0), f = `
`.charCodeAt(0), p = " ".charCodeAt(0), g2 = "\f".charCodeAt(0), c = "	".charCodeAt(0), t = "\r".charCodeAt(0), e = "[".charCodeAt(0), a3 = "]".charCodeAt(0), n = "(".charCodeAt(0), u = ")".charCodeAt(0), m2 = "{".charCodeAt(0), v = "}".charCodeAt(0), y = ";".charCodeAt(0), w2 = "*".charCodeAt(0), d4 = ":".charCodeAt(0), _ = "@".charCodeAt(0), O2 = /[ \n\t\r\f{}()'"\\;/[\]#]/g, S2 = /[ \n\t\r\f(){}:;@!'"\\\][#]|\/(?=\*)/g, M2 = /.[\\/("'\n]/, R = /[a-f0-9]/i;
  function $(J2, X3) {
    X3 === void 0 && (X3 = {});
    var F = J2.css.valueOf(), K = X3.ignoreErrors, W2, T2, D2, j, N, b2, Q, G, L, B, P, Z3, V, q, x2 = F.length, k2 = -1, z = 1, A2 = 0, E = [], H3 = [];
    function U() {
      return A2;
    }
    function re2(te2) {
      throw J2.error("Unclosed " + te2, z, A2 - k2);
    }
    function ne() {
      return H3.length === 0 && A2 >= x2;
    }
    function ce(te2) {
      if (H3.length)
        return H3.pop();
      if (!(A2 >= x2)) {
        var ie = te2 ? te2.ignoreUnclosed : false;
        switch (W2 = F.charCodeAt(A2), (W2 === f || W2 === g2 || W2 === t && F.charCodeAt(A2 + 1) !== f) && (k2 = A2, z += 1), W2) {
          case f:
          case p:
          case c:
          case t:
          case g2:
            T2 = A2;
            do
              T2 += 1, W2 = F.charCodeAt(T2), W2 === f && (k2 = T2, z += 1);
            while (W2 === p || W2 === f || W2 === c || W2 === t || W2 === g2);
            q = ["space", F.slice(A2, T2)], A2 = T2 - 1;
            break;
          case e:
          case a3:
          case m2:
          case v:
          case d4:
          case y:
          case u:
            var ae2 = String.fromCharCode(W2);
            q = [ae2, ae2, z, A2 - k2];
            break;
          case n:
            if (Z3 = E.length ? E.pop()[1] : "", V = F.charCodeAt(A2 + 1), Z3 === "url" && V !== s2 && V !== l && V !== p && V !== f && V !== c && V !== g2 && V !== t) {
              T2 = A2;
              do {
                if (B = false, T2 = F.indexOf(")", T2 + 1), T2 === -1)
                  if (K || ie) {
                    T2 = A2;
                    break;
                  } else
                    re2("bracket");
                for (P = T2; F.charCodeAt(P - 1) === o; )
                  P -= 1, B = !B;
              } while (B);
              q = ["brackets", F.slice(A2, T2 + 1), z, A2 - k2, z, T2 - k2], A2 = T2;
            } else
              T2 = F.indexOf(")", A2 + 1), b2 = F.slice(A2, T2 + 1), T2 === -1 || M2.test(b2) ? q = ["(", "(", z, A2 - k2] : (q = ["brackets", b2, z, A2 - k2, z, T2 - k2], A2 = T2);
            break;
          case s2:
          case l:
            D2 = W2 === s2 ? "'" : '"', T2 = A2;
            do {
              if (B = false, T2 = F.indexOf(D2, T2 + 1), T2 === -1)
                if (K || ie) {
                  T2 = A2 + 1;
                  break;
                } else
                  re2("string");
              for (P = T2; F.charCodeAt(P - 1) === o; )
                P -= 1, B = !B;
            } while (B);
            b2 = F.slice(A2, T2 + 1), j = b2.split(`
`), N = j.length - 1, N > 0 ? (G = z + N, L = T2 - j[N].length) : (G = z, L = k2), q = ["string", F.slice(A2, T2 + 1), z, A2 - k2, G, T2 - L], k2 = L, z = G, A2 = T2;
            break;
          case _:
            O2.lastIndex = A2 + 1, O2.test(F), O2.lastIndex === 0 ? T2 = F.length - 1 : T2 = O2.lastIndex - 2, q = ["at-word", F.slice(A2, T2 + 1), z, A2 - k2, z, T2 - k2], A2 = T2;
            break;
          case o:
            for (T2 = A2, Q = true; F.charCodeAt(T2 + 1) === o; )
              T2 += 1, Q = !Q;
            if (W2 = F.charCodeAt(T2 + 1), Q && W2 !== h2 && W2 !== p && W2 !== f && W2 !== c && W2 !== t && W2 !== g2 && (T2 += 1, R.test(F.charAt(T2)))) {
              for (; R.test(F.charAt(T2 + 1)); )
                T2 += 1;
              F.charCodeAt(T2 + 1) === p && (T2 += 1);
            }
            q = ["word", F.slice(A2, T2 + 1), z, A2 - k2, z, T2 - k2], A2 = T2;
            break;
          default:
            W2 === h2 && F.charCodeAt(A2 + 1) === w2 ? (T2 = F.indexOf("*/", A2 + 2) + 1, T2 === 0 && (K || ie ? T2 = F.length : re2("comment")), b2 = F.slice(A2, T2 + 1), j = b2.split(`
`), N = j.length - 1, N > 0 ? (G = z + N, L = T2 - j[N].length) : (G = z, L = k2), q = ["comment", b2, z, A2 - k2, G, T2 - L], k2 = L, z = G, A2 = T2) : (S2.lastIndex = A2 + 1, S2.test(F), S2.lastIndex === 0 ? T2 = F.length - 1 : T2 = S2.lastIndex - 2, q = ["word", F.slice(A2, T2 + 1), z, A2 - k2, z, T2 - k2], E.push(q), A2 = T2);
            break;
        }
        return A2++, q;
      }
    }
    function fe2(te2) {
      H3.push(te2);
    }
    return { back: fe2, nextToken: ce, endOfFile: ne, position: U };
  }
  i2.exports = r.default;
} }), Vo = C({ "node_modules/postcss/lib/parse.js"(r, i2) {
  I(), r.__esModule = true, r.default = void 0;
  var s2 = o(Pt()), l = o(mr());
  function o(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function h2(p, g2) {
    var c = new l.default(p, g2), t = new s2.default(c);
    try {
      t.parse();
    } catch (e) {
      throw e;
    }
    return t.root;
  }
  var f = h2;
  r.default = f, i2.exports = r.default;
} }), af = C({ "node_modules/postcss/lib/list.js"(r, i2) {
  I(), r.__esModule = true, r.default = void 0;
  var s2 = { split: function(h2, f, p) {
    for (var g2 = [], c = "", t = false, e = 0, a3 = false, n = false, u = 0; u < h2.length; u++) {
      var m2 = h2[u];
      a3 ? n ? n = false : m2 === "\\" ? n = true : m2 === a3 && (a3 = false) : m2 === '"' || m2 === "'" ? a3 = m2 : m2 === "(" ? e += 1 : m2 === ")" ? e > 0 && (e -= 1) : e === 0 && f.indexOf(m2) !== -1 && (t = true), t ? (c !== "" && g2.push(c.trim()), c = "", t = false) : c += m2;
    }
    return (p || c !== "") && g2.push(c.trim()), g2;
  }, space: function(h2) {
    var f = [" ", `
`, "	"];
    return s2.split(h2, f);
  }, comma: function(h2) {
    return s2.split(h2, [","], true);
  } }, l = s2;
  r.default = l, i2.exports = r.default;
} }), Go = C({ "node_modules/postcss/lib/rule.js"(r, i2) {
  I(), r.__esModule = true, r.default = void 0;
  var s2 = o(wr()), l = o(af());
  function o(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function h2(t, e) {
    for (var a3 = 0; a3 < e.length; a3++) {
      var n = e[a3];
      n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
    }
  }
  function f(t, e, a3) {
    return e && h2(t.prototype, e), a3 && h2(t, a3), t;
  }
  function p(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
  }
  var g2 = function(t) {
    p(e, t);
    function e(a3) {
      var n;
      return n = t.call(this, a3) || this, n.type = "rule", n.nodes || (n.nodes = []), n;
    }
    return f(e, [{ key: "selectors", get: function() {
      return l.default.comma(this.selector);
    }, set: function(n) {
      var u = this.selector ? this.selector.match(/,\s*/) : null, m2 = u ? u[0] : "," + this.raw("between", "beforeOpen");
      this.selector = n.join(m2);
    } }]), e;
  }(s2.default), c = g2;
  r.default = c, i2.exports = r.default;
} }), wr = C({ "node_modules/postcss/lib/container.js"(r, i2) {
  I(), r.__esModule = true, r.default = void 0;
  var s2 = h2($o()), l = h2(yr()), o = h2(qt());
  function h2(m2) {
    return m2 && m2.__esModule ? m2 : { default: m2 };
  }
  function f(m2, v) {
    var y;
    if (typeof Symbol > "u" || m2[Symbol.iterator] == null) {
      if (Array.isArray(m2) || (y = p(m2)) || v && m2 && typeof m2.length == "number") {
        y && (m2 = y);
        var w2 = 0;
        return function() {
          return w2 >= m2.length ? { done: true } : { done: false, value: m2[w2++] };
        };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    return y = m2[Symbol.iterator](), y.next.bind(y);
  }
  function p(m2, v) {
    if (!!m2) {
      if (typeof m2 == "string")
        return g2(m2, v);
      var y = Object.prototype.toString.call(m2).slice(8, -1);
      if (y === "Object" && m2.constructor && (y = m2.constructor.name), y === "Map" || y === "Set")
        return Array.from(m2);
      if (y === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(y))
        return g2(m2, v);
    }
  }
  function g2(m2, v) {
    (v == null || v > m2.length) && (v = m2.length);
    for (var y = 0, w2 = new Array(v); y < v; y++)
      w2[y] = m2[y];
    return w2;
  }
  function c(m2, v) {
    for (var y = 0; y < v.length; y++) {
      var w2 = v[y];
      w2.enumerable = w2.enumerable || false, w2.configurable = true, "value" in w2 && (w2.writable = true), Object.defineProperty(m2, w2.key, w2);
    }
  }
  function t(m2, v, y) {
    return v && c(m2.prototype, v), y && c(m2, y), m2;
  }
  function e(m2, v) {
    m2.prototype = Object.create(v.prototype), m2.prototype.constructor = m2, m2.__proto__ = v;
  }
  function a3(m2) {
    return m2.map(function(v) {
      return v.nodes && (v.nodes = a3(v.nodes)), delete v.source, v;
    });
  }
  var n = function(m2) {
    e(v, m2);
    function v() {
      return m2.apply(this, arguments) || this;
    }
    var y = v.prototype;
    return y.push = function(d4) {
      return d4.parent = this, this.nodes.push(d4), this;
    }, y.each = function(d4) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      var _ = this.lastEach;
      if (this.indexes[_] = 0, !!this.nodes) {
        for (var O2, S2; this.indexes[_] < this.nodes.length && (O2 = this.indexes[_], S2 = d4(this.nodes[O2], O2), S2 !== false); )
          this.indexes[_] += 1;
        return delete this.indexes[_], S2;
      }
    }, y.walk = function(d4) {
      return this.each(function(_, O2) {
        var S2;
        try {
          S2 = d4(_, O2);
        } catch (R) {
          if (R.postcssNode = _, R.stack && _.source && /\n\s{4}at /.test(R.stack)) {
            var M2 = _.source;
            R.stack = R.stack.replace(/\n\s{4}at /, "$&" + M2.input.from + ":" + M2.start.line + ":" + M2.start.column + "$&");
          }
          throw R;
        }
        return S2 !== false && _.walk && (S2 = _.walk(d4)), S2;
      });
    }, y.walkDecls = function(d4, _) {
      return _ ? d4 instanceof RegExp ? this.walk(function(O2, S2) {
        if (O2.type === "decl" && d4.test(O2.prop))
          return _(O2, S2);
      }) : this.walk(function(O2, S2) {
        if (O2.type === "decl" && O2.prop === d4)
          return _(O2, S2);
      }) : (_ = d4, this.walk(function(O2, S2) {
        if (O2.type === "decl")
          return _(O2, S2);
      }));
    }, y.walkRules = function(d4, _) {
      return _ ? d4 instanceof RegExp ? this.walk(function(O2, S2) {
        if (O2.type === "rule" && d4.test(O2.selector))
          return _(O2, S2);
      }) : this.walk(function(O2, S2) {
        if (O2.type === "rule" && O2.selector === d4)
          return _(O2, S2);
      }) : (_ = d4, this.walk(function(O2, S2) {
        if (O2.type === "rule")
          return _(O2, S2);
      }));
    }, y.walkAtRules = function(d4, _) {
      return _ ? d4 instanceof RegExp ? this.walk(function(O2, S2) {
        if (O2.type === "atrule" && d4.test(O2.name))
          return _(O2, S2);
      }) : this.walk(function(O2, S2) {
        if (O2.type === "atrule" && O2.name === d4)
          return _(O2, S2);
      }) : (_ = d4, this.walk(function(O2, S2) {
        if (O2.type === "atrule")
          return _(O2, S2);
      }));
    }, y.walkComments = function(d4) {
      return this.walk(function(_, O2) {
        if (_.type === "comment")
          return d4(_, O2);
      });
    }, y.append = function() {
      for (var d4 = arguments.length, _ = new Array(d4), O2 = 0; O2 < d4; O2++)
        _[O2] = arguments[O2];
      for (var S2 = 0, M2 = _; S2 < M2.length; S2++)
        for (var R = M2[S2], $ = this.normalize(R, this.last), J2 = f($), X3; !(X3 = J2()).done; ) {
          var F = X3.value;
          this.nodes.push(F);
        }
      return this;
    }, y.prepend = function() {
      for (var d4 = arguments.length, _ = new Array(d4), O2 = 0; O2 < d4; O2++)
        _[O2] = arguments[O2];
      _ = _.reverse();
      for (var S2 = f(_), M2; !(M2 = S2()).done; ) {
        for (var R = M2.value, $ = this.normalize(R, this.first, "prepend").reverse(), J2 = f($), X3; !(X3 = J2()).done; ) {
          var F = X3.value;
          this.nodes.unshift(F);
        }
        for (var K in this.indexes)
          this.indexes[K] = this.indexes[K] + $.length;
      }
      return this;
    }, y.cleanRaws = function(d4) {
      if (m2.prototype.cleanRaws.call(this, d4), this.nodes)
        for (var _ = f(this.nodes), O2; !(O2 = _()).done; ) {
          var S2 = O2.value;
          S2.cleanRaws(d4);
        }
    }, y.insertBefore = function(d4, _) {
      d4 = this.index(d4);
      for (var O2 = d4 === 0 ? "prepend" : false, S2 = this.normalize(_, this.nodes[d4], O2).reverse(), M2 = f(S2), R; !(R = M2()).done; ) {
        var $ = R.value;
        this.nodes.splice(d4, 0, $);
      }
      var J2;
      for (var X3 in this.indexes)
        J2 = this.indexes[X3], d4 <= J2 && (this.indexes[X3] = J2 + S2.length);
      return this;
    }, y.insertAfter = function(d4, _) {
      d4 = this.index(d4);
      for (var O2 = this.normalize(_, this.nodes[d4]).reverse(), S2 = f(O2), M2; !(M2 = S2()).done; ) {
        var R = M2.value;
        this.nodes.splice(d4 + 1, 0, R);
      }
      var $;
      for (var J2 in this.indexes)
        $ = this.indexes[J2], d4 < $ && (this.indexes[J2] = $ + O2.length);
      return this;
    }, y.removeChild = function(d4) {
      d4 = this.index(d4), this.nodes[d4].parent = void 0, this.nodes.splice(d4, 1);
      var _;
      for (var O2 in this.indexes)
        _ = this.indexes[O2], _ >= d4 && (this.indexes[O2] = _ - 1);
      return this;
    }, y.removeAll = function() {
      for (var d4 = f(this.nodes), _; !(_ = d4()).done; ) {
        var O2 = _.value;
        O2.parent = void 0;
      }
      return this.nodes = [], this;
    }, y.replaceValues = function(d4, _, O2) {
      return O2 || (O2 = _, _ = {}), this.walkDecls(function(S2) {
        _.props && _.props.indexOf(S2.prop) === -1 || _.fast && S2.value.indexOf(_.fast) === -1 || (S2.value = S2.value.replace(d4, O2));
      }), this;
    }, y.every = function(d4) {
      return this.nodes.every(d4);
    }, y.some = function(d4) {
      return this.nodes.some(d4);
    }, y.index = function(d4) {
      return typeof d4 == "number" ? d4 : this.nodes.indexOf(d4);
    }, y.normalize = function(d4, _) {
      var O2 = this;
      if (typeof d4 == "string") {
        var S2 = Vo();
        d4 = a3(S2(d4).nodes);
      } else if (Array.isArray(d4)) {
        d4 = d4.slice(0);
        for (var M2 = f(d4), R; !(R = M2()).done; ) {
          var $ = R.value;
          $.parent && $.parent.removeChild($, "ignore");
        }
      } else if (d4.type === "root") {
        d4 = d4.nodes.slice(0);
        for (var J2 = f(d4), X3; !(X3 = J2()).done; ) {
          var F = X3.value;
          F.parent && F.parent.removeChild(F, "ignore");
        }
      } else if (d4.type)
        d4 = [d4];
      else if (d4.prop) {
        if (typeof d4.value > "u")
          throw new Error("Value field is missed in node creation");
        typeof d4.value != "string" && (d4.value = String(d4.value)), d4 = [new s2.default(d4)];
      } else if (d4.selector) {
        var K = Go();
        d4 = [new K(d4)];
      } else if (d4.name) {
        var W2 = Ho();
        d4 = [new W2(d4)];
      } else if (d4.text)
        d4 = [new l.default(d4)];
      else
        throw new Error("Unknown node type in node creation");
      var T2 = d4.map(function(D2) {
        return D2.parent && D2.parent.removeChild(D2), typeof D2.raws.before > "u" && _ && typeof _.raws.before < "u" && (D2.raws.before = _.raws.before.replace(/[^\s]/g, "")), D2.parent = O2, D2;
      });
      return T2;
    }, t(v, [{ key: "first", get: function() {
      if (!!this.nodes)
        return this.nodes[0];
    } }, { key: "last", get: function() {
      if (!!this.nodes)
        return this.nodes[this.nodes.length - 1];
    } }]), v;
  }(o.default), u = n;
  r.default = u, i2.exports = r.default;
} }), Ho = C({ "node_modules/postcss/lib/at-rule.js"(r, i2) {
  I(), r.__esModule = true, r.default = void 0;
  var s2 = l(wr());
  function l(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function o(p, g2) {
    p.prototype = Object.create(g2.prototype), p.prototype.constructor = p, p.__proto__ = g2;
  }
  var h2 = function(p) {
    o(g2, p);
    function g2(t) {
      var e;
      return e = p.call(this, t) || this, e.type = "atrule", e;
    }
    var c = g2.prototype;
    return c.append = function() {
      var e;
      this.nodes || (this.nodes = []);
      for (var a3 = arguments.length, n = new Array(a3), u = 0; u < a3; u++)
        n[u] = arguments[u];
      return (e = p.prototype.append).call.apply(e, [this].concat(n));
    }, c.prepend = function() {
      var e;
      this.nodes || (this.nodes = []);
      for (var a3 = arguments.length, n = new Array(a3), u = 0; u < a3; u++)
        n[u] = arguments[u];
      return (e = p.prototype.prepend).call.apply(e, [this].concat(n));
    }, g2;
  }(s2.default), f = h2;
  r.default = f, i2.exports = r.default;
} }), uf = C({ "node_modules/postcss/lib/map-generator.js"(r, i2) {
  I(), i2.exports = class {
    generate() {
    }
  };
} }), cf = C({ "node_modules/postcss/lib/warn-once.js"(r, i2) {
  I(), r.__esModule = true, r.default = l;
  var s2 = {};
  function l(o) {
    s2[o] || (s2[o] = true, typeof console < "u" && console.warn && console.warn(o));
  }
  i2.exports = r.default;
} }), lf = C({ "node_modules/postcss/lib/warning.js"(r, i2) {
  I(), r.__esModule = true, r.default = void 0;
  var s2 = function() {
    function o(f, p) {
      if (p === void 0 && (p = {}), this.type = "warning", this.text = f, p.node && p.node.source) {
        var g2 = p.node.positionBy(p);
        this.line = g2.line, this.column = g2.column;
      }
      for (var c in p)
        this[c] = p[c];
    }
    var h2 = o.prototype;
    return h2.toString = function() {
      return this.node ? this.node.error(this.text, { plugin: this.plugin, index: this.index, word: this.word }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
    }, o;
  }(), l = s2;
  r.default = l, i2.exports = r.default;
} }), ff = C({ "node_modules/postcss/lib/result.js"(r, i2) {
  I(), r.__esModule = true, r.default = void 0;
  var s2 = l(lf());
  function l(g2) {
    return g2 && g2.__esModule ? g2 : { default: g2 };
  }
  function o(g2, c) {
    for (var t = 0; t < c.length; t++) {
      var e = c[t];
      e.enumerable = e.enumerable || false, e.configurable = true, "value" in e && (e.writable = true), Object.defineProperty(g2, e.key, e);
    }
  }
  function h2(g2, c, t) {
    return c && o(g2.prototype, c), t && o(g2, t), g2;
  }
  var f = function() {
    function g2(t, e, a3) {
      this.processor = t, this.messages = [], this.root = e, this.opts = a3, this.css = void 0, this.map = void 0;
    }
    var c = g2.prototype;
    return c.toString = function() {
      return this.css;
    }, c.warn = function(e, a3) {
      a3 === void 0 && (a3 = {}), a3.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (a3.plugin = this.lastPlugin.postcssPlugin);
      var n = new s2.default(e, a3);
      return this.messages.push(n), n;
    }, c.warnings = function() {
      return this.messages.filter(function(e) {
        return e.type === "warning";
      });
    }, h2(g2, [{ key: "content", get: function() {
      return this.css;
    } }]), g2;
  }(), p = f;
  r.default = p, i2.exports = r.default;
} }), Jo = C({ "node_modules/postcss/lib/lazy-result.js"(r, i2) {
  I(), r.__esModule = true, r.default = void 0;
  var s2 = p(uf()), l = p(Wo());
  p(cf());
  var h2 = p(ff()), f = p(Vo());
  function p(v) {
    return v && v.__esModule ? v : { default: v };
  }
  function g2(v, y) {
    var w2;
    if (typeof Symbol > "u" || v[Symbol.iterator] == null) {
      if (Array.isArray(v) || (w2 = c(v)) || y && v && typeof v.length == "number") {
        w2 && (v = w2);
        var d4 = 0;
        return function() {
          return d4 >= v.length ? { done: true } : { done: false, value: v[d4++] };
        };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    return w2 = v[Symbol.iterator](), w2.next.bind(w2);
  }
  function c(v, y) {
    if (!!v) {
      if (typeof v == "string")
        return t(v, y);
      var w2 = Object.prototype.toString.call(v).slice(8, -1);
      if (w2 === "Object" && v.constructor && (w2 = v.constructor.name), w2 === "Map" || w2 === "Set")
        return Array.from(v);
      if (w2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(w2))
        return t(v, y);
    }
  }
  function t(v, y) {
    (y == null || y > v.length) && (y = v.length);
    for (var w2 = 0, d4 = new Array(y); w2 < y; w2++)
      d4[w2] = v[w2];
    return d4;
  }
  function e(v, y) {
    for (var w2 = 0; w2 < y.length; w2++) {
      var d4 = y[w2];
      d4.enumerable = d4.enumerable || false, d4.configurable = true, "value" in d4 && (d4.writable = true), Object.defineProperty(v, d4.key, d4);
    }
  }
  function a3(v, y, w2) {
    return y && e(v.prototype, y), w2 && e(v, w2), v;
  }
  function n(v) {
    return typeof v == "object" && typeof v.then == "function";
  }
  var u = function() {
    function v(w2, d4, _) {
      this.stringified = false, this.processed = false;
      var O2;
      if (typeof d4 == "object" && d4 !== null && d4.type === "root")
        O2 = d4;
      else if (d4 instanceof v || d4 instanceof h2.default)
        O2 = d4.root, d4.map && (typeof _.map > "u" && (_.map = {}), _.map.inline || (_.map.inline = false), _.map.prev = d4.map);
      else {
        var S2 = f.default;
        _.syntax && (S2 = _.syntax.parse), _.parser && (S2 = _.parser), S2.parse && (S2 = S2.parse);
        try {
          O2 = S2(d4, _);
        } catch (M2) {
          this.error = M2;
        }
      }
      this.result = new h2.default(w2, O2, _);
    }
    var y = v.prototype;
    return y.warnings = function() {
      return this.sync().warnings();
    }, y.toString = function() {
      return this.css;
    }, y.then = function(d4, _) {
      return this.async().then(d4, _);
    }, y.catch = function(d4) {
      return this.async().catch(d4);
    }, y.finally = function(d4) {
      return this.async().then(d4, d4);
    }, y.handleError = function(d4, _) {
      try {
        if (this.error = d4, d4.name === "CssSyntaxError" && !d4.plugin)
          d4.plugin = _.postcssPlugin, d4.setMessage();
        else if (_.postcssVersion && false)
          var O2, S2, M2, R, $;
      } catch (J2) {
        console && console.error && console.error(J2);
      }
    }, y.asyncTick = function(d4, _) {
      var O2 = this;
      if (this.plugin >= this.processor.plugins.length)
        return this.processed = true, d4();
      try {
        var S2 = this.processor.plugins[this.plugin], M2 = this.run(S2);
        this.plugin += 1, n(M2) ? M2.then(function() {
          O2.asyncTick(d4, _);
        }).catch(function(R) {
          O2.handleError(R, S2), O2.processed = true, _(R);
        }) : this.asyncTick(d4, _);
      } catch (R) {
        this.processed = true, _(R);
      }
    }, y.async = function() {
      var d4 = this;
      return this.processed ? new Promise(function(_, O2) {
        d4.error ? O2(d4.error) : _(d4.stringify());
      }) : this.processing ? this.processing : (this.processing = new Promise(function(_, O2) {
        if (d4.error)
          return O2(d4.error);
        d4.plugin = 0, d4.asyncTick(_, O2);
      }).then(function() {
        return d4.processed = true, d4.stringify();
      }), this.processing);
    }, y.sync = function() {
      if (this.processed)
        return this.result;
      if (this.processed = true, this.processing)
        throw new Error("Use process(css).then(cb) to work with async plugins");
      if (this.error)
        throw this.error;
      for (var d4 = g2(this.result.processor.plugins), _; !(_ = d4()).done; ) {
        var O2 = _.value, S2 = this.run(O2);
        if (n(S2))
          throw new Error("Use process(css).then(cb) to work with async plugins");
      }
      return this.result;
    }, y.run = function(d4) {
      this.result.lastPlugin = d4;
      try {
        return d4(this.result.root, this.result);
      } catch (_) {
        throw this.handleError(_, d4), _;
      }
    }, y.stringify = function() {
      if (this.stringified)
        return this.result;
      this.stringified = true, this.sync();
      var d4 = this.result.opts, _ = l.default;
      d4.syntax && (_ = d4.syntax.stringify), d4.stringifier && (_ = d4.stringifier), _.stringify && (_ = _.stringify);
      var O2 = new s2.default(_, this.result.root, this.result.opts), S2 = O2.generate();
      return this.result.css = S2[0], this.result.map = S2[1], this.result;
    }, a3(v, [{ key: "processor", get: function() {
      return this.result.processor;
    } }, { key: "opts", get: function() {
      return this.result.opts;
    } }, { key: "css", get: function() {
      return this.stringify().css;
    } }, { key: "content", get: function() {
      return this.stringify().content;
    } }, { key: "map", get: function() {
      return this.stringify().map;
    } }, { key: "root", get: function() {
      return this.sync().root;
    } }, { key: "messages", get: function() {
      return this.sync().messages;
    } }]), v;
  }(), m2 = u;
  r.default = m2, i2.exports = r.default;
} }), pf = C({ "node_modules/postcss/lib/processor.js"(r, i2) {
  I(), r.__esModule = true, r.default = void 0;
  var s2 = l(Jo());
  function l(c) {
    return c && c.__esModule ? c : { default: c };
  }
  function o(c, t) {
    var e;
    if (typeof Symbol > "u" || c[Symbol.iterator] == null) {
      if (Array.isArray(c) || (e = h2(c)) || t && c && typeof c.length == "number") {
        e && (c = e);
        var a3 = 0;
        return function() {
          return a3 >= c.length ? { done: true } : { done: false, value: c[a3++] };
        };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    return e = c[Symbol.iterator](), e.next.bind(e);
  }
  function h2(c, t) {
    if (!!c) {
      if (typeof c == "string")
        return f(c, t);
      var e = Object.prototype.toString.call(c).slice(8, -1);
      if (e === "Object" && c.constructor && (e = c.constructor.name), e === "Map" || e === "Set")
        return Array.from(c);
      if (e === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e))
        return f(c, t);
    }
  }
  function f(c, t) {
    (t == null || t > c.length) && (t = c.length);
    for (var e = 0, a3 = new Array(t); e < t; e++)
      a3[e] = c[e];
    return a3;
  }
  var p = function() {
    function c(e) {
      e === void 0 && (e = []), this.version = "7.0.39", this.plugins = this.normalize(e);
    }
    var t = c.prototype;
    return t.use = function(a3) {
      return this.plugins = this.plugins.concat(this.normalize([a3])), this;
    }, t.process = function(e) {
      function a3(n) {
        return e.apply(this, arguments);
      }
      return a3.toString = function() {
        return e.toString();
      }, a3;
    }(function(e, a3) {
      return a3 === void 0 && (a3 = {}), this.plugins.length === 0 && (a3.parser, a3.stringifier), new s2.default(this, e, a3);
    }), t.normalize = function(a3) {
      for (var n = [], u = o(a3), m2; !(m2 = u()).done; ) {
        var v = m2.value;
        if (v.postcss === true) {
          var y = v();
          throw new Error("PostCSS plugin " + y.postcssPlugin + ` requires PostCSS 8.
Migration guide for end-users:
https://github.com/postcss/postcss/wiki/PostCSS-8-for-end-users`);
        }
        if (v.postcss && (v = v.postcss), typeof v == "object" && Array.isArray(v.plugins))
          n = n.concat(v.plugins);
        else if (typeof v == "function")
          n.push(v);
        else if (!(typeof v == "object" && (v.parse || v.stringify)))
          throw typeof v == "object" && v.postcssPlugin ? new Error("PostCSS plugin " + v.postcssPlugin + ` requires PostCSS 8.
Migration guide for end-users:
https://github.com/postcss/postcss/wiki/PostCSS-8-for-end-users`) : new Error(v + " is not a PostCSS plugin");
      }
      return n;
    }, c;
  }(), g2 = p;
  r.default = g2, i2.exports = r.default;
} }), hf = C({ "node_modules/postcss/lib/root.js"(r, i2) {
  I(), r.__esModule = true, r.default = void 0;
  var s2 = l(wr());
  function l(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function o(t, e) {
    var a3;
    if (typeof Symbol > "u" || t[Symbol.iterator] == null) {
      if (Array.isArray(t) || (a3 = h2(t)) || e && t && typeof t.length == "number") {
        a3 && (t = a3);
        var n = 0;
        return function() {
          return n >= t.length ? { done: true } : { done: false, value: t[n++] };
        };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    return a3 = t[Symbol.iterator](), a3.next.bind(a3);
  }
  function h2(t, e) {
    if (!!t) {
      if (typeof t == "string")
        return f(t, e);
      var a3 = Object.prototype.toString.call(t).slice(8, -1);
      if (a3 === "Object" && t.constructor && (a3 = t.constructor.name), a3 === "Map" || a3 === "Set")
        return Array.from(t);
      if (a3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a3))
        return f(t, e);
    }
  }
  function f(t, e) {
    (e == null || e > t.length) && (e = t.length);
    for (var a3 = 0, n = new Array(e); a3 < e; a3++)
      n[a3] = t[a3];
    return n;
  }
  function p(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
  }
  var g2 = function(t) {
    p(e, t);
    function e(n) {
      var u;
      return u = t.call(this, n) || this, u.type = "root", u.nodes || (u.nodes = []), u;
    }
    var a3 = e.prototype;
    return a3.removeChild = function(u, m2) {
      var v = this.index(u);
      return !m2 && v === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[v].raws.before), t.prototype.removeChild.call(this, u);
    }, a3.normalize = function(u, m2, v) {
      var y = t.prototype.normalize.call(this, u);
      if (m2) {
        if (v === "prepend")
          this.nodes.length > 1 ? m2.raws.before = this.nodes[1].raws.before : delete m2.raws.before;
        else if (this.first !== m2)
          for (var w2 = o(y), d4; !(d4 = w2()).done; ) {
            var _ = d4.value;
            _.raws.before = m2.raws.before;
          }
      }
      return y;
    }, a3.toResult = function(u) {
      u === void 0 && (u = {});
      var m2 = Jo(), v = pf(), y = new m2(new v(), this, u);
      return y.stringify();
    }, e;
  }(s2.default), c = g2;
  r.default = c, i2.exports = r.default;
} }), Pt = C({ "node_modules/postcss/lib/parser.js"(r, i2) {
  I(), r.__esModule = true, r.default = void 0;
  var s2 = g2($o()), l = g2(At()), o = g2(yr()), h2 = g2(Ho()), f = g2(hf()), p = g2(Go());
  function g2(t) {
    return t && t.__esModule ? t : { default: t };
  }
  var c = function() {
    function t(a3) {
      this.input = a3, this.root = new f.default(), this.current = this.root, this.spaces = "", this.semicolon = false, this.createTokenizer(), this.root.source = { input: a3, start: { line: 1, column: 1 } };
    }
    var e = t.prototype;
    return e.createTokenizer = function() {
      this.tokenizer = (0, l.default)(this.input);
    }, e.parse = function() {
      for (var n; !this.tokenizer.endOfFile(); )
        switch (n = this.tokenizer.nextToken(), n[0]) {
          case "space":
            this.spaces += n[1];
            break;
          case ";":
            this.freeSemicolon(n);
            break;
          case "}":
            this.end(n);
            break;
          case "comment":
            this.comment(n);
            break;
          case "at-word":
            this.atrule(n);
            break;
          case "{":
            this.emptyRule(n);
            break;
          default:
            this.other(n);
            break;
        }
      this.endFile();
    }, e.comment = function(n) {
      var u = new o.default();
      this.init(u, n[2], n[3]), u.source.end = { line: n[4], column: n[5] };
      var m2 = n[1].slice(2, -2);
      if (/^\s*$/.test(m2))
        u.text = "", u.raws.left = m2, u.raws.right = "";
      else {
        var v = m2.match(/^(\s*)([^]*[^\s])(\s*)$/);
        u.text = v[2], u.raws.left = v[1], u.raws.right = v[3];
      }
    }, e.emptyRule = function(n) {
      var u = new p.default();
      this.init(u, n[2], n[3]), u.selector = "", u.raws.between = "", this.current = u;
    }, e.other = function(n) {
      for (var u = false, m2 = null, v = false, y = null, w2 = [], d4 = [], _ = n; _; ) {
        if (m2 = _[0], d4.push(_), m2 === "(" || m2 === "[")
          y || (y = _), w2.push(m2 === "(" ? ")" : "]");
        else if (w2.length === 0)
          if (m2 === ";")
            if (v) {
              this.decl(d4);
              return;
            } else
              break;
          else if (m2 === "{") {
            this.rule(d4);
            return;
          } else if (m2 === "}") {
            this.tokenizer.back(d4.pop()), u = true;
            break;
          } else
            m2 === ":" && (v = true);
        else
          m2 === w2[w2.length - 1] && (w2.pop(), w2.length === 0 && (y = null));
        _ = this.tokenizer.nextToken();
      }
      if (this.tokenizer.endOfFile() && (u = true), w2.length > 0 && this.unclosedBracket(y), u && v) {
        for (; d4.length && (_ = d4[d4.length - 1][0], !(_ !== "space" && _ !== "comment")); )
          this.tokenizer.back(d4.pop());
        this.decl(d4);
      } else
        this.unknownWord(d4);
    }, e.rule = function(n) {
      n.pop();
      var u = new p.default();
      this.init(u, n[0][2], n[0][3]), u.raws.between = this.spacesAndCommentsFromEnd(n), this.raw(u, "selector", n), this.current = u;
    }, e.decl = function(n) {
      var u = new s2.default();
      this.init(u);
      var m2 = n[n.length - 1];
      for (m2[0] === ";" && (this.semicolon = true, n.pop()), m2[4] ? u.source.end = { line: m2[4], column: m2[5] } : u.source.end = { line: m2[2], column: m2[3] }; n[0][0] !== "word"; )
        n.length === 1 && this.unknownWord(n), u.raws.before += n.shift()[1];
      for (u.source.start = { line: n[0][2], column: n[0][3] }, u.prop = ""; n.length; ) {
        var v = n[0][0];
        if (v === ":" || v === "space" || v === "comment")
          break;
        u.prop += n.shift()[1];
      }
      u.raws.between = "";
      for (var y; n.length; )
        if (y = n.shift(), y[0] === ":") {
          u.raws.between += y[1];
          break;
        } else
          y[0] === "word" && /\w/.test(y[1]) && this.unknownWord([y]), u.raws.between += y[1];
      (u.prop[0] === "_" || u.prop[0] === "*") && (u.raws.before += u.prop[0], u.prop = u.prop.slice(1)), u.raws.between += this.spacesAndCommentsFromStart(n), this.precheckMissedSemicolon(n);
      for (var w2 = n.length - 1; w2 > 0; w2--) {
        if (y = n[w2], y[1].toLowerCase() === "!important") {
          u.important = true;
          var d4 = this.stringFrom(n, w2);
          d4 = this.spacesFromEnd(n) + d4, d4 !== " !important" && (u.raws.important = d4);
          break;
        } else if (y[1].toLowerCase() === "important") {
          for (var _ = n.slice(0), O2 = "", S2 = w2; S2 > 0; S2--) {
            var M2 = _[S2][0];
            if (O2.trim().indexOf("!") === 0 && M2 !== "space")
              break;
            O2 = _.pop()[1] + O2;
          }
          O2.trim().indexOf("!") === 0 && (u.important = true, u.raws.important = O2, n = _);
        }
        if (y[0] !== "space" && y[0] !== "comment")
          break;
      }
      this.raw(u, "value", n), u.value.indexOf(":") !== -1 && this.checkMissedSemicolon(n);
    }, e.atrule = function(n) {
      var u = new h2.default();
      u.name = n[1].slice(1), u.name === "" && this.unnamedAtrule(u, n), this.init(u, n[2], n[3]);
      for (var m2, v, y = false, w2 = false, d4 = []; !this.tokenizer.endOfFile(); ) {
        if (n = this.tokenizer.nextToken(), n[0] === ";") {
          u.source.end = { line: n[2], column: n[3] }, this.semicolon = true;
          break;
        } else if (n[0] === "{") {
          w2 = true;
          break;
        } else if (n[0] === "}") {
          if (d4.length > 0) {
            for (v = d4.length - 1, m2 = d4[v]; m2 && m2[0] === "space"; )
              m2 = d4[--v];
            m2 && (u.source.end = { line: m2[4], column: m2[5] });
          }
          this.end(n);
          break;
        } else
          d4.push(n);
        if (this.tokenizer.endOfFile()) {
          y = true;
          break;
        }
      }
      u.raws.between = this.spacesAndCommentsFromEnd(d4), d4.length ? (u.raws.afterName = this.spacesAndCommentsFromStart(d4), this.raw(u, "params", d4), y && (n = d4[d4.length - 1], u.source.end = { line: n[4], column: n[5] }, this.spaces = u.raws.between, u.raws.between = "")) : (u.raws.afterName = "", u.params = ""), w2 && (u.nodes = [], this.current = u);
    }, e.end = function(n) {
      this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = false, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = { line: n[2], column: n[3] }, this.current = this.current.parent) : this.unexpectedClose(n);
    }, e.endFile = function() {
      this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces;
    }, e.freeSemicolon = function(n) {
      if (this.spaces += n[1], this.current.nodes) {
        var u = this.current.nodes[this.current.nodes.length - 1];
        u && u.type === "rule" && !u.raws.ownSemicolon && (u.raws.ownSemicolon = this.spaces, this.spaces = "");
      }
    }, e.init = function(n, u, m2) {
      this.current.push(n), n.source = { start: { line: u, column: m2 }, input: this.input }, n.raws.before = this.spaces, this.spaces = "", n.type !== "comment" && (this.semicolon = false);
    }, e.raw = function(n, u, m2) {
      for (var v, y, w2 = m2.length, d4 = "", _ = true, O2, S2, M2 = /^([.|#])?([\w])+/i, R = 0; R < w2; R += 1) {
        if (v = m2[R], y = v[0], y === "comment" && n.type === "rule") {
          S2 = m2[R - 1], O2 = m2[R + 1], S2[0] !== "space" && O2[0] !== "space" && M2.test(S2[1]) && M2.test(O2[1]) ? d4 += v[1] : _ = false;
          continue;
        }
        y === "comment" || y === "space" && R === w2 - 1 ? _ = false : d4 += v[1];
      }
      if (!_) {
        var $ = m2.reduce(function(J2, X3) {
          return J2 + X3[1];
        }, "");
        n.raws[u] = { value: d4, raw: $ };
      }
      n[u] = d4;
    }, e.spacesAndCommentsFromEnd = function(n) {
      for (var u, m2 = ""; n.length && (u = n[n.length - 1][0], !(u !== "space" && u !== "comment")); )
        m2 = n.pop()[1] + m2;
      return m2;
    }, e.spacesAndCommentsFromStart = function(n) {
      for (var u, m2 = ""; n.length && (u = n[0][0], !(u !== "space" && u !== "comment")); )
        m2 += n.shift()[1];
      return m2;
    }, e.spacesFromEnd = function(n) {
      for (var u, m2 = ""; n.length && (u = n[n.length - 1][0], u === "space"); )
        m2 = n.pop()[1] + m2;
      return m2;
    }, e.stringFrom = function(n, u) {
      for (var m2 = "", v = u; v < n.length; v++)
        m2 += n[v][1];
      return n.splice(u, n.length - u), m2;
    }, e.colon = function(n) {
      for (var u = 0, m2, v, y, w2 = 0; w2 < n.length; w2++) {
        if (m2 = n[w2], v = m2[0], v === "(" && (u += 1), v === ")" && (u -= 1), u === 0 && v === ":")
          if (!y)
            this.doubleColon(m2);
          else {
            if (y[0] === "word" && y[1] === "progid")
              continue;
            return w2;
          }
        y = m2;
      }
      return false;
    }, e.unclosedBracket = function(n) {
      throw this.input.error("Unclosed bracket", n[2], n[3]);
    }, e.unknownWord = function(n) {
      throw this.input.error("Unknown word", n[0][2], n[0][3]);
    }, e.unexpectedClose = function(n) {
      throw this.input.error("Unexpected }", n[2], n[3]);
    }, e.unclosedBlock = function() {
      var n = this.current.source.start;
      throw this.input.error("Unclosed block", n.line, n.column);
    }, e.doubleColon = function(n) {
      throw this.input.error("Double colon", n[2], n[3]);
    }, e.unnamedAtrule = function(n, u) {
      throw this.input.error("At-rule without name", u[2], u[3]);
    }, e.precheckMissedSemicolon = function() {
    }, e.checkMissedSemicolon = function(n) {
      var u = this.colon(n);
      if (u !== false) {
        for (var m2 = 0, v, y = u - 1; y >= 0 && (v = n[y], !(v[0] !== "space" && (m2 += 1, m2 === 2))); y--)
          ;
        throw this.input.error("Missed semicolon", v[2], v[3]);
      }
    }, t;
  }();
  r.default = c, i2.exports = r.default;
} }), df = C({ "node_modules/postcss-less/lib/nodes/inline-comment.js"(r, i2) {
  I();
  var s2 = At(), l = mr();
  i2.exports = { isInlineComment(o) {
    if (o[0] === "word" && o[1].slice(0, 2) === "//") {
      let h2 = o, f = [], p;
      for (; o; ) {
        if (/\r?\n/.test(o[1])) {
          if (/['"].*\r?\n/.test(o[1])) {
            f.push(o[1].substring(0, o[1].indexOf(`
`)));
            let c = o[1].substring(o[1].indexOf(`
`));
            c += this.input.css.valueOf().substring(this.tokenizer.position()), this.input = new l(c), this.tokenizer = s2(this.input);
          } else
            this.tokenizer.back(o);
          break;
        }
        f.push(o[1]), p = o, o = this.tokenizer.nextToken({ ignoreUnclosed: true });
      }
      let g2 = ["comment", f.join(""), h2[2], h2[3], p[2], p[3]];
      return this.inlineComment(g2), true;
    } else if (o[1] === "/") {
      let h2 = this.tokenizer.nextToken({ ignoreUnclosed: true });
      if (h2[0] === "comment" && /^\/\*/.test(h2[1]))
        return h2[0] = "word", h2[1] = h2[1].slice(1), o[1] = "//", this.tokenizer.back(h2), i2.exports.isInlineComment.bind(this)(o);
    }
    return false;
  } };
} }), vf = C({ "node_modules/postcss-less/lib/nodes/interpolation.js"(r, i2) {
  I(), i2.exports = { interpolation(s2) {
    let l = s2, o = [s2], h2 = ["word", "{", "}"];
    if (s2 = this.tokenizer.nextToken(), l[1].length > 1 || s2[0] !== "{")
      return this.tokenizer.back(s2), false;
    for (; s2 && h2.includes(s2[0]); )
      o.push(s2), s2 = this.tokenizer.nextToken();
    let f = o.map((e) => e[1]);
    [l] = o;
    let p = o.pop(), g2 = [l[2], l[3]], c = [p[4] || p[2], p[5] || p[3]], t = ["word", f.join("")].concat(g2, c);
    return this.tokenizer.back(s2), this.tokenizer.back(t), true;
  } };
} }), mf = C({ "node_modules/postcss-less/lib/nodes/mixin.js"(r, i2) {
  I();
  var s2 = /^#[0-9a-fA-F]{6}$|^#[0-9a-fA-F]{3}$/, l = /\.[0-9]/, o = (h2) => {
    let [, f] = h2, [p] = f;
    return (p === "." || p === "#") && s2.test(f) === false && l.test(f) === false;
  };
  i2.exports = { isMixinToken: o };
} }), gf = C({ "node_modules/postcss-less/lib/nodes/import.js"(r, i2) {
  I();
  var s2 = At(), l = /^url\((.+)\)/;
  i2.exports = (o) => {
    let { name: h2, params: f = "" } = o;
    if (h2 === "import" && f.length) {
      o.import = true;
      let p = s2({ css: f });
      for (o.filename = f.replace(l, "$1"); !p.endOfFile(); ) {
        let [g2, c] = p.nextToken();
        if (g2 === "word" && c === "url")
          return;
        if (g2 === "brackets") {
          o.options = c, o.filename = f.replace(c, "").trim();
          break;
        }
      }
    }
  };
} }), yf = C({ "node_modules/postcss-less/lib/nodes/variable.js"(r, i2) {
  I();
  var s2 = /:$/, l = /^:(\s+)?/;
  i2.exports = (o) => {
    let { name: h2, params: f = "" } = o;
    if (o.name.slice(-1) === ":") {
      if (s2.test(h2)) {
        let [p] = h2.match(s2);
        o.name = h2.replace(p, ""), o.raws.afterName = p + (o.raws.afterName || ""), o.variable = true, o.value = o.params;
      }
      if (l.test(f)) {
        let [p] = f.match(l);
        o.value = f.replace(p, ""), o.raws.afterName = (o.raws.afterName || "") + p, o.variable = true;
      }
    }
  };
} }), wf = C({ "node_modules/postcss-less/lib/LessParser.js"(r, i2) {
  I();
  var s2 = yr(), l = Pt(), { isInlineComment: o } = df(), { interpolation: h2 } = vf(), { isMixinToken: f } = mf(), p = gf(), g2 = yf(), c = /(!\s*important)$/i;
  i2.exports = class extends l {
    constructor() {
      super(...arguments), this.lastNode = null;
    }
    atrule(e) {
      h2.bind(this)(e) || (super.atrule(e), p(this.lastNode), g2(this.lastNode));
    }
    decl() {
      super.decl(...arguments), /extend\(.+\)/i.test(this.lastNode.value) && (this.lastNode.extend = true);
    }
    each(e) {
      e[0][1] = " ".concat(e[0][1]);
      let a3 = e.findIndex((y) => y[0] === "("), n = e.reverse().find((y) => y[0] === ")"), u = e.reverse().indexOf(n), v = e.splice(a3, u).map((y) => y[1]).join("");
      for (let y of e.reverse())
        this.tokenizer.back(y);
      this.atrule(this.tokenizer.nextToken()), this.lastNode.function = true, this.lastNode.params = v;
    }
    init(e, a3, n) {
      super.init(e, a3, n), this.lastNode = e;
    }
    inlineComment(e) {
      let a3 = new s2(), n = e[1].slice(2);
      if (this.init(a3, e[2], e[3]), a3.source.end = { line: e[4], column: e[5] }, a3.inline = true, a3.raws.begin = "//", /^\s*$/.test(n))
        a3.text = "", a3.raws.left = n, a3.raws.right = "";
      else {
        let u = n.match(/^(\s*)([^]*[^\s])(\s*)$/);
        [, a3.raws.left, a3.text, a3.raws.right] = u;
      }
    }
    mixin(e) {
      let [a3] = e, n = a3[1].slice(0, 1), u = e.findIndex((d4) => d4[0] === "brackets"), m2 = e.findIndex((d4) => d4[0] === "("), v = "";
      if ((u < 0 || u > 3) && m2 > 0) {
        let d4 = e.reduce((K, W2, T2) => W2[0] === ")" ? T2 : K), O2 = e.slice(m2, d4 + m2).map((K) => K[1]).join(""), [S2] = e.slice(m2), M2 = [S2[2], S2[3]], [R] = e.slice(d4, d4 + 1), $ = [R[2], R[3]], J2 = ["brackets", O2].concat(M2, $), X3 = e.slice(0, m2), F = e.slice(d4 + 1);
        e = X3, e.push(J2), e = e.concat(F);
      }
      let y = [];
      for (let d4 of e)
        if ((d4[1] === "!" || y.length) && y.push(d4), d4[1] === "important")
          break;
      if (y.length) {
        let [d4] = y, _ = e.indexOf(d4), O2 = y[y.length - 1], S2 = [d4[2], d4[3]], M2 = [O2[4], O2[5]], R = y.map((J2) => J2[1]).join(""), $ = ["word", R].concat(S2, M2);
        e.splice(_, y.length, $);
      }
      let w2 = e.findIndex((d4) => c.test(d4[1]));
      w2 > 0 && ([, v] = e[w2], e.splice(w2, 1));
      for (let d4 of e.reverse())
        this.tokenizer.back(d4);
      this.atrule(this.tokenizer.nextToken()), this.lastNode.mixin = true, this.lastNode.raws.identifier = n, v && (this.lastNode.important = true, this.lastNode.raws.important = v);
    }
    other(e) {
      o.bind(this)(e) || super.other(e);
    }
    rule(e) {
      let a3 = e[e.length - 1], n = e[e.length - 2];
      if (n[0] === "at-word" && a3[0] === "{" && (this.tokenizer.back(a3), h2.bind(this)(n))) {
        let m2 = this.tokenizer.nextToken();
        e = e.slice(0, e.length - 2).concat([m2]);
        for (let v of e.reverse())
          this.tokenizer.back(v);
        return;
      }
      super.rule(e), /:extend\(.+\)/i.test(this.lastNode.selector) && (this.lastNode.extend = true);
    }
    unknownWord(e) {
      let [a3] = e;
      if (e[0][1] === "each" && e[1][0] === "(") {
        this.each(e);
        return;
      }
      if (f(a3)) {
        this.mixin(e);
        return;
      }
      super.unknownWord(e);
    }
  };
} }), _f = C({ "node_modules/postcss-less/lib/LessStringifier.js"(r, i2) {
  I();
  var s2 = gr();
  i2.exports = class extends s2 {
    atrule(o, h2) {
      if (!o.mixin && !o.variable && !o.function) {
        super.atrule(o, h2);
        return;
      }
      let f = o.function ? "" : o.raws.identifier || "@", p = "".concat(f).concat(o.name), g2 = o.params ? this.rawValue(o, "params") : "", c = o.raws.important || "";
      if (o.variable && (g2 = o.value), typeof o.raws.afterName < "u" ? p += o.raws.afterName : g2 && (p += " "), o.nodes)
        this.block(o, p + g2 + c);
      else {
        let t = (o.raws.between || "") + c + (h2 ? ";" : "");
        this.builder(p + g2 + t, o);
      }
    }
    comment(o) {
      if (o.inline) {
        let h2 = this.raw(o, "left", "commentLeft"), f = this.raw(o, "right", "commentRight");
        this.builder("//".concat(h2).concat(o.text).concat(f), o);
      } else
        super.comment(o);
    }
  };
} }), bf = C({ "node_modules/postcss-less/lib/index.js"(r, i2) {
  I();
  var s2 = mr(), l = wf(), o = _f();
  i2.exports = { parse(h2, f) {
    let p = new s2(h2, f), g2 = new l(p);
    return g2.parse(), g2.root;
  }, stringify(h2, f) {
    new o(f).stringify(h2);
  }, nodeToString(h2) {
    let f = "";
    return i2.exports.stringify(h2, (p) => {
      f += p;
    }), f;
  } };
} }), xf = C({ "node_modules/postcss-scss/lib/scss-stringifier.js"(r, i2) {
  I();
  function s2(h2, f) {
    h2.prototype = Object.create(f.prototype), h2.prototype.constructor = h2, h2.__proto__ = f;
  }
  var l = gr(), o = function(h2) {
    s2(f, h2);
    function f() {
      return h2.apply(this, arguments) || this;
    }
    var p = f.prototype;
    return p.comment = function(c) {
      var t = this.raw(c, "left", "commentLeft"), e = this.raw(c, "right", "commentRight");
      if (c.raws.inline) {
        var a3 = c.raws.text || c.text;
        this.builder("//" + t + a3 + e, c);
      } else
        this.builder("/*" + t + c.text + e + "*/", c);
    }, p.decl = function(c, t) {
      if (!c.isNested)
        h2.prototype.decl.call(this, c, t);
      else {
        var e = this.raw(c, "between", "colon"), a3 = c.prop + e + this.rawValue(c, "value");
        c.important && (a3 += c.raws.important || " !important"), this.builder(a3 + "{", c, "start");
        var n;
        c.nodes && c.nodes.length ? (this.body(c), n = this.raw(c, "after")) : n = this.raw(c, "after", "emptyBody"), n && this.builder(n), this.builder("}", c, "end");
      }
    }, p.rawValue = function(c, t) {
      var e = c[t], a3 = c.raws[t];
      return a3 && a3.value === e ? a3.scss ? a3.scss : a3.raw : e;
    }, f;
  }(l);
  i2.exports = o;
} }), kf = C({ "node_modules/postcss-scss/lib/scss-stringify.js"(r, i2) {
  I();
  var s2 = xf();
  i2.exports = function(o, h2) {
    var f = new s2(h2);
    f.stringify(o);
  };
} }), Sf = C({ "node_modules/postcss-scss/lib/nested-declaration.js"(r, i2) {
  I();
  function s2(h2, f) {
    h2.prototype = Object.create(f.prototype), h2.prototype.constructor = h2, h2.__proto__ = f;
  }
  var l = wr(), o = function(h2) {
    s2(f, h2);
    function f(p) {
      var g2;
      return g2 = h2.call(this, p) || this, g2.type = "decl", g2.isNested = true, g2.nodes || (g2.nodes = []), g2;
    }
    return f;
  }(l);
  i2.exports = o;
} }), Of = C({ "node_modules/postcss-scss/lib/scss-tokenize.js"(r, i2) {
  I();
  var s2 = "'".charCodeAt(0), l = '"'.charCodeAt(0), o = "\\".charCodeAt(0), h2 = "/".charCodeAt(0), f = `
`.charCodeAt(0), p = " ".charCodeAt(0), g2 = "\f".charCodeAt(0), c = "	".charCodeAt(0), t = "\r".charCodeAt(0), e = "[".charCodeAt(0), a3 = "]".charCodeAt(0), n = "(".charCodeAt(0), u = ")".charCodeAt(0), m2 = "{".charCodeAt(0), v = "}".charCodeAt(0), y = ";".charCodeAt(0), w2 = "*".charCodeAt(0), d4 = ":".charCodeAt(0), _ = "@".charCodeAt(0), O2 = ",".charCodeAt(0), S2 = "#".charCodeAt(0), M2 = /[ \n\t\r\f{}()'"\\;/[\]#]/g, R = /[ \n\t\r\f(){}:;@!'"\\\][#]|\/(?=\*)/g, $ = /.[\\/("'\n]/, J2 = /[a-f0-9]/i, X3 = /[\r\f\n]/g;
  i2.exports = function(K, W2) {
    W2 === void 0 && (W2 = {});
    var T2 = K.css.valueOf(), D2 = W2.ignoreErrors, j, N, b2, Q, G, L, B, P, Z3, V, q, x2, k2, z, A2 = T2.length, E = -1, H3 = 1, U = 0, re2 = [], ne = [];
    function ce(se) {
      throw K.error("Unclosed " + se, H3, U - E);
    }
    function fe2() {
      return ne.length === 0 && U >= A2;
    }
    function te2() {
      for (var se = 1, le2 = false, pe = false; se > 0; )
        N += 1, T2.length <= N && ce("interpolation"), j = T2.charCodeAt(N), x2 = T2.charCodeAt(N + 1), le2 ? !pe && j === le2 ? (le2 = false, pe = false) : j === o ? pe = !V : pe && (pe = false) : j === s2 || j === l ? le2 = j : j === v ? se -= 1 : j === S2 && x2 === m2 && (se += 1);
    }
    function ie() {
      if (ne.length)
        return ne.pop();
      if (!(U >= A2)) {
        switch (j = T2.charCodeAt(U), (j === f || j === g2 || j === t && T2.charCodeAt(U + 1) !== f) && (E = U, H3 += 1), j) {
          case f:
          case p:
          case c:
          case t:
          case g2:
            N = U;
            do
              N += 1, j = T2.charCodeAt(N), j === f && (E = N, H3 += 1);
            while (j === p || j === f || j === c || j === t || j === g2);
            k2 = ["space", T2.slice(U, N)], U = N - 1;
            break;
          case e:
            k2 = ["[", "[", H3, U - E];
            break;
          case a3:
            k2 = ["]", "]", H3, U - E];
            break;
          case m2:
            k2 = ["{", "{", H3, U - E];
            break;
          case v:
            k2 = ["}", "}", H3, U - E];
            break;
          case O2:
            k2 = ["word", ",", H3, U - E, H3, U - E + 1];
            break;
          case d4:
            k2 = [":", ":", H3, U - E];
            break;
          case y:
            k2 = [";", ";", H3, U - E];
            break;
          case n:
            if (q = re2.length ? re2.pop()[1] : "", x2 = T2.charCodeAt(U + 1), q === "url" && x2 !== s2 && x2 !== l) {
              for (z = 1, V = false, N = U + 1; N <= T2.length - 1; ) {
                if (x2 = T2.charCodeAt(N), x2 === o)
                  V = !V;
                else if (x2 === n)
                  z += 1;
                else if (x2 === u && (z -= 1, z === 0))
                  break;
                N += 1;
              }
              L = T2.slice(U, N + 1), Q = L.split(`
`), G = Q.length - 1, G > 0 ? (P = H3 + G, Z3 = N - Q[G].length) : (P = H3, Z3 = E), k2 = ["brackets", L, H3, U - E, P, N - Z3], E = Z3, H3 = P, U = N;
            } else
              N = T2.indexOf(")", U + 1), L = T2.slice(U, N + 1), N === -1 || $.test(L) ? k2 = ["(", "(", H3, U - E] : (k2 = ["brackets", L, H3, U - E, H3, N - E], U = N);
            break;
          case u:
            k2 = [")", ")", H3, U - E];
            break;
          case s2:
          case l:
            for (b2 = j, N = U, V = false; N < A2 && (N++, N === A2 && ce("string"), j = T2.charCodeAt(N), x2 = T2.charCodeAt(N + 1), !(!V && j === b2)); )
              j === o ? V = !V : V ? V = false : j === S2 && x2 === m2 && te2();
            L = T2.slice(U, N + 1), Q = L.split(`
`), G = Q.length - 1, G > 0 ? (P = H3 + G, Z3 = N - Q[G].length) : (P = H3, Z3 = E), k2 = ["string", T2.slice(U, N + 1), H3, U - E, P, N - Z3], E = Z3, H3 = P, U = N;
            break;
          case _:
            M2.lastIndex = U + 1, M2.test(T2), M2.lastIndex === 0 ? N = T2.length - 1 : N = M2.lastIndex - 2, k2 = ["at-word", T2.slice(U, N + 1), H3, U - E, H3, N - E], U = N;
            break;
          case o:
            for (N = U, B = true; T2.charCodeAt(N + 1) === o; )
              N += 1, B = !B;
            if (j = T2.charCodeAt(N + 1), B && j !== h2 && j !== p && j !== f && j !== c && j !== t && j !== g2 && (N += 1, J2.test(T2.charAt(N)))) {
              for (; J2.test(T2.charAt(N + 1)); )
                N += 1;
              T2.charCodeAt(N + 1) === p && (N += 1);
            }
            k2 = ["word", T2.slice(U, N + 1), H3, U - E, H3, N - E], U = N;
            break;
          default:
            x2 = T2.charCodeAt(U + 1), j === S2 && x2 === m2 ? (N = U, te2(), L = T2.slice(U, N + 1), Q = L.split(`
`), G = Q.length - 1, G > 0 ? (P = H3 + G, Z3 = N - Q[G].length) : (P = H3, Z3 = E), k2 = ["word", L, H3, U - E, P, N - Z3], E = Z3, H3 = P, U = N) : j === h2 && x2 === w2 ? (N = T2.indexOf("*/", U + 2) + 1, N === 0 && (D2 ? N = T2.length : ce("comment")), L = T2.slice(U, N + 1), Q = L.split(`
`), G = Q.length - 1, G > 0 ? (P = H3 + G, Z3 = N - Q[G].length) : (P = H3, Z3 = E), k2 = ["comment", L, H3, U - E, P, N - Z3], E = Z3, H3 = P, U = N) : j === h2 && x2 === h2 ? (X3.lastIndex = U + 1, X3.test(T2), X3.lastIndex === 0 ? N = T2.length - 1 : N = X3.lastIndex - 2, L = T2.slice(U, N + 1), k2 = ["comment", L, H3, U - E, H3, N - E, "inline"], U = N) : (R.lastIndex = U + 1, R.test(T2), R.lastIndex === 0 ? N = T2.length - 1 : N = R.lastIndex - 2, k2 = ["word", T2.slice(U, N + 1), H3, U - E, H3, N - E], re2.push(k2), U = N);
            break;
        }
        return U++, k2;
      }
    }
    function ae2(se) {
      ne.push(se);
    }
    return { back: ae2, nextToken: ie, endOfFile: fe2 };
  };
} }), Tf = C({ "node_modules/postcss-scss/lib/scss-parser.js"(r, i2) {
  I();
  function s2(g2, c) {
    g2.prototype = Object.create(c.prototype), g2.prototype.constructor = g2, g2.__proto__ = c;
  }
  var l = yr(), o = Pt(), h2 = Sf(), f = Of(), p = function(g2) {
    s2(c, g2);
    function c() {
      return g2.apply(this, arguments) || this;
    }
    var t = c.prototype;
    return t.createTokenizer = function() {
      this.tokenizer = f(this.input);
    }, t.rule = function(a3) {
      for (var n = false, u = 0, m2 = "", w2 = a3, v = Array.isArray(w2), y = 0, w2 = v ? w2 : w2[Symbol.iterator](); ; ) {
        var d4;
        if (v) {
          if (y >= w2.length)
            break;
          d4 = w2[y++];
        } else {
          if (y = w2.next(), y.done)
            break;
          d4 = y.value;
        }
        var _ = d4;
        if (n)
          _[0] !== "comment" && _[0] !== "{" && (m2 += _[1]);
        else {
          if (_[0] === "space" && _[1].indexOf(`
`) !== -1)
            break;
          _[0] === "(" ? u += 1 : _[0] === ")" ? u -= 1 : u === 0 && _[0] === ":" && (n = true);
        }
      }
      if (!n || m2.trim() === "" || /^[a-zA-Z-:#]/.test(m2))
        g2.prototype.rule.call(this, a3);
      else {
        a3.pop();
        var O2 = new h2();
        this.init(O2);
        var S2 = a3[a3.length - 1];
        for (S2[4] ? O2.source.end = { line: S2[4], column: S2[5] } : O2.source.end = { line: S2[2], column: S2[3] }; a3[0][0] !== "word"; )
          O2.raws.before += a3.shift()[1];
        for (O2.source.start = { line: a3[0][2], column: a3[0][3] }, O2.prop = ""; a3.length; ) {
          var M2 = a3[0][0];
          if (M2 === ":" || M2 === "space" || M2 === "comment")
            break;
          O2.prop += a3.shift()[1];
        }
        O2.raws.between = "";
        for (var R; a3.length; )
          if (R = a3.shift(), R[0] === ":") {
            O2.raws.between += R[1];
            break;
          } else
            O2.raws.between += R[1];
        (O2.prop[0] === "_" || O2.prop[0] === "*") && (O2.raws.before += O2.prop[0], O2.prop = O2.prop.slice(1)), O2.raws.between += this.spacesAndCommentsFromStart(a3), this.precheckMissedSemicolon(a3);
        for (var $ = a3.length - 1; $ > 0; $--) {
          if (R = a3[$], R[1] === "!important") {
            O2.important = true;
            var J2 = this.stringFrom(a3, $);
            J2 = this.spacesFromEnd(a3) + J2, J2 !== " !important" && (O2.raws.important = J2);
            break;
          } else if (R[1] === "important") {
            for (var X3 = a3.slice(0), F = "", K = $; K > 0; K--) {
              var W2 = X3[K][0];
              if (F.trim().indexOf("!") === 0 && W2 !== "space")
                break;
              F = X3.pop()[1] + F;
            }
            F.trim().indexOf("!") === 0 && (O2.important = true, O2.raws.important = F, a3 = X3);
          }
          if (R[0] !== "space" && R[0] !== "comment")
            break;
        }
        this.raw(O2, "value", a3), O2.value.indexOf(":") !== -1 && this.checkMissedSemicolon(a3), this.current = O2;
      }
    }, t.comment = function(a3) {
      if (a3[6] === "inline") {
        var n = new l();
        this.init(n, a3[2], a3[3]), n.raws.inline = true, n.source.end = { line: a3[4], column: a3[5] };
        var u = a3[1].slice(2);
        if (/^\s*$/.test(u))
          n.text = "", n.raws.left = u, n.raws.right = "";
        else {
          var m2 = u.match(/^(\s*)([^]*[^\s])(\s*)$/), v = m2[2].replace(/(\*\/|\/\*)/g, "*//*");
          n.text = v, n.raws.left = m2[1], n.raws.right = m2[3], n.raws.text = m2[2];
        }
      } else
        g2.prototype.comment.call(this, a3);
    }, t.raw = function(a3, n, u) {
      if (g2.prototype.raw.call(this, a3, n, u), a3.raws[n]) {
        var m2 = a3.raws[n].raw;
        a3.raws[n].raw = u.reduce(function(v, y) {
          if (y[0] === "comment" && y[6] === "inline") {
            var w2 = y[1].slice(2).replace(/(\*\/|\/\*)/g, "*//*");
            return v + "/*" + w2 + "*/";
          } else
            return v + y[1];
        }, ""), m2 !== a3.raws[n].raw && (a3.raws[n].scss = m2);
      }
    }, c;
  }(o);
  i2.exports = p;
} }), Ef = C({ "node_modules/postcss-scss/lib/scss-parse.js"(r, i2) {
  I();
  var s2 = mr(), l = Tf();
  i2.exports = function(h2, f) {
    var p = new s2(h2, f), g2 = new l(p);
    return g2.parse(), g2.root;
  };
} }), qf = C({ "node_modules/postcss-scss/lib/scss-syntax.js"(r, i2) {
  I();
  var s2 = kf(), l = Ef();
  i2.exports = { parse: l, stringify: s2 };
} }), Af = C({ "src/language-css/parser-postcss.js"(r, i2) {
  I();
  var s2 = el(), l = Ss(), o = Os(), { hasPragma: h2 } = ll(), { locStart: f, locEnd: p } = ss(), { calculateLoc: g2, replaceQuotesInInlineComments: c } = ss(), t = dl(), e = vl(), a3 = ml(), n = gl(), u = yl(), m2 = wl(), v = _l(), y = bl(), w2 = (b2) => {
    for (; b2.parent; )
      b2 = b2.parent;
    return b2;
  };
  function d4(b2, Q) {
    let { nodes: G } = b2, L = { open: null, close: null, groups: [], type: "paren_group" }, B = [L], P = L, Z3 = { groups: [], type: "comma_group" }, V = [Z3];
    for (let q = 0; q < G.length; ++q) {
      let x2 = G[q];
      if (n(Q.parser, x2.value) && x2.type === "number" && x2.unit === ".." && l(x2.value) === "." && (x2.value = x2.value.slice(0, -1), x2.unit = "..."), x2.type === "func" && x2.value === "selector" && (x2.group.groups = [$(w2(b2).text.slice(x2.group.open.sourceIndex + 1, x2.group.close.sourceIndex))]), x2.type === "func" && x2.value === "url") {
        let k2 = x2.group && x2.group.groups || [], z = [];
        for (let A2 = 0; A2 < k2.length; A2++) {
          let E = k2[A2];
          E.type === "comma_group" ? z = [...z, ...E.groups] : z.push(E);
        }
        if (t(z) || !e(z) && !m2(z[0])) {
          let A2 = v({ groups: x2.group.groups });
          x2.group.groups = [A2.trim()];
        }
      }
      if (x2.type === "paren" && x2.value === "(")
        L = { open: x2, close: null, groups: [], type: "paren_group" }, B.push(L), Z3 = { groups: [], type: "comma_group" }, V.push(Z3);
      else if (x2.type === "paren" && x2.value === ")") {
        if (Z3.groups.length > 0 && L.groups.push(Z3), L.close = x2, V.length === 1)
          throw new Error("Unbalanced parenthesis");
        V.pop(), Z3 = l(V), Z3.groups.push(L), B.pop(), L = l(B);
      } else
        x2.type === "comma" ? (L.groups.push(Z3), Z3 = { groups: [], type: "comma_group" }, V[V.length - 1] = Z3) : Z3.groups.push(x2);
    }
    return Z3.groups.length > 0 && L.groups.push(Z3), P;
  }
  function _(b2) {
    return b2.type === "paren_group" && !b2.open && !b2.close && b2.groups.length === 1 || b2.type === "comma_group" && b2.groups.length === 1 ? _(b2.groups[0]) : b2.type === "paren_group" || b2.type === "comma_group" ? Object.assign(Object.assign({}, b2), {}, { groups: b2.groups.map(_) }) : b2;
  }
  function O2(b2, Q, G) {
    if (b2 && typeof b2 == "object") {
      delete b2.parent;
      for (let L in b2)
        O2(b2[L], Q, G), L === "type" && typeof b2[L] == "string" && !b2[L].startsWith(Q) && (!G || !G.test(b2[L])) && (b2[L] = Q + b2[L]);
    }
    return b2;
  }
  function S2(b2) {
    if (b2 && typeof b2 == "object") {
      delete b2.parent;
      for (let Q in b2)
        S2(b2[Q]);
      !Array.isArray(b2) && b2.value && !b2.type && (b2.type = "unknown");
    }
    return b2;
  }
  function M2(b2, Q) {
    if (b2 && typeof b2 == "object") {
      for (let G in b2)
        G !== "parent" && (M2(b2[G], Q), G === "nodes" && (b2.group = _(d4(b2, Q)), delete b2[G]));
      delete b2.parent;
    }
    return b2;
  }
  function R(b2, Q) {
    let G = Hl(), L = null;
    try {
      L = G(b2, { loose: true }).parse();
    } catch {
      return { type: "value-unknown", value: b2 };
    }
    L.text = b2;
    let B = M2(L, Q);
    return O2(B, "value-", /^selector-/);
  }
  function $(b2) {
    if (/\/\/|\/\*/.test(b2))
      return { type: "selector-unknown", value: b2.trim() };
    let Q = Xl(), G = null;
    try {
      Q((L) => {
        G = L;
      }).process(b2);
    } catch {
      return { type: "selector-unknown", value: b2 };
    }
    return O2(G, "selector-");
  }
  function J2(b2) {
    let Q = ef().default, G = null;
    try {
      G = Q(b2);
    } catch {
      return { type: "selector-unknown", value: b2 };
    }
    return O2(S2(G), "media-");
  }
  var X3 = /(\s*)(!default).*$/, F = /(\s*)(!global).*$/;
  function K(b2, Q) {
    if (b2 && typeof b2 == "object") {
      delete b2.parent;
      for (let P in b2)
        K(b2[P], Q);
      if (!b2.type)
        return b2;
      b2.raws || (b2.raws = {});
      let G = "";
      typeof b2.selector == "string" && (G = b2.raws.selector ? b2.raws.selector.scss ? b2.raws.selector.scss : b2.raws.selector.raw : b2.selector, b2.raws.between && b2.raws.between.trim().length > 0 && (G += b2.raws.between), b2.raws.selector = G);
      let L = "";
      typeof b2.value == "string" && (L = b2.raws.value ? b2.raws.value.scss ? b2.raws.value.scss : b2.raws.value.raw : b2.value, L = L.trim(), b2.raws.value = L);
      let B = "";
      if (typeof b2.params == "string" && (B = b2.raws.params ? b2.raws.params.scss ? b2.raws.params.scss : b2.raws.params.raw : b2.params, b2.raws.afterName && b2.raws.afterName.trim().length > 0 && (B = b2.raws.afterName + B), b2.raws.between && b2.raws.between.trim().length > 0 && (B = B + b2.raws.between), B = B.trim(), b2.raws.params = B), G.trim().length > 0)
        return G.startsWith("@") && G.endsWith(":") ? b2 : b2.mixin ? (b2.selector = R(G, Q), b2) : (u(b2) && (b2.isSCSSNesterProperty = true), b2.selector = $(G), b2);
      if (L.length > 0) {
        let P = L.match(X3);
        P && (L = L.slice(0, P.index), b2.scssDefault = true, P[0].trim() !== "!default" && (b2.raws.scssDefault = P[0]));
        let Z3 = L.match(F);
        if (Z3 && (L = L.slice(0, Z3.index), b2.scssGlobal = true, Z3[0].trim() !== "!global" && (b2.raws.scssGlobal = Z3[0])), L.startsWith("progid:"))
          return { type: "value-unknown", value: L };
        b2.value = R(L, Q);
      }
      if (a3(Q) && b2.type === "css-decl" && L.startsWith("extend(") && (b2.extend || (b2.extend = b2.raws.between === ":"), b2.extend && !b2.selector && (delete b2.value, b2.selector = $(L.slice(7, -1)))), b2.type === "css-atrule") {
        if (a3(Q)) {
          if (b2.mixin) {
            let P = b2.raws.identifier + b2.name + b2.raws.afterName + b2.raws.params;
            return b2.selector = $(P), delete b2.params, b2;
          }
          if (b2.function)
            return b2;
        }
        if (Q.parser === "css" && b2.name === "custom-selector") {
          let P = b2.params.match(/:--\S+\s+/)[0].trim();
          return b2.customSelector = P, b2.selector = $(b2.params.slice(P.length).trim()), delete b2.params, b2;
        }
        if (a3(Q)) {
          if (b2.name.includes(":") && !b2.params) {
            b2.variable = true;
            let P = b2.name.split(":");
            b2.name = P[0], b2.value = R(P.slice(1).join(":"), Q);
          }
          if (!["page", "nest", "keyframes"].includes(b2.name) && b2.params && b2.params[0] === ":" && (b2.variable = true, b2.value = R(b2.params.slice(1), Q), b2.raws.afterName += ":"), b2.variable)
            return delete b2.params, b2;
        }
      }
      if (b2.type === "css-atrule" && B.length > 0) {
        let { name: P } = b2, Z3 = b2.name.toLowerCase();
        return P === "warn" || P === "error" ? (b2.params = { type: "media-unknown", value: B }, b2) : P === "extend" || P === "nest" ? (b2.selector = $(B), delete b2.params, b2) : P === "at-root" ? (/^\(\s*(?:without|with)\s*:.+\)$/s.test(B) ? b2.params = R(B, Q) : (b2.selector = $(B), delete b2.params), b2) : y(Z3) ? (b2.import = true, delete b2.filename, b2.params = R(B, Q), b2) : ["namespace", "supports", "if", "else", "for", "each", "while", "debug", "mixin", "include", "function", "return", "define-mixin", "add-mixin"].includes(P) ? (B = B.replace(/(\$\S+?)(\s+)?\.{3}/, "$1...$2"), B = B.replace(/^(?!if)(\S+)(\s+)\(/, "$1($2"), b2.value = R(B, Q), delete b2.params, b2) : ["media", "custom-media"].includes(Z3) ? B.includes("#{") ? { type: "media-unknown", value: B } : (b2.params = J2(B), b2) : (b2.params = B, b2);
      }
    }
    return b2;
  }
  function W2(b2, Q, G) {
    let L = o(Q), { frontMatter: B } = L;
    Q = L.content;
    let P;
    try {
      P = b2(Q);
    } catch (Z3) {
      let { name: V, reason: q, line: x2, column: k2 } = Z3;
      throw typeof x2 != "number" ? Z3 : s2("".concat(V, ": ").concat(q), { start: { line: x2, column: k2 } });
    }
    return P = K(O2(P, "css-"), G), g2(P, Q), B && (B.source = { startOffset: 0, endOffset: B.raw.length }, P.nodes.unshift(B)), P;
  }
  function T2(b2, Q) {
    let G = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, B = n(G.parser, b2) ? [j, D2] : [D2, j], P;
    for (let Z3 of B)
      try {
        return Z3(b2, Q, G);
      } catch (V) {
        P = P || V;
      }
    if (P)
      throw P;
  }
  function D2(b2, Q) {
    let G = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, L = bf();
    return W2((B) => L.parse(c(B)), b2, G);
  }
  function j(b2, Q) {
    let G = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, { parse: L } = qf();
    return W2(L, b2, G);
  }
  var N = { astFormat: "postcss", hasPragma: h2, locStart: f, locEnd: p };
  i2.exports = { parsers: { css: Object.assign(Object.assign({}, N), {}, { parse: T2 }), less: Object.assign(Object.assign({}, N), {}, { parse: D2 }), scss: Object.assign(Object.assign({}, N), {}, { parse: j }) } };
} }), Jp = Af();
function define$g(props = {}, tagName = "s-code-example") {
  SCodeExample.define(tagName, SCodeExample, props);
}
const __css$8 = ".s-code-example {\n    display: block;\n    text-align: initial;\n}\n            .s-rhythm--vertical > .s-code-example {\n                margin-bottom: calc(var(--s-theme-margin-default, 1rem) * 4.25);\n            }\n\n.s-code-example > * {\n        display: none;\n    }\n\n.s-code-example[mounted] > * {\n            display: block;\n        }\n\n.hljs {\n    overflow: visible;\n    white-space: pre-wrap;\n}\n\n.s-code-example__slot {\n    display: none;\n}\n\n.s-code-example__nav {\n    position: relative;\n    z-index: 20;\n}\n\n.s-code-example__tabs {\n    list-style: none;\n}\n\n.s-code-example__content {\n    position: relative;\n    /* this variable comes from the @sugar.codeExample mixin */\n    overflow: hidden;\n}\n\n.s-code-example[lines] .s-code-example__content {\n        max-height: calc(\n            2em * var(--max-lines) + (var(--paddingBlock, 1em) * 2)\n        );\n    }\n\n.s-code-example--more .s-code-example__content {\n        max-height: 99999px !important;\n    }\n\n.s-code-example__more-bar {\n    position: absolute;\n    bottom: 0;\n    left: 0;\n    height: 50%;\n    width: 100%;\n    opacity: 0;\n    pointer-events: none;\n    display: flex;\n    align-items: flex-end;\n}\n\n.s-code-example[lines] .s-code-example__more-bar {\n        opacity: 1;\n        pointer-events: all;\n    }\n\n.s-code-example__more-bar {\n    text-align: center;\n    justify-content: center;\n}\n\n.s-code-example__more-bar:before {\n        content: '';\n        position: absolute;\n        bottom: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n    }\n\n.s-code-example--more .s-code-example__more-bar:before {\n        height: 0;\n    }\n\n.s-code-example__code {\n    display: none;\n}\n\n.s-lod--1 .s-code-example__code {\n    line-height: 0;\n}\n\n.s-code-example__code[active] {\n        display: block;\n    }\n\n.s-lod--1 .s-code-example__code > code {\n        line-height: 1;\n}\n\n.s-code-example__toolbar {\n    position: absolute;\n    right: calc(var(--s-theme-margin-default, 1rem) * 0.75);\n    top: calc(var(--s-theme-margin-default, 1rem) * 0.75);\n}\n\n.s-code-example__toolbar > * {\n        opacity: 0.4;\n    }\n\n.s-lod--1 .s-code-example__toolbar > * {\n        color: hsla(calc(var(--s-theme-color-current-h, 0) + var(--s-theme-color-current-spin ,0)),calc((var(--s-theme-color-current-s, 0)) * 1%),calc((var(--s-theme-color-current-l, 0)) * 1%),var(--s-theme-color-current-a, 1));\n        font-size: 20px;\n}\n\n.s-code-example__toolbar > *:hover {\n            opacity: 0.8;\n        }\n\n[toolbar-position='nav'] .s-code-example__toolbar {\n    right: calc(var(--s-theme-margin-default, 1rem) * 0.75);\n    top: calc(var(--s-theme-margin-default, 1rem) * 0.75);\n}\n";
var __decorate = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d4 = decorators[i2])
        r = (c < 3 ? d4(r) : c > 3 ? d4(target, key, r) : d4(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter$6 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
define$q();
class SCodeExample extends SLitComponent {
  constructor() {
    super(__deepMerge({
      name: "s-code-example",
      interface: SCodeExampleComponentInterface
    }));
    this._$copy = void 0;
    this.state = {
      activeTabId: void 0,
      more: false
    };
  }
  static get properties() {
    return SLitComponent.propertiesFromInterface({}, SCodeExampleComponentInterface);
  }
  static get styles() {
    return css$1`
            ${unsafeCSS(__css$8)}
        `;
  }
  mount() {
    var _a3;
    return __awaiter$6(this, void 0, void 0, function* () {
      const languages = Object.assign({ html: xml, twig, javascript, js: javascript, php, bash, shell: bash, css, scss: css }, (_a3 = this.props.languages) !== null && _a3 !== void 0 ? _a3 : {});
      Object.keys(languages).forEach((lang) => {
        HighlightJS.registerLanguage(lang, languages[lang]);
      });
      this.$templates = this.querySelectorAll("template,code");
      this.$templates.forEach(($template) => {
        var _a4, _b2, _c2, _d2, _e2, _f2, _g;
        if (!$template.getAttribute)
          return;
        let parser = "babel";
        switch ((_b2 = (_a4 = $template.getAttribute("id")) !== null && _a4 !== void 0 ? _a4 : $template.getAttribute("language")) !== null && _b2 !== void 0 ? _b2 : $template.getAttribute("lang")) {
          case "html":
          case "xml":
            parser = "html";
            break;
          case "css":
          case "scss":
          case "postcss":
            parser = "css";
            break;
        }
        let rawCode = __decodeHtmlEntities($template.tagName.toLowerCase() === "textarea" && $template.value ? $template.value : $template.innerHTML);
        let formatedCode = rawCode;
        try {
          formatedCode = Y0.format(rawCode, {
            parser,
            plugins: [
              Jp,
              d2,
              Fd,
              __prettierPhp
            ]
          });
        } catch (e) {
        }
        this.props.items = [
          ...this.props.items,
          {
            id: (_e2 = (_d2 = (_c2 = $template.getAttribute("id")) !== null && _c2 !== void 0 ? _c2 : $template.getAttribute("language")) !== null && _d2 !== void 0 ? _d2 : $template.getAttribute("lang")) !== null && _e2 !== void 0 ? _e2 : "html",
            lang: (_g = (_f2 = $template.getAttribute("language")) !== null && _f2 !== void 0 ? _f2 : $template.getAttribute("lang")) !== null && _g !== void 0 ? _g : "html",
            code: formatedCode,
            lines: formatedCode.trim().split("\n").length
          }
        ];
        $template.remove();
      });
    });
  }
  firstUpdated() {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (this.props.active) {
        this.setActiveTab(this.props.active);
      } else {
        if (this.props.items[0]) {
          this.setActiveTab(this.props.items[0].id);
        }
      }
      this._$pre = this.querySelector(".s-code-example__code");
      this._$root = this.querySelector(".s-code-example__root");
      return true;
    });
  }
  setActiveTabByTab(e) {
    this.setActiveTab(e.target.id);
  }
  get currentItem() {
    if (!this.state.activeTabId)
      return {};
    return this.props.items.find((i2) => i2.id === this.state.activeTabId);
  }
  setActiveTab(id2) {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield __wait();
      this.state.activeTabId = id2;
      this.highlight(id2);
      this.requestUpdate();
    });
  }
  setMoreClass() {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (this.state.more) {
        this._$root.classList.add("s-code-example--more");
      } else {
        this._$root.classList.remove("s-code-example--more");
      }
    });
  }
  toggleMore() {
    var _a3;
    this.state.more = !this.state.more;
    this.setMoreClass();
    __scrollTo(this, Object.assign({}, (_a3 = this.props.scrollToSettings) !== null && _a3 !== void 0 ? _a3 : {}));
  }
  highlight(id2) {
    var _a3;
    const $content = this.querySelector(`pre#${id2} code`);
    const item = this.props.items.find((i2) => i2.id === id2);
    if ($content.hasAttribute("inited")) {
      this.setMoreClass();
      return;
    }
    $content.setAttribute("inited", "true");
    let code3;
    try {
      const codeToHighlight = __decodeHtmlEntities($content.innerHTML.replace(/(<|&lt;)!\s?--\?lit.*--\s?(>|&gt;)/, ""));
      code3 = HighlightJS.highlight(codeToHighlight, {
        language: $content.getAttribute("lang")
      });
    } catch (e) {
      console.log(e);
    }
    item.highlightedCode = (_a3 = code3 === null || code3 === void 0 ? void 0 : code3.value) !== null && _a3 !== void 0 ? _a3 : "";
    this.setMoreClass();
  }
  copy() {
    const id2 = this.state.activeTabId;
    const item = this.props.items.filter((i2) => i2.id === id2)[0];
    this.$copy.copy(item.code);
  }
  render() {
    var _a3, _b2, _c2, _d2, _e2, _f2, _g;
    const currentItem = this.currentItem;
    return html`
            <div
                class="${this.componentUtils.className("__root")} ${this.props.more ? this.componentUtils.className("more") : ""}"
                ?lines="${this.props.lines}"
                ?bare="${this.props.bare}"
                toolbar-position="${this.props.toolbarPosition}"
            >
                <div class="templates"></div>

                <header class="${this.componentUtils.className("__nav")}">
                    <div
                        class="${this.componentUtils.className("__tabs", "s-tabs")}"
                    >
                        ${((_a3 = this.props.items) !== null && _a3 !== void 0 ? _a3 : []).map((item) => html`
                                <div
                                    class="${this.componentUtils.className("__tab")}"
                                    id="${item.id}"
                                    ?active="${this.state.activeTabId === item.id}"
                                    @click="${this.setActiveTabByTab}"
                                >
                                    ${item.lang}
                                </div>
                            `)}
                    </div>
                    ${this.toolbarPosition === "nav" ? html`
                                  <div
                                      class="${this.componentUtils.className("__toolbar")}"
                                  >
                                      <s-clipboard-copy
                                          @click="${this.copy}"
                                      ></s-clipboard-copy>
                                  </div>
                              ` : ""}
                </header>
                <div
                    class="${this.componentUtils.className("__content")}"
                    style="--max-lines: ${(_b2 = this.props.lines) !== null && _b2 !== void 0 ? _b2 : 99999999};"
                >
                    ${this.toolbarPosition !== "nav" ? html`
                                  <div
                                      class="${this.componentUtils.className("__toolbar")}"
                                  >
                                      <s-clipboard-copy
                                          @click="${this.copy}"
                                      ></s-clipboard-copy>
                                  </div>
                              ` : ""}
                    ${((_c2 = this.props.items) !== null && _c2 !== void 0 ? _c2 : []).map((item) => {
      var _a4, _b3, _c3;
      return html`
                            <pre
                                class="${this.componentUtils.className("__code")}"
                                style="line-height:0;"
                                id="${(_a4 = item.id) !== null && _a4 !== void 0 ? _a4 : item.lang}"
                                ?active="${this.state.activeTabId === ((_b3 = item.id) !== null && _b3 !== void 0 ? _b3 : item.lang)}"
                            >
                            <code lang="${(_c3 = item.lang) !== null && _c3 !== void 0 ? _c3 : item.id}" class="language-${item.lang} ${item.lang} ${this.props.bare ? "" : "hljs"}">${item.highlightedCode ? unsafeHTML(item.highlightedCode) : item.code.trim()}</code>
                        </pre>
                        `;
    })}
                    ${this.props.lines && currentItem.lines > this.props.lines ? html`
                        <div class="${this.componentUtils.className("__more-bar")}">
                            ${this.moreAction === "toggle" ? html`
                                          <a
                                              class="${this.componentUtils.className("__more-button", "s-btn")}"
                                              @click="${() => this.toggleMore()}"
                                          >
                                              ${this.state.more ? html`
                                                            ${(_d2 = this.props.lessLabel) !== null && _d2 !== void 0 ? _d2 : "Show less"}
                                                        ` : html`
                                                            ${(_e2 = this.props.moreLabel) !== null && _e2 !== void 0 ? _e2 : "Show more"}
                                                        `}
                                          </a>
                                      ` : html`
                                          <a
                                              class="${this.componentUtils.className("__more-button", "s-btn s-color--accent")}"
                                              href="${this.moreAction}"
                                          >
                                              ${this.state.more ? html`
                                                            ${(_f2 = this.props.lessLabel) !== null && _f2 !== void 0 ? _f2 : "Show less"}
                                                        ` : html`
                                                            ${(_g = this.props.moreLabel) !== null && _g !== void 0 ? _g : "Show more"}
                                                        `}
                                          </a>
                                      `}                        
                            </a>
                        </div>
                    ` : ""}
                </div>
            </div>
        `;
  }
}
__decorate([
  query("s-clipboard-copy")
], SCodeExample.prototype, "$copy", void 0);
__decorate([
  query(".templates")
], SCodeExample.prototype, "$templatesContainer", void 0);
class SColorPickerComponentInterface extends SInterface {
  static get _definition() {
    return {
      name: {
        description: "Specify the name that will be assigned to the injected input if you don't provide one yourself",
        type: "String",
        default: "color"
      },
      value: {
        description: "Specify the initial value for your picker",
        type: "String"
      },
      updateInput: {
        description: 'Specify when you want to updat the attached input. Can be "pointermove", "pointerup", "pointerdown", "input", "validate", "close"',
        type: {
          type: "Array<String>",
          splitChars: [","]
        },
        values: [
          "pointerdown",
          "pointerup",
          "pointermove",
          "validate",
          "eyedropper",
          "reset",
          "clear",
          "close"
        ],
        default: [
          "pointerup",
          "validate",
          "eyedropper",
          "reset",
          "clear",
          "close"
        ]
      },
      format: {
        description: 'Specify the format of the color you want as end in the input value. Can be "hex", "hexa", "rgb", "rgba", "hsl" or "hsla"',
        type: "String",
        values: ["hex", "hexa", "rgb", "rgba", "hsl", "hsla"],
        default: "hex"
      },
      inline: {
        description: "Specify if you want to initalize the color picker inline or if you want it to be displayed only when the focus is in the input",
        type: "Boolean",
        default: false,
        physical: true
      },
      i18n: {
        description: 'Specify some translations for the color picker. You can translate the "reset", "clear" and "validate" buttons',
        type: "Object",
        default: {
          reset: "Reset",
          clear: "Clear",
          validate: "Validate"
        }
      },
      placeholder: {
        description: "Specify the placeholder that will be assigned to the injected input if you don't provide one yourself",
        type: "String",
        default: "Select a color"
      },
      backdrop: {
        description: 'Specify if you want the ".s-backdrop" element or not',
        type: "Boolean",
        default: false
      },
      eyeDropper: {
        description: "Specify if you want the eye dropper capability to pick a color anywhere on the screen or not",
        type: "Boolean",
        default: true
      },
      actions: {
        description: 'Specify the actions buttons you want to display. Can be "clear", "reset" and "validate". If false, hide all button',
        type: {
          type: "Array<String>",
          splitChars: [",", " "]
        },
        values: ["clear", "reset", "validate"],
        default: ["reset", "validate"]
      },
      floatSettings: {
        description: 'Specify some float settings to pass to the "makeFloat" function of the sugar toolkit',
        type: "Object",
        default: {
          position: "auto",
          shift: 10,
          offset: 0,
          arrow: false,
          arrowSize: 15,
          arrowPadding: 10
        }
      },
      eyeDropperIconClass: {
        description: 'Specify the class you want to apply on the "i" that display the "eyeDropper" icon',
        type: "String",
        default: "s-icon s-icon--eye-dropper"
      },
      copyIconClass: {
        description: 'Specify the class you want to apply on the "i" that display the "copy" icon',
        type: "String",
        default: "s-icon s-icon--copy"
      },
      copiedIconClass: {
        description: 'Specify the class you want to apply on the "i" that display the "copy" icon when the color has been copied',
        type: "String",
        default: "s-icon s-icon--copied"
      },
      buttonIconClass: {
        description: "Specify the class you want to apply on the injected button icon",
        type: "String",
        default: "s-icon s-icon--color"
      },
      backdropClass: {
        description: 'Specify the class to apply on the backdrop when the "backdrop" prop is true',
        type: "String",
        default: "s-backdrop"
      },
      disabled: {
        description: "Specify if the color picker is disabled",
        type: "Boolean",
        default: false
      }
    };
  }
}
function define$f(props = {}, tagName = "s-color-picker") {
  SColorPickerComponent.define(tagName, SColorPickerComponent, props);
}
const __css$7 = ".s-color-picker {\n    display: inline-block;\n    position: relative;\n}\n\n    .s-color-picker[disabled],\n    .s-color-picker[disabled] * {\n        pointer-events: none;\n    }\n\n    .s-color-picker *[disabled] {\n        opacity: 1 !important;\n    }\n\n    .s-color-picker .s-backdrop {\n        pointer-events: none;\n        opacity: 0;\n    }\n\n    .s-color-picker .s-color-picker__root {\n        display: flex;\n        width: 100%;\n    }\n\n    .s-color-picker .s-color-picker__root.is-alpha-interacting *,\n        .s-color-picker .s-color-picker__root.is-shade-interacting *,\n        .s-color-picker .s-color-picker__root.is-hue-interacting * {\n            cursor: none !important;\n        }\n\n    .s-color-picker .s-color-picker__injected {\n        display: flex;\n        width: 100%;\n    }\n\n    .s-color-picker .s-color-picker__injected input {\n            flex-grow: 1;\n        }\n\n    .s-color-picker .s-color-picker__injected button {\n            flex-grow: 0;\n        }\n\n    .s-color-picker .s-color-picker__picker {\n        position: absolute;\n        top: 100%;\n        left: 0;\n        z-index: 200;\n        max-width: 100vw;\n        display: flex;\n        flex-direction: column;\n        pointer-events: none;\n        opacity: 0;\n    }\n\n    .s-color-picker[inline] .s-color-picker__picker {\n        position: unset;\n        top: unset;\n        left: unset;\n        background: unset;\n        pointer-events: all;\n        opacity: 1;\n    }\n\n    .s-color-picker:focus-within .s-color-picker__picker {\n            opacity: 1;\n            pointer-events: all;\n        }\n\n    .s-color-picker:focus-within .s-backdrop {\n            opacity: 1;\n            pointer-events: all;\n        }\n\n    .s-color-picker .s-color-picker__chest {\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        opacity: 0.02;\n        pointer-events: none;\n    }\n\n    .s-color-picker .s-color-picker__chest:before {\n            content: '';\n            position: absolute;\n            width: 100%;\n            height: 100%;\n            top: 0;\n            left: 0;\n            background: repeating-linear-gradient(\n                0deg,\n                #000 0,\n                #000 10px,\n                #fff 10px,\n                #fff 20px\n            );\n            background-position: 50% 50%;\n            z-index: -1;\n        }\n\n    .s-color-picker .s-color-picker__chest:after {\n            content: '';\n            position: absolute;\n            width: 100%;\n            height: 100%;\n            top: 0;\n            left: 0;\n            background: repeating-linear-gradient(\n                90deg,\n                #000 0,\n                #000 10px,\n                #fff 10px,\n                #fff 20px\n            );\n            background-position: 50% 50%;\n            mix-blend-mode: difference;\n            z-index: -1;\n        }\n\n    .s-color-picker .s-color-picker__selectors {\n        display: flex;\n        height: 215px;\n    }\n\n    .s-color-picker .s-color-picker__shade-wrapper {\n        position: relative;\n        aspect-ratio: 16/9;\n        cursor: all-scroll;\n        flex-grow: 1;\n    }\n\n    .s-color-picker .s-color-picker__shade-wrapper canvas {\n            width: 100%;\n            height: 100%;\n            position: relative;\n        }\n\n    .s-color-picker .s-color-picker__hue-wrapper,\n    .s-color-picker .s-color-picker__alpha-wrapper {\n        position: relative;\n        width: 30px;\n        cursor: row-resize;\n        flex-grow: 0;\n        flex-shrink: 0;\n    }\n\n    .s-color-picker .s-color-picker__hue-wrapper canvas, .s-color-picker .s-color-picker__alpha-wrapper canvas {\n            width: 100%;\n            height: 100%;\n            position: relative;\n        }\n\n    .s-color-picker .s-color-picker__hue-wrapper:after, .s-color-picker .s-color-picker__alpha-wrapper:after {\n            content: '';\n            display: block;\n            width: calc(100%);\n            height: 5px;\n            background: red;\n            position: absolute;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            z-index: 10;\n            pointer-events: none;\n        }\n\n    .s-color-picker .s-color-picker__hue-wrapper:after {\n            top: calc((100 / 360 * var(--s-color-picker-h, 0)) * 1%);\n        }\n\n    .s-color-picker .s-color-picker__alpha-wrapper {\n        display: none;\n        background: white;\n    }\n\n    .s-color-picker .s-color-picker__alpha-wrapper.active {\n            display: block;\n        }\n\n    .s-color-picker .s-color-picker__alpha-wrapper:after {\n            top: calc(100% - var(--s-color-picker-a, 0) * 100 * 1%);\n        }\n\n    .s-color-picker .s-color-picker__shade-wrapper:after {\n            content: '';\n            display: block;\n            width: 10px;\n            height: 10px;\n            background: red;\n            position: absolute;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            z-index: 10;\n            top: calc(100% - var(--s-color-picker-shade-y, 0) * 1%);\n            left: calc(var(--s-color-picker-shade-x, 0) * 1%);\n            pointer-events: none;\n        }\n\n    .s-color-picker .s-color-picker__metas {\n        display: flex;\n        flex-wrap: nowrap;\n    }\n\n    .s-color-picker .s-color-picker__metas .s-color-picker__btn {\n            flex-grow: 0;\n        }\n\n    .s-color-picker .s-color-picker__formats {\n        display: flex;\n    }\n\n    .s-color-picker .s-color-picker__color {\n        display: flex;\n        position: relative;\n    }\n\n    .s-color-picker .s-color-picker__actions {\n        display: flex;\n    }\n\n    .s-color-picker .s-color-picker__actions button {\n            flex-grow: 1;\n            text-align: center;\n        }\n\n    .s-color-picker .s-color-picker__color-input {\n        flex-shrink: 1;\n        flex-grow: 1;\n    }\n\n    .s-color-picker .s-color-picker__preview {\n        position: relative;\n        width: 50px;\n        flex-shrink: 0;\n        flex-grow: 0;\n        cursor: pointer;\n        background-color: hsla(\n            var(--s-color-picker-h),\n            calc(var(--s-color-picker-s) * 1%),\n            calc(var(--s-color-picker-l) * 1%),\n            var(--s-color-picker-a)\n        );\n    }\n\n    .s-color-picker .s-color-picker__preview i {\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n        }\n\n    .s-color-picker .s-color-picker__eye-dropper {\n        position: absolute;\n        top: 0;\n        right: 50px;\n        width: 50px;\n        height: 100%;\n        background: rgba(0, 0, 0, 0);\n        cursor: pointer;\n    }\n\n    .s-color-picker .s-color-picker__eye-dropper i {\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n        }\n\n    [dir='rtl'] .s-color-picker .s-color-picker__picker,\n    .s-color-picker[dir='rtl'] .s-color-picker__picker {\n        right: auto;\n        left: 0;\n    }\n";
var __awaiter$5 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SColorPickerComponent extends SLitComponent {
  constructor() {
    var _a3, _b2;
    super(__deepMerge({
      name: "s-color-picker",
      interface: SColorPickerComponentInterface
    }));
    this.state = {};
    this._originalState = {};
    this._hasInput = false;
    this._hasButton = false;
    this._isShadeInInteraction = false;
    this._isAlphaInInteraction = false;
    this._isHueInInteraction = false;
    this.state = {
      h: 0,
      s: 0,
      l: 0,
      a: 1,
      metasFormat: "hex",
      value: void 0
    };
    this._$input = this.querySelector("input");
    this._hasInput = this._$input !== null;
    this._$button = this.querySelector("button");
    (_a3 = this._$button) === null || _a3 === void 0 ? void 0 : _a3.addEventListener("click", (e) => e.preventDefault());
    (_b2 = this._$button) === null || _b2 === void 0 ? void 0 : _b2.addEventListener("pointerup", (e) => e.preventDefault());
    this._hasButton = this._$button !== null;
  }
  static get properties() {
    return SLitComponent.propertiesFromInterface({}, SColorPickerComponentInterface);
  }
  static get styles() {
    return css$1`
            ${unsafeCSS(`
                ${__css$7}
            `)}
        `;
  }
  mount() {
    return __awaiter$5(this, void 0, void 0, function* () {
      this._hueColor = new SColor("#000");
      this._color = new SColor("#000");
    });
  }
  firstUpdated() {
    return __awaiter$5(this, void 0, void 0, function* () {
      Object.assign(this._originalState, this.state);
      this._$root = this.querySelector(`.${this.componentUtils.uniqueClassName("__root")}`);
      this._$picker = this.querySelector(`.${this.componentUtils.uniqueClassName("__picker")}`);
      this._$colorInput = this.querySelector(`.${this.componentUtils.uniqueClassName("__color-input")}`);
      this._$shade = this.querySelector(`.${this.componentUtils.uniqueClassName(`__shade`)}`);
      this._shadeCtx = this._$shade.getContext("2d");
      this._$hue = this.querySelector(`.${this.componentUtils.uniqueClassName(`__hue`)}`);
      this._hueCtx = this._$hue.getContext("2d");
      this._$alpha = this.querySelector(`.${this.componentUtils.uniqueClassName(`__alpha`)}`);
      this._alphaCtx = this._$alpha.getContext("2d");
      if (!this._$input) {
        this._$input = this.querySelector("input");
      }
      this.componentUtils.fastdom.mutate(() => {
        var _a3, _b2, _c2, _d2, _e2, _f2;
        if (!((_a3 = this._$input) === null || _a3 === void 0 ? void 0 : _a3.hasAttribute("name"))) {
          (_b2 = this._$input) === null || _b2 === void 0 ? void 0 : _b2.setAttribute("name", this.props.name);
        }
        if (!((_c2 = this._$input) === null || _c2 === void 0 ? void 0 : _c2.hasAttribute("placeholder"))) {
          (_d2 = this._$input) === null || _d2 === void 0 ? void 0 : _d2.setAttribute("placeholder", this.props.placeholder);
        }
        if (!((_e2 = this._$input) === null || _e2 === void 0 ? void 0 : _e2.hasAttribute("autocomplete"))) {
          (_f2 = this._$input) === null || _f2 === void 0 ? void 0 : _f2.setAttribute("autocomplete", "off");
        }
        this._$input.setAttribute("readonly", true);
      });
      this.addEventListener("focusin", (e) => {
        var _a3;
        (_a3 = this._floatApi) === null || _a3 === void 0 ? void 0 : _a3.update();
      });
      __preventViewportMovement(this.querySelector(".s-color-picker__selectors"));
      __preventViewportMovement(this.querySelector(".s-color-picker__metas"));
      if (!this._isAlphaWanted()) {
        this.state.a = 1;
      }
      this._initColor();
      this._initHueSelector();
      this._updateAlphaSelector();
      this._updateShadeCanvas();
      this._initSelectionInteractions();
      this._restoreState();
      this._updateInput("init");
      if (!this.props.inline && !__isMobile()) {
        this._floatApi = __makeFloat(this._$picker, this._$root, this.props.floatSettings);
      }
    });
  }
  _initColor() {
    var _a3, _b2;
    const value = (_a3 = this.props.value) !== null && _a3 !== void 0 ? _a3 : (_b2 = this._$input) === null || _b2 === void 0 ? void 0 : _b2.value;
    if (value) {
      this._inputColor = new SColor(value);
    }
    if (!this.state.value && value) {
      this._color = new SColor(value);
      if (!this._isAlphaWanted()) {
        this._color.a = 1;
      }
    } else {
      this._color.h = this.state.h;
      this._color.s = this.state.s;
      this._color.l = this.state.l;
      this._color.a = this.state.a;
    }
  }
  _updateInput(step) {
    if (step !== "init" && !this.props.updateInput.includes(step)) {
      return;
    }
    switch (this.props.format) {
      case "hex":
        this.state.value = this._color.toHexString();
        break;
      case "hexa":
        this.state.value = this._color.toHexaString();
        break;
      case "rgb":
        this.state.value = this._color.toRgbString();
        break;
      case "rgba":
        this.state.value = this._color.toRgbaString();
        break;
      case "hsl":
        this.state.value = this._color.toHslString();
        break;
      case "hsla":
        this.state.value = this._color.toHslaString();
        break;
    }
    if (this._$input && this._$input.value !== this.state.value) {
      this._$input.value = this.state.value;
    }
    if (step !== "init") {
      this.componentUtils.dispatchEvent("change", {
        detail: this._color.toObject()
      });
    }
    this.requestUpdate();
  }
  _restoreState() {
    this._setAlpha(this._color.a);
    this._setHue(this._color.h);
    this._setShade(this._color.s, this._color.l);
  }
  _setMetasFormat(format2) {
    this.state.metasFormat = format2;
    this.requestUpdate();
    return false;
  }
  _validate() {
    var _a3, _b2;
    this._updateInput("validate");
    (_b2 = (_a3 = document.activeElement) === null || _a3 === void 0 ? void 0 : _a3.blur) === null || _b2 === void 0 ? void 0 : _b2.call(_a3);
  }
  _clear() {
    if (this._inputColor) {
      this._setAlpha(this._inputColor.a);
      this._setHue(this._inputColor.h);
      this._setShade(this._inputColor.s, this._inputColor.l);
    } else {
      this._setAlpha(1);
      this._setHue(0);
      this._setShade(0, 0);
    }
    this._updateInput("clear");
  }
  _reset() {
    this._setAlpha(this._originalState.a);
    this._setHue(this._originalState.h);
    this._setShade(this._originalState.s, this._originalState.l);
    this._updateInput("reset");
  }
  _isAlphaWanted() {
    return this.props.format.includes("a");
  }
  _initSelectionInteractions() {
    let isShadeDown = false;
    this._$shade.addEventListener("pointerdown", (e) => {
      isShadeDown = true;
      this._isShadeInInteraction = true;
      this._$shade.setPointerCapture(e.pointerId);
      this._setShadeFromEvent(e, false);
      this._updateInput("pointerdown");
      this.requestUpdate();
    });
    this._$shade.addEventListener("pointermove", (e) => {
      e.preventDefault();
      if (!isShadeDown)
        return;
      this._setShadeFromEvent(e, false);
      this._updateInput("pointermove");
    });
    this._$shade.addEventListener("pointerup", (e) => {
      isShadeDown = false;
      this._isShadeInInteraction = false;
      this._$shade.releasePointerCapture(e.pointerId);
      this._setShadeFromEvent(e, true);
      this._updateInput("pointerup");
      this.requestUpdate();
    });
    let isAlphaDown = false;
    this._$alpha.addEventListener("pointerdown", (e) => {
      isAlphaDown = true;
      this._isAlphaInInteraction = true;
      this._$alpha.setPointerCapture(e.pointerId);
      this._setAlphaFromEvent(e, false);
      this._updateInput("pointerdown");
      this.requestUpdate();
    });
    this._$alpha.addEventListener("pointermove", (e) => {
      e.preventDefault();
      if (!isAlphaDown)
        return;
      this._setAlphaFromEvent(e, false);
      this._updateInput("pointermove");
    });
    this._$alpha.addEventListener("pointerup", (e) => {
      isAlphaDown = false;
      this._isAlphaInInteraction = false;
      this._$alpha.releasePointerCapture(e.pointerId);
      this._setAlphaFromEvent(e, true);
      this._updateInput("pointerup");
      this.requestUpdate();
    });
  }
  _setHueFromEvent(e, saveState = true) {
    const bounds = e.target.getBoundingClientRect();
    const y = e.clientY - bounds.top;
    const pY = 100 - Math.round(100 / bounds.height * y);
    let hue = 360 - Math.round(360 / 100 * pY);
    if (hue < 0)
      hue = 0;
    if (hue > 360)
      hue = 360;
    this._setHue(hue, saveState);
  }
  _setHue(h2, saveState = true) {
    if (saveState) {
      this.state.h = h2;
    }
    this._color.h = h2;
    this.style.setProperty("--s-color-picker-h", h2);
    this._updateShadeCanvas();
    this._updateAlphaSelector();
    this.requestUpdate();
  }
  _setShadeFromEvent(e, saveState = true) {
    const bounds = e.target.getBoundingClientRect();
    const y = e.clientY - bounds.top, x2 = e.clientX - bounds.left;
    let pY = 100 - Math.round(100 / bounds.height * y), pX = Math.round(100 / bounds.width * x2);
    if (pY < 0)
      pY = 0;
    if (pY > 100)
      pY = 100;
    if (pX < 0)
      pX = 0;
    if (pX > 100)
      pX = 100;
    this._setShade(pX, pY * 0.5, saveState);
  }
  _setShade(s2, l, saveState = true) {
    let lightness = l + (100 - s2) / 2;
    lightness *= l * 2 / 100;
    let saturation = s2;
    if (saveState) {
      this.state.s = saturation;
      this.state.l = lightness;
    }
    this._color.s = saturation;
    this._color.l = lightness;
    this.style.setProperty("--s-color-picker-shade-x", s2);
    this.style.setProperty("--s-color-picker-shade-y", l * 2 > 100 ? 100 : l * 2);
    this.style.setProperty("--s-color-picker-s", saturation);
    this.style.setProperty("--s-color-picker-l", lightness);
    this._updateShadeCanvas();
    this.requestUpdate();
  }
  _setAlphaFromEvent(e, saveState = true) {
    const bounds = e.target.getBoundingClientRect();
    const y = e.clientY - bounds.top;
    let pY = 100 - Math.round(100 / bounds.height * y);
    if (pY < 0)
      pY = 0;
    if (pY > 100)
      pY = 100;
    this._setAlpha(pY / 100, saveState);
  }
  _setAlpha(a3, saveState = true) {
    if (saveState) {
      this.state.a = a3;
    }
    this._color.a = a3;
    this.style.setProperty("--s-color-picker-a", a3);
    this._updateAlphaSelector();
    this.requestUpdate();
  }
  _copy() {
    const originalClass = this.props.copyIconClass;
    this.props.copyIconClass = this.props.copiedIconClass;
    copy(this._$colorInput.value);
    setTimeout(() => {
      this.props.copyIconClass = originalClass;
    }, 1e3);
  }
  _eyeDropper() {
    return __awaiter$5(this, void 0, void 0, function* () {
      const eyeDropper = new EyeDropper();
      const result2 = yield eyeDropper.open();
      if (!result2.sRGBHex) {
        return;
      }
      const newColor = new SColor(result2.sRGBHex);
      this._setAlpha(1);
      this._setHue(newColor.h);
      this._setShade(newColor.s, newColor.l);
      this._updateInput("eyedropper");
    });
  }
  _initHueSelector() {
    const bounds = this._$hue.getBoundingClientRect();
    this._hueCtx.canvas.width = bounds.width;
    this._hueCtx.canvas.height = bounds.height;
    const gradientH = this._hueCtx.createLinearGradient(0, 0, 0, bounds.height);
    gradientH.addColorStop(0, "rgb(255, 0, 0)");
    gradientH.addColorStop(1 / 6, "rgb(255, 255, 0)");
    gradientH.addColorStop(2 / 6, "rgb(0, 255, 0)");
    gradientH.addColorStop(3 / 6, "rgb(0, 255, 255)");
    gradientH.addColorStop(4 / 6, "rgb(0, 0, 255)");
    gradientH.addColorStop(5 / 6, "rgb(255, 0, 255)");
    gradientH.addColorStop(1, "rgb(255, 0, 0)");
    this._hueCtx.fillStyle = gradientH;
    this._hueCtx.fillRect(0, 0, bounds.width * 3, bounds.height);
    let isHueDown = false;
    this._$hue.addEventListener("pointerdown", (e) => {
      isHueDown = true;
      this._isHueInInteraction = true;
      this.requestUpdate();
      this._$hue.setPointerCapture(e.pointerId);
      this._setHueFromEvent(e, false);
      this._updateInput("pointerdown");
    });
    this._$hue.addEventListener("pointermove", (e) => {
      e.preventDefault();
      if (!isHueDown)
        return;
      this._setHueFromEvent(e);
      this._updateInput("pointermove", false);
    });
    this._$hue.addEventListener("pointerup", (e) => {
      isHueDown = false;
      this._isHueInInteraction = false;
      this.requestUpdate();
      this._$hue.releasePointerCapture(e.pointerId);
      this._setHueFromEvent(e, true);
      this._updateInput("pointerup", true);
    });
  }
  _updateAlphaSelector() {
    const bounds = this._$alpha.getBoundingClientRect();
    this._alphaCtx.canvas.width = bounds.width;
    this._alphaCtx.canvas.height = bounds.height;
    const gradientH = this._alphaCtx.createLinearGradient(0, 0, 0, bounds.height);
    gradientH.addColorStop(0, `rgba(${this._hueColor.r}, ${this._hueColor.g}, ${this._hueColor.b}, 1)`);
    gradientH.addColorStop(1, `rgba(${this._hueColor.r}, ${this._hueColor.g}, ${this._hueColor.b}, 0)`);
    this._alphaCtx.fillStyle = gradientH;
    this._alphaCtx.fillRect(0, 0, bounds.width * 3, bounds.height);
  }
  _updateShadeCanvas() {
    let gradientH = this._shadeCtx.createLinearGradient(0, 0, this._shadeCtx.canvas.width, 0);
    const newColor = this._color.clone();
    newColor.s = 100;
    newColor.l = 50;
    gradientH.addColorStop(0, "#fff");
    gradientH.addColorStop(1, newColor.toHex());
    this._shadeCtx.fillStyle = gradientH;
    this._shadeCtx.fillRect(0, 0, this._shadeCtx.canvas.width, this._shadeCtx.canvas.height);
    const gradientV = this._shadeCtx.createLinearGradient(0, 0, 0, this._shadeCtx.canvas.height);
    gradientV.addColorStop(0, "rgba(0,0,0,0)");
    gradientV.addColorStop(1, "#000");
    this._shadeCtx.fillStyle = gradientV;
    this._shadeCtx.fillRect(0, 0, this._shadeCtx.canvas.width, this._shadeCtx.canvas.height);
  }
  render() {
    var _a3, _b2, _c2;
    return html`
            <div
                class="${this.componentUtils.className("__root")} ${this.componentUtils.className("")}--${this.props.floatSettings.position} ${this._isShadeInInteraction ? "is-shade-interacting" : ""} ${this._isAlphaInInteraction ? "is-alpha-interacting" : ""} ${this._isHueInInteraction ? "is-hue-interacting" : ""}"
            >
                ${this.props.backdrop ? html`
                          <div
                              class="${this.componentUtils.className("__backdrop")} ${this.props.backdropClass}"
                          ></div>
                      ` : ""}
                <div
                    class="${this.componentUtils.className("__picker")}"
                    tabindex="-1"
                >
                    <div
                        class="${this.componentUtils.className("__selectors")}"
                    >
                        <div
                            class="${this.componentUtils.className("__shade-wrapper")}"
                        >
                            <div
                                class="${this.componentUtils.className("__chest")}"
                            ></div>
                            <canvas
                                class="${this.componentUtils.className("__shade")}"
                                style="opacity: ${this._color.a}"
                            ></canvas>
                        </div>
                        <div
                            class="${this.componentUtils.className("__hue-wrapper")}"
                        >
                            <div
                                class="${this.componentUtils.className("__chest")}"
                            ></div>
                            <canvas
                                class="${this.componentUtils.className("__hue")}"
                            ></canvas>
                        </div>
                        <div
                            class="${this.componentUtils.className("__alpha-wrapper")} ${this._isAlphaWanted() ? "active" : ""}"
                        >
                            <div
                                class="${this.componentUtils.className("__chest")}"
                            ></div>
                            <canvas
                                class="${this.componentUtils.className("__alpha")}"
                            ></canvas>
                        </div>
                    </div>

                    <div class="${this.componentUtils.className("__metas")}">
                        <div
                            class="${this.componentUtils.className("__formats")}"
                        >
                            <button
                                class="${this.componentUtils.className("__btn")} ${this.componentUtils.className("__hex-btn")} ${this.state.metasFormat === "hex" ? "active" : ""}"
                                @click=${(e) => e.preventDefault()}
                                @pointerup=${(e) => {
      e.preventDefault();
      this._setMetasFormat("hex");
    }}
                            >
                                HEX${this._isAlphaWanted() ? "A" : ""}
                            </button>
                            <button
                                class="${this.componentUtils.className("__btn")} ${this.componentUtils.className("__rgb-btn")} ${this.state.metasFormat === "rgb" ? "active" : ""}"
                                @click=${(e) => e.preventDefault()}
                                @pointerup=${(e) => {
      e.preventDefault();
      this._setMetasFormat("rgb");
    }}
                            >
                                RGB${this._isAlphaWanted() ? "A" : ""}
                            </button>
                            <button
                                class="${this.componentUtils.className("__btn")} ${this.componentUtils.className("__hsl-btn")} ${this.state.metasFormat === "hsl" ? "active" : ""}"
                                @click=${(e) => e.preventDefault()}
                                @pointerup=${(e) => {
      e.preventDefault();
      this._setMetasFormat("hsl");
    }}
                            >
                                HSL${this._isAlphaWanted() ? "A" : ""}
                            </button>
                        </div>
                        <div
                            class="${this.componentUtils.className("__color")}"
                        >
                            <input
                                type="text"
                                readonly
                                class="${this.componentUtils.className("__color-input")}"
                                value="${this.state.metasFormat === "hex" ? this._isAlphaWanted() ? this._color.toHexaString() : this._color.toHexString() : this.state.metasFormat === "rgb" ? this._isAlphaWanted() ? this._color.toRgbaString() : this._color.toRgbString() : this._isAlphaWanted() ? this._color.toHslaString() : this._color.toHslString()}"
                            />
                            <div
                                class="${this.componentUtils.className("__preview")} "
                                @pointerup=${() => this._copy()}
                            >
                                ${this.props.copyIconClass ? html`
                                          <i
                                              class="${this.props.copyIconClass}"
                                          ></i>
                                      ` : ""}
                            </div>
                            ${this.props.eyeDropper && window.EyeDropper ? html`
                                      <div
                                          class="${this.componentUtils.className("__eye-dropper")} "
                                          @pointerup=${() => this._eyeDropper()}
                                      >
                                          ${this.props.eyeDropperIconClass ? html`
                                                    <i
                                                        class="${this.props.eyeDropperIconClass}"
                                                    ></i>
                                                ` : ""}
                                      </div>
                                  ` : ""}
                        </div>
                    </div>
                    ${this.props.actions.length ? html`
                              <div
                                  class="${this.componentUtils.className("__actions")}"
                              >
                                  ${this.props.actions.includes("clear") ? html`
                                            <button
                                                class="${this.componentUtils.className("__clear", "s-btn s-color--error")}"
                                                @click=${(e) => e.preventDefault()}
                                                @pointerup=${(e) => {
      e.preventDefault();
      this._clear();
    }}
                                            >
                                                ${(_a3 = this.props.i18n.clear) !== null && _a3 !== void 0 ? _a3 : "Clear"}
                                            </button>
                                        ` : ""}
                                  ${this.props.actions.includes("reset") ? html`
                                            <button
                                                class="${this.componentUtils.className("__reset", "s-btn s-color--complementary")}"
                                                @click=${(e) => e.preventDefault()}
                                                @pointerup=${(e) => {
      e.preventDefault();
      this._reset();
    }}
                                            >
                                                ${(_b2 = this.props.i18n.reset) !== null && _b2 !== void 0 ? _b2 : "Reset"}
                                            </button>
                                        ` : ""}
                                  ${this.props.actions.includes("validate") ? html`
                                            <button
                                                class="${this.componentUtils.className("__validate", "s-btn s-color--accent")}"
                                                @click=${(e) => e.preventDefault()}
                                                @pointerup=${(e) => {
      e.preventDefault();
      this._validate();
    }}
                                            >
                                                ${(_c2 = this.props.i18n.validate) !== null && _c2 !== void 0 ? _c2 : "Validate"}
                                            </button>
                                        ` : ""}
                              </div>
                          ` : ""}
                </div>
            </div>
        `;
  }
}
function isDate(value) {
  return value instanceof Date || Object.prototype.toString.call(value) === "[object Date]";
}
function toDate(value) {
  if (isDate(value)) {
    return new Date(value.getTime());
  }
  if (value == null) {
    return new Date(NaN);
  }
  return new Date(value);
}
function isValidDate(value) {
  return isDate(value) && !isNaN(value.getTime());
}
function startOfWeek(value) {
  var firstDayOfWeek = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  if (!(firstDayOfWeek >= 0 && firstDayOfWeek <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6");
  }
  var date = toDate(value);
  var day = date.getDay();
  var diff = (day + 7 - firstDayOfWeek) % 7;
  date.setDate(date.getDate() - diff);
  date.setHours(0, 0, 0, 0);
  return date;
}
function startOfWeekYear(value) {
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$firstDayOfWeek = _ref.firstDayOfWeek, firstDayOfWeek = _ref$firstDayOfWeek === void 0 ? 0 : _ref$firstDayOfWeek, _ref$firstWeekContain = _ref.firstWeekContainsDate, firstWeekContainsDate = _ref$firstWeekContain === void 0 ? 1 : _ref$firstWeekContain;
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7");
  }
  var date = toDate(value);
  var year = date.getFullYear();
  var firstDateOfFirstWeek = new Date(0);
  for (var i2 = year + 1; i2 >= year - 1; i2--) {
    firstDateOfFirstWeek.setFullYear(i2, 0, firstWeekContainsDate);
    firstDateOfFirstWeek.setHours(0, 0, 0, 0);
    firstDateOfFirstWeek = startOfWeek(firstDateOfFirstWeek, firstDayOfWeek);
    if (date.getTime() >= firstDateOfFirstWeek.getTime()) {
      break;
    }
  }
  return firstDateOfFirstWeek;
}
function getWeek(value) {
  var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref2$firstDayOfWeek = _ref2.firstDayOfWeek, firstDayOfWeek = _ref2$firstDayOfWeek === void 0 ? 0 : _ref2$firstDayOfWeek, _ref2$firstWeekContai = _ref2.firstWeekContainsDate, firstWeekContainsDate = _ref2$firstWeekContai === void 0 ? 1 : _ref2$firstWeekContai;
  var date = toDate(value);
  var firstDateOfThisWeek = startOfWeek(date, firstDayOfWeek);
  var firstDateOfFirstWeek = startOfWeekYear(date, {
    firstDayOfWeek,
    firstWeekContainsDate
  });
  var diff = firstDateOfThisWeek.getTime() - firstDateOfFirstWeek.getTime();
  return Math.round(diff / (7 * 24 * 3600 * 1e3)) + 1;
}
var locale = {
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  weekdaysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  firstDayOfWeek: 0,
  firstWeekContainsDate: 1
};
var REGEX_FORMAT = /\[([^\]]+)]|YYYY|YY?|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|m{1,2}|s{1,2}|Z{1,2}|S{1,3}|w{1,2}|x|X|a|A/g;
function pad(val) {
  var len = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
  var output = "".concat(Math.abs(val));
  var sign2 = val < 0 ? "-" : "";
  while (output.length < len) {
    output = "0".concat(output);
  }
  return sign2 + output;
}
function getOffset(date) {
  return Math.round(date.getTimezoneOffset() / 15) * 15;
}
function formatTimezone(offset2) {
  var delimeter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  var sign2 = offset2 > 0 ? "-" : "+";
  var absOffset = Math.abs(offset2);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  return sign2 + pad(hours, 2) + delimeter + pad(minutes, 2);
}
var meridiem = function meridiem2(h2, _, isLowercase) {
  var word = h2 < 12 ? "AM" : "PM";
  return isLowercase ? word.toLocaleLowerCase() : word;
};
var formatFlags = {
  Y: function Y2(date) {
    var y = date.getFullYear();
    return y <= 9999 ? "".concat(y) : "+".concat(y);
  },
  YY: function YY(date) {
    return pad(date.getFullYear(), 4).substr(2);
  },
  YYYY: function YYYY(date) {
    return pad(date.getFullYear(), 4);
  },
  M: function M(date) {
    return date.getMonth() + 1;
  },
  MM: function MM(date) {
    return pad(date.getMonth() + 1, 2);
  },
  MMM: function MMM(date, locale2) {
    return locale2.monthsShort[date.getMonth()];
  },
  MMMM: function MMMM(date, locale2) {
    return locale2.months[date.getMonth()];
  },
  D: function D(date) {
    return date.getDate();
  },
  DD: function DD2(date) {
    return pad(date.getDate(), 2);
  },
  H: function H2(date) {
    return date.getHours();
  },
  HH: function HH(date) {
    return pad(date.getHours(), 2);
  },
  h: function h(date) {
    var hours = date.getHours();
    if (hours === 0) {
      return 12;
    }
    if (hours > 12) {
      return hours % 12;
    }
    return hours;
  },
  hh: function hh() {
    var hours = formatFlags.h.apply(formatFlags, arguments);
    return pad(hours, 2);
  },
  m: function m(date) {
    return date.getMinutes();
  },
  mm: function mm2(date) {
    return pad(date.getMinutes(), 2);
  },
  s: function s(date) {
    return date.getSeconds();
  },
  ss: function ss2(date) {
    return pad(date.getSeconds(), 2);
  },
  S: function S(date) {
    return Math.floor(date.getMilliseconds() / 100);
  },
  SS: function SS(date) {
    return pad(Math.floor(date.getMilliseconds() / 10), 2);
  },
  SSS: function SSS(date) {
    return pad(date.getMilliseconds(), 3);
  },
  d: function d3(date) {
    return date.getDay();
  },
  dd: function dd2(date, locale2) {
    return locale2.weekdaysMin[date.getDay()];
  },
  ddd: function ddd(date, locale2) {
    return locale2.weekdaysShort[date.getDay()];
  },
  dddd: function dddd(date, locale2) {
    return locale2.weekdays[date.getDay()];
  },
  A: function A(date, locale2) {
    var meridiemFunc = locale2.meridiem || meridiem;
    return meridiemFunc(date.getHours(), date.getMinutes(), false);
  },
  a: function a2(date, locale2) {
    var meridiemFunc = locale2.meridiem || meridiem;
    return meridiemFunc(date.getHours(), date.getMinutes(), true);
  },
  Z: function Z2(date) {
    return formatTimezone(getOffset(date), ":");
  },
  ZZ: function ZZ(date) {
    return formatTimezone(getOffset(date));
  },
  X: function X2(date) {
    return Math.floor(date.getTime() / 1e3);
  },
  x: function x(date) {
    return date.getTime();
  },
  w: function w(date, locale2) {
    return getWeek(date, {
      firstDayOfWeek: locale2.firstDayOfWeek,
      firstWeekContainsDate: locale2.firstWeekContainsDate
    });
  },
  ww: function ww(date, locale2) {
    return pad(formatFlags.w(date, locale2), 2);
  }
};
function format(val, str2) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var formatStr = str2 ? String(str2) : "YYYY-MM-DDTHH:mm:ss.SSSZ";
  var date = toDate(val);
  if (!isValidDate(date)) {
    return "Invalid Date";
  }
  var locale$1 = options.locale || locale;
  return formatStr.replace(REGEX_FORMAT, function(match5, p1) {
    if (p1) {
      return p1;
    }
    if (typeof formatFlags[match5] === "function") {
      return "".concat(formatFlags[match5](date, locale$1));
    }
    return match5;
  });
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]")
    return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i2 = 0, arr2 = new Array(arr.length); i2 < arr.length; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  }
}
function ownKeys(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys(source2, true).forEach(function(key) {
        _defineProperty(target, key, source2[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
    } else {
      ownKeys(source2).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
      });
    }
  }
  return target;
}
function _slicedToArray(arr, i2) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit(arr, i2) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }
  var _arr = [];
  var _n2 = true;
  var _d2 = false;
  var _e2 = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s2; !(_n2 = (_s2 = _i.next()).done); _n2 = true) {
      _arr.push(_s2.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err) {
    _d2 = true;
    _e2 = err;
  } finally {
    try {
      if (!_n2 && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d2)
        throw _e2;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _defineProperty(obj2, key, value) {
  if (key in obj2) {
    Object.defineProperty(obj2, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj2[key] = value;
  }
  return obj2;
}
var formattingTokens = /(\[[^\[]*\])|(MM?M?M?|Do|DD?|ddd?d?|w[o|w]?|YYYY|YY|a|A|hh?|HH?|mm?|ss?|S{1,3}|x|X|ZZ?|.)/g;
var match1 = /\d/;
var match2 = /\d\d/;
var match3 = /\d{3}/;
var match4 = /\d{4}/;
var match1to2 = /\d\d?/;
var matchShortOffset = /[+-]\d\d:?\d\d/;
var matchSigned = /[+-]?\d+/;
var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
var YEAR = "year";
var MONTH = "month";
var DAY = "day";
var HOUR = "hour";
var MINUTE = "minute";
var SECOND = "second";
var MILLISECOND = "millisecond";
var parseFlags = {};
var addParseFlag = function addParseFlag2(token, regex2, callback) {
  var tokens = Array.isArray(token) ? token : [token];
  var func;
  if (typeof callback === "string") {
    func = function func2(input) {
      var value = parseInt(input, 10);
      return _defineProperty({}, callback, value);
    };
  } else {
    func = callback;
  }
  tokens.forEach(function(key) {
    parseFlags[key] = [regex2, func];
  });
};
var escapeStringRegExp = function escapeStringRegExp2(str2) {
  return str2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
};
var matchWordRegExp = function matchWordRegExp2(localeKey) {
  return function(locale2) {
    var array = locale2[localeKey];
    if (!Array.isArray(array)) {
      throw new Error("Locale[".concat(localeKey, "] need an array"));
    }
    return new RegExp(array.map(escapeStringRegExp).join("|"));
  };
};
var matchWordCallback = function matchWordCallback2(localeKey, key) {
  return function(input, locale2) {
    var array = locale2[localeKey];
    if (!Array.isArray(array)) {
      throw new Error("Locale[".concat(localeKey, "] need an array"));
    }
    var index = array.indexOf(input);
    if (index < 0) {
      throw new Error("Invalid Word");
    }
    return _defineProperty({}, key, index);
  };
};
addParseFlag("Y", matchSigned, YEAR);
addParseFlag("YY", match2, function(input) {
  var year = new Date().getFullYear();
  var cent = Math.floor(year / 100);
  var value = parseInt(input, 10);
  value = (value > 68 ? cent - 1 : cent) * 100 + value;
  return _defineProperty({}, YEAR, value);
});
addParseFlag("YYYY", match4, YEAR);
addParseFlag("M", match1to2, function(input) {
  return _defineProperty({}, MONTH, parseInt(input, 10) - 1);
});
addParseFlag("MM", match2, function(input) {
  return _defineProperty({}, MONTH, parseInt(input, 10) - 1);
});
addParseFlag("MMM", matchWordRegExp("monthsShort"), matchWordCallback("monthsShort", MONTH));
addParseFlag("MMMM", matchWordRegExp("months"), matchWordCallback("months", MONTH));
addParseFlag("D", match1to2, DAY);
addParseFlag("DD", match2, DAY);
addParseFlag(["H", "h"], match1to2, HOUR);
addParseFlag(["HH", "hh"], match2, HOUR);
addParseFlag("m", match1to2, MINUTE);
addParseFlag("mm", match2, MINUTE);
addParseFlag("s", match1to2, SECOND);
addParseFlag("ss", match2, SECOND);
addParseFlag("S", match1, function(input) {
  return _defineProperty({}, MILLISECOND, parseInt(input, 10) * 100);
});
addParseFlag("SS", match2, function(input) {
  return _defineProperty({}, MILLISECOND, parseInt(input, 10) * 10);
});
addParseFlag("SSS", match3, MILLISECOND);
function matchMeridiem(locale2) {
  return locale2.meridiemParse || /[ap]\.?m?\.?/i;
}
function defaultIsPM(input) {
  return "".concat(input).toLowerCase().charAt(0) === "p";
}
addParseFlag(["A", "a"], matchMeridiem, function(input, locale2) {
  var isPM = typeof locale2.isPM === "function" ? locale2.isPM(input) : defaultIsPM(input);
  return {
    isPM
  };
});
function offsetFromString(str2) {
  var _ref8 = str2.match(/([+-]|\d\d)/g) || ["-", "0", "0"], _ref9 = _slicedToArray(_ref8, 3), symbol = _ref9[0], hour = _ref9[1], minute = _ref9[2];
  var minutes = parseInt(hour, 10) * 60 + parseInt(minute, 10);
  if (minutes === 0) {
    return 0;
  }
  return symbol === "+" ? -minutes : +minutes;
}
addParseFlag(["Z", "ZZ"], matchShortOffset, function(input) {
  return {
    offset: offsetFromString(input)
  };
});
addParseFlag("x", matchSigned, function(input) {
  return {
    date: new Date(parseInt(input, 10))
  };
});
addParseFlag("X", matchTimestamp, function(input) {
  return {
    date: new Date(parseFloat(input) * 1e3)
  };
});
addParseFlag("d", match1, "weekday");
addParseFlag("dd", matchWordRegExp("weekdaysMin"), matchWordCallback("weekdaysMin", "weekday"));
addParseFlag("ddd", matchWordRegExp("weekdaysShort"), matchWordCallback("weekdaysShort", "weekday"));
addParseFlag("dddd", matchWordRegExp("weekdays"), matchWordCallback("weekdays", "weekday"));
addParseFlag("w", match1to2, "week");
addParseFlag("ww", match2, "week");
function to24hour(hour, isPM) {
  if (hour !== void 0 && isPM !== void 0) {
    if (isPM) {
      if (hour < 12) {
        return hour + 12;
      }
    } else if (hour === 12) {
      return 0;
    }
  }
  return hour;
}
function getFullInputArray(input) {
  var backupDate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Date();
  var result2 = [0, 0, 1, 0, 0, 0, 0];
  var backupArr = [backupDate.getFullYear(), backupDate.getMonth(), backupDate.getDate(), backupDate.getHours(), backupDate.getMinutes(), backupDate.getSeconds(), backupDate.getMilliseconds()];
  var useBackup = true;
  for (var i2 = 0; i2 < 7; i2++) {
    if (input[i2] === void 0) {
      result2[i2] = useBackup ? backupArr[i2] : result2[i2];
    } else {
      result2[i2] = input[i2];
      useBackup = false;
    }
  }
  return result2;
}
function createDate(y, m2, d4, h2, M2, s2, ms2) {
  var date;
  if (y < 100 && y >= 0) {
    date = new Date(y + 400, m2, d4, h2, M2, s2, ms2);
    if (isFinite(date.getFullYear())) {
      date.setFullYear(y);
    }
  } else {
    date = new Date(y, m2, d4, h2, M2, s2, ms2);
  }
  return date;
}
function createUTCDate() {
  var date;
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var y = args[0];
  if (y < 100 && y >= 0) {
    args[0] += 400;
    date = new Date(Date.UTC.apply(Date, args));
    if (isFinite(date.getUTCFullYear())) {
      date.setUTCFullYear(y);
    }
  } else {
    date = new Date(Date.UTC.apply(Date, args));
  }
  return date;
}
function makeParser(dateString, format2, locale2) {
  var tokens = format2.match(formattingTokens);
  if (!tokens) {
    throw new Error();
  }
  var length = tokens.length;
  var mark = {};
  for (var i2 = 0; i2 < length; i2 += 1) {
    var token = tokens[i2];
    var parseTo = parseFlags[token];
    if (!parseTo) {
      var word = token.replace(/^\[|\]$/g, "");
      if (dateString.indexOf(word) === 0) {
        dateString = dateString.substr(word.length);
      } else {
        throw new Error("not match");
      }
    } else {
      var regex2 = typeof parseTo[0] === "function" ? parseTo[0](locale2) : parseTo[0];
      var parser = parseTo[1];
      var value = (regex2.exec(dateString) || [])[0];
      var obj2 = parser(value, locale2);
      mark = _objectSpread({}, mark, {}, obj2);
      dateString = dateString.replace(value, "");
    }
  }
  return mark;
}
function parse(str2, format2) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  try {
    var _options$locale = options.locale, _locale = _options$locale === void 0 ? locale : _options$locale, _options$backupDate = options.backupDate, backupDate = _options$backupDate === void 0 ? new Date() : _options$backupDate;
    var parseResult = makeParser(str2, format2, _locale);
    var year = parseResult.year, month = parseResult.month, day = parseResult.day, hour = parseResult.hour, minute = parseResult.minute, second = parseResult.second, millisecond = parseResult.millisecond, isPM = parseResult.isPM, date = parseResult.date, offset2 = parseResult.offset, weekday = parseResult.weekday, week = parseResult.week;
    if (date) {
      return date;
    }
    var inputArray = [year, month, day, hour, minute, second, millisecond];
    inputArray[3] = to24hour(inputArray[3], isPM);
    if (week !== void 0 && month === void 0 && day === void 0) {
      var firstDate = startOfWeekYear(year === void 0 ? backupDate : new Date(year, 3), {
        firstDayOfWeek: _locale.firstDayOfWeek,
        firstWeekContainsDate: _locale.firstWeekContainsDate
      });
      return new Date(firstDate.getTime() + (week - 1) * 7 * 24 * 3600 * 1e3);
    }
    var parsedDate;
    var result2 = getFullInputArray(inputArray, backupDate);
    if (offset2 !== void 0) {
      result2[6] += offset2 * 60 * 1e3;
      parsedDate = createUTCDate.apply(void 0, _toConsumableArray(result2));
    } else {
      parsedDate = createDate.apply(void 0, _toConsumableArray(result2));
    }
    if (weekday !== void 0 && parsedDate.getDay() !== weekday) {
      return new Date(NaN);
    }
    return parsedDate;
  } catch (e) {
    return new Date(NaN);
  }
}
class SDatetimePickerComponentInterface extends SInterface {
  static get _definition() {
    return {
      name: {
        description: "Specify the name that will be assigned to the injected input if you don't provide one yourself",
        type: "String",
        default: "color"
      },
      value: {
        description: "Specify the initial value for your picker",
        type: "String"
      },
      updateInput: {
        description: 'Specify when you want to updat the attached input. Can be "pointermove", "pointerup", "pointerdown", "input", "validate", "close"',
        type: {
          type: "Array<String>",
          splitChars: [","]
        },
        values: ["select", "validate", "reset", "clear", "close"],
        default: ["select", "validate", "reset", "clear", "close"]
      },
      format: {
        description: 'Specify the format of the color you want as end in the input value. Can be "hex", "hexa", "rgb", "rgba", "hsl" or "hsla"',
        type: "String",
        default: "YYYY-MM-DD"
      },
      inline: {
        description: "Specify if you want to initalize the color picker inline or if you want it to be displayed only when the focus is in the input",
        type: "Boolean",
        default: false,
        physical: true
      },
      calendar: {
        description: "Specify if you want to display a calendar or not",
        type: "Boolean",
        default: false,
        physical: true
      },
      i18n: {
        description: 'Specify some translations for the color picker. You can translate the "reset", "clear" and "validate" buttons',
        type: "Object",
        default: {
          reset: "Reset",
          clear: "Clear",
          validate: "Validate",
          months: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ]
        }
      },
      placeholder: {
        description: "Specify the placeholder that will be assigned to the injected input if you don't provide one yourself",
        type: "String",
        default: "Select a color"
      },
      floatSettings: {
        description: 'Specify some float settings to pass to the "makeFloat" function of the sugar toolkit',
        type: "Object",
        default: {}
      },
      copyIconClass: {
        description: 'Specify the class you want to apply on the "i" that display the "copy" icon',
        type: "String",
        default: "s-icon s-icon--copy"
      },
      copiedIconClass: {
        description: 'Specify the class you want to apply on the "i" that display the "copy" icon when the color has been copied',
        type: "String",
        default: "s-icon s-icon--copied"
      },
      buttonIconClass: {
        description: "Specify the class you want to apply on the injected button icon",
        type: "String",
        default: "s-icon s-icon--color"
      },
      backdropClass: {
        description: 'Specify the class to apply on the backdrop when the "backdrop" prop is true',
        type: "String",
        default: "s-backdrop"
      },
      disable: {
        description: 'Specify what you want to disable. It can be "weekend", "week" or "2022-12-19" (dates)',
        type: {
          type: "Array<String>",
          splitChars: [",", " "]
        },
        default: []
      },
      disabled: {
        description: "Specify if the color picker is disabled",
        type: "Boolean",
        default: false
      },
      backdrop: {
        description: 'Specify if you want the ".s-backdrop" element or not',
        type: "Boolean",
        default: false
      },
      actions: {
        description: 'Specify the actions buttons you want to display. Can be "clear", "reset" and "validate". If false, hide all button',
        type: {
          type: "Array<String>",
          splitChars: [",", " "]
        },
        values: ["clear", "reset", "validate"],
        default: ["reset", "validate"]
      },
      hours: {
        description: "Specify the hours you want in the time selector",
        type: "Array<Number>",
        default: [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23
        ]
      },
      minutes: {
        description: "Specify the minutes you want in the time selector",
        type: "Array<Number>",
        default: [0, 5, 10, 15, 20, 25, 30, 25, 40, 45, 50, 55]
      },
      fromYear: {
        description: "Specify the first year to allow selection from",
        type: "Number",
        default: new Date().getFullYear() - 100
      },
      toYear: {
        description: "Specify the last year to allow selection from",
        type: "Number",
        default: new Date().getFullYear() + 100
      }
    };
  }
}
const __css$6 = ".s-datetime-picker {\n    display: inline-block;\n    position: relative;\n}\n\n    .s-datetime-picker[disabled] {\n        pointer-events: none;\n    }\n\n    .s-datetime-picker .s-backdrop {\n        pointer-events: none;\n        opacity: 0;\n    }\n\n    .s-datetime-picker .s-datetime-picker__root {\n        width: 100%;\n    }\n\n    .s-datetime-picker .s-datetime-picker__root.is-interacting * {\n            cursor: none !important;\n        }\n\n    .s-datetime-picker .s-datetime-picker__picker {\n        position: absolute;\n        top: 100%;\n        left: 0;\n        z-index: 200;\n        max-width: 100vw;\n        display: flex;\n        flex-direction: column;\n        pointer-events: none;\n        opacity: 0;\n    }\n\n    @media screen and (max-width: 639px) {\n\n    .s-datetime-picker .s-datetime-picker__picker {\n            position: fixed;\n            bottom: 0;\n            top: auto !important;\n            left: 0 !important;\n            right: auto;\n            width: 100vw;\n            transform: translate(0, 100%)\n    }\n}\n\n    .s-datetime-picker[inline] .s-datetime-picker__picker {\n        position: unset;\n        top: unset;\n        left: unset;\n        background: unset;\n        pointer-events: all;\n        opacity: 1;\n    }\n\n    .s-datetime-picker .s-datetime-picker__actions {\n        display: flex;\n    }\n\n    .s-datetime-picker .s-datetime-picker__actions button {\n            flex-grow: 1;\n            text-align: center;\n        }\n\n    .s-datetime-picker:focus-within .s-datetime-picker__picker {\n            opacity: 1;\n            pointer-events: all;\n        }\n\n    .s-datetime-picker:focus-within .s-backdrop {\n            opacity: 1;\n            pointer-events: all;\n        }\n\n    .s-datetime-picker .s-datetime-picker__calendar:not(.active) {\n            display: none !important;\n        }\n\n    .s-datetime-picker .s-datetime-picker__calendar table {\n            width: 100%;\n        }\n\n    .s-datetime-picker .s-datetime-picker__calendar-item {\n        cursor: pointer;\n        touch-action: manipulation;\n    }\n\n    .s-datetime-picker .s-datetime-picker__calendar-item.disabled {\n            pointer-events: none;\n        }\n\n    .s-datetime-picker .s-datetime-picker__selector {\n        height: 8em;\n        overflow-y: auto;\n        scroll-snap-type: y mandatory;\n        flex-grow: 1;\n    }\n\n    .s-datetime-picker .s-datetime-picker__selector-item {\n        scroll-snap-align: center;\n    }\n\n    .s-datetime-picker .s-datetime-picker__selector-item:first-child {\n            -webkit-margin-before: 2.5em;\n                    margin-block-start: 2.5em;\n        }\n\n    .s-datetime-picker .s-datetime-picker__selector-item:last-child {\n            -webkit-margin-after: 2.5em;\n                    margin-block-end: 2.5em;\n        }\n\n    .s-datetime-picker .s-datetime-picker__selector-item.disabled {\n            pointer-events: none;\n        }\n\n    .s-datetime-picker .s-datetime-picker__date-selectors:not(.active) {\n            display: none !important;\n        }\n\n    .s-datetime-picker .s-datetime-picker__time-selectors:not(.active) {\n            display: none !important;\n        }\n\n    .s-datetime-picker .s-datetime-picker__time-selectors .s-datetime-picker__selector-item {\n            scroll-snap-align: center;\n        }\n\n    .s-datetime-picker .s-datetime-picker__time-selectors .s-datetime-picker__selector-item:first-child {\n                -webkit-margin-before: 1em;\n                        margin-block-start: 1em;\n            }\n\n    .s-datetime-picker .s-datetime-picker__time-selectors .s-datetime-picker__selector-item:last-child {\n                -webkit-margin-after: 1em;\n                        margin-block-end: 1em;\n            }\n\n    .s-datetime-picker .s-datetime-picker__date-selectors,\n    .s-datetime-picker .s-datetime-picker__time-selectors {\n        position: relative;\n        display: flex;\n    }\n\n    .s-datetime-picker .s-datetime-picker__days {\n    }\n\n    .s-datetime-picker .s-datetime-picker__day {\n    }\n";
var __awaiter$4 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SDatetimePickerComponent extends SLitComponent {
  constructor() {
    var _a3;
    super(__deepMerge({
      name: "s-datetime-picker",
      interface: SDatetimePickerComponentInterface
    }));
    this._originalState = {};
    this._hasInput = false;
    this._hasButton = false;
    this._isInInteraction = false;
    this._$input = this.querySelector("input");
    this._hasInput = this._$input !== null;
    this._$button = this.querySelector("button");
    (_a3 = this._$button) === null || _a3 === void 0 ? void 0 : _a3.addEventListener("click", (e) => e.preventDefault());
    this._hasButton = this._$button !== null;
  }
  static get properties() {
    return SLitComponent.propertiesFromInterface({}, SDatetimePickerComponentInterface);
  }
  static get styles() {
    return css$1`
            ${unsafeCSS(`
                ${__css$6}
            `)}
        `;
  }
  static get state() {
    return {
      year: 0,
      month: 0,
      day: 0,
      hour: 12,
      minutes: 0,
      displayedYear: 0,
      displayedMonth: 0,
      format: void 0
    };
  }
  mount() {
    return __awaiter$4(this, void 0, void 0, function* () {
      this._restoreState();
    });
  }
  firstUpdated() {
    return __awaiter$4(this, void 0, void 0, function* () {
      Object.assign(this._originalState, this.state);
      this._$root = this.querySelector(`.${this.componentUtils.uniqueClassName("__root")}`);
      this._$picker = this.querySelector(`.${this.componentUtils.uniqueClassName("__picker")}`);
      if (!this._$input) {
        this._$input = this.querySelector("input");
      }
      this.componentUtils.fastdom.mutate(() => {
        var _a3, _b2, _c2, _d2, _e2, _f2;
        if (!((_a3 = this._$input) === null || _a3 === void 0 ? void 0 : _a3.hasAttribute("name"))) {
          (_b2 = this._$input) === null || _b2 === void 0 ? void 0 : _b2.setAttribute("name", this.props.name);
        }
        if (!((_c2 = this._$input) === null || _c2 === void 0 ? void 0 : _c2.hasAttribute("placeholder"))) {
          (_d2 = this._$input) === null || _d2 === void 0 ? void 0 : _d2.setAttribute("placeholder", this.props.placeholder);
        }
        if (!((_e2 = this._$input) === null || _e2 === void 0 ? void 0 : _e2.hasAttribute("autocomplete"))) {
          (_f2 = this._$input) === null || _f2 === void 0 ? void 0 : _f2.setAttribute("autocomplete", "off");
        }
        this._$input.setAttribute("readonly", true);
      });
      this._$days = this.querySelector(".s-datetime-picker__days");
      this._$months = this.querySelector(".s-datetime-picker__months");
      this._$years = this.querySelector(".s-datetime-picker__years");
      this._$hours = this.querySelector(".s-datetime-picker__hours");
      this._$minutes = this.querySelector(".s-datetime-picker__minutes");
      this.addEventListener("focusin", (e) => {
        var _a3;
        (_a3 = this._floatApi) === null || _a3 === void 0 ? void 0 : _a3.update();
      });
      this._updateInput("init");
      if (!this.props.inline) {
        this._floatApi = __makeFloat(this._$picker, this._$root, Object.assign({}, this.props.floatSettings));
      }
      this._scrollSelectorsToStateValues("initial");
      this._initInteractions();
    });
  }
  _isDateNeeded() {
    return this.props.format.match(/(d{1,4}|D{1,2}|M{1,4}|Y{2,4})/);
  }
  _isTimeNeeded() {
    return this.props.format.match(/(h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3})/);
  }
  _isSelectedDatetimeValid() {
    return !this._isDateDisabled(this.state.day, this.state.month, this.state.year);
  }
  _isDateDisabled(date, month = this.state.displayedMonth, year = this.state.displayedYear) {
    if (year !== -1) {
      if (this.props.disable.includes(String(year))) {
        return true;
      }
    }
    if (month !== -1) {
      const months = [
        "january",
        "february",
        "march",
        "april",
        "may",
        "june",
        "july",
        "august",
        "september",
        "october",
        "november",
        "december"
      ];
      for (let i2 = 0; i2 < months.length; i2++) {
        const currentMonth = months[i2];
        if (this.props.disable.includes(currentMonth) && month === i2) {
          return true;
        }
      }
    }
    if (date === -1) {
      return false;
    }
    const dayInWeek = new Date(year, month, date).getDay();
    const days = [
      "sunday",
      "monday",
      "thuesday",
      "wednesday",
      "thursday",
      "friday",
      "saturday"
    ];
    for (let i2 = 0; i2 < days.length; i2++) {
      const currentDay = days[i2];
      if (this.props.disable.includes(currentDay) && dayInWeek === i2) {
        return true;
      }
    }
    if (this.props.disable.includes(this._getDisableDateFromDate(date))) {
      return true;
    }
    if (this.props.disable.includes("week") && dayInWeek > 1 && dayInWeek <= 5) {
      return true;
    }
    if (this.props.disable.includes("weekend") && (dayInWeek === 0 || dayInWeek === 6)) {
      return true;
    }
  }
  _setDay(day, delay = false) {
    this.state.day = day;
    setTimeout(() => {
      this._scrollSelectorToActiveItem(this._$days, true, delay);
    });
    this._updateInput("select");
  }
  _setMonth(month, delay = false) {
    this.state.month = month;
    this.state.displayedMonth = month;
    setTimeout(() => {
      this._scrollSelectorToActiveItem(this._$months, true, delay);
    });
    this._updateInput("select");
  }
  _setYear(year, delay = false) {
    this.state.year = year;
    this.state.displayedYear = year;
    setTimeout(() => {
      this._scrollSelectorToActiveItem(this._$years, true, delay);
    });
    this._updateInput("select");
  }
  _setHour(hour, delay = false) {
    this.state.hour = hour;
    setTimeout(() => {
      this._scrollSelectorToActiveItem(this._$hours, true, delay);
    });
    this._updateInput("select");
  }
  _setMinutes(minutes, delay = false) {
    this.state.minutes = minutes;
    setTimeout(() => {
      this._scrollSelectorToActiveItem(this._$minutes, true, delay);
    });
    this._updateInput("select");
  }
  _initInteractions() {
    let daysTimeout, monthsTimeout, yearsTimeout, hoursTimeout, minutesTimeout;
    this._$years.addEventListener("scroll", (e) => {
      if (!__isUserScrolling(this._$years)) {
        return;
      }
      clearTimeout(yearsTimeout);
      this._$years.classList.add("scrolling");
      yearsTimeout = setTimeout(() => {
        const idx = this._getSelectedIdxFromSelector(this._$years);
        this._setYear(parseInt(this._$years.children[idx - 1].innerText));
        this._$years.classList.remove("scrolling");
      }, 400);
    });
    this._$months.addEventListener("scroll", (e) => {
      if (!__isUserScrolling(this._$months)) {
        return;
      }
      clearTimeout(monthsTimeout);
      this._$months.classList.add("scrolling");
      monthsTimeout = setTimeout(() => {
        const idx = this._getSelectedIdxFromSelector(this._$months);
        this._setMonth(idx - 1);
        this._$months.classList.remove("scrolling");
      }, 400);
    });
    this._$days.addEventListener("scroll", (e) => {
      if (!__isUserScrolling(this._$days)) {
        return;
      }
      clearTimeout(daysTimeout);
      this._$days.classList.add("scrolling");
      daysTimeout = setTimeout(() => {
        const idx = this._getSelectedIdxFromSelector(this._$days);
        this._setDay(idx);
        this._$days.classList.remove("scrolling");
      }, 400);
    });
    this._$hours.addEventListener("scroll", (e) => {
      if (!__isUserScrolling(this._$hours)) {
        return;
      }
      clearTimeout(hoursTimeout);
      this._$hours.classList.add("scrolling");
      hoursTimeout = setTimeout(() => {
        const idx = this._getSelectedIdxFromSelector(this._$hours);
        this._setHour(parseInt(this._$hours.children[idx - 1].innerText));
        this._$hours.classList.remove("scrolling");
      }, 400);
    });
    this._$minutes.addEventListener("scroll", (e) => {
      if (!__isUserScrolling(this._$minutes)) {
        return;
      }
      clearTimeout(minutesTimeout);
      this._$minutes.classList.add("scrolling");
      minutesTimeout = setTimeout(() => {
        const idx = this._getSelectedIdxFromSelector(this._$minutes);
        this._setMinutes(parseInt(this._$minutes.children[idx - 1].innerText));
        this._$minutes.classList.remove("scrolling");
      }, 400);
    });
  }
  _getSelectedIdxFromSelector($selector) {
    const bounds = $selector.getBoundingClientRect();
    const scrollTop2 = $selector.scrollTop + bounds.height / 2;
    const count = $selector.children.length;
    const itemsHeight = Array.from($selector.children).reduce((current, $a2) => {
      const bounds2 = $a2.getBoundingClientRect();
      return current + bounds2.height;
    }, 0);
    return Math.round(count / itemsHeight * scrollTop2);
  }
  _scrollSelectorsToStateValues(step) {
    const smooth = step !== "initial";
    this._scrollSelectorToActiveItem(this._$years, smooth);
    this._scrollSelectorToActiveItem(this._$months, smooth);
    this._scrollSelectorToActiveItem(this._$days, smooth);
    this._scrollSelectorToActiveItem(this._$hours, smooth);
    this._scrollSelectorToActiveItem(this._$minutes, smooth);
  }
  _scrollSelectorToActiveItem($selector, smooth = true, delay = false) {
    const $activeElement = $selector.querySelector(".active");
    if ($activeElement) {
      const bounds = $activeElement.getBoundingClientRect();
      $selector.scrollTo({
        top: bounds.height * Array.from($selector.children).indexOf($activeElement),
        left: 0,
        behavior: smooth ? "smooth" : "instant"
      });
    }
  }
  _updateInput(step) {
    if (step !== "init" && !this.props.updateInput.includes(step)) {
      return;
    }
    this._$input.value = format(new Date(this.state.year, this.state.month, this.state.day, this.state.hour, this.state.minutes, 0), this.props.format);
    if (step !== "init") {
      this.componentUtils.dispatchEvent("change", {
        detail: {}
      });
    }
    this.requestUpdate();
  }
  _restoreState() {
    var _a3;
    {
      this.state.value = void 0;
      let date = new Date();
      if ((_a3 = this._$input) === null || _a3 === void 0 ? void 0 : _a3.value) {
        date = parse(this._$input.value, this.props.format, {
          backupDate: new Date()
        });
      }
      this.state.year = date.getFullYear();
      this.state.month = date.getMonth();
      this.state.day = date.getDate();
      this.state.displayedYear = this.state.year;
      this.state.displayedMonth = this.state.month;
    }
  }
  _validate() {
    var _a3, _b2;
    this._updateInput("validate");
    (_b2 = (_a3 = document.activeElement) === null || _a3 === void 0 ? void 0 : _a3.blur) === null || _b2 === void 0 ? void 0 : _b2.call(_a3);
  }
  _clear() {
    this._updateInput("clear");
  }
  _reset() {
    this._updateInput("reset");
  }
  _copy() {
    const originalClass = this.props.copyIconClass;
    this.props.copyIconClass = this.props.copiedIconClass;
    setTimeout(() => {
      this.props.copyIconClass = originalClass;
    }, 1e3);
  }
  _getDisableDateFromDate(date) {
    return `${this.state.displayedYear}-${String(this.state.displayedMonth + 1).padStart(2, "0")}-${String(date).padStart(2, "0")}`;
  }
  _getMinutes() {
    return this.props.minutes;
  }
  _getHours() {
    return this.props.hours;
  }
  _getDaysInMonth(year, month) {
    return new Date(year, month + 1, 0).getDate();
  }
  _getDays() {
    const daysInMonth = this._getDaysInMonth(this.state.displayedYear, this.state.displayedMonth);
    let days = Array.from(Array(daysInMonth).keys());
    return days;
  }
  _getMonths() {
    return this.props.i18n.months.filter((month, i2) => {
      return true;
    });
  }
  _getYears() {
    let i2 = this.props.fromYear;
    const years = [];
    for (let j = i2; j <= this.props.toYear; j++) {
      years.push(j);
    }
    return years;
  }
  render() {
    var _a3, _b2, _c2;
    let firstDayOfTheMonth = new Date(this.state.displayedYear, this.state.displayedMonth).getDay();
    let daysInMonth = 32 - new Date(this.state.displayedYear, this.state.displayedMonth, 32).getDate();
    const today = new Date();
    let date = 1;
    return html`
            <div
                class="${this.componentUtils.className("__root")} ${this.componentUtils.className("")}--${this.props.floatSettings.position} ${this._isInInteraction ? "is-interacting" : ""}"
            >
                ${this.props.backdrop ? html`
                          <div
                              class="${this.componentUtils.className("__backdrop")} ${this.props.backdropClass}"
                          ></div>
                      ` : ""}
                <div
                    class="${this.componentUtils.className("__picker")}"
                    tabindex="-1"
                >
                    <div
                        class="${this.componentUtils.className("__calendar")} ${this._isDateNeeded() && this.props.calendar ? "active" : ""}"
                    >
                        <table>
                            <thead>
                                <tr>
                                    <th>
                                        <div
                                            class="${this.componentUtils.className("__calendar-day")}"
                                        >
                                            Mon
                                        </div>
                                    </th>
                                    <th>
                                        <div
                                            class="${this.componentUtils.className("__calendar-day")}"
                                        >
                                            Tue
                                        </div>
                                    </th>
                                    <th>
                                        <div
                                            class="${this.componentUtils.className("__calendar-day")}"
                                        >
                                            Wed
                                        </div>
                                    </th>
                                    <th>
                                        <div
                                            class="${this.componentUtils.className("__calendar-day")}"
                                        >
                                            Thu
                                        </div>
                                    </th>
                                    <th>
                                        <div
                                            class="${this.componentUtils.className("__calendar-day")}"
                                        >
                                            Fri
                                        </div>
                                    </th>
                                    <th>
                                        <div
                                            class="${this.componentUtils.className("__calendar-day")}"
                                        >
                                            Sat
                                        </div>
                                    </th>
                                    <th>
                                        <div
                                            class="${this.componentUtils.className("__calendar-day")}"
                                        >
                                            Sun
                                        </div>
                                    </th>
                                </tr>
                            </thead>
                            ${Array.from(Array(6).keys()).map((i2) => html`
                                    <tr>
                                        ${Array.from(Array(7).keys()).map((j) => {
      const day = date;
      const res = html`
                                                    ${i2 === 0 && j < firstDayOfTheMonth - 1 ? html` <td></td>` : date > daysInMonth ? html`<td></td>` : html`
                                                              <td>
                                                                  <div
                                                                      @click=${(e) => this._setDay(day)}
                                                                      class="${this.componentUtils.className("__calendar-item")} ${date === today.getDate() && today.getMonth() === this.state.displayedMonth && today.getFullYear() === this.state.displayedYear ? "today" : ""} ${this.componentUtils.className("__calendar-item")} ${date === this.state.day && this.state.month === this.state.displayedMonth && this.state.year === this.state.displayedYear ? "active" : ""} ${this._isDateDisabled(date) ? "disabled" : ""}"
                                                                  >
                                                                      <span
                                                                          >${date}</span
                                                                      >
                                                                  </div>
                                                              </td>
                                                          `}
                                                `;
      if (i2 === 0 && j < firstDayOfTheMonth - 1)
        ;
      else {
        date++;
      }
      return res;
    })}
                                    </tr>
                                `)}
                        </table>
                    </div>
                    <div
                        class="${this.componentUtils.className("__date-selectors")} ${this._isDateNeeded() ? "active" : ""}"
                    >
                        <div
                            class="${this.componentUtils.className("__selector")} ${this.componentUtils.className("__days")}"
                        >
                            ${this._getDays().map((i2) => html`
                                    <div
                                        @click=${() => this._setDay(i2 + 1)}
                                        class="${this.componentUtils.className("__selector-item")} ${this.componentUtils.className("__day")} ${this.state.day === i2 + 1 ? "active" : ""} ${this._isDateDisabled(i2 + 1) ? "disabled" : ""}"
                                    >
                                        <span>
                                            ${String(i2 + 1).padStart(2, "0")}
                                        </span>
                                    </div>
                                `)}
                        </div>
                        <div
                            class="${this.componentUtils.className("__selector")} ${this.componentUtils.className("__months")}"
                        >
                            ${this._getMonths().map((month, i2) => html`
                                    <div
                                        @click=${() => this._setMonth(i2)}
                                        class="${this.componentUtils.className("__selector-item")} ${this.componentUtils.className("__month")} ${this.state.displayedMonth === i2 ? "active" : ""} ${this._isDateDisabled(-1, i2) ? "disabled" : ""}"
                                    >
                                        <span> ${month} </span>
                                    </div>
                                `)}
                        </div>
                        <div
                            class="${this.componentUtils.className("__selector")} ${this.componentUtils.className("__years")}"
                        >
                            ${this._getYears().map((year, j) => html`
                                    <div
                                        @click=${() => this._setYear(year)}
                                        class="${this.componentUtils.className("__selector-item")} ${this.componentUtils.className("__year")} ${this.state.displayedYear === year ? "active" : ""} ${this._isDateDisabled(-1, -1, year) ? "disabled" : ""}"
                                    >
                                        <span> ${year} </span>
                                    </div>
                                `)}
                        </div>
                    </div>
                    <div
                        class="${this.componentUtils.className("__time-selectors")} ${this._isTimeNeeded() ? "active" : ""}"
                    >
                        <div
                            class="${this.componentUtils.className("__selector")} ${this.componentUtils.className("__hours")}"
                        >
                            ${this._getHours().map((hour) => html`
                                    <div
                                        @click=${() => this._setHour(hour)}
                                        class="${this.componentUtils.className("__selector-item")} ${this.componentUtils.className("__hour")} ${this.state.hour === hour ? "active" : ""}"
                                    >
                                        <span>
                                            ${String(hour).padStart(2, "0")}
                                        </span>
                                    </div>
                                `)}
                        </div>
                        <div
                            class="${this.componentUtils.className("__selector")} ${this.componentUtils.className("__minutes")}"
                        >
                            ${this._getMinutes().map((minute, i2) => html`
                                    <div
                                        @click=${() => this._setMinutes(minute)}
                                        class="${this.componentUtils.className("__selector-item")} ${this.componentUtils.className("__minutes")} ${this.state.minutes === minute ? "active" : ""}"
                                    >
                                        <span>
                                            ${String(minute).padStart(2, "0")}
                                        </span>
                                    </div>
                                `)}
                        </div>
                    </div>
                    ${this.props.actions.length ? html`
                              <div
                                  class="${this.componentUtils.className("__actions")}"
                              >
                                  ${this.props.actions.includes("clear") ? html`
                                            <button
                                                class="${this.componentUtils.className("__clear", "s-btn s-color--error")}"
                                                @click=${(e) => {
      e.preventDefault();
      this._clear();
    }}
                                            >
                                                ${(_a3 = this.props.i18n.clear) !== null && _a3 !== void 0 ? _a3 : "Clear"}
                                            </button>
                                        ` : ""}
                                  ${this.props.actions.includes("reset") ? html`
                                            <button
                                                class="${this.componentUtils.className("__reset", "s-btn s-color--complementary")}"
                                                @click=${(e) => {
      e.preventDefault();
      this._reset();
    }}
                                            >
                                                ${(_b2 = this.props.i18n.reset) !== null && _b2 !== void 0 ? _b2 : "Reset"}
                                            </button>
                                        ` : ""}
                                  ${this.props.actions.includes("validate") ? html`
                                            <button
                                                ?disabled=${!this._isSelectedDatetimeValid()}
                                                class="${this.componentUtils.className("__validate", "s-btn s-color--accent")}"
                                                @click=${(e) => {
      e.preventDefault();
      this._validate();
    }}
                                            >
                                                ${(_c2 = this.props.i18n.validate) !== null && _c2 !== void 0 ? _c2 : "Validate"}
                                            </button>
                                        ` : ""}
                              </div>
                          ` : ""}
                </div>
            </div>
        `;
  }
}
function define$e(props = {}, tagName = "s-datetime-picker") {
  SLitComponent.define(tagName, SDatetimePickerComponent, props);
}
class SGoogleMapComponentInterface extends SInterface {
  static get _definition() {
    return {
      apiKey: {
        type: "String",
        description: "Specify the google api key to use. You can specify it in the config.google.map.apiKey configuration for your project if you prefer",
        default: SSugarConfig.get("google.map.apiKey"),
        required: true
      },
      mapId: {
        type: "String",
        description: "Specify your mapId that you can create [here](https://console.cloud.google.com/google/maps-apis/studio/maps)",
        required: true
      },
      lat: {
        type: "Number",
        description: "Specify the map latitude",
        required: true
      },
      lng: {
        type: "Number",
        description: "Specify the map longitude",
        required: true
      },
      zoom: {
        type: "Number",
        description: "Specify the google map zoom"
      },
      bounds: {
        type: "Boolean",
        description: "Specify if you want your map to be bounds on current markers",
        default: true
      },
      icons: {
        type: "Object",
        description: "Specify some icons to be used across your maps",
        default: {
          marker: '<i class="fa-solid fa-location-dot"></i>'
        }
      },
      zoomControl: {
        type: "Boolean",
        description: "Specify if you want the zom control or not",
        default: false
      },
      mapTypeControl: {
        type: "Boolean",
        description: "Specify if you want the map type control or not",
        default: false
      },
      scaleControl: {
        type: "Boolean",
        description: "Specify if you want the map scale control or not",
        default: false
      },
      streetViewControl: {
        type: "Boolean",
        description: "Specify if you want the streeview control or not",
        default: false
      },
      rotateControl: {
        type: "Boolean",
        description: "Specify if you want the rotate control or not",
        default: false
      },
      fullscreenControl: {
        type: "Boolean",
        description: "Specify if you want the fullscreen control or not",
        default: false
      }
    };
  }
}
const __css$5 = ".s-google-map {\n    display: block;\n    position: relative;\n}\n\n    .s-google-map:not([mounted]) {\n        opacity: 0.001;\n        pointer-events: none;\n    }\n\n    .s-google-map > div[style] {\n        background: none !important;\n    }\n\n    .s-google-map .gm-style {\n        font: inherit;\n    }\n";
function define$d(props = {}, tagName = "s-google-map") {
  SGoogleMapComponent.define(tagName, SGoogleMapComponent, props);
}
var __awaiter$3 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SGoogleMapComponent extends SLitComponent {
  constructor() {
    super(__deepMerge({
      name: "s-google-map",
      interface: SGoogleMapComponentInterface
    }));
    this._markers = this._getMarkers();
  }
  static get properties() {
    return SLitComponent.propertiesFromInterface({}, SGoogleMapComponentInterface);
  }
  static get styles() {
    return css$1`
            ${unsafeCSS(__css$5)}
        `;
  }
  static loadApi(apiKey) {
    if (this._loadApiPromise) {
      return this._loadApiPromise;
    }
    this._loadApiPromise = new Promise((resolve) => {
      const $script = document.createElement("script");
      $script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&v=beta&libraries=marker&callback=_initMap`;
      $script.async = true;
      window._initMap = function() {
        resolve(null);
      };
      document.head.appendChild($script);
    });
    return this._loadApiPromise;
  }
  mount() {
    return __awaiter$3(this, void 0, void 0, function* () {
      yield this.constructor.loadApi(this.props.apiKey);
      this._map = new google.maps.Map(this, {
        center: { lat: this.props.lat, lng: this.props.lng },
        zoom: 8,
        mapId: this.props.mapId,
        zoomControl: this.props.zoomControl,
        mapTypeControl: this.props.mapTypeControl,
        scaleControl: this.props.scaleControl,
        streetViewControl: this.props.streetViewControl,
        rotateControl: this.props.rotateControl,
        fullscreenControl: this.props.fullscreenControl,
        disableDefaultUI: true
      });
      this._createMarkers(this._markers);
      this._handleBoundsAndZoom();
    });
  }
  _handleBoundsAndZoom() {
    const boundsListener = this._map.addListener("bounds_changed", () => {
      google.maps.event.removeListener(boundsListener);
      if (this.props.bounds) {
        this._bounds(this._markers);
      }
      if (this.props.zoom) {
        this._map.setZoom(this.props.zoom);
      }
    });
  }
  _bounds(markers) {
    const bounds = new google.maps.LatLngBounds();
    for (let marker2 of markers) {
      const latLng = new google.maps.LatLng(marker2.lat, marker2.lng);
      bounds.extend(latLng);
    }
    this._map.fitBounds(bounds);
  }
  _createMarkers(markers) {
    for (let marker2 of markers) {
      const latLng = { lat: marker2.lat, lng: marker2.lng };
      if (!marker2.content) {
        document.createElement("div");
        const domParser = new DOMParser(), markerDocument = domParser.parseFromString(`
                        <div class="${this.componentUtils.className("-marker")}">
                            <div class="${this.componentUtils.className("-marker__icon")}">
                                ${this.props.icons.marker}
                            </div>
                        </div>
                    `, "text/html");
        marker2.content = markerDocument.body.children[0];
      }
      marker2.marker = new google.maps.marker.AdvancedMarkerView({
        map: this._map,
        content: marker2.content,
        position: latLng
      });
    }
  }
  _getMarkers() {
    const markers = Array.from(
      this.querySelectorAll(`${this.tagName.toLowerCase()}-marker`)
    ).map(($marker) => {
      var _a3, _b2;
      return {
        lat: parseFloat((_a3 = $marker.getAttribute("lat")) !== null && _a3 !== void 0 ? _a3 : "0"),
        lng: parseFloat((_b2 = $marker.getAttribute("lng")) !== null && _b2 !== void 0 ? _b2 : "0"),
        icon: $marker.getAttribute("icon"),
        content: $marker.children.length ? $marker.children[0] : null
      };
    });
    return markers;
  }
  render() {
    return html``;
  }
}
SGoogleMapComponent.state = {};
class SRatingComponentInterface extends SInterface {
  static get _definition() {
    return {
      name: {
        description: "Specify a name that will be attributed to the hidden input created automatically",
        type: "String",
        default: "rate"
      },
      value: {
        description: "Specify a base value for the rating",
        type: "Number",
        default: 3
      },
      min: {
        description: "Specify the minimum rate you accept",
        type: "Number",
        default: 1
      },
      max: {
        description: "Specify the maximum rate you accept",
        type: "Number",
        default: 5
      },
      icon: {
        description: 'This works only if you use the "s-icon:..." class notation. Define the icon you want to use',
        type: "String",
        default: "star"
      },
      iconClass: {
        description: 'Specify a custom icon class you want to use. If this is set, override the "icon" parameter',
        type: "String"
      },
      readonly: {
        description: "Specify if you want your rating component to just display the value and that the user cannot interact with it or not",
        type: "Boolean",
        default: false,
        physical: true
      }
    };
  }
}
function define$c(props = {}, tagName = "s-rating") {
  SRatingComponent.define(tagName, SRatingComponent, props);
}
const __css$4 = ".s-rating {\n    display: inline-block;\n    position: relative;\n    cursor: pointer;\n}\n\n    .s-rating .s-rating__icons-wrapper {\n        display: flex;\n    }\n\n    .s-rating .s-rating__base {\n        opacity: 0.3;\n    }\n\n    .s-rating .s-rating__rate {\n        position: absolute;\n        top: 0;\n        left: 0;\n    }\n\n    .s-rating:hover .s-rating__rate {\n        -webkit-clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);\n                clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);\n    }\n\n    .s-rating .s-rating__rate {\n        -webkit-clip-path: polygon(\n            0 0,\n            calc(var(--s-rating-percent) * 1%) 0,\n            calc(var(--s-rating-percent) * 1%) 100%,\n            0 100%\n        );\n                clip-path: polygon(\n            0 0,\n            calc(var(--s-rating-percent) * 1%) 0,\n            calc(var(--s-rating-percent) * 1%) 100%,\n            0 100%\n        );\n    }\n\n    .s-rating .s-rating__rate i:hover ~ i {\n            opacity: 0;\n        }\n\n.s-rating[readonly] {\n    pointer-events: none;\n}\n";
class SRatingComponent extends SLitComponent {
  constructor() {
    super({
      name: "s-rating",
      interface: SRatingComponentInterface
    });
    this.state = {
      value: 0
    };
  }
  static get properties() {
    return SLitComponent.propertiesFromInterface({}, SRatingComponentInterface);
  }
  static get styles() {
    return css$1`
            ${unsafeCSS(__css$4)}
        `;
  }
  mount() {
    this._setRating(this.props.value);
  }
  _setRating(rating) {
    this.state.value = rating;
    this.componentUtils.dispatchEvent("change", {
      detail: this.state
    });
  }
  render() {
    return html`
            <div
                class="${this.componentUtils.className("__root")}"
                style="--s-rating-rate: ${this.state.value}; --s-rating-min: ${this.props.min}; --s-rating-max: ${this.props.max}; --s-rating-percent: ${100 / this.props.max * this.state.value};"
            >
                <input
                    type="hidden"
                    name="${this.props.name}"
                    value="${this.state.value}"
                />
                <div
                    class="${this.componentUtils.className("__base")} ${this.componentUtils.className("__icons-wrapper")}"
                >
                    ${[...Array(this.props.max).keys()].map((i2) => html`
                            <i
                                class="${this.props.iconClass ? this.props.iconClass : `s-icon:${this.props.icon}`}"
                            ></i>
                        `)}
                </div>
                <div
                    class="${this.componentUtils.className("__rate")} ${this.componentUtils.className("__icons-wrapper")}"
                >
                    ${[...Array(this.props.max).keys()].map((i2) => html`
                            <i
                                @click=${() => this._setRating(i2 + 1)}
                                class="${this.props.iconClass ? this.props.iconClass : `s-icon:${this.props.icon}`}"
                            ></i>
                        `)}
                </div>
            </div>
        `;
  }
}
class SThemeSwitcherComponentInterface extends SInterface {
  static get _definition() {
    return {
      darkModeicon: {
        description: "Specify if you want to dark mode icon or not",
        type: "Boolean",
        default: false
      },
      darkModeIconClass: {
        description: "Specify the class to apply on the i tag for the dark mode icon",
        type: "String",
        default: "s-icon:dark-mode"
      }
    };
  }
}
const __css$3 = ".s-theme-switcher {\n    display: inline-block;\n    position: relative;\n    cursor: pointer;\n}\n\n    .s-theme-switcher .s-theme-switcher__dropdown-item {\n        display: flex;\n        align-items: center;\n        cursor: pointer;\n    }\n\n    .s-theme-switcher .s-theme-switcher__dropdown-item .s-theme-switcher__dark-mode {\n            opacity: 0;\n            pointer-events: none;\n            display: flex;\n            align-items: center;\n        }\n\n    .s-theme-switcher .s-theme-switcher__dropdown-item .s-theme-switcher__dark-mode.visible {\n                opacity: 1;\n                pointer-events: all;\n            }\n";
function define$b(props = {}, tagName = "s-theme-switcher") {
  SThemeSwitcherComponent.define(tagName, SThemeSwitcherComponent, props);
}
class SThemeSwitcherComponent extends SLitComponent {
  constructor() {
    super({
      name: "s-theme-switcher",
      interface: SThemeSwitcherComponentInterface
    });
    this._themes = STheme.themes;
  }
  static get properties() {
    return SLitComponent.propertiesFromInterface({}, SThemeSwitcherComponentInterface);
  }
  static get styles() {
    return css$1`
            ${unsafeCSS(__css$3)}
        `;
  }
  _toggleDarkMode() {
    if (STheme.isDark()) {
      STheme.setThemeVariant("light");
    } else {
      STheme.setThemeVariant("dark");
    }
    this.componentUtils.dispatchEvent("change", {
      detail: STheme
    });
    this.requestUpdate();
  }
  _setTheme(theme) {
    STheme.setTheme(theme);
    this.requestUpdate();
  }
  render() {
    const themesKeys = Object.keys(this._themes), themeMetas = STheme.getThemeMetas(), activeTheme = STheme.theme;
    return html`
            <div class="${this.componentUtils.className("__root")}">
                ${themesKeys.length === 1 ? html`
                          <input
                              type="checkbox"
                              @change=${() => this._toggleDarkMode()}
                              class="${this.componentUtils.className("__switch", "s-switch")}"
                              ?checked=${STheme.isDark()}
                          />
                          ${this.props.darkModeIcon ? html`
                                    <i
                                        class="${this.componentUtils.className("__icon")} ${this.props.darkModeIconClass}"
                                    ></i>
                                ` : ""}
                      ` : html`
                          <div
                              class="${this.componentUtils.className("__dropdown-container")} s-dropdown-container"
                              tabindex="0"
                          >
                              <span class="s-typo:p">
                                  ${themeMetas.title} (${themeMetas.variant})
                              </span>
                              <div
                                  class="${this.componentUtils.className("__dropdown")} s-dropdown"
                              >
                                  ${themesKeys.map((theme) => {
      const themeObj = this._themes[theme];
      return html`
                                          <div
                                              class="${this.componentUtils.className("__dropdown-item", "s-dropdown-item")} ${activeTheme === theme ? "active" : ""}"
                                              @click=${(e) => {
        e.preventDefault();
        this._setTheme(theme);
      }}
                                          >
                                              <div
                                                  class="${this.componentUtils.className("__theme-name")}"
                                              >
                                                  ${themeObj.metas.title}
                                              </div>
                                              <div
                                                  class="${this.componentUtils.className("__dark-mode")} ${activeTheme === theme ? "visible" : ""}"
                                              >
                                                  <input
                                                      type="checkbox"
                                                      @change=${(e) => {
        e.stopPropagation();
        this._toggleDarkMode();
      }}
                                                      class="${this.componentUtils.className("__switch", "s-switch")}"
                                                      ?checked=${STheme.isDark()}
                                                  />
                                                  ${this.props.darkModeIcon ? html`
                                                            <i
                                                                class="${this.componentUtils.className("__icon")} ${this.props.darkModeIconClass}"
                                                            ></i>
                                                        ` : ""}
                                              </div>
                                          </div>
                                      `;
    })}
                              </div>
                          </div>
                      `}
            </div>
        `;
  }
}
class SHighlightFeatureInterface extends SInterface {
  static get _definition() {
    return {
      type: {
        type: "String",
        description: "Specify the type of highlight you want",
        default: "light",
        physical: true
      },
      size: {
        type: "Number",
        description: "Specify the size of the highlight in px"
      },
      intensity: {
        type: "Number",
        description: "Specify the intensity of the highlight beetween 0 and 1"
      }
    };
  }
}
function define$a(props = {}, name2 = "s-highlight") {
  SHighlightFeature.define(name2, SHighlightFeature, Object.assign({}, props));
}
const __css$2 = "[s-highlight][type='light'] {\n    position: relative;\n}\n\n[s-highlight][type='light']::before,\n[s-highlight][type='light']::after {\n    border-radius: inherit;\n    content: '';\n    display: block;\n    height: 100%;\n    left: 0px;\n    opacity: 0;\n    position: absolute;\n    top: 0px;\n    transition: opacity 500ms;\n    width: 100%;\n    mix-blend-mode: overlay;\n    pointer-events: none;\n}\n\n[s-highlight][type='light']::before {\n    background: radial-gradient(\n        var(--s-highlight-size, 1000px) circle at var(--s-highlight-mouse-x)\n            var(--s-highlight-mouse-y),\n        rgba(255, 255, 255, 0.06),\n        transparent 40%\n    );\n    z-index: 3;\n}\n\n[s-highlight][type='light']::after {\n    background: radial-gradient(\n        var(--s-highlight-size, 1000px) circle at var(--s-highlight-mouse-x)\n            var(--s-highlight-mouse-y),\n        rgba(255, 255, 255, 0.4),\n        transparent 40%\n    );\n    z-index: 1;\n}\n\n[s-highlight][type='light'].highlight:before,\n    [s-highlight][type='light'].highlight:after {\n        opacity: var(--s-highlight-intensity, 0.6);\n    }\n";
var __awaiter$2 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SHighlightFeature extends SFeature {
  constructor(name2, node, settings) {
    super(name2, node, __deepMerge({
      name: "s-highlight",
      interface: SHighlightFeatureInterface,
      style: __css$2
    }, settings !== null && settings !== void 0 ? settings : {}));
  }
  mount() {
    return __awaiter$2(this, void 0, void 0, function* () {
      if (this.props.size) {
        this.node.style.setProperty("--s-highlight-size", `${this.props.size}px`);
      }
      if (this.props.intensity) {
        this.node.style.setProperty("--s-highlight-intensity", this.props.intensity);
      }
      ["mouseover", "pointerover"].forEach((eventName) => {
        this.node.addEventListener(eventName, (e) => {
          if (!this.componentUtils.isActive()) {
            return;
          }
          this.node.classList.add("highlight");
        });
      });
      ["mouseout", "pointerout"].forEach((eventName) => {
        this.node.addEventListener(eventName, (e) => {
          if (!this.componentUtils.isActive()) {
            return;
          }
          this.node.classList.remove("highlight");
        });
      });
      ["mousemove", "touchmove"].forEach((eventName) => {
        this.node.addEventListener(eventName, (e) => {
          if (!this.componentUtils.isActive()) {
            return;
          }
          const rect = this.node.getBoundingClientRect(), x2 = e.clientX - rect.left, y = e.clientY - rect.top;
          this.node.style.setProperty("--s-highlight-mouse-x", `${x2}px`);
          this.node.style.setProperty("--s-highlight-mouse-y", `${y}px`);
        });
      });
    });
  }
}
class SLazyFeatureInterface extends SInterface {
  static get _definition() {
    return {};
  }
}
function define$9(props = {}, name2 = "s-lazy") {
  SLazyFeature.define(name2, SLazyFeature, Object.assign({}, props));
}
const __css$1 = "template[s-lazy] {\n    display: block;\n    height: calc(100 * var(--vh,1vh)) ;\n}\n";
var __awaiter$1 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SLazyFeature extends SFeature {
  constructor(name2, node, settings) {
    super(name2, node, __deepMerge({
      name: "s-lazy",
      interface: SLazyFeatureInterface,
      style: __css$1
    }, settings !== null && settings !== void 0 ? settings : {}));
  }
  mount() {
    return __awaiter$1(this, void 0, void 0, function* () {
      let $content;
      if (this.node.tagName === "TEXTAREA") {
        const parser = new DOMParser();
        const html2 = this.node.value;
        const $dom = parser.parseFromString(html2, "text/html");
        $content = $dom.body.children[0];
        $dom.body.children[0];
      } else {
        $content = this.node.content;
        $content.children[0];
      }
      this.componentUtils.fastdom.mutate(() => {
        this.node.parentNode.insertBefore($content, this.node);
        this.node.remove();
      });
    });
  }
}
function __queryStringToObject(str2) {
  str2 = __ltrim(str2, "?");
  str2 = str2.replace(/%20/gm, " ");
  str2 = decodeURIComponent(str2);
  let chunks = str2.split("&");
  const obj2 = {};
  chunks = chunks.filter((ch) => {
    return ch !== "";
  });
  for (let c = 0; c < chunks.length; c++) {
    const split = chunks[c].split("=", 2);
    if (split[1] !== void 0) {
      obj2[split[0]] = split[1];
    } else {
      obj2[split[0]] = true;
    }
  }
  return obj2;
}
try {
  if (document && !document.env) {
    document.env = {
      SUGAR: {}
    };
  }
} catch (e) {
}
class SEnv$1 {
  static is(env) {
    env = env.toLowerCase();
    if (env === "verbose") {
      if (this.get("verbose")) {
        return true;
      }
    }
    if (env === "devscut") {
      if (this.get("devsCut")) {
        return true;
      }
    }
    if (env === "dev" || env === "development") {
      if (this.get("env") === "dev" || this.get("env") === "development")
        return true;
    } else if (env === "prod" || env === "production") {
      if (this.get("env") === "prod" || this.get("env") === "production")
        return true;
    } else {
      return this.get("env") === env;
    }
    return false;
  }
  static get(name2) {
    return autoCast(this.env[__snakeCase(name2).toUpperCase()]);
  }
  static set(name2, value) {
    this.env[__snakeCase(name2).toUpperCase()] = value;
    return value;
  }
  static delete(name2) {
    delete this.env[__snakeCase(name2).toUpperCase()];
  }
}
class SEnv extends SEnv$1 {
  static get env() {
    if (this._env)
      return this._env;
    const envConfig = SSugarConfig.get("env");
    const queryStringObj = __queryStringToObject(document.location.search);
    let finalEnv = "development";
    if (envConfig.env) {
      finalEnv = envConfig.env;
    } else if (envConfig.envFromLocation && Object.keys(envConfig.envFromLocation).length) {
      for (let [env, regex2] of Object.entries(envConfig.envFromLocation)) {
        if (new RegExp(regex2).test(document.location.href)) {
          finalEnv = env;
          break;
        }
      }
    } else {
      console.log(`%c[SEnv] The environment cannot be determined. Either set the config.env.env configuration or specify some environments by setting the config.env.envFromLocation object of {env}:{regex} environments`, "color: orange");
    }
    console.log(`%c[SEnv] Current environment is "${finalEnv}"${queryStringObj.devsCut ? " developer's cut (devsCut)" : ""}`, `color: ${finalEnv === "production" ? "red" : finalEnv === "staging" ? "cyan" : "lightGreen"}`);
    document.env.ENVIRONMENT = finalEnv;
    document.env.ENV = finalEnv;
    document.env.PLATFORM = "browser";
    document.env.DEVS_CUT = queryStringObj.devsCut !== void 0;
    document.env.VERBOSE = queryStringObj.verbose !== void 0;
    this._env = document.env;
    return document.env;
  }
}
class SPageTransitionFeatureInterface extends SInterface {
  static get _definition() {
    return {
      patchBody: {
        description: "Specify if you want to patch the body tag with the new page body tag",
        type: "Boolean",
        default: true
      },
      scrollTop: {
        description: "Specify if you want to scroll to the top of the updated element after a transition",
        type: "Boolean",
        default: true
      },
      before: {
        description: "Specify a function to run before the transition",
        type: "Function"
      },
      after: {
        description: "Specify a function to run after the transition",
        type: "Function"
      },
      autoStyle: {
        description: 'Specify if you want to automatically add classes like "s-tc:error" on the broken links (only the "a" tags)',
        type: "Boolean",
        default: true
      },
      injectBrokenLinkIcon: {
        description: 'Specify if you want to inject the "error" icon on the broken links',
        type: "Boolean",
        default: true
      },
      brokenLinkIcon: {
        description: "Specify the icon you want to inject on the broken links",
        type: "String",
        default: '<i class="s-icon:link-broken-solid" alt="Broken link"></i>'
      },
      ga: {
        description: "Specify if you want to track pages change using google analytics of not. If true, will use the config.google.ga configuration as target, otherwise you can specify the gtag universal id here...",
        type: "Boolean|String",
        default: true
      }
    };
  }
}
function define$8(props = {}, name2 = "s-page-transition") {
  SPageTransitionFeature.define(name2, SPageTransitionFeature, Object.assign({}, props));
}
const __css = ".s-page-transition-source.error [s-page-transition-broken-link-icon] {\n    margin-right: 0.5ch;\n    margin-left: 0.5ch;\n}\n";
var __awaiter = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SPageTransitionFeature extends SFeature {
  constructor(name2, node, settings) {
    super(name2, node, __deepMerge({
      interface: SPageTransitionFeatureInterface,
      style: __css
    }, settings !== null && settings !== void 0 ? settings : {}));
    this._currentUrl = `${document.location.pathname}${document.location.search}`;
    window.history.pushState({
      html: this.node.innerHTML
    }, document.title, document.location.href);
    window.addEventListener("popstate", (e) => {
      var _a3;
      if (!((_a3 = e.state) === null || _a3 === void 0 ? void 0 : _a3.html))
        return;
      if (e.state.containerId) {
        const $elm = document.querySelector(`[s-page-transition-container="${e.state.containerId}"]`);
        if (!$elm) {
          return;
        }
        $elm.innerHTML = e.state.html;
        __scrollTo($elm);
      } else {
        this.node.innerHTML = e.state.html;
        __scrollTo(this.node);
      }
    });
    document.addEventListener("location.href", (e) => {
      this.transitionTo(e.detail, e.target).catch((e2) => {
      });
    });
    document.addEventListener("click", (e) => {
      const $target = e.target;
      if (this._isEligibleLink($target)) {
        e.preventDefault();
        this.transitionTo($target.getAttribute("href"), $target).catch((e2) => {
        });
      } else {
        const $upHrefElm = __querySelectorUp($target, "a[href]");
        if ($upHrefElm && this._isEligibleLink($upHrefElm)) {
          e.preventDefault();
          this.transitionTo($upHrefElm.getAttribute("href"), $upHrefElm).catch((e2) => {
          });
        }
      }
    });
  }
  mount() {
  }
  _isEligibleLink($link) {
    return $link.tagName === "A" && $link.hasAttribute("href") && !$link.getAttribute("href").match(/^https?:\/\//) && !$link.getAttribute("href").match(/^#/) && !$link.hasAttribute("target");
  }
  transitionTo(url, $source) {
    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
      var _a3, _b2, _c2;
      this.componentUtils.dispatchEvent("start", {
        $elm: $source,
        detail: {
          url
        }
      });
      this.componentUtils.fastdom.mutate(() => {
        document.body.classList.add("loading");
        document.body.setAttribute("loading", "true");
        $source.classList.add("s-page-transition-source");
        $source.classList.add("loading");
        $source.setAttribute("loading", true);
      });
      (_b2 = (_a3 = this.props).before) === null || _b2 === void 0 ? void 0 : _b2.call(_a3, {
        url,
        $source
      });
      const request2 = new SRequest({
        url
      });
      let response;
      try {
        response = yield request2.send();
      } catch (e) {
        response = e;
      }
      if (!response || response.status !== 200) {
        this._onAfter($source, response.status, url);
        return reject(response);
      }
      const domParser = new DOMParser();
      const dom = domParser.parseFromString((_c2 = response.data) !== null && _c2 !== void 0 ? _c2 : "", "text/html");
      const $inPageContainer = document.querySelector("[s-page-transition]");
      const $container = dom.querySelector("[s-page-transition]");
      const $inPageScopedContainer = document.querySelector("[s-page-transition-container]");
      const $scopedContainer = dom.querySelector("[s-page-transition-container]");
      if (!$container || !$inPageContainer) {
        this._onAfter($source, 500, url);
        return reject();
      }
      if (this.props.patchBody) {
        const $inPageBody = document.querySelector("body");
        const $newBody = dom.querySelector("body");
        if ($inPageBody && $newBody) {
          const newAttrNames = [];
          for (let attr of $newBody.attributes) {
            $inPageBody.setAttribute(attr.name, attr.value);
            newAttrNames.push(attr.name);
          }
          for (let attr of $inPageBody.attributes) {
            if (!newAttrNames.includes(attr.name)) {
              $inPageBody.removeAttribute(attr.name);
            }
          }
        }
      }
      let newState = {};
      if ($inPageScopedContainer && $scopedContainer && ($inPageScopedContainer === null || $inPageScopedContainer === void 0 ? void 0 : $inPageScopedContainer.getAttribute("s-page-transition-container")) === $scopedContainer.getAttribute("s-page-transition-container")) {
        $inPageScopedContainer.innerHTML = $scopedContainer.innerHTML;
        newState.html = $scopedContainer.innerHTML;
        newState.containerId = $scopedContainer.getAttribute("s-page-transition-container");
      } else {
        $inPageContainer.innerHTML = $container.innerHTML;
        newState.html = $container.innerHTML;
      }
      if (this.props.scrollTop) {
        __scrollTo($inPageScopedContainer !== null && $inPageScopedContainer !== void 0 ? $inPageScopedContainer : $inPageContainer);
      }
      this._onAfter($source, 200, url, newState);
      if (window.gtag && SEnv.is("production")) {
        const gaUid = typeof this.props.ga === "string" ? this.props.ga : SSugarConfig.get("google.ga");
        if (gaUid) {
          window.gtag("event", "page_view", {
            page_title: document.title,
            page_location: document.location.href,
            page_path: document.location.pathname,
            send_to: gaUid
          });
        }
      } else if (window.gtag && this.props.verbose) {
        console.log(`%c[SPageTransitionFeature] Google analytics is activate and this transition to "${document.location.pathname}" will be correctly tracked in production environment`, "color: lightGreen");
      }
      resolve();
    }));
  }
  _onAfter($source, code3, url, newState) {
    var _a3, _b2, _c2, _d2;
    document.body.classList.remove("loading");
    document.body.removeAttribute("loading");
    $source.classList.remove("s-page-transition-source");
    $source.classList.remove("loading");
    $source.removeAttribute("loading");
    (_b2 = (_a3 = this.props).after) === null || _b2 === void 0 ? void 0 : _b2.call(_a3, {
      $source
    });
    if (code3 !== 200) {
      history.replaceState("", "", this._currentUrl);
      $source.classList.add("s-page-transition-source");
      $source.classList.add("error");
      $source.setAttribute("error", "");
      if (this.props.autoStyle) {
        $source.classList.add("s-tc:error");
      }
      if (this.props.injectBrokenLinkIcon && !$source.querySelector("[s-page-transition-broken-link-icon]")) {
        $source.innerHTML = `${$source.innerHTML}${this.props.brokenLinkIcon.replace(/^\<([a-z]+)/, "<$1 s-page-transition-broken-link-icon")}`;
      }
      this.componentUtils.dispatchEvent("error", {
        $elm: $source,
        detail: {
          code: code3,
          $source
        }
      });
      (_d2 = (_c2 = this.props).onError) === null || _d2 === void 0 ? void 0 : _d2.call(_c2, {
        $source
      });
    }
    __scrollTo("top");
    if (code3 === 200 && newState && url) {
      window.history.pushState(newState, document.title, url);
      this._currentUrl = url;
    }
    this.componentUtils.dispatchEvent("end", {
      $elm: $source,
      detail: {
        code: code3,
        $source
      }
    });
  }
}
class SParallaxFeatureInterface extends SInterface {
  static get _definition() {
    return {
      amount: {
        description: "Specify the amount of parallax you want to apply",
        type: "Number",
        default: 1
      },
      amountX: {
        description: "Specify the amount of parallax you want for the x axis. This will be applied on top of the global amount",
        type: "Number",
        default: 1
      },
      amountY: {
        description: "Specify the amount of parallax you want for the y axis. This will be applied on top of the global amount",
        type: "Number",
        default: 1
      },
      amountT: {
        description: "Specify the amount of parallax you want for the translate x and y axis. This will be applied on top of the global amount",
        type: "Number",
        default: 1
      },
      amountTx: {
        description: "Specify the amount of parallax you want for the translate x axis. This will be applied on top of the global amount",
        type: "Number",
        default: 1
      },
      amountTy: {
        description: "Specify the amount of parallax you want for the translate y axis. This will be applied on top of the global amount",
        type: "Number",
        default: 1
      },
      amountR: {
        description: "Specify the amount of parallax you want for the rotate x and y axis. This will be applied on top of the global amount",
        type: "Number",
        default: 1
      },
      amountRx: {
        description: "Specify the amount of parallax you want for the rotate x axis. This will be applied on top of the global amount",
        type: "Number",
        default: 1
      },
      amountRy: {
        description: "Specify the amount of parallax you want for the rotate y axis. This will be applied on top of the global amount",
        type: "Number",
        default: 1
      },
      amountRz: {
        description: "Specify the amount of parallax you want for the rotate z axis. This will be applied on top of the global amount",
        type: "Number",
        default: 1
      }
    };
  }
}
function define$7(props = {}, name2 = "s-parallax") {
  SParallaxFeature.define(name2, SParallaxFeature, Object.assign({}, props));
}
class SParallaxFeature extends SFeature {
  constructor(name2, node, settings) {
    super(name2, node, __deepMerge({
      name: "s-parallax",
      interface: SParallaxFeatureInterface
    }, settings !== null && settings !== void 0 ? settings : {}));
  }
  mount() {
    const style = window.getComputedStyle(this.node);
    const transformStr = style.transform;
    this._originalTransform = transformStr;
    document.addEventListener("mousemove", (e) => {
      if (!this.componentUtils.isActive()) {
        return;
      }
      const percentage = this._getPositionPercentages(e);
      this._setLayerTransform(percentage);
    });
  }
  _setLayerTransform(percentage) {
    var _a3;
    const rotateY$1 = 90 / 100 * percentage.x;
    const rotateX$1 = 90 / 100 * percentage.y;
    const offsetX = 200 / 100 * percentage.x;
    const offsetY = 200 / 100 * percentage.y;
    const amount = (_a3 = this.props.amount) !== null && _a3 !== void 0 ? _a3 : "1";
    const matrix = fromString(this._originalTransform);
    const finalRotateX = rotateX$1 * parseFloat(amount) * parseFloat(this.props.amountX) * parseFloat(this.props.amountR) * parseFloat(this.props.amountRx);
    const finalRotateY = rotateY$1 * parseFloat(amount) * parseFloat(this.props.amountY) * parseFloat(this.props.amountR) * parseFloat(this.props.amountRy);
    const finalRotateZ = rotateY$1 * parseFloat(amount) * parseFloat(this.props.amountZ) * parseFloat(this.props.amountR) * parseFloat(this.props.amountRz);
    const finalOffsetX = offsetX * parseFloat(amount) * parseFloat(this.props.amountX) * parseFloat(this.props.amountT) * parseFloat(this.props.amountTx);
    const finalOffsetY = offsetY * parseFloat(amount) * parseFloat(this.props.amountY) * parseFloat(this.props.amountT) * parseFloat(this.props.amountTy);
    const tx = translateX(finalOffsetX), ty = translateY(finalOffsetY), rx = rotateX(finalRotateX), ry = rotateY(finalRotateY);
    rotateZ(finalRotateZ);
    let newMatrix = [matrix, tx, ty, rx, ry].reduce(multiply);
    this.node.style.transform = toString$1(newMatrix);
  }
  _getPositionPercentages(e) {
    var _a3, _b2, _c2, _d2;
    const viewportWidth = document.documentElement.clientWidth, viewportHeight = document.documentElement.clientHeight, halfViewportWidth = viewportWidth * 0.5, halfViewportHeight = viewportHeight * 0.5, positionX = (_b2 = (_a3 = e.touches) === null || _a3 === void 0 ? void 0 : _a3[0].clientX) !== null && _b2 !== void 0 ? _b2 : e.pageX, positionY = ((_d2 = (_c2 = e.touches) === null || _c2 === void 0 ? void 0 : _c2[0].clientY) !== null && _d2 !== void 0 ? _d2 : e.pageY) - document.documentElement.scrollTop, percentageX = 100 / halfViewportWidth * (positionX - halfViewportWidth), percentageY = 100 / halfViewportHeight * (positionY - halfViewportHeight);
    return {
      x: percentageX,
      y: percentageY
    };
  }
}
new SStateManager({
  id: "ck-state",
  save: true
});
let _docmap, _docmapPromise;
async function loadDocmap() {
  if (_docmap)
    return _docmap;
  if (_docmapPromise)
    return (await _docmapPromise).data;
  const request2 = new SRequest({
    url: `/docmap.json`,
    method: "GET"
  });
  const promise = request2.send();
  _docmapPromise = promise;
  _docmap = (await promise).data;
  return _docmap;
}
class SCKDiscoverPropsInterface extends SInterface {
  static get _definition() {
    return {
      platform: {
        type: "String"
      }
    };
  }
}
class CKDiscover extends SLitComponent {
  constructor() {
    super({
      shadowDom: false
    });
    __publicField(this, "_docmap");
    __publicField(this, "item");
    __publicField(this, "timeout");
  }
  static get properties() {
    return SLitComponent.propertiesFromInterface(
      {},
      SCKDiscoverPropsInterface
    );
  }
  async firstUpdated() {
    this._docmap = await loadDocmap();
    this.grabItem();
  }
  async grabItem() {
    const newMap = __filter(this._docmap.map, (key, item) => {
      var _a3, _b2;
      if (!item.platform)
        return false;
      if (!((_b2 = (_a3 = item.example) == null ? void 0 : _a3[0]) == null ? void 0 : _b2.code))
        return false;
      if (this.props.platform && item.platform[0].name !== this.props.platform)
        return false;
      return true;
    });
    const mapCount = Object.keys(newMap).length;
    const mapKeys = Object.keys(newMap);
    const itemIdx = Math.floor(Math.random() * mapCount);
    this.item = newMap[mapKeys[itemIdx]];
    this.requestUpdate();
    this.timeout = setTimeout(() => {
      this.timeout = void 0;
      this.requestUpdate();
    }, 200);
  }
  render() {
    var _a3, _b2, _c2, _d2, _e2, _f2;
    return html`
            <div class="ck-discover">
                ${!this.item ? html`
                          <div class="s-code-example-loader">
                              <i class="s-loader:spinner s-color:accent"></i>
                              &nbsp;
                              <p class="s-typo:p s-display:inline-block">
                                  Loading code example. Please wait...
                              </p>
                          </div>
                      ` : html`
                          <a
                              @click="${this.grabItem}"
                              class="s-btn s-radius:100 s-align:abs-top-right s-color:accent s-float:right"
                          >
                              <i class="s-icon:ui-refresh"></i>
                          </a>
                          ${this.item.async ? html`
                                    <span class="s-badge:outline s-color:accent"
                                        >Async</span
                                    >&nbsp;
                                ` : ""}
                          ${((_b2 = (_a3 = this.item.type) == null ? void 0 : _a3.types) == null ? void 0 : _b2[0].type) || this.item.type ? html`
                                    <span class="s-badge s-color:complementary"
                                        >${(_f2 = (_e2 = (_d2 = (_c2 = this.item.type) == null ? void 0 : _c2.types) == null ? void 0 : _d2[0]) == null ? void 0 : _e2.type) != null ? _f2 : this.item.type}</span
                                    >
                                ` : ""}
                          <br />
                          <br />
                          <h1 class="s-typo:h3 s-mbe:30">${this.item.name}</h1>
                          <p class="s-typo:p s-mbe:30 s-truncate:3">
                              ${this.item.description}
                          </p>
                          ${!this.timeout ? html`
                                    <s-code-example
                                        lines="8"
                                        s-deps
                                        css="codeExample"
                                    >
                                        <code
                                            lang="${this.props.platform === "ts" || this.props.platform === "node" ? "js" : this.props.platform === "postcss" ? "css" : this.props.platform}"
                                        >
                                            ${this.item.example[0].code}
                                        </code>
                                    </s-code-example>
                                ` : ""}
                      `}
            </div>
        `;
  }
}
function define$6(props = {}, tagName = "ck-discover") {
  SLitComponent.define(tagName, CKDiscover, props);
}
class SCKDiscoverTabedPropsInterface extends SInterface {
  static get _definition() {
    return {
      platform: {
        type: "String"
      }
    };
  }
}
class CKDiscoverTabed extends SLitComponent {
  constructor() {
    super({
      shadowDom: false
    });
    __publicField(this, "_tabs", [
      {
        id: "js",
        title: "JS"
      },
      {
        id: "css",
        title: "CSS"
      },
      {
        id: "node",
        title: "NodeJS"
      },
      {
        id: "php",
        title: "PHP"
      }
    ]);
    __publicField(this, "state", {
      activeTabId: "js"
    });
    __publicField(this, "_$discover");
  }
  static get properties() {
    return SLitComponent.propertiesFromInterface(
      {},
      SCKDiscoverTabedPropsInterface
    );
  }
  async firstUpdated() {
    this._$discover = this.querySelector("ck-discover");
  }
  render() {
    return html`
      <div class="ck-discover-tabed">
        <ul class="s-tabs s-color:accent s-mbe:50 @mobile s-tabs:grow">
          ${this._tabs.map(
      (tab) => html`
              <li
                class="${this.state.activeTabId === tab.id ? "active" : ""}"
                @click=${() => {
        this.state.activeTabId = tab.id;
        this._$discover.grabItem();
      }}
              >
                ${tab.title}
              </li>
            `
    )}
        </ul>
        <ck-discover platform="${this.state.activeTabId}"></ck-discover>
      </div>
    `;
  }
}
function define$5(props = {}, tagName = "ck-discover-tabed") {
  SLitComponent.define(tagName, CKDiscoverTabed, props);
}
class SCKDiscoverWelcomePropsInterface extends SInterface {
  static get _definition() {
    return {
      platform: {
        type: "String"
      }
    };
  }
}
class CKDiscoverWelcome extends SLitComponent {
  constructor() {
    super({
      shadowDom: false
    });
    __publicField(this, "_docmap");
    __publicField(this, "item");
    __publicField(this, "timeout");
  }
  static get properties() {
    return SLitComponent.propertiesFromInterface(
      {},
      SCKDiscoverWelcomePropsInterface
    );
  }
  async firstUpdated() {
    this._docmap = await loadDocmap();
    this.grabItem();
  }
  async grabItem() {
    this.item = void 0;
    this.timeout = void 0;
    this.requestUpdate();
    await __wait();
    const ids = [
      "@coffeekraken.sugar.js.dom.query.querySelectorLive",
      "@coffeekraken.sugar.js.dom.query.querySelectorUp",
      "@coffeekraken.sugar.js.dom.class.addAnimationClass",
      "@coffeekraken.sugar.js.dom.detect.onScrollEnd",
      "@coffeekraken.sugar.js.dom.detect.whenInteract",
      "@coffeekraken.sugar.js.dom.detect.whenInViewport",
      "@coffeekraken.sugar.js.dom.element.elementAreaStats",
      "@coffeekraken.sugar.js.dom.is.isInViewport",
      "@coffeekraken.sugar.js.dom.is.isUserScrolling",
      "@coffeekraken.sugar.js.dom.style.getTransformProperties",
      "@coffeekraken.sugar.js.dom.ui.makeFloat",
      "@coffeekraken.sugar.js.is.isChrome",
      "@coffeekraken.sugar.js.is.isFirefox",
      "@coffeekraken.sugar.js.is.isEdge",
      "@coffeekraken.sugar.js.is.isMobile",
      "@coffeekraken.sugar.js.keyboard.hotkey",
      "@coffeekraken.sugar.node.compression.unzip",
      "@coffeekraken.sugar.node.exec.execPhp",
      "@coffeekraken.sugar.node.is.isCommandExists",
      "@coffeekraken.sugar.node.load.loadConfigFile",
      "@coffeekraken.sugar.node.network.getFreePort",
      "@coffeekraken.sugar.node.network.ipAddress",
      "@coffeekraken.sugar.node.network.isPortFree",
      "@coffeekraken.sugar.node.process.onProcessExit",
      "@coffeekraken.sugar.node.process.sharedContext",
      "@coffeekraken.sugar.php.gravatar.url",
      "@coffeekraken.sugar.php.object.deepMap",
      "@coffeekraken.sugar.php.object.deepMerge",
      "@coffeekraken.sugar.php.object.sort",
      "@coffeekraken.sugar.php.url.currentUrl",
      "@coffeekraken.sugar.shared.array.pickRandom",
      "@coffeekraken.sugar.shared.array.unique",
      "@coffeekraken.sugar.shared.color.convert",
      "@coffeekraken.sugar.shared.crypto.aes",
      "@coffeekraken.sugar.shared.crypto.base64",
      "@coffeekraken.sugar.shared.crypto.md5",
      "@coffeekraken.sugar.shared.crypto.sha256",
      "@coffeekraken.sugar.shared.crypto.sha512",
      "@coffeekraken.sugar.shared.css.easing.cssEasingStrToJsFunction",
      "@coffeekraken.sugar.shared.datetime.formatDuration",
      "@coffeekraken.sugar.shared.datetime.wait",
      "@coffeekraken.sugar.shared.extension.commonAudioFileExtensions",
      "@coffeekraken.sugar.shared.extension.commonFontFileExtensions",
      "@coffeekraken.sugar.shared.extension.commonImageFileExtensions",
      "@coffeekraken.sugar.shared.extension.commonProgrammingFileExtensions",
      "@coffeekraken.sugar.shared.extension.commonVideoFileExtensions",
      "@coffeekraken.sugar.shared.extension.commonWebFileExtensions",
      "@coffeekraken.sugar.shared.function.throttle",
      "@coffeekraken.sugar.shared.is.isBase64",
      "@coffeekraken.sugar.shared.is.isBrowser",
      "@coffeekraken.sugar.shared.is.isChildProcess",
      "@coffeekraken.sugar.shared.is.isColor",
      "@coffeekraken.sugar.shared.is.isCreditCard",
      "@coffeekraken.sugar.shared.is.isEmail",
      "@coffeekraken.sugar.shared.is.isIsoDate",
      "@coffeekraken.sugar.shared.is.isLinux",
      "@coffeekraken.sugar.shared.is.isNode",
      "@coffeekraken.sugar.shared.is.isPlainObject",
      "@coffeekraken.sugar.shared.is.isWindows",
      "@coffeekraken.sugar.shared.math.clamp",
      "@coffeekraken.sugar.shared.math.easeClamp",
      "@coffeekraken.sugar.shared.module.currentModuleSystem",
      "@coffeekraken.sugar.shared.object.deepMap",
      "@coffeekraken.sugar.shared.object.deepMerge",
      "@coffeekraken.sugar.shared.object.clone",
      "@coffeekraken.sugar.shared.object.set",
      "@coffeekraken.sugar.shared.object.get",
      "@coffeekraken.sugar.shared.string.camelCase",
      "@coffeekraken.sugar.shared.string.dashCase",
      "@coffeekraken.sugar.shared.string.snakeCase",
      "@coffeekraken.sugar.shared.url.gravatarUrl"
    ];
    for (let i2 = 0; i2 < ids.length; i2++) {
      if (!this._docmap.map[ids[i2]] || !this._docmap.map[ids[i2]].example) {
        console.log(ids[i2]);
      }
    }
    this.item = this._docmap.map[__pickRandom(ids)];
    this.requestUpdate();
  }
  render() {
    return html`
            <div class="ck-discover-welcome">
                ${!this.item ? html`` : html`
                          ${!this.timeout ? html`
                                    <s-code-example lines="15">
                                        <code
                                            lang="${this.item.example[0].language}"
                                        >
                                            ${this.item.example[0].code}
                                        </code>
                                    </s-code-example>
                                ` : ""}
                      `}
                <a
                    @click="${() => this.grabItem()}"
                    class="s-btn s-radius:100 s-color:accent __refresh"
                >
                    <i class="s-icon:ui-refresh"></i>
                </a>
            </div>
        `;
  }
}
function define$4(props = {}, tagName = "ck-discover-welcome") {
  SLitComponent.define(tagName, CKDiscoverWelcome, props);
}
define$t(
  {
    value: "name",
    label: (item) => {
      return `${item.type} ${item.namespace}`;
    },
    closeOnSelect: true,
    resetOnSelect: false,
    showKeywords: true,
    saveState: false,
    filtrable: ["namespace", "name", "type"],
    searchValuePreprocess: (value) => {
      if (value.match(/^@[a-z_-]+\s.*/)) {
        return value.replace(/^@[a-z_-]+\s/, "").trim();
      }
      if (value.match(/^@[a-z_-]+/)) {
        return value.replace(/^@/, "").trim();
      }
      if (value.match(/^\/[a-z]+\s.*/)) {
        return value.replace(/^\/[a-z]+\s/, "").trim();
      }
      if (value.match(/^\/[a-z]+/)) {
        return value.replace(/^\//, "").trim();
      }
      return value;
    },
    templates: ({ type, item, html: html2, unsafeHTML: unsafeHTML2 }) => {
      var _a3, _b2, _c2, _d2, _e2, _f2, _g;
      if (type === "item") {
        switch (item.type) {
          case "category":
          case "package":
            return html2`
                            <div class="ck-search__list-item">
                                <div class="s-flex s-mbe:10">
                                    <h4
                                        class="ck-search__list-item-title s-typo:bold s-tc:accent s-flex-item:grow"
                                    >
                                        ${unsafeHTML2(item.name)}
                                    </h4>
                                </div>
                                <p class="__description s-typo:p s-truncate:2">
                                    ${unsafeHTML2((_a3 = item.description) != null ? _a3 : "")}
                                </p>
                            </div>
                        `;
          default:
            return html2`
                            <div class="ck-search__list-item">
                                <div class="s-flex s-mbe:10">
                                    <h4
                                        class="ck-search__list-item-title s-typo:bold s-tc:accent s-flex-item:grow"
                                    >
                                        ${unsafeHTML2(item.name)}
                                    </h4>
                                    <div>
                                        ${(_b2 = item.platform) == null ? void 0 : _b2.map(
              (platform2) => html2`
                                                <i
                                                    class="s-platform:${platform2.name}"
                                                ></i>
                                            `
            )}
                                        &nbsp;
                                        <span class="s-badge s-color:main"
                                            >${unsafeHTML2(
              (_e2 = (_d2 = (_c2 = item.type) == null ? void 0 : _c2.types) == null ? void 0 : _d2[0].type) != null ? _e2 : ""
            )}</span
                                        >
                                    </div>
                                </div>
                                <p
                                    class="__namespace s-opacity:50 s-font:20 s-mbe:20"
                                >
                                    ${unsafeHTML2((_f2 = item.namespace) != null ? _f2 : "")}
                                </p>
                                <p class="__description s-typo:p s-truncate:2">
                                    ${unsafeHTML2((_g = item.description) != null ? _g : "")}
                                </p>
                            </div>
                        `;
        }
      }
    },
    items: async ({ value }) => {
      async function fetchItems() {
        const request2 = new SRequest({
          url: "/docmap.json"
        });
        const result2 = await request2.send();
        const items2 = [];
        Object.keys(result2.data.map).forEach((namespace) => {
          const item = result2.data.map[namespace];
          item.fullNamespace = namespace;
          item.preventSet = true;
          items2.push(item);
        });
        return items2;
      }
      let items = await fetchItems();
      if (value.match(/^@([a-z_-]+)?$/)) {
        let packageName = value.replace(/^@/, "");
        let packages = {};
        items.forEach((item) => {
          if (item.package.name.includes(
            `@coffeekraken/${packageName}`
          )) {
            if (!packages[item.package.name]) {
              packages[item.package.name] = {
                value: `@${item.package.name.replace(
                  "@coffeekraken/",
                  ""
                )}`,
                namespace: item.package.name,
                type: "package",
                name: item.package.name,
                description: item.package.description,
                preventClose: true,
                props: {
                  value: "value"
                }
              };
            }
          }
        });
        return Object.values(packages);
      }
      if (value.match(/^\/([a-z]+)?$/)) {
        return [
          {
            value: "/doc",
            namespace: "/doc",
            type: "category",
            name: "Documentation",
            description: "Search through the documentation",
            preventClose: true,
            props: {
              value: "value"
            }
          },
          {
            value: "/styleguide",
            namespace: "/styleguide",
            type: "category",
            name: "Styleguide",
            description: "Search through the styleguide",
            preventClose: true,
            props: {
              value: "value"
            }
          },
          {
            value: "/api",
            namespace: "/api",
            type: "category",
            name: "API",
            description: "Search through the API",
            preventClose: true,
            props: {
              value: "value"
            }
          }
        ];
      }
      if (value.match(/^@[a-z_-]+\s.*?/)) {
        const packageName = `@coffeekraken/${value.replace(/^@/, "").split(" ")[0].trim()}`;
        return items.filter((item) => {
          return item.package.name.startsWith(packageName);
        });
      }
      if (value.match(/^\/[a-z]+.*?/)) {
        if (value.startsWith("/doc")) {
          return items.filter((item) => {
            return item.type === "Markdown";
          });
        }
        if (value.startsWith("/styleguide")) {
          return items.filter((item) => {
            return item.type === "Styleguide";
          });
        }
        if (value.startsWith("/api")) {
          return items.filter((item) => {
            return item.type !== "Markdown" && item.type !== "Styleguide";
          });
        }
      }
      return items;
    }
  },
  "ck-search-input"
);
class CKSearch extends SLitComponent {
  constructor() {
    super({
      shadowDom: false
    });
    __publicField(this, "$input");
    __publicField(this, "_search");
  }
  static get properties() {
    return SLitComponent.propertiesFromInterface();
  }
  firstUpdated() {
    this.$input = this.querySelector("input");
    __hotkey("ctrl+f").on("press", () => {
      __cursorToEnd(this.$input);
    });
    this.addEventListener("s-filtrable-input.select", (e) => {
      var _a3;
      const { item, $elm } = e.detail;
      if (item.type === "category" || item.type === "package") {
        this.$input.value = item.value + " ";
        __cursorToEnd(this.$input);
      } else {
        if ((_a3 = item.menu) == null ? void 0 : _a3.slug) {
          if (item.package.name !== __SEnv.env.PACKAGE.name) {
            $elm.dispatchEvent(
              new CustomEvent("location.href", {
                detail: `/package/${item.package.name}${item.menu.slug}`,
                bubbles: true
              })
            );
          } else {
            $elm.dispatchEvent(
              new CustomEvent("location.href", {
                detail: `${item.menu.slug}`,
                bubbles: true
              })
            );
          }
        } else {
          $elm.dispatchEvent(
            new CustomEvent("location.href", {
              detail: `/api/${item.fullNamespace}`,
              bubbles: true
            })
          );
        }
      }
    });
  }
  render() {
    return html`
            <div class="ck-search" s-deps css="ckSearch">
                <div class="ck-search__background"></div>
                <div class="ck-search__content">
                    <ck-search-input id="ck-search-input">
                        <input
                            placeholder="Search ( Ctrl+F )..."
                            type="text"
                            name="search"
                            value="${this._search}"
                            class="s-input s-color:accent s-scale:08"
                        />
                        <template type="before">
                            <div class="s-p:30" id="search-tips">
                                <p class="s-mbe:20">
                                    <span class="s-typo:p s-tc:current"
                                        >Search tips</span
                                    >
                                </p>
                                <p class="s-typo:p s-color:accent">
                                    <span class="s-badge:outline s-mie:10"
                                        >/...</span
                                    >
                                    Categories&nbsp;&nbsp;&nbsp;&nbsp;<span
                                        class="s-badge:outline s-mie:10"
                                        >@...</span
                                    >
                                    Packages&nbsp;&nbsp;&nbsp;&nbsp;<span
                                        class="s-badge s-color:complementary s-mie:10"
                                        >CTRL+F</span
                                    >
                                    Search
                                </p>
                            </div>
                        </template>
                    </ck-search-input>
                </div>
            </div>
        `;
  }
}
function define$3(props = {}, tagName = "ck-search") {
  SLitComponent.define(tagName, CKSearch, props);
}
class CkSettings extends SLitComponent {
  constructor() {
    super({
      shadowDom: false
    });
    __publicField(this, "_theme", STheme.getCurrentTheme());
    STheme.whenLodChange((e) => {
    });
  }
  static get properties() {
    return SLitComponent.propertiesFromInterface();
  }
  async firstUpdated() {
    const $baseColorPicker = this.querySelector("#setting-base-color");
    const $mainColorPicker = this.querySelector("#setting-main-color");
    const $accentColorPicker = this.querySelector("#setting-accent-color");
    const $complementaryColorPicker = this.querySelector(
      "#setting-complementary-color"
    );
    const $fontSizeRange = this.querySelector("#setting-font-size");
    $baseColorPicker.addEventListener("s-color-picker.change", (e) => {
      this._theme.setColor("base", e.detail.hex);
    });
    $mainColorPicker.addEventListener("s-color-picker.change", (e) => {
      this._theme.setColor("main", e.detail.hex);
    });
    $accentColorPicker.addEventListener("s-color-picker.change", (e) => {
      this._theme.setColor("accent", e.detail.hex);
    });
    $complementaryColorPicker.addEventListener("s-color-picker.change", (e) => {
      this._theme.setColor("complementary", e.detail.hex);
    });
    $fontSizeRange.addEventListener("change", (e) => {
      this._theme.set("scale.default", `${e.target.value}`);
    });
  }
  async mount() {
  }
  _setLod(level) {
    STheme.setLod(level);
  }
  render() {
    return html`
      <div s-deps css="ckSettings">
        <div class="s-p:50 s-mbe:40 @mobile s-p:40 s-mbe:10">
          <h1 class="s-typo:h3 s-mbe:40 @mobile s-mbe:0">Settings</h1>
          <p class="s-typo:p @mobile s-hide">
            These settings allows you to customize your Coffeekraken experience
            as well as feature some of the capabilities that our toolkit has to
            offer.
          </p>
        </div>

        <form>
          <ul class="__settings s-bg:odd">
            <!-- <li class="s-bg:main-surface">
                            <label
                                class="s-label s-pi:50 s-pb:30 @mobile s-pi:40"
                            >
                                <span> Dark mode </span>
                                <s-theme-switcher
                                    class="s-color:accent"
                                ></s-theme-switcher>
                            </label>
                        </li> -->
            <li class="s-bg:main-surface">
              <label
                class="s-label:responsive s-pi:50 s-pb:30 @mobile s-pi:40"
                for="setting-font-size"
              >
                <span>Level of details</span>
                <s-range
                  class="s-color:accent"
                  id="setting-lod"
                  min="0"
                  max="4"
                  value=${STheme.lod}
                  values='["Bare","Low","Medium","High","Extrem"]'
                  tooltip
                  step="1"
                  @change=${(e) => {
      this._setLod(e.target.value);
    }}
                >
                </s-range>
              </label>
            </li>
            <li class="s-bg:main-surface">
              <label
                class="s-label:responsive s-pi:50 s-pb:30 @mobile s-pi:40"
                for="setting-base-color"
              >
                <span> Base color </span>
                <s-color-picker id="setting-base-color">
                  <div class="s-group">
                    <input
                      type="text"
                      class="s-input"
                      value="${this._theme.getColor("base").toHex()}"
                    />
                    <button class="s-btn s-color:base">
                      <i class="s-icon:color"></i>
                    </button>
                  </div>
                </s-color-picker>
              </label>
            </li>
            <li class="s-bg:main-surface">
              <label
                class="s-label:responsive s-pi:50 s-pb:30 @mobile s-pi:40"
                for="setting-main-color"
              >
                <span> Main color </span>
                <s-color-picker id="setting-main-color">
                  <div class="s-group">
                    <input
                      type="text"
                      class="s-input"
                      value="${this._theme.getColor("main").toHex()}"
                    />
                    <button class="s-btn s-color:main">
                      <i class="s-icon:color"></i>
                    </button>
                  </div>
                </s-color-picker>
              </label>
            </li>
            <li class="s-bg:main-surface">
              <label
                class="s-label:responsive s-pi:50 s-pb:30 @mobile s-pi:40"
                for="setting-accent-color"
              >
                <span> Accent color </span>
                <s-color-picker
                  style="position:relative"
                  id="setting-accent-color"
                >
                  <div class="s-group">
                    <input
                      type="text"
                      class="s-input"
                      value="${this._theme.getColor("accent").toHex()}"
                    />
                    <button class="s-btn s-color:accent">
                      <i class="s-icon:color"></i>
                    </button>
                  </div>
                </s-color-picker>
              </label>
            </li>
            <li class="s-bg:main-surface">
              <label
                class="s-label:responsive s-pi:50 s-pb:30 @mobile s-pi:40"
                for="setting-complementary-color"
              >
                <span> Complementary color </span>
                <s-color-picker id="setting-complementary-color">
                  <div class="s-group">
                    <input
                      type="text"
                      class="s-input"
                      value="${this._theme.getColor("complementary").toHex()}"
                    />
                    <button class="s-btn s-color:complementary">
                      <i class="s-icon:color"></i>
                    </button>
                  </div>
                </s-color-picker>
              </label>
            </li>
            <li class="s-bg:main-surface">
              <label
                class="s-label:responsive s-pi:50 s-pb:30 @mobile s-pi:40"
                for="setting-font-size"
              >
                <span>Document scale</span>
                <s-range
                  class="s-color:accent"
                  id="setting-font-size"
                  min="0.5"
                  max="1.5"
                  value="1"
                  tooltip
                  step="0.1"
                >
                </s-range>
              </label>
            </li>
            <li class="s-bg:main-surface">
              <label
                class="s-label s-pi:50 s-pb:30 @mobile s-pi:40"
                for="setting-complementary-color"
              >
                Restore default settings!
                <button
                  type="reset"
                  class="s-btn s-color:accent"
                  @click=${() => {
      this._theme.clear();
    }}
                >
                  Restore!
                </button>
              </label>
            </li>
          </ul>
        </form>
      </div>
    `;
  }
}
__publicField(CkSettings, "state", {});
function define$2(props = {}, tagName = "ck-settings") {
  SLitComponent.define(tagName, CkSettings, {
    id: "ck-settings",
    ...props
  });
}
class SCKVersionSelectorPropsInterface extends SInterface {
  static get _definition() {
    return {
      versions: {
        type: "Object",
        required: true
      }
    };
  }
}
class CKVersionSelector extends SLitComponent {
  constructor() {
    super({
      shadowDom: false
    });
    __publicField(this, "_versions");
    __publicField(this, "_currentVersion");
    __publicField(this, "_currentVersionObj");
    __publicField(this, "_lastViewedVersion");
  }
  static get properties() {
    return SLitComponent.propertiesFromInterface(
      {},
      SCKVersionSelectorPropsInterface
    );
  }
  async firstUpdated() {
  }
  async mount() {
    var _a3;
    this._versions = Object.keys((_a3 = this.props.versions) != null ? _a3 : {});
    this._currentVersion = this._versions[0];
    this._currentVersionObj = this.props.versions[this._currentVersion];
  }
  isNewVersion() {
    return this.state.lastViewedVersion && this.state.lastViewedVersion !== this._currentVersion;
  }
  render() {
    if (!this._versions) {
      return;
    }
    if (this.isNewVersion()) {
      this._lastViewedVersion = this.state.lastViewedVersion;
    } else {
      this.state.lastViewedVersion = this._currentVersion;
    }
    let $dropdownContainer, $dropdown;
    setTimeout(() => {
      $dropdownContainer = this.querySelector(".s-dropdown-container");
      $dropdown = $dropdownContainer.querySelector(".s-dropdown");
      if (this.isNewVersion()) {
        $dropdownContainer.focus();
      }
    });
    const color2 = this._versions[0].includes("alpha") ? "error" : "complementary";
    return html`
            <span class="s-dropdown-container" tabindex="0">
                <span class="s-badge s-color--${color2}">
                    ${this._currentVersionObj.codename ? html` <span class="s-typo:bold s-text:uppercase"
                              >${this._currentVersionObj.codename}</span
                          >` : `${this._versions[0]}`}
                </span>
                <div class="s-dropdown:bottom s-bare">
                    <div class="__inner">
                        ${this.isNewVersion() ? html`
                                  <div class="__new s-p:30">
                                      <h3
                                          class="s-typo:h3 s-gradient:text:accent s-mbe:20"
                                      >
                                          Hell Yeaaah!
                                      </h3>
                                      <p class="s-typo--p s-mbe:20">
                                          A new version has been released<br />since
                                          your latest visite on the<br />
                                          <span class="s-tc:accent"
                                              >${this._lastViewedVersion}</span
                                          >
                                          one.
                                      </p>
                                      <blockquote class="__codename s-mbs:30">
                                          <span class="s-tc:accent"
                                              >${this._versions[0]}</span
                                          >
                                          codename
                                          <div
                                              class="s-typo:h5 s-text:uppercase s-mbs:20"
                                          >
                                              ${this._currentVersionObj.codename}
                                          </div>
                                      </blockquote>
                                      <button
                                          class="s-btn:block s-color:accent s-mbs:30"
                                          @click=${() => {
      $dropdown.style.display = "none";
      document.activeElement.blur();
      setTimeout(() => {
        $dropdown.style.display = "unset";
      });
      this.state.lastViewedVersion = this._currentVersion;
    }}
                                      >
                                          Ok thanks!
                                      </button>
                                  </div>
                              ` : ""}

                        <div class="__versions">
                            ${this._versions.map((version2, i2) => {
      return html`
                                    <div class="__version">
                                        <a
                                            href="https://${version2.split(".").join("")}.coffeekraken.io"
                                            target="_blank"
                                            title="Coffeekraken version ${version2}"
                                            class="__number"
                                        >
                                            ${version2}
                                        </a>
                                        <span class="__actions">
                                            ${this.props.versions[version2].codename ? html` <span
                                                      class="s-badge s-typo:bold s-text:uppercase s-color--${version2.includes(
        "alpha"
      ) ? "error" : "complementary"} s-mis--20"
                                                  >
                                                      ${this.props.versions[version2].codename}
                                                  </span>` : ""}
                                            <div class="s-tooltip-container">
                                                <a
                                                    href="/changelog/${version2}"
                                                    class="s-badge s-mis:10"
                                                    title="Coffeekraken ${version2} changelog"
                                                    @click=${() => {
        $dropdown.style.display = "none";
        document.activeElement.blur();
        setTimeout(() => {
          $dropdown.style.display = "unset";
        });
      }}
                                                >
                                                    <i class="s-icon:write"></i>
                                                </a>
                                                <div
                                                    class="s-tooltip s-color:complementary"
                                                >
                                                    View the changelog
                                                </div>
                                            </div>
                                        </span>
                                    </div>
                                `;
    })}
                        </div>
                    </div>
                </div>
            </span>
        `;
  }
}
__publicField(CKVersionSelector, "state", {
  lastViewedVersion: null
});
function define$1(props = {}, tagName = "ck-version-selector") {
  SLitComponent.define(tagName, CKVersionSelector, {
    ...props,
    id: "version-selector",
    saveState: true
  });
}
if (!window.___isObject) {
  window.___isObject = function(item) {
    return item && typeof item === "object" && !Array.isArray(item);
  };
}
if (!window.___deepMerge) {
  window.___deepMerge = function(target, ...sources) {
    if (!sources.length)
      return target;
    var source2 = sources.shift();
    if (window.___isObject(target) && window.___isObject(source2)) {
      for (const key in source2) {
        if (window.___isObject(source2[key])) {
          if (!target[key])
            Object.assign(target, { [key]: {} });
          window.___deepMerge(target[key], source2[key]);
        } else {
          Object.assign(target, { [key]: source2[key] });
        }
      }
    }
    return window.___deepMerge(target, ...sources);
  };
}
document.env = window.___deepMerge(JSON.parse(`{"PLATFORM":"browser","ENV":"development","ENVIRONMENT":"development","SUGAR":{"config":{"assets":{"dev":{"type":"module","defer":true,"src":"/src/js/index.ts","env":"development"},"module":{"type":"module","defer":true,"src":"/dist/js/index.esm.js","env":"production"},"nomodule":{"nomodule":true,"defer":true,"src":"/dist/js/index.amd.js","env":"production"},"style":{"id":"global","defer":true,"src":"/dist/css/index.css"}},"datetime":{"dateFormat":"YYYY-MM-DD","timeFormat":"h:mm:ss","i18n":{"previousMonth":"Previous Month","nextMonth":"Next Month","months":["January","February","March","April","May","June","July","August","September","October","November","December"],"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"]}},"discord":{"server":{"id":"940362961682333767","url":"https://discord.gg/HzycksDJ"}},"google":{"gtm":null,"ga":"UA-91271113-1","map":{"apiKey":"AIzaSyDzFfEzhmYXRTlONUCtMWQ88uHJhsbtXY4"}},"metas":{"lang":"en","og":{"type":"website","image":"https://cdnv2.coffeekraken.io/coffeekraken-og.png"}},"project":{"environments":{"dev":{"branch":"develop","urls":{"website":{"label":"Template","url":"http://localhost:3000"},"admin":{"label":"Admin","url":"http://localhost:3000/admin"}}},"staging":{"branch":"staging","urls":{"website":{"label":"Template","url":"http://staging.localhost:3000"},"admin":{"label":"Admin","url":"http://staging.localhost:3000/admin"}}},"preprod":{"branch":"preprod","urls":{"website":{"label":"Template","url":"http://preprod.localhost:3000"},"admin":{"label":"Admin","url":"http://preprod.localhost:3000/admin"}}},"prod":{"branch":"prod","urls":{"website":{"label":"Template","url":"http://prod.localhost:3000"},"admin":{"label":"Admin","url":"http://prod.localhost:3000/admin"}}}}},"serve":{"img":{"imgPath":"/dist/img"},"js":{"path":"/dist/js"},"css":{"path":"/dist/css"},"icons":{"path":"/dist/icons"},"fonts":{"path":"/dist/fonts"},"cache":{"path":"/cache"}},"storage":{"system":{"tmpDir":"/private/var/folders/9h/ncs8vtzj6051qh5tqqx_7r_00000gn/T"},"package":{"rootDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io","localDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/.local","cacheDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/.local/cache","tmpDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/.local/tmp","nodeModulesDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/node_modules"},"sugar":{"rootDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/config/s-sugar-config"},"src":{"rootDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/src","jsDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/src/js","nodeDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/src/node","cssDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/src/css","configDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/src/config","docDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/src/doc","fontsDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/src/fonts","iconsDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/src/icons","imgDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/src/img","pagesDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/src/pages","publicDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/src/public","viewsDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/src/views"},"dist":{"rootDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/dist","jsDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/dist/js","nodeDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/dist/node","cssDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/dist/css","docDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/dist/doc","fontsDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/dist/fonts","iconsDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/dist/icons","imgDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/dist/img","pagesDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/dist/pages","viewsDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/dist/views"},"exclude":["**/bin/**","**/.DS_Store","**/__WIP__/**","**/__wip__/**","**/__TESTS/**","**/__tests__/**","**/__tests__.wip/**","**/.*/**","**/node_modules/**"]},"bench":{"filters":{"min":50,"max":99999999999}},"carpenter":{"server":{"port":3001},"sources":{"components":{"title":"Components","specsNamespaces":["views.components"]},"sections":{"title":"Sections","specsNamespaces":["views.sections"]}}},"dashboard":{"layout":[["s-dashboard-pages"],["s-dashboard-browserstack","s-dashboard-google","s-dashboard-web-vitals","s-dashboard-responsive"],["s-dashboard-project","s-dashboard-frontend-checker"]]},"env":{"envFromLocation":{"development":"https?://(localhost|127.0.0.1|0.0.0.0|192.168.[0-9]{1,3}.[0-9]{1,3}|.*.local)","staging":"https?://([a-zA-Z0-9.-]+)?staging([a-zA-Z0-9.-]+)?","production":"https://.*"},"git":{"template":{"name":"Template","commit":{}}}},"frontendServer":{"port":8080,"hostname":"127.0.0.1","rootDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io","staticDirs":{"/tmp":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/.local/tmp","/dist/css/partials":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/dist/css/partials","/dist":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/src"},"viewsDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/src/views","pagesDir":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/@websites/coffeekraken-io/src/pages","logLevel":"info","corsProxy":{"port":9999,"url":"http://127.0.0.1:9999","targetUrlHeaderName":"TargetUrl","limit":"12mb"},"proxy":{},"middlewares":{"bench":{"description":"Track how many times take a request","path":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/servers/s-frontend-server/dist/pkg/esm/config/../node/middleware/benchMiddleware","settings":{}},"request":{"description":"Inject the \\"request\\" object for views","path":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/servers/s-frontend-server/dist/pkg/esm/config/../node/middleware/requestMiddleware","settings":{}},"env":{"description":"Inject an \\"env\\" object for the views","path":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/servers/s-frontend-server/dist/pkg/esm/config/../node/middleware/envMiddleware","settings":{}},"packageJson":{"description":"Inject a \\"packageJson\\" object for the views","path":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/servers/s-frontend-server/dist/pkg/esm/config/../node/middleware/packageJsonMiddleware","settings":{}}},"data":{},"modules":{"404":{"description":"This module handle the 404 by rendering either your 404 page configured in the pages or the default 404 page","path":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/servers/s-frontend-server/dist/pkg/esm/config/../node/modules/404/404","settings":{}},"publicDir":{"description":"This module allows you to serve files from the public directory","path":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/servers/s-frontend-server/dist/pkg/esm/config/../node/modules/publicDir/publicDir","settings":{}},"upload":{"description":"This module allows you to upload files to the tmp/upload directory","path":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/servers/s-frontend-server/dist/pkg/esm/config/../node/modules/upload/upload","settings":{}},"generic":{"description":"This module gives you access to the \\"generic\\" handler that renders dynamically views from your page config","path":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/servers/s-frontend-server/dist/pkg/esm/config/../node/modules/generic/generic","settings":{}},"docmap":{"description":"This module gives you access to a \\"docmap\\" object in the views","path":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/servers/s-frontend-server/dist/pkg/esm/config/../node/modules/docmap/docmap","settings":{}},"carpenter":{"description":"This module gives you access to a \\"carpenter\\" object in the views","path":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/servers/s-frontend-server/dist/pkg/esm/config/../node/modules/carpenter/carpenter","settings":{}},"redirect":{"description":"This module allows you to make redirections depending on requested path","path":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/servers/s-frontend-server/dist/pkg/esm/config/../node/modules/redirect/redirect","settings":{}},"config":{"description":"This module gives you access to a \\"config\\" and a \\"configFiles\\" object into the views","path":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/servers/s-frontend-server/dist/pkg/esm/config/../node/modules/config/config","settings":{}},"frontspec":{"description":"This module gives you access to a \\"frontspec\\" object into the views","path":"/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/servers/s-frontend-server/dist/pkg/esm/config/../node/modules/frontspec/frontspec","settings":{}}},"pages":{},"handlers":{}},"kitchenActions":{"copy":{"title":"Copy file/directory","description":"Copy a file or a directory from the source to the destination passed in params","command":"sugar fs.copy [arguments]","params":{},"settings":{}},"rename":{"title":"Rename project","description":"Rename a project (folder, package.json, etc...)","command":"sugar package.rename [arguments]","params":{},"settings":{}},"initNpm":{"title":"Init npm package","description":"Init npm package in the project","command":"npm init es6 -y","params":{},"settings":{}},"addSugarJson":{"title":"Adding sugar.json file","description":"Adding the sugar.json file to the project","command":"sugar kitchen.add sugarJson [arguments]","params":{},"settings":{}},"addSugar":{"title":"Adding sugar","description":"Adding the sugar toolkit and the s-sugar feature in your project","command":"sugar kitchen.add sugar [arguments]","params":{},"settings":{}},"addNvmrc":{"title":"Adding .nvmrc file","description":"Adding the .nvmrc file to the project","command":"sugar kitchen.add nvmrc [arguments]","params":{},"settings":{}},"addFrontspecJson":{"title":"Adding frontspec.json file","description":"Adding the frontspec.json file to the project","command":"sugar kitchen.add frontspec [arguments]","params":{},"settings":{}},"addManifestJson":{"title":"Adding manifest.json file","description":"Adding the manifest.json file to the project","command":"sugar kitchen.add manifest [arguments]","params":{},"settings":{}},"addFavicon":{"title":"Adding source favicon file","description":"Adding the favicon source file to the project","command":"sugar kitchen.add favicon [arguments]","params":{},"settings":{}},"addReadme":{"title":"Adding source README.md file","description":"Adding the README.md source file to the project","command":"sugar kitchen.add readme [arguments]","params":{},"settings":{}},"addDefaultPages":{"title":"Adding default pages/views file","description":"Adding some default pages/views to the project","command":"sugar kitchen.add defaultPages [arguments]","params":{},"settings":{}},"addDefaultScripts":{"title":"Adding default script files","description":"Adding some default scripts to the project","command":"sugar kitchen.add defaultScripts [arguments]","params":{},"settings":{}},"addDefaultPackageJson":{"title":"Adding default package.json file","description":"Adding default package.json to the project","command":"sugar kitchen.add defaultPackageJson [arguments]","params":{},"settings":{}},"addSugarPostcss":{"title":"Adding sugar postcss plugin","description":"Adding the sugar postcss plugin to the project","command":"sugar kitchen.add postcss [arguments]","params":{},"settings":{}},"installDependencies":{"title":"Install dependencies","description":"Install dependencies like node_modules and composer if exists","command":"sugar package.install [arguments]","interface":"@coffeekraken/s-package/node/interface/SPackageInstallParamsInterface","params":{},"settings":{"silent":true}},"frontendServer":{"title":"Frontend server","description":"Frontend server using the @coffeekraken/s-frontend-server package","command":"sugar frontendServer.start [arguments]","interface":"@coffeekraken/s-frontend-server/node/interface/SFrontendServerStartParamsInterface","params":{},"settings":{"processManager":{"restart":true}}},"corsProxy":{"title":"Cors Proxy","description":"Frontend cors proxy server using the @coffeekraken/s-frontend-server package","command":"sugar frontendServer.corsProxy [arguments]","interface":"@coffeekraken/s-frontend-server/node/interface/SFrontendServerCorsProxyParamsInterface","params":{},"settings":{"processManager":{"restart":true}}},"postcssBuild":{"title":"PostCSS build action","description":"Build css using the amazing PostCSS package","command":"sugar postcss.build [arguments]","interface":"@coffeekraken/s-postcss-builder/node/interface/SPostcssBuilderBuildParamsInterface","params":{},"settings":{"processManager":{}}},"typescriptBuild":{"title":"Typescript builder build action","description":"Build typescript using the s-typescript-builder package","command":"sugar typescript.build [arguments]","interface":"@coffeekraken/s-typescript-builder/node/interface/STypescriptBuilderBuildParamsInterface","params":{"watch":true},"settings":{"processManager":{}}},"imagesBuild":{"title":"Images build action","description":"Build your images with ease. Compress, resize, webp version, etc...","command":"sugar images.build [arguments]","interface":"@coffeekraken/s-images-builder/node/interface/SImagesBuilderBuildParamsInterface","params":{},"settings":{"processManager":{}}},"vite":{"title":"Vite development stack","description":"Allow to build files easily while developing","command":"sugar vite [arguments]","interface":"@coffeekraken/s-vite/node/interface/SViteStartParamsInterface","params":{},"settings":{"processManager":{}}},"viteBuild":{"title":"Vite build stack","description":"Allow to compile javascript (js, ts, riot, react, etc...) files easily","command":"sugar vite.build [arguments]","interface":"@coffeekraken/s-vite/node/interface/SViteBuildParamsInterface","params":{},"settings":{"processManager":{}}},"docmapBuild":{"title":"Docmap build action","description":"Allow to build and maintain up to date the docmap.json file","command":"sugar docmap.build [arguments]","interface":"@coffeekraken/s-docmap/node/interface/SDocmapBuildParamsInterface","params":{},"settings":{"processManager":{}}},"sitemapBuild":{"title":"Sitemap build action","description":"Allow to build and maintain up to date the sitemap.xml file","command":"sugar sitemap.build [arguments]","interface":"@coffeekraken/s-sitemap-builder/node/interface/SSitemapBuilderBuildParamsInterface","params":{},"settings":{"processManager":{}}},"faviconBuild":{"title":"Docmap build action","description":"Allow to build and maintain up to date your favicon files and the manifest.json","command":"sugar favicon.build [arguments]","interface":"@coffeekraken/s-favicon-builder/node/interface/SFaviconBuilderBuildParamsInterface","params":{},"settings":{"processManager":{}}},"markdownBuild":{"title":"Docmap build action","description":"Allow to build your markdown files","command":"sugar markdown.build -p default,readme [arguments]","interface":"@coffeekraken/s-markdown-builder/node/interface/SMarkdownBuilderBuildParamsInterface","params":{},"settings":{"processManager":{}}},"format":{"title":"SCodeFormatter format action","description":"Format your code using the s-code-formatter package","command":"sugar formatter.format [arguments]","interface":"@coffeekraken/s-code-formatter/node/interface/SCodeFormatterFormatParamsInterface","params":{"watch":true},"settings":{"processManager":{}}}},"theme":{"theme":"default","variant":"light","cssVariables":["*"],"themes":{"default-light":{"defaultColor":"main","color":{},"lod":{"enabled":true,"defaultLevel":3,"levels":{"0":"bare","1":"low","2":"medium","3":"high","4":"extrem"},"cssProperties":{}},"easing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"scroll":{"duration":300,"offset":0,"offsetX":0,"offsetY":100},"timing":{},"transition":{},"gradient":{},"helpers":{},"layout":{"offset":{"top":100,"right":0,"bottom":0,"left":0},"container":{"default":"1280px","wide":"1440px","full":"none"},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","21":"2 1","112":"1 1 2","122":"1 2 2","123":"1 2 3","211":"2 1 1","221":"2 2 1","321":"3 2 1","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","2221":"2 2 2 1","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","22221":"2 2 2 2 1","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6","1_2":"1 _ 2","2_1":"2 _ 1","12_33":"1 2 _ 3 3","1_23":"1 _ 2 3","1_2_3":"1 _ 2 _ 3","32_1":"3 2 _ 1","3_21":"3 _ 2 1","12_34":"1 2 _ 3 4","123_4":"1 2 3 _ 4","1_234":"1 _ 2 3 4","1_2_3_4":"1 _ 2 _ 3 _ 4","123_45":"1 2 3 _ 4 5","12_345":"1 2 _ 3 4 5","1_2345":"1 _ 2 3 4 5","1234_5":"1 2 3 4 _ 5","1_2_3_4_5":"1 _ 2 _ 3 _ 4 _ 5"}},"ratio":{},"scalable":{},"scale":{},"opacity":{},"width":{},"height":{},"depth":{},"size":{},"font":{},"border":{},"space":{},"margin":{},"padding":{},"offsize":{},"media":{"defaultAction":"<=","defaultMedia":"desktop","defaultQuery":"screen","queries":{"mobile":{"minWidth":0,"maxWidth":639},"tablet":{"minWidth":640,"maxWidth":1279},"desktop":{"minWidth":1280,"maxWidth":2047},"wide":{"minWidth":2048,"maxWidth":null},"dwarf":{"minHeight":0,"maxHeight":950}}},"ui":{},"typo":{},"colorSchema":{},"metas":{"title":"Coffeekraken (default)","description":"Default Coffeekraken theme that you can use as a base for your custom theme"}},"default-dark":{"defaultColor":"main","color":{},"lod":{"enabled":true,"defaultLevel":3,"levels":{"0":"bare","1":"low","2":"medium","3":"high","4":"extrem"},"cssProperties":{}},"easing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"scroll":{"duration":300,"offset":0,"offsetX":0,"offsetY":100},"timing":{},"transition":{},"gradient":{},"helpers":{},"layout":{"offset":{"top":100,"right":0,"bottom":0,"left":0},"container":{"default":"1280px","wide":"1440px","full":"none"},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","21":"2 1","112":"1 1 2","122":"1 2 2","123":"1 2 3","211":"2 1 1","221":"2 2 1","321":"3 2 1","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","2221":"2 2 2 1","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","22221":"2 2 2 2 1","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6","1_2":"1 _ 2","2_1":"2 _ 1","12_33":"1 2 _ 3 3","1_23":"1 _ 2 3","1_2_3":"1 _ 2 _ 3","32_1":"3 2 _ 1","3_21":"3 _ 2 1","12_34":"1 2 _ 3 4","123_4":"1 2 3 _ 4","1_234":"1 _ 2 3 4","1_2_3_4":"1 _ 2 _ 3 _ 4","123_45":"1 2 3 _ 4 5","12_345":"1 2 _ 3 4 5","1_2345":"1 _ 2 3 4 5","1234_5":"1 2 3 4 _ 5","1_2_3_4_5":"1 _ 2 _ 3 _ 4 _ 5"}},"ratio":{},"scalable":{},"scale":{},"opacity":{},"width":{},"height":{},"depth":{},"size":{},"font":{},"border":{},"space":{},"margin":{},"padding":{},"offsize":{},"media":{"defaultAction":"<=","defaultMedia":"desktop","defaultQuery":"screen","queries":{"mobile":{"minWidth":0,"maxWidth":639},"tablet":{"minWidth":640,"maxWidth":1279},"desktop":{"minWidth":1280,"maxWidth":2047},"wide":{"minWidth":2048,"maxWidth":null},"dwarf":{"minHeight":0,"maxHeight":950}}},"ui":{},"typo":{},"colorSchema":{},"metas":{"title":"Coffeekraken (default)","description":"Default Coffeekraken theme that you can use as a base for your custom theme"}}}},"themeBase":{"defaultColor":"main","color":{},"lod":{"enabled":true,"defaultLevel":3,"levels":{"0":"bare","1":"low","2":"medium","3":"high","4":"extrem"},"cssProperties":{}},"easing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"scroll":{"duration":300,"offset":0,"offsetX":0,"offsetY":100},"timing":{},"transition":{},"gradient":{},"helpers":{},"layout":{"offset":{"top":100,"right":0,"bottom":0,"left":0},"container":{"default":"1280px","wide":"1440px","full":"none"},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","21":"2 1","112":"1 1 2","122":"1 2 2","123":"1 2 3","211":"2 1 1","221":"2 2 1","321":"3 2 1","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","2221":"2 2 2 1","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","22221":"2 2 2 2 1","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6","1_2":"1 _ 2","2_1":"2 _ 1","12_33":"1 2 _ 3 3","1_23":"1 _ 2 3","1_2_3":"1 _ 2 _ 3","32_1":"3 2 _ 1","3_21":"3 _ 2 1","12_34":"1 2 _ 3 4","123_4":"1 2 3 _ 4","1_234":"1 _ 2 3 4","1_2_3_4":"1 _ 2 _ 3 _ 4","123_45":"1 2 3 _ 4 5","12_345":"1 2 _ 3 4 5","1_2345":"1 _ 2 3 4 5","1234_5":"1 2 3 4 _ 5","1_2_3_4_5":"1 _ 2 _ 3 _ 4 _ 5"}},"ratio":{},"scalable":{},"scale":{},"opacity":{},"width":{},"height":{},"depth":{},"size":{},"font":{},"border":{},"space":{},"margin":{},"padding":{},"offsize":{},"media":{"defaultAction":"<=","defaultMedia":"desktop","defaultQuery":"screen","queries":{"mobile":{"minWidth":0,"maxWidth":639},"tablet":{"minWidth":640,"maxWidth":1279},"desktop":{"minWidth":1280,"maxWidth":2047},"wide":{"minWidth":2048,"maxWidth":null},"dwarf":{"minHeight":0,"maxHeight":950}}},"ui":{},"typo":{}},"themeDefault":{"themeName":"default","metas":{"title":"Coffeekraken (default)","description":"Default Coffeekraken theme that you can use as a base for your custom theme"},"variants":{"light":{"defaultColor":"main","color":{},"lod":{"enabled":true,"defaultLevel":3,"levels":{"0":"bare","1":"low","2":"medium","3":"high","4":"extrem"},"cssProperties":{}},"easing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"scroll":{"duration":300,"offset":0,"offsetX":0,"offsetY":100},"timing":{},"transition":{},"gradient":{},"helpers":{},"layout":{"offset":{"top":100,"right":0,"bottom":0,"left":0},"container":{"default":"1280px","wide":"1440px","full":"none"},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","21":"2 1","112":"1 1 2","122":"1 2 2","123":"1 2 3","211":"2 1 1","221":"2 2 1","321":"3 2 1","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","2221":"2 2 2 1","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","22221":"2 2 2 2 1","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6","1_2":"1 _ 2","2_1":"2 _ 1","12_33":"1 2 _ 3 3","1_23":"1 _ 2 3","1_2_3":"1 _ 2 _ 3","32_1":"3 2 _ 1","3_21":"3 _ 2 1","12_34":"1 2 _ 3 4","123_4":"1 2 3 _ 4","1_234":"1 _ 2 3 4","1_2_3_4":"1 _ 2 _ 3 _ 4","123_45":"1 2 3 _ 4 5","12_345":"1 2 _ 3 4 5","1_2345":"1 _ 2 3 4 5","1234_5":"1 2 3 4 _ 5","1_2_3_4_5":"1 _ 2 _ 3 _ 4 _ 5"}},"ratio":{},"scalable":{},"scale":{},"opacity":{},"width":{},"height":{},"depth":{},"size":{},"font":{},"border":{},"space":{},"margin":{},"padding":{},"offsize":{},"media":{"defaultAction":"<=","defaultMedia":"desktop","defaultQuery":"screen","queries":{"mobile":{"minWidth":0,"maxWidth":639},"tablet":{"minWidth":640,"maxWidth":1279},"desktop":{"minWidth":1280,"maxWidth":2047},"wide":{"minWidth":2048,"maxWidth":null},"dwarf":{"minHeight":0,"maxHeight":950}}},"ui":{},"typo":{},"colorSchema":{},"metas":{"title":"Coffeekraken (default)","description":"Default Coffeekraken theme that you can use as a base for your custom theme"}},"dark":{"defaultColor":"main","color":{},"lod":{"enabled":true,"defaultLevel":3,"levels":{"0":"bare","1":"low","2":"medium","3":"high","4":"extrem"},"cssProperties":{}},"easing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"scroll":{"duration":300,"offset":0,"offsetX":0,"offsetY":100},"timing":{},"transition":{},"gradient":{},"helpers":{},"layout":{"offset":{"top":100,"right":0,"bottom":0,"left":0},"container":{"default":"1280px","wide":"1440px","full":"none"},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","21":"2 1","112":"1 1 2","122":"1 2 2","123":"1 2 3","211":"2 1 1","221":"2 2 1","321":"3 2 1","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","2221":"2 2 2 1","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","22221":"2 2 2 2 1","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6","1_2":"1 _ 2","2_1":"2 _ 1","12_33":"1 2 _ 3 3","1_23":"1 _ 2 3","1_2_3":"1 _ 2 _ 3","32_1":"3 2 _ 1","3_21":"3 _ 2 1","12_34":"1 2 _ 3 4","123_4":"1 2 3 _ 4","1_234":"1 _ 2 3 4","1_2_3_4":"1 _ 2 _ 3 _ 4","123_45":"1 2 3 _ 4 5","12_345":"1 2 _ 3 4 5","1_2345":"1 _ 2 3 4 5","1234_5":"1 2 3 4 _ 5","1_2_3_4_5":"1 _ 2 _ 3 _ 4 _ 5"}},"ratio":{},"scalable":{},"scale":{},"opacity":{},"width":{},"height":{},"depth":{},"size":{},"font":{},"border":{},"space":{},"margin":{},"padding":{},"offsize":{},"media":{"defaultAction":"<=","defaultMedia":"desktop","defaultQuery":"screen","queries":{"mobile":{"minWidth":0,"maxWidth":639},"tablet":{"minWidth":640,"maxWidth":1279},"desktop":{"minWidth":1280,"maxWidth":2047},"wide":{"minWidth":2048,"maxWidth":null},"dwarf":{"minHeight":0,"maxHeight":950}}},"ui":{},"typo":{},"colorSchema":{},"metas":{"title":"Coffeekraken (default)","description":"Default Coffeekraken theme that you can use as a base for your custom theme"}}}},"themeDefaultDark":{"defaultColor":"main","color":{},"lod":{"enabled":true,"defaultLevel":3,"levels":{"0":"bare","1":"low","2":"medium","3":"high","4":"extrem"},"cssProperties":{}},"easing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"scroll":{"duration":300,"offset":0,"offsetX":0,"offsetY":100},"timing":{},"transition":{},"gradient":{},"helpers":{},"layout":{"offset":{"top":100,"right":0,"bottom":0,"left":0},"container":{"default":"1280px","wide":"1440px","full":"none"},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","21":"2 1","112":"1 1 2","122":"1 2 2","123":"1 2 3","211":"2 1 1","221":"2 2 1","321":"3 2 1","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","2221":"2 2 2 1","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","22221":"2 2 2 2 1","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6","1_2":"1 _ 2","2_1":"2 _ 1","12_33":"1 2 _ 3 3","1_23":"1 _ 2 3","1_2_3":"1 _ 2 _ 3","32_1":"3 2 _ 1","3_21":"3 _ 2 1","12_34":"1 2 _ 3 4","123_4":"1 2 3 _ 4","1_234":"1 _ 2 3 4","1_2_3_4":"1 _ 2 _ 3 _ 4","123_45":"1 2 3 _ 4 5","12_345":"1 2 _ 3 4 5","1_2345":"1 _ 2 3 4 5","1234_5":"1 2 3 4 _ 5","1_2_3_4_5":"1 _ 2 _ 3 _ 4 _ 5"}},"ratio":{},"scalable":{},"scale":{},"opacity":{},"width":{},"height":{},"depth":{},"size":{},"font":{},"border":{},"space":{},"margin":{},"padding":{},"offsize":{},"media":{"defaultAction":"<=","defaultMedia":"desktop","defaultQuery":"screen","queries":{"mobile":{"minWidth":0,"maxWidth":639},"tablet":{"minWidth":640,"maxWidth":1279},"desktop":{"minWidth":1280,"maxWidth":2047},"wide":{"minWidth":2048,"maxWidth":null},"dwarf":{"minHeight":0,"maxHeight":950}}},"ui":{},"typo":{},"colorSchema":{},"metas":{"title":"Coffeekraken (default)","description":"Default Coffeekraken theme that you can use as a base for your custom theme"}},"themeDefaultLight":{"defaultColor":"main","color":{},"lod":{"enabled":true,"defaultLevel":3,"levels":{"0":"bare","1":"low","2":"medium","3":"high","4":"extrem"},"cssProperties":{}},"easing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"scroll":{"duration":300,"offset":0,"offsetX":0,"offsetY":100},"timing":{},"transition":{},"gradient":{},"helpers":{},"layout":{"offset":{"top":100,"right":0,"bottom":0,"left":0},"container":{"default":"1280px","wide":"1440px","full":"none"},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","21":"2 1","112":"1 1 2","122":"1 2 2","123":"1 2 3","211":"2 1 1","221":"2 2 1","321":"3 2 1","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","2221":"2 2 2 1","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","22221":"2 2 2 2 1","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6","1_2":"1 _ 2","2_1":"2 _ 1","12_33":"1 2 _ 3 3","1_23":"1 _ 2 3","1_2_3":"1 _ 2 _ 3","32_1":"3 2 _ 1","3_21":"3 _ 2 1","12_34":"1 2 _ 3 4","123_4":"1 2 3 _ 4","1_234":"1 _ 2 3 4","1_2_3_4":"1 _ 2 _ 3 _ 4","123_45":"1 2 3 _ 4 5","12_345":"1 2 _ 3 4 5","1_2345":"1 _ 2 3 4 5","1234_5":"1 2 3 4 _ 5","1_2_3_4_5":"1 _ 2 _ 3 _ 4 _ 5"}},"ratio":{},"scalable":{},"scale":{},"opacity":{},"width":{},"height":{},"depth":{},"size":{},"font":{},"border":{},"space":{},"margin":{},"padding":{},"offsize":{},"media":{"defaultAction":"<=","defaultMedia":"desktop","defaultQuery":"screen","queries":{"mobile":{"minWidth":0,"maxWidth":639},"tablet":{"minWidth":640,"maxWidth":1279},"desktop":{"minWidth":1280,"maxWidth":2047},"wide":{"minWidth":2048,"maxWidth":null},"dwarf":{"minHeight":0,"maxHeight":950}}},"ui":{},"typo":{},"colorSchema":{},"metas":{"title":"Coffeekraken (default)","description":"Default Coffeekraken theme that you can use as a base for your custom theme"}},"themeEasing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"themeLayout":{"offset":{"top":100,"right":0,"bottom":0,"left":0},"container":{"default":"1280px","wide":"1440px","full":"none"},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","21":"2 1","112":"1 1 2","122":"1 2 2","123":"1 2 3","211":"2 1 1","221":"2 2 1","321":"3 2 1","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","2221":"2 2 2 1","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","22221":"2 2 2 2 1","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6","1_2":"1 _ 2","2_1":"2 _ 1","12_33":"1 2 _ 3 3","1_23":"1 _ 2 3","1_2_3":"1 _ 2 _ 3","32_1":"3 2 _ 1","3_21":"3 _ 2 1","12_34":"1 2 _ 3 4","123_4":"1 2 3 _ 4","1_234":"1 _ 2 3 4","1_2_3_4":"1 _ 2 _ 3 _ 4","123_45":"1 2 3 _ 4 5","12_345":"1 2 _ 3 4 5","1_2345":"1 _ 2 3 4 5","1234_5":"1 2 3 4 _ 5","1_2_3_4_5":"1 _ 2 _ 3 _ 4 _ 5"}},"themeLod":{"enabled":true,"defaultLevel":3,"levels":{"0":"bare","1":"low","2":"medium","3":"high","4":"extrem"},"cssProperties":{}},"themeMedia":{"defaultAction":"<=","defaultMedia":"desktop","defaultQuery":"screen","queries":{"mobile":{"minWidth":0,"maxWidth":639},"tablet":{"minWidth":640,"maxWidth":1279},"desktop":{"minWidth":1280,"maxWidth":2047},"wide":{"minWidth":2048,"maxWidth":null},"dwarf":{"minHeight":0,"maxHeight":950}}},"themeScroll":{"duration":300,"offset":0,"offsetX":0,"offsetY":100}}},"PACKAGE":{"name":"@website/coffeekraken-io","title":"Coffeekraken","version":"2.0.0-alpha.20","description":"The frontend toolkit that works for everyone. Experts, professionals and new-comers","type":"module","private":true,"scripts":{"dev":"sugard kitchen.run dev","prod":"sugard kitchen.run prod","build":"sugard kitchen.run build","deploy":"rsync -avzh --delete --progress --stats ./static fe0mt_coffeekraken@fe0mt.ftp.infomaniak.com:~/sites/coffeekraken.io","deploy.bogdanov":"rsync -avzh --delete --progress --stats ./static fe0mt_bogdanov_ssh@fe0mt.ftp.infomaniak.com:~/sites/bogdanov.coffeekraken.io"},"repository":{"type":"git","url":"https://olivierbossel.com"},"author":"Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)","license":"MIT","dependencies":{"@builder.io/html-to-figma":"^0.0.3","@coffeekraken/cli":"^2.0.0-alpha.20","@coffeekraken/s-activate-feature":"^2.0.0-alpha.20","@coffeekraken/s-appear-feature":"^2.0.0-alpha.20","@coffeekraken/s-bench":"^2.0.0-alpha.20","@coffeekraken/s-builder":"^2.0.0-alpha.20","@coffeekraken/s-carpenter":"^2.0.0-alpha.20","@coffeekraken/s-class":"^2.0.0-alpha.20","@coffeekraken/s-clipboard-copy-component":"^2.0.0-alpha.20","@coffeekraken/s-code-example-component":"^2.0.0-alpha.20","@coffeekraken/s-color":"^2.0.0-alpha.20","@coffeekraken/s-color-picker-component":"^2.0.0-alpha.20","@coffeekraken/s-component-utils":"^2.0.0-alpha.20","@coffeekraken/s-conductor":"^2.0.0-alpha.20","@coffeekraken/s-config":"^2.0.0-alpha.20","@coffeekraken/s-dashboard":"^2.0.0-alpha.20","@coffeekraken/s-datetime-picker-component":"^2.0.0-alpha.20","@coffeekraken/s-descriptor":"^2.0.0-alpha.20","@coffeekraken/s-docblock":"^2.0.0-alpha.20","@coffeekraken/s-docmap":"^2.0.0-alpha.20","@coffeekraken/s-duration":"^2.0.0-alpha.20","@coffeekraken/s-env":"^2.0.0-alpha.20","@coffeekraken/s-event-emitter":"^2.0.0-alpha.20","@coffeekraken/s-favicon-builder":"^2.0.0-alpha.20","@coffeekraken/s-feature":"^2.0.0-alpha.20","@coffeekraken/s-file":"^2.0.0-alpha.20","@coffeekraken/s-filtrable-input-component":"^2.0.0-alpha.20","@coffeekraken/s-floating-feature":"^2.0.0-alpha.20","@coffeekraken/s-form-validate-feature":"^2.0.0-alpha.20","@coffeekraken/s-frontend-server":"^2.0.0-alpha.20","@coffeekraken/s-frontspec":"^2.0.0-alpha.20","@coffeekraken/s-glitch-feature":"^2.0.0-alpha.20","@coffeekraken/s-glob":"^2.0.0-alpha.20","@coffeekraken/s-google-map-component":"^2.0.0-alpha.20","@coffeekraken/s-handlebars":"^2.0.0-alpha.20","@coffeekraken/s-highlight-feature":"^2.0.0-alpha.20","@coffeekraken/s-images-builder":"^2.0.0-alpha.20","@coffeekraken/s-inline-feature":"^2.0.0-alpha.20","@coffeekraken/s-interface":"^2.0.0-alpha.20","@coffeekraken/s-kitchen":"^2.0.0-alpha.20","@coffeekraken/s-lazy-feature":"^2.0.0-alpha.20","@coffeekraken/s-lit-component":"^2.0.0-alpha.20","@coffeekraken/s-log":"^2.0.0-alpha.20","@coffeekraken/s-markdown-builder":"^2.0.0-alpha.20","@coffeekraken/s-pack-essentials":"^2.0.0-alpha.20","@coffeekraken/s-page-transition-feature":"^2.0.0-alpha.20","@coffeekraken/s-panel-component":"^2.0.0-alpha.20","@coffeekraken/s-parallax-feature":"^2.0.0-alpha.20","@coffeekraken/s-postcss-sugar-plugin":"^2.0.0-alpha.20","@coffeekraken/s-process":"^2.0.0-alpha.20","@coffeekraken/s-promise":"^2.0.0-alpha.20","@coffeekraken/s-range-component":"^2.0.0-alpha.20","@coffeekraken/s-rating-component":"^2.0.0-alpha.20","@coffeekraken/s-refocus-feature":"^2.0.0-alpha.20","@coffeekraken/s-request":"^2.0.0-alpha.20","@coffeekraken/s-scroll-component":"^2.0.0-alpha.20","@coffeekraken/s-sitemap-builder":"^2.0.0-alpha.20","@coffeekraken/s-slider-component":"^2.0.0-alpha.20","@coffeekraken/s-state":"^2.0.0-alpha.20","@coffeekraken/s-static-builder":"^2.0.0-alpha.20","@coffeekraken/s-stdio":"^2.0.0-alpha.20","@coffeekraken/s-sugar-config":"^2.0.0-alpha.20","@coffeekraken/s-sugar-feature":"^2.0.0-alpha.20","@coffeekraken/s-sugar-json":"^2.0.0-alpha.20","@coffeekraken/s-theme":"^2.0.0-alpha.20","@coffeekraken/s-theme-switcher-component":"^2.0.0-alpha.20","@coffeekraken/s-timer":"^2.0.0-alpha.20","@coffeekraken/s-type":"^2.0.0-alpha.20","@coffeekraken/s-typescript-builder":"^2.0.0-alpha.20","@coffeekraken/s-url":"^2.0.0-alpha.20","@coffeekraken/s-view-renderer":"^2.0.0-alpha.20","@coffeekraken/s-vite":"^2.0.0-alpha.20","@coffeekraken/s-vite-postcss-plugin":"^2.0.0-alpha.20","@coffeekraken/s-vite-sugar-plugin":"^2.0.0-alpha.20","@coffeekraken/sugar":"^2.0.0-alpha.20","firebase":"^9.9.1","lit":"^2.2.8","lit-element":"^2.5.1","minisearch":"^3.3.0","three":"^0.143.0"},"devDependencies":{"esbuild":"^0.14.53"},"exports":{"./shared/*":{"require":"./dist/pkg/cjs/shared/*.js","import":"./dist/pkg/esm/shared/*.js"},"./node/*":{"require":"./dist/pkg/cjs/node/*.js","import":"./dist/pkg/esm/node/*.js"},"./js/*":{"require":"./dist/pkg/cjs/js/*.js","import":"./dist/pkg/esm/js/*.js"}},"homepage":"https://coffeekraken.io"}}`), {
  SUGAR: (_a2 = document.SUGAR) != null ? _a2 : {}
});
(async () => {
  SFeature.setDefaultProps("*", {
    mountWhen: "nearViewport"
  });
  SFeature.setDefaultProps(["s-highlight"], {
    opacity: 0.3,
    lod: 4
  });
  SFeature.setDefaultProps(["s-parallax", "s-appear"], {
    lod: 3
  });
  SFeature.setDefaultProps(["s-form-validate"], {
    customValidations: {
      coffeekraken: (value, helpers) => {
        if (value === "coffeekraken") {
          return helpers.message(
            "Are you sure? Krakens are dangerous..."
          );
        }
        return value;
      }
    }
  });
  SLitComponent.setDefaultProps("*", {
    mountWhen: "nearViewport"
  });
  SLitComponent.setDefaultProps(
    ["ck-search-input", "s-color-picker", "s-datetime-picker"],
    {
      mountWhen: "interact"
    }
  );
  SLitComponent.setDefaultProps(["s-panel", "ck-settings"], {
    mountWhen: "direct"
  });
  SLitComponent.setDefaultProps(["s-code-example"], {
    scrollToSettings: {
      offset: 100
    },
    responsive: {
      mobile: {
        lines: 5
      }
    }
  });
  STheme.init({
    variant: "dark"
  });
  SPackEssentials();
  define$8();
  define$9();
  define$7();
  define$a();
  define$g();
  define$i();
  define$t();
  define$m();
  define$c();
  define$f();
  define$e();
  define$d();
  define$b();
  define$3();
  define$2();
  define$6();
  define$4();
  define$5();
  define$1();
  __querySelectorLive(".s-code-example__content", ($elm) => {
    $elm.setAttribute("intensity", "0.3");
    $elm.setAttribute("s-highlight", "light");
  });
})();
export {
  SSugarConfig as S
};

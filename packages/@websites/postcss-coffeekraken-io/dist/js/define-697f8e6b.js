import{c as d,r as $,s as S,a as V,t as b,b as k,u as E,v as x,w as v,x as C,d as L}from"./index.esm.js";function j(t){return/^(?:(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11}))$/.test(t)}function A(t){return/^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(t.toLowerCase())}function M(t){return t.match(/^([0-9]{4})-(1[0-2]|0[1-9])$/)||t.match(/^([0-9]{4})-?(1[0-2]|0[1-9])-?(3[01]|0[1-9]|[12][0-9])$/)||t.match(/^([0-9]{4})(-?)(1[0-2]|0[1-9])\2(3[01]|0[1-9]|[12][0-9])$/)||t.match(/^([0-9]{4})-?(36[0-6]|3[0-5][0-9]|[12][0-9]{2}|0[1-9][0-9]|00[1-9])$/)}function D(t){return t.match(/^([0-9]{4})-?(1[0-2]|0[1-9])-?(3[01]|0[1-9]|[12][0-9])â†µ\s(2[0-3]|[01][0-9]):?([0-5][0-9]):?([0-5][0-9])$/)||t.match(/^(?:([0-9]{4})-?(1[0-2]|0[1-9])-?(3[01]|0[1-9]|[12][0-9])\s(2[0-3]|[01][0-9]):?([0-5][0-9]):?([0-5][0-9])|([0-9]{4})(1[0-2]|0[1-9])(3[01]|0[1-9]|[12][0-9])\s(2[0-3]|[01][0-9])([0-5][0-9])([0-5][0-9]))$/)}function T(t){return t.match(/^(2[0-3]|[01][0-9]):?([0-5][0-9])$/)||t.match(/^(2[0-3]|[01][0-9]):?([0-5][0-9]):?([0-5][0-9])$/)||t.match(/^(Z|[+-](?:2[0-3]|[01][0-9])(?::?(?:[0-5][0-9]))?)$/)||t.match(/^(2[0-3]|[01][0-9]):?([0-5][0-9]):?([0-5][0-9])(Z|[+-](?:2[0-3]|[01][0-9])(?::?(?:[0-5][0-9]))?)$/)}const h={min:{string:"Must have at least %n characters",object:"Must have at least %n properties",number:"Must be greater than %n",array:"Must have at least %n items"},max:{string:"Must have at max %n characters",object:"Must have at max %n properties",number:"Must be lower than %n",array:"Must have at max %n items"},email:{string:"Must be a valid email address"},required:{default:"This is required"},isoDate:{string:"Must be a valid ISO date"},isoTime:{string:"Must be a valid ISO time"},isoDateTime:{string:"Must be a valid ISO date time"},integer:{string:"Must be an integer"},number:{string:"Must be an number"},negative:{string:"Must be a negative number"},positive:{string:"Must be a positive number"},pattern:{string:"Must match the pattern %pattern"},alphanum:{string:"Must contain only alphanumeric characters"},creditCard:{string:"Must be a valid credit card number"},color:{string:"Must be a valid color (hex, rgb, rgba, hsl, hsla)"},hex:{string:"Must be a valid hex color"},password:{weak:"",medium:"Must be >=6 characters, at least 1 lowercase/uppercase/special character",strong:"Must be >=8 characters, at least 1 lowercase/uppercase/digit/special character"}},O={description:"Validate an alphanum string",type:"String"};function N(t,e){let i,r;if(e=d({i18n:h.alphanum,trim:!0},e??{}),typeof t!="string")throw new Error('Sorry but the "alphanum" validation only works with string');return{valid:r=(t=e.trim?t.trim():t).match(/^[a-z0-9]+$/i),message:i=r?i:(t=e.i18n)==null?void 0:t.string}}const B={description:"Validate a color string",type:"String"};function q(t,e){let i,r;if(e=d({i18n:h.color,trim:!0},e??{}),typeof t!="string")throw new Error('Sorry but the "color" validation only works with string');return e.trim&&(t=t.trim()),{valid:r=$(t),message:i=r?i:(t=e.i18n)==null?void 0:t.string}}const R={description:"Validate a credit card string",type:"String"};function Z(t,e){let i,r;if(e=d({i18n:h.creditCard,trim:!0},e??{}),typeof t!="string")throw new Error('Sorry but the "creditCard" validation only works with string');return{valid:r=j(t=e.trim?t.trim():t),message:i=r?i:(t=e.i18n)==null?void 0:t.string}}const z={description:"Validate an email string",type:"String"};function F(t,e){let i,r;if(e=d({i18n:h.email,trim:!0},e??{}),typeof t!="string")throw new Error('Sorry but the "email" validation only works with string');return{valid:r=A(t=e.trim?t.trim():t),message:i=r?i:(t=e.i18n)==null?void 0:t.string}}const I={description:"Validate a hexadecimal string",type:"String"};function H(t,e){let i,r;if(e=d({i18n:h.hex,trim:!0},e??{}),typeof t!="string")throw new Error('Sorry but the "hex" validation only works with string');return{valid:r=(t=e.trim?t.trim():t).match(/^#[a-zA-Z0-9]{3,6}$/),message:i=r?i:(t=e.i18n)==null?void 0:t.string}}const P={description:"Validate an integer",type:"number"};function U(t,e){let i,r;if(e=d({i18n:h.integer,cast:!0,trim:!0},e??{}),typeof t!="string"&&typeof t!="number")throw new Error('Sorry but the "integer" validation only works with string and number');return typeof(t=typeof t=="string"&&e.trim?t.trim():t)=="string"&&e.cast&&(t=Number(t)),(r=!isNaN(t)&&Number.isInteger(t))||(i=(t=e.i18n)==null?void 0:t.string),{valid:r,message:i}}const W={description:"Validate an iso date string",type:"String"};function Y(t,e){let i,r;if(e=d({i18n:h.isoDate,trim:!0},e??{}),typeof t!="string")throw new Error('Sorry but the "isoDate" validation only works with string');return{valid:r=M(t=e.trim?t.trim():t),message:i=r?i:(t=e.i18n)==null?void 0:t.string}}const G={description:"Validate an iso date string",type:"String"};function J(t,e){let i,r;if(e=d({i18n:h.isoDateTime,trim:!0},e??{}),typeof t!="string")throw new Error('Sorry but the "isoDateTime" validation only works with string');return{valid:r=D(t=e.trim?t.trim():t),message:i=r?i:(t=e.i18n)==null?void 0:t.string}}const K={description:"Validate an iso time string",type:"String"};function Q(t,e){let i,r;if(e=d({i18n:h.isoTime,trim:!0},e??{}),typeof t!="string")throw new Error('Sorry but the "isoTime" validation only works with string');return{valid:r=T(t=e.trim?t.trim():t),message:i=r?i:(t=e.i18n)==null?void 0:t.string}}const X={description:'Validate string, array, object and number using the "max" rule',type:"String|Array|Object|Number"};function tt(t,e,i){var r;let s,a;var n=d({i18n:h.max,trim:!0},i??{});switch(!0){case typeof t=="string":n.trim&&(t=t.trim()),a=t.length<=e,s=(r=n.i18n)==null?void 0:r.string.replace("%n",e);break;case typeof t=="number":a=t<=e,s=(r=n.i18n)==null?void 0:r.number.replace("%n",e);break;case Array.isArray(t):a=t.length<=e,s=(r=n.i18n)==null?void 0:r.array.replace("%n",e);break;case typeof t=="object":a=Object.keys(t).length<=e,s=(r=n.i18n)==null?void 0:r.object.replace("%n",e);break;default:throw new Error('Sorry but the "max" validation only works with string, number, array or object values.')}return{valid:a,message:s}}const et={description:'Validate string, array, object and number using the "min" rule',type:"String|Array|Object|Number"};function it(t,e,i){var r;let s,a;var n=d({i18n:h.min,trim:!0},i??{});switch(!0){case typeof t=="string":n.trim&&(t=t.trim()),a=t.length>=e,s=(r=n.i18n)==null?void 0:r.string.replace("%n",e);break;case typeof t=="number":a=e<=t,s=(r=n.i18n)==null?void 0:r.number.replace("%n",e);break;case Array.isArray(t):a=t.length>=e,s=(r=n.i18n)==null?void 0:r.array.replace("%n",e);break;case typeof t=="object":a=Object.keys(t).length>=e,s=(r=n.i18n)==null?void 0:r.object.replace("%n",e);break;default:throw new Error('Sorry but the "min" validation only works with string, number, array or object values.')}return{valid:a,message:s}}const rt={description:"Validate an negative number",type:"number"};function st(t,e){let i,r;if(e=d({i18n:h.negative,cast:!0,trim:!0},e??{}),typeof t!="string"&&typeof t!="number")throw new Error('Sorry but the "negative" validation only works with string and number');return typeof(t=typeof t=="string"&&e.trim?t.trim():t)=="string"&&e.cast&&(t=Number(t)),(r=!isNaN(t)&&t<0)||(i=(t=e.i18n)==null?void 0:t.string),{valid:r,message:i}}const at={description:"Validate an number",type:"number"};function nt(t,e){let i,r;if(e=d({i18n:h.number,cast:!0,trim:!0},e??{}),typeof t!="string"&&typeof t!="number")throw new Error('Sorry but the "number" validation only works with string and number');return typeof(t=typeof t=="string"&&e.trim?t.trim():t)=="string"&&e.cast&&(t=Number(t)),(r=!isNaN(t))||(i=(t=e.i18n)==null?void 0:t.string),{valid:r,message:i}}const ot={description:"Validate a password string",type:"String"};function lt(t,e,i){let r,s=!1;if(i=d({i18n:h.password,trim:!0,weakReg:/.*/,mediumReg:/((?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[^A-Za-z0-9])(?=.{6,}))|((?=.*[a-z])(?=.*[A-Z])(?=.*[^A-Za-z0-9])(?=.{8,}))/,strongReg:/(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[^A-Za-z0-9])(?=.{8,})/},i??{}),typeof t!="string")throw new Error('Sorry but the "password" validation only works with string');i.trim&&(t=t.trim());var a=[];return i.weakReg.test(t)&&(t&&a.push("weak"),e==="weak")&&(s=!0),i.mediumReg.test(t)&&(t&&a.push("medium"),e==="medium")&&(s=!0),(s=i.strongReg.test(t)&&(t&&a.push("strong"),e==="strong")?!0:s)||(r=(t=i.i18n)==null?void 0:t[e]),{valid:s,message:r,metas:{levels:["weak","medium","strong"],validLevels:a}}}const dt={description:"Validate a string using a regex pattern",type:"String"};function ut(t,e,i){let r,s;if(i=d({i18n:h.pattern,trim:!0},i??{}),typeof t!="string")throw new Error('Sorry but the "pattern" validation only works with string');return i.trim&&(t=t.trim()),{valid:s=new RegExp(e).test(t),message:r=s?r:(t=i.i18n)==null?void 0:t.string.replace("%pattern",e)}}const ht={description:"Validate an positive number",type:"number"};function pt(t,e){let i,r;if(e=d({i18n:h.positive,cast:!0,trim:!0},e??{}),typeof t!="string"&&typeof t!="number")throw new Error('Sorry but the "positive" validation only works with string and number');return typeof(t=typeof t=="string"&&e.trim?t.trim():t)=="string"&&e.cast&&(t=Number(t)),(r=!isNaN(t)&&0<=t)||(i=(t=e.i18n)==null?void 0:t.string),{valid:r,message:i}}const ct={description:"Make sure a value has been provided",type:"Boolean"};function mt(t,e){let i,r;return e=d({i18n:h.required,trim:!0},e??{}),{valid:r=(t=typeof t=="string"&&e.trim?t.trim():t)!=null&&t!=="",message:i=r?i:(t=e.i18n)==null?void 0:t.default}}class o extends S{static registerValidator(e,i,r){o._validators[e]={validator:i,settings:r}}static registerPreset(e,i,r){o._presets[e]={rules:i,settings:r}}static getValidatorsDefinition(){var e,i,r={};for([e,i]of Object.entries(o._validators))i.settings.definition&&(r[e]=i.settings.definition);return r}constructor(e){super(d({i18n:h},e??{}))}validate(e,i,r){var s,a,n={valid:!0,rules:{},messages:[]};let l=i;if(typeof i=="string"){if(!o._presets[i])throw new Error(`Sorry but the preset "${i}" is not registered`);l=o._presets[i].rules}for([s,a]of Object.entries(l)){let c=(p=a.settings)!=null?p:{},f=(p=a.value)!=null?p:a,m;var p=o._validators[s];if(!p)throw new Error(`Sorry but the validator "${s}" is not registered`);var u=Object.assign(Object.assign({},c),{i18n:(u=this.settings.i18n[s])!=null?u:{}});(m=typeof i=="boolean"?p.validator(e,u):p.validator(e,f,u)).valid?n.rules[s]=m:(m.message=m.message.replace("%value",e).replace("%validator",s),n.valid=!1,n.rules[s]=m,n.messages.push(m.message))}return n}}o._validators={},o._presets={},o.registerValidator("min",it,{definition:et}),o.registerValidator("max",tt,{definition:X}),o.registerValidator("email",F,{definition:z}),o.registerValidator("required",mt,{definition:ct}),o.registerValidator("isoDate",Y,{definition:W}),o.registerValidator("isoTime",Q,{definition:K}),o.registerValidator("isoDateTime",J,{definition:G}),o.registerValidator("integer",U,{definition:P}),o.registerValidator("number",nt,{definition:at}),o.registerValidator("negative",st,{definition:rt}),o.registerValidator("positive",pt,{definition:ht}),o.registerValidator("pattern",ut,{definition:dt}),o.registerValidator("alphanum",N,{definition:O}),o.registerValidator("creditCard",Z,{definition:R}),o.registerValidator("color",q,{definition:B}),o.registerValidator("hex",H,{definition:I}),o.registerValidator("password",lt,{definition:ot});const ft=`@keyframes error-message-appear{0%{line-height:1;max-height:0}to{max-height:2em;line-height:2}}.s-form-validate+.s-form-validate-error-message{text-align:end;color:hsla(calc(var(--s-color-error-h, 0) + var(--s-color-error-spin ,0)),calc((var(--s-color-error-s, 0)) * 1%),calc((var(--s-color-error-l, 0)) * 1%),var(--s-color-error-a, 1));overflow:hidden;max-height:0;line-height:1;margin:0;animation:.2s error-message-appear var(--s-easing-default, 0) forwards}
`,w=o.getValidatorsDefinition(),_={};for(let[t,e]of Object.entries(w))_[t+"Message"]={description:`The message to display when the validator "${t}" fails`,type:"String"};class g extends V{static get _definition(){return Object.assign(Object.assign(Object.assign({},w),_),{type:{description:"Specify the validation type. Usually automatically detected depending on the field type",type:"String",default:"text"},on:{description:'Specify when to trigger a validation. Can be "change","submit","enter" and/or "reset"',type:"Array<String>",values:["keyup","change","submit","enter","reset"],default:["keyup","change","submit","enter","reset"]},format:{description:'Specify if you want your value to be formatted a certain way. You can specify every "import { __format } from `@coffeekraken/sugar/string`" supported formats',type:"String",values:b.formats},errorClass:{description:"Specify the class to apply when theres an error",type:"String",default:"s-form-validate--error s-color--error"},validClass:{description:"Specify the class to apply on your s-form-validate element when validation is passed successfully",type:"String",default:"s-form-validate--valid s-color--success"},handlers:{description:'Specify some custom handlers by validator that will be executed in addition to the default validate behavior. The handler will take as argument an object containing the "result" SValidator result, the "$feature" that represent the s-validate node, the "$form" node if exists, the "$node" attached node if using the "nodes" property, the "$field" that represent the input field handled and the "props" that represent the feature properties',type:"Object",default:{}},nodes:{description:'Specify a css selector that target some HTMLElements used for the validation. Every HTMLElement has to specify 1 validator by using element attributes (same as on the feature itself). Classes are applied on each "node" to specify if the validator is valid or not',type:"String"},language:{description:"Specify the language you want to use for messages",type:"String",default:"en"},displayError:{description:"Specify if you want to display the error messages or not",type:"Boolean",default:!0},errorContainerAttr:{description:"Specify the attribute to search for the error container. If not found, a default container will be created and inserted after your s-form-validate element",type:"String",default:"s-form-validate-error"}})}}var gt=globalThis&&globalThis.__awaiter||function(t,e,i,r){return new(i=i||Promise)(function(s,a){function n(u){try{p(r.next(u))}catch(c){a(c)}}function l(u){try{p(r.throw(u))}catch(c){a(c)}}function p(u){var c;u.done?s(u.value):((c=u.value)instanceof i?c:new i(function(f){f(c)})).then(n,l)}p((r=r.apply(t,e||[])).next())})};class y extends k{constructor(e,i,r){var s;Object.keys((s=(s=E.getDefaultProps(e))==null?void 0:s.customValidations)!=null?s:{}).forEach(a=>{g.definition[a]||(g.definition[a]={type:"String|Boolean"})}),super(e,i,d({name:"s-form-validate",interface:g,style:ft},r??{})),this._nodeByValidator={},this._isDirty=!1,this._isValidating=!1,(s=this.props.handlers)!=null&&s.password||(e=this.props.handlers)!=null&&(e.password=this._passwordDefaultHandler),this._validator=new o,this._$form=x(this.node,"form"),this._$form&&this._$form.addEventListener("submit",a=>{var n;if(!this._$form._submitHandler){this._$form._submitHandler=!0;const l=[],p=u=>{l.push(u.detail)};this._$form.addEventListener("s-form-validate.error",p),a.preventDefault(),a instanceof CustomEvent&&((n=a.detail)==null||!n.internal)||a.stopPropagation(),setTimeout(()=>{delete this._$form._submitHandler,this._$form.removeEventListener("s-form-validate.error",p),l.length||(this._$form.submit(),a instanceof CustomEvent)||this._$form.dispatchEvent(new CustomEvent("submit",{bubbles:!0,cancelable:!0}))})}}),this.utils.exposeApi({validate:this.validate},this),this.props.nodes&&(this._$nodes=this.node.querySelectorAll(this.props.nodes),this._$nodes.forEach(a=>{for(let l=0;l<a.attributes.length;l++){var n=a.attributes[l];n.name in this.props&&(this.props[v(n.name)]=C(n.value),this._nodeByValidator[v(n.name)]=a)}}))}mount(){L("input,textarea,select",e=>{this._initField(e)},{rootNode:this.node,scopes:!1}),this.props.type&&(this.props.type==="text"?this._validationType="string":this._validationType=this.props.type)}_passwordDefaultHandler({result:e,$feature:i}){var r;e.valid?(i.classList.remove("password-weak"),i.classList.remove("password-medium"),i.classList.remove("password-strong")):(r=e.metas)!=null&&r.levels&&e.metas.levels.forEach(s=>{s!==e.metas.validLevels.slice(-1)[0]?i.classList.remove("password-"+s):i.classList.add("password-"+s)})}_initField(e){this._$field=e,this._$field=this.node,e=this.node.querySelector("input,textarea,select"),e&&(this._$field=e),this._$field.setAttribute("novalidate","true"),["required","maxlength","minlength","max","min","pattern"].forEach(i=>{!this._$field.hasAttribute(i)||this.props[i]||(this.props[i]=this._$field.getAttribute(i),i!=="maxlength"&&i!=="minlength"&&this._$field.removeAttribute(i))}),["keydown","change"].forEach(i=>{this._$field.addEventListener(i,r=>{!this.props.format||r.target.type!=="text"&&r.target.tagName.toLowerCase()!=="textarea"||setTimeout(()=>{var s=this.format((s=r.target.value)!=null?s:"",this.props.format);s!==r.target.value&&(this._$field.value=s)})})}),this.props.on.forEach(i=>{var r;i==="enter"?this._$field.addEventListener("keyup",s=>{s.keyCode===13&&(this._$form?this._$form.dispatchEvent(new CustomEvent("submit",{bubbles:!1,detail:{internal:!0}})):this.validate(s))}):i==="reset"?(r=this._$field.form)!=null&&r.addEventListener(i,s=>{setTimeout(()=>{this.validate(s)})}):i==="submit"?(r=this._$field.form)!=null&&r.addEventListener(i,s=>{var a;s.preventDefault(),s instanceof CustomEvent&&((a=s.detail)==null||!a.internal)||(s.stopPropagation(),this.validate(s))}):i==="keyup"?this.node.addEventListener(i,s=>{this._isDirty&&this.validate(s)}):this.node.addEventListener(i,s=>{this.validate(s)})})}format(e,i){return b(e,i)}validate(e){var i;if(!this._$field)throw new Error("No $field has been found to be validated...");var r=this._getFieldValue();if(((i=e==null?void 0:e.currentTarget)==null?void 0:i.tagName.toLowerCase())==="form"&&e.type!=="reset"&&e.preventDefault(),!this._isValidating){this._isValidating=!0,setTimeout(()=>{this._isValidating=!1});let l;var s,a,n={};for([s,a]of Object.entries(o.getValidatorsDefinition()))this.props[s]!==void 0&&(n[s]=this.props[s]);l=this._validator.validate(r,n),e.type==="reset"&&(l={valid:!0}),this._applyResult(l,e)}}_getFieldValue(){switch(!0){case this._$field.type==="checkbox":return this._getCheckboxValues();case this._$field.type==="range":return this._getRangeValue();case this._$field.tagName.toLowerCase()==="select":return this._getSelectValues();case this._$field.type==="radio":return this._getRadioValue();default:return this._$field.value}}_getCheckboxValues(){return Array.from(this.node.querySelectorAll('input[type="checkbox"]:checked')).map(e=>e.value)}_getRadioValue(){return this.node.querySelector('input[type="radio"]:checked').value}_getRangeValue(){return parseFloat(this._$field.value)}_getSelectValues(){return Array.from(this._$field.querySelectorAll("option")).filter(e=>e.selected).map(e=>e.value)}_applyResult(e,i){var r,s;return gt(this,void 0,void 0,function*(){for(var[a,n]of Object.entries(o.getValidatorsDefinition()))this.props[a]&&this.props.handlers[a]&&(yield this.props.handlers[a]({result:Object.assign({},(r=(r=e.rules)==null?void 0:r[a])!=null?r:e),props:this.props,$feature:this.node,$form:this._$form,$field:this._$field,$node:(r=this._nodeByValidator)==null?void 0:r[a]}));if(e.valid){if(this._isDirty=!1,i.type!=="reset"?this.node.classList.add(...this.props.validClass.split(" ")):this.node.classList.remove(...this.props.validClass.split(" ")),this.node.classList.remove(...this.props.errorClass.split(" ")),(s=this._$error)!=null&&s.hasAttribute("s-form-validate-error")&&(s=this._$error)!=null&&s.remove(),Object.keys(this._nodeByValidator).length)for(var[l,p]of Object.entries(e.rules))this._nodeByValidator[l]&&(this._nodeByValidator[l].classList.remove(...this.props.errorClass.split(" ")),this._nodeByValidator[l].classList.add(...this.props.validClass.split(" ")));this.utils.dispatchEvent("valid",{detail:e})}else{this._isDirty=!0,this.node.classList.add(...this.props.errorClass.split(" ")),this.node.classList.remove(...this.props.validClass.split(" "));var u=Object.keys(e.rules)[0];if(Object.keys(this._nodeByValidator).length)for(var[c,f]of Object.entries(e.rules))this._nodeByValidator[c]&&(f.valid?(this._nodeByValidator[c].classList.remove(...this.props.errorClass.split(" ")),this._nodeByValidator[c].classList.add(...this.props.validClass.split(" "))):(this._nodeByValidator[c].classList.remove(...this.props.validClass.split(" ")),this._nodeByValidator[c].classList.add(...this.props.errorClass.split(" "))));else u=this.props[u+"Message"]||e.messages[0],this.props.displayError&&(this._$error=(s=this.node.querySelector(`[${this.props.errorContainerAttr}]`))!=null?s:this.node.nextElementSibling,this._$error&&this._$error.hasAttribute("s-form-validate-error")||(this._$error=document.createElement("p"),this._$error.setAttribute("s-form-validate-error","true"),this._$error.classList.add("s-form-validate-error-message"),this.node.parentNode.insertBefore(this._$error,this.node.nextSibling)),this._$error.innerHTML=u);this.utils.dispatchEvent("error",{detail:e})}})}}function yt(t={},e="s-form-validate"){y.define(e,y,Object.assign({mountWhen:"inViewport"},t))}export{yt as default};

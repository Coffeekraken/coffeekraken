class SClass {
  static extends(Cls) {
    class SClass2 extends Cls {
      constructor(settings, ...args) {
        super(...args);
        this.settings = {};
        setSettings(this, settings);
        this.metas = getMetas(this);
        Object.defineProperty(this, "metas", {
          enumerable: true,
          value: getMetas(this)
        });
      }
      expose(instance, settings) {
        return expose(this, instance, settings);
      }
      toPlainObject() {
        return toPlainObject(this);
      }
    }
    return SClass2;
  }
  /**
   * @name            constructor
   * @type            Function
   * @constructor
   *
   * Constructor
   *
   * @since           2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  constructor(settings = {}) {
    this.settings = {};
    setSettings(this, settings);
    this.metas = getMetas(this);
    Object.defineProperty(this, "metas", {
      enumerable: true,
      value: getMetas(this)
    });
  }
  expose(instance, settings) {
    return expose(this, instance, settings);
  }
  toPlainObject() {
    return toPlainObject(this);
  }
}
function getMetas(ctx) {
  var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h;
  let name2 = `<yellow>${((_a2 = ctx.settings.metas) === null || _a2 === void 0 ? void 0 : _a2.name) || ""}</yellow>`;
  if ((_b2 = ctx.settings.metas) === null || _b2 === void 0 ? void 0 : _b2.id) {
    name2 += ` <cyan>${ctx.settings.metas.id}</cyan>`;
  }
  const metasObj = {
    id: (_d2 = (_c2 = ctx.settings.metas) === null || _c2 === void 0 ? void 0 : _c2.id) !== null && _d2 !== void 0 ? _d2 : ctx.constructor.name,
    name: (_f2 = (_e2 = ctx.settings.metas) === null || _e2 === void 0 ? void 0 : _e2.name) !== null && _f2 !== void 0 ? _f2 : ctx.constructor.name,
    formattedName: name2,
    color: (_h = (_g2 = ctx.settings.metas) === null || _g2 === void 0 ? void 0 : _g2.color) !== null && _h !== void 0 ? _h : "yellow"
  };
  return metasObj;
}
function expose(ctx, instance, settings) {
  var _a2;
  settings = Object.assign({ as: void 0, props: [] }, settings !== null && settings !== void 0 ? settings : {});
  if (settings.as && typeof settings.as === "string") {
    ctx[settings.as] = instance;
  }
  (_a2 = settings === null || settings === void 0 ? void 0 : settings.props) === null || _a2 === void 0 ? void 0 : _a2.forEach((prop) => {
    if (instance[prop].bind && typeof instance[prop].bind === "function") {
      ctx[prop] = instance[prop].bind(instance);
    } else {
      ctx[prop] = instance[prop];
    }
  });
}
function toPlainObject(ctx) {
  return JSON.parse(JSON.stringify(ctx));
}
function setSettings(ctx, settings = {}) {
  var _a2;
  ctx.settings = settings;
  if (!ctx.settings.metas)
    ctx.settings.metas = {};
  if (!((_a2 = ctx.settings.metas) === null || _a2 === void 0 ? void 0 : _a2.id))
    ctx.settings.metas.id = ctx.constructor.name;
  ctx.settings.metas.color = "yellow";
}
function __isPlainObject(object) {
  if (!object)
    return false;
  if (typeof object !== "object")
    return false;
  if (object.constructor && object.constructor.name !== "Object")
    return false;
  if (Object.prototype.toString.call(object) !== "[object Object]")
    return false;
  if (object !== Object(object))
    return false;
  return true;
}
function __camelize(text) {
  if (!text)
    text = "";
  let res = "";
  const reg = /(?:^|[_-\s])(\w)/g;
  res = text.replace(reg, function(_, c) {
    return c ? c.toUpperCase() : "";
  });
  res = res.substr(0, 1).toLowerCase() + res.slice(1);
  return res.trim();
}
function __camelCase(text) {
  return __camelize(text);
}
function __camelCaseProps(object, settings) {
  const finalSettings = Object.assign({ deep: true }, settings !== null && settings !== void 0 ? settings : {});
  for (let [key, value] of Object.entries(object)) {
    const newKey = __camelCase(key);
    if (__isPlainObject(value) && finalSettings.deep) {
      object[newKey] = __camelCaseProps(object[key], finalSettings);
    } else {
      object[newKey] = value;
    }
    if (newKey !== key) {
      delete object[key];
    }
  }
  return object;
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        var args = [null];
        args.push.apply(args, arguments);
        var Ctor = Function.bind.apply(f, args);
        return new Ctor();
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d2 = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var lodash_clone = { exports: {} };
lodash_clone.exports;
(function(module, exports) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reFlags = /\w*$/;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  function addMapEntry(map2, pair) {
    map2.set(pair[0], pair[1]);
    return map2;
  }
  function addSetEntry(set2, value) {
    set2.add(value);
    return set2;
  }
  function arrayEach(array, iteratee) {
    var index = -1, length = array ? array.length : 0;
    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset2 = array.length;
    while (++index < length) {
      array[offset2 + index] = values[index];
    }
    return array;
  }
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array ? array.length : 0;
    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }
  function baseTimes(n, iteratee) {
    var index = -1, result2 = Array(n);
    while (++index < n) {
      result2[index] = iteratee(index);
    }
    return result2;
  }
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  function isHostObject(value) {
    var result2 = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result2 = !!(value + "");
      } catch (e) {
      }
    }
    return result2;
  }
  function mapToArray(map2) {
    var index = -1, result2 = Array(map2.size);
    map2.forEach(function(value, key) {
      result2[++index] = [key, value];
    });
    return result2;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  function setToArray(set2) {
    var index = -1, result2 = Array(set2.size);
    set2.forEach(function(value) {
      result2[++index] = value;
    });
    return result2;
  }
  var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString = funcProto.toString;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var Buffer2 = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
  var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
  var DataView2 = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
  var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet(key) {
    var data2 = this.__data__;
    if (nativeCreate) {
      var result2 = data2[key];
      return result2 === HASH_UNDEFINED ? void 0 : result2;
    }
    return hasOwnProperty2.call(data2, key) ? data2[key] : void 0;
  }
  function hashHas(key) {
    var data2 = this.__data__;
    return nativeCreate ? data2[key] !== void 0 : hasOwnProperty2.call(data2, key);
  }
  function hashSet(key, value) {
    var data2 = this.__data__;
    data2[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key) {
    var data2 = this.__data__, index = assocIndexOf(data2, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data2.length - 1;
    if (index == lastIndex) {
      data2.pop();
    } else {
      splice.call(data2, index, 1);
    }
    return true;
  }
  function listCacheGet(key) {
    var data2 = this.__data__, index = assocIndexOf(data2, key);
    return index < 0 ? void 0 : data2[index][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data2 = this.__data__, index = assocIndexOf(data2, key);
    if (index < 0) {
      data2.push([key, value]);
    } else {
      data2[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash()
    };
  }
  function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function Stack(entries) {
    this.__data__ = new ListCache(entries);
  }
  function stackClear() {
    this.__data__ = new ListCache();
  }
  function stackDelete(key) {
    return this.__data__["delete"](key);
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var cache2 = this.__data__;
    if (cache2 instanceof ListCache) {
      var pairs = cache2.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        return this;
      }
      cache2 = this.__data__ = new MapCache(pairs);
    }
    cache2.set(key, value);
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var result2 = isArray2(value) || isArguments5(value) ? baseTimes(value.length, String) : [];
    var length = result2.length, skipIndexes = !!length;
    for (var key in value) {
      if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
        result2.push(key);
      }
    }
    return result2;
  }
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
      object[key] = value;
    }
  }
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseAssign(object, source2) {
    return object && copyObject(source2, keys3(source2), object);
  }
  function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
    var result2;
    if (customizer) {
      result2 = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result2 !== void 0) {
      return result2;
    }
    if (!isObject3(value)) {
      return value;
    }
    var isArr = isArray2(value);
    if (isArr) {
      result2 = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result2);
      }
    } else {
      var tag2 = getTag(value), isFunc = tag2 == funcTag || tag2 == genTag;
      if (isBuffer2(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag2 == objectTag || tag2 == argsTag || isFunc && !object) {
        if (isHostObject(value)) {
          return object ? value : {};
        }
        result2 = initCloneObject(isFunc ? {} : value);
        if (!isDeep) {
          return copySymbols(value, baseAssign(result2, value));
        }
      } else {
        if (!cloneableTags[tag2]) {
          return object ? value : {};
        }
        result2 = initCloneByTag(value, tag2, baseClone, isDeep);
      }
    }
    stack || (stack = new Stack());
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result2);
    if (!isArr) {
      var props = isFull ? getAllKeys(value) : keys3(value);
    }
    arrayEach(props || value, function(subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value[key2];
      }
      assignValue(result2, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
    });
    return result2;
  }
  function baseCreate(proto2) {
    return isObject3(proto2) ? objectCreate(proto2) : {};
  }
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result2 = keysFunc(object);
    return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
  }
  function baseGetTag(value) {
    return objectToString.call(value);
  }
  function baseIsNative(value) {
    if (!isObject3(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction2(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseKeys(object) {
    if (!isPrototype2(object)) {
      return nativeKeys(object);
    }
    var result2 = [];
    for (var key in Object(object)) {
      if (hasOwnProperty2.call(object, key) && key != "constructor") {
        result2.push(key);
      }
    }
    return result2;
  }
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var result2 = new buffer.constructor(buffer.length);
    buffer.copy(result2);
    return result2;
  }
  function cloneArrayBuffer(arrayBuffer) {
    var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
    return result2;
  }
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }
  function cloneMap(map2, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(mapToArray(map2), true) : mapToArray(map2);
    return arrayReduce(array, addMapEntry, new map2.constructor());
  }
  function cloneRegExp(regexp) {
    var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result2.lastIndex = regexp.lastIndex;
    return result2;
  }
  function cloneSet(set2, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(setToArray(set2), true) : setToArray(set2);
    return arrayReduce(array, addSetEntry, new set2.constructor());
  }
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  function copyArray(source2, array) {
    var index = -1, length = source2.length;
    array || (array = Array(length));
    while (++index < length) {
      array[index] = source2[index];
    }
    return array;
  }
  function copyObject(source2, props, object, customizer) {
    object || (object = {});
    var index = -1, length = props.length;
    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source2[key], key, object, source2) : void 0;
      assignValue(object, key, newValue === void 0 ? source2[key] : newValue);
    }
    return object;
  }
  function copySymbols(source2, object) {
    return copyObject(source2, getSymbols(source2), object);
  }
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys3, getSymbols);
  }
  function getMapData(map2, key) {
    var data2 = map2.__data__;
    return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
  var getTag = baseGetTag;
  if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
    getTag = function(value) {
      var result2 = objectToString.call(value), Ctor = result2 == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result2;
    };
  }
  function initCloneArray(array) {
    var length = array.length, result2 = array.constructor(length);
    if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
      result2.index = array.index;
      result2.input = array.input;
    }
    return result2;
  }
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype2(object) ? baseCreate(getPrototype(object)) : {};
  }
  function initCloneByTag(object, tag2, cloneFunc, isDeep) {
    var Ctor = object.constructor;
    switch (tag2) {
      case arrayBufferTag:
        return cloneArrayBuffer(object);
      case boolTag:
      case dateTag:
        return new Ctor(+object);
      case dataViewTag:
        return cloneDataView(object, isDeep);
      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object, isDeep);
      case mapTag:
        return cloneMap(object, isDeep, cloneFunc);
      case numberTag:
      case stringTag:
        return new Ctor(object);
      case regexpTag:
        return cloneRegExp(object);
      case setTag:
        return cloneSet(object, isDeep, cloneFunc);
      case symbolTag:
        return cloneSymbol(object);
    }
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function isPrototype2(value) {
    var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto2;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  function clone2(value) {
    return baseClone(value, false, true);
  }
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArguments5(value) {
    return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray2 = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  var isBuffer2 = nativeIsBuffer || stubFalse;
  function isFunction2(value) {
    var tag2 = isObject3(value) ? objectToString.call(value) : "";
    return tag2 == funcTag || tag2 == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject3(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function keys3(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  function stubArray() {
    return [];
  }
  function stubFalse() {
    return false;
  }
  module.exports = clone2;
})(lodash_clone, lodash_clone.exports);
var lodash_cloneExports = lodash_clone.exports;
const __clone = /* @__PURE__ */ getDefaultExportFromCjs(lodash_cloneExports);
var lodash_clonedeep = { exports: {} };
lodash_clonedeep.exports;
(function(module, exports) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reFlags = /\w*$/;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  function addMapEntry(map2, pair) {
    map2.set(pair[0], pair[1]);
    return map2;
  }
  function addSetEntry(set2, value) {
    set2.add(value);
    return set2;
  }
  function arrayEach(array, iteratee) {
    var index = -1, length = array ? array.length : 0;
    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset2 = array.length;
    while (++index < length) {
      array[offset2 + index] = values[index];
    }
    return array;
  }
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array ? array.length : 0;
    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }
  function baseTimes(n, iteratee) {
    var index = -1, result2 = Array(n);
    while (++index < n) {
      result2[index] = iteratee(index);
    }
    return result2;
  }
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  function isHostObject(value) {
    var result2 = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result2 = !!(value + "");
      } catch (e) {
      }
    }
    return result2;
  }
  function mapToArray(map2) {
    var index = -1, result2 = Array(map2.size);
    map2.forEach(function(value, key) {
      result2[++index] = [key, value];
    });
    return result2;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  function setToArray(set2) {
    var index = -1, result2 = Array(set2.size);
    set2.forEach(function(value) {
      result2[++index] = value;
    });
    return result2;
  }
  var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString = funcProto.toString;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var Buffer2 = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
  var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
  var DataView2 = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
  var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet(key) {
    var data2 = this.__data__;
    if (nativeCreate) {
      var result2 = data2[key];
      return result2 === HASH_UNDEFINED ? void 0 : result2;
    }
    return hasOwnProperty2.call(data2, key) ? data2[key] : void 0;
  }
  function hashHas(key) {
    var data2 = this.__data__;
    return nativeCreate ? data2[key] !== void 0 : hasOwnProperty2.call(data2, key);
  }
  function hashSet(key, value) {
    var data2 = this.__data__;
    data2[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key) {
    var data2 = this.__data__, index = assocIndexOf(data2, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data2.length - 1;
    if (index == lastIndex) {
      data2.pop();
    } else {
      splice.call(data2, index, 1);
    }
    return true;
  }
  function listCacheGet(key) {
    var data2 = this.__data__, index = assocIndexOf(data2, key);
    return index < 0 ? void 0 : data2[index][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data2 = this.__data__, index = assocIndexOf(data2, key);
    if (index < 0) {
      data2.push([key, value]);
    } else {
      data2[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash()
    };
  }
  function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function Stack(entries) {
    this.__data__ = new ListCache(entries);
  }
  function stackClear() {
    this.__data__ = new ListCache();
  }
  function stackDelete(key) {
    return this.__data__["delete"](key);
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var cache2 = this.__data__;
    if (cache2 instanceof ListCache) {
      var pairs = cache2.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        return this;
      }
      cache2 = this.__data__ = new MapCache(pairs);
    }
    cache2.set(key, value);
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var result2 = isArray2(value) || isArguments5(value) ? baseTimes(value.length, String) : [];
    var length = result2.length, skipIndexes = !!length;
    for (var key in value) {
      if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
        result2.push(key);
      }
    }
    return result2;
  }
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
      object[key] = value;
    }
  }
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseAssign(object, source2) {
    return object && copyObject(source2, keys3(source2), object);
  }
  function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
    var result2;
    if (customizer) {
      result2 = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result2 !== void 0) {
      return result2;
    }
    if (!isObject3(value)) {
      return value;
    }
    var isArr = isArray2(value);
    if (isArr) {
      result2 = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result2);
      }
    } else {
      var tag2 = getTag(value), isFunc = tag2 == funcTag || tag2 == genTag;
      if (isBuffer2(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag2 == objectTag || tag2 == argsTag || isFunc && !object) {
        if (isHostObject(value)) {
          return object ? value : {};
        }
        result2 = initCloneObject(isFunc ? {} : value);
        if (!isDeep) {
          return copySymbols(value, baseAssign(result2, value));
        }
      } else {
        if (!cloneableTags[tag2]) {
          return object ? value : {};
        }
        result2 = initCloneByTag(value, tag2, baseClone, isDeep);
      }
    }
    stack || (stack = new Stack());
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result2);
    if (!isArr) {
      var props = isFull ? getAllKeys(value) : keys3(value);
    }
    arrayEach(props || value, function(subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value[key2];
      }
      assignValue(result2, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
    });
    return result2;
  }
  function baseCreate(proto2) {
    return isObject3(proto2) ? objectCreate(proto2) : {};
  }
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result2 = keysFunc(object);
    return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
  }
  function baseGetTag(value) {
    return objectToString.call(value);
  }
  function baseIsNative(value) {
    if (!isObject3(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction2(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseKeys(object) {
    if (!isPrototype2(object)) {
      return nativeKeys(object);
    }
    var result2 = [];
    for (var key in Object(object)) {
      if (hasOwnProperty2.call(object, key) && key != "constructor") {
        result2.push(key);
      }
    }
    return result2;
  }
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var result2 = new buffer.constructor(buffer.length);
    buffer.copy(result2);
    return result2;
  }
  function cloneArrayBuffer(arrayBuffer) {
    var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
    return result2;
  }
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }
  function cloneMap(map2, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(mapToArray(map2), true) : mapToArray(map2);
    return arrayReduce(array, addMapEntry, new map2.constructor());
  }
  function cloneRegExp(regexp) {
    var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result2.lastIndex = regexp.lastIndex;
    return result2;
  }
  function cloneSet(set2, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(setToArray(set2), true) : setToArray(set2);
    return arrayReduce(array, addSetEntry, new set2.constructor());
  }
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  function copyArray(source2, array) {
    var index = -1, length = source2.length;
    array || (array = Array(length));
    while (++index < length) {
      array[index] = source2[index];
    }
    return array;
  }
  function copyObject(source2, props, object, customizer) {
    object || (object = {});
    var index = -1, length = props.length;
    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source2[key], key, object, source2) : void 0;
      assignValue(object, key, newValue === void 0 ? source2[key] : newValue);
    }
    return object;
  }
  function copySymbols(source2, object) {
    return copyObject(source2, getSymbols(source2), object);
  }
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys3, getSymbols);
  }
  function getMapData(map2, key) {
    var data2 = map2.__data__;
    return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
  var getTag = baseGetTag;
  if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
    getTag = function(value) {
      var result2 = objectToString.call(value), Ctor = result2 == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result2;
    };
  }
  function initCloneArray(array) {
    var length = array.length, result2 = array.constructor(length);
    if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
      result2.index = array.index;
      result2.input = array.input;
    }
    return result2;
  }
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype2(object) ? baseCreate(getPrototype(object)) : {};
  }
  function initCloneByTag(object, tag2, cloneFunc, isDeep) {
    var Ctor = object.constructor;
    switch (tag2) {
      case arrayBufferTag:
        return cloneArrayBuffer(object);
      case boolTag:
      case dateTag:
        return new Ctor(+object);
      case dataViewTag:
        return cloneDataView(object, isDeep);
      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object, isDeep);
      case mapTag:
        return cloneMap(object, isDeep, cloneFunc);
      case numberTag:
      case stringTag:
        return new Ctor(object);
      case regexpTag:
        return cloneRegExp(object);
      case setTag:
        return cloneSet(object, isDeep, cloneFunc);
      case symbolTag:
        return cloneSymbol(object);
    }
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function isPrototype2(value) {
    var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto2;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  function cloneDeep(value) {
    return baseClone(value, true, true);
  }
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArguments5(value) {
    return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray2 = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  var isBuffer2 = nativeIsBuffer || stubFalse;
  function isFunction2(value) {
    var tag2 = isObject3(value) ? objectToString.call(value) : "";
    return tag2 == funcTag || tag2 == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject3(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function keys3(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  function stubArray() {
    return [];
  }
  function stubFalse() {
    return false;
  }
  module.exports = cloneDeep;
})(lodash_clonedeep, lodash_clonedeep.exports);
var lodash_clonedeepExports = lodash_clonedeep.exports;
const __deepClone = /* @__PURE__ */ getDefaultExportFromCjs(lodash_clonedeepExports);
function clone(object, settings = {}) {
  settings = Object.assign({ deep: false }, settings);
  if (settings.deep) {
    return __deepClone(object);
  }
  return __clone(object);
}
var decycle_1;
const isArray$5 = (e) => Array.isArray(e), isObject$4 = (e) => "Object" === Object.prototype.toString.call(e).slice(8, -1), validate = (e) => {
  if (void 0 === e)
    throw new Error("This method requires one parameter");
  if (!isArray$5(e) && !isObject$4(e))
    throw new TypeError("This method only accepts arrays and objects");
}, findRef = (e, r) => Object.keys(r).find((a) => r[a] === e), decycle = (e) => {
  validate(e);
  let r = {};
  const a = (e2, c = "$") => {
    const s = findRef(e2, r);
    return s ? { $ref: s } : isArray$5(e2) || isObject$4(e2) ? (r[c] = e2, isArray$5(e2) ? e2.map((e3, r2) => a(e3, `${c}[${r2}]`)) : Object.keys(e2).reduce((r2, s2) => (r2[s2] = a(e2[s2], `${c}.${s2}`), r2), {})) : e2;
  };
  return a(e);
};
decycle_1 = decycle;
function __unique(array) {
  const a = array.concat();
  for (let i = 0; i < a.length; ++i) {
    for (let j = i + 1; j < a.length; ++j) {
      if (a[i] === a[j])
        a.splice(j--, 1);
    }
  }
  return a;
}
function __deepAssign(referenceObj, ...objects) {
  const settings = {
    array: true,
    object: true,
    cloneChilds: true
  };
  function merge(refObj, mixWithObj) {
    for (const key of Object.keys(mixWithObj)) {
      if (settings.array === true && Array.isArray(refObj[key]) && Array.isArray(mixWithObj[key])) {
        const newArray = __unique([...refObj[key], ...mixWithObj[key]]);
        refObj[key] = newArray;
        continue;
      }
      if (settings.object === true && __isPlainObject(refObj[key]) && __isPlainObject(mixWithObj[key])) {
        refObj[key] = merge(refObj[key], mixWithObj[key]);
        continue;
      }
      if (__isPlainObject(mixWithObj[key]) && settings.cloneChilds) {
        refObj[key] = clone(mixWithObj[key], {
          deep: true
        });
      } else {
        refObj[key] = mixWithObj[key];
      }
    }
    return refObj;
  }
  const potentialSettingsObj = objects[objects.length - 1] || {};
  if (potentialSettingsObj.array && typeof potentialSettingsObj.array === "boolean" || potentialSettingsObj.object && typeof potentialSettingsObj.object === "boolean") {
    if (potentialSettingsObj.array !== void 0)
      settings.array = potentialSettingsObj.array;
    if (potentialSettingsObj.object !== void 0)
      settings.object = potentialSettingsObj.object;
    objects.pop();
  }
  for (let i = 0; i < objects.length; i++) {
    const toMergeObj = objects[i] || {};
    merge(referenceObj, toMergeObj);
  }
  return referenceObj;
}
function __isClassInstance(object) {
  if (!object)
    return false;
  if (typeof object !== "object")
    return false;
  if (object.constructor && object.constructor.name === "Object")
    return false;
  if (Object.prototype.toString.call(object) === "[object Object]")
    return false;
  if (object.constructor === Object)
    return false;
  return true;
}
function __deepMerge(...args) {
  var _a2;
  let settings = {}, hasSettings = false;
  const potentialSettings = (_a2 = args[args.length - 1]) !== null && _a2 !== void 0 ? _a2 : {};
  if (potentialSettings && Object.keys(potentialSettings).length <= 2 && (potentialSettings.array !== void 0 || potentialSettings.clone !== void 0)) {
    hasSettings = true;
    settings = potentialSettings;
  }
  let finalSettings = Object.assign({ array: false, clone: true }, settings);
  function merge(firstObj, secondObj) {
    const newObj = finalSettings.clone ? {} : firstObj;
    if (!secondObj)
      return firstObj;
    const firstProps = Object.getOwnPropertyNames(firstObj);
    firstProps.forEach((key) => {
      const desc = Object.getOwnPropertyDescriptor(firstObj, key);
      if (desc.set || desc.get) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = firstObj[key];
      }
    });
    const secondProps = Object.getOwnPropertyNames(secondObj);
    secondProps.forEach((key) => {
      const secondObjDesc = Object.getOwnPropertyDescriptor(secondObj, key);
      if (secondObjDesc.set || secondObjDesc.get) {
        Object.defineProperty(newObj, key, secondObjDesc);
      } else if (finalSettings.array && Array.isArray(firstObj[key]) && Array.isArray(secondObj[key])) {
        newObj[key] = [...firstObj[key], ...secondObj[key]];
      } else if (__isPlainObject(newObj[key]) && __isPlainObject(secondObj[key])) {
        newObj[key] = merge(newObj[key], secondObj[key]);
      } else {
        newObj[key] = secondObj[key];
      }
    });
    return newObj;
  }
  if (hasSettings) {
    args.pop();
  }
  let currentObj = finalSettings.clone ? {} : args[0];
  for (let i = 0; i < args.length; i++) {
    const toMergeObj = args[i];
    currentObj = merge(currentObj, toMergeObj);
  }
  return currentObj;
}
function __deepMap(objectOrArray, processor, settings, _path = []) {
  settings = __deepMerge({
    classInstances: false,
    array: true,
    clone: false,
    privateProps: true
  }, settings);
  const isArray2 = Array.isArray(objectOrArray);
  let newObject = isArray2 ? [] : settings.clone ? clone(objectOrArray, { deep: true }) : objectOrArray;
  Object.keys(objectOrArray).forEach((prop) => {
    if (!settings.privateProps && prop.match(/^_/))
      return;
    if (__isPlainObject(objectOrArray[prop]) || __isClassInstance(objectOrArray[prop]) && settings.classInstances || Array.isArray(objectOrArray[prop]) && settings.array) {
      const res2 = __deepMap(objectOrArray[prop], processor, Object.assign(Object.assign({}, settings), { clone: false }), [..._path, prop]);
      if (isArray2) {
        newObject.push(res2);
      } else {
        if (prop === "..." && __isPlainObject(res2)) {
          newObject = Object.assign(Object.assign({}, newObject), res2);
        } else {
          newObject[prop] = res2;
        }
      }
      return;
    }
    const res = processor({
      object: objectOrArray,
      prop,
      value: objectOrArray[prop],
      path: [..._path, prop].join(".")
    });
    if (res === -1) {
      delete newObject[prop];
      return;
    }
    if (isArray2) {
      newObject.push(res);
    } else {
      if (prop === "..." && __isPlainObject(res)) {
        newObject = Object.assign(Object.assign({}, newObject), res);
      } else {
        newObject[prop] = res;
      }
    }
  });
  return newObject;
}
function __proxyArray(array) {
  if (array.__$proxied)
    return array;
  const watchStack = {};
  Object.defineProperty(array, "__$proxied", {
    value: true,
    enumerable: false,
    writable: false
  });
  function _proxyMethod(name2, ...args) {
    const handlersStack = [];
    Object.keys(watchStack).forEach((watchId) => {
      const watch = watchStack[watchId];
      if (watch.methods.indexOf(name2) === -1)
        return;
      handlersStack.push({
        handlerFn: watch.handlerFn,
        watchObj: {
          oldValue: [...array],
          action: `${name2}`,
          fullAction: `Array.${name2}`,
          args
        }
      });
    });
    const returnValue = Array.prototype[name2].call(array, ...args);
    handlersStack.forEach((handlerObj) => {
      handlerObj.watchObj = Object.assign(Object.assign({}, handlerObj.watchObj), { value: array, returnedValue: returnValue });
      handlerObj.handlerFn(handlerObj.watchObj);
    });
    return returnValue;
  }
  Object.getOwnPropertyNames(Array.prototype).forEach((methodName) => {
    const unProxyMethods = ["length", "constructor"];
    if (unProxyMethods.indexOf(methodName) !== -1)
      return;
    Object.defineProperty(array, methodName, {
      writable: false,
      configurable: false,
      enumerable: false,
      value: (...args) => {
        return _proxyMethod(methodName, ...args);
      }
    });
  });
  Object.defineProperty(array, "watch", {
    writable: false,
    configurable: false,
    enumerable: false,
    value: (methods, handlerFn) => {
      const watchId = `s-${Date.now()}-${Math.round(Math.random() * 9999999999999)}`;
      watchStack[watchId] = {
        methods,
        handlerFn
      };
      return watchId;
    }
  });
  Object.defineProperty(array, "unwatch", {
    writable: false,
    configurable: false,
    enumerable: false,
    value: (watchId) => {
      delete watchStack[watchId];
    }
  });
  return array;
}
function __isDomElement(element) {
  return typeof HTMLElement === "object" ? element instanceof HTMLElement : element && typeof element === "object" && element !== null && element.nodeType === 1 && typeof element.nodeName === "string";
}
function __deepProxy(object, handlerFn, settings = {}) {
  let isRevoked = false;
  settings = __deepMerge({
    deep: true,
    handleSet: true,
    handleGet: false,
    handleDelete: true,
    domElements: false
  }, settings);
  function makeHandler(path2) {
    return {
      set(target, key, value) {
        if (isRevoked || !settings.handleSet)
          return true;
        if (value === target[key])
          return true;
        if (settings.deep && typeof value === "object" && __isPlainObject(value)) {
          value = proxify(value, [...path2, key]);
        }
        const oldValue = target[key];
        target[key] = value;
        handlerFn({
          object,
          target,
          key,
          path: [...path2, key].join("."),
          action: "set",
          fullAction: `Object.set`,
          oldValue,
          value
        });
        return true;
      },
      get(target, key, receiver) {
        if (Reflect.has(target, key)) {
          if (!settings.handleGet)
            return target[key];
          const value = handlerFn({
            object,
            target,
            key,
            path: [...path2, key].join("."),
            action: "get",
            fullAction: "Object.get"
          });
          if (key === "revoke")
            return receiver.revoke;
          if (value === void 0)
            return target[key];
          return value;
        }
        return void 0;
      },
      deleteProperty(target, key) {
        if (isRevoked || !settings.handleDelete)
          return true;
        if (Reflect.has(target, key)) {
          const oldValue = target[key];
          const deleted = Reflect.deleteProperty(target, key);
          if (deleted) {
            handlerFn({
              object,
              target,
              key,
              path: [...path2, key].join("."),
              action: "delete",
              fullAction: "Object.delete",
              oldValue
            });
          }
          return deleted;
        }
        return false;
      }
    };
  }
  function proxify(obj, path2) {
    if (obj === null)
      return obj;
    if (!settings.domElements && __isDomElement(obj)) {
      return obj;
    }
    if (settings.deep) {
      for (const key of Object.keys(obj)) {
        if (Array.isArray(obj[key])) {
          obj[key] = __proxyArray(obj[key]);
          obj[key].watch(Object.getOwnPropertyNames(Array.prototype), (watchObj) => {
            handlerFn(Object.assign({ path: [...path2, key].join(".") }, watchObj));
          });
        } else if (typeof obj[key] === "object" && __isPlainObject(obj[key])) {
          obj[key] = proxify(obj[key], [...path2, key]);
        }
      }
    }
    const p = Proxy.revocable(obj, makeHandler(path2));
    const revokePropertyObj = {
      writable: true,
      configurable: false,
      enumerable: false,
      value: () => {
        let __copy2 = clone(p.proxy, { deep: true });
        isRevoked = true;
        __copy2 = __deepMap(__copy2, ({ value, prop }) => {
          if (prop === "revoke" && typeof value === "function") {
            return -1;
          }
          return value;
        });
        setTimeout(() => {
          __deepMap(p.proxy, ({ value, prop }) => {
            if (prop === "revoke" && typeof value === "function") {
              value();
            }
          }, {});
          p.revoke();
        });
        return __copy2;
      }
    };
    if (Array.isArray(p.proxy)) {
      p.proxy.revoke = revokePropertyObj.value;
    } else {
      Object.defineProperties(p.proxy, {
        revoke: revokePropertyObj
      });
    }
    return p.proxy;
  }
  return proxify(object, []);
}
function __unquote(string, quotesToRemove = ['"', "'", "”", "`"]) {
  string = string.trim();
  quotesToRemove.forEach((quote) => {
    if (string.substr(0, 1) === quote && string.substr(-1) === quote) {
      string = string.substr(1);
      string = string.substr(0, string.length - 1);
      return;
    }
  });
  return string;
}
function get(obj, path2, settings = {}) {
  settings = Object.assign({}, settings);
  if (Array.isArray(path2)) {
    return __get(obj, path2, settings);
  }
  if (obj[path2] !== void 0)
    return obj[path2];
  if (!path2 || path2 === "" || path2 === ".")
    return obj;
  path2 = path2.replace(/\[(\w+)\]/g, ".$1");
  path2 = path2.replace(/\\\./g, "_dot_");
  path2 = path2.replace(/^\./, "");
  let potentialPaths = [path2.replace(/\?/gm, "")];
  const parts = path2.split(".");
  for (let i = parts.length - 1; i >= 0; i--) {
    const part = parts[i];
    if (part.match(/\?$/)) {
      const before = parts.slice(0, i);
      const after = parts.slice(i + 1);
      potentialPaths.push([...before, ...after].join("."));
      potentialPaths.push([...before, ...after.filter((a) => !a.match(/\?$/))].join("."));
    }
  }
  potentialPaths = __unique(potentialPaths.map((s) => s.replace(/\?/gm, "")));
  for (let i = 0; i < potentialPaths.length; i++) {
    const path3 = potentialPaths[i];
    const result2 = __get(obj, path3, settings);
    if (result2 !== void 0)
      return result2;
  }
}
function __get(obj, path2, settings = {}) {
  settings = Object.assign({}, settings);
  let o = obj, a;
  if (typeof path2 === "string") {
    if (obj[path2] !== void 0)
      return obj[path2];
    if (!path2 || path2 === "" || path2 === ".")
      return obj;
    path2 = path2.split(/(?!\B"[^"]*)\.(?![^"]*"\B)/gm);
  }
  a = [...path2].map((p) => {
    if (typeof p === "string")
      return __unquote(p);
    return p;
  });
  while (a.length) {
    let n = a.shift();
    if (typeof n === "string") {
      n = n.replace(/\?$/, "");
    }
    if (typeof o !== "object" || !(o && n in o)) {
      return;
    }
    o = o[n];
  }
  return o;
}
function __set(obj, path2, value, settings) {
  const finalSettings = Object.assign({ preferAssign: false }, settings !== null && settings !== void 0 ? settings : {});
  let o = obj, a;
  if (Array.isArray(path2) && path2.length === 1) {
    path2 = path2[0];
  }
  if (typeof path2 === "string") {
    if (!path2 || path2 === "" || path2 === ".") {
      Object.assign(obj, value);
      return;
    }
    path2 = path2.replace(/\[(\w+)\]/g, ".[$1]");
    a = __unquote(path2).split(/(?!\B"[^"]*)\.(?![^"]*"\B)/gm).map((p) => __unquote(p));
  } else if (Array.isArray(path2)) {
    a = [...path2];
  }
  while (a.length - 1) {
    const n = a.shift();
    if (!(n in o)) {
      if (typeof a[0] === "string") {
        if (a[0].match(/^\[[0-9]+\]$/))
          o[n] = [];
        else
          o[n] = {};
      } else {
        o[n] = {};
      }
    }
    if (!o[n]) {
      o[n] = {};
    }
    o = o[n];
  }
  if (typeof a[0] === "string" && a[0].match(/^\[[0-9]+\]$/)) {
    if (!Array.isArray(o)) {
      o = [];
    }
    o.push(value);
  } else {
    if (__isPlainObject(o[a[0]]) && __isPlainObject(value) && finalSettings.preferAssign) {
      for (const key in o[a[0]]) {
        delete o[a[0]][key];
      }
      Object.assign(o[a[0]], value);
    } else {
      o[a[0]] = value;
    }
  }
  return get(obj, path2);
}
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var slice$1 = Array.prototype.slice;
var toStr$a = Object.prototype.toString;
var funcType = "[object Function]";
var implementation$b = function bind(that) {
  var target = this;
  if (typeof target !== "function" || toStr$a.call(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slice$1.call(arguments, 1);
  var bound2;
  var binder = function() {
    if (this instanceof bound2) {
      var result2 = target.apply(
        this,
        args.concat(slice$1.call(arguments))
      );
      if (Object(result2) === result2) {
        return result2;
      }
      return this;
    } else {
      return target.apply(
        that,
        args.concat(slice$1.call(arguments))
      );
    }
  };
  var boundLength = Math.max(0, target.length - args.length);
  var boundArgs = [];
  for (var i = 0; i < boundLength; i++) {
    boundArgs.push("$" + i);
  }
  bound2 = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target.prototype;
    bound2.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound2;
};
var implementation$a = implementation$b;
var functionBind = Function.prototype.bind || implementation$a;
var bind$1 = functionBind;
var src$1 = bind$1.call(Function.call, Object.prototype.hasOwnProperty);
var toString$4 = {}.toString;
var isarray = Array.isArray || function(arr) {
  return toString$4.call(arr) == "[object Array]";
};
var fnToStr$2 = Function.prototype.toString;
var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
  try {
    badArrayLike = Object.defineProperty({}, "length", {
      get: function() {
        throw isCallableMarker;
      }
    });
    isCallableMarker = {};
    reflectApply(function() {
      throw 42;
    }, null, badArrayLike);
  } catch (_) {
    if (_ !== isCallableMarker) {
      reflectApply = null;
    }
  }
} else {
  reflectApply = null;
}
var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
  try {
    var fnStr = fnToStr$2.call(value);
    return constructorRegex.test(fnStr);
  } catch (e) {
    return false;
  }
};
var tryFunctionObject = function tryFunctionToStr(value) {
  try {
    if (isES6ClassFn(value)) {
      return false;
    }
    fnToStr$2.call(value);
    return true;
  } catch (e) {
    return false;
  }
};
var toStr$9 = Object.prototype.toString;
var objectClass = "[object Object]";
var fnClass = "[object Function]";
var genClass = "[object GeneratorFunction]";
var ddaClass = "[object HTMLAllCollection]";
var ddaClass2 = "[object HTML document.all class]";
var ddaClass3 = "[object HTMLCollection]";
var hasToStringTag$a = typeof Symbol === "function" && !!Symbol.toStringTag;
var isIE68 = !(0 in [,]);
var isDDA = function isDocumentDotAll() {
  return false;
};
if (typeof document === "object") {
  var all = document.all;
  if (toStr$9.call(all) === toStr$9.call(document.all)) {
    isDDA = function isDocumentDotAll2(value) {
      if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
        try {
          var str2 = toStr$9.call(value);
          return (str2 === ddaClass || str2 === ddaClass2 || str2 === ddaClass3 || str2 === objectClass) && value("") == null;
        } catch (e) {
        }
      }
      return false;
    };
  }
}
var isCallable$1 = reflectApply ? function isCallable(value) {
  if (isDDA(value)) {
    return true;
  }
  if (!value) {
    return false;
  }
  if (typeof value !== "function" && typeof value !== "object") {
    return false;
  }
  try {
    reflectApply(value, null, badArrayLike);
  } catch (e) {
    if (e !== isCallableMarker) {
      return false;
    }
  }
  return !isES6ClassFn(value) && tryFunctionObject(value);
} : function isCallable2(value) {
  if (isDDA(value)) {
    return true;
  }
  if (!value) {
    return false;
  }
  if (typeof value !== "function" && typeof value !== "object") {
    return false;
  }
  if (hasToStringTag$a) {
    return tryFunctionObject(value);
  }
  if (isES6ClassFn(value)) {
    return false;
  }
  var strClass2 = toStr$9.call(value);
  if (strClass2 !== fnClass && strClass2 !== genClass && !/^\[object HTML/.test(strClass2)) {
    return false;
  }
  return tryFunctionObject(value);
};
var shams$1 = function hasSymbols() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor2 = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor2.value !== symVal || descriptor2.enumerable !== true) {
      return false;
    }
  }
  return true;
};
var origSymbol = typeof Symbol !== "undefined" && Symbol;
var hasSymbolSham = shams$1;
var hasSymbols$4 = function hasNativeSymbols() {
  if (typeof origSymbol !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return hasSymbolSham();
};
var test$1 = {
  foo: {}
};
var $Object$2 = Object;
var hasProto$4 = function hasProto() {
  return { __proto__: test$1 }.foo === test$1.foo && !({ __proto__: null } instanceof $Object$2);
};
var undefined$1;
var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError$3 = TypeError;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e) {
  }
};
var $gOPD$1 = Object.getOwnPropertyDescriptor;
if ($gOPD$1) {
  try {
    $gOPD$1({}, "");
  } catch (e) {
    $gOPD$1 = null;
  }
}
var throwTypeError = function() {
  throw new $TypeError$3();
};
var ThrowTypeError = $gOPD$1 ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD$1(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols$3 = hasSymbols$4();
var hasProto$3 = hasProto$4();
var getProto$4 = Object.getPrototypeOf || (hasProto$3 ? function(x) {
  return x.__proto__;
} : null);
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" || !getProto$4 ? undefined$1 : getProto$4(Uint8Array);
var INTRINSICS = {
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols$3 && getProto$4 ? getProto$4([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols$3 && getProto$4 ? getProto$4(getProto$4([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols$3 || !getProto$4 ? undefined$1 : getProto$4((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols$3 || !getProto$4 ? undefined$1 : getProto$4((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols$3 && getProto$4 ? getProto$4(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols$3 ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$3,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
};
if (getProto$4) {
  try {
    null.error;
  } catch (e) {
    var errorProto = getProto$4(getProto$4(e));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
}
var doEval = function doEval2(name2) {
  var value;
  if (name2 === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name2 === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name2 === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name2 === "%AsyncGenerator%") {
    var fn2 = doEval2("%AsyncGeneratorFunction%");
    if (fn2) {
      value = fn2.prototype;
    }
  } else if (name2 === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen && getProto$4) {
      value = getProto$4(gen.prototype);
    }
  }
  INTRINSICS[name2] = value;
  return value;
};
var LEGACY_ALIASES = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind2 = functionBind;
var hasOwn$1 = src$1;
var $concat = bind2.call(Function.call, Array.prototype.concat);
var $spliceApply = bind2.call(Function.apply, Array.prototype.splice);
var $replace = bind2.call(Function.call, String.prototype.replace);
var $strSlice = bind2.call(Function.call, String.prototype.slice);
var $exec$1 = bind2.call(Function.call, RegExp.prototype.exec);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string) {
  var first = $strSlice(string, 0, 1);
  var last = $strSlice(string, -1);
  if (first === "%" && last !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
  } else if (last === "%" && first !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
  }
  var result2 = [];
  $replace(string, rePropName, function(match2, number, quote, subString) {
    result2[result2.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match2;
  });
  return result2;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
  var intrinsicName = name2;
  var alias;
  if (hasOwn$1(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn$1(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError$3("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
};
var getIntrinsic = function GetIntrinsic(name2, allowMissing) {
  if (typeof name2 !== "string" || name2.length === 0) {
    throw new $TypeError$3("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError$3('"allowMissing" argument must be a boolean');
  }
  if ($exec$1(/^%?[^%]*%?$/, name2) === null) {
    throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  }
  var parts = stringToPath(name2);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }
  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);
    if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
      throw new $SyntaxError("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn$1(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError$3("base intrinsic for " + name2 + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD$1 && i + 1 >= parts.length) {
        var desc = $gOPD$1(value, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn$1(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
var callBind$4 = { exports: {} };
(function(module) {
  var bind3 = functionBind;
  var GetIntrinsic3 = getIntrinsic;
  var $apply = GetIntrinsic3("%Function.prototype.apply%");
  var $call = GetIntrinsic3("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic3("%Reflect.apply%", true) || bind3.call($call, $apply);
  var $gOPD2 = GetIntrinsic3("%Object.getOwnPropertyDescriptor%", true);
  var $defineProperty2 = GetIntrinsic3("%Object.defineProperty%", true);
  var $max = GetIntrinsic3("%Math.max%");
  if ($defineProperty2) {
    try {
      $defineProperty2({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty2 = null;
    }
  }
  module.exports = function callBind2(originalFunction) {
    var func = $reflectApply(bind3, $call, arguments);
    if ($gOPD2 && $defineProperty2) {
      var desc = $gOPD2(func, "length");
      if (desc.configurable) {
        $defineProperty2(
          func,
          "length",
          { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
        );
      }
    }
    return func;
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind3, $apply, arguments);
  };
  if ($defineProperty2) {
    $defineProperty2(module.exports, "apply", { value: applyBind });
  } else {
    module.exports.apply = applyBind;
  }
})(callBind$4);
var callBindExports = callBind$4.exports;
var GetIntrinsic$a = getIntrinsic;
var callBind$3 = callBindExports;
var $indexOf = callBind$3(GetIntrinsic$a("String.prototype.indexOf"));
var callBound$a = function callBoundIntrinsic(name2, allowMissing) {
  var intrinsic = GetIntrinsic$a(name2, !!allowMissing);
  if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
    return callBind$3(intrinsic);
  }
  return intrinsic;
};
var hasSymbols$2 = shams$1;
var shams = function hasToStringTagShams() {
  return hasSymbols$2() && !!Symbol.toStringTag;
};
var callBound$9 = callBound$a;
var $boolToStr = callBound$9("Boolean.prototype.toString");
var $toString$3 = callBound$9("Object.prototype.toString");
var tryBooleanObject = function booleanBrandCheck(value) {
  try {
    $boolToStr(value);
    return true;
  } catch (e) {
    return false;
  }
};
var boolClass = "[object Boolean]";
var hasToStringTag$9 = shams();
var isBooleanObject = function isBoolean(value) {
  if (typeof value === "boolean") {
    return true;
  }
  if (value === null || typeof value !== "object") {
    return false;
  }
  return hasToStringTag$9 && Symbol.toStringTag in value ? tryBooleanObject(value) : $toString$3(value) === boolClass;
};
var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateGetDayCall(value) {
  try {
    getDay.call(value);
    return true;
  } catch (e) {
    return false;
  }
};
var toStr$8 = Object.prototype.toString;
var dateClass = "[object Date]";
var hasToStringTag$8 = shams();
var isDateObject = function isDateObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  return hasToStringTag$8 ? tryDateObject(value) : toStr$8.call(value) === dateClass;
};
var toStr$7 = Object.prototype.toString;
var fnToStr$1 = Function.prototype.toString;
var isFnRegex$1 = /^\s*(?:function)?\*/;
var hasToStringTag$7 = shams();
var getProto$3 = Object.getPrototypeOf;
var getGeneratorFunc = function() {
  if (!hasToStringTag$7) {
    return false;
  }
  try {
    return Function("return function*() {}")();
  } catch (e) {
  }
};
var GeneratorFunction;
var isGeneratorFunction$1 = function isGeneratorFunction(fn2) {
  if (typeof fn2 !== "function") {
    return false;
  }
  if (isFnRegex$1.test(fnToStr$1.call(fn2))) {
    return true;
  }
  if (!hasToStringTag$7) {
    var str2 = toStr$7.call(fn2);
    return str2 === "[object GeneratorFunction]";
  }
  if (!getProto$3) {
    return false;
  }
  if (typeof GeneratorFunction === "undefined") {
    var generatorFunc = getGeneratorFunc();
    GeneratorFunction = generatorFunc ? getProto$3(generatorFunc) : false;
  }
  return getProto$3(fn2) === GeneratorFunction;
};
var numToStr = Number.prototype.toString;
var tryNumberObject = function tryNumberObject2(value) {
  try {
    numToStr.call(value);
    return true;
  } catch (e) {
    return false;
  }
};
var toStr$6 = Object.prototype.toString;
var numClass = "[object Number]";
var hasToStringTag$6 = shams();
var isNumberObject = function isNumberObject2(value) {
  if (typeof value === "number") {
    return true;
  }
  if (typeof value !== "object") {
    return false;
  }
  return hasToStringTag$6 ? tryNumberObject(value) : toStr$6.call(value) === numClass;
};
var callBound$8 = callBound$a;
var hasToStringTag$5 = shams();
var has$2;
var $exec;
var isRegexMarker;
var badStringifier;
if (hasToStringTag$5) {
  has$2 = callBound$8("Object.prototype.hasOwnProperty");
  $exec = callBound$8("RegExp.prototype.exec");
  isRegexMarker = {};
  var throwRegexMarker = function() {
    throw isRegexMarker;
  };
  badStringifier = {
    toString: throwRegexMarker,
    valueOf: throwRegexMarker
  };
  if (typeof Symbol.toPrimitive === "symbol") {
    badStringifier[Symbol.toPrimitive] = throwRegexMarker;
  }
}
var $toString$2 = callBound$8("Object.prototype.toString");
var gOPD$1 = Object.getOwnPropertyDescriptor;
var regexClass = "[object RegExp]";
var isRegex$1 = hasToStringTag$5 ? function isRegex(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  var descriptor2 = gOPD$1(value, "lastIndex");
  var hasLastIndexDataProperty = descriptor2 && has$2(descriptor2, "value");
  if (!hasLastIndexDataProperty) {
    return false;
  }
  try {
    $exec(value, badStringifier);
  } catch (e) {
    return e === isRegexMarker;
  }
} : function isRegex2(value) {
  if (!value || typeof value !== "object" && typeof value !== "function") {
    return false;
  }
  return $toString$2(value) === regexClass;
};
var strValue = String.prototype.valueOf;
var tryStringObject = function tryStringObject2(value) {
  try {
    strValue.call(value);
    return true;
  } catch (e) {
    return false;
  }
};
var toStr$5 = Object.prototype.toString;
var strClass = "[object String]";
var hasToStringTag$4 = shams();
var isString$3 = function isString(value) {
  if (typeof value === "string") {
    return true;
  }
  if (typeof value !== "object") {
    return false;
  }
  return hasToStringTag$4 ? tryStringObject(value) : toStr$5.call(value) === strClass;
};
var isSymbol$2 = { exports: {} };
var toStr$4 = Object.prototype.toString;
var hasSymbols$1 = hasSymbols$4();
if (hasSymbols$1) {
  var symToStr = Symbol.prototype.toString;
  var symStringRegex = /^Symbol\(.*\)$/;
  var isSymbolObject = function isRealSymbolObject(value) {
    if (typeof value.valueOf() !== "symbol") {
      return false;
    }
    return symStringRegex.test(symToStr.call(value));
  };
  isSymbol$2.exports = function isSymbol2(value) {
    if (typeof value === "symbol") {
      return true;
    }
    if (toStr$4.call(value) !== "[object Symbol]") {
      return false;
    }
    try {
      return isSymbolObject(value);
    } catch (e) {
      return false;
    }
  };
} else {
  isSymbol$2.exports = function isSymbol2(value) {
    return false;
  };
}
var isSymbolExports = isSymbol$2.exports;
var isBigint = { exports: {} };
var $BigInt = typeof BigInt !== "undefined" && BigInt;
var hasBigints = function hasNativeBigInts() {
  return typeof $BigInt === "function" && typeof BigInt === "function" && typeof $BigInt(42) === "bigint" && typeof BigInt(42) === "bigint";
};
var hasBigInts = hasBigints();
if (hasBigInts) {
  var bigIntValueOf = BigInt.prototype.valueOf;
  var tryBigInt = function tryBigIntObject(value) {
    try {
      bigIntValueOf.call(value);
      return true;
    } catch (e) {
    }
    return false;
  };
  isBigint.exports = function isBigInt2(value) {
    if (value === null || typeof value === "undefined" || typeof value === "boolean" || typeof value === "string" || typeof value === "number" || typeof value === "symbol" || typeof value === "function") {
      return false;
    }
    if (typeof value === "bigint") {
      return true;
    }
    return tryBigInt(value);
  };
} else {
  isBigint.exports = function isBigInt2(value) {
    return false;
  };
}
var isBigintExports = isBigint.exports;
var hasToStringTag$3 = shams();
var callBound$7 = callBound$a;
var $toString$1 = callBound$7("Object.prototype.toString");
var isStandardArguments = function isArguments(value) {
  if (hasToStringTag$3 && value && typeof value === "object" && Symbol.toStringTag in value) {
    return false;
  }
  return $toString$1(value) === "[object Arguments]";
};
var isLegacyArguments = function isArguments2(value) {
  if (isStandardArguments(value)) {
    return true;
  }
  return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString$1(value) !== "[object Array]" && $toString$1(value.callee) === "[object Function]";
};
(function() {
  return isStandardArguments(arguments);
})();
isStandardArguments.isLegacyArguments = isLegacyArguments;
const __viteBrowserExternal = new Proxy({}, {
  get(_, key) {
    throw new Error(`Module "" has been externalized for browser compatibility. Cannot access ".${key}" in client code.  See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
  }
});
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$5 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var GetIntrinsic$9 = getIntrinsic;
var callBound$6 = callBound$a;
GetIntrinsic$9("%TypeError%");
GetIntrinsic$9("%WeakMap%", true);
GetIntrinsic$9("%Map%", true);
callBound$6("WeakMap.prototype.get", true);
callBound$6("WeakMap.prototype.set", true);
callBound$6("WeakMap.prototype.has", true);
callBound$6("Map.prototype.get", true);
callBound$6("Map.prototype.set", true);
callBound$6("Map.prototype.has", true);
var GetIntrinsic$8 = getIntrinsic;
GetIntrinsic$8("%TypeError%");
typeof StopIteration === "object" ? StopIteration : null;
var $Map$2 = typeof Map === "function" && Map.prototype ? Map : null;
var $Set$2 = typeof Set === "function" && Set.prototype ? Set : null;
var exported$2;
if (!$Map$2) {
  exported$2 = function isMap3(x) {
    return false;
  };
}
var $mapHas$3 = $Map$2 ? Map.prototype.has : null;
var $setHas$3 = $Set$2 ? Set.prototype.has : null;
if (!exported$2 && !$mapHas$3) {
  exported$2 = function isMap3(x) {
    return false;
  };
}
var isMap$1 = exported$2 || function isMap(x) {
  if (!x || typeof x !== "object") {
    return false;
  }
  try {
    $mapHas$3.call(x);
    if ($setHas$3) {
      try {
        $setHas$3.call(x);
      } catch (e) {
        return true;
      }
    }
    return x instanceof $Map$2;
  } catch (e) {
  }
  return false;
};
var $Map$1 = typeof Map === "function" && Map.prototype ? Map : null;
var $Set$1 = typeof Set === "function" && Set.prototype ? Set : null;
var exported$1;
if (!$Set$1) {
  exported$1 = function isSet3(x) {
    return false;
  };
}
var $mapHas$2 = $Map$1 ? Map.prototype.has : null;
var $setHas$2 = $Set$1 ? Set.prototype.has : null;
if (!exported$1 && !$setHas$2) {
  exported$1 = function isSet3(x) {
    return false;
  };
}
var isSet$1 = exported$1 || function isSet(x) {
  if (!x || typeof x !== "object") {
    return false;
  }
  try {
    $setHas$2.call(x);
    if ($mapHas$2) {
      try {
        $mapHas$2.call(x);
      } catch (e) {
        return true;
      }
    }
    return x instanceof $Set$1;
  } catch (e) {
  }
  return false;
};
if (hasSymbols$4() || shams$1())
  ;
else {
  var GetIntrinsic$7 = getIntrinsic;
  var $Map = GetIntrinsic$7("%Map%", true);
  var $Set = GetIntrinsic$7("%Set%", true);
  var callBound$5 = callBound$a;
  callBound$5("Array.prototype.push");
  callBound$5("String.prototype.charCodeAt");
  callBound$5("String.prototype.slice");
  if (!$Map && !$Set)
    ;
  else {
    callBound$5("Map.prototype.forEach", true);
    callBound$5("Set.prototype.forEach", true);
    if (typeof process === "undefined" || !process.versions || !process.versions.node) {
      callBound$5("Map.prototype.iterator", true);
      callBound$5("Set.prototype.iterator", true);
    }
    callBound$5("Map.prototype.@@iterator", true) || callBound$5("Map.prototype._es6-shim iterator_", true);
    callBound$5("Set.prototype.@@iterator", true) || callBound$5("Set.prototype._es6-shim iterator_", true);
  }
}
var $WeakMap = typeof WeakMap === "function" && WeakMap.prototype ? WeakMap : null;
var $WeakSet$1 = typeof WeakSet === "function" && WeakSet.prototype ? WeakSet : null;
var exported;
if (!$WeakMap) {
  exported = function isWeakMap3(x) {
    return false;
  };
}
var $mapHas$1 = $WeakMap ? $WeakMap.prototype.has : null;
var $setHas$1 = $WeakSet$1 ? $WeakSet$1.prototype.has : null;
if (!exported && !$mapHas$1) {
  exported = function isWeakMap3(x) {
    return false;
  };
}
var isWeakmap = exported || function isWeakMap(x) {
  if (!x || typeof x !== "object") {
    return false;
  }
  try {
    $mapHas$1.call(x, $mapHas$1);
    if ($setHas$1) {
      try {
        $setHas$1.call(x, $setHas$1);
      } catch (e) {
        return true;
      }
    }
    return x instanceof $WeakMap;
  } catch (e) {
  }
  return false;
};
var isWeakset = { exports: {} };
var GetIntrinsic$6 = getIntrinsic;
var callBound$4 = callBound$a;
var $WeakSet = GetIntrinsic$6("%WeakSet%", true);
var $setHas = callBound$4("WeakSet.prototype.has", true);
if ($setHas) {
  var $mapHas = callBound$4("WeakMap.prototype.has", true);
  isWeakset.exports = function isWeakSet2(x) {
    if (!x || typeof x !== "object") {
      return false;
    }
    try {
      $setHas(x, $setHas);
      if ($mapHas) {
        try {
          $mapHas(x, $mapHas);
        } catch (e) {
          return true;
        }
      }
      return x instanceof $WeakSet;
    } catch (e) {
    }
    return false;
  };
} else {
  isWeakset.exports = function isWeakSet2(x) {
    return false;
  };
}
var isWeaksetExports = isWeakset.exports;
var isMap2 = isMap$1;
var isSet2 = isSet$1;
var isWeakMap2 = isWeakmap;
var isWeakSet = isWeaksetExports;
var whichCollection$1 = function whichCollection(value) {
  if (value && typeof value === "object") {
    if (isMap2(value)) {
      return "Map";
    }
    if (isSet2(value)) {
      return "Set";
    }
    if (isWeakMap2(value)) {
      return "WeakMap";
    }
    if (isWeakSet(value)) {
      return "WeakSet";
    }
  }
  return false;
};
var isString$2 = isString$3;
var isNumber = isNumberObject;
var isBoolean2 = isBooleanObject;
var isSymbol$1 = isSymbolExports;
var isBigInt = isBigintExports;
var whichBoxedPrimitive$1 = function whichBoxedPrimitive(value) {
  if (value == null || typeof value !== "object" && typeof value !== "function") {
    return null;
  }
  if (isString$2(value)) {
    return "String";
  }
  if (isNumber(value)) {
    return "Number";
  }
  if (isBoolean2(value)) {
    return "Boolean";
  }
  if (isSymbol$1(value)) {
    return "Symbol";
  }
  if (isBigInt(value)) {
    return "BigInt";
  }
};
var GetIntrinsic$5 = getIntrinsic;
var $TypeError$2 = GetIntrinsic$5("%TypeError%");
var CheckObjectCoercible = function CheckObjectCoercible2(value, optMessage) {
  if (value == null) {
    throw new $TypeError$2(optMessage || "Cannot call method on " + value);
  }
  return value;
};
var RequireObjectCoercible$2 = CheckObjectCoercible;
var GetIntrinsic$4 = getIntrinsic;
var $Object$1 = GetIntrinsic$4("%Object%");
var RequireObjectCoercible$1 = RequireObjectCoercible$2;
var ToObject$1 = function ToObject(value) {
  RequireObjectCoercible$1(value);
  return $Object$1(value);
};
var toStr$3 = Object.prototype.toString;
var isArguments$2 = function isArguments3(value) {
  var str2 = toStr$3.call(value);
  var isArgs2 = str2 === "[object Arguments]";
  if (!isArgs2) {
    isArgs2 = str2 !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr$3.call(value.callee) === "[object Function]";
  }
  return isArgs2;
};
var implementation$9;
var hasRequiredImplementation$1;
function requireImplementation$1() {
  if (hasRequiredImplementation$1)
    return implementation$9;
  hasRequiredImplementation$1 = 1;
  var keysShim2;
  if (!Object.keys) {
    var has2 = Object.prototype.hasOwnProperty;
    var toStr2 = Object.prototype.toString;
    var isArgs2 = isArguments$2;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
    var hasProtoEnumBug = isEnumerable.call(function() {
    }, "prototype");
    var dontEnums = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ];
    var equalsConstructorPrototype = function(o) {
      var ctor = o.constructor;
      return ctor && ctor.prototype === o;
    };
    var excludedKeys = {
      $applicationCache: true,
      $console: true,
      $external: true,
      $frame: true,
      $frameElement: true,
      $frames: true,
      $innerHeight: true,
      $innerWidth: true,
      $onmozfullscreenchange: true,
      $onmozfullscreenerror: true,
      $outerHeight: true,
      $outerWidth: true,
      $pageXOffset: true,
      $pageYOffset: true,
      $parent: true,
      $scrollLeft: true,
      $scrollTop: true,
      $scrollX: true,
      $scrollY: true,
      $self: true,
      $webkitIndexedDB: true,
      $webkitStorageInfo: true,
      $window: true
    };
    var hasAutomationEqualityBug = function() {
      if (typeof window === "undefined") {
        return false;
      }
      for (var k in window) {
        try {
          if (!excludedKeys["$" + k] && has2.call(window, k) && window[k] !== null && typeof window[k] === "object") {
            try {
              equalsConstructorPrototype(window[k]);
            } catch (e) {
              return true;
            }
          }
        } catch (e) {
          return true;
        }
      }
      return false;
    }();
    var equalsConstructorPrototypeIfNotBuggy = function(o) {
      if (typeof window === "undefined" || !hasAutomationEqualityBug) {
        return equalsConstructorPrototype(o);
      }
      try {
        return equalsConstructorPrototype(o);
      } catch (e) {
        return false;
      }
    };
    keysShim2 = function keys3(object) {
      var isObject3 = object !== null && typeof object === "object";
      var isFunction2 = toStr2.call(object) === "[object Function]";
      var isArguments5 = isArgs2(object);
      var isString3 = isObject3 && toStr2.call(object) === "[object String]";
      var theKeys = [];
      if (!isObject3 && !isFunction2 && !isArguments5) {
        throw new TypeError("Object.keys called on a non-object");
      }
      var skipProto = hasProtoEnumBug && isFunction2;
      if (isString3 && object.length > 0 && !has2.call(object, 0)) {
        for (var i = 0; i < object.length; ++i) {
          theKeys.push(String(i));
        }
      }
      if (isArguments5 && object.length > 0) {
        for (var j = 0; j < object.length; ++j) {
          theKeys.push(String(j));
        }
      } else {
        for (var name2 in object) {
          if (!(skipProto && name2 === "prototype") && has2.call(object, name2)) {
            theKeys.push(String(name2));
          }
        }
      }
      if (hasDontEnumBug) {
        var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
        for (var k = 0; k < dontEnums.length; ++k) {
          if (!(skipConstructor && dontEnums[k] === "constructor") && has2.call(object, dontEnums[k])) {
            theKeys.push(dontEnums[k]);
          }
        }
      }
      return theKeys;
    };
  }
  implementation$9 = keysShim2;
  return implementation$9;
}
var slice = Array.prototype.slice;
var isArgs = isArguments$2;
var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) {
  return origKeys(o);
} : requireImplementation$1();
var originalKeys = Object.keys;
keysShim.shim = function shimObjectKeys() {
  if (Object.keys) {
    var keysWorksWithArguments = function() {
      var args = Object.keys(arguments);
      return args && args.length === arguments.length;
    }(1, 2);
    if (!keysWorksWithArguments) {
      Object.keys = function keys3(object) {
        if (isArgs(object)) {
          return originalKeys(slice.call(object));
        }
        return originalKeys(object);
      };
    }
  } else {
    Object.keys = keysShim;
  }
  return Object.keys || keysShim;
};
var objectKeys = keysShim;
var GetIntrinsic$3 = getIntrinsic;
var $defineProperty = GetIntrinsic$3("%Object.defineProperty%", true);
var hasPropertyDescriptors$1 = function hasPropertyDescriptors() {
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
      return true;
    } catch (e) {
      return false;
    }
  }
  return false;
};
hasPropertyDescriptors$1.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
  if (!hasPropertyDescriptors$1()) {
    return null;
  }
  try {
    return $defineProperty([], "length", { value: 1 }).length !== 1;
  } catch (e) {
    return true;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors$1;
var keys$1 = objectKeys;
var hasSymbols2 = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
var toStr$2 = Object.prototype.toString;
var concat$1 = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;
var isFunction$2 = function(fn2) {
  return typeof fn2 === "function" && toStr$2.call(fn2) === "[object Function]";
};
var hasPropertyDescriptors2 = hasPropertyDescriptors_1();
var supportsDescriptors$1 = origDefineProperty && hasPropertyDescriptors2;
var defineProperty$2 = function(object, name2, value, predicate) {
  if (name2 in object) {
    if (predicate === true) {
      if (object[name2] === value) {
        return;
      }
    } else if (!isFunction$2(predicate) || !predicate()) {
      return;
    }
  }
  if (supportsDescriptors$1) {
    origDefineProperty(object, name2, {
      configurable: true,
      enumerable: false,
      value,
      writable: true
    });
  } else {
    object[name2] = value;
  }
};
var defineProperties = function(object, map2) {
  var predicates = arguments.length > 2 ? arguments[2] : {};
  var props = keys$1(map2);
  if (hasSymbols2) {
    props = concat$1.call(props, Object.getOwnPropertySymbols(map2));
  }
  for (var i = 0; i < props.length; i += 1) {
    defineProperty$2(object, props[i], map2[props[i]], predicates[props[i]]);
  }
};
defineProperties.supportsDescriptors = !!supportsDescriptors$1;
var defineProperties_1 = defineProperties;
var IsCallable$3 = isCallable$1;
var Type$3 = function Type(x) {
  if (x === null) {
    return "Null";
  }
  if (typeof x === "undefined") {
    return "Undefined";
  }
  if (typeof x === "function" || typeof x === "object") {
    return "Object";
  }
  if (typeof x === "number") {
    return "Number";
  }
  if (typeof x === "boolean") {
    return "Boolean";
  }
  if (typeof x === "string") {
    return "String";
  }
};
var ES5Type = Type$3;
var Type$2 = function Type2(x) {
  if (typeof x === "symbol") {
    return "Symbol";
  }
  if (typeof x === "bigint") {
    return "BigInt";
  }
  return ES5Type(x);
};
var isCallable3 = isCallable$1;
var toStr$1 = Object.prototype.toString;
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var forEachArray = function forEachArray2(array, iterator, receiver) {
  for (var i = 0, len = array.length; i < len; i++) {
    if (hasOwnProperty$1.call(array, i)) {
      if (receiver == null) {
        iterator(array[i], i, array);
      } else {
        iterator.call(receiver, array[i], i, array);
      }
    }
  }
};
var forEachString = function forEachString2(string, iterator, receiver) {
  for (var i = 0, len = string.length; i < len; i++) {
    if (receiver == null) {
      iterator(string.charAt(i), i, string);
    } else {
      iterator.call(receiver, string.charAt(i), i, string);
    }
  }
};
var forEachObject = function forEachObject2(object, iterator, receiver) {
  for (var k in object) {
    if (hasOwnProperty$1.call(object, k)) {
      if (receiver == null) {
        iterator(object[k], k, object);
      } else {
        iterator.call(receiver, object[k], k, object);
      }
    }
  }
};
var forEach$2 = function forEach(list2, iterator, thisArg) {
  if (!isCallable3(iterator)) {
    throw new TypeError("iterator must be a function");
  }
  var receiver;
  if (arguments.length >= 3) {
    receiver = thisArg;
  }
  if (toStr$1.call(list2) === "[object Array]") {
    forEachArray(list2, iterator, receiver);
  } else if (typeof list2 === "string") {
    forEachString(list2, iterator, receiver);
  } else {
    forEachObject(list2, iterator, receiver);
  }
};
var forEach_1 = forEach$2;
var possibleNames = [
  "BigInt64Array",
  "BigUint64Array",
  "Float32Array",
  "Float64Array",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "Uint16Array",
  "Uint32Array",
  "Uint8Array",
  "Uint8ClampedArray"
];
var g$1 = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
var availableTypedArrays$1 = function availableTypedArrays() {
  var out = [];
  for (var i = 0; i < possibleNames.length; i++) {
    if (typeof g$1[possibleNames[i]] === "function") {
      out[out.length] = possibleNames[i];
    }
  }
  return out;
};
var GetIntrinsic$2 = getIntrinsic;
var $gOPD = GetIntrinsic$2("%Object.getOwnPropertyDescriptor%", true);
if ($gOPD) {
  try {
    $gOPD([], "length");
  } catch (e) {
    $gOPD = null;
  }
}
var gopd = $gOPD;
var isTypedArray$1;
var hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray)
    return isTypedArray$1;
  hasRequiredIsTypedArray = 1;
  var forEach3 = forEach_1;
  var availableTypedArrays3 = availableTypedArrays$1;
  var callBound2 = callBound$a;
  var $toString2 = callBound2("Object.prototype.toString");
  var hasToStringTag2 = shams();
  var gOPD2 = gopd;
  var g2 = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
  var typedArrays2 = availableTypedArrays3();
  var $indexOf2 = callBound2("Array.prototype.indexOf", true) || function indexOf(array, value) {
    for (var i = 0; i < array.length; i += 1) {
      if (array[i] === value) {
        return i;
      }
    }
    return -1;
  };
  var $slice2 = callBound2("String.prototype.slice");
  var toStrTags2 = {};
  var getPrototypeOf7 = Object.getPrototypeOf;
  if (hasToStringTag2 && gOPD2 && getPrototypeOf7) {
    forEach3(typedArrays2, function(typedArray) {
      var arr = new g2[typedArray]();
      if (Symbol.toStringTag in arr) {
        var proto2 = getPrototypeOf7(arr);
        var descriptor2 = gOPD2(proto2, Symbol.toStringTag);
        if (!descriptor2) {
          var superProto = getPrototypeOf7(proto2);
          descriptor2 = gOPD2(superProto, Symbol.toStringTag);
        }
        toStrTags2[typedArray] = descriptor2.get;
      }
    });
  }
  var tryTypedArrays2 = function tryAllTypedArrays2(value) {
    var anyTrue = false;
    forEach3(toStrTags2, function(getter, typedArray) {
      if (!anyTrue) {
        try {
          anyTrue = getter.call(value) === typedArray;
        } catch (e) {
        }
      }
    });
    return anyTrue;
  };
  isTypedArray$1 = function isTypedArray2(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    if (!hasToStringTag2 || !(Symbol.toStringTag in value)) {
      var tag2 = $slice2($toString2(value), 8, -1);
      return $indexOf2(typedArrays2, tag2) > -1;
    }
    if (!gOPD2) {
      return false;
    }
    return tryTypedArrays2(value);
  };
  return isTypedArray$1;
}
var forEach$1 = forEach_1;
var availableTypedArrays2 = availableTypedArrays$1;
var callBind$2 = callBindExports;
var callBound$3 = callBound$a;
var gOPD = gopd;
var $toString = callBound$3("Object.prototype.toString");
var hasToStringTag$2 = shams();
var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
var typedArrays = availableTypedArrays2();
var $slice = callBound$3("String.prototype.slice");
var toStrTags = { __proto__: null };
var getPrototypeOf = Object.getPrototypeOf;
if (hasToStringTag$2 && gOPD && getPrototypeOf) {
  forEach$1(typedArrays, function(typedArray) {
    if (typeof g[typedArray] === "function") {
      var arr = new g[typedArray]();
      if (Symbol.toStringTag in arr) {
        var proto2 = getPrototypeOf(arr);
        var descriptor2 = gOPD(proto2, Symbol.toStringTag);
        if (!descriptor2) {
          var superProto = getPrototypeOf(proto2);
          descriptor2 = gOPD(superProto, Symbol.toStringTag);
        }
        toStrTags[typedArray] = callBind$2(descriptor2.get);
      }
    }
  });
}
var tryTypedArrays = function tryAllTypedArrays(value) {
  var foundName = false;
  forEach$1(toStrTags, function(getter, typedArray) {
    if (!foundName) {
      try {
        var name2 = getter(value);
        if (name2 === typedArray) {
          foundName = name2;
        }
      } catch (e) {
      }
    }
  });
  return foundName;
};
var isTypedArray = requireIsTypedArray();
var whichTypedArray$1 = function whichTypedArray(value) {
  if (!isTypedArray(value)) {
    return false;
  }
  if (!hasToStringTag$2 || !(Symbol.toStringTag in value)) {
    return $slice($toString(value), 8, -1);
  }
  return tryTypedArrays(value);
};
var callBound$2 = callBound$a;
var $deref = callBound$2("WeakRef.prototype.deref", true);
var isWeakref = typeof WeakRef === "undefined" ? function isWeakRef(value) {
  return false;
} : function isWeakRef2(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  try {
    $deref(value);
    return true;
  } catch (e) {
    return false;
  }
};
var callBound$1 = callBound$a;
var $register = callBound$1("FinalizationRegistry.prototype.register", true);
var isFinalizationregistry = $register ? function isFinalizationRegistry(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  try {
    $register(value, {});
    return true;
  } catch (e) {
    return false;
  }
} : function isFinalizationRegistry2(value) {
  return false;
};
var IsCallable$2 = isCallable$1;
var functionsHaveNames_1;
var hasRequiredFunctionsHaveNames;
function requireFunctionsHaveNames() {
  if (hasRequiredFunctionsHaveNames)
    return functionsHaveNames_1;
  hasRequiredFunctionsHaveNames = 1;
  var functionsHaveNames2 = function functionsHaveNames3() {
    return typeof (function f() {
    }).name === "string";
  };
  var gOPD2 = Object.getOwnPropertyDescriptor;
  if (gOPD2) {
    try {
      gOPD2([], "length");
    } catch (e) {
      gOPD2 = null;
    }
  }
  functionsHaveNames2.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
    if (!functionsHaveNames2() || !gOPD2) {
      return false;
    }
    var desc = gOPD2(function() {
    }, "name");
    return !!desc && !!desc.configurable;
  };
  var $bind = Function.prototype.bind;
  functionsHaveNames2.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
    return functionsHaveNames2() && typeof $bind === "function" && (function f() {
    }).bind().name !== "";
  };
  functionsHaveNames_1 = functionsHaveNames2;
  return functionsHaveNames_1;
}
var IsCallable$1 = IsCallable$2;
var functionsHaveNames$1 = requireFunctionsHaveNames()();
var callBound = callBound$a;
var $functionToString = callBound("Function.prototype.toString");
var $stringMatch = callBound("String.prototype.match");
var classRegex = /^class /;
var isClass$2 = function isClassConstructor(fn2) {
  if (IsCallable$1(fn2)) {
    return false;
  }
  if (typeof fn2 !== "function") {
    return false;
  }
  try {
    var match2 = $stringMatch($functionToString(fn2), classRegex);
    return !!match2;
  } catch (e) {
  }
  return false;
};
var regex = /\s*function\s+([^(\s]*)\s*/;
var functionProto = Function.prototype;
var implementation$8 = function getName() {
  if (!isClass$2(this) && !IsCallable$1(this)) {
    throw new TypeError("Function.prototype.name sham getter called on non-function");
  }
  if (functionsHaveNames$1) {
    return this.name;
  }
  if (this === functionProto) {
    return "";
  }
  var str2 = $functionToString(this);
  var match2 = $stringMatch(str2, regex);
  var name2 = match2 && match2[1];
  return name2;
};
var implementation$7 = implementation$8;
var polyfill$3 = function getPolyfill() {
  return implementation$7;
};
var supportsDescriptors = defineProperties_1.supportsDescriptors;
var functionsHaveNames = requireFunctionsHaveNames()();
var getPolyfill$3 = polyfill$3;
var defineProperty$1 = Object.defineProperty;
var TypeErr = TypeError;
var shim$8 = function shimName() {
  var polyfill2 = getPolyfill$3();
  if (functionsHaveNames) {
    return polyfill2;
  }
  if (!supportsDescriptors) {
    throw new TypeErr("Shimming Function.prototype.name support requires ES5 property descriptor support.");
  }
  var functionProto2 = Function.prototype;
  defineProperty$1(functionProto2, "name", {
    configurable: true,
    enumerable: false,
    get: function() {
      var name2 = polyfill2.call(this);
      if (this !== functionProto2) {
        defineProperty$1(this, "name", {
          configurable: true,
          enumerable: false,
          value: name2,
          writable: false
        });
      }
      return name2;
    }
  });
  return polyfill2;
};
var define$n = defineProperties_1;
var callBind$1 = callBindExports;
var implementation$6 = implementation$8;
var getPolyfill$2 = polyfill$3;
var shim$7 = shim$8;
var bound$1 = callBind$1(implementation$6);
define$n(bound$1, {
  getPolyfill: getPolyfill$2,
  implementation: implementation$6,
  shim: shim$7
});
var function_prototype_name = bound$1;
var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*async(?:\s+function(?:\s+|\()|\s*\()/;
var hasToStringTag$1 = shams();
var getProto$2 = Object.getPrototypeOf;
var getAsyncFunc = function() {
  if (!hasToStringTag$1) {
    return false;
  }
  try {
    return Function("return async function () {}")();
  } catch (e) {
  }
};
var AsyncFunction;
var isAsyncFunction$1 = function isAsyncFunction(fn2) {
  if (typeof fn2 !== "function") {
    return false;
  }
  if (isFnRegex.test(fnToStr.call(fn2))) {
    return true;
  }
  if (!hasToStringTag$1) {
    var str2 = toStr.call(fn2);
    return str2 === "[object AsyncFunction]";
  }
  if (!getProto$2) {
    return false;
  }
  if (typeof AsyncFunction === "undefined") {
    var asyncFunc = getAsyncFunc();
    AsyncFunction = asyncFunc ? getProto$2(asyncFunc) : false;
  }
  return getProto$2(fn2) === AsyncFunction;
};
var whichBoxedPrimitive2 = whichBoxedPrimitive$1;
var whichCollection2 = whichCollection$1;
var whichTypedArray2 = whichTypedArray$1;
var isArray$4 = isarray;
var isDate$1 = isDateObject;
var isRegex3 = isRegex$1;
var isWeakRef3 = isWeakref;
var isFinalizationRegistry3 = isFinalizationregistry;
var name$1 = function_prototype_name;
var isGeneratorFunction2 = isGeneratorFunction$1;
var isAsyncFunction2 = isAsyncFunction$1;
var hasToStringTag = shams();
var toStringTag = hasToStringTag && Symbol.toStringTag;
var $Object = Object;
var promiseThen = typeof Promise === "function" && Promise.prototype.then;
var isPromise = function isPromise2(value) {
  if (!value || typeof value !== "object" || !promiseThen) {
    return false;
  }
  try {
    promiseThen.call(value, null, function() {
    });
    return true;
  } catch (e) {
  }
  return false;
};
var isKnownBuiltin = function isKnownBuiltin2(builtinName) {
  return builtinName && builtinName !== "BigInt" && builtinName !== "Boolean" && builtinName !== "Null" && builtinName !== "Number" && builtinName !== "String" && builtinName !== "Symbol" && builtinName !== "Undefined" && builtinName !== "Math" && builtinName !== "JSON" && builtinName !== "Reflect" && builtinName !== "Atomics" && builtinName !== "Map" && builtinName !== "Set" && builtinName !== "WeakMap" && builtinName !== "WeakSet" && builtinName !== "BigInt64Array" && builtinName !== "BigUint64Array" && builtinName !== "Float32Array" && builtinName !== "Float64Array" && builtinName !== "Int16Array" && builtinName !== "Int32Array" && builtinName !== "Int8Array" && builtinName !== "Uint16Array" && builtinName !== "Uint32Array" && builtinName !== "Uint8Array" && builtinName !== "Uint8ClampedArray" && builtinName !== "Array" && builtinName !== "Date" && builtinName !== "FinalizationRegistry" && builtinName !== "Promise" && builtinName !== "RegExp" && builtinName !== "WeakRef" && builtinName !== "Function" && builtinName !== "GeneratorFunction" && builtinName !== "AsyncFunction";
};
var whichBuiltinType$1 = function whichBuiltinType(value) {
  if (value == null) {
    return value;
  }
  var which = whichBoxedPrimitive2($Object(value)) || whichCollection2(value) || whichTypedArray2(value);
  if (which) {
    return which;
  }
  if (isArray$4(value)) {
    return "Array";
  }
  if (isDate$1(value)) {
    return "Date";
  }
  if (isRegex3(value)) {
    return "RegExp";
  }
  if (isWeakRef3(value)) {
    return "WeakRef";
  }
  if (isFinalizationRegistry3(value)) {
    return "FinalizationRegistry";
  }
  if (typeof value === "function") {
    if (isGeneratorFunction2(value)) {
      return "GeneratorFunction";
    }
    if (isAsyncFunction2(value)) {
      return "AsyncFunction";
    }
    return "Function";
  }
  if (isPromise(value)) {
    return "Promise";
  }
  if (toStringTag && toStringTag in value) {
    var tag2 = value[toStringTag];
    if (isKnownBuiltin(tag2)) {
      return tag2;
    }
  }
  if (typeof value.constructor === "function") {
    var constructorName = name$1(value.constructor);
    if (isKnownBuiltin(constructorName)) {
      return constructorName;
    }
  }
  return "Object";
};
var GetIntrinsic$1 = getIntrinsic;
var IsCallable = IsCallable$3;
var Type$1 = Type$2;
var whichBuiltinType2 = whichBuiltinType$1;
var $gPO = GetIntrinsic$1("%Object.getPrototypeOf%", true);
var $ObjectPrototype = GetIntrinsic$1("%Object.prototype%");
var $TypeError$1 = GetIntrinsic$1("%TypeError%");
var hasProto$2 = [].__proto__ === Array.prototype;
var implementation$5 = function getPrototypeOf2(O) {
  if (Type$1(O) !== "Object") {
    throw new $TypeError$1("Reflect.getPrototypeOf called on non-object");
  }
  if ($gPO) {
    return $gPO(O);
  }
  if (hasProto$2) {
    var proto2 = O.__proto__;
    if (proto2 || proto2 === null) {
      return proto2;
    }
  }
  var type = whichBuiltinType2(O);
  if (type) {
    var intrinsic = GetIntrinsic$1("%" + type + "%.prototype", true);
    if (intrinsic) {
      return intrinsic;
    }
  }
  if (IsCallable(O.constructor)) {
    return O.constructor.prototype;
  }
  if (O instanceof Object) {
    return $ObjectPrototype;
  }
  return null;
};
var Type3 = Type$2;
var GetIntrinsic2 = getIntrinsic;
var $TypeError = GetIntrinsic2("%TypeError%");
var implementation$4 = implementation$5;
var hasProto$1 = [].__proto__ === Array.prototype;
var getProto$1 = function getPrototypeOf3(value) {
  if (Type3(value) !== "Object") {
    throw new $TypeError("Reflect.getPrototypeOf called on non-object");
  }
  return value.__proto__;
};
var polyfill$2 = function getPolyfill2() {
  if (typeof Reflect === "object" && Reflect && Reflect.getPrototypeOf) {
    return Reflect.getPrototypeOf;
  }
  if (hasProto$1) {
    return getProto$1;
  }
  return implementation$4;
};
var define$m = defineProperties_1;
var getPolyfill$1 = polyfill$2;
var shim$6 = function shimGetPrototypeOf() {
  define$m(
    commonjsGlobal,
    { Reflect: {} },
    { Reflect: function() {
      return typeof Reflect !== "object" || !Reflect;
    } }
  );
  var polyfill2 = getPolyfill$1();
  define$m(
    Reflect,
    { getPrototypeOf: polyfill2 },
    { getPrototypeOf: function() {
      return Reflect.getPrototypeOf !== polyfill2;
    } }
  );
  return polyfill2;
};
var callBind = callBindExports;
var define$l = defineProperties_1;
var implementation$3 = implementation$5;
var getPolyfill3 = polyfill$2;
var shim$5 = shim$6;
var bound = callBind(getPolyfill3(), typeof Reflect === "object" ? Reflect : Object);
define$l(bound, {
  getPolyfill: getPolyfill3,
  implementation: implementation$3,
  shim: shim$5
});
var reflect_getprototypeof = bound;
var ToObject2 = ToObject$1;
var ReflectGetPrototypeOf = reflect_getprototypeof;
var implementation$2 = function getPrototypeOf4(O) {
  return ReflectGetPrototypeOf(ToObject2(O));
};
var RequireObjectCoercible = RequireObjectCoercible$2;
var implementation$1 = implementation$2;
var hasProto2 = [].__proto__ === Array.prototype;
var getProto = function getPrototypeOf5(value) {
  RequireObjectCoercible(value);
  return value.__proto__;
};
var $getPrototypeOf = Object.getPrototypeOf;
var getPrototypeOfPrimitivesToo = function getPrototypeOf6(value) {
  RequireObjectCoercible(value);
  return $getPrototypeOf(Object(value));
};
var polyfill$1 = function getPolyfill4() {
  if ($getPrototypeOf) {
    try {
      $getPrototypeOf(true);
    } catch (e) {
      return getPrototypeOfPrimitivesToo;
    }
    return $getPrototypeOf;
  }
  if (hasProto2) {
    return getProto;
  }
  return implementation$1;
};
polyfill$1();
shams$1();
hasBigints();
requireFunctionsHaveNames()();
function __flatten(object, settings = {}) {
  const toReturn = {};
  if (!Array.isArray(object) && !__isPlainObject(object))
    return object;
  settings = Object.assign({ separator: ".", array: false, quoteSeparatedProperties: true, quoteCharacter: '"', excludeProps: [], keepLastIntact: false }, settings);
  for (const key in object) {
    if (object[key] === void 0)
      continue;
    if (object[key] === null) {
      toReturn[key] = null;
      continue;
    }
    if (settings.excludeProps.indexOf(key) !== -1) {
      toReturn[key] = object[key];
      continue;
    }
    if (Array.isArray(object[key]) && settings.array || (!Array.isArray(object[key]) && typeof object[key]) == "object") {
      const isArray2 = Array.isArray(object[key]);
      const flatObject = __flatten(object[key], Object.assign(Object.assign({}, settings), { keepLastIntact: false }));
      for (const x in flatObject) {
        if (flatObject[x] === void 0)
          continue;
        if (isArray2) {
          toReturn[`${key}[${x}]`] = flatObject[x];
        } else {
          const part = key;
          if (settings.quoteSeparatedProperties && part.includes(settings.separator)) {
            toReturn[`${settings.quoteCharacter}${key}${settings.quoteCharacter}` + settings.separator + x] = flatObject[x];
          } else {
            toReturn[key + settings.separator + x] = flatObject[x];
          }
        }
      }
      continue;
    }
    toReturn[key] = object[key];
  }
  return toReturn;
}
const __viteBrowserExternal_path = new Proxy({}, {
  get(_, key) {
    throw new Error(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code.  See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
  }
});
const __viteBrowserExternal_path$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal_path
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$4 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal_path$1);
var concatMap$1 = function(xs2, fn2) {
  var res = [];
  for (var i = 0; i < xs2.length; i++) {
    var x = fn2(xs2[i], i);
    if (isArray$3(x))
      res.push.apply(res, x);
    else
      res.push(x);
  }
  return res;
};
var isArray$3 = Array.isArray || function(xs2) {
  return Object.prototype.toString.call(xs2) === "[object Array]";
};
var balancedMatch = balanced$1;
function balanced$1(a, b, str2) {
  if (a instanceof RegExp)
    a = maybeMatch(a, str2);
  if (b instanceof RegExp)
    b = maybeMatch(b, str2);
  var r = range(a, b, str2);
  return r && {
    start: r[0],
    end: r[1],
    pre: str2.slice(0, r[0]),
    body: str2.slice(r[0] + a.length, r[1]),
    post: str2.slice(r[1] + b.length)
  };
}
function maybeMatch(reg, str2) {
  var m = str2.match(reg);
  return m ? m[0] : null;
}
balanced$1.range = range;
function range(a, b, str2) {
  var begs, beg, left, right, result2;
  var ai = str2.indexOf(a);
  var bi = str2.indexOf(b, ai + 1);
  var i = ai;
  if (ai >= 0 && bi > 0) {
    if (a === b) {
      return [ai, bi];
    }
    begs = [];
    left = str2.length;
    while (i >= 0 && !result2) {
      if (i == ai) {
        begs.push(i);
        ai = str2.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result2 = [begs.pop(), bi];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }
        bi = str2.indexOf(b, i + 1);
      }
      i = ai < bi && ai >= 0 ? ai : bi;
    }
    if (begs.length) {
      result2 = [left, right];
    }
  }
  return result2;
}
var concatMap = concatMap$1;
var balanced = balancedMatch;
var braceExpansion = expandTop;
var escSlash = "\0SLASH" + Math.random() + "\0";
var escOpen = "\0OPEN" + Math.random() + "\0";
var escClose = "\0CLOSE" + Math.random() + "\0";
var escComma = "\0COMMA" + Math.random() + "\0";
var escPeriod = "\0PERIOD" + Math.random() + "\0";
function numeric(str2) {
  return parseInt(str2, 10) == str2 ? parseInt(str2, 10) : str2.charCodeAt(0);
}
function escapeBraces(str2) {
  return str2.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
}
function unescapeBraces(str2) {
  return str2.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
}
function parseCommaParts(str2) {
  if (!str2)
    return [""];
  var parts = [];
  var m = balanced("{", "}", str2);
  if (!m)
    return str2.split(",");
  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(",");
  p[p.length - 1] += "{" + body + "}";
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length - 1] += postParts.shift();
    p.push.apply(p, postParts);
  }
  parts.push.apply(parts, p);
  return parts;
}
function expandTop(str2) {
  if (!str2)
    return [];
  if (str2.substr(0, 2) === "{}") {
    str2 = "\\{\\}" + str2.substr(2);
  }
  return expand$1(escapeBraces(str2), true).map(unescapeBraces);
}
function embrace(str2) {
  return "{" + str2 + "}";
}
function isPadded(el2) {
  return /^-?0\d/.test(el2);
}
function lte(i, y2) {
  return i <= y2;
}
function gte(i, y2) {
  return i >= y2;
}
function expand$1(str2, isTop) {
  var expansions = [];
  var m = balanced("{", "}", str2);
  if (!m || /\$$/.test(m.pre))
    return [str2];
  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(",") >= 0;
  if (!isSequence && !isOptions) {
    if (m.post.match(/,.*\}/)) {
      str2 = m.pre + "{" + m.body + escClose + m.post;
      return expand$1(str2);
    }
    return [str2];
  }
  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      n = expand$1(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length ? expand$1(m.post, false) : [""];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }
  var pre = m.pre;
  var post = m.post.length ? expand$1(m.post, false) : [""];
  var N2;
  if (isSequence) {
    var x = numeric(n[0]);
    var y2 = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length);
    var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
    var test2 = lte;
    var reverse = y2 < x;
    if (reverse) {
      incr *= -1;
      test2 = gte;
    }
    var pad2 = n.some(isPadded);
    N2 = [];
    for (var i = x; test2(i, y2); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === "\\")
          c = "";
      } else {
        c = String(i);
        if (pad2) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join("0");
            if (i < 0)
              c = "-" + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N2.push(c);
    }
  } else {
    N2 = concatMap(n, function(el2) {
      return expand$1(el2, false);
    });
  }
  for (var j = 0; j < N2.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N2[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }
  return expansions;
}
minimatch.Minimatch = Minimatch;
var path = function() {
  try {
    return require$$0$4;
  } catch (e) {
  }
}() || {
  sep: "/"
};
minimatch.sep = path.sep;
var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
var expand = braceExpansion;
var plTypes = {
  "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
  "?": { open: "(?:", close: ")?" },
  "+": { open: "(?:", close: ")+" },
  "*": { open: "(?:", close: ")*" },
  "@": { open: "(?:", close: ")" }
};
var qmark = "[^/]";
var star = qmark + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var reSpecials = charSet("().*{}+?[]^$\\!");
function charSet(s) {
  return s.split("").reduce(function(set2, c) {
    set2[c] = true;
    return set2;
  }, {});
}
var slashSplit = /\/+/;
minimatch.filter = filter$1;
function filter$1(pattern, options) {
  options = options || {};
  return function(p, i, list2) {
    return minimatch(p, pattern, options);
  };
}
function ext(a, b) {
  b = b || {};
  var t = {};
  Object.keys(a).forEach(function(k) {
    t[k] = a[k];
  });
  Object.keys(b).forEach(function(k) {
    t[k] = b[k];
  });
  return t;
}
minimatch.defaults = function(def) {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch;
  }
  var orig = minimatch;
  var m = function minimatch2(p, pattern, options) {
    return orig(p, pattern, ext(def, options));
  };
  m.Minimatch = function Minimatch2(pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options));
  };
  m.Minimatch.defaults = function defaults(options) {
    return orig.defaults(ext(def, options)).Minimatch;
  };
  m.filter = function filter2(pattern, options) {
    return orig.filter(pattern, ext(def, options));
  };
  m.defaults = function defaults(options) {
    return orig.defaults(ext(def, options));
  };
  m.makeRe = function makeRe2(pattern, options) {
    return orig.makeRe(pattern, ext(def, options));
  };
  m.braceExpand = function braceExpand2(pattern, options) {
    return orig.braceExpand(pattern, ext(def, options));
  };
  m.match = function(list2, pattern, options) {
    return orig.match(list2, pattern, ext(def, options));
  };
  return m;
};
Minimatch.defaults = function(def) {
  return minimatch.defaults(def).Minimatch;
};
function minimatch(p, pattern, options) {
  assertValidPattern(pattern);
  if (!options)
    options = {};
  if (!options.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch(pattern, options).match(p);
}
function Minimatch(pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options);
  }
  assertValidPattern(pattern);
  if (!options)
    options = {};
  pattern = pattern.trim();
  if (!options.allowWindowsEscape && path.sep !== "/") {
    pattern = pattern.split(path.sep).join("/");
  }
  this.options = options;
  this.set = [];
  this.pattern = pattern;
  this.regexp = null;
  this.negate = false;
  this.comment = false;
  this.empty = false;
  this.partial = !!options.partial;
  this.make();
}
Minimatch.prototype.debug = function() {
};
Minimatch.prototype.make = make;
function make() {
  var pattern = this.pattern;
  var options = this.options;
  if (!options.nocomment && pattern.charAt(0) === "#") {
    this.comment = true;
    return;
  }
  if (!pattern) {
    this.empty = true;
    return;
  }
  this.parseNegate();
  var set2 = this.globSet = this.braceExpand();
  if (options.debug)
    this.debug = function debug() {
      console.error.apply(console, arguments);
    };
  this.debug(this.pattern, set2);
  set2 = this.globParts = set2.map(function(s) {
    return s.split(slashSplit);
  });
  this.debug(this.pattern, set2);
  set2 = set2.map(function(s, si, set3) {
    return s.map(this.parse, this);
  }, this);
  this.debug(this.pattern, set2);
  set2 = set2.filter(function(s) {
    return s.indexOf(false) === -1;
  });
  this.debug(this.pattern, set2);
  this.set = set2;
}
Minimatch.prototype.parseNegate = parseNegate;
function parseNegate() {
  var pattern = this.pattern;
  var negate = false;
  var options = this.options;
  var negateOffset = 0;
  if (options.nonegate)
    return;
  for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
    negate = !negate;
    negateOffset++;
  }
  if (negateOffset)
    this.pattern = pattern.substr(negateOffset);
  this.negate = negate;
}
minimatch.braceExpand = function(pattern, options) {
  return braceExpand(pattern, options);
};
Minimatch.prototype.braceExpand = braceExpand;
function braceExpand(pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options;
    } else {
      options = {};
    }
  }
  pattern = typeof pattern === "undefined" ? this.pattern : pattern;
  assertValidPattern(pattern);
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return expand(pattern);
}
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = function(pattern) {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};
Minimatch.prototype.parse = parse$1;
var SUBPARSE = {};
function parse$1(pattern, isSub) {
  assertValidPattern(pattern);
  var options = this.options;
  if (pattern === "**") {
    if (!options.noglobstar)
      return GLOBSTAR;
    else
      pattern = "*";
  }
  if (pattern === "")
    return "";
  var re = "";
  var hasMagic = !!options.nocase;
  var escaping = false;
  var patternListStack = [];
  var negativeLists = [];
  var stateChar;
  var inClass = false;
  var reClassStart = -1;
  var classStart = -1;
  var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
  var self2 = this;
  function clearStateChar() {
    if (stateChar) {
      switch (stateChar) {
        case "*":
          re += star;
          hasMagic = true;
          break;
        case "?":
          re += qmark;
          hasMagic = true;
          break;
        default:
          re += "\\" + stateChar;
          break;
      }
      self2.debug("clearStateChar %j %j", stateChar, re);
      stateChar = false;
    }
  }
  for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
    this.debug("%s	%s %s %j", pattern, i, re, c);
    if (escaping && reSpecials[c]) {
      re += "\\" + c;
      escaping = false;
      continue;
    }
    switch (c) {
      case "/": {
        return false;
      }
      case "\\":
        clearStateChar();
        escaping = true;
        continue;
      case "?":
      case "*":
      case "+":
      case "@":
      case "!":
        this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
        if (inClass) {
          this.debug("  in class");
          if (c === "!" && i === classStart + 1)
            c = "^";
          re += c;
          continue;
        }
        self2.debug("call clearStateChar %j", stateChar);
        clearStateChar();
        stateChar = c;
        if (options.noext)
          clearStateChar();
        continue;
      case "(":
        if (inClass) {
          re += "(";
          continue;
        }
        if (!stateChar) {
          re += "\\(";
          continue;
        }
        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        });
        re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
        this.debug("plType %j %j", stateChar, re);
        stateChar = false;
        continue;
      case ")":
        if (inClass || !patternListStack.length) {
          re += "\\)";
          continue;
        }
        clearStateChar();
        hasMagic = true;
        var pl2 = patternListStack.pop();
        re += pl2.close;
        if (pl2.type === "!") {
          negativeLists.push(pl2);
        }
        pl2.reEnd = re.length;
        continue;
      case "|":
        if (inClass || !patternListStack.length || escaping) {
          re += "\\|";
          escaping = false;
          continue;
        }
        clearStateChar();
        re += "|";
        continue;
      case "[":
        clearStateChar();
        if (inClass) {
          re += "\\" + c;
          continue;
        }
        inClass = true;
        classStart = i;
        reClassStart = re.length;
        re += c;
        continue;
      case "]":
        if (i === classStart + 1 || !inClass) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        var cs2 = pattern.substring(classStart + 1, i);
        try {
          RegExp("[" + cs2 + "]");
        } catch (er2) {
          var sp = this.parse(cs2, SUBPARSE);
          re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
          hasMagic = hasMagic || sp[1];
          inClass = false;
          continue;
        }
        hasMagic = true;
        inClass = false;
        re += c;
        continue;
      default:
        clearStateChar();
        if (escaping) {
          escaping = false;
        } else if (reSpecials[c] && !(c === "^" && inClass)) {
          re += "\\";
        }
        re += c;
    }
  }
  if (inClass) {
    cs2 = pattern.substr(classStart + 1);
    sp = this.parse(cs2, SUBPARSE);
    re = re.substr(0, reClassStart) + "\\[" + sp[0];
    hasMagic = hasMagic || sp[1];
  }
  for (pl2 = patternListStack.pop(); pl2; pl2 = patternListStack.pop()) {
    var tail = re.slice(pl2.reStart + pl2.open.length);
    this.debug("setting tail", re, pl2);
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
      if (!$2) {
        $2 = "\\";
      }
      return $1 + $1 + $2 + "|";
    });
    this.debug("tail=%j\n   %s", tail, tail, pl2, re);
    var t = pl2.type === "*" ? star : pl2.type === "?" ? qmark : "\\" + pl2.type;
    hasMagic = true;
    re = re.slice(0, pl2.reStart) + t + "\\(" + tail;
  }
  clearStateChar();
  if (escaping) {
    re += "\\\\";
  }
  var addPatternStart = false;
  switch (re.charAt(0)) {
    case "[":
    case ".":
    case "(":
      addPatternStart = true;
  }
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl2 = negativeLists[n];
    var nlBefore = re.slice(0, nl2.reStart);
    var nlFirst = re.slice(nl2.reStart, nl2.reEnd - 8);
    var nlLast = re.slice(nl2.reEnd - 8, nl2.reEnd);
    var nlAfter = re.slice(nl2.reEnd);
    nlLast += nlAfter;
    var openParensBefore = nlBefore.split("(").length - 1;
    var cleanAfter = nlAfter;
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
    }
    nlAfter = cleanAfter;
    var dollar = "";
    if (nlAfter === "" && isSub !== SUBPARSE) {
      dollar = "$";
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
    re = newRe;
  }
  if (re !== "" && hasMagic) {
    re = "(?=.)" + re;
  }
  if (addPatternStart) {
    re = patternStart + re;
  }
  if (isSub === SUBPARSE) {
    return [re, hasMagic];
  }
  if (!hasMagic) {
    return globUnescape(pattern);
  }
  var flags2 = options.nocase ? "i" : "";
  try {
    var regExp = new RegExp("^" + re + "$", flags2);
  } catch (er2) {
    return new RegExp("$.");
  }
  regExp._glob = pattern;
  regExp._src = re;
  return regExp;
}
minimatch.makeRe = function(pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe();
};
Minimatch.prototype.makeRe = makeRe$1;
function makeRe$1() {
  if (this.regexp || this.regexp === false)
    return this.regexp;
  var set2 = this.set;
  if (!set2.length) {
    this.regexp = false;
    return this.regexp;
  }
  var options = this.options;
  var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
  var flags2 = options.nocase ? "i" : "";
  var re = set2.map(function(pattern) {
    return pattern.map(function(p) {
      return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
    }).join("\\/");
  }).join("|");
  re = "^(?:" + re + ")$";
  if (this.negate)
    re = "^(?!" + re + ").*$";
  try {
    this.regexp = new RegExp(re, flags2);
  } catch (ex) {
    this.regexp = false;
  }
  return this.regexp;
}
minimatch.match = function(list2, pattern, options) {
  options = options || {};
  var mm2 = new Minimatch(pattern, options);
  list2 = list2.filter(function(f) {
    return mm2.match(f);
  });
  if (mm2.options.nonull && !list2.length) {
    list2.push(pattern);
  }
  return list2;
};
Minimatch.prototype.match = function match(f, partial) {
  if (typeof partial === "undefined")
    partial = this.partial;
  this.debug("match", f, this.pattern);
  if (this.comment)
    return false;
  if (this.empty)
    return f === "";
  if (f === "/" && partial)
    return true;
  var options = this.options;
  if (path.sep !== "/") {
    f = f.split(path.sep).join("/");
  }
  f = f.split(slashSplit);
  this.debug(this.pattern, "split", f);
  var set2 = this.set;
  this.debug(this.pattern, "set", set2);
  var filename;
  var i;
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i];
    if (filename)
      break;
  }
  for (i = 0; i < set2.length; i++) {
    var pattern = set2[i];
    var file = f;
    if (options.matchBase && pattern.length === 1) {
      file = [filename];
    }
    var hit = this.matchOne(file, pattern, partial);
    if (hit) {
      if (options.flipNegate)
        return true;
      return !this.negate;
    }
  }
  if (options.flipNegate)
    return false;
  return this.negate;
};
Minimatch.prototype.matchOne = function(file, pattern, partial) {
  var options = this.options;
  this.debug(
    "matchOne",
    { "this": this, file, pattern }
  );
  this.debug("matchOne", file.length, pattern.length);
  for (var fi2 = 0, pi2 = 0, fl2 = file.length, pl2 = pattern.length; fi2 < fl2 && pi2 < pl2; fi2++, pi2++) {
    this.debug("matchOne loop");
    var p = pattern[pi2];
    var f = file[fi2];
    this.debug(pattern, p, f);
    if (p === false)
      return false;
    if (p === GLOBSTAR) {
      this.debug("GLOBSTAR", [pattern, p, f]);
      var fr2 = fi2;
      var pr2 = pi2 + 1;
      if (pr2 === pl2) {
        this.debug("** at the end");
        for (; fi2 < fl2; fi2++) {
          if (file[fi2] === "." || file[fi2] === ".." || !options.dot && file[fi2].charAt(0) === ".")
            return false;
        }
        return true;
      }
      while (fr2 < fl2) {
        var swallowee = file[fr2];
        this.debug("\nglobstar while", file, fr2, pattern, pr2, swallowee);
        if (this.matchOne(file.slice(fr2), pattern.slice(pr2), partial)) {
          this.debug("globstar found match!", fr2, fl2, swallowee);
          return true;
        } else {
          if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
            this.debug("dot detected!", file, fr2, pattern, pr2);
            break;
          }
          this.debug("globstar swallow a segment, and continue");
          fr2++;
        }
      }
      if (partial) {
        this.debug("\n>>> no match, partial?", file, fr2, pattern, pr2);
        if (fr2 === fl2)
          return true;
      }
      return false;
    }
    var hit;
    if (typeof p === "string") {
      hit = f === p;
      this.debug("string match", p, f, hit);
    } else {
      hit = f.match(p);
      this.debug("pattern match", p, f, hit);
    }
    if (!hit)
      return false;
  }
  if (fi2 === fl2 && pi2 === pl2) {
    return true;
  } else if (fi2 === fl2) {
    return partial;
  } else if (pi2 === pl2) {
    return fi2 === fl2 - 1 && file[fi2] === "";
  }
  throw new Error("wtf?");
};
function globUnescape(s) {
  return s.replace(/\\(.)/g, "$1");
}
function regExpEscape(s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}
function pad(hash2, len) {
  while (hash2.length < len) {
    hash2 = "0" + hash2;
  }
  return hash2;
}
function fold(hash2, text) {
  var i;
  var chr;
  var len;
  if (text.length === 0) {
    return hash2;
  }
  for (i = 0, len = text.length; i < len; i++) {
    chr = text.charCodeAt(i);
    hash2 = (hash2 << 5) - hash2 + chr;
    hash2 |= 0;
  }
  return hash2 < 0 ? hash2 * -2 : hash2;
}
function foldObject(hash2, o, seen2) {
  return Object.keys(o).sort().reduce(foldKey, hash2);
  function foldKey(hash3, key) {
    return foldValue(hash3, o[key], key, seen2);
  }
}
function foldValue(input, value, key, seen2) {
  var hash2 = fold(fold(fold(input, key), toString$3(value)), typeof value);
  if (value === null) {
    return fold(hash2, "null");
  }
  if (value === void 0) {
    return fold(hash2, "undefined");
  }
  if (typeof value === "object" || typeof value === "function") {
    if (seen2.indexOf(value) !== -1) {
      return fold(hash2, "[Circular]" + key);
    }
    seen2.push(value);
    var objHash = foldObject(hash2, value, seen2);
    if (!("valueOf" in value) || typeof value.valueOf !== "function") {
      return objHash;
    }
    try {
      return fold(objHash, String(value.valueOf()));
    } catch (err) {
      return fold(objHash, "[valueOf exception]" + (err.stack || err.message));
    }
  }
  return fold(hash2, value.toString());
}
function toString$3(o) {
  return Object.prototype.toString.call(o);
}
function sum(o) {
  return pad(foldValue(0, o, "", []).toString(16), 8);
}
var hashSum = sum;
const __hashSum = /* @__PURE__ */ getDefaultExportFromCjs(hashSum);
function objectHash(obj, settings = {}) {
  settings = Object.assign({}, settings);
  return __hashSum(obj);
}
function __sort(object, sort) {
  const keys3 = Object.keys(object);
  const sortedKeys = keys3.sort((a, b) => {
    if (!sort) {
      if (a < b) {
        return -1;
      }
      if (a > b) {
        return 1;
      }
      return 0;
    }
    return sort({ key: a, value: object[a] }, { key: b, value: object[b] });
  });
  const resultObj = {};
  sortedKeys.forEach((k) => {
    resultObj[k] = object[k];
  });
  return resultObj;
}
class SLog {
  static filter(filter2) {
    if (typeof filter2 === "function") {
      this._filterFunctions = [...this._filterFunctions, filter2];
    } else {
      this._filteredTypes = filter2;
    }
  }
  /**
   * @name            clearFilters
   * @type            Function
   * @static
   *
   * This static method allows you to reset all the filters applied
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static clearFilters() {
    this._filteredTypes = [];
    this._filterFunctions = [];
    M;
  }
  static setDefaultLogObj(logObj) {
    this._defaultLogObj = logObj;
  }
  /**
   * @name            isTypeEnabled
   * @type            Function
   * @static
   *
   * This static method allows you Check if a particular log type is enabled or not.
   * You can pass as well multiple log types as an array.
   *
   * @param       {ISLogType|ISLogType[]}             types      The log type(s) you want to check
   * @return      {Boolean}                              True if the log type is enabled, false otherwise
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static isTypeEnabled(types2) {
    if (!this._filteredTypes.length) {
      return true;
    }
    if (!Array.isArray(types2))
      types2 = [types2];
    for (const type of types2) {
      if (!this._filteredTypes.includes(type))
        return false;
    }
    return true;
  }
  /**
   * @name        constructor
   * @type        Function
   * @constructor
   *
   * Constructor
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  constructor(logObj) {
    var _a2;
    if (!(logObj === null || logObj === void 0 ? void 0 : logObj.value) && !logObj._logObj)
      ;
    this._logObj = __deepMerge(
      {
        type: SLog.TYPE_LOG,
        timestamp: Date.now(),
        decorators: true,
        time: false,
        verbose: false,
        notify: false,
        metas: {}
      },
      // @ts-ignore
      this.constructor._defaultLogObj,
      // @ts-ignore
      (_a2 = logObj._logObj) !== null && _a2 !== void 0 ? _a2 : logObj
    );
  }
  /**
   * @name        value
   * @type        Any
   * @get
   * @set
   *
   * Access the "value" property of the SLog object
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get value() {
    return this._logObj.value;
  }
  set value(value) {
    this._logObj.value = value;
  }
  /**
   * @name        metas
   * @type        Any
   * @get
   * @set
   *
   * Access the "metas" property of the SLog object
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get metas() {
    var _a2;
    return (_a2 = this._logObj.metas) !== null && _a2 !== void 0 ? _a2 : {};
  }
  set metas(value) {
    this._logObj.metas = value;
  }
  /**
   * @name        type
   * @type        String
   * @get
   *
   * Access the "type" property of the SLog object
   * This specify which type if the log. LOG, INFO, WARN, ERROR or VERBODE
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get type() {
    return this._logObj.type;
  }
  /**
   * @name        group
   * @type        String
   * @get
   *
   * Access the "group" property of the SLog object
   * The group can be used to display logs in a stack or whatever...
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get group() {
    return this._logObj.group;
  }
  set group(value) {
    if (typeof value !== "string") {
      throw new Error(`<red>[SLog]</red> The "<cyan>group</cyan>" property MUST be a string. You've passed a "${typeof value}"...`);
    }
    this._logObj.group = value;
  }
  /**
   * @name        active
   * @type        Boolean
   * @get
   *
   * Access the "active" property of the SLog object
   * This specify if the log is active depending on parameters like `SLog.filter`.
   * Check the documentation of this static method for more info.
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get active() {
    for (let [idx, fn2] of this.constructor._filterFunctions.entries()) {
      if (!fn2(this)) {
        return false;
      }
    }
    if (!this._logObj.type)
      return true;
    if (!this.constructor._filteredTypes.length) {
      return true;
    }
    if (!this.constructor.TYPES.includes(this._logObj.type)) {
      return true;
    }
    if (!this.constructor._filteredTypes.includes(this._logObj.type))
      return false;
    return true;
  }
  /**
   * @name        decorators
   * @type        Boolean
   * @get
   * @set
   *
   * Access the "decorators" property of the SLog object.
   * This specify if the log has to be printed with decorators or not
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get decorators() {
    return this._logObj.decorators;
  }
  set decorators(value) {
    this._logObj.decorators = value;
  }
  /**
   * @name        time
   * @type        Boolean
   * @get
   *
   * Access the "time" property of the SLog object.
   * This specify if the log has to be printed with his time or not
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get time() {
    return this._logObj.time;
  }
  /**
   * @name        timestamp
   * @type        String
   * @get
   *
   * Access the "timestamp" property of the SLog object
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get timestamp() {
    return this._logObj.timestamp;
  }
  /**
   * @name        clear
   * @type        Boolean
   * @get
   *
   * Access the "clear" property of the SLog object.
   * This specify if the previous logs have to be cleared before printing this one
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get clear() {
    return this._logObj.clear;
  }
  /**
   * @name        margin
   * @type        ISLogMargin
   * @get
   *
   * Access the "margin" property of the SLog object.
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get margin() {
    var _a2;
    return (_a2 = this._logObj.margin) !== null && _a2 !== void 0 ? _a2 : {
      top: 0,
      bottom: 0
    };
  }
  /**
   * @name        temp
   * @type        Boolean
   * @get
   *
   * Access the "temp" property of the SLog object.
   * This specify if this log is a temporary one and if it has to be deleted
   * when the next log appear.
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get temp() {
    return this._logObj.temp;
  }
  /**
   * @name        as
   * @type        String
   * @get
   *
   * Access the "as" property of the SLog object.
   * This specify the optimal way the log has to be displayed.
   * This depends on the logger you use and how it can display logs.
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get as() {
    return this._logObj.as;
  }
  /**
   * @name        verbose
   * @type        Boolean
   * @get
   *
   * Access the "verbose" property of the SLog object
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get verbose() {
    return this._logObj.verbose;
  }
  set verbose(value) {
    this._logObj.verbose = value;
  }
  /**
   * @name        notify
   * @type        Boolean
   * @get
   *
   * Access the "notify" property of the SLog object
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get notify() {
    return this._logObj.notify;
  }
  set notify(value) {
    this._logObj.notify = value;
  }
  /**
   * @name        logger
   * @type        Function
   * @get
   *
   * Access the "logger" property of the SLog object.
   * This represent a function that will be used to actually log the message.
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get logger() {
    return this._logObj.logger;
  }
}
SLog.TYPE_LOG = "log";
SLog.TYPE_INFO = "info";
SLog.TYPE_WARN = "warn";
SLog.TYPE_ERROR = "error";
SLog.TYPE_SUCCESS = "success";
SLog.TYPES = [
  SLog.TYPE_LOG,
  SLog.TYPE_INFO,
  SLog.TYPE_WARN,
  SLog.TYPE_ERROR,
  SLog.TYPE_SUCCESS
];
SLog.PRESET_SILENT = [];
SLog.PRESET_DEFAULT = [
  SLog.TYPE_LOG,
  SLog.TYPE_INFO,
  SLog.TYPE_WARN,
  SLog.TYPE_ERROR,
  SLog.TYPE_SUCCESS
];
SLog.PRESET_WARN = [SLog.TYPE_WARN, SLog.TYPE_ERROR];
SLog.PRESET_ERROR = [SLog.TYPE_ERROR];
SLog.PRESET_VERBOSE = [
  SLog.TYPE_LOG,
  SLog.TYPE_INFO,
  SLog.TYPE_WARN,
  SLog.TYPE_ERROR,
  SLog.TYPE_SUCCESS
];
SLog.PRESETS = ["silent", "default", "warn", "error"];
SLog._filteredTypes = [];
SLog._filterFunctions = [];
SLog._filteredTypes = [];
SLog._defaultLogObj = {};
function availableColors(settings) {
  settings = Object.assign({ excludeBasics: false }, settings !== null && settings !== void 0 ? settings : {});
  const _colors = [
    "yellow",
    "cyan",
    "green",
    "magenta",
    "blue",
    "red",
    "grey",
    "gray"
  ];
  let colors = _colors;
  if (settings.excludeBasics) {
    colors = _colors.filter((c) => {
      return c !== "white" && c !== "black" && c !== "grey" && c !== "gray";
    });
  }
  return colors;
}
class SSugarConfig {
  static get finalConfig() {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h;
    if (SSugarConfig._finalConfig)
      return SSugarConfig._finalConfig;
    SSugarConfig._finalConfig = __deepMerge(
      // @ts-ignore
      (_h = (_c2 = (_b2 = (_a2 = document.env) === null || _a2 === void 0 ? void 0 : _a2.SUGAR) === null || _b2 === void 0 ? void 0 : _b2.config) !== null && _c2 !== void 0 ? _c2 : (_g2 = (_f2 = (_e2 = (_d2 = window.top) === null || _d2 === void 0 ? void 0 : _d2.document) === null || _e2 === void 0 ? void 0 : _e2.env) === null || _f2 === void 0 ? void 0 : _f2.SUGAR) === null || _g2 === void 0 ? void 0 : _g2.config) !== null && _h !== void 0 ? _h : {}
    );
    return SSugarConfig._finalConfig;
  }
  /**
   * @name        config
   * @type        ISSugarConfig
   * @get
   *
   * Simple config accessor to access directly the config object
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static get config() {
    return this.get(".");
  }
  /**
   * @name            get
   * @type            Function
   * @static
   *
   * This static method allows you to access your configurations
   *
   * @param       {String}            [dotpath='.']             The dotpath representing the configuration you want to access
   * @return      {any}                                   The getted configuration
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static get(dotpath = ".") {
    return get(SSugarConfig.finalConfig, dotpath);
  }
  /**
   * @name            set
   * @type            Function
   * @static
   *
   * This static method allows you to set a configuration value
   *
   * @param       {String}            dotpath             The dotpath representing the configuration you want to access
   * @param       {any}               value               The value you want to set
   * @return      {any}                                   The getted configuration
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static set(dotpath, value) {
    return __set(SSugarConfig.finalConfig, dotpath, value);
  }
}
function __pickRandom(array, count = 1) {
  array = __unique(array);
  const items = [];
  if (count > 1) {
    if (count >= array.length) {
      return array;
    }
    for (let i = 0; i < count; i++) {
      let item = __pickRandom(array, 1);
      while (items.includes(item)) {
        item = __pickRandom(array, 1);
      }
      items.push(item);
    }
    return items;
  } else if (count === 1) {
    return array[Math.round(Math.random() * (array.length - 1))];
  }
  return array;
}
var md5$2 = { exports: {} };
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var core$1 = { exports: {} };
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore)
    return core$1.exports;
  hasRequiredCore = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory();
      }
    })(commonjsGlobal, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined$12) {
        var crypto;
        if (typeof window !== "undefined" && window.crypto) {
          crypto = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto = globalThis.crypto;
        }
        if (!crypto && typeof window !== "undefined" && window.msCrypto) {
          crypto = window.msCrypto;
        }
        if (!crypto && typeof commonjsGlobal !== "undefined" && commonjsGlobal.crypto) {
          crypto = commonjsGlobal.crypto;
        }
        if (!crypto && typeof commonjsRequire === "function") {
          try {
            crypto = require$$0$5;
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto) {
            if (typeof crypto.getRandomValues === "function") {
              try {
                return crypto.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto.randomBytes === "function") {
              try {
                return crypto.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create2 = Object.create || function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create2(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties2) {
              for (var propertyName in properties2) {
                if (properties2.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties2[propertyName];
                }
              }
              if (properties2.hasOwnProperty("toString")) {
                this.toString = properties2.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined$12) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex2).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone2 = Base.clone.call(this);
            clone2.words = this.words.slice(0);
            return clone2;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex2 = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data2) {
            if (typeof data2 == "string") {
              data2 = Utf8.parse(data2);
            }
            this._data.concat(data2);
            this._nDataBytes += data2.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data2 = this._data;
            var dataWords = data2.words;
            var dataSigBytes = data2.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset2 = 0; offset2 < nWordsReady; offset2 += blockSize) {
                this._doProcessBlock(dataWords, offset2);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data2.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone2 = Base.clone.call(this);
            clone2._data = this._data.clone();
            return clone2;
          },
          _minBufferSize: 0
        });
        C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash2 = this._doFinalize();
            return hash2;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS;
    });
  })(core$1);
  return core$1.exports;
}
(function(module, exports) {
  (function(root, factory) {
    {
      module.exports = factory(requireCore());
    }
  })(commonjsGlobal, function(CryptoJS) {
    (function(Math2) {
      var C = CryptoJS;
      var C_lib = C.lib;
      var WordArray = C_lib.WordArray;
      var Hasher = C_lib.Hasher;
      var C_algo = C.algo;
      var T = [];
      (function() {
        for (var i = 0; i < 64; i++) {
          T[i] = Math2.abs(Math2.sin(i + 1)) * 4294967296 | 0;
        }
      })();
      var MD5 = C_algo.MD5 = Hasher.extend({
        _doReset: function() {
          this._hash = new WordArray.init([
            1732584193,
            4023233417,
            2562383102,
            271733878
          ]);
        },
        _doProcessBlock: function(M2, offset2) {
          for (var i = 0; i < 16; i++) {
            var offset_i = offset2 + i;
            var M_offset_i = M2[offset_i];
            M2[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
          }
          var H = this._hash.words;
          var M_offset_0 = M2[offset2 + 0];
          var M_offset_1 = M2[offset2 + 1];
          var M_offset_2 = M2[offset2 + 2];
          var M_offset_3 = M2[offset2 + 3];
          var M_offset_4 = M2[offset2 + 4];
          var M_offset_5 = M2[offset2 + 5];
          var M_offset_6 = M2[offset2 + 6];
          var M_offset_7 = M2[offset2 + 7];
          var M_offset_8 = M2[offset2 + 8];
          var M_offset_9 = M2[offset2 + 9];
          var M_offset_10 = M2[offset2 + 10];
          var M_offset_11 = M2[offset2 + 11];
          var M_offset_12 = M2[offset2 + 12];
          var M_offset_13 = M2[offset2 + 13];
          var M_offset_14 = M2[offset2 + 14];
          var M_offset_15 = M2[offset2 + 15];
          var a = H[0];
          var b = H[1];
          var c = H[2];
          var d2 = H[3];
          a = FF(a, b, c, d2, M_offset_0, 7, T[0]);
          d2 = FF(d2, a, b, c, M_offset_1, 12, T[1]);
          c = FF(c, d2, a, b, M_offset_2, 17, T[2]);
          b = FF(b, c, d2, a, M_offset_3, 22, T[3]);
          a = FF(a, b, c, d2, M_offset_4, 7, T[4]);
          d2 = FF(d2, a, b, c, M_offset_5, 12, T[5]);
          c = FF(c, d2, a, b, M_offset_6, 17, T[6]);
          b = FF(b, c, d2, a, M_offset_7, 22, T[7]);
          a = FF(a, b, c, d2, M_offset_8, 7, T[8]);
          d2 = FF(d2, a, b, c, M_offset_9, 12, T[9]);
          c = FF(c, d2, a, b, M_offset_10, 17, T[10]);
          b = FF(b, c, d2, a, M_offset_11, 22, T[11]);
          a = FF(a, b, c, d2, M_offset_12, 7, T[12]);
          d2 = FF(d2, a, b, c, M_offset_13, 12, T[13]);
          c = FF(c, d2, a, b, M_offset_14, 17, T[14]);
          b = FF(b, c, d2, a, M_offset_15, 22, T[15]);
          a = GG(a, b, c, d2, M_offset_1, 5, T[16]);
          d2 = GG(d2, a, b, c, M_offset_6, 9, T[17]);
          c = GG(c, d2, a, b, M_offset_11, 14, T[18]);
          b = GG(b, c, d2, a, M_offset_0, 20, T[19]);
          a = GG(a, b, c, d2, M_offset_5, 5, T[20]);
          d2 = GG(d2, a, b, c, M_offset_10, 9, T[21]);
          c = GG(c, d2, a, b, M_offset_15, 14, T[22]);
          b = GG(b, c, d2, a, M_offset_4, 20, T[23]);
          a = GG(a, b, c, d2, M_offset_9, 5, T[24]);
          d2 = GG(d2, a, b, c, M_offset_14, 9, T[25]);
          c = GG(c, d2, a, b, M_offset_3, 14, T[26]);
          b = GG(b, c, d2, a, M_offset_8, 20, T[27]);
          a = GG(a, b, c, d2, M_offset_13, 5, T[28]);
          d2 = GG(d2, a, b, c, M_offset_2, 9, T[29]);
          c = GG(c, d2, a, b, M_offset_7, 14, T[30]);
          b = GG(b, c, d2, a, M_offset_12, 20, T[31]);
          a = HH(a, b, c, d2, M_offset_5, 4, T[32]);
          d2 = HH(d2, a, b, c, M_offset_8, 11, T[33]);
          c = HH(c, d2, a, b, M_offset_11, 16, T[34]);
          b = HH(b, c, d2, a, M_offset_14, 23, T[35]);
          a = HH(a, b, c, d2, M_offset_1, 4, T[36]);
          d2 = HH(d2, a, b, c, M_offset_4, 11, T[37]);
          c = HH(c, d2, a, b, M_offset_7, 16, T[38]);
          b = HH(b, c, d2, a, M_offset_10, 23, T[39]);
          a = HH(a, b, c, d2, M_offset_13, 4, T[40]);
          d2 = HH(d2, a, b, c, M_offset_0, 11, T[41]);
          c = HH(c, d2, a, b, M_offset_3, 16, T[42]);
          b = HH(b, c, d2, a, M_offset_6, 23, T[43]);
          a = HH(a, b, c, d2, M_offset_9, 4, T[44]);
          d2 = HH(d2, a, b, c, M_offset_12, 11, T[45]);
          c = HH(c, d2, a, b, M_offset_15, 16, T[46]);
          b = HH(b, c, d2, a, M_offset_2, 23, T[47]);
          a = II(a, b, c, d2, M_offset_0, 6, T[48]);
          d2 = II(d2, a, b, c, M_offset_7, 10, T[49]);
          c = II(c, d2, a, b, M_offset_14, 15, T[50]);
          b = II(b, c, d2, a, M_offset_5, 21, T[51]);
          a = II(a, b, c, d2, M_offset_12, 6, T[52]);
          d2 = II(d2, a, b, c, M_offset_3, 10, T[53]);
          c = II(c, d2, a, b, M_offset_10, 15, T[54]);
          b = II(b, c, d2, a, M_offset_1, 21, T[55]);
          a = II(a, b, c, d2, M_offset_8, 6, T[56]);
          d2 = II(d2, a, b, c, M_offset_15, 10, T[57]);
          c = II(c, d2, a, b, M_offset_6, 15, T[58]);
          b = II(b, c, d2, a, M_offset_13, 21, T[59]);
          a = II(a, b, c, d2, M_offset_4, 6, T[60]);
          d2 = II(d2, a, b, c, M_offset_11, 10, T[61]);
          c = II(c, d2, a, b, M_offset_2, 15, T[62]);
          b = II(b, c, d2, a, M_offset_9, 21, T[63]);
          H[0] = H[0] + a | 0;
          H[1] = H[1] + b | 0;
          H[2] = H[2] + c | 0;
          H[3] = H[3] + d2 | 0;
        },
        _doFinalize: function() {
          var data2 = this._data;
          var dataWords = data2.words;
          var nBitsTotal = this._nDataBytes * 8;
          var nBitsLeft = data2.sigBytes * 8;
          dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
          var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
          var nBitsTotalL = nBitsTotal;
          dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
          dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
          data2.sigBytes = (dataWords.length + 1) * 4;
          this._process();
          var hash2 = this._hash;
          var H = hash2.words;
          for (var i = 0; i < 4; i++) {
            var H_i = H[i];
            H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
          }
          return hash2;
        },
        clone: function() {
          var clone2 = Hasher.clone.call(this);
          clone2._hash = this._hash.clone();
          return clone2;
        }
      });
      function FF(a, b, c, d2, x, s, t) {
        var n = a + (b & c | ~b & d2) + x + t;
        return (n << s | n >>> 32 - s) + b;
      }
      function GG(a, b, c, d2, x, s, t) {
        var n = a + (b & d2 | c & ~d2) + x + t;
        return (n << s | n >>> 32 - s) + b;
      }
      function HH(a, b, c, d2, x, s, t) {
        var n = a + (b ^ c ^ d2) + x + t;
        return (n << s | n >>> 32 - s) + b;
      }
      function II(a, b, c, d2, x, s, t) {
        var n = a + (c ^ (b | ~d2)) + x + t;
        return (n << s | n >>> 32 - s) + b;
      }
      C.MD5 = Hasher._createHelper(MD5);
      C.HmacMD5 = Hasher._createHmacHelper(MD5);
    })(Math);
    return CryptoJS.MD5;
  });
})(md5$2);
var md5Exports = md5$2.exports;
const md5$1 = /* @__PURE__ */ getDefaultExportFromCjs(md5Exports);
function __parse(value) {
  if (typeof value !== "string")
    return value;
  if (value === "true")
    return true;
  if (value === "false")
    return false;
  if (value === "null")
    return null;
  if (value === "undefined")
    return void 0;
  value = value.split("⠀").join("").trim();
  try {
    return Function(`
            "use strict";
            return (${value});
        `)();
  } catch (e) {
    return value;
  }
}
var ansiStyles$1 = { exports: {} };
var colorName;
var hasRequiredColorName;
function requireColorName() {
  if (hasRequiredColorName)
    return colorName;
  hasRequiredColorName = 1;
  colorName = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };
  return colorName;
}
var conversions;
var hasRequiredConversions;
function requireConversions() {
  if (hasRequiredConversions)
    return conversions;
  hasRequiredConversions = 1;
  const cssKeywords = requireColorName();
  const reverseKeywords = {};
  for (const key of Object.keys(cssKeywords)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
  const convert2 = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  conversions = convert2;
  for (const model of Object.keys(convert2)) {
    if (!("channels" in convert2[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert2[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert2[model].labels.length !== convert2[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    const { channels, labels } = convert2[model];
    delete convert2[model].channels;
    delete convert2[model].labels;
    Object.defineProperty(convert2[model], "channels", { value: channels });
    Object.defineProperty(convert2[model], "labels", { value: labels });
  }
  convert2.rgb.hsl = function(rgb) {
    const r = rgb[0] / 255;
    const g2 = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min2 = Math.min(r, g2, b);
    const max2 = Math.max(r, g2, b);
    const delta = max2 - min2;
    let h;
    let s;
    if (max2 === min2) {
      h = 0;
    } else if (r === max2) {
      h = (g2 - b) / delta;
    } else if (g2 === max2) {
      h = 2 + (b - r) / delta;
    } else if (b === max2) {
      h = 4 + (r - g2) / delta;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
      h += 360;
    }
    const l = (min2 + max2) / 2;
    if (max2 === min2) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max2 + min2);
    } else {
      s = delta / (2 - max2 - min2);
    }
    return [h, s * 100, l * 100];
  };
  convert2.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h;
    let s;
    const r = rgb[0] / 255;
    const g2 = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v2 = Math.max(r, g2, b);
    const diff = v2 - Math.min(r, g2, b);
    const diffc = function(c) {
      return (v2 - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h = 0;
      s = 0;
    } else {
      s = diff / v2;
      rdif = diffc(r);
      gdif = diffc(g2);
      bdif = diffc(b);
      if (r === v2) {
        h = bdif - gdif;
      } else if (g2 === v2) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v2) {
        h = 2 / 3 + gdif - rdif;
      }
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }
    return [
      h * 360,
      s * 100,
      v2 * 100
    ];
  };
  convert2.rgb.hwb = function(rgb) {
    const r = rgb[0];
    const g2 = rgb[1];
    let b = rgb[2];
    const h = convert2.rgb.hsl(rgb)[0];
    const w = 1 / 255 * Math.min(r, Math.min(g2, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g2, b));
    return [h, w * 100, b * 100];
  };
  convert2.rgb.cmyk = function(rgb) {
    const r = rgb[0] / 255;
    const g2 = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g2, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m = (1 - g2 - k) / (1 - k) || 0;
    const y2 = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y2 * 100, k * 100];
  };
  function comparativeDistance(x, y2) {
    return (x[0] - y2[0]) ** 2 + (x[1] - y2[1]) ** 2 + (x[2] - y2[2]) ** 2;
  }
  convert2.rgb.keyword = function(rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys(cssKeywords)) {
      const value = cssKeywords[keyword];
      const distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
    return currentClosestKeyword;
  };
  convert2.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert2.rgb.xyz = function(rgb) {
    let r = rgb[0] / 255;
    let g2 = rgb[1] / 255;
    let b = rgb[2] / 255;
    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
    g2 = g2 > 0.04045 ? ((g2 + 0.055) / 1.055) ** 2.4 : g2 / 12.92;
    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
    const x = r * 0.4124 + g2 * 0.3576 + b * 0.1805;
    const y2 = r * 0.2126 + g2 * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g2 * 0.1192 + b * 0.9505;
    return [x * 100, y2 * 100, z * 100];
  };
  convert2.rgb.lab = function(rgb) {
    const xyz = convert2.rgb.xyz(rgb);
    let x = xyz[0];
    let y2 = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y2 /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
    z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y2 - 16;
    const a = 500 * (x - y2);
    const b = 200 * (y2 - z);
    return [l, a, b];
  };
  convert2.hsl.rgb = function(hsl) {
    const h = hsl[0] / 360;
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val;
    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }
    const t1 = 2 * l - t2;
    const rgb = [0, 0, 0];
    for (let i = 0; i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert2.hsl.hsv = function(hsl) {
    const h = hsl[0];
    let s = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v2 = (l + s) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v2 * 100];
  };
  convert2.hsv.rgb = function(hsv) {
    const h = hsv[0] / 60;
    const s = hsv[1] / 100;
    let v2 = hsv[2] / 100;
    const hi = Math.floor(h) % 6;
    const f = h - Math.floor(h);
    const p = 255 * v2 * (1 - s);
    const q = 255 * v2 * (1 - s * f);
    const t = 255 * v2 * (1 - s * (1 - f));
    v2 *= 255;
    switch (hi) {
      case 0:
        return [v2, t, p];
      case 1:
        return [q, v2, p];
      case 2:
        return [p, v2, t];
      case 3:
        return [p, q, v2];
      case 4:
        return [t, p, v2];
      case 5:
        return [v2, p, q];
    }
  };
  convert2.hsv.hsl = function(hsv) {
    const h = hsv[0];
    const s = hsv[1] / 100;
    const v2 = hsv[2] / 100;
    const vmin = Math.max(v2, 0.01);
    let sl2;
    let l;
    l = (2 - s) * v2;
    const lmin = (2 - s) * vmin;
    sl2 = s * vmin;
    sl2 /= lmin <= 1 ? lmin : 2 - lmin;
    sl2 = sl2 || 0;
    l /= 2;
    return [h, sl2 * 100, l * 100];
  };
  convert2.hwb.rgb = function(hwb) {
    const h = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl2 = hwb[2] / 100;
    const ratio = wh + bl2;
    let f;
    if (ratio > 1) {
      wh /= ratio;
      bl2 /= ratio;
    }
    const i = Math.floor(6 * h);
    const v2 = 1 - bl2;
    f = 6 * h - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    const n = wh + f * (v2 - wh);
    let r;
    let g2;
    let b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v2;
        g2 = n;
        b = wh;
        break;
      case 1:
        r = n;
        g2 = v2;
        b = wh;
        break;
      case 2:
        r = wh;
        g2 = v2;
        b = n;
        break;
      case 3:
        r = wh;
        g2 = n;
        b = v2;
        break;
      case 4:
        r = n;
        g2 = wh;
        b = v2;
        break;
      case 5:
        r = v2;
        g2 = wh;
        b = n;
        break;
    }
    return [r * 255, g2 * 255, b * 255];
  };
  convert2.cmyk.rgb = function(cmyk) {
    const c = cmyk[0] / 100;
    const m = cmyk[1] / 100;
    const y2 = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g2 = 1 - Math.min(1, m * (1 - k) + k);
    const b = 1 - Math.min(1, y2 * (1 - k) + k);
    return [r * 255, g2 * 255, b * 255];
  };
  convert2.xyz.rgb = function(xyz) {
    const x = xyz[0] / 100;
    const y2 = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g2;
    let b;
    r = x * 3.2406 + y2 * -1.5372 + z * -0.4986;
    g2 = x * -0.9689 + y2 * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y2 * -0.204 + z * 1.057;
    r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
    g2 = g2 > 31308e-7 ? 1.055 * g2 ** (1 / 2.4) - 0.055 : g2 * 12.92;
    b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g2 = Math.min(Math.max(0, g2), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g2 * 255, b * 255];
  };
  convert2.xyz.lab = function(xyz) {
    let x = xyz[0];
    let y2 = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y2 /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
    z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y2 - 16;
    const a = 500 * (x - y2);
    const b = 200 * (y2 - z);
    return [l, a, b];
  };
  convert2.lab.xyz = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y2;
    let z;
    y2 = (l + 16) / 116;
    x = a / 500 + y2;
    z = y2 - b / 200;
    const y22 = y2 ** 3;
    const x2 = x ** 3;
    const z2 = z ** 3;
    y2 = y22 > 8856e-6 ? y22 : (y2 - 16 / 116) / 7.787;
    x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y2 *= 100;
    z *= 108.883;
    return [x, y2, z];
  };
  convert2.lab.lch = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h;
    const hr2 = Math.atan2(b, a);
    h = hr2 * 360 / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    const c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };
  convert2.lch.lab = function(lch) {
    const l = lch[0];
    const c = lch[1];
    const h = lch[2];
    const hr2 = h / 360 * 2 * Math.PI;
    const a = c * Math.cos(hr2);
    const b = c * Math.sin(hr2);
    return [l, a, b];
  };
  convert2.rgb.ansi16 = function(args, saturation = null) {
    const [r, g2, b] = args;
    let value = saturation === null ? convert2.rgb.hsv(args)[2] : saturation;
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g2 / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert2.hsv.ansi16 = function(args) {
    return convert2.rgb.ansi16(convert2.hsv.rgb(args), args[2]);
  };
  convert2.rgb.ansi256 = function(args) {
    const r = args[0];
    const g2 = args[1];
    const b = args[2];
    if (r === g2 && g2 === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g2 / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  convert2.ansi16.rgb = function(args) {
    let color = args % 10;
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    const mult = (~~(args > 50) + 1) * 0.5;
    const r = (color & 1) * mult * 255;
    const g2 = (color >> 1 & 1) * mult * 255;
    const b = (color >> 2 & 1) * mult * 255;
    return [r, g2, b];
  };
  convert2.ansi256.rgb = function(args) {
    if (args >= 232) {
      const c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    let rem;
    const r = Math.floor(args / 36) / 5 * 255;
    const g2 = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [r, g2, b];
  };
  convert2.rgb.hex = function(args) {
    const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert2.hex.rgb = function(args) {
    const match2 = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match2) {
      return [0, 0, 0];
    }
    let colorString = match2[0];
    if (match2[0].length === 3) {
      colorString = colorString.split("").map((char) => {
        return char + char;
      }).join("");
    }
    const integer = parseInt(colorString, 16);
    const r = integer >> 16 & 255;
    const g2 = integer >> 8 & 255;
    const b = integer & 255;
    return [r, g2, b];
  };
  convert2.rgb.hcg = function(rgb) {
    const r = rgb[0] / 255;
    const g2 = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max2 = Math.max(Math.max(r, g2), b);
    const min2 = Math.min(Math.min(r, g2), b);
    const chroma = max2 - min2;
    let grayscale;
    let hue;
    if (chroma < 1) {
      grayscale = min2 / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max2 === r) {
      hue = (g2 - b) / chroma % 6;
    } else if (max2 === g2) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g2) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert2.hsl.hcg = function(hsl) {
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
    let f = 0;
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert2.hsv.hcg = function(hsv) {
    const s = hsv[1] / 100;
    const v2 = hsv[2] / 100;
    const c = s * v2;
    let f = 0;
    if (c < 1) {
      f = (v2 - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert2.hcg.rgb = function(hcg) {
    const h = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g2 = hcg[2] / 100;
    if (c === 0) {
      return [g2 * 255, g2 * 255, g2 * 255];
    }
    const pure = [0, 0, 0];
    const hi = h % 1 * 6;
    const v2 = hi % 1;
    const w = 1 - v2;
    let mg2 = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v2;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v2;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v2;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    mg2 = (1 - c) * g2;
    return [
      (c * pure[0] + mg2) * 255,
      (c * pure[1] + mg2) * 255,
      (c * pure[2] + mg2) * 255
    ];
  };
  convert2.hcg.hsv = function(hcg) {
    const c = hcg[1] / 100;
    const g2 = hcg[2] / 100;
    const v2 = c + g2 * (1 - c);
    let f = 0;
    if (v2 > 0) {
      f = c / v2;
    }
    return [hcg[0], f * 100, v2 * 100];
  };
  convert2.hcg.hsl = function(hcg) {
    const c = hcg[1] / 100;
    const g2 = hcg[2] / 100;
    const l = g2 * (1 - c) + 0.5 * c;
    let s = 0;
    if (l > 0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s = c / (2 * (1 - l));
    }
    return [hcg[0], s * 100, l * 100];
  };
  convert2.hcg.hwb = function(hcg) {
    const c = hcg[1] / 100;
    const g2 = hcg[2] / 100;
    const v2 = c + g2 * (1 - c);
    return [hcg[0], (v2 - c) * 100, (1 - v2) * 100];
  };
  convert2.hwb.hcg = function(hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v2 = 1 - b;
    const c = v2 - w;
    let g2 = 0;
    if (c < 1) {
      g2 = (v2 - c) / (1 - c);
    }
    return [hwb[0], c * 100, g2 * 100];
  };
  convert2.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert2.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert2.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert2.gray.hsl = function(args) {
    return [0, 0, args[0]];
  };
  convert2.gray.hsv = convert2.gray.hsl;
  convert2.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert2.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert2.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert2.gray.hex = function(gray) {
    const val = Math.round(gray[0] / 100 * 255) & 255;
    const integer = (val << 16) + (val << 8) + val;
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert2.rgb.gray = function(rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
  return conversions;
}
var route;
var hasRequiredRoute;
function requireRoute() {
  if (hasRequiredRoute)
    return route;
  hasRequiredRoute = 1;
  const conversions2 = requireConversions();
  function buildGraph() {
    const graph = {};
    const models = Object.keys(conversions2);
    for (let len = models.length, i = 0; i < len; i++) {
      graph[models[i]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    }
    return graph;
  }
  function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      const current = queue.pop();
      const adjacents = Object.keys(conversions2[current]);
      for (let len = adjacents.length, i = 0; i < len; i++) {
        const adjacent = adjacents[i];
        const node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link(from2, to2) {
    return function(args) {
      return to2(from2(args));
    };
  }
  function wrapConversion(toModel, graph) {
    const path2 = [graph[toModel].parent, toModel];
    let fn2 = conversions2[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path2.unshift(graph[cur].parent);
      fn2 = link(conversions2[graph[cur].parent][cur], fn2);
      cur = graph[cur].parent;
    }
    fn2.conversion = path2;
    return fn2;
  }
  route = function(fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);
    for (let len = models.length, i = 0; i < len; i++) {
      const toModel = models[i];
      const node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
  return route;
}
var colorConvert;
var hasRequiredColorConvert;
function requireColorConvert() {
  if (hasRequiredColorConvert)
    return colorConvert;
  hasRequiredColorConvert = 1;
  const conversions2 = requireConversions();
  const route2 = requireRoute();
  const convert2 = {};
  const models = Object.keys(conversions2);
  function wrapRaw(fn2) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      return fn2(args);
    };
    if ("conversion" in fn2) {
      wrappedFn.conversion = fn2.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn2) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      const result2 = fn2(args);
      if (typeof result2 === "object") {
        for (let len = result2.length, i = 0; i < len; i++) {
          result2[i] = Math.round(result2[i]);
        }
      }
      return result2;
    };
    if ("conversion" in fn2) {
      wrappedFn.conversion = fn2.conversion;
    }
    return wrappedFn;
  }
  models.forEach((fromModel) => {
    convert2[fromModel] = {};
    Object.defineProperty(convert2[fromModel], "channels", { value: conversions2[fromModel].channels });
    Object.defineProperty(convert2[fromModel], "labels", { value: conversions2[fromModel].labels });
    const routes = route2(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach((toModel) => {
      const fn2 = routes[toModel];
      convert2[fromModel][toModel] = wrapRounded(fn2);
      convert2[fromModel][toModel].raw = wrapRaw(fn2);
    });
  });
  colorConvert = convert2;
  return colorConvert;
}
ansiStyles$1.exports;
(function(module) {
  const wrapAnsi16 = (fn2, offset2) => (...args) => {
    const code3 = fn2(...args);
    return `\x1B[${code3 + offset2}m`;
  };
  const wrapAnsi256 = (fn2, offset2) => (...args) => {
    const code3 = fn2(...args);
    return `\x1B[${38 + offset2};5;${code3}m`;
  };
  const wrapAnsi16m = (fn2, offset2) => (...args) => {
    const rgb = fn2(...args);
    return `\x1B[${38 + offset2};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };
  const ansi2ansi = (n) => n;
  const rgb2rgb = (r, g2, b) => [r, g2, b];
  const setLazyProperty = (object, property, get2) => {
    Object.defineProperty(object, property, {
      get: () => {
        const value = get2();
        Object.defineProperty(object, property, {
          value,
          enumerable: true,
          configurable: true
        });
        return value;
      },
      enumerable: true,
      configurable: true
    });
  };
  let colorConvert2;
  const makeDynamicStyles = (wrap2, targetSpace, identity2, isBackground) => {
    if (colorConvert2 === void 0) {
      colorConvert2 = requireColorConvert();
    }
    const offset2 = isBackground ? 10 : 0;
    const styles2 = {};
    for (const [sourceSpace, suite] of Object.entries(colorConvert2)) {
      const name2 = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
      if (sourceSpace === targetSpace) {
        styles2[name2] = wrap2(identity2, offset2);
      } else if (typeof suite === "object") {
        styles2[name2] = wrap2(suite[targetSpace], offset2);
      }
    }
    return styles2;
  };
  function assembleStyles() {
    const codes = /* @__PURE__ */ new Map();
    const styles2 = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        // Bright color
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles2.color.gray = styles2.color.blackBright;
    styles2.bgColor.bgGray = styles2.bgColor.bgBlackBright;
    styles2.color.grey = styles2.color.blackBright;
    styles2.bgColor.bgGrey = styles2.bgColor.bgBlackBright;
    for (const [groupName, group] of Object.entries(styles2)) {
      for (const [styleName, style] of Object.entries(group)) {
        styles2[styleName] = {
          open: `\x1B[${style[0]}m`,
          close: `\x1B[${style[1]}m`
        };
        group[styleName] = styles2[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles2, groupName, {
        value: group,
        enumerable: false
      });
    }
    Object.defineProperty(styles2, "codes", {
      value: codes,
      enumerable: false
    });
    styles2.color.close = "\x1B[39m";
    styles2.bgColor.close = "\x1B[49m";
    setLazyProperty(styles2.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
    setLazyProperty(styles2.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
    setLazyProperty(styles2.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
    setLazyProperty(styles2.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
    setLazyProperty(styles2.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
    setLazyProperty(styles2.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
    return styles2;
  }
  Object.defineProperty(module, "exports", {
    enumerable: true,
    get: assembleStyles
  });
})(ansiStyles$1);
var ansiStylesExports = ansiStyles$1.exports;
var browser = {
  stdout: false,
  stderr: false
};
const stringReplaceAll$1 = (string, substring, replacer) => {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.substr(endIndex);
  return returnValue;
};
const stringEncaseCRLFWithFirstIndex$1 = (string, prefix, postfix, index) => {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string[index - 1] === "\r";
    returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
    endIndex = index + 1;
    index = string.indexOf("\n", endIndex);
  } while (index !== -1);
  returnValue += string.substr(endIndex);
  return returnValue;
};
var util$2 = {
  stringReplaceAll: stringReplaceAll$1,
  stringEncaseCRLFWithFirstIndex: stringEncaseCRLFWithFirstIndex$1
};
var templates;
var hasRequiredTemplates;
function requireTemplates() {
  if (hasRequiredTemplates)
    return templates;
  hasRequiredTemplates = 1;
  const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
  const ESCAPES = /* @__PURE__ */ new Map([
    ["n", "\n"],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", "\x1B"],
    ["a", "\x07"]
  ]);
  function unescape2(c) {
    const u = c[0] === "u";
    const bracket = c[1] === "{";
    if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
      return String.fromCharCode(parseInt(c.slice(1), 16));
    }
    if (u && bracket) {
      return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
    }
    return ESCAPES.get(c) || c;
  }
  function parseArguments(name2, arguments_) {
    const results = [];
    const chunks = arguments_.trim().split(/\s*,\s*/g);
    let matches;
    for (const chunk of chunks) {
      const number = Number(chunk);
      if (!Number.isNaN(number)) {
        results.push(number);
      } else if (matches = chunk.match(STRING_REGEX)) {
        results.push(matches[2].replace(ESCAPE_REGEX, (m, escape2, character) => escape2 ? unescape2(escape2) : character));
      } else {
        throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name2}')`);
      }
    }
    return results;
  }
  function parseStyle(style) {
    STYLE_REGEX.lastIndex = 0;
    const results = [];
    let matches;
    while ((matches = STYLE_REGEX.exec(style)) !== null) {
      const name2 = matches[1];
      if (matches[2]) {
        const args = parseArguments(name2, matches[2]);
        results.push([name2].concat(args));
      } else {
        results.push([name2]);
      }
    }
    return results;
  }
  function buildStyle(chalk2, styles2) {
    const enabled = {};
    for (const layer of styles2) {
      for (const style of layer.styles) {
        enabled[style[0]] = layer.inverse ? null : style.slice(1);
      }
    }
    let current = chalk2;
    for (const [styleName, styles3] of Object.entries(enabled)) {
      if (!Array.isArray(styles3)) {
        continue;
      }
      if (!(styleName in current)) {
        throw new Error(`Unknown Chalk style: ${styleName}`);
      }
      current = styles3.length > 0 ? current[styleName](...styles3) : current[styleName];
    }
    return current;
  }
  templates = (chalk2, temporary) => {
    const styles2 = [];
    const chunks = [];
    let chunk = [];
    temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
      if (escapeCharacter) {
        chunk.push(unescape2(escapeCharacter));
      } else if (style) {
        const string = chunk.join("");
        chunk = [];
        chunks.push(styles2.length === 0 ? string : buildStyle(chalk2, styles2)(string));
        styles2.push({ inverse, styles: parseStyle(style) });
      } else if (close) {
        if (styles2.length === 0) {
          throw new Error("Found extraneous } in Chalk template literal");
        }
        chunks.push(buildStyle(chalk2, styles2)(chunk.join("")));
        chunk = [];
        styles2.pop();
      } else {
        chunk.push(character);
      }
    });
    chunks.push(chunk.join(""));
    if (styles2.length > 0) {
      const errMessage = `Chalk template literal is missing ${styles2.length} closing bracket${styles2.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(errMessage);
    }
    return chunks.join("");
  };
  return templates;
}
const ansiStyles = ansiStylesExports;
const { stdout: stdoutColor, stderr: stderrColor } = browser;
const {
  stringReplaceAll,
  stringEncaseCRLFWithFirstIndex
} = util$2;
const { isArray: isArray$2 } = Array;
const levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
const styles = /* @__PURE__ */ Object.create(null);
const applyOptions = (object, options = {}) => {
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === void 0 ? colorLevel : options.level;
};
class ChalkClass {
  constructor(options) {
    return chalkFactory(options);
  }
}
const chalkFactory = (options) => {
  const chalk2 = {};
  applyOptions(chalk2, options);
  chalk2.template = (...arguments_) => chalkTag(chalk2.template, ...arguments_);
  Object.setPrototypeOf(chalk2, Chalk.prototype);
  Object.setPrototypeOf(chalk2.template, chalk2);
  chalk2.template.constructor = () => {
    throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
  };
  chalk2.template.Instance = ChalkClass;
  return chalk2.template;
};
function Chalk(options) {
  return chalkFactory(options);
}
for (const [styleName, style] of Object.entries(ansiStyles)) {
  styles[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    }
  };
}
styles.visible = {
  get() {
    const builder = createBuilder(this, this._styler, true);
    Object.defineProperty(this, "visible", { value: builder });
    return builder;
  }
};
const usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
for (const model of usedModels) {
  styles[model] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
        return createBuilder(this, styler, this._isEmpty);
      };
    }
  };
}
for (const model of usedModels) {
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles[bgModel] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
        return createBuilder(this, styler, this._isEmpty);
      };
    }
  };
}
const proto = Object.defineProperties(() => {
}, {
  ...styles,
  level: {
    enumerable: true,
    get() {
      return this._generator.level;
    },
    set(level) {
      this._generator.level = level;
    }
  }
});
const createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === void 0) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
};
const createBuilder = (self2, _styler, _isEmpty) => {
  const builder = (...arguments_) => {
    if (isArray$2(arguments_[0]) && isArray$2(arguments_[0].raw)) {
      return applyStyle(builder, chalkTag(builder, ...arguments_));
    }
    return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  };
  Object.setPrototypeOf(builder, proto);
  builder._generator = self2;
  builder._styler = _styler;
  builder._isEmpty = _isEmpty;
  return builder;
};
const applyStyle = (self2, string) => {
  if (self2.level <= 0 || !string) {
    return self2._isEmpty ? "" : string;
  }
  let styler = self2._styler;
  if (styler === void 0) {
    return string;
  }
  const { openAll, closeAll } = styler;
  if (string.indexOf("\x1B") !== -1) {
    while (styler !== void 0) {
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string.indexOf("\n");
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
};
let template;
const chalkTag = (chalk2, ...strings) => {
  const [firstString] = strings;
  if (!isArray$2(firstString) || !isArray$2(firstString.raw)) {
    return strings.join(" ");
  }
  const arguments_ = strings.slice(1);
  const parts = [firstString.raw[0]];
  for (let i = 1; i < firstString.length; i++) {
    parts.push(
      String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"),
      String(firstString.raw[i])
    );
  }
  if (template === void 0) {
    template = requireTemplates();
  }
  return template(chalk2, parts.join(""));
};
Object.defineProperties(Chalk.prototype, styles);
const chalk = Chalk();
chalk.supportsColor = stdoutColor;
chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
chalk.stderr.supportsColor = stderrColor;
var source$1 = chalk;
const __chalk = /* @__PURE__ */ getDefaultExportFromCjs(source$1);
function __mapToObject(map2) {
  const obj = {};
  for (const [k, v2] of map2)
    obj[k] = v2;
  return obj;
}
function __isArray(value) {
  return Array.isArray(value);
}
function __isBoolean(value) {
  return typeof value === "boolean";
}
function __isFunction(value) {
  return value && {}.toString.call(value) === "[object Function]";
}
function __isJson(value) {
  try {
    const res = JSON.parse(value);
    if (Object.keys(res).length)
      return true;
    return false;
  } catch (e) {
    return false;
  }
  return true;
}
function __isMap(value) {
  return value instanceof Map;
}
function __isObject(value) {
  return value && typeof value === "object" && value.constructor === Object;
}
function fn$5(value, settings = {}) {
  settings = __deepMerge({
    beautify: true,
    highlight: true,
    verbose: true,
    theme: {
      number: __chalk.yellow,
      default: __chalk.white,
      keyword: __chalk.blue,
      regexp: __chalk.red,
      string: __chalk.whiteBright,
      class: __chalk.yellow,
      function: __chalk.yellow,
      comment: __chalk.gray,
      variable: __chalk.red,
      attr: __chalk.green
    }
  }, settings);
  if (typeof value === "string")
    return value;
  if (value === null)
    return null;
  if (value === void 0)
    return void 0;
  if (value instanceof Error) {
    const errorStr = value.toString();
    const stackStr = value.stack;
    const messageStr = value.message;
    if (settings.verbose) {
      return [
        `<red>${value.constructor.name || "Error"}</red>`,
        "",
        messageStr,
        "",
        stackStr
      ].join("\n");
    }
    return errorStr;
  }
  if (__isMap(value)) {
    value = __mapToObject(value);
  }
  if (__isObject(value) || __isArray(value) || __isJson(value)) {
    try {
      value = decycle_1(value);
    } catch (e) {
    }
    value = __deepMap(value, ({ value: value2 }) => {
      if (value2 instanceof Map)
        return __mapToObject(value2);
      return value2;
    });
    let prettyString = JSON.stringify(value, null, settings.beautify ? 4 : 0);
    prettyString = prettyString.replace(/"([^"]+)":/g, "$1:").replace(/\uFFFF/g, '\\"');
    if (settings.highlight)
      ;
    return prettyString;
  }
  if (__isBoolean(value)) {
    if (value)
      return "true";
    else
      return "false";
  }
  if (__isFunction(value)) {
    return "" + value;
  }
  let returnString = "";
  try {
    value = decycle_1(value);
    returnString = JSON.stringify(value, null, settings.beautify ? 4 : 0);
  } catch (e) {
    try {
      returnString = value.toString();
    } catch (e2) {
      returnString = value;
    }
  }
  return returnString;
}
const __encryptedMessages = {};
const __md5 = {
  /**
   * @name        encrypt
   * @type          Function
   *
   * Encrypt
   *
   * @param       {String}      message         The message to encrypt
   * @return      {String}                      The encrypted string
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  encrypt: function(message) {
    if (typeof message !== "string")
      message = fn$5(message);
    const string = md5$1(message).toString();
    __encryptedMessages[string] = message;
    return string;
  },
  /**
   * @name        decrypt
   * @type        Function
   *
   * Decrypt
   *
   * @param       {String}        message         The message to decrypt
   * @return      {String}                        The decrypted message
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  decrypt: function(message) {
    if (!__encryptedMessages[message]) {
      console.warn(`The message "${message}" cannot be decrypted...`);
      return;
    }
    const string = __encryptedMessages[message];
    delete __encryptedMessages[message];
    return __parse(string);
  }
};
let _colorsStack = {};
let _colorUsedByScope = {};
function getColorFor(ref, settings) {
  settings = __deepMerge({
    scope: "default",
    excludeBasics: true
  }, settings !== null && settings !== void 0 ? settings : {});
  const availableColors$1 = availableColors(settings);
  const scopeId = __md5.encrypt(settings.scope);
  const refId = __md5.encrypt(ref);
  if (_colorsStack[`${scopeId}.${refId}`]) {
    return _colorsStack[`${scopeId}.${refId}`];
  }
  if (!_colorUsedByScope[scopeId])
    _colorUsedByScope[scopeId] = [];
  if (_colorUsedByScope[scopeId].length >= availableColors$1.length) {
    const color = __pickRandom(availableColors$1);
    _colorsStack[`${scopeId}.${refId}`] = color;
    return color;
  } else {
    for (let i = 0; i < availableColors$1.length; i++) {
      if (_colorUsedByScope[scopeId].indexOf(availableColors$1[i]) === -1) {
        _colorUsedByScope[scopeId].push(availableColors$1[i]);
        _colorsStack[`${scopeId}.${refId}`] = availableColors$1[i];
        return availableColors$1[i];
      }
    }
  }
}
function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor2 = _classExtractFieldDescriptor(receiver, privateMap, "get");
  return _classApplyDescriptorGet(receiver, descriptor2);
}
function _classPrivateFieldSet(receiver, privateMap, value) {
  var descriptor2 = _classExtractFieldDescriptor(receiver, privateMap, "set");
  _classApplyDescriptorSet(receiver, descriptor2, value);
  return value;
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet(receiver, descriptor2) {
  if (descriptor2.get) {
    return descriptor2.get.call(receiver);
  }
  return descriptor2.value;
}
function _classApplyDescriptorSet(receiver, descriptor2, value) {
  if (descriptor2.set) {
    descriptor2.set.call(receiver, value);
  } else {
    if (!descriptor2.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor2.value = value;
  }
}
function _classPrivateMethodGet(receiver, privateSet, fn2) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn2;
}
function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldInitSpec(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap);
  privateMap.set(obj, value);
}
function _classPrivateMethodInitSpec(obj, privateSet) {
  _checkPrivateRedeclaration(obj, privateSet);
  privateSet.add(obj);
}
var list = [
  " daum[ /]",
  " deusu/",
  " yadirectfetcher",
  "(?:^| )site",
  "(?:^|[^g])news",
  "@[a-z]",
  "\\(at\\)[a-z]",
  "\\(github\\.com/",
  "\\[at\\][a-z]",
  "^12345",
  "^<",
  "^[\\w \\.\\-\\(\\)]+(/v?\\d+(\\.\\d+)?(\\.\\d{1,10})?)?$",
  "^[^ ]{50,}$",
  "^active",
  "^ad muncher",
  "^amaya",
  "^anglesharp/",
  "^anonymous",
  "^avsdevicesdk/",
  "^axios/",
  "^bidtellect/",
  "^biglotron",
  "^btwebclient/",
  "^castro",
  "^clamav[ /]",
  "^client/",
  "^cobweb/",
  "^coccoc",
  "^custom",
  "^ddg[_-]android",
  "^discourse",
  "^dispatch/\\d",
  "^downcast/",
  "^duckduckgo",
  "^facebook",
  "^fdm[ /]\\d",
  "^getright/",
  "^gozilla/",
  "^hatena",
  "^hobbit",
  "^hotzonu",
  "^hwcdn/",
  "^jeode/",
  "^jetty/",
  "^jigsaw",
  "^linkdex",
  "^lwp[-: ]",
  "^metauri",
  "^microsoft bits",
  "^movabletype",
  "^mozilla/\\d\\.\\d \\(compatible;?\\)$",
  "^mozilla/\\d\\.\\d \\w*$",
  "^navermailapp",
  "^netsurf",
  "^offline explorer",
  "^php",
  "^postman",
  "^postrank",
  "^python",
  "^read",
  "^reed",
  "^restsharp/",
  "^snapchat",
  "^space bison",
  "^svn",
  "^swcd ",
  "^taringa",
  "^test certificate info",
  "^thumbor/",
  "^tumblr/",
  "^user-agent:mozilla",
  "^valid",
  "^venus/fedoraplanet",
  "^w3c",
  "^webbandit/",
  "^webcopier",
  "^wget",
  "^whatsapp",
  "^xenu link sleuth",
  "^yahoo",
  "^yandex",
  "^zdm/\\d",
  "^zoom marketplace/",
  "^{{.*}}$",
  "adbeat\\.com",
  "appinsights",
  "archive",
  "ask jeeves/teoma",
  "bit\\.ly/",
  "bluecoat drtr",
  "bot",
  "browsex",
  "burpcollaborator",
  "capture",
  "catch",
  "check",
  "chrome-lighthouse",
  "chromeframe",
  "cloud",
  "crawl",
  "cryptoapi",
  "dareboost",
  "datanyze",
  "dataprovider",
  "dejaclick",
  "dmbrowser",
  "download",
  "evc-batch/",
  "feed",
  "firephp",
  "freesafeip",
  "ghost",
  "gomezagent",
  "google",
  "headlesschrome/",
  "http",
  "httrack",
  "hubspot marketing grader",
  "hydra",
  "ibisbrowser",
  "images",
  "iplabel",
  "ips-agent",
  "java",
  "library",
  "mail\\.ru/",
  "manager",
  "monitor",
  "morningscore/",
  "neustar wpm",
  "nutch",
  "offbyone",
  "optimize",
  "pageburst",
  "pagespeed",
  "perl",
  "phantom",
  "pingdom",
  "powermarks",
  "preview",
  "proxy",
  "ptst[ /]\\d",
  "reader",
  "rexx;",
  "rigor",
  "rss",
  "scan",
  "scrape",
  "search",
  "serp ?reputation ?management",
  "server",
  "sogou",
  "sparkler/",
  "speedcurve",
  "spider",
  "statuscake",
  "stumbleupon\\.com",
  "supercleaner",
  "synapse",
  "synthetic",
  "taginspector/",
  "torrent",
  "tracemyfile",
  "transcoder",
  "trendsmapresolver",
  "twingly recon",
  "url",
  "virtuoso",
  "wappalyzer",
  "webglance",
  "webkit2png",
  "websitemetadataretriever",
  "whatcms/",
  "wordpress",
  "zgrab"
];
function amend(list2) {
  try {
    new RegExp("(?<! cu)bot").test("dangerbot");
  } catch (error2) {
    return list2;
  }
  [
    // Addresses: Cubot device
    ["bot", "(?<! cu)bot"],
    // Addresses: Android webview
    ["google", "(?<! (?:channel/|google/))google(?!(app|/google| pixel))"],
    // Addresses: libhttp browser
    ["http", "(?<!(?:lib))http"],
    // Addresses: java based browsers
    ["java", "java(?!;)"],
    // Addresses: Yandex Search App
    ["search", "(?<! ya(?:yandex)?)search"]
  ].forEach((_ref) => {
    let [search, replace2] = _ref;
    const index = list2.lastIndexOf(search);
    if (~index) {
      list2.splice(index, 1, replace2);
    }
  });
  return list2;
}
amend(list);
const flags = "i";
var _list = /* @__PURE__ */ new WeakMap();
var _pattern = /* @__PURE__ */ new WeakMap();
var _update = /* @__PURE__ */ new WeakSet();
var _index = /* @__PURE__ */ new WeakSet();
class Isbot {
  constructor(patterns) {
    _classPrivateMethodInitSpec(this, _index);
    _classPrivateMethodInitSpec(this, _update);
    _classPrivateFieldInitSpec(this, _list, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _pattern, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _list, patterns || list.slice());
    _classPrivateMethodGet(this, _update, _update2).call(this);
    const isbot2 = (ua) => this.test(ua);
    return Object.defineProperties(isbot2, Object.entries(Object.getOwnPropertyDescriptors(Isbot.prototype)).reduce((accumulator, _ref) => {
      let [prop, descriptor2] = _ref;
      if (typeof descriptor2.value === "function") {
        Object.assign(accumulator, {
          [prop]: {
            value: this[prop].bind(this)
          }
        });
      }
      if (typeof descriptor2.get === "function") {
        Object.assign(accumulator, {
          [prop]: {
            get: () => this[prop]
          }
        });
      }
      return accumulator;
    }, {}));
  }
  /**
   * Get a clone of the pattern
   * @type RegExp
   */
  get pattern() {
    return new RegExp(_classPrivateFieldGet(this, _pattern));
  }
  /**
   * Match given string against out pattern
   * @param  {string} ua User Agent string
   * @returns {boolean}
   */
  test(ua) {
    return Boolean(ua) && _classPrivateFieldGet(this, _pattern).test(ua);
  }
  /**
   * Get the match for strings' known crawler pattern
   * @param  {string} ua User Agent string
   * @returns {string|null}
   */
  find() {
    let ua = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    const match2 = ua.match(_classPrivateFieldGet(this, _pattern));
    return match2 && match2[0];
  }
  /**
   * Get the patterns that match user agent string if any
   * @param  {string} ua User Agent string
   * @returns {string[]}
   */
  matches() {
    let ua = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return _classPrivateFieldGet(this, _list).filter((entry) => new RegExp(entry, flags).test(ua));
  }
  /**
   * Clear all patterns that match user agent
   * @param  {string} ua User Agent string
   * @returns {void}
   */
  clear() {
    let ua = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    this.exclude(this.matches(ua));
  }
  /**
   * Extent patterns for known crawlers
   * @param  {string[]} filters
   * @returns {void}
   */
  extend() {
    let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    [].push.apply(_classPrivateFieldGet(this, _list), filters.filter((rule) => _classPrivateMethodGet(this, _index, _index2).call(this, rule) === -1).map((filter2) => filter2.toLowerCase()));
    _classPrivateMethodGet(this, _update, _update2).call(this);
  }
  /**
   * Exclude patterns from bot pattern rule
   * @param  {string[]} filters
   * @returns {void}
   */
  exclude() {
    let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    let {
      length
    } = filters;
    while (length--) {
      const index = _classPrivateMethodGet(this, _index, _index2).call(this, filters[length]);
      if (index > -1) {
        _classPrivateFieldGet(this, _list).splice(index, 1);
      }
    }
    _classPrivateMethodGet(this, _update, _update2).call(this);
  }
  /**
   * Create a new Isbot instance using given list or self's list
   * @param  {string[]} [list]
   * @returns {Isbot}
   */
  spawn(list2) {
    return new Isbot(list2 || _classPrivateFieldGet(this, _list));
  }
}
function _update2() {
  _classPrivateFieldSet(this, _pattern, new RegExp(_classPrivateFieldGet(this, _list).join("|"), flags));
}
function _index2(rule) {
  return _classPrivateFieldGet(this, _list).indexOf(rule.toLowerCase());
}
const isbot = new Isbot();
function __isCrawler(ua = navigator.userAgent) {
  return isbot(ua);
}
function __isChildProcess() {
  return process.send !== void 0 || {}.IS_CHILD_PROCESS !== void 0;
}
var isClass$1 = { exports: {} };
(function(module, exports) {
  (function(root) {
    const toString2 = Function.prototype.toString;
    function fnBody(fn2) {
      return toString2.call(fn2).replace(/^[^{]*{\s*/, "").replace(/\s*}[^}]*$/, "");
    }
    function isClass2(fn2) {
      if (typeof fn2 !== "function") {
        return false;
      }
      if (/^class[\s{]/.test(toString2.call(fn2))) {
        return true;
      }
      const body = fnBody(fn2);
      return /classCallCheck\(/.test(body) || /TypeError\("Cannot call a class as a function"\)/.test(body);
    }
    {
      if (module.exports) {
        exports = module.exports = isClass2;
      }
      exports.isClass = isClass2;
    }
  })();
})(isClass$1, isClass$1.exports);
var isClassExports = isClass$1.exports;
const __isClass = /* @__PURE__ */ getDefaultExportFromCjs(isClassExports);
function isClass(cls) {
  if (!Array.isArray(cls))
    cls = [cls];
  for (let i = 0; i < cls.length; i++) {
    if (!__isClass(cls[i]))
      return false;
  }
  return true;
}
function __isColor(value) {
  try {
    const ele = document.createElement("div");
    ele.style.color = value;
    return ele.style.color.split(/\s+/).join("").toLowerCase() !== "";
  } catch (e) {
  }
  if (typeof value !== "string")
    return false;
  return value.match(/^#[a-zA-Z0-9]{3,6}$/) || value.match(/^rgba\([0-9]{1,3}(\s+)?,(\s+)?[0-9]{1,3}(\s+)?,(\s+)?[0-9]{1,3}(\s+)?,(\s+)?[0-9]{1,3}\)$/) || value.match(/^rgb\([0-9]{1,3}(\s+)?,(\s+)?[0-9]{1,3}(\s+)?,(\s+)?[0-9]{1,3}\)$/) || value.match(/^hsl\([0-9]{1,3}%?(\s+)?,(\s+)?[0-9]{1,3}%?(\s+)?,(\s+)?[0-9]{1,3}%?(\s+)?\)$/) || value.match(/^hsv\([0-9]{1,3}%?(\s+)?,(\s+)?[0-9]{1,3}%?(\s+)?,(\s+)?[0-9]{1,3}%?(\s+)?\)$/);
}
/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var isExtglob$1 = function isExtglob(str2) {
  if (typeof str2 !== "string" || str2 === "") {
    return false;
  }
  var match2;
  while (match2 = /(\\).|([@?!+*]\(.*\))/g.exec(str2)) {
    if (match2[2])
      return true;
    str2 = str2.slice(match2.index + match2[0].length);
  }
  return false;
};
/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var isExtglob2 = isExtglob$1;
var chars = { "{": "}", "(": ")", "[": "]" };
var strictCheck = function(str2) {
  if (str2[0] === "!") {
    return true;
  }
  var index = 0;
  var pipeIndex = -2;
  var closeSquareIndex = -2;
  var closeCurlyIndex = -2;
  var closeParenIndex = -2;
  var backSlashIndex = -2;
  while (index < str2.length) {
    if (str2[index] === "*") {
      return true;
    }
    if (str2[index + 1] === "?" && /[\].+)]/.test(str2[index])) {
      return true;
    }
    if (closeSquareIndex !== -1 && str2[index] === "[" && str2[index + 1] !== "]") {
      if (closeSquareIndex < index) {
        closeSquareIndex = str2.indexOf("]", index);
      }
      if (closeSquareIndex > index) {
        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
          return true;
        }
        backSlashIndex = str2.indexOf("\\", index);
        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
          return true;
        }
      }
    }
    if (closeCurlyIndex !== -1 && str2[index] === "{" && str2[index + 1] !== "}") {
      closeCurlyIndex = str2.indexOf("}", index);
      if (closeCurlyIndex > index) {
        backSlashIndex = str2.indexOf("\\", index);
        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
          return true;
        }
      }
    }
    if (closeParenIndex !== -1 && str2[index] === "(" && str2[index + 1] === "?" && /[:!=]/.test(str2[index + 2]) && str2[index + 3] !== ")") {
      closeParenIndex = str2.indexOf(")", index);
      if (closeParenIndex > index) {
        backSlashIndex = str2.indexOf("\\", index);
        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
          return true;
        }
      }
    }
    if (pipeIndex !== -1 && str2[index] === "(" && str2[index + 1] !== "|") {
      if (pipeIndex < index) {
        pipeIndex = str2.indexOf("|", index);
      }
      if (pipeIndex !== -1 && str2[pipeIndex + 1] !== ")") {
        closeParenIndex = str2.indexOf(")", pipeIndex);
        if (closeParenIndex > pipeIndex) {
          backSlashIndex = str2.indexOf("\\", pipeIndex);
          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
            return true;
          }
        }
      }
    }
    if (str2[index] === "\\") {
      var open = str2[index + 1];
      index += 2;
      var close = chars[open];
      if (close) {
        var n = str2.indexOf(close, index);
        if (n !== -1) {
          index = n + 1;
        }
      }
      if (str2[index] === "!") {
        return true;
      }
    } else {
      index++;
    }
  }
  return false;
};
var relaxedCheck = function(str2) {
  if (str2[0] === "!") {
    return true;
  }
  var index = 0;
  while (index < str2.length) {
    if (/[*?{}()[\]]/.test(str2[index])) {
      return true;
    }
    if (str2[index] === "\\") {
      var open = str2[index + 1];
      index += 2;
      var close = chars[open];
      if (close) {
        var n = str2.indexOf(close, index);
        if (n !== -1) {
          index = n + 1;
        }
      }
      if (str2[index] === "!") {
        return true;
      }
    } else {
      index++;
    }
  }
  return false;
};
var isGlob = function isGlob2(str2, options) {
  if (typeof str2 !== "string" || str2 === "") {
    return false;
  }
  if (isExtglob2(str2)) {
    return true;
  }
  var check = strictCheck;
  if (options && options.strict === false) {
    check = relaxedCheck;
  }
  return check(str2);
};
const __isGlob$1 = /* @__PURE__ */ getDefaultExportFromCjs(isGlob);
function __isGlob(string) {
  return __isGlob$1(string);
}
function __isInteger(data2) {
  return typeof data2 === "number" && !isNaN(data2) && function(x) {
    return (x | 0) === x;
  }(parseFloat(data2));
}
function __isNode$2() {
  return typeof process !== "undefined" && process.release && process.release.name === "node";
}
function __isString(value) {
  return typeof value === "string" || value instanceof String;
}
function __decodeHtmlEntities(string) {
  const txt = document.createElement("textarea");
  txt.innerHTML = string;
  return txt.value;
}
function __uniqid() {
  const url = URL.createObjectURL(new Blob());
  return `s-${url.substring(url.lastIndexOf("/") + 1)}`;
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error2, e.suppressed = suppressed, e;
};
function lowerCase(str2) {
  return str2.toLowerCase();
}
var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
function noCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  var _a2 = options.splitRegexp, splitRegexp = _a2 === void 0 ? DEFAULT_SPLIT_REGEXP : _a2, _b2 = options.stripRegexp, stripRegexp = _b2 === void 0 ? DEFAULT_STRIP_REGEXP : _b2, _c2 = options.transform, transform = _c2 === void 0 ? lowerCase : _c2, _d2 = options.delimiter, delimiter = _d2 === void 0 ? " " : _d2;
  var result2 = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
  var start = 0;
  var end = result2.length;
  while (result2.charAt(start) === "\0")
    start++;
  while (result2.charAt(end - 1) === "\0")
    end--;
  return result2.slice(start, end).split("\0").map(transform).join(delimiter);
}
function replace(input, re, value) {
  if (re instanceof RegExp)
    return input.replace(re, value);
  return re.reduce(function(input2, re2) {
    return input2.replace(re2, value);
  }, input);
}
function dotCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  return noCase(input, __assign({ delimiter: "." }, options));
}
function paramCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  return dotCase(input, __assign({ delimiter: "-" }, options));
}
function __dashCase(text) {
  return paramCase(text);
}
var toRegex$1 = { exports: {} };
var lib = { exports: {} };
var util$1 = {};
var types$4 = {
  ROOT: 0,
  GROUP: 1,
  POSITION: 2,
  SET: 3,
  RANGE: 4,
  REPETITION: 5,
  REFERENCE: 6,
  CHAR: 7
};
var sets$1 = {};
var types$3 = types$4;
var INTS = function() {
  return [{ type: types$3.RANGE, from: 48, to: 57 }];
};
var WORDS = function() {
  return [
    { type: types$3.CHAR, value: 95 },
    { type: types$3.RANGE, from: 97, to: 122 },
    { type: types$3.RANGE, from: 65, to: 90 }
  ].concat(INTS());
};
var WHITESPACE = function() {
  return [
    { type: types$3.CHAR, value: 9 },
    { type: types$3.CHAR, value: 10 },
    { type: types$3.CHAR, value: 11 },
    { type: types$3.CHAR, value: 12 },
    { type: types$3.CHAR, value: 13 },
    { type: types$3.CHAR, value: 32 },
    { type: types$3.CHAR, value: 160 },
    { type: types$3.CHAR, value: 5760 },
    { type: types$3.CHAR, value: 6158 },
    { type: types$3.CHAR, value: 8192 },
    { type: types$3.CHAR, value: 8193 },
    { type: types$3.CHAR, value: 8194 },
    { type: types$3.CHAR, value: 8195 },
    { type: types$3.CHAR, value: 8196 },
    { type: types$3.CHAR, value: 8197 },
    { type: types$3.CHAR, value: 8198 },
    { type: types$3.CHAR, value: 8199 },
    { type: types$3.CHAR, value: 8200 },
    { type: types$3.CHAR, value: 8201 },
    { type: types$3.CHAR, value: 8202 },
    { type: types$3.CHAR, value: 8232 },
    { type: types$3.CHAR, value: 8233 },
    { type: types$3.CHAR, value: 8239 },
    { type: types$3.CHAR, value: 8287 },
    { type: types$3.CHAR, value: 12288 },
    { type: types$3.CHAR, value: 65279 }
  ];
};
var NOTANYCHAR = function() {
  return [
    { type: types$3.CHAR, value: 10 },
    { type: types$3.CHAR, value: 13 },
    { type: types$3.CHAR, value: 8232 },
    { type: types$3.CHAR, value: 8233 }
  ];
};
sets$1.words = function() {
  return { type: types$3.SET, set: WORDS(), not: false };
};
sets$1.notWords = function() {
  return { type: types$3.SET, set: WORDS(), not: true };
};
sets$1.ints = function() {
  return { type: types$3.SET, set: INTS(), not: false };
};
sets$1.notInts = function() {
  return { type: types$3.SET, set: INTS(), not: true };
};
sets$1.whitespace = function() {
  return { type: types$3.SET, set: WHITESPACE(), not: false };
};
sets$1.notWhitespace = function() {
  return { type: types$3.SET, set: WHITESPACE(), not: true };
};
sets$1.anyChar = function() {
  return { type: types$3.SET, set: NOTANYCHAR(), not: true };
};
(function(exports) {
  var types2 = types$4;
  var sets2 = sets$1;
  var CTRL = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?";
  var SLSH = { "0": 0, "t": 9, "n": 10, "v": 11, "f": 12, "r": 13 };
  exports.strToChars = function(str2) {
    var chars_regex = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z\[\\\]\^?])|([0tnvfr]))/g;
    str2 = str2.replace(chars_regex, function(s, b, lbs, a16, b16, c8, dctrl, eslsh) {
      if (lbs) {
        return s;
      }
      var code3 = b ? 8 : a16 ? parseInt(a16, 16) : b16 ? parseInt(b16, 16) : c8 ? parseInt(c8, 8) : dctrl ? CTRL.indexOf(dctrl) : SLSH[eslsh];
      var c = String.fromCharCode(code3);
      if (/[\[\]{}\^$.|?*+()]/.test(c)) {
        c = "\\" + c;
      }
      return c;
    });
    return str2;
  };
  exports.tokenizeClass = function(str2, regexpStr) {
    var tokens = [];
    var regexp = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(?:\\)?([^\]]))|(\])|(?:\\)?(.)/g;
    var rs2, c;
    while ((rs2 = regexp.exec(str2)) != null) {
      if (rs2[1]) {
        tokens.push(sets2.words());
      } else if (rs2[2]) {
        tokens.push(sets2.ints());
      } else if (rs2[3]) {
        tokens.push(sets2.whitespace());
      } else if (rs2[4]) {
        tokens.push(sets2.notWords());
      } else if (rs2[5]) {
        tokens.push(sets2.notInts());
      } else if (rs2[6]) {
        tokens.push(sets2.notWhitespace());
      } else if (rs2[7]) {
        tokens.push({
          type: types2.RANGE,
          from: (rs2[8] || rs2[9]).charCodeAt(0),
          to: rs2[10].charCodeAt(0)
        });
      } else if (c = rs2[12]) {
        tokens.push({
          type: types2.CHAR,
          value: c.charCodeAt(0)
        });
      } else {
        return [tokens, regexp.lastIndex];
      }
    }
    exports.error(regexpStr, "Unterminated character class");
  };
  exports.error = function(regexp, msg) {
    throw new SyntaxError("Invalid regular expression: /" + regexp + "/: " + msg);
  };
})(util$1);
var positions$1 = {};
var types$2 = types$4;
positions$1.wordBoundary = function() {
  return { type: types$2.POSITION, value: "b" };
};
positions$1.nonWordBoundary = function() {
  return { type: types$2.POSITION, value: "B" };
};
positions$1.begin = function() {
  return { type: types$2.POSITION, value: "^" };
};
positions$1.end = function() {
  return { type: types$2.POSITION, value: "$" };
};
var util = util$1;
var types$1 = types$4;
var sets = sets$1;
var positions = positions$1;
lib.exports = function(regexpStr) {
  var i = 0, l, c, start = { type: types$1.ROOT, stack: [] }, lastGroup = start, last = start.stack, groupStack = [];
  var repeatErr = function(i2) {
    util.error(regexpStr, "Nothing to repeat at column " + (i2 - 1));
  };
  var str2 = util.strToChars(regexpStr);
  l = str2.length;
  while (i < l) {
    c = str2[i++];
    switch (c) {
      case "\\":
        c = str2[i++];
        switch (c) {
          case "b":
            last.push(positions.wordBoundary());
            break;
          case "B":
            last.push(positions.nonWordBoundary());
            break;
          case "w":
            last.push(sets.words());
            break;
          case "W":
            last.push(sets.notWords());
            break;
          case "d":
            last.push(sets.ints());
            break;
          case "D":
            last.push(sets.notInts());
            break;
          case "s":
            last.push(sets.whitespace());
            break;
          case "S":
            last.push(sets.notWhitespace());
            break;
          default:
            if (/\d/.test(c)) {
              last.push({ type: types$1.REFERENCE, value: parseInt(c, 10) });
            } else {
              last.push({ type: types$1.CHAR, value: c.charCodeAt(0) });
            }
        }
        break;
      case "^":
        last.push(positions.begin());
        break;
      case "$":
        last.push(positions.end());
        break;
      case "[":
        var not2;
        if (str2[i] === "^") {
          not2 = true;
          i++;
        } else {
          not2 = false;
        }
        var classTokens = util.tokenizeClass(str2.slice(i), regexpStr);
        i += classTokens[1];
        last.push({
          type: types$1.SET,
          set: classTokens[0],
          not: not2
        });
        break;
      case ".":
        last.push(sets.anyChar());
        break;
      case "(":
        var group = {
          type: types$1.GROUP,
          stack: [],
          remember: true
        };
        c = str2[i];
        if (c === "?") {
          c = str2[i + 1];
          i += 2;
          if (c === "=") {
            group.followedBy = true;
          } else if (c === "!") {
            group.notFollowedBy = true;
          } else if (c !== ":") {
            util.error(
              regexpStr,
              "Invalid group, character '" + c + "' after '?' at column " + (i - 1)
            );
          }
          group.remember = false;
        }
        last.push(group);
        groupStack.push(lastGroup);
        lastGroup = group;
        last = group.stack;
        break;
      case ")":
        if (groupStack.length === 0) {
          util.error(regexpStr, "Unmatched ) at column " + (i - 1));
        }
        lastGroup = groupStack.pop();
        last = lastGroup.options ? lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;
        break;
      case "|":
        if (!lastGroup.options) {
          lastGroup.options = [lastGroup.stack];
          delete lastGroup.stack;
        }
        var stack = [];
        lastGroup.options.push(stack);
        last = stack;
        break;
      case "{":
        var rs2 = /^(\d+)(,(\d+)?)?\}/.exec(str2.slice(i)), min2, max2;
        if (rs2 !== null) {
          if (last.length === 0) {
            repeatErr(i);
          }
          min2 = parseInt(rs2[1], 10);
          max2 = rs2[2] ? rs2[3] ? parseInt(rs2[3], 10) : Infinity : min2;
          i += rs2[0].length;
          last.push({
            type: types$1.REPETITION,
            min: min2,
            max: max2,
            value: last.pop()
          });
        } else {
          last.push({
            type: types$1.CHAR,
            value: 123
          });
        }
        break;
      case "?":
        if (last.length === 0) {
          repeatErr(i);
        }
        last.push({
          type: types$1.REPETITION,
          min: 0,
          max: 1,
          value: last.pop()
        });
        break;
      case "+":
        if (last.length === 0) {
          repeatErr(i);
        }
        last.push({
          type: types$1.REPETITION,
          min: 1,
          max: Infinity,
          value: last.pop()
        });
        break;
      case "*":
        if (last.length === 0) {
          repeatErr(i);
        }
        last.push({
          type: types$1.REPETITION,
          min: 0,
          max: Infinity,
          value: last.pop()
        });
        break;
      default:
        last.push({
          type: types$1.CHAR,
          value: c.charCodeAt(0)
        });
    }
  }
  if (groupStack.length !== 0) {
    util.error(regexpStr, "Unterminated group");
  }
  return start;
};
lib.exports.types = types$1;
var libExports = lib.exports;
var parse = libExports;
var types = parse.types;
var safeRegex = function(re, opts) {
  if (!opts)
    opts = {};
  var replimit = opts.limit === void 0 ? 25 : opts.limit;
  if (isRegExp(re))
    re = re.source;
  else if (typeof re !== "string")
    re = String(re);
  try {
    re = parse(re);
  } catch (err) {
    return false;
  }
  var reps = 0;
  return function walk(node, starHeight) {
    if (node.type === types.REPETITION) {
      starHeight++;
      reps++;
      if (starHeight > 1)
        return false;
      if (reps > replimit)
        return false;
    }
    if (node.options) {
      for (var i = 0, len = node.options.length; i < len; i++) {
        var ok = walk({ stack: node.options[i] }, starHeight);
        if (!ok)
          return false;
      }
    }
    var stack = node.stack || node.value && node.value.stack;
    if (!stack)
      return true;
    for (var i = 0; i < stack.length; i++) {
      var ok = walk(stack[i], starHeight);
      if (!ok)
        return false;
    }
    return true;
  }(re, 0);
};
function isRegExp(x) {
  return {}.toString.call(x) === "[object RegExp]";
}
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var isobject$1 = function isObject(val) {
  return val != null && typeof val === "object" && Array.isArray(val) === false;
};
var toString$2 = Object.prototype.toString;
var kindOf = function kindOf2(val) {
  if (val === void 0)
    return "undefined";
  if (val === null)
    return "null";
  var type = typeof val;
  if (type === "boolean")
    return "boolean";
  if (type === "string")
    return "string";
  if (type === "number")
    return "number";
  if (type === "symbol")
    return "symbol";
  if (type === "function") {
    return isGeneratorFn(val) ? "generatorfunction" : "function";
  }
  if (isArray$1(val))
    return "array";
  if (isBuffer(val))
    return "buffer";
  if (isArguments$1(val))
    return "arguments";
  if (isDate(val))
    return "date";
  if (isError(val))
    return "error";
  if (isRegexp(val))
    return "regexp";
  switch (ctorName(val)) {
    case "Symbol":
      return "symbol";
    case "Promise":
      return "promise";
    case "WeakMap":
      return "weakmap";
    case "WeakSet":
      return "weakset";
    case "Map":
      return "map";
    case "Set":
      return "set";
    case "Int8Array":
      return "int8array";
    case "Uint8Array":
      return "uint8array";
    case "Uint8ClampedArray":
      return "uint8clampedarray";
    case "Int16Array":
      return "int16array";
    case "Uint16Array":
      return "uint16array";
    case "Int32Array":
      return "int32array";
    case "Uint32Array":
      return "uint32array";
    case "Float32Array":
      return "float32array";
    case "Float64Array":
      return "float64array";
  }
  if (isGeneratorObj(val)) {
    return "generator";
  }
  type = toString$2.call(val);
  switch (type) {
    case "[object Object]":
      return "object";
    case "[object Map Iterator]":
      return "mapiterator";
    case "[object Set Iterator]":
      return "setiterator";
    case "[object String Iterator]":
      return "stringiterator";
    case "[object Array Iterator]":
      return "arrayiterator";
  }
  return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
};
function ctorName(val) {
  return typeof val.constructor === "function" ? val.constructor.name : null;
}
function isArray$1(val) {
  if (Array.isArray)
    return Array.isArray(val);
  return val instanceof Array;
}
function isError(val) {
  return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
}
function isDate(val) {
  if (val instanceof Date)
    return true;
  return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
}
function isRegexp(val) {
  if (val instanceof RegExp)
    return true;
  return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
}
function isGeneratorFn(name2, val) {
  return ctorName(name2) === "GeneratorFunction";
}
function isGeneratorObj(val) {
  return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
}
function isArguments$1(val) {
  try {
    if (typeof val.length === "number" && typeof val.callee === "function") {
      return true;
    }
  } catch (err) {
    if (err.message.indexOf("callee") !== -1) {
      return true;
    }
  }
  return false;
}
function isBuffer(val) {
  if (val.constructor && typeof val.constructor.isBuffer === "function") {
    return val.constructor.isBuffer(val);
  }
  return false;
}
/*!
 * is-accessor-descriptor <https://github.com/jonschlinkert/is-accessor-descriptor>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var typeOf$2 = kindOf;
var accessor = {
  get: "function",
  set: "function",
  configurable: "boolean",
  enumerable: "boolean"
};
function isAccessorDescriptor(obj, prop) {
  if (typeof prop === "string") {
    var val = Object.getOwnPropertyDescriptor(obj, prop);
    return typeof val !== "undefined";
  }
  if (typeOf$2(obj) !== "object") {
    return false;
  }
  if (has$1(obj, "value") || has$1(obj, "writable")) {
    return false;
  }
  if (!has$1(obj, "get") || typeof obj.get !== "function") {
    return false;
  }
  if (has$1(obj, "set") && typeof obj[key] !== "function" && typeof obj[key] !== "undefined") {
    return false;
  }
  for (var key in obj) {
    if (!accessor.hasOwnProperty(key)) {
      continue;
    }
    if (typeOf$2(obj[key]) === accessor[key]) {
      continue;
    }
    if (typeof obj[key] !== "undefined") {
      return false;
    }
  }
  return true;
}
function has$1(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}
var isAccessorDescriptor_1 = isAccessorDescriptor;
/*!
 * is-data-descriptor <https://github.com/jonschlinkert/is-data-descriptor>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var typeOf$1 = kindOf;
var isDataDescriptor = function isDataDescriptor2(obj, prop) {
  var data2 = {
    configurable: "boolean",
    enumerable: "boolean",
    writable: "boolean"
  };
  if (typeOf$1(obj) !== "object") {
    return false;
  }
  if (typeof prop === "string") {
    var val = Object.getOwnPropertyDescriptor(obj, prop);
    return typeof val !== "undefined";
  }
  if (!("value" in obj) && !("writable" in obj)) {
    return false;
  }
  for (var key in obj) {
    if (key === "value")
      continue;
    if (!data2.hasOwnProperty(key)) {
      continue;
    }
    if (typeOf$1(obj[key]) === data2[key]) {
      continue;
    }
    if (typeof obj[key] !== "undefined") {
      return false;
    }
  }
  return true;
};
/*!
 * is-descriptor <https://github.com/jonschlinkert/is-descriptor>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var typeOf = kindOf;
var isAccessor = isAccessorDescriptor_1;
var isData = isDataDescriptor;
var isDescriptor$1 = function isDescriptor(obj, key) {
  if (typeOf(obj) !== "object") {
    return false;
  }
  if ("get" in obj) {
    return isAccessor(obj, key);
  }
  return isData(obj, key);
};
/*!
 * define-property <https://github.com/jonschlinkert/define-property>
 *
 * Copyright (c) 2015-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
var isobject = isobject$1;
var isDescriptor2 = isDescriptor$1;
var define$k = typeof Reflect !== "undefined" && Reflect.defineProperty ? Reflect.defineProperty : Object.defineProperty;
var defineProperty = function defineProperty2(obj, key, val) {
  if (!isobject(obj) && typeof obj !== "function" && !Array.isArray(obj)) {
    throw new TypeError("expected an object, function, or array");
  }
  if (typeof key !== "string") {
    throw new TypeError('expected "key" to be a string');
  }
  if (isDescriptor2(val)) {
    define$k(obj, key, val);
    return obj;
  }
  define$k(obj, key, {
    configurable: true,
    enumerable: false,
    writable: true,
    value: val
  });
  return obj;
};
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var isObject$3 = isobject$1;
function isObjectObject(o) {
  return isObject$3(o) === true && Object.prototype.toString.call(o) === "[object Object]";
}
var isPlainObject$1 = function isPlainObject(o) {
  var ctor, prot;
  if (isObjectObject(o) === false)
    return false;
  ctor = o.constructor;
  if (typeof ctor !== "function")
    return false;
  prot = ctor.prototype;
  if (isObjectObject(prot) === false)
    return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
};
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var isPlainObject2 = isPlainObject$1;
var isExtendable$1 = function isExtendable(val) {
  return isPlainObject2(val) || typeof val === "function" || Array.isArray(val);
};
/*!
 * assign-symbols <https://github.com/jonschlinkert/assign-symbols>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var assignSymbols$1 = function(receiver, objects) {
  if (receiver === null || typeof receiver === "undefined") {
    throw new TypeError("expected first argument to be an object.");
  }
  if (typeof objects === "undefined" || typeof Symbol === "undefined") {
    return receiver;
  }
  if (typeof Object.getOwnPropertySymbols !== "function") {
    return receiver;
  }
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var target = Object(receiver);
  var len = arguments.length, i = 0;
  while (++i < len) {
    var provider = Object(arguments[i]);
    var names = Object.getOwnPropertySymbols(provider);
    for (var j = 0; j < names.length; j++) {
      var key = names[j];
      if (isEnumerable.call(provider, key)) {
        target[key] = provider[key];
      }
    }
  }
  return target;
};
var isExtendable2 = isExtendable$1;
var assignSymbols = assignSymbols$1;
var extendShallow = Object.assign || function(obj) {
  if (obj === null || typeof obj === "undefined") {
    throw new TypeError("Cannot convert undefined or null to object");
  }
  if (!isObject$2(obj)) {
    obj = {};
  }
  for (var i = 1; i < arguments.length; i++) {
    var val = arguments[i];
    if (isString$1(val)) {
      val = toObject(val);
    }
    if (isObject$2(val)) {
      assign$2(obj, val);
      assignSymbols(obj, val);
    }
  }
  return obj;
};
function assign$2(a, b) {
  for (var key in b) {
    if (hasOwn(b, key)) {
      a[key] = b[key];
    }
  }
}
function isString$1(val) {
  return val && typeof val === "string";
}
function toObject(str2) {
  var obj = {};
  for (var i in str2) {
    obj[i] = str2[i];
  }
  return obj;
}
function isObject$2(val) {
  return val && typeof val === "object" || isExtendable2(val);
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
var extend$1 = extendShallow;
var safe$1 = safeRegex;
function toRegex(pattern, options) {
  return new RegExp(toRegex.create(pattern, options));
}
toRegex.create = function(pattern, options) {
  if (typeof pattern !== "string") {
    throw new TypeError("expected a string");
  }
  var opts = extend$1({}, options);
  if (opts.contains === true) {
    opts.strictNegate = false;
  }
  var open = opts.strictOpen !== false ? "^" : "";
  var close = opts.strictClose !== false ? "$" : "";
  var endChar = opts.endChar ? opts.endChar : "+";
  var str2 = pattern;
  if (opts.strictNegate === false) {
    str2 = "(?:(?!(?:" + pattern + ")).)" + endChar;
  } else {
    str2 = "(?:(?!^(?:" + pattern + ")$).)" + endChar;
  }
  var res = open + str2 + close;
  if (opts.safe === true && safe$1(res) === false) {
    throw new Error("potentially unsafe regular expression: " + res);
  }
  return res;
};
var regexNot = toRegex;
var safe = safeRegex;
var define$j = defineProperty;
var extend = extendShallow;
var not = regexNot;
var MAX_LENGTH = 1024 * 64;
var cache = {};
toRegex$1.exports = function(patterns, options) {
  if (!Array.isArray(patterns)) {
    return makeRe(patterns, options);
  }
  return makeRe(patterns.join("|"), options);
};
function makeRe(pattern, options) {
  if (pattern instanceof RegExp) {
    return pattern;
  }
  if (typeof pattern !== "string") {
    throw new TypeError("expected a string");
  }
  if (pattern.length > MAX_LENGTH) {
    throw new Error("expected pattern to be less than " + MAX_LENGTH + " characters");
  }
  var key = pattern;
  if (!options || options && options.cache !== false) {
    key = createKey(pattern, options);
    if (cache.hasOwnProperty(key)) {
      return cache[key];
    }
  }
  var opts = extend({}, options);
  if (opts.contains === true) {
    if (opts.negate === true) {
      opts.strictNegate = false;
    } else {
      opts.strict = false;
    }
  }
  if (opts.strict === false) {
    opts.strictOpen = false;
    opts.strictClose = false;
  }
  var open = opts.strictOpen !== false ? "^" : "";
  var close = opts.strictClose !== false ? "$" : "";
  var flags2 = opts.flags || "";
  var regex2;
  if (opts.nocase === true && !/i/.test(flags2)) {
    flags2 += "i";
  }
  try {
    if (opts.negate || typeof opts.strictNegate === "boolean") {
      pattern = not.create(pattern, opts);
    }
    var str2 = open + "(?:" + pattern + ")" + close;
    regex2 = new RegExp(str2, flags2);
    if (opts.safe === true && safe(regex2) === false) {
      throw new Error("potentially unsafe regular expression: " + regex2.source);
    }
  } catch (err) {
    if (opts.strictErrors === true || opts.safe === true) {
      err.key = key;
      err.pattern = pattern;
      err.originalOptions = options;
      err.createdOptions = opts;
      throw err;
    }
    try {
      regex2 = new RegExp("^" + pattern.replace(/(\W)/g, "\\$1") + "$");
    } catch (err2) {
      regex2 = /.^/;
    }
  }
  if (opts.cache !== false) {
    memoize(regex2, key, pattern, opts);
  }
  return regex2;
}
function memoize(regex2, key, pattern, options) {
  define$j(regex2, "cached", true);
  define$j(regex2, "pattern", pattern);
  define$j(regex2, "options", options);
  define$j(regex2, "key", key);
  cache[key] = regex2;
}
function createKey(pattern, options) {
  if (!options)
    return pattern;
  var key = pattern;
  for (var prop in options) {
    if (options.hasOwnProperty(prop)) {
      key += ";" + prop + "=" + String(options[prop]);
    }
  }
  return key;
}
toRegex$1.exports.makeRe = makeRe;
function format$1(string, format2) {
  var _a2;
  let schema = [];
  switch (format2) {
    case "isoDate":
      schema = [
        "\\d",
        "\\d",
        "\\d",
        "\\d",
        "-",
        "\\d",
        "\\d",
        "-",
        "\\d",
        "\\d"
      ];
      break;
    case "isoDateTime":
      schema = [
        "\\d",
        "\\d",
        "\\d",
        "\\d",
        "-",
        "\\d",
        "\\d",
        "-",
        "\\d",
        "\\d",
        " ",
        "\\d",
        "\\d",
        ":",
        "\\d",
        "\\d",
        ":",
        "\\d",
        "\\d"
      ];
      break;
    case "isoTime":
      schema = ["\\d", "\\d", ":", "\\d", "\\d", ":", "\\d", "\\d"];
      break;
    case "hex":
      schema = ["#", "\\w", "\\w", "\\w", "\\w", "\\w", "\\w"];
      break;
    case "hexa":
      schema = [
        "#",
        "\\w",
        "\\w",
        "\\w",
        "\\w",
        "\\w",
        "\\w",
        "\\w",
        "\\w"
      ];
      break;
    case "integer":
      return string.replace(/^[0-9]+$/i, "");
    case "number":
      return string.replace(/^[0-9\.]+$/i, "");
    case "alphanum":
      return string.replace(/^[a-z0-9]+$/i, "");
    case "creditCard":
      schema = [
        "\\d",
        "\\d",
        "\\d",
        "\\d",
        " ",
        "\\d",
        "\\d",
        "\\d",
        "\\d",
        " ",
        "\\d",
        "\\d",
        "\\d",
        "\\d",
        " ",
        "\\d",
        "\\d",
        "\\d",
        "\\d"
      ];
      break;
    default:
      return string;
  }
  let newValue = "";
  const loopOn = string.length > schema.length ? string : schema;
  let schemaCharI = 0;
  for (let i = 0; i < loopOn.length; i++) {
    const schemaChar = schema[schemaCharI], char = (_a2 = string[i]) !== null && _a2 !== void 0 ? _a2 : "";
    if (!schemaChar || !char || i >= string.length) {
      break;
    }
    if (schemaChar === char) {
      newValue += char;
      schemaCharI++;
    } else if (schemaChar.match(/^\\d/)) {
      if (char.match(/^\d$/)) {
        newValue += char;
        schemaCharI++;
      }
    } else if (schemaChar.match(/^\\w/)) {
      if (char.match(/^\w$/)) {
        newValue += char;
        schemaCharI++;
      }
    } else if (schemaChar !== char) {
      newValue += schemaChar;
      i--;
      schemaCharI++;
    } else
      ;
  }
  return newValue;
}
format$1.formats = [
  "isoDate",
  "isoDateTime",
  "isoTime",
  "integer",
  "number",
  "alphanum",
  "hex",
  "hexa",
  "creditCard"
];
function __ltrim(string, needle, trimResult = true) {
  if (string.substr(0, needle.length) === needle) {
    return trimResult ? string.substr(needle.length).trim() : string.substr(needle.length);
  }
  return string;
}
var sprintf = {};
(function(exports) {
  !function() {
    var re = {
      not_string: /[^s]/,
      not_bool: /[^t]/,
      not_type: /[^T]/,
      not_primitive: /[^v]/,
      number: /[diefg]/,
      numeric_arg: /[bcdiefguxX]/,
      json: /[j]/,
      not_json: /[^j]/,
      text: /^[^\x25]+/,
      modulo: /^\x25{2}/,
      placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
      key: /^([a-z_][a-z_\d]*)/i,
      key_access: /^\.([a-z_][a-z_\d]*)/i,
      index_access: /^\[(\d+)\]/,
      sign: /^[+-]/
    };
    function sprintf2(key) {
      return sprintf_format(sprintf_parse(key), arguments);
    }
    function vsprintf(fmt, argv) {
      return sprintf2.apply(null, [fmt].concat(argv || []));
    }
    function sprintf_format(parse_tree, argv) {
      var cursor = 1, tree_length = parse_tree.length, arg, output = "", i, k, ph, pad2, pad_character, pad_length, is_positive, sign2;
      for (i = 0; i < tree_length; i++) {
        if (typeof parse_tree[i] === "string") {
          output += parse_tree[i];
        } else if (typeof parse_tree[i] === "object") {
          ph = parse_tree[i];
          if (ph.keys) {
            arg = argv[cursor];
            for (k = 0; k < ph.keys.length; k++) {
              if (arg == void 0) {
                throw new Error(sprintf2('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
              }
              arg = arg[ph.keys[k]];
            }
          } else if (ph.param_no) {
            arg = argv[ph.param_no];
          } else {
            arg = argv[cursor++];
          }
          if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
            arg = arg();
          }
          if (re.numeric_arg.test(ph.type) && (typeof arg !== "number" && isNaN(arg))) {
            throw new TypeError(sprintf2("[sprintf] expecting number but found %T", arg));
          }
          if (re.number.test(ph.type)) {
            is_positive = arg >= 0;
          }
          switch (ph.type) {
            case "b":
              arg = parseInt(arg, 10).toString(2);
              break;
            case "c":
              arg = String.fromCharCode(parseInt(arg, 10));
              break;
            case "d":
            case "i":
              arg = parseInt(arg, 10);
              break;
            case "j":
              arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
              break;
            case "e":
              arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
              break;
            case "f":
              arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
              break;
            case "g":
              arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
              break;
            case "o":
              arg = (parseInt(arg, 10) >>> 0).toString(8);
              break;
            case "s":
              arg = String(arg);
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "t":
              arg = String(!!arg);
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "T":
              arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "u":
              arg = parseInt(arg, 10) >>> 0;
              break;
            case "v":
              arg = arg.valueOf();
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "x":
              arg = (parseInt(arg, 10) >>> 0).toString(16);
              break;
            case "X":
              arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
              break;
          }
          if (re.json.test(ph.type)) {
            output += arg;
          } else {
            if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
              sign2 = is_positive ? "+" : "-";
              arg = arg.toString().replace(re.sign, "");
            } else {
              sign2 = "";
            }
            pad_character = ph.pad_char ? ph.pad_char === "0" ? "0" : ph.pad_char.charAt(1) : " ";
            pad_length = ph.width - (sign2 + arg).length;
            pad2 = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
            output += ph.align ? sign2 + arg + pad2 : pad_character === "0" ? sign2 + pad2 + arg : pad2 + sign2 + arg;
          }
        }
      }
      return output;
    }
    var sprintf_cache = /* @__PURE__ */ Object.create(null);
    function sprintf_parse(fmt) {
      if (sprintf_cache[fmt]) {
        return sprintf_cache[fmt];
      }
      var _fmt = fmt, match2, parse_tree = [], arg_names = 0;
      while (_fmt) {
        if ((match2 = re.text.exec(_fmt)) !== null) {
          parse_tree.push(match2[0]);
        } else if ((match2 = re.modulo.exec(_fmt)) !== null) {
          parse_tree.push("%");
        } else if ((match2 = re.placeholder.exec(_fmt)) !== null) {
          if (match2[2]) {
            arg_names |= 1;
            var field_list = [], replacement_field = match2[2], field_match = [];
            if ((field_match = re.key.exec(replacement_field)) !== null) {
              field_list.push(field_match[1]);
              while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                } else {
                  throw new SyntaxError("[sprintf] failed to parse named argument key");
                }
              }
            } else {
              throw new SyntaxError("[sprintf] failed to parse named argument key");
            }
            match2[2] = field_list;
          } else {
            arg_names |= 2;
          }
          if (arg_names === 3) {
            throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
          }
          parse_tree.push(
            {
              placeholder: match2[0],
              param_no: match2[1],
              keys: match2[2],
              sign: match2[3],
              pad_char: match2[4],
              align: match2[5],
              width: match2[6],
              precision: match2[7],
              type: match2[8]
            }
          );
        } else {
          throw new SyntaxError("[sprintf] unexpected placeholder");
        }
        _fmt = _fmt.substring(match2[0].length);
      }
      return sprintf_cache[fmt] = parse_tree;
    }
    {
      exports["sprintf"] = sprintf2;
      exports["vsprintf"] = vsprintf;
    }
    if (typeof window !== "undefined") {
      window["sprintf"] = sprintf2;
      window["vsprintf"] = vsprintf;
    }
  }();
})(sprintf);
function __snakeCase(text) {
  const dashCase = __dashCase(text);
  return dashCase.replace(/\-/g, "_");
}
function __upperFirst(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
function __replaceChunks(string, chunks, replacer) {
  const reg = new RegExp(chunks.join("|"), "gi");
  return string.replace(reg, (str2) => {
    return replacer(str2);
  });
}
var globToRegexp = function(glob, opts) {
  if (typeof glob !== "string") {
    throw new TypeError("Expected a string");
  }
  var str2 = String(glob);
  var reStr = "";
  var extended = opts ? !!opts.extended : false;
  var globstar = opts ? !!opts.globstar : false;
  var inGroup = false;
  var flags2 = opts && typeof opts.flags === "string" ? opts.flags : "";
  var c;
  for (var i = 0, len = str2.length; i < len; i++) {
    c = str2[i];
    switch (c) {
      case "/":
      case "$":
      case "^":
      case "+":
      case ".":
      case "(":
      case ")":
      case "=":
      case "!":
      case "|":
        reStr += "\\" + c;
        break;
      case "?":
        if (extended) {
          reStr += ".";
          break;
        }
      case "[":
      case "]":
        if (extended) {
          reStr += c;
          break;
        }
      case "{":
        if (extended) {
          inGroup = true;
          reStr += "(";
          break;
        }
      case "}":
        if (extended) {
          inGroup = false;
          reStr += ")";
          break;
        }
      case ",":
        if (inGroup) {
          reStr += "|";
          break;
        }
        reStr += "\\" + c;
        break;
      case "*":
        var prevChar = str2[i - 1];
        var starCount = 1;
        while (str2[i + 1] === "*") {
          starCount++;
          i++;
        }
        var nextChar = str2[i + 1];
        if (!globstar) {
          reStr += ".*";
        } else {
          var isGlobstar = starCount > 1 && (prevChar === "/" || prevChar === void 0) && (nextChar === "/" || nextChar === void 0);
          if (isGlobstar) {
            reStr += "((?:[^/]*(?:/|$))*)";
            i++;
          } else {
            reStr += "([^/]*)";
          }
        }
        break;
      default:
        reStr += c;
    }
  }
  if (!flags2 || !~flags2.indexOf("g")) {
    reStr = "^" + reStr + "$";
  }
  return new RegExp(reStr, flags2);
};
const __globToRegex = /* @__PURE__ */ getDefaultExportFromCjs(globToRegexp);
var __awaiter$y = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
let SEventEmitter$1 = class SEventEmitter extends SClass {
  static get global() {
    if (!SEventEmitter._globalInstance) {
      SEventEmitter._globalInstance = new SEventEmitter({
        metas: {
          id: "sugarEventSPromise"
        }
      });
    }
    return SEventEmitter._globalInstance;
  }
  /**
   * @name                  pipe
   * @type                  Function
   * @static
   *
   * This static function allows you to redirect some SEventEmitter "events" to another SEventEmitter instance
   * with the ability to process the linked value before emiting it on the destination SEventEmitter.
   *
   * @param         {SEventEmitter}      sourceSEventEmitter        The source SEventEmitter instance on which to listen for "events"
   * @param         {SEventEmitter}      destSEventEmitter          The destination SEventEmitter instance on which to emit the listened "events"
   * @param         {Object}        [settings={}]         An object of settings to configure your pipe process
   * - stacks (*) {String}: Specify which stacks you want to pipe. By default it's all using the "*" character
   * - processor (null) {Function}: Specify a function to apply on the emited value before emiting it on the dest SEventEmitter. Take as arguments the value itself and the stack name. Need to return a new value
   * - filter (null) {Function}: Specify a function to filter the "events". It will take as parameter the emited value and the metas object. You must return true or false depending if you want to pipe the particular event or not
   *
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  static pipe(sourceSEventEmitter, destSEventEmitter, settings) {
    const set2 = Object.assign({ events: "*", overrideEmitter: false, processor: void 0, exclude: ["finally", "resolve", "reject", "cancel", "catch"], filter: void 0 }, settings !== null && settings !== void 0 ? settings : {});
    if (!sourceSEventEmitter || !sourceSEventEmitter.on || typeof sourceSEventEmitter.on !== "function") {
      return sourceSEventEmitter;
    }
    sourceSEventEmitter.on(set2.events || "*", (value, metas) => __awaiter$y(this, void 0, void 0, function* () {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
      if (!metas || !value) {
        return;
      }
      metas.id = (_c2 = (_a2 = metas.id) !== null && _a2 !== void 0 ? _a2 : (_b2 = metas.emitter.metas) === null || _b2 === void 0 ? void 0 : _b2.id) !== null && _c2 !== void 0 ? _c2 : __uniqid();
      metas.color = (_f2 = (_d2 = metas.color) !== null && _d2 !== void 0 ? _d2 : (_e2 = metas.emitter.metas) === null || _e2 === void 0 ? void 0 : _e2.color) !== null && _f2 !== void 0 ? _f2 : getColorFor(metas.id);
      if (set2.exclude && set2.exclude.indexOf(metas.event) !== -1)
        return;
      if (set2.filter && !set2.filter(value, metas))
        return;
      if (set2.processor) {
        const res = set2.processor(value, metas);
        if (Array.isArray(res) && res.length === 2) {
          value = res[0];
          metas = res[1];
        } else if (typeof res === "object" && res.value !== void 0 && res.metas !== void 0) {
          value = res.value;
          metas = res.metas;
        } else {
          value = res;
        }
      }
      if (metas && metas.event) {
        metas.event;
        if (!metas.emitter) {
          metas.emitter = this;
        }
        const emitMetas = Object.assign(Object.assign({}, metas), { level: ((_g2 = metas === null || metas === void 0 ? void 0 : metas.level) !== null && _g2 !== void 0 ? _g2 : 0) + 1 });
        if (destSEventEmitter instanceof SEventEmitter) {
          if (!set2.overrideEmitter && destSEventEmitter.settings.bind) {
            emitMetas.emitter = destSEventEmitter.settings.bind;
          } else if (set2.overrideEmitter === true) {
            emitMetas.emitter = destSEventEmitter;
          }
        }
        if (__isNode$2() && destSEventEmitter === process && __isChildProcess()) {
          if (value.value && value.value instanceof Error) {
            value.value = fn$5(value.value);
          }
          if (!this._ipcInstance._pipedEventsUids) {
            this._ipcInstance._pipedEventsUids = [];
          }
          if (this._ipcInstance && !this._ipcInstance._pipedEventsUids.includes(emitMetas.uid)) {
            this._ipcInstance._pipedEventsUids.push(emitMetas.uid);
            this._ipcInstance.of[`ipc-${process.ppid}`].emit("message", {
              value,
              metas: emitMetas
            });
          }
        } else {
          destSEventEmitter.emit(metas.event, value, emitMetas);
        }
      }
    }));
  }
  /**
   * @name                  constructor
   * @type                  Function
   *
   * Constructor
   *
   * @param         {Object}            [settings={}]     An object of settings for this particular SEventEmitter instance. Here's the available settings:
   *
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  constructor(settings) {
    super(__deepMerge({
      asyncStart: false,
      bufferTimeout: 1e3,
      defaults: {},
      castByEvent: {
        log: SLog
      },
      bind: void 0
    }, settings !== null && settings !== void 0 ? settings : {}));
    this._asyncStarted = false;
    this._buffer = [];
    this._eventsStacks = {};
    this._onStackById = {};
  }
  /**
   * @name          bind
   * @type      Function
   *
   * This method allows you to bind another object as the emitter.
   *
   * @since       2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  bind(obj) {
    this.settings.bind = obj;
    return this;
  }
  /**
   * @name          pipe
   * @type          Function
   *
   * This method take an SEventEmitter instance as parameter on which to pipe the
   * specified stacks using the settings.stacks property.
   * It is exactly the same as the static ```pipe``` method but for this
   * particular instance.
   *
   * @param       {SEventEmitter}      input      The input promise on which to pipe the events in this one
   * @param       {ISEventEmitterPipeSettings}      [settings={}]    An object ob settings to configure the pipe process:
   *
   * @since       2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  pipe(input, settings) {
    SEventEmitter.pipe(input, this, settings);
    return input;
  }
  /**
   * @name          pipeErrors
   * @type          Function
   *
   * This is the exact same as the original ```pipe``` method. It's just pipe only the errors.
   *
   * @param       {SEventEmitter}      input      The input promise on which to pipe the events in this one
   * @param       {ISEventEmitterPipeSettings}      [settings={}]    An object ob settings to configure the pipe process:
   *
   * @since       2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  pipeErrors(input, settings) {
    SEventEmitter.pipe(input, this, Object.assign(Object.assign({}, settings), { events: "error" }));
    return input;
  }
  /**
   * @name      pipeFrom
   * @type      Function
   *
   * This is the exacte same as the original ```pipe``` method. It's just an aliasw.
   *
   * @since     2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  pipeFrom(input, settings) {
    return this.pipe(input, settings);
  }
  /**
   * @name          pipe
   * @type          Function
   *
   * This method is the same as the ```pipe```and ```pipeFrom``` one but it's just act as the inverse.
   * Here you specify whenre you want to pipe this instance events and not from which you want to pipe them here...
   *
   * @param       {SEventEmitter}      dest      The destination event emitter on which to pipe the events from this one
   * @param       {ISEventEmitterPipeSettings}      [settings={}]    An object ob settings to configure the pipe process:
   *
   * @since       2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  pipeTo(dest, settings) {
    SEventEmitter.pipe(this, dest, settings);
    return this;
  }
  /**
   * @name          start
   * @type          Function
   *
   * This method has to be called when you want to start the event emissions.
   * This is usefull only if you set the setting ```asyncStart``` to true.
   * Untill you call this method, all the emitted events
   * are store in memory and emitted after.
   *
   * @since         2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  start() {
    if (!this.settings.asyncStart)
      return;
    this._asyncStarted = true;
    this._processBuffer();
  }
  /**
   * @name          emit
   * @type          Function
   * @async
   *
   * This is the method that allows you to emit the callbacks like "catch", "finally", etc... without actually resolving the Promise itself
   *
   * @param         {String|Array}        event            The event that you want to emit. You can emit multiple events by passing an Array like ['catch','finally'], or a string like "catch,finally"
   * @param         {Mixed}         value         The value you want to pass to the callback
   * @return        {ISEventEmitter}                       The SEventEmitter instance to maintain chainability
   *
   * @example         js
   *
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  _createMetas(event, metas = {}) {
    var _a2, _b2, _c2;
    return __deepMerge({
      event,
      name: event,
      emitter: (_b2 = (_a2 = this.settings.bind) !== null && _a2 !== void 0 ? _a2 : metas === null || metas === void 0 ? void 0 : metas.emitter) !== null && _b2 !== void 0 ? _b2 : this,
      originalEmitter: (_c2 = metas === null || metas === void 0 ? void 0 : metas.originalEmitter) !== null && _c2 !== void 0 ? _c2 : this,
      time: Date.now(),
      level: 0
    }, metas !== null && metas !== void 0 ? metas : {});
  }
  emit(event, value, metas) {
    return new Promise((resolve2, reject) => __awaiter$y(this, void 0, void 0, function* () {
      let metasObj = this._createMetas(event, metas);
      const isFirstLevel = !metasObj.level;
      if (__isPlainObject(value)) {
        Object.keys(this.settings.defaults).forEach((key) => {
          var _a2;
          const parts = key.split(",").map((l) => l.trim());
          if (parts.indexOf(event) === -1 && parts.indexOf("*") === -1)
            return;
          value = __deepMerge(value, (_a2 = this.settings.defaults) === null || _a2 === void 0 ? void 0 : _a2[key]);
        });
      }
      const CastClass = this.settings.castByEvent[event];
      if (CastClass && isClass(CastClass) && !(value instanceof CastClass) && !value._sEventEmitterPreprocessed) {
        value = new CastClass(value);
      }
      if (event === "ask") {
        if (isFirstLevel) {
          metasObj.askId = __uniqid();
        }
      }
      if (!this._asyncStarted && this.settings.asyncStart) {
        this._buffer.push({
          event,
          value,
          metas: metasObj,
          resolve: resolve2,
          reject
        });
        return;
      }
      this._emit({
        event,
        value,
        metas: metasObj,
        resolve: resolve2,
        reject
      });
    }));
  }
  _emit(logObj) {
    return __awaiter$y(this, void 0, void 0, function* () {
      logObj.metas.uid = __uniqid();
      if (logObj.event === "ask") {
        this.constructor.global.on(`answer.${logObj.metas.askId}`, (answer, metas) => {
          logObj.resolve(answer);
        });
        this._emitEvents(logObj.event, logObj.value, Object.assign({}, logObj.metas));
      } else {
        const res = yield this._emitEvents(logObj.event, logObj.value, Object.assign({}, logObj.metas));
        logObj.resolve(res);
      }
    });
  }
  /**
   * @name            _registerNewEventsStacks
   * @type            Function
   * @private
   *
   * This methods allows you to register new stacks.
   * A new stack can be called then using the "on('stackName', ...)" method,
   * or directly on the SEventEmitter instance like so "myPromise.stackName(...)".
   *
   * @param       {String|Array}      stacks        The stack(s) name(s) you want to register. Can be an Array or a comma separated string
   * @return      {SEventEmitter}                        The SEventEmitter instance
   *
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  _registerNewEventsStacks(events) {
    if (typeof events === "string")
      events = events.split(",").map((s) => s.trim());
    events.forEach((event) => {
      if (!this._eventsStacks[event]) {
        this._eventsStacks[event] = {
          buffer: [],
          callStack: []
        };
      }
    });
  }
  /**
   * @name            _registerCallbackInEventStack
   * @type            Function
   *
   * This function take as argument a stack array and register into it the passed callback function
   *
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  _registerCallbackInEventStack(event, callback, settings = {}) {
    settings = Object.assign({ callNumber: void 0, filter: void 0, processor: void 0, id: void 0 }, settings);
    if (settings.id) {
      if (!this._onStackById[settings.id])
        this._onStackById[settings.id] = [];
      this._onStackById[settings.id].push({
        event,
        callback,
        settings
      });
    }
    if (!this._eventsStacks[event]) {
      this._registerNewEventsStacks(event);
    }
    const eventStackObj = this._eventsStacks[event];
    let callNumber = settings.callNumber;
    if (callNumber === void 0) {
      callNumber = -1;
    }
    if (typeof callback === "function")
      eventStackObj.callStack.push({
        callback,
        callNumber,
        filter: settings.filter,
        processor: settings.processor,
        called: 0
      });
    this._processBuffer();
    return this;
  }
  /**
   * @name          _processBuffer
   * @type          Function
   * @private
   *
   * This method simply take care of empty the buffer by emitting
   * all the buffered events
   *
   * @since         2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  _processBuffer() {
    if (this._buffer.length > 0) {
      setTimeout(() => {
        this._buffer = this._buffer.filter((item) => {
          this._emit(item);
          return false;
        });
      }, this.settings.bufferTimeout);
    }
  }
  /**
   * @name            _emitEventStack
   * @type            Function
   * @private
   * @async
   *
   * This function take an Array Stack as parameter and execute it to return the result
   *
   * @param         {String}             event             The event to execute
   * @param         {Mixed}             initialValue      The initial value to pass to the first stack callback
   * @return        {Promise}                             A promise resolved with the stack result
   *
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  _emitEventStack(event, initialValue, metasObj) {
    return __awaiter$y(this, void 0, void 0, function* () {
      let currentCallbackReturnedValue = initialValue;
      if (!this._eventsStacks || Object.keys(this._eventsStacks).length === 0)
        return currentCallbackReturnedValue;
      if (!this._eventsStacks[event]) {
        this._registerNewEventsStacks(event);
      }
      let eventStackArray = [];
      const eventStackObj = this._eventsStacks[event];
      if (eventStackObj && eventStackObj.callStack) {
        eventStackArray = [
          ...eventStackArray,
          ...eventStackObj.callStack
        ];
      }
      Object.keys(this._eventsStacks).forEach((stackName) => {
        if (stackName === event)
          return currentCallbackReturnedValue;
        if (__globToRegex(stackName).test(event) && this._eventsStacks[stackName] !== void 0) {
          eventStackArray = [
            ...eventStackArray,
            ...this._eventsStacks[stackName].callStack
          ];
        }
      });
      eventStackArray.map((item) => item.called++);
      eventStackArray = eventStackArray.filter((item) => {
        if (item.callNumber === -1)
          return true;
        if (item.called <= item.callNumber)
          return true;
        return false;
      });
      for (let i = 0; i < eventStackArray.length; i++) {
        const item = eventStackArray[i];
        if (!item.callback)
          return currentCallbackReturnedValue;
        if (item.filter && !item.filter(currentCallbackReturnedValue, metasObj))
          continue;
        if (item.processor) {
          const res = item.processor(currentCallbackReturnedValue, metasObj);
          if (Array.isArray(res) && res.length === 2) {
            currentCallbackReturnedValue = res[0];
            metasObj = res[1];
          } else if (typeof res === "object" && res.value !== void 0 && res.metas !== void 0) {
            currentCallbackReturnedValue = res.value;
            metasObj = res.metas;
          } else {
            currentCallbackReturnedValue = res;
          }
        }
        const callbackResult = yield item.callback(currentCallbackReturnedValue, metasObj, (metasObj === null || metasObj === void 0 ? void 0 : metasObj.askId) ? (answer) => {
          this.constructor.global.emit(`answer.${metasObj.askId}`, answer, metasObj);
        } : void 0);
        if (callbackResult !== void 0) {
          currentCallbackReturnedValue = callbackResult;
        }
      }
      return currentCallbackReturnedValue;
    });
  }
  /**
   * @name          _emitEvents
   * @type          Function
   * @private
   * @async
   *
   * This function take as parameters a list of events to emit like an Array ['catch','finnaly'], or a string like so "catch,finally", and as second parameter,
   * the initial value to pass to the first callback of the joined stacks...
   *
   * @param         {Array|String}            stacks          The stacks to emit
   * @param         {Mixed}                   initialValue    The initial value to pass to the first stack callback
   * @return        {Promise}                                 A promise that will be resolved with the stacks resulting value
   *
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  _emitEvents(events, initialValue, metas) {
    return new Promise((resolve2, reject) => __awaiter$y(this, void 0, void 0, function* () {
      if (!events)
        return this;
      if (typeof events === "string")
        events = events.split(",").map((s) => s.trim());
      let currentStackResult = initialValue;
      for (let i = 0; i < events.length; i++) {
        const stackResult = yield this._emitEventStack(events[i], currentStackResult, metas);
        if (stackResult !== void 0) {
          currentStackResult = stackResult;
        }
      }
      resolve2(currentStackResult);
    }));
  }
  /**
   * @name                on
   * @type                Function
   *
   * This method allows the SEventEmitter user to register a function that will be called every time the "resolve" one is called in the executor
   * The context of the callback will be the SEventEmitter instance itself so you can call all the methods available like "resolve", "release", "on", etc using
   * the "this.resolve('something')" statusment. In an arrow function like "(value) => { ... }", the "this" keyword will be bound to the current context where you define
   * your function. You can access to the SEventEmitter instance through the last parameter like so "(value, SEventEmitterInstance) => { ... }".
   *
   * @param           {String|Array}      stacks        The stacks in which you want register your callback. Either an Array like ['catch','finally'], or a String like "catch,finally"
   * @param           {Function}        callback        The callback function to register
   * @return          {SEventEmitter}                  The SEventEmitter instance to maintain chainability
   *
   * @example         js
   *
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  on(events, callback, settings) {
    const set2 = __deepMerge({
      filter: void 0,
      processor: void 0,
      id: void 0
    }, settings);
    if (typeof events === "string")
      events = events.split(",").map((s) => s.trim());
    events.forEach((name2) => {
      const splitedName = name2.split(":");
      let callNumber = -1;
      if (splitedName.length === 2) {
        name2 = splitedName[0];
        callNumber = parseInt(splitedName[1]);
      }
      this._registerCallbackInEventStack(name2, callback, {
        callNumber,
        filter: set2.filter,
        processor: set2.processor,
        id: set2.id
      });
    });
    return this;
  }
  /**
   * @name            off
   * @type            Function
   *
   * This method allows you to unsubscribe to an event by passing the event name an optionally the callback function.
   * If you don't pass the callback function, all the subscribed events the same as the passed one will be unsubscribed.
   *
   * @param       {String}        event        The event name to unsubscribe to. It can be also an "on" method passed setting "id". In this case, it will unsubscribe all the created subscription(s) in this particular "on" call.
   * @param       {Function}    [callback=null]     The callback function you want to unsubscribe
   * @return      {SEventEmitter}                The SEventEmitter instance to maintain chainability
   *
   * @since     2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  off(event, callback) {
    if (!callback) {
      if (this._eventsStacks[event]) {
        delete this._eventsStacks[event];
      } else if (this._onStackById[event]) {
        this._onStackById[event].forEach((onStackByIdObj) => {
          this.off(onStackByIdObj.event, onStackByIdObj.callback);
        });
        delete this._onStackById[event];
      }
      return this;
    }
    const eventStackObj = this._eventsStacks[event];
    if (!eventStackObj)
      return this;
    eventStackObj.callStack = eventStackObj.callStack.filter((item) => {
      if (item.callback === callback)
        return false;
      return true;
    });
    this._eventsStacks[event] = eventStackObj;
    return this;
  }
  /**
   * @name                      destroy
   * @type                      Function
   *
   * Destroying the SEventEmitter instance by unregister all the callbacks, etc...
   *
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  destroy() {
    this._eventsStacks = {};
  }
};
SEventEmitter$1.usableAsMixin = true;
class SEventEmitter2 extends SEventEmitter$1 {
}
var src = {};
var config = {};
const name = "clone-class";
const version$1 = "0.6.20";
const description = "Clone an ES6 Class as Another Class Name for Isolating Class Static Properties.";
const main = "src/index.js";
const typings = "src/index.d.ts";
const scripts = {
  clean: "shx rm -fr dist/*",
  dist: "npm run clean && tsc && shx cp {README.md,package.json} dist/",
  pack: "npm pack dist/",
  example: "ts-node examples/example.ts",
  lint: "npm run lint:ts",
  "lint:ts": "tslint --project tsconfig.json && tsc --noEmit",
  test: "npm run test:unit",
  "test:unit": 'blue-tape -r ts-node/register "src/**/*.spec.ts" "tests/**/*.spec.ts"',
  "test:pack": "bash -x scripts/npm-pack-testing.sh"
};
const repository = {
  type: "git",
  url: "git+https://github.com/huan/clone-class.git"
};
const keywords = [
  "clone",
  "class",
  "es6",
  "static"
];
const author = "Huan LI <zixia@zixia.net>";
const license = "Apache-2.0";
const bugs = {
  url: "https://github.com/huan/clone-class/issues"
};
const homepage = "https://github.com/huan/clone-class#readme";
const devDependencies = {
  "@types/blue-tape": "^0.1.31",
  "@types/node": "^10.0.3",
  "@types/semver": "^5.5.0",
  "blue-tape": "^1.0.0",
  "git-scripts": "^0.2.1",
  semver: "^5.5.0",
  shx: "^0.3.0",
  "ts-node": "^7.0.0",
  tslint: "^5.9.1",
  typescript: "^3.0.3"
};
const git = {
  scripts: {
    "pre-push": "./scripts/pre-push.sh"
  }
};
const publishConfig = {
  access: "public",
  tag: "latest"
};
const require$$0$3 = {
  name,
  version: version$1,
  description,
  main,
  typings,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  git,
  publishConfig
};
Object.defineProperty(config, "__esModule", { value: true });
config.VERSION = require$$0$3.version;
var instanceToClass$1 = {};
Object.defineProperty(instanceToClass$1, "__esModule", { value: true });
function instanceToClass(instance, baseClass) {
  return instance.constructor;
}
instanceToClass$1.instanceToClass = instanceToClass;
instanceToClass$1.default = instanceToClass;
var cloneClass$1 = {};
Object.defineProperty(cloneClass$1, "__esModule", { value: true });
function cloneClass(OriginalClass) {
  for (const staticProperty in OriginalClass) {
    if (/^[A-Z]/.test(staticProperty)) {
      continue;
    }
    if (typeof OriginalClass[staticProperty] === "object") {
      throw new Error("static property initialized to an object with defination is not supported with cloneClass.");
    }
  }
  class AnotherOriginalClass extends OriginalClass {
    constructor(...args) {
      super(...args);
    }
  }
  Reflect.defineProperty(AnotherOriginalClass, "name", {
    value: OriginalClass.name
  });
  return AnotherOriginalClass;
}
cloneClass$1.cloneClass = cloneClass;
cloneClass$1.default = cloneClass;
Object.defineProperty(src, "__esModule", { value: true });
var config_1 = config;
src.VERSION = config_1.VERSION;
var instance_to_class_1 = instanceToClass$1;
src.instanceToClass = instance_to_class_1.instanceToClass;
const clone_class_1 = cloneClass$1;
src.cloneClass = clone_class_1.cloneClass;
src.default = clone_class_1.cloneClass;
const fn$4 = function(cls, settings = {}) {
  const stack = {};
  if (!isClass(cls)) {
    cls = cls.constructor;
  }
  if (settings.includeBaseClass === true) {
    stack[cls.name] = cls;
  }
  let baseClass = cls;
  while (baseClass) {
    const newBaseClass = Object.getPrototypeOf(baseClass);
    if (newBaseClass && newBaseClass !== Object && newBaseClass.name) {
      stack[newBaseClass.name] = newBaseClass;
      baseClass = newBaseClass;
    } else {
      break;
    }
  }
  return stack;
};
function __getMethods(toCheck) {
  let props = [];
  let obj = toCheck;
  do {
    const _props = Object.getOwnPropertyNames(obj);
    if (_props.indexOf("__defineGetter__") !== -1)
      continue;
    props = props.concat(_props);
  } while (obj = Object.getPrototypeOf(obj));
  return props.sort().filter(function(e, i, arr) {
    if (e != arr[i + 1] && typeof toCheck[e] == "function")
      return true;
  });
}
var dist = {};
Object.defineProperty(dist, "__esModule", { value: true });
const ranges = [
  { min: 1, max: 60, name: { short: "s", medium: "sec", long: "second" } },
  { max: 3600, name: { short: "m", medium: "min", long: "minute" } },
  { max: 86400, name: { short: "h", medium: "hr", long: "hour" } },
  { max: 86400 * 7, name: { short: "d", medium: "day", long: "day" } },
  { max: 86400 * 28, name: { short: "w", medium: "wk", long: "week" } },
  {
    min: 86400 * 31,
    max: 86400 * 365,
    name: { short: "m", medium: "mon", long: "month" }
  },
  {
    max: 86400 * 365 * 100,
    name: { short: "y", medium: "yr", long: "year" }
  }
];
function js_ago(timestamp, options = { format: "medium" }) {
  if (!["short", "medium", "long"].includes(options.format)) {
    throw new Error("The provided format is incorrect.");
  }
  const nowMs = (/* @__PURE__ */ new Date()).getTime();
  const tsDiff = timestamp instanceof Date ? (nowMs - timestamp.getTime()) / 1e3 : nowMs / 1e3 - timestamp;
  const index = ranges.findIndex((item) => item.max > tsDiff);
  const range2 = ranges[index];
  const prevIndex = index - 1;
  const min2 = range2.min || ranges[prevIndex].max;
  const diff = Math.ceil(tsDiff / min2);
  if (diff < 0) {
    throw new Error("The time difference is negative. The provided timestamp is in the future.");
  }
  const isShort = options.format === "short";
  const plural = diff > 1 && !isShort ? "s" : "";
  const wording = range2.name[options.format];
  return `${diff}${isShort ? "" : " "}${wording}${plural} ago`;
}
dist.default = js_ago;
function __wait(timeout = 0) {
  return new Promise((resolve2) => {
    setTimeout(() => {
      resolve2();
    }, timeout);
  });
}
const fn$3 = function treatAsValue(promise, settings = {}) {
  settings = Object.assign({ during: -1 }, settings);
  let during = settings.during || -1;
  try {
    const proxy = Proxy.revocable(promise, {
      get(target, prop, receiver) {
        if (prop === "then") {
          return target;
        }
        if (during > 0)
          during--;
        else if (during === 0) {
          proxy.revoke();
        }
        return Reflect.get(...arguments);
      }
    });
    proxy.proxy.restorePromiseBehavior = () => {
      proxy.revoke();
      return promise;
    };
    return proxy.proxy;
  } catch (e) {
    return promise;
  }
};
var __awaiter$x = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SPromise extends SClass.extends(Promise) {
  /**
   * @name        queue
   * @type        Function
   * @static
   * @async
   *
   * This static method allows you to pass an array of promises that will be executed one after the other.
   * It will call the "callback" function if specified with the resolved promise as argument.
   *
   * @param       {Promise[]}        promises        The array of promises to execute one after the other
   * @param       {Function}      [before=null]        A callback to call before each promises executions
   * @param       {Function}      [after=null]        A callback to call after each promises executions
   * @return      {SPromise}                            The promise that will be resolved once all promises are resolved
   *
   * @since       2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  static queue(promises, before, after) {
    return new SPromise(({ resolve: resolve2, reject, pipe }) => __awaiter$x(this, void 0, void 0, function* () {
      const results = {};
      function next() {
        return __awaiter$x(this, void 0, void 0, function* () {
          const firstKey = Object.keys(promises)[0];
          let promise = promises[firstKey];
          if (typeof promise === "function")
            promise = promise();
          try {
            delete promises[firstKey];
            if (before)
              yield before(firstKey, promise);
            if (promise instanceof SPromise) {
              pipe(promise);
            }
            let res = yield promise;
            results[firstKey] = res;
            if (after) {
              let afterRes = yield after(firstKey, result);
              if (afterRes !== void 0)
                result[firstKey] = afterRes;
            }
            if (Object.keys(promises).length) {
              next();
            } else {
              resolve2(results);
            }
          } catch (e) {
            reject(promise);
          }
        });
      }
      next();
    }));
  }
  /**
   * @name        treatAsValue
   * @type        Function
   * @static
   *
   * This function allows you to wrap a promise in a ```resolve``` call to prevent
   * this promise to be treated as a "chaining" promise but to be treated as
   * normal value passed in the resolve call.
   *
   * @param           {Promise}          promise          The promise to treat as a simple value
   * @return          {ITreatAsValueProxy}                             A proxy of this promise that will act just like a normal promise once getted by the "await" statement
   *
   * @since      2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  static treatAsValue(promise, settings = {}) {
    return fn$3(promise, settings);
  }
  /**
   * @name          promiseSettings
   * @type          ISPromiseSettings
   * @get
   *
   * Access to the spromise settings
   *
   * @since       2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  get promiseSettings() {
    var _a2;
    return (_a2 = this.settings.promise) !== null && _a2 !== void 0 ? _a2 : this.settings;
  }
  /**
   * @name                  constructor
   * @type                  Function
   *
   * Constructor
   *
   * @param         {Function}          executor          The executor function that will receive the resolve and reject ones...
   * @param         {Object}            [settings={}]     An object of settings for this particular SPromise instance. Here's the available settings:
   *
   * @example       js
   * const promise = new SPromise(({ resolve, reject, emit }) => {
   *    // do something...
   * }).then(value => {
   *    // do something...
   * }).finally(value => {
   *    // do something...
   * });
   *
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  constructor(executorFnOrSettings = {}, settings) {
    var _a2;
    let executorFn, resolvers = {};
    super(__deepMerge({
      promise: {
        treatCancelAs: "resolve",
        destroyTimeout: 1,
        preventRejectOnThrow: false,
        emitLogErrorEventOnThrow: true,
        resolveAtResolveEvent: false,
        rejectAtRejectEvent: false,
        resolveProxies: [],
        rejectProxies: []
      }
    }, typeof executorFnOrSettings === "object" ? executorFnOrSettings : {}, settings !== null && settings !== void 0 ? settings : {}), (resolve2, reject) => {
      resolvers.resolve = resolve2;
      new Promise((rejectPromiseResolve, rejectPromiseReject) => {
        resolvers.reject = (...args) => {
          rejectPromiseReject(...args);
          if (this.promiseSettings.preventRejectOnThrow) {
            resolve2(...args);
          } else {
            reject(...args);
          }
        };
      }).catch((e) => {
        this.emit("catch", e);
      });
    });
    this._promiseState = "pending";
    this._eventEmitter = new SEventEmitter2(__deepMerge({
      metas: Object.assign({}, this.metas)
    }, (_a2 = this.settings.eventEmitter) !== null && _a2 !== void 0 ? _a2 : {}));
    this.expose(this._eventEmitter, {
      as: "eventEmitter",
      props: [
        "on",
        "off",
        "emit",
        "pipe",
        "pipeErrors",
        "pipeFrom",
        "pipeTo"
      ]
    });
    this.bind = this._eventEmitter.bind.bind(this);
    this._resolvers = resolvers;
    if (this.promiseSettings.destroyTimeout !== -1) {
      this.on("finally", (v2, m) => {
        setTimeout(() => {
          this.destroy();
        }, this.promiseSettings.destroyTimeout);
      });
    }
    executorFn = typeof executorFnOrSettings === "function" ? executorFnOrSettings : null;
    if (executorFn) {
      const api = {};
      __getMethods(this).forEach((func) => {
        if (func.slice(0, 1) === "_")
          return;
        api[func] = this[func].bind(this);
      });
      (() => __awaiter$x(this, void 0, void 0, function* () {
        yield __wait(0);
        try {
          yield executorFn(api);
        } catch (e) {
          if (this.promiseSettings.emitLogErrorEventOnThrow) {
            this.emit("log", {
              type: SLog.TYPE_ERROR,
              value: e
            });
          }
          this.reject(e);
        }
      }))();
    }
    if (this.promiseSettings.resolveAtResolveEvent) {
      this.on("resolve", (data2, metas) => {
        this.resolve(data2);
      });
    }
    if (this.promiseSettings.rejectAtRejectEvent) {
      this.on("reject", (data2, metas) => {
        this.reject(data2);
      });
    }
  }
  // you can also use Symbol.species in order to
  // return a Promise for then/catch/finally
  static get [Symbol.species]() {
    return Promise;
  }
  // Promise overrides his Symbol.toStringTag
  get [Symbol.toStringTag]() {
    return "SPromise";
  }
  /**
   * @name                    promiseState
   * @type                    String
   * @get
   *
   * Access the promise state. Can be one of these:
   * - pending: When the promise is waiting for resolution or rejection
   * - resolved: When the promise has been resolved
   * - rejected: When the promise has been rejected
   * - canceled: When the promise has been canceled
   * - destroyed: When the promise has been destroyed
   *
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  get promiseState() {
    return this._promiseState;
  }
  /**
   * @name                  treatAsValue
   * @type                  Function
   *
   * This method wrap the promise into a revocable proxy to allow
   * passing this Promise to methods like ```then```, etc... and make
   * this promise treated as a value and not as a chained promise.
   * Once you have done with this behavior, you just have to call
   * the ```restorePromiseBehavior``` on the returned proxy and
   * the default promise behavior will be restored
   *
   * @param         {ITreatAsValueSettings}       [settings={}]     Some settings to configure your custom behavior
   * @return        {ITreatAsValueProxy}                            A custom proxy that you can revoke using the ```restorePromiseBehavior```
   *
   * @since         2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  treatAsValue(settings = {}) {
    return fn$3(this, settings);
  }
  /**
   * @name             registerProxy
   * @type              Function
   *
   * ALlows you to register a proxy at a certain point of the promise lifecycle like:
   * - resolve: Allows you to edit the value that will be sent to the resolve point
   * - reject: Allows you to edit the value that will be sent to the reject point
   *
   * @since       2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  registerProxy(point, proxy) {
    const ar2 = point.split(",").map((l) => l.trim());
    ar2.forEach((a) => {
      if (a === "resolve") {
        this.settings.promise.resolveProxies.push(proxy);
      } else if (a === "reject") {
        this.settings.promise.rejectProxies.push(proxy);
      }
    });
  }
  /**
   * @name                  is
   * @type                  Function
   *
   * Check is the promise is on one of the passed status
   *
   * @param       {String}        status        A comma separated list of status to check
   * @return      {Boolean}                     Return true if the promise is in one of the passed status
   *
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  is(status) {
    const statusArray = status.split(",").map((l) => l.trim());
    if (statusArray.indexOf(this._promiseState) !== -1)
      return true;
    return false;
  }
  /**
   * @name                  isPending
   * @type                  Function
   *
   * Return back true or false depending on the promise status
   *
   * @return    {Boolean}         true or false depending on the promise status
   *
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  isPending() {
    return this._promiseState === "pending";
  }
  /**
   * @name                  isResolved
   * @type                  Function
   *
   * Return back true or false depending on the promise status
   *
   * @return    {Boolean}         true or false depending on the promise status
   *
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  isResolved() {
    return this._promiseState === "resolved";
  }
  /**
   * @name                  isRejected
   * @type                  Function
   *
   * Return back true or false depending on the promise status
   *
   * @return    {Boolean}         true or false depending on the promise status
   *
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  isRejected() {
    return this._promiseState === "rejected";
  }
  /**
   * @name                  isCanceled
   * @type                  Function
   *
   * Return back true or false depending on the promise status
   *
   * @return    {Boolean}         true or false depending on the promise status
   *
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  isCanceled() {
    return this._promiseState === "canceled";
  }
  /**
   * @name                  isDestroyed
   * @type                  Function
   *
   * Return back true or false depending on the promise status
   *
   * @return    {Boolean}         true or false depending on the promise status
   *
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  isDestroyed() {
    return this._promiseState === "destroyed";
  }
  /**
   * @name          resolve
   * @type          Function
   * @async
   *
   * This is the "resolve" method exposed on the promise itself for convinience
   *
   * @param         {Mixed}         arg       The value that you want to return back from the promise
   * @param       {Array|String}         [stacksOrder='resolve,finally']      This specify in which order have to be called the stacks
   * @return        {Promise}                       A simple promise that will be resolved once the promise has been canceled with the cancel stack result as value
   *
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  resolve(arg, stacksOrder = "resolve,finally") {
    return this._resolve(arg, stacksOrder);
  }
  /**
   * @name          _resolve
   * @type          Function
   * @private
   * @async
   *
   * This is the method that will be called by the promise executor passed resolve function
   *
   * @param       {Mixed}         arg           The argument that the promise user is sendind through the resolve function
   * @param       {Array|String}         [stacksOrder='resolve,finally']      This specify in which order have to be called the stacks
   * @return        {Promise}                       A simple promise that will be resolved once the promise has been canceled with the cancel stack result as value
   *
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  _resolve(arg, stacksOrder = "resolve,finally") {
    return __awaiter$x(this, void 0, void 0, function* () {
      if (this._promiseState === "destroyed")
        return;
      this._promiseState = "resolved";
      const stacksOrderArray = stacksOrder.split(",").map((l) => l.trim());
      for (let i = 0; i < stacksOrderArray.length; i++) {
        const stack = stacksOrderArray[i];
        arg = yield this.eventEmitter.emit(stack, arg);
      }
      for (const proxyFn of this.settings.promise.resolveProxies || []) {
        arg = yield proxyFn(arg);
      }
      this._resolvers.resolve(arg);
      return arg;
    });
  }
  /**
   * @name          reject
   * @type          Function
   * @async
   *
   * This is the "reject" method exposed on the promise itself for convinience
   *
   * @param         {Mixed}         arg       The value that you want to return back from the promise
   * @param       {Array|String}         [stacksOrder='catch,reject,finally']      This specify in which order have to be called the stacks
   * @return        {Promise}      A simple promise that will be resolved once the promise has been canceled with the cancel stack result as value
   *
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  reject(arg, stacksOrder = `catch,reject,finally`) {
    return this._reject(arg, stacksOrder);
  }
  /**
   * @name          _reject
   * @type          Function
   * @private
   * @async
   *
   * This is the method that will be called by the promise executor passed reject function
   *
   * @param         {Mixed}         arg       The value that you want to return back from the promise
   * @param       {Array|String}         [stacksOrder='catch,reject,finally']      This specify in which order have to be called the stacks
   * @return        {Promise}                       A simple promise that will be resolved once the promise has been canceled with the cancel stack result as value
   *
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  _reject(arg, stacksOrder = `catch,reject,finally`) {
    return __awaiter$x(this, void 0, void 0, function* () {
      if (this._promiseState === "destroyed")
        return;
      this._promiseState = "rejected";
      const stacksOrderArray = stacksOrder.split(",").map((l) => l.trim());
      for (let i = 0; i < stacksOrderArray.length; i++) {
        const stack = stacksOrderArray[i];
        arg = yield this.eventEmitter.emit(stack, arg);
      }
      for (const proxyFn of this.settings.promise.rejectProxies || []) {
        arg = yield proxyFn(arg);
      }
      this._resolvers.reject(arg);
      return arg;
    });
  }
  /**
   * @name          cancel
   * @type          Function
   * @async
   *
   * This is the "cancel" method exposed on the promise itself for convinience
   *
   * @param         {Mixed}         arg       The value that you want to return back from the promise
   * @param       {Array|String}         [stacksOrder='cancel,finally']      This specify in which order have to be called the stacks
   * @return        {Promise}                       A simple promise that will be resolved once the promise has been canceled with the cancel stack result as value
   *
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  cancel(arg, stacksOrder = "cancel,finally") {
    return this._cancel(arg, stacksOrder);
  }
  /**
   * @name            _cancel
   * @type            Function
   * @private
   * @async
   *
   * Cancel the promise execution, destroy the Promise and resolve it with the passed value without calling any callbacks
   *
   * @param         {Mixed}           arg           The argument you want to pass to the cancel callbacks
   * @param       {Array|String}         [stacksOrder='cancel,finally']      This specify in which order have to be called the stacks
   * @return        {Promise}                       A simple promise that will be resolved once the promise has been canceled with the cancel stack result as value
   *
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  _cancel(arg, stacksOrder = "cancel,finally") {
    if (this._promiseState === "destroyed")
      return;
    return new Promise((resolve2, reject) => __awaiter$x(this, void 0, void 0, function* () {
      this._promiseState = "canceled";
      const stacksOrderArray = stacksOrder.split(",").map((l) => l.trim());
      for (let i = 0; i < stacksOrderArray.length; i++) {
        const stack = stacksOrderArray[i];
        arg = yield this.eventEmitter.emit(stack, arg);
      }
      if (this.settings.promise.treatCancelAs === "reject") {
        this._resolvers.reject(arg);
      } else {
        this._resolvers.resolve(arg);
      }
      resolve2(arg);
    }));
  }
  /**
   * @name                catch
   * @type                Function
   *
   * This method allows the SPromise user to register a function that will be called every time the "reject" one is called in the executor
   * The context of the callback will be the SPromise instance itself so you can call all the methods available like "resolve", "catch", etc using
   * the "this.resolve('something')" statusment. In an arrow function like "(value) => { ... }", the "this" keyword will be bound to the current context where you define
   * your function. You can access to the SPromise instance through the last parameter like so "(value, sPromiseInstance) => { ... }".
   *
   * @param           {Number}          [callNumber=-1]     (Optional) How many times you want this callback to be called at max. -1 means unlimited
   * @param           {Function}        callback        The callback function to register
   * @return          {SPromise}                  The SPromise instance to maintain chainability
   *
   * @example         js
   * new SPromise(({ resolve, reject }) => {
   *    // do something...
   *    reject('hello world');
   * }).catch(value => {
   *    // do something with the value that is "hello world"
   * }).catch(1, value => {
   *    // do something that will be executed only once
   * });
   *
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  catch(...args) {
    super.catch(...args);
    return this.on("catch", ...args);
  }
  /**
   * @name                finally
   * @type                Function
   *
   * This method allows the SPromise user to register a function that will be called every time the "reject" one is called in the executor
   * The context of the callback will be the SPromise instance itself so you can call all the methods available like "resolve", "catch", etc using
   * the "this.resolve('something')" statusment. In an arrow function like "(value) => { ... }", the "this" keyword will be bound to the current context where you define
   * your function. You can access to the SPromise instance through the last parameter like so "(value, sPromiseInstance) => { ... }".
   *
   * @param           {Function}        callback        The callback function to register
   * @return          {SPromise}                  The SPromise instance to maintain chainability
   *
   * @example         js
   * new SPromise(({ resolve, reject, emit }) => {
   *    // do something...
   *    resolve('hello world');
   * }).finally(value => {
   *    // do something with the value that is "hello world"
   * });
   *
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  finally(...args) {
    return this.on("finally", ...args);
  }
  /**
   * @name                      destroy
   * @type                      Function
   *
   * Destroying the SPromise instance by unregister all the callbacks, etc...
   *
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  destroy() {
    this._eventEmitter.destroy();
    this._promiseState = "destroyed";
  }
}
var isff = typeof navigator !== "undefined" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : false;
function addEvent(object, event, method, useCapture) {
  if (object.addEventListener) {
    object.addEventListener(event, method, useCapture);
  } else if (object.attachEvent) {
    object.attachEvent("on".concat(event), function() {
      method(window.event);
    });
  }
}
function getMods(modifier, key) {
  var mods = key.slice(0, key.length - 1);
  for (var i = 0; i < mods.length; i++)
    mods[i] = modifier[mods[i].toLowerCase()];
  return mods;
}
function getKeys(key) {
  if (typeof key !== "string")
    key = "";
  key = key.replace(/\s/g, "");
  var keys3 = key.split(",");
  var index = keys3.lastIndexOf("");
  for (; index >= 0; ) {
    keys3[index - 1] += ",";
    keys3.splice(index, 1);
    index = keys3.lastIndexOf("");
  }
  return keys3;
}
function compareArray(a1, a2) {
  var arr1 = a1.length >= a2.length ? a1 : a2;
  var arr2 = a1.length >= a2.length ? a2 : a1;
  var isIndex = true;
  for (var i = 0; i < arr1.length; i++) {
    if (arr2.indexOf(arr1[i]) === -1)
      isIndex = false;
  }
  return isIndex;
}
var _keyMap = {
  backspace: 8,
  "⌫": 8,
  tab: 9,
  clear: 12,
  enter: 13,
  "↩": 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  "⇪": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": isff ? 173 : 189,
  "=": isff ? 61 : 187,
  ";": isff ? 59 : 186,
  "'": 222,
  "[": 219,
  "]": 221,
  "\\": 220
};
var _modifier = {
  // shiftKey
  "⇧": 16,
  shift: 16,
  // altKey
  "⌥": 18,
  alt: 18,
  option: 18,
  // ctrlKey
  "⌃": 17,
  ctrl: 17,
  control: 17,
  // metaKey
  "⌘": 91,
  cmd: 91,
  command: 91
};
var modifierMap = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
};
var _mods = {
  16: false,
  18: false,
  17: false,
  91: false
};
var _handlers = {};
for (var k = 1; k < 20; k++) {
  _keyMap["f".concat(k)] = 111 + k;
}
var _downKeys = [];
var winListendFocus = false;
var _scope = "all";
var elementHasBindEvent = [];
var code = function code2(x) {
  return _keyMap[x.toLowerCase()] || _modifier[x.toLowerCase()] || x.toUpperCase().charCodeAt(0);
};
var getKey = function getKey2(x) {
  return Object.keys(_keyMap).find(function(k) {
    return _keyMap[k] === x;
  });
};
var getModifier = function getModifier2(x) {
  return Object.keys(_modifier).find(function(k) {
    return _modifier[k] === x;
  });
};
function setScope(scope) {
  _scope = scope || "all";
}
function getScope() {
  return _scope || "all";
}
function getPressedKeyCodes() {
  return _downKeys.slice(0);
}
function getPressedKeyString() {
  return _downKeys.map(function(c) {
    return getKey(c) || getModifier(c) || String.fromCharCode(c);
  });
}
function filter(event) {
  var target = event.target || event.srcElement;
  var tagName = target.tagName;
  var flag = true;
  if (target.isContentEditable || (tagName === "INPUT" || tagName === "TEXTAREA" || tagName === "SELECT") && !target.readOnly) {
    flag = false;
  }
  return flag;
}
function isPressed(keyCode) {
  if (typeof keyCode === "string") {
    keyCode = code(keyCode);
  }
  return _downKeys.indexOf(keyCode) !== -1;
}
function deleteScope(scope, newScope) {
  var handlers;
  var i;
  if (!scope)
    scope = getScope();
  for (var key in _handlers) {
    if (Object.prototype.hasOwnProperty.call(_handlers, key)) {
      handlers = _handlers[key];
      for (i = 0; i < handlers.length; ) {
        if (handlers[i].scope === scope)
          handlers.splice(i, 1);
        else
          i++;
      }
    }
  }
  if (getScope() === scope)
    setScope(newScope || "all");
}
function clearModifier(event) {
  var key = event.keyCode || event.which || event.charCode;
  var i = _downKeys.indexOf(key);
  if (i >= 0) {
    _downKeys.splice(i, 1);
  }
  if (event.key && event.key.toLowerCase() === "meta") {
    _downKeys.splice(0, _downKeys.length);
  }
  if (key === 93 || key === 224)
    key = 91;
  if (key in _mods) {
    _mods[key] = false;
    for (var k in _modifier)
      if (_modifier[k] === key)
        hotkeys[k] = false;
  }
}
function unbind(keysInfo) {
  if (typeof keysInfo === "undefined") {
    Object.keys(_handlers).forEach(function(key) {
      return delete _handlers[key];
    });
  } else if (Array.isArray(keysInfo)) {
    keysInfo.forEach(function(info) {
      if (info.key)
        eachUnbind(info);
    });
  } else if (typeof keysInfo === "object") {
    if (keysInfo.key)
      eachUnbind(keysInfo);
  } else if (typeof keysInfo === "string") {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    var scope = args[0], method = args[1];
    if (typeof scope === "function") {
      method = scope;
      scope = "";
    }
    eachUnbind({
      key: keysInfo,
      scope,
      method,
      splitKey: "+"
    });
  }
}
var eachUnbind = function eachUnbind2(_ref) {
  var key = _ref.key, scope = _ref.scope, method = _ref.method, _ref$splitKey = _ref.splitKey, splitKey = _ref$splitKey === void 0 ? "+" : _ref$splitKey;
  var multipleKeys = getKeys(key);
  multipleKeys.forEach(function(originKey) {
    var unbindKeys = originKey.split(splitKey);
    var len = unbindKeys.length;
    var lastKey = unbindKeys[len - 1];
    var keyCode = lastKey === "*" ? "*" : code(lastKey);
    if (!_handlers[keyCode])
      return;
    if (!scope)
      scope = getScope();
    var mods = len > 1 ? getMods(_modifier, unbindKeys) : [];
    _handlers[keyCode] = _handlers[keyCode].filter(function(record) {
      var isMatchingMethod = method ? record.method === method : true;
      return !(isMatchingMethod && record.scope === scope && compareArray(record.mods, mods));
    });
  });
};
function eventHandler(event, handler, scope, element) {
  if (handler.element !== element) {
    return;
  }
  var modifiersMatch;
  if (handler.scope === scope || handler.scope === "all") {
    modifiersMatch = handler.mods.length > 0;
    for (var y2 in _mods) {
      if (Object.prototype.hasOwnProperty.call(_mods, y2)) {
        if (!_mods[y2] && handler.mods.indexOf(+y2) > -1 || _mods[y2] && handler.mods.indexOf(+y2) === -1) {
          modifiersMatch = false;
        }
      }
    }
    if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === "*") {
      handler.keys = [];
      handler.keys = handler.keys.concat(_downKeys);
      if (handler.method(event, handler) === false) {
        if (event.preventDefault)
          event.preventDefault();
        else
          event.returnValue = false;
        if (event.stopPropagation)
          event.stopPropagation();
        if (event.cancelBubble)
          event.cancelBubble = true;
      }
    }
  }
}
function dispatch(event, element) {
  var asterisk = _handlers["*"];
  var key = event.keyCode || event.which || event.charCode;
  if (!hotkeys.filter.call(this, event))
    return;
  if (key === 93 || key === 224)
    key = 91;
  if (_downKeys.indexOf(key) === -1 && key !== 229)
    _downKeys.push(key);
  ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach(function(keyName) {
    var keyNum = modifierMap[keyName];
    if (event[keyName] && _downKeys.indexOf(keyNum) === -1) {
      _downKeys.push(keyNum);
    } else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) {
      _downKeys.splice(_downKeys.indexOf(keyNum), 1);
    } else if (keyName === "metaKey" && event[keyName] && _downKeys.length === 3) {
      if (!(event.ctrlKey || event.shiftKey || event.altKey)) {
        _downKeys = _downKeys.slice(_downKeys.indexOf(keyNum));
      }
    }
  });
  if (key in _mods) {
    _mods[key] = true;
    for (var k in _modifier) {
      if (_modifier[k] === key)
        hotkeys[k] = true;
    }
    if (!asterisk)
      return;
  }
  for (var e in _mods) {
    if (Object.prototype.hasOwnProperty.call(_mods, e)) {
      _mods[e] = event[modifierMap[e]];
    }
  }
  if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState("AltGraph")) {
    if (_downKeys.indexOf(17) === -1) {
      _downKeys.push(17);
    }
    if (_downKeys.indexOf(18) === -1) {
      _downKeys.push(18);
    }
    _mods[17] = true;
    _mods[18] = true;
  }
  var scope = getScope();
  if (asterisk) {
    for (var i = 0; i < asterisk.length; i++) {
      if (asterisk[i].scope === scope && (event.type === "keydown" && asterisk[i].keydown || event.type === "keyup" && asterisk[i].keyup)) {
        eventHandler(event, asterisk[i], scope, element);
      }
    }
  }
  if (!(key in _handlers))
    return;
  for (var _i2 = 0; _i2 < _handlers[key].length; _i2++) {
    if (event.type === "keydown" && _handlers[key][_i2].keydown || event.type === "keyup" && _handlers[key][_i2].keyup) {
      if (_handlers[key][_i2].key) {
        var record = _handlers[key][_i2];
        var splitKey = record.splitKey;
        var keyShortcut = record.key.split(splitKey);
        var _downKeysCurrent = [];
        for (var a = 0; a < keyShortcut.length; a++) {
          _downKeysCurrent.push(code(keyShortcut[a]));
        }
        if (_downKeysCurrent.sort().join("") === _downKeys.sort().join("")) {
          eventHandler(event, record, scope, element);
        }
      }
    }
  }
}
function isElementBind(element) {
  return elementHasBindEvent.indexOf(element) > -1;
}
function hotkeys(key, option, method) {
  _downKeys = [];
  var keys3 = getKeys(key);
  var mods = [];
  var scope = "all";
  var element = document;
  var i = 0;
  var keyup = false;
  var keydown = true;
  var splitKey = "+";
  var capture = false;
  if (method === void 0 && typeof option === "function") {
    method = option;
  }
  if (Object.prototype.toString.call(option) === "[object Object]") {
    if (option.scope)
      scope = option.scope;
    if (option.element)
      element = option.element;
    if (option.keyup)
      keyup = option.keyup;
    if (option.keydown !== void 0)
      keydown = option.keydown;
    if (option.capture !== void 0)
      capture = option.capture;
    if (typeof option.splitKey === "string")
      splitKey = option.splitKey;
  }
  if (typeof option === "string")
    scope = option;
  for (; i < keys3.length; i++) {
    key = keys3[i].split(splitKey);
    mods = [];
    if (key.length > 1)
      mods = getMods(_modifier, key);
    key = key[key.length - 1];
    key = key === "*" ? "*" : code(key);
    if (!(key in _handlers))
      _handlers[key] = [];
    _handlers[key].push({
      keyup,
      keydown,
      scope,
      mods,
      shortcut: keys3[i],
      method,
      key: keys3[i],
      splitKey,
      element
    });
  }
  if (typeof element !== "undefined" && !isElementBind(element) && window) {
    elementHasBindEvent.push(element);
    addEvent(element, "keydown", function(e) {
      dispatch(e, element);
    }, capture);
    if (!winListendFocus) {
      winListendFocus = true;
      addEvent(window, "focus", function() {
        _downKeys = [];
      }, capture);
    }
    addEvent(element, "keyup", function(e) {
      dispatch(e, element);
      clearModifier(e);
    }, capture);
  }
}
function trigger(shortcut) {
  var scope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all";
  Object.keys(_handlers).forEach(function(key) {
    var dataList = _handlers[key].filter(function(item) {
      return item.scope === scope && item.shortcut === shortcut;
    });
    dataList.forEach(function(data2) {
      if (data2 && data2.method) {
        data2.method();
      }
    });
  });
}
var _api = {
  getPressedKeyString,
  setScope,
  getScope,
  deleteScope,
  getPressedKeyCodes,
  isPressed,
  filter,
  trigger,
  unbind,
  keyMap: _keyMap,
  modifier: _modifier,
  modifierMap
};
for (var a in _api) {
  if (Object.prototype.hasOwnProperty.call(_api, a)) {
    hotkeys[a] = _api[a];
  }
}
if (typeof window !== "undefined") {
  var _hotkeys = window.hotkeys;
  hotkeys.noConflict = function(deep) {
    if (deep && window.hotkeys === hotkeys) {
      window.hotkeys = _hotkeys;
    }
    return hotkeys;
  };
  window.hotkeys = hotkeys;
}
var hotkeys_common = hotkeys;
const hotkeys$1 = /* @__PURE__ */ getDefaultExportFromCjs(hotkeys_common);
hotkeys$1.filter = function() {
  return true;
};
function __hotkey(hotkey, settings = {}) {
  settings = Object.assign({ rootNode: [document], keyup: false, keydown: true, once: false, splitKey: "+", title: hotkey, description: null, private: false }, settings);
  if (!Array.isArray(settings.rootNode)) {
    settings.rootNode = [settings.rootNode];
  }
  return new SPromise(({ resolve: resolve2, reject, emit, cancel }) => {
    settings.rootNode.forEach((rootNode) => {
      var _a2;
      const documentElement = (_a2 = rootNode.ownerDocument) !== null && _a2 !== void 0 ? _a2 : rootNode;
      if (!settings.private) {
        if (!(documentElement === null || documentElement === void 0 ? void 0 : documentElement.env)) {
          documentElement.env = {};
        }
        if (!documentElement.env.HOTKEYS) {
          documentElement.env.HOTKEYS = {};
        }
        if (!documentElement.env.HOTKEYS[hotkey]) {
          setTimeout(() => {
            var _a3;
            rootNode.dispatchEvent(new CustomEvent("hotkeys.update", {
              bubbles: true,
              detail: (_a3 = documentElement.env) === null || _a3 === void 0 ? void 0 : _a3.HOTKEYS
            }));
          });
        }
        documentElement.env.HOTKEYS[hotkey] = {
          title: settings.title,
          description: settings.description,
          hotkey
        };
      }
      hotkeys$1(hotkey, Object.assign({ element: rootNode }, settings), (e, h) => {
        emit("press", e);
        if (settings.once)
          cancel();
      });
    });
  }, {
    id: "hotkey"
  }).on("finally", () => {
    settings.rootNode.forEach((rootNode) => {
      var _a2, _b2, _c2;
      const documentElement = (_a2 = rootNode.ownerDocument) !== null && _a2 !== void 0 ? _a2 : rootNode;
      (_b2 = documentElement.env) === null || _b2 === void 0 ? true : delete _b2.HOTKEYS[hotkey];
      rootNode.dispatchEvent(new CustomEvent("hotkeys.update", {
        bubbles: true,
        detail: (_c2 = documentElement.env) === null || _c2 === void 0 ? void 0 : _c2.HOTKEYS
      }));
    });
    hotkeys$1.unbind(hotkey);
  });
}
const _escapeQueue = [];
let _isEscaping = false;
function escapeQueue(callback, settings) {
  return new SPromise(({ resolve: resolve2, reject, on }) => {
    var _a2;
    const finalSettings = Object.assign({ rootNode: document }, settings !== null && settings !== void 0 ? settings : {});
    const roots = Array.isArray(finalSettings.rootNode) ? finalSettings.rootNode : [finalSettings.rootNode];
    roots.forEach(($root) => {
      if ($root._escapeQueue) {
        return;
      }
      $root._escapeQueue = true;
      __hotkey("escape", {
        rootNode: $root,
        private: true
      }).on("press", () => {
        var _a3;
        if (!_escapeQueue.length || _isEscaping) {
          return;
        }
        _isEscaping = true;
        setTimeout(() => {
          _isEscaping = false;
        });
        const queueItem2 = _escapeQueue.pop();
        (_a3 = queueItem2.callback) === null || _a3 === void 0 ? void 0 : _a3.call(queueItem2);
        queueItem2.resolve();
      });
    });
    const queueItem = {
      id: (_a2 = finalSettings.id) !== null && _a2 !== void 0 ? _a2 : __uniqid(),
      callback,
      resolve: resolve2
    };
    if (finalSettings.id) {
      const existing = _escapeQueue.find((i) => i.id === finalSettings.id);
      if (existing) {
        existing.callback = callback;
        existing.resolve = resolve2;
      } else {
        _escapeQueue.push(queueItem);
      }
    } else {
      _escapeQueue.push(queueItem);
    }
    on("cancel", () => {
      _escapeQueue.splice(_escapeQueue.indexOf(queueItem, 1));
    });
  });
}
function __isNode$1() {
  return typeof process !== "undefined" && process.release && process.release.name === "node";
}
function getAvailableInterfaceTypes() {
  if (__isNode$1())
    return global._registeredInterfacesTypes || {};
  else if (window !== void 0)
    return window._registeredInterfacesTypes || {};
  else
    return {};
}
function __replaceTags(text, tags) {
  if (!text)
    text = "";
  text = fn$5(text);
  let oneLineText = text.replace(/\r\n/g, "|rn|");
  oneLineText = oneLineText.replace(/\n/g, "|n|");
  oneLineText = oneLineText.replace(/\r/g, "|r|");
  Object.keys(tags).forEach((tagName) => {
    const reg = new RegExp(`<s*${tagName}[^>]*>((.*?))<\\s*/\\s*${tagName}>`, "g");
    const tagsArray = oneLineText.match(reg);
    const singleReg = new RegExp(`\\s?<${tagName}\\s?/>\\s?`, "g");
    const singleTagsArray = oneLineText.match(singleReg);
    if (tagsArray) {
      for (let i = 0; i < tagsArray.length; i++) {
        const t = tagsArray[i];
        const tagArgs = t.match(`<\\s*${tagName}[^>]*>((.*?))<\\s*/\\s*${tagName}>`);
        if (!tagArgs)
          continue;
        const tagToReplace = tagArgs[0];
        const tagContent = tagArgs[1];
        oneLineText = oneLineText.replace(tagToReplace, tags[tagName](tagName, tagContent));
      }
    }
    if (singleTagsArray) {
      for (let i = 0; i < singleTagsArray.length; i++) {
        const t = singleTagsArray[i];
        const tagArgs = t.match(`\\s?<${tagName}\\s?/>\\s?`);
        if (!tagArgs)
          continue;
        const tagToReplace = tagArgs[0];
        const tagContent = "";
        oneLineText = oneLineText.replace(tagToReplace, tags[tagName](tagName, tagContent));
      }
    }
  });
  oneLineText = oneLineText.replace(/\|rn\|/g, "\r\n");
  oneLineText = oneLineText.replace(/\|n\|/g, "\n");
  oneLineText = oneLineText.replace(/\|r\|/g, "\r");
  return oneLineText;
}
const tagsMap = {
  black: (tag2, content) => `\x1B[30m${content}\x1B[0m`,
  red: (tag2, content) => `\x1B[1;31m${content}\x1B[0m`,
  green: (tag2, content) => `\x1B[1;32m${content}\x1B[0m`,
  yellow: (tag2, content) => `\x1B[1;33m${content}\x1B[0m`,
  blue: (tag2, content) => `\x1B[1;34m${content}\x1B[0m`,
  magenta: (tag2, content) => `\x1B[1;35m${content}\x1B[0m`,
  cyan: (tag2, content) => `\x1B[1;36m${content}\x1B[0m`,
  white: (tag2, content) => `\x1B[1;37m${content}\x1B[0m`,
  grey: (tag2, content) => `\x1B[1;30m${content}\x1B[0m`,
  bgBlack: (tag2, content) => `\x1B[40m${content}\x1B[0m`,
  bgRed: (tag2, content) => `\x1B[41m${content}\x1B[0m`,
  bgGreen: (tag2, content) => `\x1B[42m${content}\x1B[0m`,
  bgYellow: (tag2, content) => `\x1B[43m${content}\x1B[0m`,
  bgBlue: (tag2, content) => `\x1B[44m${content}\x1B[0m`,
  bgMagenta: (tag2, content) => `\x1B[45m${content}\x1B[0m`,
  bgCyan: (tag2, content) => `\x1B[46m${content}\x1B[0m`,
  bgWhite: (tag2, content) => `\x1B[47m${content}\x1B[0m`,
  bgGrey: (tag2, content) => `\x1B[48m${content}\x1B[0m`,
  bold: (tag2, content) => content,
  dim: (tag2, content) => content,
  italic: (tag2, content) => content,
  underline: (tag2, content) => content,
  strike: (tag2, content) => content,
  date: (tag2, content) => (/* @__PURE__ */ new Date()).getDate().toString().padStart("0", 2) + "-" + ((/* @__PURE__ */ new Date()).getMonth() + 1).toString().padStart("0", 2) + "-" + (/* @__PURE__ */ new Date()).getFullYear().toString().padStart("0", 2),
  time: (tag2, content) => (/* @__PURE__ */ new Date()).getHours().toString().padStart("0", 2) + ":" + (/* @__PURE__ */ new Date()).getMinutes().toString().padStart("0", 2) + ":" + (/* @__PURE__ */ new Date()).getMinutes().toString().padStart("0", 2),
  day: (tag2, content) => (/* @__PURE__ */ new Date()).getDate().toString().padStart("0", 2),
  days: (tag2, content) => (/* @__PURE__ */ new Date()).getDate().toString().padStart("0", 2),
  month: (tag2, content) => (/* @__PURE__ */ new Date()).getMonth().toString().padStart("0", 2),
  months: (tag2, content) => (/* @__PURE__ */ new Date()).getMonth().toString().padStart("0", 2),
  year: (tag2, content) => (/* @__PURE__ */ new Date()).getFullYear().toString().padStart("0", 2),
  years: (tag2, content) => (/* @__PURE__ */ new Date()).getFullYear().toString().padStart("0", 2),
  hour: (tag2, content) => (/* @__PURE__ */ new Date()).getHours().toString().padStart("0", 2),
  hours: (tag2, content) => (/* @__PURE__ */ new Date()).getHours().toString().padStart("0", 2),
  minute: (tag2, content) => (/* @__PURE__ */ new Date()).getMinutes().toString().padStart("0", 2),
  minutes: (tag2, content) => (/* @__PURE__ */ new Date()).getMinutes().toString().padStart("0", 2),
  second: (tag2, content) => (/* @__PURE__ */ new Date()).getSeconds().toString().padStart("0", 2),
  seconds: (tag2, content) => (/* @__PURE__ */ new Date()).getSeconds().toString().padStart("0", 2),
  br: (tag2, content) => "\n"
};
function __parseHtml(message) {
  let isArray2 = false;
  if (Array.isArray(message)) {
    isArray2 = true;
  } else {
    message = [message];
  }
  message = message.map((m) => {
    return __replaceTags(m, tagsMap);
  });
  if (isArray2)
    return message;
  return message[0];
}
function __typeOf(value, settings = {}) {
  settings = __deepMerge({
    of: false,
    customClass: true
  }, settings);
  let type;
  if (Array.isArray(value))
    type = "Array";
  else if (value instanceof Map)
    type = "Map";
  else if (value === null)
    type = "Null";
  else if (value === void 0)
    type = "Undefined";
  else if (typeof value === "string")
    type = "String";
  else if (__isInteger(value))
    type = "Integer";
  else if (typeof value === "number")
    type = "Number";
  else if (typeof value === "boolean")
    type = "Boolean";
  else if (value instanceof RegExp)
    type = "RegExp";
  else if (settings.customClass === true && isClass(value) && value.name !== void 0) {
    type = __upperFirst(value.name);
  } else if (settings.customClass === true && value.constructor !== void 0 && value.constructor.name !== void 0) {
    type = __upperFirst(value.constructor.name);
  } else if (settings.customClass === false && isClass(value)) {
    type = "Class";
  } else if (typeof value === "function")
    type = "Function";
  else if (typeof value === "object")
    type = "Object";
  else
    type = "Unknown";
  const avoidTypes = [
    "Null",
    "Undefined",
    "String",
    "Integer",
    "Number",
    "Boolean",
    "Unknown"
  ];
  if (settings.of === true && !avoidTypes.includes(type)) {
    const loopOn = Array.isArray(value) ? [...value.keys()] : Object.keys(value);
    const receivedTypes = [];
    loopOn.forEach((valueIndex) => {
      const valueToCheck = value[valueIndex];
      const childType = __typeOf(valueToCheck, {
        of: false,
        customClass: settings.customClass
      });
      if (!receivedTypes.includes(childType)) {
        receivedTypes.push(childType);
      }
    });
    type += `<${receivedTypes.join("|")}>`;
  }
  return type;
}
const fn$2 = function(stack, callback, settings = {}) {
  settings = Object.assign({ newStack: false }, settings);
  const stackType = __typeOf(stack).toLowerCase();
  let loopOnKeys;
  if (stackType === "object")
    loopOnKeys = Object.keys(stack);
  else if (stackType === "array")
    loopOnKeys = Array.from(Array(stack.length).keys());
  else if (stackType === "number" || stackType === "integer")
    loopOnKeys = Array.from(Array(Math.round(stack)).keys());
  else if (stackType === "string")
    loopOnKeys = Array.from(stack);
  else if (stackType === "set")
    loopOnKeys = Array.from(stack);
  else
    loopOnKeys = Array.from(stack.keys());
  if (stackType === "string" || stackType === "number" || stackType === "integer" || stackType === "set")
    settings.newStack = true;
  let newStack = [];
  if (stackType === "object")
    newStack = {};
  else if (stackType === "map")
    newStack = /* @__PURE__ */ new Map();
  else if (stackType === "set")
    newStack = /* @__PURE__ */ new Set();
  let value;
  let newValue;
  const _get = (s, k) => {
    switch (__typeOf(s).toLowerCase()) {
      case "array":
      case "object":
        return s[k];
      case "string":
        return k;
      case "number":
      case "integer":
        return k;
      case "map":
        return s.get(k);
      case "set":
        return k;
    }
  };
  const _set = (s, k, v2) => {
    switch (__typeOf(s).toLowerCase()) {
      case "array":
        if (settings.newStack === true)
          s.push(v2);
        else
          s[k] = v2;
        break;
      case "object":
        s[k] = v2;
        break;
      case "number":
      case "integer":
      case "string":
        s.push(v2);
        break;
      case "map":
        s.set(k, v2);
        break;
      case "set":
        s.add(v2);
        break;
    }
  };
  for (let i = 0; i < loopOnKeys.length; i++) {
    const key = loopOnKeys[i];
    value = _get(stack, key);
    newValue = callback({ key, prop: key, value, i, idx: i });
    if (newValue === -1)
      break;
    _set(settings.newStack ? newStack : stack, key, newValue);
  }
  if (stackType === "string") {
    return newStack.join("");
  }
  return settings.newStack ? newStack : stack;
};
function parseSingleTypeString(typeString) {
  let ofStr = "", typeStr = typeString, ofTypes = [];
  if (typeStr.match(/^['"`]/)) {
    return {
      type: "string",
      of: void 0,
      value: typeStr.replace(/^['"`]/, "").replace(/['"`]$/, "")
    };
  }
  const autoCastedValue = __parse(typeStr);
  if (typeof autoCastedValue === "number") {
    return {
      type: "number",
      of: void 0,
      value: autoCastedValue
    };
  }
  typeStr = typeStr.trim().replace(/^([a-zA-Z0-9-_]+)\[\]$/, "array<$1>");
  const ofPartsString = typeStr.match(/<(.+)>$/gm);
  if (ofPartsString && ofPartsString.length) {
    ofStr = ofPartsString[0].replace("<", "").replace(">", "");
  }
  if (ofStr !== "") {
    typeStr = typeStr.replace(`<${ofStr}>`, "");
  }
  ofTypes = ofStr !== "" ? [ofStr] : void 0;
  if (ofStr !== void 0 && ofStr.includes("|")) {
    ofTypes = ofStr.split("|").map((t) => t.trim());
  }
  const result2 = {
    type: typeStr,
    of: ofTypes
  };
  Object.defineProperty(result2, "toString", {
    get() {
      return () => typeString;
    }
  });
  return result2;
}
function __parseTypeString(typeString) {
  const originalTypeString = typeString;
  typeString = typeString.trim();
  typeString = typeString.replace(/^\{/, "").replace(/\}$/, "");
  let isArray2 = false;
  if (typeString.match(/\)\[\]$/)) {
    isArray2 = true;
    typeString = typeString.replace(/\)\[\]$/, "").replace(/^\(/, "");
  }
  const firstTypes = [];
  let inSubLevel = 0, typeStr = "", areSubLevels = false;
  for (let i = 0; i < typeString.length; i++) {
    const char = typeString[i];
    if (["(", "<"].includes(char)) {
      inSubLevel++;
      areSubLevels = true;
      typeStr += "^";
    } else if ([")", ">"].includes(char)) {
      inSubLevel--;
      typeStr += "$";
    } else if (char === "|" && inSubLevel === 0) {
      firstTypes.push({
        areSubLevels,
        type: typeStr
      });
      typeStr = "";
    } else {
      typeStr += char;
    }
    if (inSubLevel < 0) {
      throw new Error(`It seems that your type string "${typeString}" is not valid...`);
    }
  }
  firstTypes.push({
    areSubLevels,
    type: typeStr
  });
  let finalTypes = [];
  firstTypes.forEach((type) => {
    if (type.areSubLevels) {
      finalTypes = [...finalTypes, ...__parseTypeString(type.type)];
    } else {
      finalTypes.push(parseSingleTypeString(type.type.replace("^", "<").replace("$", ">")));
    }
  });
  if (isArray2) {
    const result2 = [
      {
        type: "array",
        of: finalTypes
      }
    ];
    result2.__proto__.toString = () => originalTypeString;
    return result2;
  }
  finalTypes = __deepMap(finalTypes, ({ object, prop, value, path: path2 }) => {
    if (typeof value === "string") {
      value = value.replace(/^\./, "").trim();
    }
    return value;
  });
  Object.defineProperty(finalTypes, "toString", {
    get() {
      return () => originalTypeString;
    }
  });
  return finalTypes;
}
class STypeResult {
  /**
   * @name       typeString
   * @type       string
   * @get
   *
   * Access the type in string format
   *
   * @since     2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get typeString() {
    return this._data.typeString;
  }
  /**
   * @name       value
   * @type       string
   * @get
   *
   * Access the value passed to be type validated
   *
   * @since     2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get value() {
    return this._data.value;
  }
  /**
   * @name       received
   * @type       ISTypeResultReceived
   * @get
   *
   * Access the received descriptor object
   *
   * @since     2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get received() {
    return this._data.received;
  }
  /**
   * @name       expected
   * @type       ISTypeResultExpected
   * @get
   *
   * Access the expected descriptor object
   *
   * @since     2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get expected() {
    return this._data.expected;
  }
  /**
   * @name       issues
   * @type       ISTypeResultIssueObj[]
   * @get
   *
   * Access the issues array
   *
   * @since     2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get issues() {
    return this._data.issues;
  }
  /**
   * @name       settings
   * @type       ISTypeResultSettings
   * @get
   *
   * Access the settings object
   *
   * @since     2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get settings() {
    return this._data.settings;
  }
  /**
   * @name        constructor
   * @type        Function
   * @constructor
   *
   * Constructor
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  constructor(data2) {
    this._data = data2;
  }
  /**
   * @name          hasIssues
   * @type          Function
   *
   * Return true if some issues have been detected, false if not
   *
   * @return        {Boolean}       true if has some issues, false if not
   *
   * @since         2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  hasIssues() {
    if (this._data)
      return true;
    return false;
  }
  /**
   * @name             toString
   * @type              Functio n
   *
   * This method return a string terminal compatible or html of this result object
   *
   * @return        {String}                The result object in string format
   *
   * @since          2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  toString() {
    if (__isNode$2()) {
      return this.toConsole();
    } else {
      return `The method "toHtml" has not being integrated for now...`;
    }
  }
  /**
   * @name          toConsole
   * @type          Function
   *
   * This method simply returns you a terminal compatible string
   * of the interface checking result
   *
   * @return        {String}                A string compatible with the terminal
   *
   * @since         2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  toConsole() {
    const headerArray = [
      `<underline><magenta>${this._data.settings.name}</magenta></underline>`,
      "",
      "<underline>Received value</underline>",
      "",
      `${fn$5(this._data.value, {
        beautify: true
      })}`,
      ""
    ];
    const issuesArray = [];
    Object.keys(this._data.issues).forEach((ruleId) => {
      const issueObj = this._data.issues[ruleId];
      const message = [];
      if (issueObj.expected.type) {
        message.push(`- Expected "<yellow>${issueObj.expected.type}</yellow>"`);
      }
      if (issueObj.received.type) {
        message.push(`- Received "<red>${issueObj.received.type}</red>"`);
      }
      if (issueObj.message) {
        message.push(["<underline>Details:</underline>", issueObj.message].join("\n"));
      }
      issuesArray.push(message.join("\n"));
    });
    const settingsArray = [
      "",
      `<underline>Settings</underline>`,
      "",
      `${fn$5(this._data.settings, {
        beautify: true
      })}`
    ];
    return __parseHtml(`
${headerArray.join("\n")}
${issuesArray.join("\n")}
${this.settings.verbose ? settingsArray.join("\n") : ""}
    `).trim();
  }
}
function __isNode() {
  return typeof process !== "undefined" && process.release && process.release.name === "node";
}
function __getAvailableInterfaceTypes() {
  if (__isNode())
    return global._registeredInterfacesTypes || {};
  else if (window !== void 0)
    return window._registeredInterfacesTypes || {};
  else
    return {};
}
class SType {
  /**
   * @name      registerType
   * @type      Function
   * @static
   *
   * This static method allows you to register a new rule
   * by passing a valid ISDescriptorRule object
   *
   * @param     {ISDescriptorRule}        rule        The rule object to register
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com>
   */
  static registerType(type) {
    if (type.id === void 0 || typeof type.id !== "string") {
      throw new Error(`Sorry but you try to register a type that does not fit the ISTypeDescriptor interface...`);
    }
    this._registeredTypes[type.id] = type;
  }
  /**
   * @name      parseTypeString
   * @type      Function
   * @static
   *
   * This static method allows you to parse a type string.
   *
   * @param     {String}        typeString      The type string to parse
   * @return    {ITypeStringObject[]}             An array of object(s) describing the type string passed
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com>
   */
  static parseTypeString(typeString) {
    return __parseTypeString(typeString);
  }
  /**
   * @name      constructor
   * @type      Function
   * @constructor
   *
   * Constructor
   *
   * @since     2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  constructor(typeString, settings = {}) {
    this.typeString = typeString;
    typeString = typeString.toLowerCase().trim();
    if (this.constructor._instanciatedTypes[typeString] !== void 0)
      return this.constructor._instanciatedTypes[typeString];
    if (typeString.includes("[]")) {
      console.log(typeString);
    }
    this.types = __parseTypeString(typeString);
    if (typeString.includes("[]")) {
      console.log(this.types);
    }
    this.settings = __deepMerge({
      id: this.constructor.name,
      name: this.constructor.name,
      customTypes: true,
      interfaces: true
    }, settings);
    this.constructor._instanciatedTypes[typeString] = this;
  }
  /**
   * @name      is
   * @type      Function
   *
   * This method make a simple check to see if the passed value correspond to the
   * type that this instance represent.
   * Same as the ```check``` method, but return only a Boolean.
   *
   * @param     {Any}       value       The value to check
   * @param     {ISTypeSettings}        [settings={}]     Some settings to configure your check
   * @return    {Boolean}               true if correspond, false if not
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com>
   */
  is(value, settings = {}) {
    const res = this.check(value, settings);
    if (res === true)
      return true;
    else if (res instanceof STypeResult)
      return !res.hasIssues();
    return true;
  }
  /**
   * @name        check
   * @type        Function
   *
   * This method allows you to make sure the passed value correspond with the type(s)
   * this instance represent
   * If all is ok, return true, otherwise return an instance of the STypeResult class that
   * describe what is wrong
   *
   * @param     {Any}       value       The value to check
   * @param     {ISTypeSettings}        [settings={}]     Some settings to configure your check
   * @return    {Boolean|STypeResult}               true if correspond, an instance of the STypeResult class if not
   *
   * @since     2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com>
   */
  check(value, settings = {}) {
    settings = __deepMerge(this.settings, settings);
    const issues = {};
    for (let i = 0; i < this.types.length; i++) {
      const typeObj = this.types[i], typeId = typeObj.type;
      const res2 = this._isType(value, typeId, settings);
      if (res2 === true) {
        if (typeObj.of === void 0)
          return true;
        const typeOf2 = __typeOf(value);
        if (typeOf2 !== "Array" && typeOf2 !== "Object" && typeOf2 !== "Map") {
          throw new Error(`Sorry but you have specified a type string "<yellow>${this.typeString}</yellow>" with some "<...>" definition on a type "<cyan>${typeOf2}</cyan>" that does not support "child" value(s)...`);
        }
        const loopOn = typeOf2 === "Object" ? Object.keys(value) : Array.from(value.keys());
        if (!loopOn.length)
          return true;
        for (let k = 0; k < loopOn.length; k++) {
          for (let j = 0; j < typeObj.of.length; j++) {
            const type = typeObj.of[j];
            const idx = loopOn[k];
            const v2 = typeOf2 === "Map" ? value.get(idx) : value[idx];
            const ofRes = this._isType(v2, type, settings);
            if (ofRes !== true) {
              issues[typeObj.type] = {
                expected: {
                  type: typeObj.type
                },
                received: {
                  type: __typeOf(v2),
                  value: v2
                }
              };
            } else {
              return true;
            }
          }
        }
      } else {
        const issueObj = {
          expected: {
            type: typeObj.type
          },
          received: {
            type: __typeOf(value),
            value
          }
        };
        if (res2 !== void 0 && res2 !== null && res2 !== false && res2.toString && typeof res2.toString === "function") {
          issueObj.message = res2.toString();
        }
        issues[typeObj.type] = issueObj;
      }
    }
    const res = new STypeResult({
      typeString: this.typeString,
      value,
      expected: {
        type: this.typeString
      },
      received: {
        type: __typeOf(value)
      },
      issues,
      settings
    });
    return res;
  }
  /**
   * @name          _isType
   * @type          Function
   * @private
   *
   * This method simply take a type string like "string", "array", etc..., a value and
   * check if this value correspond to the passed type
   *
   * @param     {Any}       value       The value to validate
   * @param     {String}    type        The type to check the value with
   * @return    {Boolean}               true if all if ok, false if not
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com>
   */
  _isType(value, type, settings = {}) {
    settings = __deepMerge(this.settings, settings);
    if (this.constructor._registeredTypes[type.toLowerCase()] === void 0) {
      if (settings.interfaces === true) {
        const availableInterfaceTypes = __getAvailableInterfaceTypes();
        if (availableInterfaceTypes[type] !== void 0) {
          const res = availableInterfaceTypes[type].apply(value, {});
          return res;
        }
      }
      if (settings.customTypes === true) {
        const typeOf2 = __typeOf(value).toLowerCase();
        const extendsStack = Object.keys(fn$4(value)).map((s) => s.toLowerCase());
        if (type === typeOf2 || extendsStack.indexOf(type) !== -1)
          return true;
      }
      throw new Error(`Sorry but you try to validate a value with the type "<yellow>${type}</yellow>" but this type is not registered...`);
    }
    return this.constructor._registeredTypes[type.toLowerCase()].is(value);
  }
  /**
   * @name          cast
   * @type          Function
   *
   * This method allows you to cast the passed value to the wanted type.
   * !!! If multiple types are passed in the typeString, the first one that
   * is "castable" to will be used.
   *
   * @param     {Any}         value         The value you want to cast
   * @param     {ISTypeSettings}      [settings={}]       Some settings you want to override
   * @return    {Any|Error}                         The casted value, or undefined if cannot be casted
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com>
   */
  cast(value, params, settings) {
    settings = __deepMerge(this.settings, settings);
    const verboseObj = {
      value,
      issues: {},
      settings,
      toString() {
        const strAr = Object.entries(this.issues);
        return strAr.map((l) => l[1]).join("\n");
      }
    };
    if (this.is(value)) {
      return value;
    }
    for (let i = 0; i < this.types.length; i++) {
      const typeObj = this.types[i], typeId = typeObj.type;
      const descriptorObj = this.constructor._registeredTypes[typeId.toLowerCase()];
      if (descriptorObj === void 0) {
        continue;
      }
      if (descriptorObj.cast === void 0)
        continue;
      let castedValue;
      castedValue = descriptorObj.cast(value, params);
      if (castedValue instanceof Error) {
        verboseObj.issues[typeId] = castedValue.toString();
        continue;
      }
      if (typeObj.of !== void 0 && this.canHaveChilds(castedValue) === false) {
        const issueStr = `Sorry but the passed type "<yellow>${typeId}</yellow>" has some child(s) dependencies "<green>${typeObj.of.join("|")}</green>" but this type can not have child(s)`;
        throw new Error(__parseHtml(issueStr));
      } else if (typeObj.of !== void 0) {
        const sTypeInstance = new SType(typeObj.of.join("|"));
        castedValue = fn$2(castedValue, ({ value: value2 }) => {
          return sTypeInstance.cast(value2, params, settings);
        });
      }
      if (castedValue === null && descriptorObj.id === "null")
        return null;
      if (castedValue === void 0 && descriptorObj.id === "undefined")
        return void 0;
      if (castedValue !== null && castedValue !== void 0)
        return castedValue;
      verboseObj.issues[typeId] = `Something goes wrong but no details are available... Sorry`;
    }
    const stack = [
      `Sorry but the value of type "<cyan>${__typeOf(value)}</cyan>" passed to be casted in type "<yellow>${this.typeString}</yellow>" can not be casted correctly. Here's why:
`
    ];
    Object.keys(verboseObj.issues).forEach((descriptorId) => {
      stack.push(`- <red>${descriptorId}</red>: ${verboseObj.issues[descriptorId]}`);
    });
    throw new Error(__parseHtml(stack.join("\n")));
  }
  /**
   * @name          canHaveChilds
   * @type          Function
   *
   * This method simply take a value and return true if can have child(s), false if not
   *
   * @param       {Any}       value       The value to check
   * @return      {Boolean}         true if can have child(s) (Object, Array and Map), false if not
   *
   * @since     2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com>
   */
  canHaveChilds(value) {
    const type = __typeOf(value);
    return type === "Array" || type === "Object" || type === "Map";
  }
  /**
   * @name          name
   * @type          String
   * @get
   *
   * Access the descriptor name. Either the value of settings.name, or the constructor name
   *
   * @since         2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com>
   */
  get name() {
    return this.settings.name;
  }
  /**
   * @name          id
   * @type          String
   * @get
   *
   * Access the descriptor id. Either the value of settings.name, or the constructor name
   *
   * @since         2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com>
   */
  get id() {
    return this.settings.id;
  }
}
SType._instanciatedTypes = {};
SType._registeredTypes = {};
const descriptor$g = {
  name: "Array",
  id: "array",
  is: (value) => {
    return Array.isArray(value);
  },
  cast: (value, params = {}) => {
    if (!value)
      return [];
    if (params.splitChars && Array.isArray(params.splitChars)) {
      if (value === true)
        value = "";
      value = value.split(new RegExp(`(${params.splitChars.join("|")})`, "gm")).filter((l) => l.trim() !== "" && params.splitChars.indexOf(l) === -1);
    }
    if (Array.isArray(value))
      return value;
    return [value];
  }
};
const descriptor$f = {
  name: "Bigint",
  id: "bigint",
  is: (value) => typeof value === "bigint",
  cast: (value) => {
    if (typeof value === "bigint")
      return value;
    if (typeof value !== "string" && typeof value !== "number") {
      return new Error(`Sorry but only <yellow>String</yellow> and <yellow>Number</yellow> can be casted to <green>Bigint</green>`);
    }
    let res;
    try {
      res = BigInt(value);
    } catch (e) {
      res = new Error(`It seem's that the passed value "<yellow>${value}</yellow>" can not be casted to a <green>BigInt</green>`);
    }
    return res;
  }
};
const descriptor$e = {
  name: "Boolean",
  id: "boolean",
  is: (value) => typeof value === "boolean",
  cast: (value, params = {}) => {
    if (value !== false && params && params.nullishAsTrue && !value) {
      return true;
    }
    if (typeof value === "boolean")
      return value;
    if (value === null || value === void 0)
      return false;
    if (typeof value === "number") {
      if (value > 0)
        return true;
      return false;
    }
    if (typeof value === "string") {
      return value.length > 0 ? true : false;
    }
    if (Array.isArray(value)) {
      if (value.length > 0)
        return true;
      return false;
    }
    if (typeof value === "object") {
      return Object.keys(value).length > 0 ? true : false;
    }
    return new Error([
      `Sorry but for now only these types can be casted to boolean:`,
      "- <yellow>null</yellow>: Will be casted as <red>false</red>",
      "- <yellow>undefined</yellow>: Will be casted as <red>false</red>",
      "- <yellow>Number</yellow>: Will be casted as <green>true</green> when greater than 0, <red>false</red> otherwise",
      "- <yellow>String</yellow>: Will be casted as <green>true</green> when longer than 0 characters, <red>false</red> otherwise",
      "- <yellow>Array</yellow>: Will be casted as <green>true</green> when having more than 0 items, <red>false</red> otherwise",
      "- <yellow>Object</yellow>: Will be casted as <green>true</green> when have more than 0 properties, <red>false</red> otherwise"
    ].join("\n"));
  }
};
const descriptor$d = {
  name: "Class",
  id: "class",
  is: (value) => isClass(value),
  cast: (value) => {
    return new Error(`Sorry but nothing is castable to a Class`);
  }
};
const descriptor$c = {
  name: "Date",
  id: "date",
  is: (value) => value instanceof Date,
  cast: (value) => {
    if (typeof value === "string") {
      return new Date(value);
    }
    if (typeof value === "number") {
      return new Date(Math.round(value));
    }
    if (__isPlainObject(value)) {
      const now = /* @__PURE__ */ new Date();
      let year = now.getFullYear(), month = 0, day = 1, hours = 0, minutes = 0, seconds = 0, milliseconds = 0;
      if (value.year && typeof value.year === "number") {
        year = value.year;
      }
      if (value.month && typeof value.month === "number") {
        month = value.month;
      }
      if (value.day && typeof value.day === "number") {
        day = value.day;
      }
      if (value.hours && typeof value.hours === "number") {
        hours = value.hours;
      }
      if (value.minutes && typeof value.minutes === "number") {
        minutes = value.minutes;
      }
      if (value.seconds && typeof value.seconds === "number") {
        seconds = value.seconds;
      }
      if (value.milliseconds && typeof value.milliseconds === "number") {
        milliseconds = value.milliseconds;
      }
      return new Date(year, month, day, hours, minutes, seconds, milliseconds);
    }
    return new Error(`Sorry but for now only <yellow>String</yellow>, <yellow>Number</yellow> and <yellow>Object</yellow> (with properties: year, month, day?, hours?, minutes?, seconds? and milliseconds?) are castable to Date`);
  }
};
const descriptor$b = {
  name: "Function",
  id: "function",
  is: (value) => typeof value === "function",
  cast: (value) => {
    return new Error(`Sorry but nothing is castable to a Function`);
  }
};
const descriptor$a = {
  name: "Integer",
  id: "integer",
  is: (value) => Number.isInteger(value),
  cast: (value) => {
    if (typeof value !== "string" && typeof value !== "number") {
      return new Error(`Sorry but only strings and numbers can be casted to integers... Passed value: ${value}`);
    }
    const res = parseInt(value);
    if (isNaN(res))
      return new Error(`Sorry but the conversion of "<yellow>${value}</yellow>" to a <green>Integer</green> does not work...`);
    return res;
  }
};
const descriptor$9 = {
  name: "Map",
  id: "map",
  is: (value) => __isMap(value),
  cast: (value) => {
    if (__isMap(value))
      return value;
    const map2 = /* @__PURE__ */ new Map();
    map2.set("value", value);
    return map2;
  }
};
const descriptor$8 = {
  name: "Null",
  id: "null",
  is: (value) => value === null,
  cast: (value) => {
    return null;
  }
};
const descriptor$7 = {
  name: "Number",
  id: "number",
  is: (value) => typeof value === "number",
  cast: (value) => {
    if (typeof value !== "string") {
      return new Error(`Sorry but only strings can be casted to numbers...`);
    }
    const res = parseFloat(value);
    if (isNaN(res)) {
      return new Error(`Sorry but the conversion of "<yellow>${value}</yellow>" to a <green>Number</green> does not work...`);
    }
    return res;
  }
};
const descriptor$6 = {
  name: "Object",
  id: "object",
  is: (value) => __isObject(value),
  cast: (value) => {
    if (__isObject(value))
      return value;
    return {
      value
    };
  }
};
const descriptor$5 = {
  name: "Set",
  id: "set",
  is: (value) => value instanceof Set,
  cast: (value) => {
    if (value instanceof Set)
      return value;
    const set2 = /* @__PURE__ */ new Set();
    set2.add(value);
    return set2;
  }
};
const descriptor$4 = {
  name: "String",
  id: "string",
  is: (value) => {
    return __isString(value);
  },
  cast: (value) => fn$5(value, {
    beautify: true
  })
};
const descriptor$3 = {
  name: "Symbol",
  id: "symbol",
  is: (value) => typeof value === "symbol",
  cast: (value) => {
    if (typeof value === "symbol")
      return value;
    return Symbol(value);
  }
};
const descriptor$2 = {
  name: "Undefined",
  id: "undefined",
  is: (value) => value === void 0,
  cast: (value) => {
    return void 0;
  }
};
const descriptor$1 = {
  name: "WeakMap",
  id: "weakmap",
  is: (value) => value instanceof WeakMap,
  cast: (value) => {
    return new Error(`Sorry but nothing can be casted to a WeakMap for now`);
  }
};
const descriptor = {
  name: "WeakSet",
  id: "weakset",
  is: (value) => value instanceof WeakSet,
  cast: (value) => {
    return new Error(`Sorry but nothing can be casted to a WeakSet for now`);
  }
};
SType.registerType(descriptor$4);
SType.registerType(descriptor$9);
SType.registerType(descriptor$6);
SType.registerType(descriptor$g);
SType.registerType(descriptor$a);
SType.registerType(descriptor$7);
SType.registerType(descriptor$e);
SType.registerType(descriptor$2);
SType.registerType(descriptor$8);
SType.registerType(descriptor$3);
SType.registerType(descriptor$f);
SType.registerType(descriptor$c);
SType.registerType(descriptor$b);
SType.registerType(descriptor$1);
SType.registerType(descriptor);
SType.registerType(descriptor$5);
SType.registerType(descriptor$d);
class SDescriptorResult extends SClass {
  /**
   * @name      constructor
   * @type      Function
   * @constructor
   *
   * Constructor
   *
   * @since     2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  constructor(descriptor2, value, descriptorSettings) {
    super({});
    this._issues = {};
    this._descriptor = descriptor2;
    this._descriptorSettings = descriptorSettings;
    try {
      this._originalValue = clone(value, { deep: true });
    } catch (e) {
      this._originalValue = value;
    }
    this.value = value;
  }
  /**
   * @name           hasIssues
   * @type           Function
   *
   * This method return true if theirs no issues, false if not
   *
   * @return        {Boolean}           true if no issue(s), false if not
   *
   * @since          2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  hasIssues() {
    return Object.keys(this._issues).length >= 1;
  }
  /**
   * @name           add
   * @type           Function
   *
   * This method is used to add a rule result to the global descriptor result.
   *
   * @param         {ISDescriptorResultRule}        ruleResult      The rule result object you want to add
   *
   * @since          2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  add(ruleResult) {
    if (!ruleResult.__ruleObj.id)
      return;
    this._issues[ruleResult.__ruleObj.id] = ruleResult;
  }
  /**
   * @name             toString
   * @type              Functio n
   *
   * This method return a string terminal compatible of this result object
   *
   * @return        {String}                The result object in string format
   *
   * @since          2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  toString() {
    if (__isNode$2()) {
      return this.toConsole();
    } else {
      return this.toConsole();
    }
  }
  /**
   * @name             toConsole
   * @type              Function
   *
   * This method return a string terminal compatible of this result object
   *
   * @return        {String}                The result object in string format
   *
   * @since          2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  toConsole() {
    const headerArray = [
      `<underline><magenta>${this._descriptor.metas.name}</magenta></underline>`,
      "",
      `${fn$5(this.value, {
        beautify: true
      })}`,
      ""
    ];
    const issuesArray = [];
    Object.keys(this._issues).forEach((ruleId) => {
      const ruleResult = this._issues[ruleId];
      let message = "";
      if (ruleResult.__error && ruleResult.__error instanceof Error) {
        message = ruleResult.__error.message;
      } else if (ruleResult.__ruleObj.message !== void 0 && typeof ruleResult.__ruleObj.message === "function") {
        message = ruleResult.__ruleObj.message(ruleResult);
      } else if (ruleResult.__ruleObj.message !== void 0 && typeof ruleResult.__ruleObj.message === "string") {
        message = ruleResult.__ruleObj.message;
      }
      issuesArray.push(`-${typeof ruleResult.__propName === "string" ? ` [<magenta>${ruleResult.__propName}</magenta>]` : ""} <red>${ruleId}</red>: ${message}`);
    });
    const settingsArray = [
      "",
      `<underline>Settings</underline>`,
      "",
      `${fn$5(this._descriptorSettings, {
        beautify: true
      })}`
    ];
    return __parseHtml(`
${headerArray.join("\n")}
${issuesArray.join("\n")}
${settingsArray.join("\n")}
    `).trim();
  }
}
class SDescriptor extends SClass {
  /**
   * @name      registerRule
   * @type      Function
   * @static
   *
   * This static method allows you to register a new rule
   * by passing a valid ISDescriptorRule object
   *
   * @param     {ISDescriptorRule}        rule        The rule object to register
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com>
   */
  static registerRule(rule) {
    if (rule.id === void 0 || typeof rule.id !== "string") {
      throw new Error(`Sorry but you try to register a rule that does not fit the ISDescriptionRule interface...`);
    }
    this._registeredRules[rule.id] = rule;
  }
  /**
   * @name      constructor
   * @type      Function
   * @constructor
   *
   * Constructor
   *
   * @since     2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  constructor(settings) {
    super(__deepMerge({
      rules: {},
      type: "Object",
      arrayAsValue: false,
      throwOnMissingRule: false,
      defaults: true
    }, settings !== null && settings !== void 0 ? settings : {}));
  }
  /**
   * @name          apply
   * @type          Function
   *
   * This method simply apply the descriptor instance on the passed value.
   * The value can be anything depending on the descriptor you use.
   * When you pass an Array, by default it will apply the descriptor on
   * each array items. If you don't want this behavior and the Array passed has to be
   * treated as a single value, pass the "arrayAsValue" setting to true
   *
   * @param       {Any}       value         The value to apply the descriptor on
   * @param       {ISDescriptorSettings}        [settings={}]       An object of settings to configure your descriptor. These settings will override the base ones passed in the constructor
   * @return      {ISDescriptorResultObj|true}           Will return true if all is ok, and an object describing the issue if not
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  apply(value, settings) {
    const set2 = __deepMerge(this.settings, settings || {});
    if (value === void 0 || value === null)
      value = {};
    const valuesObjToProcess = {}, finalValuesObj = {};
    this._descriptorResult = new SDescriptorResult(this, finalValuesObj, Object.assign({}, set2));
    const rules2 = set2.rules;
    const typeInstance = new SType(set2.type);
    if (!typeInstance.is(value)) {
      throw new Error(`Sorry but this descriptor "<yellow>${this.metas.name}</yellow>" does not accept values of type "<cyan>${__typeOf(value)}</cyan>" but only "<green>${set2.type}</green>"...`);
    }
    if (Array.isArray(value) && !set2.arrayAsValue) {
      throw new Error(`Sorry but the support for arrays like values has not been integrated for not...`);
    } else if (typeof value === "object" && value !== null && value !== void 0) {
      Object.keys(rules2).forEach((propName) => {
        if (__isGlob(propName) && value)
          ;
        else {
          valuesObjToProcess[propName] = get(value, propName);
        }
      });
      Object.keys(valuesObjToProcess).forEach((propName) => {
        const ruleObj2 = rules2[propName];
        if (valuesObjToProcess[propName] === void 0 && set2.defaults && ruleObj2.default !== void 0) {
          valuesObjToProcess[propName] = ruleObj2.default;
        }
        if (ruleObj2.interface !== void 0) {
          const interfaceValue = valuesObjToProcess[propName];
          valuesObjToProcess[propName] = ruleObj2.interface.apply(interfaceValue || {}, {});
        }
        const validationResult = this._validate(valuesObjToProcess[propName], propName, ruleObj2, set2);
        if (validationResult !== void 0 && validationResult !== null) {
          __set(finalValuesObj, propName, validationResult);
        }
      });
    } else {
      console.warn(value);
      throw new Error(`You can apply an <yellow>SDescriptor</yellow> only on an Object like value...`);
    }
    if (this._descriptorResult.hasIssues()) {
      throw new Error(this._descriptorResult.toString());
    }
    return this._descriptorResult;
  }
  /**
   * @name          _validate
   * @type          Function
   * @private
   *
   * This method take a value and validate it using the defined rules
   *
   * @param       {Any}       value       The value to validate
   * @return      {ISDescriptionValidationResult|true}        true if the validation has been made correctly, an object describing the issue if not
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  _validate(value, propName, rulesObj, settings) {
    if (rulesObj === void 0)
      return value;
    if (rulesObj.required === void 0 || rulesObj.required === false) {
      if (value === void 0 || value === null)
        return value;
    }
    let rulesNamesInOrder = Object.keys(rulesObj).filter((l) => l !== "default");
    rulesNamesInOrder = rulesNamesInOrder.sort((a, b) => {
      const objA = this.constructor._registeredRules[a];
      const objB = this.constructor._registeredRules[b];
      if (!objA)
        return -1;
      if (!objB)
        return 1;
      if (objA.priority === void 0)
        objA.priority = 9999999999;
      if (objB.priority === void 0)
        objB.priority = 9999999999;
      return objA.priotity - objB.priority;
    }).reverse();
    let resultValue = value;
    rulesNamesInOrder.forEach((ruleName) => {
      const ruleValue = rulesObj[ruleName];
      if (this.constructor._registeredRules[ruleName] === void 0) {
        if (settings.throwOnMissingRule) {
          throw new Error(`Sorry but you try to validate a value using the "<yellow>${ruleName}</yellow>" rule but this rule is not registered. Here's the available rules:
              - ${Object.keys(this.constructor._registeredRules).join("\n- ")}`);
        }
      } else {
        const ruleObj2 = this.constructor._registeredRules[ruleName];
        const params = ruleObj2.processParams !== void 0 ? ruleObj2.processParams(ruleValue) : ruleValue;
        const ruleSettings = ruleObj2.settings !== void 0 ? ruleObj2.settings : {};
        if (ruleSettings.mapOnArray && Array.isArray(resultValue)) {
          let newResultValue = [];
          resultValue.forEach((v2) => {
            const processedValue = this._processRule(v2, ruleObj2, propName, params, ruleSettings, settings);
            if (Array.isArray(processedValue)) {
              newResultValue = [
                ...newResultValue,
                ...processedValue
              ];
            } else {
              newResultValue.push(processedValue);
            }
          });
          resultValue = newResultValue;
        } else {
          const processedValue = this._processRule(resultValue, ruleObj2, propName, params, ruleSettings, settings);
          resultValue = processedValue;
        }
      }
    });
    return resultValue;
  }
  _processRule(value, ruleObj2, propName, params, ruleSettings, settings) {
    const ruleResult = ruleObj2.apply(value, params, ruleSettings, Object.assign(Object.assign({}, settings), { propName, name: `${settings.name}.${propName}` }));
    if (params && params.type && params.type.toLowerCase() === "boolean" && ruleResult === true) {
      return true;
    }
    if (ruleResult instanceof Error) {
      const obj = {
        __error: ruleResult,
        __ruleObj: ruleObj2,
        __propName: propName
      };
      if (this._descriptorResult) {
        this._descriptorResult.add(obj);
        throw new Error(this._descriptorResult.toString());
      }
    } else {
      return ruleResult;
    }
  }
}
SDescriptor._registeredRules = {};
SDescriptor.rules = {};
SDescriptor.type = "Object";
const ruleObj$3 = {
  name: "Max",
  id: "max",
  settings: {},
  accept: "Number",
  message: (resultObj) => {
    return `This value has to be maximum "<yellow>${resultObj.max}</yellow>". Received "<red>${resultObj.received}</red>"`;
  },
  processParams: (params) => {
    return { value: params };
  },
  apply: (value, params, ruleSettings, settings) => {
    if (value > params.value) {
      return new Error(`<red>[minRule]</red> Sorry but the passed value "<yellow>${value}</yellow>" must be lower or equal at <cyan>${params.value}</cyan>`);
    }
    return value;
  }
};
const ruleObj$2 = {
  name: "Min",
  id: "min",
  settings: {},
  accept: "Number",
  message: (resultObj) => {
    return `This value has to be minimum "<yellow>${resultObj.min}</yellow>". Received "<red>${resultObj.received}</red>"`;
  },
  processParams: (params) => {
    return { value: params };
  },
  apply: (value, params, ruleSettings, settings) => {
    if (value < params.value) {
      return new Error(`<red>[minRule]</red> Sorry but the passed value "<yellow>${value}</yellow>" must be greater or equal at <cyan>${params.value}</cyan>`);
    }
    return value;
  }
};
const ruleObj$1 = {
  priority: 1,
  name: "Required",
  id: "required",
  settings: {
    when: [void 0, null]
  },
  message: "This value is required",
  processParams: (params) => {
    return { value: params };
  },
  apply: (value, params, ruleSettings, settings) => {
    if (params.value === true) {
      if (ruleSettings.when.indexOf(value) !== -1) {
        return new Error("This property is <yellow>required</yellow>");
      }
    }
    return value;
  }
};
const ruleObj = {
  prority: 10,
  name: "Type",
  id: "type",
  settings: {},
  processParams: (params) => {
    var _a2, _b2;
    if (!(params === null || params === void 0 ? void 0 : params.type) && typeof params !== "string") {
      throw new Error(`<yellow>[sugar.shared.type.descriptors.typeRule]</yellow> Sorry but to use the <magenta>type</magenta> descriptor rule you need to specify a type string either directly under the "type" property, or in an object under the "type.type" property...`);
    }
    return Object.assign(Object.assign({}, typeof params !== "string" ? params : {}), { type: (_a2 = params.type) !== null && _a2 !== void 0 ? _a2 : params, cast: (_b2 = params.cast) !== null && _b2 !== void 0 ? _b2 : true });
  },
  apply: (value, params, ruleSettings, settings) => {
    const type = new SType(params.type, {
      metas: {
        id: settings.id
      }
    });
    if (params.cast && !type.is(value)) {
      value = type.cast(value, params);
    }
    if (!type.is(value)) {
      return new Error(`The value must be of type "<yellow>${params.type}</yellow>" but you've passed a value of type "<cyan>${typeof value}</cyan>"`);
    }
    return value;
  }
};
SDescriptor.registerRule(ruleObj$1);
SDescriptor.registerRule(ruleObj);
SDescriptor.registerRule(ruleObj$2);
SDescriptor.registerRule(ruleObj$3);
function __parseArgs(string, settings) {
  settings = __deepMerge({
    valueQuote: void 0,
    treatNoAsBoolean: true,
    camelCase: true
  }, settings !== null && settings !== void 0 ? settings : {});
  string = string.trim();
  string = string.replace(/(["'`])--/gm, "$1--§ --");
  if (settings.treatNoAsBoolean) {
    const noMatches = string.match(/--no-[\w]+/g);
    noMatches === null || noMatches === void 0 ? void 0 : noMatches.forEach((match2) => {
      string = string.replace(match2, `${match2.replace("--no-", "--")} false`);
    });
  }
  let valueQuote = settings.valueQuote;
  if (!valueQuote) {
    for (let i = 0; i < string.length; i++) {
      const char = string[i];
      if (char === '"' || char === "`" || char === "'") {
        valueQuote = char;
        break;
      }
    }
    if (!valueQuote)
      valueQuote = '"';
  }
  let stringArray = [];
  let isFunctionStyle = false;
  if (string.match(/^\(/) && string.match(/\)$/)) {
    isFunctionStyle = true;
    string = string.slice(1, -1);
    let currentStr = "";
    let parenthesisCount = 0;
    let quotesCount = 0;
    for (let i = 0; i < string.length; i++) {
      const char = string[i];
      const previousChar = string[i - 1] || string[0];
      if (char === valueQuote && previousChar !== "\\" && !quotesCount) {
        quotesCount++;
      } else if (char === valueQuote && previousChar !== "\\" && quotesCount) {
        quotesCount--;
      }
      if (!quotesCount && char === "(") {
        parenthesisCount++;
      } else if (!quotesCount && char === ")") {
        parenthesisCount--;
      }
      if (char === ",") {
        if (quotesCount || parenthesisCount) {
          currentStr += char;
        } else {
          stringArray.push(currentStr.trim());
          currentStr = "";
        }
      } else {
        currentStr += char;
      }
    }
    if (parenthesisCount)
      currentStr += ")".repeat(parenthesisCount);
    stringArray.push(currentStr.trim());
  } else {
    let currentStr = "";
    let quotesCount = false;
    for (let i = 0; i < string.length; i++) {
      const char = string[i];
      const previousChar = string[i - 1] || string[0];
      if (char === valueQuote && previousChar !== "\\" && !quotesCount) {
        quotesCount = true;
      } else if (char === valueQuote && previousChar !== "\\" && quotesCount) {
        quotesCount = false;
      }
      if (char === " ") {
        if (quotesCount) {
          currentStr += char;
        } else {
          stringArray.push(currentStr.trim());
          currentStr = "";
        }
      } else {
        currentStr += char;
      }
    }
    stringArray.push(currentStr.trim());
  }
  if (stringArray)
    stringArray = stringArray.map((item) => __unquote(item));
  let argsObj = {};
  let currentArgName = void 0;
  let currentValue;
  stringArray = stringArray.forEach((part, i) => {
    if (!isFunctionStyle && !part.includes(" ") && (part.slice(0, 2) === "--" || part.slice(0, 1) === "-")) {
      if (currentValue === void 0 && currentArgName !== -1 && currentArgName && argsObj[currentArgName] === void 0) {
        argsObj[currentArgName] = true;
      }
      currentArgName = part.replace(/^[-]{1,2}/, "");
      if (argsObj[currentArgName] === void 0) {
        argsObj[currentArgName] = true;
      }
    } else {
      let value;
      if (part && typeof part === "string") {
        value = part.replace(/^\\\\\\`/, "").replace(/\\\\\\`$/, "").replace(/^'/, "").replace(/'$/, "").replace(/^"/, "").replace(/"$/, "");
        if (value.match(/^\$[a-zA-Z0-9-_]+\s?:.*/)) {
          const parts = part.split(":");
          currentArgName = parts[0].trim().replace(/^\$/, "");
          value = parts.slice(1).join(":").trim();
        }
      }
      currentValue = __parse(value);
      if (typeof currentValue === "string") {
        currentValue = currentValue.replace("--§ ", "");
      }
      if (currentArgName !== void 0) {
        if (argsObj[currentArgName] !== void 0 && argsObj[currentArgName] !== true) {
          if (!Array.isArray(argsObj[currentArgName])) {
            argsObj[currentArgName] = [argsObj[currentArgName]];
          }
          argsObj[currentArgName].push(currentValue);
        } else {
          argsObj[currentArgName] = currentValue;
        }
        currentValue = void 0;
        currentArgName = void 0;
      } else {
        argsObj[i] = currentValue;
      }
    }
  });
  if (settings.camelCase) {
    argsObj = __camelCaseProps(argsObj);
  }
  Object.keys(argsObj).forEach((key) => {
    const value = argsObj[key];
    if (value === void 0)
      delete argsObj[key];
  });
  return argsObj;
}
try {
  if (global)
    global._registeredInterfacesTypes = {};
  else
    window._registeredInterfacesTypes = {};
} catch (e) {
}
class SInterface extends SClass {
  static get definition() {
    var _a2, _b2;
    if (this._cachedDefinition)
      return this._cachedDefinition;
    this._cachedDefinition = (_a2 = this._definition) !== null && _a2 !== void 0 ? _a2 : {};
    for (let [prop, value] of Object.entries(this._cachedDefinition)) {
      if (typeof ((_b2 = value.type) === null || _b2 === void 0 ? void 0 : _b2.type) === "string") {
        if (value.type.type.match(/\[\]/)) {
          this._cachedDefinition[prop].type.type = value.type.type.replace(/([a-zA-Z0-9-_]+)\[\]/gm, "Array<$1>");
          continue;
        }
      }
      if (typeof value.type === "string") {
        if (value.type.match(/\[\]/)) {
          this._cachedDefinition[prop].type = value.type.replace(/([a-zA-Z0-9-_]+)\[\]/gm, "Array<$1>");
        }
      }
    }
    return this._cachedDefinition;
  }
  static set definition(value) {
    this._cachedDefinition = value;
  }
  static registerRenderer(rendererClass) {
    if (!rendererClass.id) {
      throw new Error(`Sorry but the interface renderer "<yellow>${rendererClass.name}</yellow>" that you want to register is missing the required <yellow>static</yellow> <green>id</green> property...`);
    }
    this._registeredRenderers[rendererClass.id] = rendererClass;
  }
  /**
   * @name      mix
   * @type      Function
   * @static
   *
   * This static method allows you to mix multiple interfaces into one
   *
   * @param     {SInterface[]}      ...ints       The interfaces to mix together
   * @return    {SInterface}                          The mixed interface
   *
   * @since     2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static mix(...ints) {
    const newInt = new SInterface();
    ints.forEach((int) => {
      if (int.definition) {
        newInt.definition = __deepMerge(newInt.definition, int.definition);
      }
    });
    return newInt;
  }
  /**
   * @name      overrie
   * @type      Function
   * @static
   *
   * This static method is usefull to make a duplicate of the base interface with some updates
   * in the definition object.
   *
   * @param     {Object}      definition      A definition object to override or extends the base one
   * @return    {SInterface}                  A new interface overrided with your new values
   *
   * @since     2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static override(definition) {
    const _this = this;
    class SInterfaceOverrided extends this {
    }
    SInterfaceOverrided.overridedName = `${_this.name} (overrided)`;
    SInterfaceOverrided.definition = __deepMerge(_this.definition, definition);
    return SInterfaceOverrided;
  }
  /**
   * @name            isDefault
   * @type            Function
   * @static
   *
   * This static method allows you to check if a certain value is the default of a certain property or not.
   *
   * @param           {String}            prop        The property to check if it's the default of or not
   * @param           {Any}               value       The value to check with
   * @return          {Boolean}                       true if is the default value, false if not
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static isDefault(prop, value) {
    const defaults = this.defaults();
    if (defaults[prop] === void 0) {
      return false;
    }
    if (defaults[prop] === value) {
      return true;
    }
    return false;
  }
  /**
   * @name            getAvailableTypes
   * @type            Function
   * @static
   *
   * This static method allows you to get the types that have been make widely available
   * using the ```makeAvailableAsType``` method.
   *
   * @return      {Object<SInterface>}          An object listing all the interface types maked available widely
   *
   * @since     2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static getAvailableTypes() {
    return getAvailableInterfaceTypes();
  }
  /**
   * @name            makeAvailableAsType
   * @type            Function
   * @static
   *
   * This static method allows you to promote your interface at the level where it can be
   * used in the "type" interface definition property like so "Object<MyCoolType>"
   *
   * @param       {String}      [name=null]       A custom name to register your interface. Otherwise take the class name and register two types: MyClassInterface => MyClassInterface && MyClass
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static makeAvailableAsType(name2 = null) {
    const n = (name2 || this.name).toLowerCase();
    if (global !== void 0) {
      global._registeredInterfacesTypes[n] = this;
      global._registeredInterfacesTypes[n.replace("interface", "")] = this;
    } else if (window !== void 0) {
      window._registeredInterfacesTypes[n] = this;
      window._registeredInterfacesTypes[n.replace("interface", "")] = this;
    }
  }
  /**
   * @name              toObject
   * @type              Function
   * @static
   *
   * This function allows you to get back a simple object describing the interface
   *
   * @return              {ISInterfaceObj}                The interface in plain object format
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static toObject() {
    var _a2;
    return {
      name: this.name,
      description: (_a2 = this.description) !== null && _a2 !== void 0 ? _a2 : "",
      definition: Object.assign({}, this.definition)
    };
  }
  /**
   * @name              defaults
   * @type              Function
   * @static
   *
   * This function simply returns you the default interface values in object format
   *
   * @since         2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static defaults() {
    const defaults = {};
    Object.keys(this.definition).forEach((key) => {
      const propObj = this.definition[key];
      if (propObj.default !== void 0) {
        defaults[key] = propObj.default;
      }
    });
    return defaults;
  }
  /**
   * @name              apply
   * @type              Function
   * @static
   *
   * This static method allows you to apply the interface on an object instance.
   * By default, if something is wrong in your class implementation, an error with the
   * description of what's wrong will be thrown. You can change that behavior if you prefer having
   * true returned when all is ok, or a string describing the current issue by specify the "settings.throw" property to false.
   *
   * @param       {Any}                objectOrString              The object on which to apply the interface on, or a cli string to use as input
   * @param       {ISInterfaceSettings}               [settings={}]         An object of settings to configure your apply process
   * - return (String) {String}: Specify in which return you want the result back. Can be "String" of "Object".
   * @return      {Boolean|String}                              true if all is ok, a string describing the issue if not...
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static apply(objectOrString, settings) {
    const int = new this({
      interface: settings !== null && settings !== void 0 ? settings : {}
    });
    return int.apply(objectOrString);
  }
  /**
   * @name            help
   * @type            Function
   * @static
   *
   * This static method allows you to get back the help using the
   * passed renderer. Awailable rendered are for now:
   * - terminal (default): The default terminal renderer
   * - more to come depending on needs...
   *
   * @param         {String}          [renderer="terminal"]        The registered renderer you want to use.
   * @param         {ISInterfaceRendererSettings}     [settings={}]     Some settings to configure your render
   *
   * @setting     {'terminal'}        [renderer="terminal"]       The renderer you want to use.
   * @setting     {Array<String>}     [exclude=['help']]                An array of properties you don't want to render
   *
   * @since     2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static render(renderer = "terminal", settings) {
    const set2 = __deepMerge({
      renderer: "terminal",
      exclude: ["help"]
    }, settings);
    if (!this._registeredRenderers[renderer]) {
      throw new Error(`Sorry but the requested renderer "<yellow>${renderer}</yellow>" does not exists... Here's the available renderers: <green>${Object.keys(this._registeredRenderers).join(", ")}</green>`);
    }
    const rendererInstance = new this._registeredRenderers[renderer](this, set2);
    return rendererInstance.render();
  }
  /**
   * @name              constructor
   * @type              Function
   * @constructor
   *
   * Constructor
   *
   * @since         2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  constructor(settings) {
    super(__deepMerge({
      stripUnkown: false
    }, settings !== null && settings !== void 0 ? settings : {}));
    this._definition = {};
    this._definition = this.constructor.definition;
  }
  /**
   * @name              apply
   * @type              Function
   *
   * This method allows you to apply the interface on an object instance.
   * By default, if something is wrong in your class implementation, an error with the
   * description of what's wrong will be thrown. You can change that behavior if you prefer having
   * true returned when all is ok, or a string describing the current issue by specify the "settings.throw" property to false.
   *
   * @param       {Any}                objectOrString              The object on which to apply the interface on, or a cli like string to use as input
   * @param       {ISInterfaceSettings}               [settings={}]         An object of settings to configure your apply process
   * @return      {Boolean|String}                              true if all is ok, a string describing the issue if not...
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  apply(objectOrString, settings) {
    var _a2;
    const set2 = __deepMerge(this.settings, settings !== null && settings !== void 0 ? settings : {});
    let objectOnWhichToApplyInterface = objectOrString;
    if (typeof objectOrString === "string") {
      objectOnWhichToApplyInterface = __parseArgs(objectOrString);
      Object.keys(objectOnWhichToApplyInterface).forEach((argName) => {
        for (let i = 0; i < Object.keys(this._definition).length; i++) {
          const defArgName = Object.keys(this._definition)[i];
          const obj = this._definition[defArgName];
          if (obj.explicit) {
            if (obj.alias && ` ${objectOrString} `.match(new RegExp(`\\s-${obj.alias}\\s`))) {
              return;
            } else if (` ${objectOrString} `.match(new RegExp(`\\s--${argName}\\s`))) {
              return;
            }
            delete objectOnWhichToApplyInterface[argName];
          }
        }
      });
      Object.keys(objectOnWhichToApplyInterface).forEach((argName) => {
        for (let i = 0; i < Object.keys(this._definition).length; i++) {
          const defArgName = Object.keys(this._definition)[i];
          const obj = this._definition[defArgName];
          if (!obj.alias)
            continue;
          if (obj.alias === argName && objectOnWhichToApplyInterface[defArgName] === void 0) {
            objectOnWhichToApplyInterface[defArgName] = objectOnWhichToApplyInterface[argName];
            delete objectOnWhichToApplyInterface[argName];
          }
        }
      });
      Object.keys(objectOnWhichToApplyInterface).forEach((argName, i) => {
        if (argName === `${i}`) {
          const definitionKeys = Object.keys(this._definition);
          if (definitionKeys[i]) {
            objectOnWhichToApplyInterface[definitionKeys[i]] = objectOnWhichToApplyInterface[argName];
          }
          delete objectOnWhichToApplyInterface[argName];
        }
      });
    }
    const descriptor2 = new SDescriptor(Object.assign({ type: "Object", rules: this._definition }, (_a2 = set2.descriptor) !== null && _a2 !== void 0 ? _a2 : {}));
    if (set2.baseObj) {
      objectOnWhichToApplyInterface = __deepMerge(set2.baseObj, objectOnWhichToApplyInterface);
    }
    for (let [key, value] of Object.entries(this._definition)) {
      if (__isPlainObject(value.default) && __isPlainObject(objectOnWhichToApplyInterface[key])) {
        objectOnWhichToApplyInterface[key] = __deepMerge(value.default, objectOnWhichToApplyInterface[key]);
      }
    }
    const descriptorResult = descriptor2.apply(objectOnWhichToApplyInterface);
    if (descriptorResult.hasIssues()) {
      throw new Error(descriptorResult.toString());
    }
    let resultObj = descriptorResult.value;
    if (!set2.stripUnkown) {
      resultObj = __deepMerge(objectOnWhichToApplyInterface, resultObj);
    }
    return resultObj;
  }
}
SInterface.description = "";
SInterface._registeredRenderers = {};
class SDashboardSettingsInterface extends SInterface {
  static get _definition() {
    return {
      layout: {
        description: "Specify the layout of the dashboard with the components you want to display in which column",
        type: "Array",
        default: SSugarConfig.get("dashboard.layout")
      },
      widgets: {
        description: "Specify each widget settings if wanted to customize default behaviors",
        type: "Object",
        default: {}
      }
    };
  }
}
var __awaiter$w = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SDashboard extends SClass {
  /**
   * @name            iframe
   * @type            HTMLIframeElement
   * @get
   *
   * Access the dashboard iframe
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static get iframe() {
    return document.querySelector("iframe.s-dashboard-iframe");
  }
  /**
   * @name            document
   * @type            Document
   * @get
   *
   * Access the document that the dashboard is using.
   * If in an iframe, take the parent document, otherwise, the document itself
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get document() {
    var _a2, _b2;
    return (_b2 = (_a2 = window.parent) === null || _a2 === void 0 ? void 0 : _a2.document) !== null && _b2 !== void 0 ? _b2 : document;
  }
  /**
   * @name            constructor
   * @type            Function
   *
   * Constructor
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  constructor(settings) {
    super(__deepMerge(
      // @ts-ignore
      SDashboardSettingsInterface.defaults(),
      {
        layout: [
          [
            "s-dashboard-browserstack",
            "s-dashboard-web-vitals",
            "s-dashboard-assets",
            "s-dashboard-google"
          ],
          ["s-dashboard-frontend-checker"]
        ]
      },
      settings !== null && settings !== void 0 ? settings : {}
    ));
    this._inited = false;
    this._webVitalsInjected = false;
    document.dashboard = this;
    this._$iframe = document.createElement("iframe");
    this._$iframe.setAttribute("title", "s-dashboard");
    this._$iframe.classList.add(`s-dashboard-iframe`);
    this._$iframe.style.width = "0";
    this._$iframe.style.height = "0";
    document.body.appendChild(this._$iframe);
    document.addEventListener("keyup", this._onKeyup.bind(this));
  }
  /**
   * Init the dashboard
   */
  _onKeyup(e) {
    if ((e.key === "s" || e.key === "x") && e.ctrlKey) {
      if (e.key === "x") {
        this.settings.env = "development";
      }
      document.removeEventListener("keyup", this._onKeyup);
      this.open();
    }
  }
  /**
   * Init the dashboard
   */
  _initDashboard() {
    if (this._inited) {
      return;
    }
    this._$focusItem = document.createElement("div");
    this._$focusItem.setAttribute("tabindex", "-1");
    this._$focusItem.style.position = "fixed";
    this._$focusItem.style.top = "0";
    this._$focusItem.style.left = "0";
    document.body.appendChild(this._$focusItem);
    __hotkey("ctrl+x", {
      title: "Dashboard",
      description: "Open the Sugar dashboard"
    }).on("press", () => {
      this.open();
    });
    this._injectWebVitals();
    this._$iframe.contentWindow.document.open();
    this._$iframe.contentWindow.document.write(`
                <html>
                <head>
                    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
                    <script>
                        var $document = document;
                        if (window.parent) {
                            $document = window.parent.document;
                        }
                        var $html = $document.querySelector('html');
                        var $dashboardHtml = document.querySelector('html');
                        var theme = $html.getAttribute('theme');
                        var isDark = theme.match(/dark$/);
                        if (isDark && window.parent) {
                            $dashboardHtml.setAttribute('theme', 'default-dark');
                        } else {
                            $dashboardHtml.setAttribute('theme', 'default-light');
                        }
                        $document.addEventListener('s-theme.change', function(e) {
                            $dashboardHtml.setAttribute('theme', 'default-' + e.detail.variant);
                        });
                    <\/script>
                    ${this.settings.env === "development" ? '<script src="http://0.0.0.0:5173/sugar/dashboard/init.js" type="module" defer><\/script>' : '<script src="https://cdnv2.coffeekraken.io/s-dashboard/init/init.js" type="module" defer><\/script>'}
                </head>
                <body s-sugar>
                    <s-dashboard></s-dashboard>
                </body>
                </html>
            `);
    this._$iframe.contentWindow.document.close();
    this._inited = true;
  }
  _injectWebVitals() {
    if (this._webVitalsInjected)
      return;
    this._webVitalsInjected = true;
    const $script = document.createElement("script");
    $script.setAttribute("type", "module");
    $script.text = `
            import {getCLS, getFID, getLCP, getFCP, getTTFB} from 'https://unpkg.com/web-vitals?module';
            getCLS(function(res) {
                document.webVitals.cls = res;
                document.dispatchEvent(new CustomEvent('webVitals', {
                    detail: document.webVitals
                }));
            });
            getFID(function(res) {
                document.webVitals.fid = res;
                document.dispatchEvent(new CustomEvent('webVitals', {
                    detail: document.webVitals
                }));
            });
            getLCP(function(res) {
                document.webVitals.lcp = res;
                document.dispatchEvent(new CustomEvent('webVitals', {
                    detail: document.webVitals
                }));
            });
            getFCP(function(res) {
                document.webVitals.fcp = res;
                document.dispatchEvent(new CustomEvent('webVitals', {
                    detail: document.webVitals
                }));
            });
            getTTFB(function(res) {
                document.webVitals.ttfb = res;
                document.dispatchEvent(new CustomEvent('webVitals', {
                    detail: document.webVitals
                }));
            });
        `;
    document.webVitals = {};
    this.document.body.appendChild($script);
  }
  /**
   * @name            open
   * @type            Function
   *
   * Open the dashboard
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  close() {
    this._$iframe.classList.remove("active");
    this.document.querySelector("html").style.removeProperty("overflow");
    setTimeout(() => {
      this._$focusItem.focus();
    }, 100);
  }
  /**
   * @name            open
   * @type            Function
   *
   * Open the dashboard
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  open() {
    return __awaiter$w(this, void 0, void 0, function* () {
      if (!this._inited) {
        this._initDashboard();
      }
      this._$iframe.classList.add("active");
      this.document.querySelector("html").style.overflow = "hidden";
      escapeQueue(() => {
        this.close();
      }, {
        rootNode: [document, this.document]
      });
    });
  }
}
const PartytownSnippet = `/* Partytown 0.7.6 - MIT builder.io */
!function(t,e,n,i,r,o,a,d,s,c,p,l){function u(){l||(l=1,"/"==(a=(o.lib||"/~partytown/")+(o.debug?"debug/":""))[0]&&(s=e.querySelectorAll('script[type="text/partytown"]'),i!=t?i.dispatchEvent(new CustomEvent("pt1",{detail:t})):(d=setTimeout(f,1e4),e.addEventListener("pt0",w),r?h(1):n.serviceWorker?n.serviceWorker.register(a+(o.swPath||"partytown-sw.js"),{scope:a}).then((function(t){t.active?h():t.installing&&t.installing.addEventListener("statechange",(function(t){"activated"==t.target.state&&h()}))}),console.error):f())))}function h(t){c=e.createElement(t?"script":"iframe"),t||(c.setAttribute("style","display:block;width:0;height:0;border:0;visibility:hidden"),c.setAttribute("aria-hidden",!0)),c.src=a+"partytown-"+(t?"atomics.js?v=0.7.6":"sandbox-sw.html?"+Date.now()),e.body.appendChild(c)}function f(n,r){for(w(),i==t&&(o.forward||[]).map((function(e){delete t[e.split(".")[0]]})),n=0;n<s.length;n++)(r=e.createElement("script")).innerHTML=s[n].innerHTML,e.head.appendChild(r);c&&c.parentNode.removeChild(c)}function w(){clearTimeout(d)}o=t.partytown||{},i==t&&(o.forward||[]).map((function(e){p=t,e.split(".").map((function(e,n,i){p=p[i[n]]=n+1<i.length?"push"==i[n+1]?[]:p[i[n]]||{}:function(){(t._ptf=t._ptf||[]).push(i,arguments)}}))})),"complete"==e.readyState?u():(t.addEventListener("DOMContentLoaded",u),t.addEventListener("load",u))}(window,document,navigator,top,window.crossOriginIsolated);`;
const createSnippet = (config2, snippetCode) => {
  const { forward = [], ...filteredConfig } = config2 || {};
  const configStr = JSON.stringify(filteredConfig, (k, v2) => {
    if (typeof v2 === "function") {
      v2 = String(v2);
      if (v2.startsWith(k + "(")) {
        v2 = "function " + v2;
      }
    }
    return v2;
  });
  return [
    `!(function(w,p,f,c){`,
    Object.keys(filteredConfig).length > 0 ? `c=w[p]=Object.assign(w[p]||{},${configStr});` : `c=w[p]=w[p]||{};`,
    `c[f]=(c[f]||[])`,
    forward.length > 0 ? `.concat(${JSON.stringify(forward)})` : ``,
    `})(window,'partytown','forward');`,
    snippetCode
  ].join("");
};
const partytownSnippet = (config2) => createSnippet(config2, PartytownSnippet);
function __queryStringToObject(str2) {
  str2 = __ltrim(str2, "?");
  str2 = str2.replace(/%20/gm, " ");
  str2 = decodeURIComponent(str2);
  let chunks = str2.split("&");
  const obj = {};
  chunks = chunks.filter((ch) => {
    return ch !== "";
  });
  for (let c = 0; c < chunks.length; c++) {
    const split = chunks[c].split("=", 2);
    if (split[1] !== void 0) {
      obj[split[0]] = split[1];
    } else {
      obj[split[0]] = true;
    }
  }
  return obj;
}
new Proxy({}, {
  get(_, key) {
    throw new Error(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code.  See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
  }
});
try {
  if (document && !document.env) {
    document.env = {
      SUGAR: {}
    };
  }
} catch (e) {
}
let SEnv$1 = class SEnv {
  /**
   * @name        is
   * @type        Function
   * @static
   *
   * This static method allows you to check if the environment
   * is "dev", "development", "prod" or "production"
   *
   * @param     {String}      env       The environment you want to check
   * @return    {Boolean}               true if is the passed environment, false if not
   *
   * @since     2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static is(env) {
    env = env.toLowerCase();
    if (env === "verbose") {
      if (this.get("verbose")) {
        return true;
      }
    }
    if (env === "devscut") {
      if (this.get("devsCut")) {
        return true;
      }
    }
    if (env === "dev" || env === "development") {
      if (this.get("env") === "dev" || this.get("env") === "development")
        return true;
    } else if (env === "prod" || env === "production") {
      if (this.get("env") === "prod" || this.get("env") === "production")
        return true;
    } else {
      return this.get("env") === env;
    }
    return false;
  }
  /**
   * @name        get
   * @type        Function
   * @static
   *
   * This static method allows you to access an env variable.
   * The variables keys are stored in UPPERCASE but you can use lowercase as well
   *
   * @param     {String}      name       The variable name you want to get back
   * @return    {Any}                   The variable getted or undefined
   *
   * @since     2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static get(name2) {
    return __parse(this.env[__snakeCase(name2).toUpperCase()]);
  }
  /**
   * @name        set
   * @type        Function
   * @static
   *
   * This static method allows you to set an env variable.
   * The variables keys are stored in UPPERCASE but you can use lowercase as well
   *
   * @param     {String}     name       The variable name you want to get back
   * @param     {Any}         value     The value you want to set
   * @return    {Any}                  The value setted
   *
   * @since     2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static set(name2, value) {
    this.env[__snakeCase(name2).toUpperCase()] = value;
    return value;
  }
  /**
   * @name        delete
   * @type        Function
   * @static
   *
   * This static method allows you to delete an env variable.
   * The variables keys are stored in UPPERCASE but you can use lowercase as well
   *
   * @param     {String}     name       The variable name you want to get back
   * @param     {Any}         value     The value you want to set
   * @return    {Any}                  The value setted
   *
   * @since     2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static delete(name2) {
    delete this.env[__snakeCase(name2).toUpperCase()];
  }
};
class SEnv2 extends SEnv$1 {
  static get env() {
    var _a2;
    if (this._env)
      return this._env;
    const envConfig = (_a2 = SSugarConfig.get("env")) !== null && _a2 !== void 0 ? _a2 : {};
    const queryStringObj = __queryStringToObject(document.location.search);
    let finalEnv = "development";
    if (envConfig.env) {
      finalEnv = envConfig.env;
    } else if (envConfig.envFromLocation && Object.keys(envConfig.envFromLocation).length) {
      for (let [env, regex2] of Object.entries(envConfig.envFromLocation)) {
        if (new RegExp(regex2).test(document.location.href)) {
          finalEnv = env;
          break;
        }
      }
    } else {
      console.log(`<red>[SEnv]</red> The environment cannot be determined. Either set the config.env.env configuration or specify some environments by setting the config.env.envFromLocation object of {env}:{regex} environments`);
    }
    document.env.ENV = finalEnv;
    document.env.PLATFORM = "browser";
    document.env.DEVS_CUT = queryStringObj.devsCut !== void 0;
    document.env.VERBOSE = queryStringObj.verbose !== void 0;
    this._env = document.env;
    return document.env;
  }
}
function __setCookie(name2, value, settings = {}) {
  settings = Object.assign({ path: "/" }, settings);
  try {
    value = JSON.stringify(value);
  } catch (e) {
  }
  if (settings.expires instanceof Date) {
    settings.expires = settings.expires.toUTCString();
  }
  let updatedCookie = encodeURIComponent(name2) + "=" + encodeURIComponent(value);
  for (let optionKey in settings) {
    updatedCookie += "; " + optionKey;
    let optionValue = settings[optionKey];
    if (optionValue !== true) {
      updatedCookie += "=" + optionValue;
    }
  }
  document.cookie = updatedCookie;
}
function __getCookie(name2) {
  let matches = document.cookie.match(new RegExp("(?:^|; )" + name2.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, "\\$1") + "=([^;]*)"));
  let value;
  if (matches === null || matches === void 0 ? void 0 : matches[1]) {
    value = decodeURIComponent(matches[1]);
    try {
      value = JSON.parse(value);
    } catch (e) {
    }
  }
  return value;
}
function __injectStyle(style, settings) {
  var _a2;
  const finalSettings = Object.assign({ id: `injected-style-${__uniqid()}`, rootNode: void 0 }, settings !== null && settings !== void 0 ? settings : {});
  if (document.querySelector(`#${finalSettings.id}`))
    return;
  const $tag = document.createElement("style");
  $tag.type = "text/css";
  $tag.setAttribute("id", finalSettings.id);
  $tag.innerHTML = style;
  if (finalSettings.rootNode) {
    finalSettings.rootNode.appendChild($tag);
  } else {
    const $firstLink = document.querySelector('head link[rel="stylesheet"]');
    if ($firstLink) {
      (_a2 = $firstLink.parentElement) === null || _a2 === void 0 ? void 0 : _a2.insertBefore($tag, $firstLink);
    } else {
      document.head.appendChild($tag);
    }
  }
  return $tag;
}
function __addEventListener($elm, eventNames, callback = null, useCapture = false) {
  if (!Array.isArray(eventNames))
    eventNames = eventNames.split(",").map((e) => e.trim());
  if (callback && typeof callback === "function")
    callback = callback;
  else if (callback && typeof callback === "boolean")
    useCapture = callback;
  const eventsStack = {};
  const promise = new SPromise({
    id: "addEventListener"
  }).on("finally", () => {
    eventNames.forEach((eventName) => {
      const stack = eventsStack[eventName];
      $elm.removeEventListener(eventName, stack.callback, stack.useCapture);
    });
  });
  eventNames.forEach((eventName) => {
    const internalCallback = (event) => {
      if (callback)
        callback.apply(this, [event]);
      promise.emit(eventName, event);
    };
    eventsStack[eventName] = {
      callback: internalCallback,
      useCapture
    };
    $elm.addEventListener(eventName, internalCallback, useCapture);
  });
  return promise;
}
function __addEventListenerOnce($elm, eventNames, callback = null, useCapture = false) {
  if (!Array.isArray(eventNames))
    eventNames = [eventNames];
  const globalPromise = new SPromise({
    id: "addEventListenerOnce"
  });
  const eventsStack = {};
  globalPromise.on("finally", () => {
    eventNames.forEach((eventName) => {
      eventsStack[eventName].promise.cancel();
    });
  });
  eventNames.forEach((eventName) => {
    const promise = __addEventListener($elm, eventName, null, useCapture);
    eventsStack[eventName] = {
      promise
    };
    promise.on(eventNames, (event) => {
      if (callback && typeof callback === "function") {
        callback.apply(this, [event]);
      }
      globalPromise.emit(eventName, event);
      promise.cancel();
    });
  });
  return globalPromise;
}
function __whenAnimationEnd($elm) {
  return new Promise((resolve2) => {
    __addEventListenerOnce($elm, "animationend", (e) => {
      resolve2($elm);
    });
  });
}
globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __awaiter$v = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function __adoptStyleInShadowRoot($shadowRoot, $context = document) {
  return __awaiter$v(this, void 0, void 0, function* () {
    const $links = $context.querySelectorAll('link[rel="stylesheet"]');
    if ($links && $shadowRoot) {
      Array.from($links).forEach(($link) => __awaiter$v(this, void 0, void 0, function* () {
        $shadowRoot === null || $shadowRoot === void 0 ? void 0 : $shadowRoot.appendChild($link.cloneNode());
      }));
    }
    return true;
  });
}
var fastdom = { exports: {} };
(function(module) {
  !function(win) {
    var debug = function() {
    };
    var raf = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.msRequestAnimationFrame || function(cb) {
      return setTimeout(cb, 16);
    };
    function FastDom() {
      var self2 = this;
      self2.reads = [];
      self2.writes = [];
      self2.raf = raf.bind(win);
    }
    FastDom.prototype = {
      constructor: FastDom,
      /**
       * We run this inside a try catch
       * so that if any jobs error, we
       * are able to recover and continue
       * to flush the batch until it's empty.
       *
       * @param {Array} tasks
       */
      runTasks: function(tasks) {
        var task;
        while (task = tasks.shift())
          task();
      },
      /**
       * Adds a job to the read batch and
       * schedules a new frame if need be.
       *
       * @param  {Function} fn
       * @param  {Object} ctx the context to be bound to `fn` (optional).
       * @public
       */
      measure: function(fn2, ctx) {
        var task = !ctx ? fn2 : fn2.bind(ctx);
        this.reads.push(task);
        scheduleFlush(this);
        return task;
      },
      /**
       * Adds a job to the
       * write batch and schedules
       * a new frame if need be.
       *
       * @param  {Function} fn
       * @param  {Object} ctx the context to be bound to `fn` (optional).
       * @public
       */
      mutate: function(fn2, ctx) {
        var task = !ctx ? fn2 : fn2.bind(ctx);
        this.writes.push(task);
        scheduleFlush(this);
        return task;
      },
      /**
       * Clears a scheduled 'read' or 'write' task.
       *
       * @param {Object} task
       * @return {Boolean} success
       * @public
       */
      clear: function(task) {
        return remove(this.reads, task) || remove(this.writes, task);
      },
      /**
       * Extend this FastDom with some
       * custom functionality.
       *
       * Because fastdom must *always* be a
       * singleton, we're actually extending
       * the fastdom instance. This means tasks
       * scheduled by an extension still enter
       * fastdom's global task queue.
       *
       * The 'super' instance can be accessed
       * from `this.fastdom`.
       *
       * @example
       *
       * var myFastdom = fastdom.extend({
       *   initialize: function() {
       *     // runs on creation
       *   },
       *
       *   // override a method
       *   measure: function(fn) {
       *     // do extra stuff ...
       *
       *     // then call the original
       *     return this.fastdom.measure(fn);
       *   },
       *
       *   ...
       * });
       *
       * @param  {Object} props  properties to mixin
       * @return {FastDom}
       */
      extend: function(props) {
        if (typeof props != "object")
          throw new Error("expected object");
        var child = Object.create(this);
        mixin(child, props);
        child.fastdom = this;
        if (child.initialize)
          child.initialize();
        return child;
      },
      // override this with a function
      // to prevent Errors in console
      // when tasks throw
      catch: null
    };
    function scheduleFlush(fastdom2) {
      if (!fastdom2.scheduled) {
        fastdom2.scheduled = true;
        fastdom2.raf(flush.bind(null, fastdom2));
      }
    }
    function flush(fastdom2) {
      var writes = fastdom2.writes;
      var reads = fastdom2.reads;
      var error2;
      try {
        debug("flushing reads", reads.length);
        fastdom2.runTasks(reads);
        debug("flushing writes", writes.length);
        fastdom2.runTasks(writes);
      } catch (e) {
        error2 = e;
      }
      fastdom2.scheduled = false;
      if (reads.length || writes.length)
        scheduleFlush(fastdom2);
      if (error2) {
        debug("task errored", error2.message);
        if (fastdom2.catch)
          fastdom2.catch(error2);
        else
          throw error2;
      }
    }
    function remove(array, item) {
      var index = array.indexOf(item);
      return !!~index && !!array.splice(index, 1);
    }
    function mixin(target, source2) {
      for (var key in source2) {
        if (source2.hasOwnProperty(key))
          target[key] = source2[key];
      }
    }
    var exports = win.fastdom = win.fastdom || new FastDom();
    module.exports = exports;
  }(typeof window !== "undefined" ? window : commonjsGlobal);
})(fastdom);
var fastdomExports = fastdom.exports;
const __fastdom = /* @__PURE__ */ getDefaultExportFromCjs(fastdomExports);
function __isInViewport(elm, settings = {}) {
  settings = Object.assign({}, settings);
  const scrollTop = document.documentElement.scrollTop || document.body.scrollTop, scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;
  const containerHeight = window.innerHeight || document.documentElement.clientHeight, containerWidth = window.innerWidth || document.documentElement.clientWidth, rect = elm.getBoundingClientRect();
  const top = rect.top - scrollTop, left = rect.left - scrollLeft, right = rect.right - scrollLeft, bottom = rect.bottom - scrollTop;
  const isTopIn = top - containerHeight <= 0, isBottomIn = bottom <= containerHeight, isLeftIn = left >= 0 && left <= containerWidth, isRightIn = right >= 0 && right <= containerWidth;
  if ((isTopIn || isBottomIn) && (isLeftIn || isRightIn)) {
    return true;
  }
  if (top <= 0 && bottom >= containerHeight && left <= 0 && right >= containerWidth) {
    return true;
  }
  if (top <= 0 && bottom >= containerHeight && left <= 0 && isRightIn) {
    return true;
  }
  if (top <= 0 && bottom >= containerHeight && right >= containerWidth && isLeftIn) {
    return true;
  }
  if (left <= 0 && right >= containerWidth && top <= 0 && isBottomIn) {
    return true;
  }
  if (left <= 0 && right >= containerWidth && bottom >= containerHeight && isTopIn) {
    return true;
  }
  return false;
}
var __awaiter$u = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function __whenEntersViewport(elm, settings = {}) {
  function getRootMargin() {
    return [
      `${Math.round(window.innerHeight * 0.15 * -1)}px`,
      `${Math.round(window.innerWidth * 0.15 * -1)}px`,
      `${Math.round(window.innerHeight * 0.15 * -1)}px`,
      `${Math.round(window.innerWidth * 0.15 * -1)}px`
    ].join(" ");
  }
  settings = Object.assign({}, settings);
  let observer, resizeTimeout;
  return new Promise((resolve2) => __awaiter$u(this, void 0, void 0, function* () {
    var _a2;
    const options = {
      root: null,
      rootMargin: (_a2 = settings.offset) !== null && _a2 !== void 0 ? _a2 : getRootMargin(),
      threshold: 0
      // visible amount of item shown in relation to root
    };
    if (__isInViewport(elm)) {
      return resolve2(elm);
    }
    function onChange(changes, observer2) {
      changes.forEach((change) => {
        var _a3;
        if (change.intersectionRatio > 0) {
          (_a3 = observer2.disconnect) === null || _a3 === void 0 ? void 0 : _a3.call(observer2);
          resolve2(elm);
        }
      });
    }
    observer = new IntersectionObserver(onChange, options);
    observer.observe(elm);
    window.addEventListener("resize", (e) => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        var _a3, _b2;
        (_a3 = observer.disconnect) === null || _a3 === void 0 ? void 0 : _a3.call(observer);
        options.rootMargin = (_b2 = settings.offset) !== null && _b2 !== void 0 ? _b2 : getRootMargin();
        observer = new IntersectionObserver(onChange, options);
        observer.observe(elm);
      }, 500);
    });
  }));
}
class WhenInteractSettingsInterface extends SInterface {
  static get _definition() {
    return {
      pointerover: {
        description: "Specify if the pointerover event has to be used",
        type: "Boolean",
        default: true
      },
      pointerout: {
        description: "Specify if the pointerout event has to be used",
        type: "Boolean",
        default: true
      },
      click: {
        description: "Specify if the click event has to be used",
        type: "Boolean",
        default: true
      },
      touchstart: {
        description: "Specify if the touchstart event has to be used",
        type: "Boolean",
        default: true
      },
      touchend: {
        description: "Specify if the touchend event has to be used",
        type: "Boolean",
        default: true
      },
      focus: {
        description: "Specify if the focus event has to be used",
        type: "Boolean",
        default: true
      }
    };
  }
}
function __whenInteract(elm, settings) {
  return new Promise((resolve2, reject) => {
    settings = WhenInteractSettingsInterface.apply(settings !== null && settings !== void 0 ? settings : {});
    function interacted(interaction) {
      resolve2(interaction);
      elm.removeEventListener("pointerover", pointerover);
      elm.removeEventListener("pointerout", pointerout);
      elm.removeEventListener("pointerdown", pointerdown);
      elm.removeEventListener("touchstart", touchstart);
      elm.removeEventListener("touchend", touchend);
      elm.removeEventListener("focus", focus);
      elm.removeEventListener("focusin", focus);
    }
    function pointerover(e) {
      interacted("pointerover");
    }
    if (settings.pointerover) {
      elm.addEventListener("pointerover", pointerover);
    }
    function pointerout(e) {
      interacted("pointerout");
    }
    if (settings.pointerout) {
      elm.addEventListener("pointerout", pointerout);
    }
    function pointerdown(e) {
      interacted("pointerdown");
    }
    if (settings.pointerdown) {
      elm.addEventListener("pointerdown", pointerdown);
    }
    function touchstart(e) {
      interacted("touchstart");
    }
    if (settings.touchstart) {
      elm.addEventListener("touchstart", touchstart, {
        passive: true
      });
    }
    function touchend(e) {
      interacted("touchend");
    }
    if (settings.touchend) {
      elm.addEventListener("touchend", touchend);
    }
    function focus(e) {
      interacted("focus");
    }
    if (settings.focus === true) {
      elm.addEventListener("focus", focus);
      elm.addEventListener("focusin", focus);
    }
  });
}
function __whenInViewport($elm, settings = {}) {
  settings = Object.assign({ offset: "10px", once: true, whenIn: null, whenOut: null }, settings);
  let observer;
  const id2 = __uniqid();
  const pro = new SPromise(({ resolve: resolve2, emit }) => {
    const options = {
      root: null,
      rootMargin: settings.offset,
      threshold: 0
      // visible amount of item shown in relation to root
    };
    if (!$elm._whenInViewportStatus) {
      $elm._whenInViewportStatus = {};
    }
    function onChange(changes) {
      changes.forEach((change) => {
        var _a2, _b2;
        if (change.intersectionRatio === 0) {
          if (!$elm._whenInViewportStatus[id2]) {
            return;
          }
          $elm._whenInViewportStatus[id2] = false;
          (_a2 = settings.whenOut) === null || _a2 === void 0 ? void 0 : _a2.call(settings, $elm);
          emit("out", $elm);
        } else {
          if (settings.once) {
            observer.disconnect();
          }
          if ($elm._whenInViewportStatus[id2]) {
            return;
          }
          $elm._whenInViewportStatus[id2] = true;
          (_b2 = settings.whenIn) === null || _b2 === void 0 ? void 0 : _b2.call(settings, $elm);
          emit("in", $elm);
          if (settings.once) {
            resolve2($elm);
          }
        }
      });
    }
    observer = new IntersectionObserver(onChange, options);
    observer.observe($elm);
  });
  pro.on("cancel", () => {
    observer === null || observer === void 0 ? void 0 : observer.disconnect();
  });
  return pro;
}
function whenLod(level) {
  return new Promise((resolve2) => {
    const $html = document.querySelector("html");
    if ($html === null || $html === void 0 ? void 0 : $html.classList.contains(`s-lod-${level}`)) {
      return resolve2();
    }
    const observer = new MutationObserver((mutationList, observer2) => {
      for (const mutation of mutationList) {
        if (mutation.type === "attributes" && mutation.attributeName === "class") {
          if ($html === null || $html === void 0 ? void 0 : $html.classList.contains(`s-lod-${level}`)) {
            observer2.disconnect();
            return resolve2();
          }
        }
      }
    });
    observer.observe(document.body, {
      attributeFilter: ["class"],
      attributes: true
    });
  });
}
function __isScrollable($elm, settings) {
  var _a2;
  settings = Object.assign({ x: true, y: true }, settings !== null && settings !== void 0 ? settings : {});
  if (!($elm instanceof Element)) {
    return false;
  }
  const style = ((_a2 = window.parent) !== null && _a2 !== void 0 ? _a2 : window).getComputedStyle($elm);
  var overflowY = style.overflowY.trim();
  var overflowX = style.overflowX.trim();
  const dir = {
    vertical: (overflowY === "scroll" || overflowY === "auto") && $elm.scrollHeight > $elm.clientHeight,
    horizontal: (overflowX === "scroll" || overflowX === "auto") && $elm.scrollWidth > $elm.clientWidth
  };
  if ($elm.classList.contains("body")) {
    _console.log("b", dir, overflowX, overflowY);
  }
  if (settings.x && dir.horizontal)
    return true;
  if (settings.y && dir.vertical)
    return true;
  return false;
}
function __traverseUp($elm, callback) {
  const originalElm = $elm;
  $elm = $elm.parentNode;
  while ($elm && $elm != originalElm.ownerDocument) {
    if (callback($elm)) {
      return $elm;
    }
    $elm = $elm.parentNode;
  }
  return null;
}
function __closestScrollable($elm, selector) {
  const res = __traverseUp($elm, ($e2) => __isScrollable($e2));
  return res;
}
var __awaiter$t = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function __whenNearViewport(elm, settings = {}) {
  function getRootMargin() {
    return [
      `${Math.round(window.innerHeight * 0.5)}px`,
      `${Math.round(window.innerWidth * 0.5)}px`,
      `${Math.round(window.innerHeight * 0.5)}px`,
      `${Math.round(window.innerWidth * 0.5)}px`
    ].join(" ");
  }
  settings = Object.assign({}, settings);
  let observer, resizeTimeout;
  let $closest = __closestScrollable(elm);
  if (($closest === null || $closest === void 0 ? void 0 : $closest.tagName) === "HTML")
    $closest = null;
  return new Promise((resolve2) => __awaiter$t(this, void 0, void 0, function* () {
    var _a2;
    const options = {
      root: $closest,
      rootMargin: (_a2 = settings.offset) !== null && _a2 !== void 0 ? _a2 : getRootMargin(),
      threshold: 0
      // visible amount of item shown in relation to root
    };
    function onChange(changes, observer2) {
      changes.forEach((change) => {
        var _a3;
        if (change.intersectionRatio > 0) {
          (_a3 = observer2.disconnect) === null || _a3 === void 0 ? void 0 : _a3.call(observer2);
          resolve2(elm);
        }
      });
    }
    observer = new IntersectionObserver(onChange, options);
    observer.observe(elm);
    window.addEventListener("resize", (e) => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        var _a3, _b2;
        (_a3 = observer.disconnect) === null || _a3 === void 0 ? void 0 : _a3.call(observer);
        options.rootMargin = (_b2 = settings.offset) !== null && _b2 !== void 0 ? _b2 : getRootMargin();
        observer = new IntersectionObserver(onChange, options);
        observer.observe(elm);
      }, 500);
    });
  }));
}
function __whenOutOfViewport(elm, settings = {}) {
  return new Promise((resolve2, reject) => {
    settings = Object.assign({ offset: "10px" }, settings);
    let isInViewport = false;
    const _cb = () => {
      if (!isInViewport) {
        observer.disconnect();
        resolve2(elm);
      }
    };
    const observer = new IntersectionObserver((entries, observer2) => {
      if (!entries.length)
        return;
      const entry = entries[0];
      if (entry.intersectionRatio > 0) {
        isInViewport = true;
      } else {
        isInViewport = false;
      }
      _cb();
    }, {
      root: null,
      rootMargin: settings.offset,
      threshold: [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]
    });
    observer.observe(elm);
  });
}
function alreadyLoaded(link) {
  const href = link.href;
  let result2 = false;
  for (let i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].href && document.styleSheets[i].href.match(href)) {
      result2 = true;
    } else if (i == document.styleSheets.length - 1)
      ;
  }
  return result2;
}
function __whenLinkLoaded(link, cb = null) {
  return new Promise((resolve2, reject) => {
    if (alreadyLoaded(link)) {
      resolve2(link);
      cb === null || cb === void 0 ? void 0 : cb(link);
    } else {
      const img = document.createElement("img");
      img.addEventListener("error", (e) => {
        resolve2(link);
        cb === null || cb === void 0 ? void 0 : cb(link);
      });
      img.src = link.href;
    }
  });
}
function __whenStylesheetsReady(links = null) {
  if (!links) {
    links = Array.from(document.querySelectorAll('link[rel="stylesheet"]'));
  }
  const promises = [];
  [].forEach.call(links, ($link) => {
    promises.push(__whenLinkLoaded($link));
  });
  const allPromises = Promise.all(promises);
  return allPromises;
}
function __whenVisible($elm, settings) {
  const pro = new SPromise(({ resolve: resolve2, reject, emit }) => {
    const finalSettings = Object.assign({ whenVisible: null, whenInvisible: null, once: true }, settings !== null && settings !== void 0 ? settings : {});
    if (!$elm._whenVisibleStatus) {
      $elm._whenVisibleStatus = {};
    }
    const id2 = __uniqid();
    var observer = new IntersectionObserver(function(entries) {
      var _a2, _b2;
      if (entries[0]["intersectionRatio"] == 0) {
        if (!$elm._whenVisibleStatus[id2]) {
          return;
        }
        $elm._whenVisibleStatus[id2] = false;
        (_a2 = finalSettings.whenInvisible) === null || _a2 === void 0 ? void 0 : _a2.call(finalSettings, $elm);
        emit("invisible", $elm);
      } else {
        if (finalSettings.once) {
          observer.disconnect();
        }
        if ($elm._whenVisibleStatus[id2]) {
          return;
        }
        $elm._whenVisibleStatus[id2] = true;
        (_b2 = finalSettings.whenVisible) === null || _b2 === void 0 ? void 0 : _b2.call(finalSettings, $elm);
        emit("visible", $elm);
        if (finalSettings.once) {
          resolve2($elm);
        }
      }
    });
    observer.observe($elm);
    pro.on("cancel", () => {
      observer === null || observer === void 0 ? void 0 : observer.disconnect();
    });
    return pro;
  });
}
var __awaiter$s = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const WhenTriggers = [
  "direct",
  "directly",
  "inViewport",
  "nearViewport",
  "enterViewport",
  "outOfViewport",
  "interact",
  "visible",
  "stylesheetsReady",
  "domReady",
  "animationEnd",
  "lod:0",
  "lod:1",
  "lod:2",
  "lod:3",
  "lod:4"
];
function __when($elm, trigger2, settings) {
  const finalSettings = Object.assign({ whenInViewport: {}, whenNearViewport: {}, whenOutOfViewport: {}, whenInteract: {}, whenVisible: {}, whenStylesheetsReady: {} }, settings !== null && settings !== void 0 ? settings : {});
  return new Promise((resolve2, reject) => __awaiter$s(this, void 0, void 0, function* () {
    if (!Array.isArray(trigger2))
      trigger2 = trigger2.split(",").map((t) => t.trim());
    const promises = [];
    trigger2.forEach((t) => {
      const lodMatches = t.match(/^lod\:([0-9]{1,2})/);
      if (lodMatches && lodMatches[1]) {
        const level = parseInt(lodMatches[1]);
        promises.push(whenLod(level));
        return;
      }
      const timeoutMatches = t.match(/^timeout\:([0-9]+)/);
      if (timeoutMatches && timeoutMatches[1]) {
        const timeout = parseInt(timeoutMatches[1]);
        const promise = new Promise((resolve3) => {
          setTimeout(resolve3, timeout);
        });
        promises.push(promise);
        return;
      }
      const eventMatches = t.match(/^event\:[a-zA-Z0-9-_\.]/);
      if (eventMatches && eventMatches[1]) {
        const promise = new Promise((resolve3) => {
          $elm.addEventListener(eventMatches[1], (e) => {
            resolve3();
          });
        });
        promises.push(promise);
        return;
      }
      switch (t) {
        case "inViewport":
          promises.push(__whenInViewport($elm, finalSettings.whenInViewport));
          break;
        case "nearViewport":
          promises.push(__whenNearViewport($elm, finalSettings.whenNearViewport));
          break;
        case "entersViewport":
          promises.push(__whenEntersViewport($elm, finalSettings.whenEntersViewport));
          break;
        case "outOfViewport":
          promises.push(__whenOutOfViewport($elm, finalSettings.whenOutOfViewport));
          break;
        case "interact":
          promises.push(__whenInteract($elm, finalSettings.whenInteract));
          break;
        case "visible":
          promises.push(__whenVisible($elm, {
            whenVisible: finalSettings.whenVisible,
            once: true
          }));
          break;
        case "domReady":
          promises.push(__whenDomReady());
          break;
        case "stylesheetsReady":
          promises.push(__whenStylesheetsReady($elm ? [$elm] : null));
          break;
        case "animationEnd":
          promises.push(__whenAnimationEnd($elm));
          break;
      }
    });
    if (!trigger2.length || trigger2.includes("direct") || trigger2.includes("directly")) {
      resolve2($elm);
      return;
    }
    yield Promise.race(promises);
    resolve2($elm);
  }));
}
var __awaiter$r = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function __querySelectorLive(selector, cb = null, settings = {}, _isFirstLevel = true) {
  var _a2, _b2, _c2, _d2, _e2, _f2;
  let _emit, noScopeSelector, observer, canceled = false;
  __uniqid();
  const selectedNodes = [];
  settings = __deepMerge({
    rootNode: document,
    once: true,
    afterFirst: null,
    scopes: true,
    firstOnly: false,
    attributes: [],
    when: void 0
  }, settings);
  const innerPromises = [];
  if (settings.scopes) {
    noScopeSelector = selector.split(",").map((sel) => {
      return `${sel.trim()}:not([s-scope] ${sel.trim()})`;
    }).join(",");
  }
  const pro = new SPromise(({ resolve: resolve2, reject, emit, pipe }) => {
    _emit = emit;
  });
  function isCanceled() {
    return selectedNodes.length && canceled && _isFirstLevel;
  }
  if (isCanceled()) {
    return;
  }
  function handleNode(node, sel) {
    if (isCanceled()) {
      return;
    }
    _emit === null || _emit === void 0 ? void 0 : _emit("node", {
      node,
      cancel() {
        pro.cancel();
      }
    });
    cb === null || cb === void 0 ? void 0 : cb(node, {
      cancel() {
        pro.cancel();
      }
    });
    if (settings.firstOnly) {
      pro.cancel();
    }
    if (!selectedNodes.includes(node)) {
      selectedNodes.push(node);
    }
  }
  function processNode(node, sel) {
    return __awaiter$r(this, void 0, void 0, function* () {
      if (!node.matches || isCanceled()) {
        return;
      }
      if (node.matches(selector) && (!settings.once || !selectedNodes.includes(node))) {
        if (settings.when) {
          yield __when(node, settings.when);
          if (isCanceled()) {
            return;
          }
          handleNode(node);
        } else {
          handleNode(node);
        }
      }
      findAndProcess(node, sel);
    });
  }
  function findAndProcess($root, sel) {
    if (!$root.querySelectorAll || isCanceled()) {
      return;
    }
    const nodes = Array.from($root === null || $root === void 0 ? void 0 : $root.querySelectorAll(sel));
    nodes.forEach((node) => {
      processNode(node, sel);
    });
  }
  if (settings.scopes && (settings.rootNode === document || !((_b2 = (_a2 = settings.rootNode) === null || _a2 === void 0 ? void 0 : _a2.hasAttribute) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, "s-scope")))) {
    let isAfterCalledByScopeId = {};
    innerPromises.push(__querySelectorLive("[s-scope]", ($scope) => __awaiter$r(this, void 0, void 0, function* () {
      const scopeId = $scope.id || `s-scope-${__uniqid()}`;
      if ($scope.id !== scopeId) {
        $scope.setAttribute("id", scopeId);
      }
      if (isCanceled()) {
        return;
      }
      yield __when($scope, "nearViewport");
      if (isCanceled()) {
        return;
      }
      innerPromises.push(__querySelectorLive(selector, ($elm) => {
        processNode($elm, selector);
      }, Object.assign({}, settings, {
        rootNode: $scope,
        scopes: false,
        afterFirst() {
          if (isAfterCalledByScopeId[scopeId] && $scope._sQuerySelectorLiveScopeDirty) {
            return;
          }
          $scope._sQuerySelectorLiveScopeDirty = true;
          isAfterCalledByScopeId[scopeId] = true;
          __fastdom.mutate(() => {
            $scope.classList.add("ready");
            $scope.setAttribute("ready", "true");
          });
        }
      }), true));
    }), Object.assign({}, settings, {
      firstOnly: false,
      scopes: false
    }), false));
    innerPromises.push(__querySelectorLive(noScopeSelector, ($elm) => {
      processNode($elm, selector);
    }, Object.assign({}, settings, {
      scopes: false
    }), false));
    (_c2 = settings.afterFirst) === null || _c2 === void 0 ? void 0 : _c2.call(settings);
  } else {
    observer = new MutationObserver((mutations, obs) => {
      mutations.forEach((mutation) => {
        if (mutation.attributeName) {
          processNode(mutation.target, selector);
        }
        if (mutation.addedNodes) {
          mutation.addedNodes.forEach((node) => {
            processNode(node, selector);
          });
        }
      });
    });
    let observeSettings = {
      childList: true,
      subtree: true
    };
    selector.split(",").map((l) => l.trim()).forEach((sel) => {
      const attrMatches = sel.match(/\[[^\]]+\]/gm);
      if (attrMatches === null || attrMatches === void 0 ? void 0 : attrMatches.length) {
        attrMatches.forEach((attrStr) => {
          var _a3, _b3;
          const attrName = attrStr.split("=")[0].replace(/^\[/, "").replace(/\]$/, "");
          if (!((_a3 = settings.attributes) === null || _a3 === void 0 ? void 0 : _a3.includes(attrName))) {
            (_b3 = settings.attributes) === null || _b3 === void 0 ? void 0 : _b3.push(attrName);
          }
        });
      }
    });
    if ((_d2 = settings.attributes) === null || _d2 === void 0 ? void 0 : _d2.length) {
      observeSettings = Object.assign(Object.assign({}, observeSettings), { attributes: (_e2 = settings.attributes) === null || _e2 === void 0 ? void 0 : _e2.length, attributeFilter: settings.attributes.length ? settings.attributes : null });
    }
    observer.observe(settings.rootNode, observeSettings);
    findAndProcess(settings.rootNode, selector);
    (_f2 = settings.afterFirst) === null || _f2 === void 0 ? void 0 : _f2.call(settings);
  }
  pro.on("cancel", () => {
    canceled = true;
    innerPromises.forEach((promise) => {
      promise.cancel();
    });
    observer === null || observer === void 0 ? void 0 : observer.disconnect();
  });
  return pro;
}
function reloadStylesheets(settings) {
  var _a2;
  const finalSettings = Object.assign({ $root: document }, settings !== null && settings !== void 0 ? settings : {});
  Array.from((_a2 = finalSettings.$root.querySelectorAll("link[rel=stylesheet]")) !== null && _a2 !== void 0 ? _a2 : []).forEach(($link) => {
    var _a3;
    const id2 = (_a3 = $link.id) !== null && _a3 !== void 0 ? _a3 : __uniqid();
    const $newLink = $link.cloneNode();
    $newLink.href = $link.href.replace(/\?.*|$/, "?" + Date.now());
    $newLink.addEventListener("load", (e) => {
      var _a4;
      Array.from((_a4 = finalSettings.$root.querySelectorAll(`link[id="${id2}"]`)) !== null && _a4 !== void 0 ? _a4 : []).forEach(($remove) => {
        if ($remove === $newLink)
          return;
        $remove.remove();
      });
    });
    $link.after($newLink);
  });
}
var _a$8, _b$5;
let oldX = 0, oldY = 0;
const threshold = 0;
try {
  (_a$8 = document === null || document === void 0 ? void 0 : document.addEventListener) === null || _a$8 === void 0 ? void 0 : _a$8.call(document, "pointermove", (e) => {
    calculateDirection(e);
  });
  (_b$5 = document === null || document === void 0 ? void 0 : document.addEventListener) === null || _b$5 === void 0 ? void 0 : _b$5.call(document, "pointerdown", (e) => {
    calculateDirection(e);
  });
} catch (e) {
}
function calculateDirection(e) {
  if (e.pageX < oldX - threshold) {
    oldX - e.pageX;
    oldX = e.pageX;
  } else if (e.pageX > oldX + threshold) {
    e.pageX - oldX;
    oldX = e.pageX;
  }
  if (e.pageY < oldY - threshold) {
    oldY - e.pageY;
    oldY = e.pageY;
  } else if (e.pageY > oldY + threshold) {
    e.pageY - oldY;
    oldY = e.pageY;
  }
}
globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function __whenRemoved($elm) {
  return new Promise((resolve2, reject) => {
    const observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mutation) {
        mutation.removedNodes.forEach(function(removedNode) {
          if (removedNode === $elm) {
            resolve2($elm);
            observer.disconnect();
          }
        });
      });
    });
    observer.observe($elm.parentElement, {
      subtree: false,
      childList: true
    });
  });
}
function autoResize($textarea) {
  $textarea.style.boxSizing = "border-box";
  var offset2 = $textarea.offsetHeight - $textarea.clientHeight;
  $textarea.addEventListener("input", function(event) {
    event.target.style.height = "auto";
    event.target.style.height = event.target.scrollHeight + offset2 + "px";
  });
}
function __isInIframe() {
  try {
    return window.self !== window.top;
  } catch (e) {
    return true;
  }
}
var _a$7, _b$4;
let _isUserScrolling = false, _isUserScrollingTimeout;
try {
  (_a$7 = document === null || document === void 0 ? void 0 : document.addEventListener) === null || _a$7 === void 0 ? void 0 : _a$7.call(document, "wheel", (e) => {
    _isUserScrolling = true;
    clearTimeout(_isUserScrollingTimeout);
    _isUserScrollingTimeout = setTimeout(() => {
      _isUserScrolling = false;
    }, 200);
  });
  (_b$4 = document === null || document === void 0 ? void 0 : document.addEventListener) === null || _b$4 === void 0 ? void 0 : _b$4.call(document, "touchmove", (e) => {
    _isUserScrolling = true;
    clearTimeout(_isUserScrollingTimeout);
    _isUserScrollingTimeout = setTimeout(() => {
      _isUserScrolling = false;
    }, 200);
  });
} catch (e) {
}
function __isUserScrolling($elm) {
  if ($elm._isUserInteractive !== void 0) {
    return $elm._isUserInteractive && _isUserScrolling;
  }
  $elm.addEventListener("mouseover", (e) => {
    $elm._isUserInteractive = true;
  });
  $elm.addEventListener("mouseout", (e) => {
    $elm._isUserInteractive = false;
  });
  $elm.addEventListener("touchstart", (e) => {
    $elm._isUserInteractive = true;
  });
  $elm.addEventListener("touchend", (e) => {
    $elm._isUserInteractive = false;
  });
  return $elm._isUserInteractive && _isUserScrolling;
}
function __matches(el2, selector) {
  if (el2.nodeName == "#comment" || el2.nodeName == "#text") {
    return false;
  }
  const p = Element.prototype;
  const f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function(s) {
    return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
  };
  return f.call(el2, selector);
}
function __querySelectorUp($elm, selector) {
  const originalElm = $elm;
  $elm = $elm.parentNode;
  while ($elm && $elm != originalElm.ownerDocument) {
    if (typeof selector === "function") {
      if (selector($elm))
        return $elm;
    } else if (typeof selector === "string" && __matches($elm, selector)) {
      return $elm;
    }
    $elm = $elm.parentNode;
  }
  return null;
}
const _groups = {};
function _check() {
  for (let [group, stack] of Object.entries(_groups)) {
    let nearest = 9999999, $nearest;
    _groups[group] = _groups[group].filter((itemObj) => {
      const bound2 = itemObj.$target.getBoundingClientRect();
      if (!itemObj.$target.isConnected) {
        return false;
      }
      const percent = 100 / window.innerHeight * bound2.top;
      if (percent < itemObj.percentY && Math.abs(percent) - itemObj.percentY < nearest) {
        nearest = Math.abs(percent) - itemObj.percentY;
        $nearest = itemObj.$target;
      }
      return true;
    });
    for (let itemObj of stack) {
      if (itemObj.$target === $nearest) {
        if (itemObj.lastEmittedEvent === "activate") {
          continue;
        }
        itemObj.emit("activate", itemObj.$target);
        itemObj.lastEmittedEvent = "activate";
      } else {
        if (itemObj.lastEmittedEvent === "unactivate") {
          continue;
        }
        itemObj.emit("unactivate", itemObj.$target);
        itemObj.lastEmittedEvent = "unactivate";
      }
    }
  }
}
document.addEventListener("scroll", () => {
  _check();
});
let _firstCheckTimeout;
function __scrollSpy($target, settings) {
  return new SPromise(({ resolve: resolve2, reject, emit, on }) => {
    const finalSettings = Object.assign({ group: "default", percentY: 50 }, settings !== null && settings !== void 0 ? settings : {});
    function remove() {
      _groups[finalSettings.group] = _groups[finalSettings.group].filter((itemObj) => {
        return itemObj.$target !== $target;
      });
      if (!_groups[finalSettings.group].length) {
        delete _groups[finalSettings.group];
      }
    }
    on("finally", () => {
      remove();
    });
    if (!_groups[finalSettings.group]) {
      _groups[finalSettings.group] = [];
    }
    _groups[finalSettings.group].push({
      $target,
      percentY: finalSettings.percentY,
      emit
    });
    clearTimeout(_firstCheckTimeout);
    _firstCheckTimeout = setTimeout(() => {
      _check();
    });
  });
}
function __easeInOutQuad(t) {
  return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
}
let requestAnimationFrame$1;
try {
  requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
} catch (e) {
}
const requestAnimationFrame$2 = requestAnimationFrame$1;
var __awaiter$q = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function __scrollTo(target, settings = {}) {
  return new Promise((resolve2, reject) => __awaiter$q(this, void 0, void 0, function* () {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h, _j, _k, _l2, _m2, _o2, _p, _q, _r2, _s2, _t2, _u2, _v, _w, _x, _y, _z, _0, _1, _22;
    settings = Object.assign({ $elm: window, duration: (_f2 = (_e2 = (_d2 = (_c2 = (_b2 = (_a2 = document.env) === null || _a2 === void 0 ? void 0 : _a2.SUGAR) === null || _b2 === void 0 ? void 0 : _b2.theme) === null || _c2 === void 0 ? void 0 : _c2.get) === null || _d2 === void 0 ? void 0 : _d2.call(_c2, "scroll")) === null || _e2 === void 0 ? void 0 : _e2.duration) !== null && _f2 !== void 0 ? _f2 : 500, easing: __easeInOutQuad, offset: 0, offsetX: (_l2 = (_k = (_j = (_h = (_g2 = document.env) === null || _g2 === void 0 ? void 0 : _g2.SUGAR) === null || _h === void 0 ? void 0 : _h.theme) === null || _j === void 0 ? void 0 : _j.get) === null || _k === void 0 ? void 0 : _k.call(_j, "scroll")) === null || _l2 === void 0 ? void 0 : _l2.offsetX, offsetY: (_r2 = (_q = (_p = (_o2 = (_m2 = document.env) === null || _m2 === void 0 ? void 0 : _m2.SUGAR) === null || _o2 === void 0 ? void 0 : _o2.theme) === null || _p === void 0 ? void 0 : _p.get) === null || _q === void 0 ? void 0 : _q.call(_p, "scroll")) === null || _r2 === void 0 ? void 0 : _r2.offsetY, align: "start", justify: "start", onFinish: null, force: false }, settings);
    if (settings.$elm === document.body)
      settings.$elm = window;
    if (settings.$elm === document)
      settings.$elm = window;
    if (settings.$elm === document.querySelector("html"))
      settings.$elm = window;
    const $scrollElm = settings.$elm === window ? document.body : settings.$elm;
    let elmHeight = settings.$elm === window ? window.innerHeight : settings.$elm.offsetHeight;
    let elmWidth = settings.$elm === window ? window.innerWidth : settings.$elm.offsetWidth;
    let elmTop = settings.$elm === window ? 0 : (_s2 = settings.$elm) === null || _s2 === void 0 ? void 0 : _s2.getBoundingClientRect().top;
    let elmLeft = settings.$elm === window ? 0 : (_t2 = settings.$elm) === null || _t2 === void 0 ? void 0 : _t2.getBoundingClientRect().left;
    let maxScrollY = $scrollElm.scrollHeight - elmHeight;
    let maxScrollX = $scrollElm.scrollWidth - elmWidth;
    const currentY = settings.$elm === window ? window.pageYOffset : (_u2 = settings.$elm) === null || _u2 === void 0 ? void 0 : _u2.scrollTop;
    const currentX = settings.$elm === window ? window.pageXOffset : (_v = settings.$elm) === null || _v === void 0 ? void 0 : _v.scrollLeft;
    if (settings.$elm !== window) {
      const computedScrollStyles = window.getComputedStyle(settings.$elm);
      maxScrollY += parseInt(computedScrollStyles.paddingTop);
      maxScrollY += parseInt(computedScrollStyles.paddingBottom);
      maxScrollX += parseInt(computedScrollStyles.paddingLeft);
      maxScrollX += parseInt(computedScrollStyles.paddingRight);
    }
    let targetY = currentY, targetX = currentX;
    let targetBounds;
    try {
      if (window.getComputedStyle(target).display === "none") {
        target.style.display = "block";
      }
      targetBounds = target.getBoundingClientRect();
      target.style.display = null;
    } catch (e) {
      targetBounds = {
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      };
    }
    const offsetY = (_w = settings.offsetY) !== null && _w !== void 0 ? _w : settings.offset;
    const offsetX = (_x = settings.offsetX) !== null && _x !== void 0 ? _x : settings.offset;
    if (target === "top") {
      targetY = 0;
    } else if (target === "bottom") {
      targetY = (_z = (_y = settings.$elm) === null || _y === void 0 ? void 0 : _y.scrollHeight) !== null && _z !== void 0 ? _z : document.documentElement.scrollHeight;
    }
    if (target === "left") {
      targetX = 0;
    } else if (target === "right") {
      targetY = (_1 = (_0 = settings.$elm) === null || _0 === void 0 ? void 0 : _0.scrollWidth) !== null && _1 !== void 0 ? _1 : document.documentElement.scrollWidth;
    }
    if (settings.align === "center") {
      targetY += targetBounds.top + targetBounds.height / 2;
      targetY -= elmHeight / 2;
      targetY -= offsetY;
    } else if (settings.align === "end") {
      targetY += targetBounds.bottom;
      targetY -= elmHeight;
      targetY += offsetY;
    } else {
      targetY += targetBounds.top;
      targetY -= offsetY;
    }
    targetY = Math.max(Math.min(maxScrollY, targetY), 0);
    const deltaY = targetY - currentY - elmTop;
    if (settings.justify === "center") {
      targetX += targetBounds.left + targetBounds.width / 2;
      targetX -= elmWidth / 2;
      targetX -= offsetX;
    } else if (settings.justify === "end") {
      targetX += targetBounds.right;
      targetX -= elmWidth;
      targetX += offsetX;
    } else {
      targetX += targetBounds.left;
      targetX -= offsetX;
    }
    targetX = Math.max(Math.min(maxScrollX, targetX), 0);
    const deltaX = targetX - currentX - elmLeft;
    if ((_22 = settings.$elm) === null || _22 === void 0 ? void 0 : _22.getBoundingClientRect) {
      const elmBounds = settings.$elm.getBoundingClientRect();
      targetY -= elmBounds.top;
      targetX -= elmBounds.left;
    }
    const obj = {
      targetY,
      targetX,
      deltaY,
      deltaX,
      currentY,
      currentX,
      duration: settings.duration,
      easing: settings.easing,
      force: settings.force,
      $elm: settings.$elm,
      onFinish() {
        settings.onFinish && settings.onFinish();
        resolve2();
      },
      startTime: Date.now(),
      step: __scrollTo.step
    };
    requestAnimationFrame$2(obj.step.bind(obj));
  }));
}
__scrollTo.step = function() {
  const t = Math.min((Date.now() - this.startTime) / this.duration, 1);
  let $scrollElm = this.$elm;
  if (this.$elm === document.body || this.$elm === document) {
    $scrollElm = window;
  }
  const x = this.targetX - (1 - this.easing(t)) * this.deltaX;
  const y2 = this.targetY - (1 - this.easing(t)) * this.deltaY;
  $scrollElm.scrollTo(x, y2);
  if (!this.force && __isUserScrolling(this.$elm))
    return;
  if (t !== 1) {
    requestAnimationFrame$2(this.step.bind(this));
  } else {
    if (this.onFinish)
      this.onFinish();
  }
};
function __scrollToLocationHash(settings = {}) {
  settings = __deepMerge({
    scroll: {}
  }, settings);
  const hash2 = document.location.hash;
  if (!hash2)
    return;
  let targetElm;
  try {
    targetElm = document.querySelector(hash2);
  } catch (e) {
  }
  if (!targetElm)
    return;
  if ("scrollRestoration" in history) {
    history.scrollRestoration = "manual";
  }
  return __scrollTo(targetElm, settings.scroll);
}
/*! @license Rematrix v0.7.2

	Copyright 2021 Julian Lloyd.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
*/
function format(source2) {
  if (source2 && source2.constructor === Array) {
    var values = source2.filter(function(value) {
      return typeof value === "number";
    }).filter(function(value) {
      return !isNaN(value);
    });
    if (source2.length === 6 && values.length === 6) {
      var matrix = identity();
      matrix[0] = values[0];
      matrix[1] = values[1];
      matrix[4] = values[2];
      matrix[5] = values[3];
      matrix[12] = values[4];
      matrix[13] = values[5];
      return matrix;
    } else if (source2.length === 16 && values.length === 16) {
      return source2;
    }
  }
  throw new TypeError("Expected a `number[]` with length 6 or 16.");
}
function fromString(source2) {
  if (typeof source2 === "string") {
    var match2 = source2.match(/matrix(3d)?\(([^)]+)\)/);
    if (match2) {
      var raw = match2[2].split(",").map(parseFloat);
      return format(raw);
    }
    if (source2 === "none" || source2 === "") {
      return identity();
    }
  }
  throw new TypeError("Expected a string containing `matrix()` or `matrix3d()");
}
function identity() {
  var matrix = [];
  for (var i = 0; i < 16; i++) {
    i % 5 == 0 ? matrix.push(1) : matrix.push(0);
  }
  return matrix;
}
function multiply(matrixA, matrixB) {
  var fma = format(matrixA);
  var fmb = format(matrixB);
  var product = [];
  for (var i = 0; i < 4; i++) {
    var row = [fma[i], fma[i + 4], fma[i + 8], fma[i + 12]];
    for (var j = 0; j < 4; j++) {
      var k = j * 4;
      var col = [fmb[k], fmb[k + 1], fmb[k + 2], fmb[k + 3]];
      var result2 = row[0] * col[0] + row[1] * col[1] + row[2] * col[2] + row[3] * col[3];
      product[i + k] = result2;
    }
  }
  return product;
}
function rotateX(angle) {
  var theta = Math.PI / 180 * angle;
  var matrix = identity();
  matrix[5] = matrix[10] = Math.cos(theta);
  matrix[6] = matrix[9] = Math.sin(theta);
  matrix[9] *= -1;
  return matrix;
}
function rotateY(angle) {
  var theta = Math.PI / 180 * angle;
  var matrix = identity();
  matrix[0] = matrix[10] = Math.cos(theta);
  matrix[2] = matrix[8] = Math.sin(theta);
  matrix[2] *= -1;
  return matrix;
}
function rotateZ(angle) {
  var theta = Math.PI / 180 * angle;
  var matrix = identity();
  matrix[0] = matrix[5] = Math.cos(theta);
  matrix[1] = matrix[4] = Math.sin(theta);
  matrix[4] *= -1;
  return matrix;
}
function toString$1(source2) {
  return "matrix3d(" + format(source2).join(", ") + ")";
}
function translate3d(distanceX, distanceY, distanceZ) {
  var matrix = identity();
  if (distanceX !== void 0 && distanceY !== void 0 && distanceZ !== void 0) {
    matrix[12] = distanceX;
    matrix[13] = distanceY;
    matrix[14] = distanceZ;
  }
  return matrix;
}
function translateX(distance) {
  var matrix = identity();
  matrix[12] = distance;
  return matrix;
}
function translateY(distance) {
  var matrix = identity();
  matrix[13] = distance;
  return matrix;
}
function __clearTransmations($elm = document.body, settings) {
  const cls = `s-clear-transmations-${__uniqid()}`;
  $elm.classList.add(cls);
  const $tag = document.createElement("style");
  $tag.type = "text/css";
  $tag.innerHTML = `
        .${cls},
        .${cls}:before,
        .${cls}:after,
        .${cls} *,
        .${cls} *:before,
        .${cls} *:after {
            animation: none !important;
            transition: none !important;
        }
    `;
  document.head.appendChild($tag);
  function reset() {
    $elm.classList.remove(cls);
    $tag.remove();
  }
  if (settings === null || settings === void 0 ? void 0 : settings.timeout) {
    setTimeout(() => {
      reset();
    }, settings.timeout);
  }
  return reset;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "x" : "y";
}
function getLengthFromAxis(axis) {
  return axis === "y" ? "height" : "width";
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  const commonAlign = reference[length] / 2 - floating[length] / 2;
  const side = getSide(placement);
  const isVertical = mainAxis === "x";
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config2;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  {
    if (platform2 == null) {
      console.error(["Floating UI: `platform` property was not passed to config. If you", "want to use Floating UI on the web, install @floating-ui/dom", "instead of the /core package. Otherwise, you can create your own", "`platform`: https://floating-ui.com/docs/platform"].join(" "));
    }
    if (middleware.filter((_ref) => {
      let {
        name: name2
      } = _ref;
      return name2 === "autoPlacement" || name2 === "flip";
    }).length > 1) {
      throw new Error(["Floating UI: duplicate `flip` and/or `autoPlacement`", "middleware detected. This will lead to an infinite loop. Ensure only", "one of either has been passed to the `middleware` array."].join(" "));
    }
  }
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < middleware.length; i++) {
    const {
      name: name2,
      fn: fn2
    } = middleware[i];
    const {
      x: nextX,
      y: nextY,
      data: data2,
      reset
    } = await fn2({
      x,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name2]: {
        ...middlewareData[name2],
        ...data2
      }
    };
    {
      if (resetCount > 50) {
        console.warn(["Floating UI: The middleware lifecycle appears to be running in an", "infinite loop. This is usually caused by a `reset` continually", "being returned without a break condition."].join(" "));
      }
    }
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
      continue;
    }
  }
  return {
    x,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getSideObjectFromPadding(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
async function detectOverflow(middlewareArguments, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = middlewareArguments;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = options;
  const paddingObject = getSideObjectFromPadding(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: elementContext === "floating" ? {
      ...rects.floating,
      x,
      y: y2
    } : rects.reference,
    offsetParent: await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating)),
    strategy
  }) : rects[elementContext]);
  return {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
}
const min$1 = Math.min;
const max$2 = Math.max;
function within(min$1$1, value, max$12) {
  return max$2(min$1$1, min$1(value, max$12));
}
const arrow = (options) => ({
  name: "arrow",
  options,
  async fn(middlewareArguments) {
    const {
      element,
      padding = 0
    } = options != null ? options : {};
    const {
      x,
      y: y2,
      placement,
      rects,
      platform: platform2
    } = middlewareArguments;
    if (element == null) {
      {
        console.warn("Floating UI: No `element` was passed to the `arrow` middleware.");
      }
      return {};
    }
    const paddingObject = getSideObjectFromPadding(padding);
    const coords = {
      x,
      y: y2
    };
    const axis = getMainAxisFromPlacement(placement);
    const alignment = getAlignment(placement);
    const length = getLengthFromAxis(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const minProp = axis === "y" ? "top" : "left";
    const maxProp = axis === "y" ? "bottom" : "right";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    if (clientSize === 0) {
      clientSize = rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const min2 = paddingObject[minProp];
    const max2 = clientSize - arrowDimensions[length] - paddingObject[maxProp];
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = within(min2, center, max2);
    const alignmentPadding = alignment === "start" ? paddingObject[minProp] : paddingObject[maxProp];
    const shouldAddOffset = alignmentPadding > 0 && center !== offset2 && rects.reference[length] <= rects.floating[length];
    const alignmentOffset = shouldAddOffset ? center < min2 ? min2 - center : max2 - center : 0;
    return {
      [axis]: coords[axis] - alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2
      }
    };
  }
});
const hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (matched) => hash$1[matched]);
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement(mainAlignmentSide)
  };
}
const hash = {
  start: "end",
  end: "start"
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (matched) => hash[matched]);
}
const sides = ["top", "right", "bottom", "left"];
const allPlacements = /* @__PURE__ */ sides.reduce((acc, side) => acc.concat(side, side + "-start", side + "-end"), []);
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getSide(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter((placement) => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
const autoPlacement = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "autoPlacement",
    options,
    async fn(middlewareArguments) {
      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _placementsSortedByLe;
      const {
        x,
        y: y2,
        rects,
        middlewareData,
        placement,
        platform: platform2,
        elements
      } = middlewareArguments;
      const {
        alignment = null,
        allowedPlacements = allPlacements,
        autoAlignment = true,
        ...detectOverflowOptions
      } = options;
      const placements = getPlacementList(alignment, autoAlignment, allowedPlacements);
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const currentIndex = (_middlewareData$autoP = (_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.index) != null ? _middlewareData$autoP : 0;
      const currentPlacement = placements[currentIndex];
      if (currentPlacement == null) {
        return {};
      }
      const {
        main: main2,
        cross
      } = getAlignmentSides(currentPlacement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
      if (placement !== currentPlacement) {
        return {
          x,
          y: y2,
          reset: {
            placement: placements[0]
          }
        };
      }
      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main2], overflow[cross]];
      const allOverflows = [...(_middlewareData$autoP3 = (_middlewareData$autoP4 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP4.overflows) != null ? _middlewareData$autoP3 : [], {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements[currentIndex + 1];
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b) => a.overflows[0] - b.overflows[0]);
      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find((_ref) => {
        let {
          overflows
        } = _ref;
        return overflows.every((overflow2) => overflow2 <= 0);
      })) == null ? void 0 : _placementsSortedByLe.placement;
      const resetPlacement = placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement;
      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
const flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(middlewareArguments) {
      var _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = middlewareArguments;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        flipAlignment = true,
        ...detectOverflowOptions
      } = options;
      const side = getSide(placement);
      const isBasePlacement = side === initialPlacement;
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const {
          main: main2,
          cross
        } = getAlignmentSides(placement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
        overflows.push(overflow[main2], overflow[cross]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip$, _middlewareData$flip2;
        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = "bottom";
        switch (fallbackStrategy) {
          case "bestFit": {
            var _overflowsData$map$so;
            const placement2 = (_overflowsData$map$so = overflowsData.map((d2) => [d2, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;
            if (placement2) {
              resetPlacement = placement2;
            }
            break;
          }
          case "initialPlacement":
            resetPlacement = initialPlacement;
            break;
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(middlewareArguments, value) {
  const {
    placement,
    platform: platform2,
    elements
  } = middlewareArguments;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getMainAxisFromPlacement(placement) === "x";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = typeof value === "function" ? value(middlewareArguments) : value;
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset = function(value) {
  if (value === void 0) {
    value = 0;
  }
  return {
    name: "offset",
    options: value,
    async fn(middlewareArguments) {
      const {
        x,
        y: y2
      } = middlewareArguments;
      const diffCoords = await convertValueToCoords(middlewareArguments, value);
      return {
        x: x + diffCoords.x,
        y: y2 + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
function getCrossAxis(axis) {
  return axis === "x" ? "y" : "x";
}
const shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(middlewareArguments) {
      const {
        x,
        y: y2,
        placement
      } = middlewareArguments;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y3
            } = _ref;
            return {
              x: x2,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = options;
      const coords = {
        x,
        y: y2
      };
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement(getSide(placement));
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = within(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = within(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...middlewareArguments,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y2
        }
      };
    }
  };
};
const inline = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "inline",
    options,
    async fn(middlewareArguments) {
      var _await$platform$getCl;
      const {
        placement,
        elements,
        rects,
        platform: platform2,
        strategy
      } = middlewareArguments;
      const {
        padding = 2,
        x,
        y: y2
      } = options;
      const fallback = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
        rect: rects.reference,
        offsetParent: await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating)),
        strategy
      }) : rects.reference);
      const clientRects = (_await$platform$getCl = await (platform2.getClientRects == null ? void 0 : platform2.getClientRects(elements.reference))) != null ? _await$platform$getCl : [];
      const paddingObject = getSideObjectFromPadding(padding);
      function getBoundingClientRect2() {
        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y2 != null) {
          var _clientRects$find;
          return (_clientRects$find = clientRects.find((rect) => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y2 > rect.top - paddingObject.top && y2 < rect.bottom + paddingObject.bottom)) != null ? _clientRects$find : fallback;
        }
        if (clientRects.length >= 2) {
          if (getMainAxisFromPlacement(placement) === "x") {
            const firstRect = clientRects[0];
            const lastRect = clientRects[clientRects.length - 1];
            const isTop = getSide(placement) === "top";
            const top2 = firstRect.top;
            const bottom2 = lastRect.bottom;
            const left2 = isTop ? firstRect.left : lastRect.left;
            const right2 = isTop ? firstRect.right : lastRect.right;
            const width2 = right2 - left2;
            const height2 = bottom2 - top2;
            return {
              top: top2,
              bottom: bottom2,
              left: left2,
              right: right2,
              width: width2,
              height: height2,
              x: left2,
              y: top2
            };
          }
          const isLeftSide = getSide(placement) === "left";
          const maxRight = max$2(...clientRects.map((rect) => rect.right));
          const minLeft = min$1(...clientRects.map((rect) => rect.left));
          const measureRects = clientRects.filter((rect) => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
          const top = measureRects[0].top;
          const bottom = measureRects[measureRects.length - 1].bottom;
          const left = minLeft;
          const right = maxRight;
          const width = right - left;
          const height = bottom - top;
          return {
            top,
            bottom,
            left,
            right,
            width,
            height,
            x: left,
            y: top
          };
        }
        return fallback;
      }
      const resetRects = await platform2.getElementRects({
        reference: {
          getBoundingClientRect: getBoundingClientRect2
        },
        floating: elements.floating,
        strategy
      });
      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
        return {
          reset: {
            rects: resetRects
          }
        };
      }
      return {};
    }
  };
};
function isWindow(value) {
  return value && value.document && value.location && value.alert && value.setInterval;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (!isWindow(node)) {
    const ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeName(node) {
  return isWindow(node) ? "" : node ? (node.nodeName || "").toLowerCase() : "";
}
function getUAString() {
  const uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands) {
    return uaData.brands.map((item) => item.brand + "/" + item.version).join(" ");
  }
  return navigator.userAgent;
}
function isHTMLElement(value) {
  return value instanceof getWindow(value).HTMLElement;
}
function isElement(value) {
  return value instanceof getWindow(value).Element;
}
function isNode(value) {
  return value instanceof getWindow(value).Node;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  const OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const isFirefox = /firefox/i.test(getUAString());
  const css2 = getComputedStyle$1(element);
  return css2.transform !== "none" || css2.perspective !== "none" || // @ts-ignore (TS 4.1 compat)
  css2.contain === "paint" || ["transform", "perspective"].includes(css2.willChange) || isFirefox && css2.willChange === "filter" || isFirefox && (css2.filter ? css2.filter !== "none" : false);
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
const min = Math.min;
const max$1 = Math.max;
const round = Math.round;
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  let scaleX = 1;
  let scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  const win = isElement(element) ? getWindow(element) : window;
  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  const x = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;
  const y2 = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;
  const width = clientRect.width / scaleX;
  const height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y2,
    right: x + width,
    bottom: y2 + height,
    left: x,
    x,
    y: y2
  };
}
function getDocumentElement(node) {
  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function isScaled(element) {
  const rect = getBoundingClientRect(element);
  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const rect = getBoundingClientRect(
    element,
    // @ts-ignore - checked above (TS 4.1 compat)
    isOffsetParentAnElement && isScaled(offsetParent),
    strategy === "fixed"
  );
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // @ts-ignore
    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    node.parentNode || // DOM Element detected
    (isShadowRoot(node) ? node.host : null) || // ShadowRoot detected
    getDocumentElement(node)
  );
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && !["html", "body"].includes(getNodeName(currentNode))) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  const window2 = getWindow(element);
  let offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getDimensions(element) {
  if (isHTMLElement(element)) {
    return {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
  }
  const rect = getBoundingClientRect(element);
  return {
    width: rect.width,
    height: rect.height
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    ...rect,
    x: rect.x - scroll.scrollLeft + offsets.x,
    y: rect.y - scroll.scrollTop + offsets.y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html2 = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html2.clientWidth;
  let height = html2.clientHeight;
  let x = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y: y2
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  const html2 = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  const width = max$1(html2.scrollWidth, html2.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  const height = max$1(html2.scrollHeight, html2.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body || html2).direction === "rtl") {
    x += max$1(html2.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y: y2
  };
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (["html", "body", "#document"].includes(getNodeName(parentNode))) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list2) {
  var _node$ownerDocument;
  if (list2 === void 0) {
    list2 = [];
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow(scrollableAncestor);
  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;
  const updatedList = list2.concat(target);
  return isBody ? updatedList : (
    // @ts-ignore: isBody tells us target will be an HTMLElement here
    updatedList.concat(getOverflowAncestors(target))
  );
}
function contains$2(parent, child) {
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    do {
      if (next && parent === next) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, false, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  return {
    top,
    left,
    x: left,
    y: top,
    right: left + element.clientWidth,
    bottom: top + element.clientHeight,
    width: element.clientWidth,
    height: element.clientHeight
  };
}
function getClientRectFromClippingAncestor(element, clippingParent, strategy) {
  if (clippingParent === "viewport") {
    return rectToClientRect(getViewportRect(element, strategy));
  }
  if (isElement(clippingParent)) {
    return getInnerBoundingClientRect(clippingParent, strategy);
  }
  return rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingAncestors(element) {
  const clippingAncestors = getOverflowAncestors(element);
  const canEscapeClipping = ["absolute", "fixed"].includes(getComputedStyle$1(element).position);
  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingAncestors.filter((clippingAncestors2) => isElement(clippingAncestors2) && contains$2(clippingAncestors2, clipperElement) && getNodeName(clippingAncestors2) !== "body");
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const mainClippingAncestors = boundary === "clippingAncestors" ? getClippingAncestors(element) : [].concat(boundary);
  const clippingAncestors = [...mainClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max$1(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max$1(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
const platform = {
  getClippingRect,
  convertOffsetParentRelativeRectToViewportRelativeRect,
  isElement,
  getDimensions,
  getOffsetParent,
  getDocumentElement,
  getElementRects: (_ref) => {
    let {
      reference,
      floating,
      strategy
    } = _ref;
    return {
      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),
      floating: {
        ...getDimensions(floating),
        x: 0,
        y: 0
      }
    };
  },
  getClientRects: (element) => Array.from(element.getClientRects()),
  isRTL: (element) => getComputedStyle$1(element).direction === "rtl"
};
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll: _ancestorScroll = true,
    ancestorResize: _ancestorResize = true,
    elementResize = true,
    animationFrame = false
  } = options;
  const ancestorScroll = _ancestorScroll && !animationFrame;
  const ancestorResize = _ancestorResize && !animationFrame;
  const ancestors = ancestorScroll || ancestorResize ? [...isElement(reference) ? getOverflowAncestors(reference) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  let observer = null;
  if (elementResize) {
    let initialUpdate = true;
    observer = new ResizeObserver(() => {
      if (!initialUpdate) {
        update();
      }
      initialUpdate = false;
    });
    isElement(reference) && !animationFrame && observer.observe(reference);
    observer.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _observer;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    (_observer = observer) == null ? void 0 : _observer.disconnect();
    observer = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const computePosition = (reference, floating, options) => computePosition$1(reference, floating, {
  platform,
  ...options
});
var __awaiter$p = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function __makeFloat($elm, $depending, settings) {
  const finalSettings = Object.assign({ position: "auto", shift: 10, offset: 0, arrow: false, arrowSize: 15, arrowPadding: 10 }, settings !== null && settings !== void 0 ? settings : {});
  $depending.classList.add("s-floating");
  const middlewares = [
    offset(finalSettings.offset),
    shift({
      padding: finalSettings.shift
    }),
    inline()
  ];
  if (finalSettings.position !== "auto") {
    middlewares.push(flip());
  } else {
    middlewares.push(autoPlacement());
  }
  let $arrow;
  if (finalSettings.arrow) {
    $arrow = document.createElement("div");
    $arrow.classList.add("s-floating_arrow");
    $elm.append($arrow);
    middlewares.push(arrow({
      element: $arrow,
      padding: finalSettings.arrowPadding
    }));
  }
  if (finalSettings.arrowSize) {
    $elm.style.setProperty(`--arrow-size`, `${finalSettings.arrowSize}px`);
  }
  const update = () => __awaiter$p(this, void 0, void 0, function* () {
    yield computePosition($depending, $elm, {
      // @ts-ignore
      placement: finalSettings.position,
      middleware: middlewares
    });
    computePosition($depending, $elm, {
      // @ts-ignore
      placement: finalSettings.position,
      middleware: middlewares
    }).then(({ x, y: y2, placement, middlewareData }) => {
      Object.assign($elm.style, {
        position: "absolute",
        top: `${y2}px`,
        left: `${x}px`
      });
      if (middlewareData.arrow) {
        const staticSide = {
          top: "bottom",
          right: "left",
          bottom: "top",
          left: "right"
        }[placement.split("-")[0]];
        Object.assign($arrow.style, {
          position: "absolute",
          left: middlewareData.arrow.x != null ? `${middlewareData.arrow.x}px` : "",
          top: middlewareData.arrow.y != null ? `${middlewareData.arrow.y}px` : "",
          right: "",
          bottom: "",
          [staticSide]: "-4px"
        });
      }
    });
  });
  update();
  const cancel = autoUpdate($depending, $elm, () => {
    update();
  });
  __whenRemoved($elm).then(() => {
    cancel();
  });
  __whenRemoved($depending).then(() => {
    cancel();
  });
  $depending.addEventListener("pointerover", () => {
    update();
  });
  return {
    update,
    cancel
  };
}
let map$1 = {};
try {
  map$1 = {
    a: window.HTMLAnchorElement,
    audio: window.HTMLAudioElement,
    body: window.HTMLBodyElement,
    button: window.HTMLButtonElement,
    canvas: window.HTMLCanvasElement,
    dl: window.HTMLDListElement,
    data: window.HTMLDataElement,
    datalist: window.HTMLDataListElement,
    details: window.HTMLDetailsElement,
    // dialog: window.HTMLDialogElement,
    dir: window.HTMLDirectoryElement,
    div: window.HTMLDivElement,
    html: window.HTMLDocument,
    embed: window.HTMLEmbedElement,
    fieldset: window.HTMLFieldSetElement,
    font: window.HTMLFontElement,
    form: window.HTMLFormElement,
    frame: window.HTMLFrameElement,
    h1: window.HTMLTitleElement,
    h2: window.HTMLTitleElement,
    h3: window.HTMLTitleElement,
    h4: window.HTMLTitleElement,
    h5: window.HTMLTitleElement,
    h6: window.HTMLTitleElement,
    head: window.HTMLHeadElement,
    html: window.HTMLHtmlElement,
    iframe: window.HTMLIFrameElement,
    img: window.HTMLImageElement,
    input: window.HTMLInputElement,
    label: window.HTMLLabelElement,
    legend: window.HTMLLegendElement,
    link: window.HTMLLinkElement,
    map: window.HTMLMapElement,
    marquee: window.HTMLMarqueeElement,
    media: window.HTMLMediaElement,
    menu: window.HTMLMenuElement,
    meta: window.HTMLMetaElement,
    meter: window.HTMLMeterElement,
    del: window.HTMLModElement,
    ins: window.HTMLModElement,
    dol: window.HTMLOListElement,
    object: window.HTMLObjectElement,
    optgroup: window.HTMLOptGroupElement,
    option: window.HTMLOptionElement,
    output: window.HTMLOutputElement,
    p: window.HTMLParagraphElement,
    param: window.HTMLParamElement,
    picture: window.HTMLPictureElement,
    pre: window.HTMLPreElement,
    progress: window.HTMLProgressElement,
    quote: window.HTMLQuoteElement,
    script: window.HTMLScriptElement,
    select: window.HTMLSelectElement,
    slot: window.HTMLSlotElement,
    source: window.HTMLSourceElement,
    span: window.HTMLSpanElement,
    style: window.HTMLStyleElement,
    td: window.HTMLTableCellElement,
    th: window.HTMLTableCellElement,
    col: window.HTMLTableColElement,
    colgroup: window.HTMLTableColElement,
    table: window.HTMLTableElement,
    tr: window.HTMLTableRowElement,
    tfoot: window.HTMLTableSectionElement,
    thead: window.HTMLTableSectionElement,
    tbody: window.HTMLTableSectionElement,
    template: window.HTMLTemplateElement,
    textarea: window.HTMLTextAreaElement,
    time: window.HTMLTimeElement,
    title: window.HTMLTitleElement,
    track: window.HTMLTrackElement,
    ul: window.HTMLUListElement,
    video: window.HTMLVideoElement,
    area: window.HTMLAreaElement
  };
} catch (e) {
}
function __splitLetters(elm, settings = {}) {
  settings = Object.assign({ tag: "span", class: "s-split-letters", letterClass: "s-split-letter" }, settings);
  let string = elm._splitLettersOriginalString;
  if (!string) {
    string = elm.innerHTML;
    elm._splitLettersOriginalString = string;
  }
  elm.classList.add(settings.class);
  function process2(nodes) {
    nodes.forEach((node) => {
      if (node.childNodes.length) {
        process2(node.childNodes);
      }
      if (node.nodeName === "#text") {
        const newValue = node.textContent.split("").map((letter) => {
          return `<${settings.tag}>${letter}</span>`;
        }).join("");
        const $wrap = document.createElement(settings.tag);
        $wrap.innerHTML = newValue;
        Array.from($wrap.children).forEach((child) => child.classList.add(settings.letterClass));
        $wrap.classList.add(settings.class);
        node.after($wrap);
        node.remove();
      }
    });
  }
  process2(elm.childNodes);
  return elm;
}
class SClassmapBase extends SClass {
  /**
   * @name            constructor
   * @type            Function
   * @constructor
   *
   * Constructor
   *
   * @since       2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  constructor(settings) {
    super(__deepMerge({
      path: void 0,
      map: void 0
    }, settings !== null && settings !== void 0 ? settings : {}));
    if (this.settings.map) {
      this.map = this.settings.map;
    }
  }
  /**
   * @name            patchHtml
   * @type        Function
   *
   * This method takes an html string and replace all the classnames that are present in the classmap
   *
   * @param       {String}            html            The html to process
   * @return      {String}                            The processed html
   *
   * @since       2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  // patchHtml(html: string): string {
  //     console.log('patch', html);
  // }
  /**
   * @name            patchHtml
   * @type            Function
   * @platform        php
   * @status          beta
   *
   * This method allows you to patch the passed html and replace in it all the available
   * classes in the map
   *
   * @param       {String}            $html           The html to patch
   * @return      {String}                            The patched html
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  patchHtml(html2) {
    let reg = /class="[a-zA-Z0-9_\-:@\s]+"/gm, needClassAttr = true;
    if (html2.trim().match(/class="[a-zA-Z0-9_\-:@\s]+$/)) {
      reg = /class="[a-zA-Z0-9_\-:@\s]+"?/gm;
    } else if (html2.trim().match(/^[a-zA-Z0-9_\-:@\s]+$/)) {
      reg = /[a-zA-Z0-9_\-:@\s]+/gm;
      needClassAttr = false;
    }
    const matches = html2.match(reg);
    if (!matches)
      return html2;
    matches.forEach((match2) => {
      const endQuote = match2.match(/"$/) ? '"' : "";
      const classesStr = match2.replace('class="', "").replace('"', "");
      const newClassesNames = classesStr.split(" ").map((cls) => {
        var _a2;
        return (_a2 = this.map[cls]) !== null && _a2 !== void 0 ? _a2 : cls;
      });
      if (needClassAttr) {
        html2 = html2.replace(match2, `class="${newClassesNames.join(" ")}${endQuote}`);
      } else {
        html2 = html2.replace(match2, `${newClassesNames.join(" ")}${endQuote}`);
      }
    });
    return html2;
  }
}
var __awaiter$o = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SClassmap extends SClassmapBase {
  /**
   * @name            init
   * @type            Function
   * @static
   *
   * This method allows you to init the your SClassmap instance and store it into the document.env.SUGAR.classmap property
   *
   * @return          {SClassmap}                                    The SClassmal instance that represent the classmap.json file
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static init(settings) {
    let classmapInstance = new this(settings);
    if (!document.env)
      document.env = {};
    if (!document.env.SUGAR)
      document.env.SUGAR = {};
    document.env.SUGAR.classmap = classmapInstance;
    return classmapInstance;
  }
  /**
   * @name           isEnabled
   * @type            Function
   * @static
   *
   * Store if the classmap if enabled or not
   *
   * @return      {Boolean}       true if enabled, false if not. Basically, the classmap is enabled if a `document.env.CLASSMAP` map exists
   *
   * @since       2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  static isEnabled() {
    var _a2;
    return ((_a2 = document.env) === null || _a2 === void 0 ? void 0 : _a2.CLASSMAP) !== void 0;
  }
  static areNativeMethodsPatched() {
    return this._areNativeMethodsPatched;
  }
  /**
   * @name            constructor
   * @type            Function
   * @constructor
   *
   * Constructor
   *
   * @since       2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  constructor(settings) {
    var _a2, _b2;
    super(Object.assign({ map: (_b2 = (_a2 = document.env) === null || _a2 === void 0 ? void 0 : _a2.CLASSMAP) !== null && _b2 !== void 0 ? _b2 : {}, patchNativeMethods: true }, settings !== null && settings !== void 0 ? settings : {}));
    if (this.settings.patchNativeMethods && !this.constructor.areNativeMethodsPatched()) {
      this.patchNativeMethods();
    }
    this.patchDomLive();
  }
  /**
   * @name        patchNativeMethods
   * @type        Function
   *
   * This method will patch the native methods like classList.add, style.setProperty, etc... to make use
   * of the classmap
   *
   * @since       2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  patchNativeMethods() {
    const _this = this;
    this.constructor._areNativeMethodsPatched = true;
    function getClassList() {
      var element = this;
      var classList = this.className.split(" ");
      classList.add = function(name2) {
        var _a2;
        const finalName = (_a2 = _this.map[name2]) !== null && _a2 !== void 0 ? _a2 : name2;
        if (classList.indexOf(finalName) !== -1) {
          return;
        }
        classList.push(finalName);
        element.className = classList.join(" ");
      };
      classList.remove = function(name2) {
        var _a2;
        const finalName = (_a2 = _this.map[name2]) !== null && _a2 !== void 0 ? _a2 : name2;
        var index = classList.indexOf(finalName);
        if (index !== -1) {
          classList.splice(index, 1);
          element.className = classList.join(" ");
        }
      };
      classList.contains = function(name2) {
        var _a2;
        return classList.indexOf((_a2 = _this.map[name2]) !== null && _a2 !== void 0 ? _a2 : name2) !== -1;
      };
      return classList;
    }
    Object.defineProperty(HTMLElement.prototype, "classList", {
      get: getClassList
    });
    const nativeQuerySelectorAll = Element.prototype.querySelectorAll;
    Element.prototype.querySelectorAll = function(...sels) {
      const newSels = sels.map((sel) => {
        return _this.patchSelector(sel);
      });
      return nativeQuerySelectorAll.call(this, [...sels, ...newSels]);
    };
    const nativeQuerySelector = Element.prototype.querySelector;
    Element.prototype.querySelector = function(...sels) {
      const newSels = sels.map((sel) => {
        const newSel = _this.patchSelector(sel);
        return newSel;
      });
      return nativeQuerySelector.call(this, [...sels, ...newSels]);
    };
  }
  resolve(cls) {
    var _a2, _b2;
    return (_b2 = (_a2 = this.map[cls]) !== null && _a2 !== void 0 ? _a2 : this.map[cls.replace(/^\./, "")]) !== null && _b2 !== void 0 ? _b2 : cls;
  }
  patchElement($elm) {
    var _a2, _b2;
    const cls = (_b2 = (_a2 = $elm.getAttribute("class")) === null || _a2 === void 0 ? void 0 : _a2.split(" ")) !== null && _b2 !== void 0 ? _b2 : [];
    const newCls = cls.map((c) => this.resolve(c));
    $elm.setAttribute("class", newCls.join(" "));
  }
  patchDomLive($rootNode = document) {
    const patchDomLiveCallback = (mutationList) => {
      mutationList.forEach((mutation) => {
        if (mutation.addedNodes) {
          mutation.addedNodes.forEach((node) => {
            if (!node.matches)
              return;
            this.patchElement(node);
            this.patchDom(node);
          });
        }
        if (mutation.attributeName === "class") {
          if (mutation.target._classmapProcessing) {
            return;
          }
          clearTimeout(mutation.target._classmapTimeout);
          mutation.target._classmapTimeout = setTimeout(() => {
            mutation.target._classmapProcessing = true;
            this.patchElement(mutation.target);
            setTimeout(() => {
              mutation.target._classmapProcessing = false;
            });
          });
        }
      });
    };
    const observer = new MutationObserver(patchDomLiveCallback);
    observer.observe($rootNode, {
      attributeFilter: ["class"],
      attributeOldValue: true,
      childList: true,
      subtree: true
    });
  }
  patchDom($rootNode) {
    var _a2;
    const $elms = Array.from((_a2 = $rootNode.querySelectorAll("[class]")) !== null && _a2 !== void 0 ? _a2 : []);
    for (let [idx, $elm] of $elms.entries()) {
      this.patchElement($elm);
    }
  }
  patchHtml(html2) {
    const classesMatches = html2.match(/class="([a-zA-Z0-9_-\s]+)"/gm);
    if (classesMatches === null || classesMatches === void 0 ? void 0 : classesMatches.length) {
      classesMatches.forEach((clsStatement) => {
        let sels = clsStatement.replace('class="', "").replace(/\"$/, "").split(" ");
        sels = sels.map((sel) => {
          return this.resolve(sel);
        });
        html2 = html2.replace(clsStatement, `class="${sels.join(" ")}"`);
      });
    }
    return html2;
  }
  patchSelector(sel) {
    const newSel = sel.split(" ").map((part) => {
      const classMatches = part.match(/\.[a-zA-Z0-9_-]+/gm);
      if (classMatches) {
        classMatches.forEach((cls) => {
          var _a2;
          const clsWithoutDot = cls.slice(1);
          part = part.replace(cls, `.${(_a2 = this.map[clsWithoutDot]) !== null && _a2 !== void 0 ? _a2 : clsWithoutDot}`);
        });
      }
      return part;
    }).join(" ");
    return newSel;
  }
  /**
   * @name      loadFromUrl
   * @type        Function
   * @async
   *
   * Load a classmap from a url
   *
   * @param       {string}               url      The url to load the map from
   * @return      {Promise<Object>}               The loaded classmap
   *
   * @since       2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  loadFromUrl(url) {
    return new Promise((resolve2) => __awaiter$o(this, void 0, void 0, function* () {
      const res = yield fetch(url).then((response) => response.json());
      this.map = res;
      resolve2(res);
    }));
  }
}
class SFrontspec {
  /**
   * @name            init
   * @type            Function
   * @static
   *
   * This method allows you to init the your SFrontspec instance and store it into the document.env.SUGAR.frontspec property
   *
   * @return          {SFrontspec}                                    The SFrontspec instance that represent the frontspec.json file
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static init(frontspec) {
    let frontspecInstance = new this(frontspec);
    if (!document.env)
      document.env = {};
    if (!document.env.SUGAR)
      document.env.SUGAR = {};
    document.env.SUGAR.frontspec = frontspecInstance;
    return frontspecInstance;
  }
  /**
   * @name        get
   * @type        Function
   * @static
   *
   * Access a frontspec value by passing a dotpath like "partytown.enabled", or by accessing the full frontspec object by using `.get()` call.
   *
   * @param       {String}        [dotpah="."]            The dotpath of the frontspec value you want to access
   * @return      {Any}                                   The getted frontspec value
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static get(dotpath = ".") {
    if (!this._defaultFrontspecInstance) {
      this._defaultFrontspecInstance = SFrontspec.init();
    }
    return this._defaultFrontspecInstance.get(dotpath);
  }
  /**
   * @name        metas
   * @type        ISFrontspecMetas
   * @private
   *
   * Store the frontspec metas object
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get metas() {
    return this._frontspec.metas;
  }
  /**
   * @name        package
   * @type        ISFrontspecPackage
   * @private
   *
   * Store the frontspec package object
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get package() {
    return this._frontspec.package;
  }
  /**
   * @name        assets
   * @type        ISFrontspecAssets
   * @private
   *
   * Store the frontspec assets object
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get assets() {
    return this._frontspec.assets;
  }
  /**
   * @name        favicon
   * @type        ISFrontspecFavicon
   * @private
   *
   * Store the frontspec favicon object
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get favicon() {
    return this._frontspec.favicon;
  }
  /**
   * @name        theme
   * @type        ISFrontspecTheme
   * @private
   *
   * Store the frontspec theme object
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get theme() {
    return this._frontspec.theme;
  }
  /**
   * @name        media
   * @type        ISFrontspecMedia
   * @private
   *
   * Store the frontspec media object
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get media() {
    return this._frontspec.media;
  }
  /**
   * @name        views
   * @type        ISFrontspecViews
   * @private
   *
   * Store the frontspec views object
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get views() {
    return this._frontspec.views;
  }
  /**
   * @name        specs
   * @type        ISFrontspecSpecs
   * @private
   *
   * Store the frontspec specs object
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get specs() {
    return this._frontspec.specs;
  }
  /**
   * @name        google
   * @type        ISFrontspecGoogle
   * @private
   *
   * Store the frontspec google object
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get google() {
    return this._frontspec.google;
  }
  /**
   * @name        lod
   * @type        ISFrontspecLod
   * @private
   *
   * Store the frontspec lod object
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get lod() {
    return this._frontspec.lod;
  }
  /**
   * @name        partytown
   * @type        ISFrontspecPartytown
   * @private
   *
   * Store the frontspec partytown object
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get partytown() {
    return this._frontspec.partytown;
  }
  /**
   * @name            constructor
   * @type            Function
   * @constructor
   *
   * Constructor
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  constructor(frontspec = {}) {
    var _a2;
    this._frontspec = {};
    this.constructor._defaultFrontspecInstance = this;
    this._frontspec = __deepMerge(((_a2 = document.env) === null || _a2 === void 0 ? void 0 : _a2.FRONTSPEC) ? document.env.FRONTSPEC : {}, frontspec);
  }
  /**
   * @name        get
   * @type        Function
   *
   * Access a frontspec value by passing a dotpath like "partytown.enabled", or by accessing the full frontspec object by using `.get()` call.
   *
   * @param       {String}        [dotpah="."]            The dotpath of the frontspec value you want to access
   * @return      {Any}                                   The getted frontspec value
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get(dotpath = ".") {
    return get(this._frontspec, dotpath);
  }
}
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i = links.length - 1; i >= 0; i--) {
        const link2 = links[i];
        if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule()).catch((err) => {
    const e = new Event("vite:preloadError", { cancelable: true });
    e.payload = err;
    window.dispatchEvent(e);
    if (!e.defaultPrevented) {
      throw err;
    }
  });
};
class SStdioSettingsInterface extends SInterface {
  static get _definition() {
    return {
      filter: {
        description: "Specify a function that will be used to filter the logs. It will take the log object as parameter and MUST return a boolean.",
        type: "Function"
      },
      processor: {
        description: "Specify a function that will be used to process the logs. It will take the log object and MUST return it, updated or not...",
        type: "Function"
      },
      defaultLogObj: {
        description: "Specify a default log object that will be used as base for each received logs",
        type: "Object",
        default: {}
      },
      defaultAskObj: {
        description: "Specify a default ask object that will be used as base for each received questions (ask)",
        type: "Object",
        default: {}
      }
    };
  }
}
var __awaiter$n = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SStdio extends SClass {
  /**
   * @name            existingOrNew
   * @type            Function
   * @async
   *
   * This static method allows you to get back either an existing stdio instance or a new one
   *
   * @param       {String}      id        The id of the instance you want to get back
   * @param         {SProcess}          proc        The process to display Stdio for
   * @param         {Object}            [settings={}]     An object of blessed settings that will be passed to the main blessed.box instance
   * @return      {SStdio}            The existing or new stdio instance
   *
   * @todo      interface
   * @todo      doc
   * @todo      tests
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static existingOrNew(id2, sources, adapters, settings = {}) {
    if (this._instanciatedStdio[id2])
      return this._instanciatedStdio[id2];
    return this.new(id2, sources, adapters, settings);
  }
  /**
   * @name            new
   * @type            Function
   * @async
   *
   * This static method is a sugar to instanciate an stdio by specifying some sources,
   * and either a path to a SStdio class, an SStdio class directly or a pre-registered
   * stdio id like:
   * - inherit: If is in node context, will fallback to STerminalStdio, if in browser, in SConsoleStdio
   * -
   * - terminal: STerminalStdio (node only)
   * - console: SConsoleStdio (browser only)
   *
   * @param     {String}          id          A unique id for your stdio instance
   * @param         {SProcess}          proc        The process to display Stdio for
   * @param         {Object}            [settings={}]     An object of blessed settings that will be passed to the main blessed.box instance
   * @return        {SStdio}                      The newly created stdio instance
   *
   * @todo      interface
   * @todo      doc
   * @todo      tests
   *
   * @example       js
   * import SStdio from '@coffeekraken/s-stdio';
   * import { __spawn } from '@coffeekraken/sugar/process';
   * const proc = __spawn('ls -la');
   * SStdio.new('default', proc);
   *
   * @since     2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static new(id2, sources, adapters, settings = {}) {
    return new Promise((resolve2) => __awaiter$n(this, void 0, void 0, function* () {
      const __new = (yield __vitePreload(() => import("./new-15f9a073.js"), true ? [] : void 0)).default;
      return __new(id2, sources, adapters, settings);
    }));
  }
  get id() {
    return this._id;
  }
  /**
   * @name      constructor
   * @type      Function
   * @constructor
   *
   * Constructor
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  constructor(id2, sources, adapters, settings) {
    super(__deepMerge(
      // @ts-ignore
      SStdioSettingsInterface.defaults(),
      settings !== null && settings !== void 0 ? settings : {}
    ));
    this._logsBuffer = [];
    this._isDisplayed = false;
    this._id = "";
    this._isClearing = false;
    this._id = id2;
    this.adapters = Array.isArray(adapters) ? adapters : [adapters];
    this.sources = Array.isArray(sources) ? sources : [sources];
    if (this.constructor._instanciatedStdio[this.id]) {
      throw new Error(`<red>${this.constructor.name}</red> Sorry but a instance of the SStdio class already exists with the id "<yellow>${this.id}</yellow>"`);
    }
    this.constructor._instanciatedStdio[this.id] = this;
    this.sources.forEach((s) => {
      this.registerSource(s);
    });
  }
  /**
   * @name          _logBuffer
   * @type          Function
   * @private
   *
   * This method simply take the buffered logs and log them in the feed
   *
   * @since         2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  _logBuffer() {
    this._logsBuffer = this._logsBuffer.filter((log) => {
      this.log(log);
      return false;
    });
  }
  /**
   * @name          display
   * @type          Function
   *
   * This method tells the stdio instance that it has been showned.
   *
   * @since     2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  display() {
    this._isDisplayed = true;
    this._logBuffer();
  }
  /**
   * @name          hide
   * @type          Function
   *
   * This method tells the stdio instance that it has been hided
   *
   * @since         2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  hide() {
    this._isDisplayed = false;
  }
  /**
   * @name          registerSource
   * @type          Function
   *
   * This method simply listen to the process and log the values getted
   * from it into the panel
   *
   * @param     {SPromise}      source        The source to register
   * @param     {ISBlessedStdioSettings}     [settings={}]
   *
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  registerSource(source2) {
    source2.on("log", this.log.bind(this));
    source2.on("ask", this.ask.bind(this));
    source2.on("ready", () => {
      this.display();
    });
  }
  /**
   * Apply a callback function on each adapters
   */
  _applyOnAdapters(callback) {
    this.adapters.forEach((adapter) => {
      callback(adapter);
    });
  }
  log(...logObj) {
    for (let i = 0; i < logObj.length; i++) {
      let log = logObj[i];
      if (!(log === null || log === void 0 ? void 0 : log.active))
        continue;
      if (!this.isDisplayed() || this._isClearing) {
        this._logsBuffer.push(log);
        continue;
      }
      if (this._lastLogObj && this._lastLogObj.temp) {
        if (!this.clearLast || typeof this.clearLast !== "function")
          throw new Error(`You try to clear the last log but it does not implements the "<cyan>clearLast</cyan>" method`);
        (() => __awaiter$n(this, void 0, void 0, function* () {
          if (!this.clearLast)
            return;
          this._applyOnAdapters((adapter) => {
            var _a2;
            (_a2 = adapter.clearLast) === null || _a2 === void 0 ? void 0 : _a2.call(adapter);
          });
          this._logBuffer();
        }))();
      }
      if (log.clear === true) {
        this._isClearing = true;
        if (!this.clear || typeof this.clear !== "function")
          throw new Error(`You try to clear the "<yellow>${this.constructor.name}</yellow>" stdio but it does not implements the "<cyan>clear</cyan>" method`);
        (() => __awaiter$n(this, void 0, void 0, function* () {
          this._applyOnAdapters((adapter) => {
            var _a2;
            (_a2 = adapter.clear) === null || _a2 === void 0 ? void 0 : _a2.call(adapter);
          });
          this._isClearing = false;
          this._logBuffer();
        }))();
      }
      if (!log.group) {
        log.group = "Sugar ♥";
      }
      this._applyOnAdapters((adapter) => {
        adapter.log(log);
      });
      this._lastLogObj = log;
    }
  }
  /**
   * @name      ask
   * @type      Function
   * @async
   *
   * This method is the one called to ask something.
   * It will call the ```_ask``` method that each implementation of the
   * SStdio class MUST have
   *
   * @param         {ISLog[]}        ...logObj      The log object(s) you want to log
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  // _isCleared = true;
  ask(askObj) {
    return __awaiter$n(this, void 0, void 0, function* () {
      let ask = __deepMerge(this.settings.defaultAskObj, askObj);
      const answer = yield this.adapters[0].ask(ask);
      return answer;
    });
  }
  /**
   * @name        isDisplayed
   * @type        Boolean
   *
   * true if the stdio if actually displayed, false if not
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  isDisplayed() {
    return this._isDisplayed;
  }
}
SStdio._instanciatedStdio = {};
class SStdioAdapter extends SClass {
  constructor(settings) {
    super(settings);
  }
}
var __awaiter$m = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _a$6;
const _nativeConsole = {};
for (let key of ["log", "error", "warn", "verbose"]) {
  _nativeConsole[key] = (_a$6 = console[key]) !== null && _a$6 !== void 0 ? _a$6 : console.log;
}
class SStdioBasicAdapter extends SStdioAdapter {
  /**
   * @name            constructor
   * @type            Function
   * @constructor
   *
   * Constructor
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  constructor(settings) {
    super(__deepMerge({}, settings || {}));
    this._lastLogLinesCountStack = [];
    this._loggedGroups = {};
    this._logsStack = [];
  }
  clear() {
    console.clear();
  }
  _getGroupObj(group, log = true) {
    var _a2;
    let groupObj = this._loggedGroups[group];
    if (!groupObj || ((_a2 = this._lastLogObj) === null || _a2 === void 0 ? void 0 : _a2.group) !== group) {
      groupObj = {
        color: getColorFor(group)
      };
      groupObj.prefix = __parseHtml(`<${groupObj.color}>█</${groupObj.color}>`);
      this._loggedGroups[group] = groupObj;
    }
    return groupObj;
  }
  log(logObj) {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h, _j;
    const logger = (_a2 = logObj === null || logObj === void 0 ? void 0 : logObj.logger) !== null && _a2 !== void 0 ? _a2 : _nativeConsole.log;
    if (logObj.value instanceof HTMLElement) {
      return logger(logObj.value);
    }
    if (!logObj) {
      return logger(logObj);
    }
    const groupObj = this._getGroupObj(logObj.group);
    if (logObj.group !== ((_b2 = this._lastLogObj) === null || _b2 === void 0 ? void 0 : _b2.group)) {
      logger(groupObj.prefix);
      logger(__parseHtml(`<bg${__upperFirst(groupObj.color)}><black> ${logObj.group} </black></bg${__upperFirst(groupObj.color)}><${groupObj.color}>${"-".repeat(50)}</${groupObj.color}>`));
      logger(groupObj.prefix);
    }
    if (logObj.clear && ((_c2 = this._lastLogObj) === null || _c2 === void 0 ? void 0 : _c2.type) !== SLog.TYPE_WARN && ((_d2 = this._lastLogObj) === null || _d2 === void 0 ? void 0 : _d2.type) !== SLog.TYPE_ERROR) {
      console.clear();
    }
    let logLinesCount = 0;
    if ((_e2 = logObj.margin) === null || _e2 === void 0 ? void 0 : _e2.top) {
      for (let i = 0; i < logObj.margin.top; i++) {
        logger(__parseHtml(`<${groupObj.color}>█</${groupObj.color}>`));
      }
      logLinesCount += logObj.margin.top;
    }
    let logValue = (_h = (_g2 = (_f2 = logObj.value) === null || _f2 === void 0 ? void 0 : _f2.value) !== null && _g2 !== void 0 ? _g2 : logObj.value) !== null && _h !== void 0 ? _h : logObj;
    let log = logValue;
    if (typeof logValue === "string") {
      log = __parseHtml(`<${groupObj.color}>█</${groupObj.color}> ${logValue}`);
    }
    logLinesCount += 1;
    logger(log);
    if ((_j = logObj.margin) === null || _j === void 0 ? void 0 : _j.bottom) {
      for (let i = 0; i < logObj.margin.bottom; i++) {
        logger(__parseHtml(`<${groupObj.color}>█</${groupObj.color}>`));
      }
      logLinesCount += logObj.margin.top;
    }
    this._lastLogLinesCountStack.push(logLinesCount);
    this._lastLogObj = logObj;
  }
  /**
   * @name          _ask
   * @type          Function
   * @private
   *
   * Method that actually log the passed log object with the passed component
   *
   * @param         {ILogAsk}        askObj            The ask object to ask to the user
   * @param         {ISStdioComponent}      component       The component to use for logging
   *
   * @since         2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  _ask(askObj) {
    return new SPromise(({ resolve: resolve2, reject, emit }) => __awaiter$m(this, void 0, void 0, function* () {
      throw new Error(`<red>[SStdioBasicAdapter]</red> The "ask" feature has not been implemented yet in the browser environment...`);
    }));
  }
}
var __awaiter$l = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SStdioSource extends SClass {
  constructor(settings) {
    super(settings);
    this._callbacks = {};
  }
  log(logObj) {
    var _a2;
    (_a2 = this._callbacks.log) === null || _a2 === void 0 ? void 0 : _a2.forEach((callback) => {
      callback(logObj);
    });
  }
  ask(askObj) {
    return new Promise((resolve2, reject) => __awaiter$l(this, void 0, void 0, function* () {
      let answer;
      for (let [key, fn2] of this._callbacks.ask.entries()) {
        answer = yield fn2(askObj);
      }
      resolve2(answer);
    }));
  }
  ready() {
    var _a2;
    (_a2 = this._callbacks.ready) === null || _a2 === void 0 ? void 0 : _a2.forEach((callback) => {
      callback();
    });
  }
  on(event, callback) {
    if (!this._callbacks[event]) {
      this._callbacks[event] = [];
    }
    if (this._callbacks[event].includes(callback)) {
      return;
    }
    this._callbacks[event].push(callback);
  }
  off(event, callback) {
    if (!this._callbacks[event]) {
      return;
    }
    if (!this._callbacks[event].includes(callback)) {
      return;
    }
    this._callbacks[event].splice(this._callbacks[event].indexOf(callback, 1));
  }
}
var __awaiter$k = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const _console$1 = {};
for (let key of ["log", "error", "warn", "success", "verbose", "notify"]) {
  _console$1[key] = console[key];
}
try {
  global._console = _console$1;
} catch (e) {
}
class SStdioConsoleSource extends SStdioSource {
  constructor(settings) {
    super(settings);
    this._tmpPrintedLogs = [];
    this._overrideNativeConsole();
    console.ask = (askObj) => __awaiter$k(this, void 0, void 0, function* () {
      this._restoreNativeConsole();
      yield __wait(100);
      const res = yield this.ask(askObj);
      this._overrideNativeConsole();
      return res;
    });
    setTimeout(() => {
      this.ready();
    });
  }
  /**
   * Restore native console (for ask, etc...)
   */
  _restoreNativeConsole() {
    for (let key of [
      "log",
      "error",
      "warn",
      "success",
      "verbose",
      "notify"
    ]) {
      console[key] = _console$1[key];
    }
  }
  /**
   * Override native console
   */
  _overrideNativeConsole() {
    var _a2;
    for (let key of [
      "log",
      "error",
      "warn",
      "success",
      "verbose",
      "notify"
    ]) {
      _console$1[key] = (_a2 = console[key]) !== null && _a2 !== void 0 ? _a2 : _console$1.log;
      console[key] = (...args) => {
        var _a3, _b2;
        args = args.filter((log) => {
          var _a4;
          if (log === null || log === void 0) {
            _console$1.log(log);
            return false;
          }
          if ((_a4 = log === null || log === void 0 ? void 0 : log.toString) === null || _a4 === void 0 ? void 0 : _a4.call(log).match(/[a-zA-Z0-9]Error\:/)) {
            _console$1.error(log);
            return false;
          }
          return true;
        });
        const e = new Error();
        const stack = e.stack.toString().split("\n").slice(2).map((str2) => {
          var _a4;
          return (_a4 = str2.trim) === null || _a4 === void 0 ? void 0 : _a4.call(str2);
        });
        const callerStr = (_a3 = stack[0]) !== null && _a3 !== void 0 ? _a3 : "";
        let group = callerStr.split(" ")[callerStr.match(/^at new/) ? 2 : 1].split(".")[0];
        if (group === "Timeout") {
          group = stack[1].split(" ")[callerStr.match(/^at new/) ? 2 : 1].split(".")[0];
        }
        if (group.match(`^file:///`)) {
          group = (_b2 = group.trim) === null || _b2 === void 0 ? void 0 : _b2.call(group).split("/").pop();
        }
        args = args.map((log) => {
          var _a4, _b3, _c2, _d2;
          return new SLog({
            type: (_b3 = (_a4 = log === null || log === void 0 ? void 0 : log.type) !== null && _a4 !== void 0 ? _a4 : key) !== null && _b3 !== void 0 ? _b3 : SLog.TYPE_LOG,
            value: log,
            group: (_c2 = log === null || log === void 0 ? void 0 : log.group) !== null && _c2 !== void 0 ? _c2 : group,
            notify: key === "notify" || (log === null || log === void 0 ? void 0 : log.notify),
            verbose: key === "verbose" || (log === null || log === void 0 ? void 0 : log.verbose),
            metas: (_d2 = log === null || log === void 0 ? void 0 : log.metas) !== null && _d2 !== void 0 ? _d2 : {},
            // @ts-ignore
            logger: _console$1[key]
          });
        });
        args.forEach((log) => {
          this.log(log);
        });
      };
    }
  }
}
function loopsCount(timeframe = 100) {
  let sysm = 0, start = (/* @__PURE__ */ new Date()).getTime(), end = start;
  while (end - start === 0) {
    end = (/* @__PURE__ */ new Date()).getTime();
  }
  start = end;
  while (end - start < timeframe) {
    sysm++;
    end = (/* @__PURE__ */ new Date()).getTime();
  }
  return sysm;
}
function speedIndex(slow = 1e5, fast = 15e5) {
  const loopsCount$1 = loopsCount(100), index = 100 / (fast - slow) * loopsCount$1;
  return Math.round(index);
}
function __parseHsla(hslaString) {
  hslaString = hslaString.toLowerCase();
  const string = hslaString.replace("hsla(", "").replace("hsl(", "").replace(")", "").replace(/\s/g, "");
  const array = string.split(",");
  return {
    h: parseFloat(array[0]),
    s: parseFloat(array[1]),
    l: parseFloat(array[2]),
    a: array[3] ? parseFloat(array[3]) : 1
  };
}
function HSLAToRGBA(h, s, l, a) {
  s /= 100;
  l /= 100;
  let c = (1 - Math.abs(2 * l - 1)) * s, x = c * (1 - Math.abs(h / 60 % 2 - 1)), m = l - c / 2, r = 0, g2 = 0, b = 0;
  if (0 <= h && h < 60) {
    r = c;
    g2 = x;
    b = 0;
  } else if (60 <= h && h < 120) {
    r = x;
    g2 = c;
    b = 0;
  } else if (120 <= h && h < 180) {
    r = 0;
    g2 = c;
    b = x;
  } else if (180 <= h && h < 240) {
    r = 0;
    g2 = x;
    b = c;
  } else if (240 <= h && h < 300) {
    r = x;
    g2 = 0;
    b = c;
  } else if (300 <= h && h < 360) {
    r = c;
    g2 = 0;
    b = x;
  }
  r = Math.round((r + m) * 255);
  g2 = Math.round((g2 + m) * 255);
  b = Math.round((b + m) * 255);
  return {
    r,
    g: g2,
    b,
    a
  };
}
function __hslaToRgba(h, s, l, a = 1) {
  if (typeof h === "string") {
    if (!h.match(/^hsla?\(/)) {
      throw new Error("<red>[hslaToRgba]</red> When passing a string to the first parameter, it MUST be formatted like: hsla?(.*)");
    }
    h = __parseHsla(h);
  }
  if (typeof h === "object") {
    h = h.h;
    s = h.s;
    l = h.l;
    a = h.a;
  }
  return HSLAToRGBA(h, s, l, a);
}
function hexToRGBA(h) {
  let r = 0, g2 = 0, b = 0;
  if (h.length == 4) {
    r = "0x" + h[1] + h[1];
    g2 = "0x" + h[2] + h[2];
    b = "0x" + h[3] + h[3];
  } else if (h.length == 7) {
    r = "0x" + h[1] + h[2];
    g2 = "0x" + h[3] + h[4];
    b = "0x" + h[5] + h[6];
  }
  return { r, g: g2, b, a: 1 };
}
function __hexToRgba(hex) {
  return hexToRGBA(hex);
}
function __parseRgba(rgbaString) {
  rgbaString = rgbaString.toLowerCase();
  const string = rgbaString.replace("rgba(", "").replace("rgb(", "").replace(")", "").replace(/\s/g, "");
  const array = string.split(",");
  return {
    r: parseInt(array[0]),
    g: parseInt(array[1]),
    b: parseInt(array[2]),
    a: array[3] ? parseInt(array[3]) : 1
  };
}
function RGBAToHSLA(r, g2, b, a) {
  r /= 255;
  g2 /= 255;
  b /= 255;
  let cmin = Math.min(r, g2, b), cmax = Math.max(r, g2, b), delta = cmax - cmin, h = 0, s = 0, l = 0;
  if (delta == 0)
    h = 0;
  else if (cmax == r)
    h = (g2 - b) / delta % 6;
  else if (cmax == g2)
    h = (b - r) / delta + 2;
  else
    h = (r - g2) / delta + 4;
  h = Math.round(h * 60);
  if (h < 0)
    h += 360;
  l = (cmax + cmin) / 2;
  s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
  s = +(s * 100).toFixed(1);
  l = +(l * 100).toFixed(1);
  return { h, s, l, a };
}
function __rgbaToHsla(r, g2, b, a = 1) {
  if (typeof r === "string") {
    if (!r.match(/^rgba?\(/)) {
      throw new Error("<red>[rgbaToHsla]</red> When passing a string to the first parameter, it MUST be formatted like: rgba?(.*)");
    }
    r = __parseRgba(r);
  }
  if (typeof r === "object") {
    g2 = r.g;
    b = r.b;
    a = r.a;
    r = r.r;
  }
  return RGBAToHSLA(r, g2, b, a);
}
function __parseColor(color, format2 = "rgba") {
  color = color.replace(/\s/g, "");
  if (color.startsWith("rgb")) {
    color = __parseRgba(color);
  } else if (color.startsWith("hsl")) {
    color = __parseHsla(color);
    color = __hslaToRgba(color.h, color.s, color.l);
  } else if (color.startsWith("#")) {
    color = __hexToRgba(color);
  }
  switch (format2) {
    case "hsla":
    case "hsl":
      return __rgbaToHsla(color);
    case "rgba":
    case "rgb":
    default:
      return color;
  }
}
function RGBToHex(r, g2, b) {
  r = r.toString(16);
  g2 = g2.toString(16);
  b = b.toString(16);
  if (r.length == 1)
    r = "0" + r;
  if (g2.length == 1)
    g2 = "0" + g2;
  if (b.length == 1)
    b = "0" + b;
  return "#" + r + g2 + b;
}
function __rgbaToHex(r, g2, b, a = 1) {
  if (typeof r === "string") {
    if (!r.match(/^rgba?\(/)) {
      throw new Error("<red>[rgbaToHex]</red> When passing a string to the first parameter, it MUST be formatted like: rgba?(.*)");
    }
    r = __parseRgba(r);
  }
  if (typeof r === "object") {
    r = r.r;
    g2 = r.g;
    b = r.b;
  }
  return RGBToHex(r, g2, b);
}
function __convert(input, format2 = "rgba") {
  let rgbaObj = {};
  if (typeof input === "string") {
    rgbaObj = __parseColor(input, "rgba");
  } else if (typeof input === "object") {
    if (input.r !== void 0 && input.g !== void 0 && input.b !== void 0) {
      rgbaObj = input;
    } else if (input.h !== void 0 && input.s !== void 0 && input.l !== void 0) {
      rgbaObj = __hslaToRgba(input);
    }
  }
  switch (format2) {
    case "rgba":
      return rgbaObj;
    case "hsl":
    case "hsla":
      return __rgbaToHsla(rgbaObj);
    case "hex":
    case "hexString":
      return __rgbaToHex(rgbaObj);
    case "rgbString":
      return `rgb(${rgbaObj.r},${rgbaObj.g},${rgbaObj.b})`;
    case "rgbaString":
      return `rgba(${rgbaObj.r},${rgbaObj.g},${rgbaObj.b},${rgbaObj.a})`;
    case "hslString":
      const hslObj = convert(rgbaObj, "hsl");
      return `hsl(${hslObj.h},${hslObj.s},${hslObj.l})`;
    case "hslaString":
      const hslaObj = convert(rgbaObj, "hsla");
      return `hsla(${hslaObj.h},${hslaObj.s},${hslaObj.l},${hslaObj.a})`;
  }
  return void 0;
}
function HSLToHex(h, s, l) {
  s /= 100;
  l /= 100;
  let c = (1 - Math.abs(2 * l - 1)) * s, x = c * (1 - Math.abs(h / 60 % 2 - 1)), m = l - c / 2, r = 0, g2 = 0, b = 0;
  if (0 <= h && h < 60) {
    r = c;
    g2 = x;
    b = 0;
  } else if (60 <= h && h < 120) {
    r = x;
    g2 = c;
    b = 0;
  } else if (120 <= h && h < 180) {
    r = 0;
    g2 = c;
    b = x;
  } else if (180 <= h && h < 240) {
    r = 0;
    g2 = x;
    b = c;
  } else if (240 <= h && h < 300) {
    r = x;
    g2 = 0;
    b = c;
  } else if (300 <= h && h < 360) {
    r = c;
    g2 = 0;
    b = x;
  }
  r = Math.round((r + m) * 255).toString(16);
  g2 = Math.round((g2 + m) * 255).toString(16);
  b = Math.round((b + m) * 255).toString(16);
  if (r.length == 1)
    r = "0" + r;
  if (g2.length == 1)
    g2 = "0" + g2;
  if (b.length == 1)
    b = "0" + b;
  return "#" + r + g2 + b;
}
function __hslaToHex(h, s, l, a = 1) {
  if (typeof h === "string") {
    if (!h.match(/^hsla?\(/)) {
      throw new Error("<red>[hslaToRgba]</red> When passing a string to the first parameter, it MUST be formatted like: hsla?(.*)");
    }
    h = __parseHsla(h);
  }
  if (typeof h === "object") {
    h = h.h;
    s = h.s;
    l = h.l;
    a = h.a;
  }
  return HSLToHex(h, s, l);
}
function HSLAToHexA(h, s, l, a) {
  s /= 100;
  l /= 100;
  let c = (1 - Math.abs(2 * l - 1)) * s, x = c * (1 - Math.abs(h / 60 % 2 - 1)), m = l - c / 2, r = 0, g2 = 0, b = 0;
  if (0 <= h && h < 60) {
    r = c;
    g2 = x;
    b = 0;
  } else if (60 <= h && h < 120) {
    r = x;
    g2 = c;
    b = 0;
  } else if (120 <= h && h < 180) {
    r = 0;
    g2 = c;
    b = x;
  } else if (180 <= h && h < 240) {
    r = 0;
    g2 = x;
    b = c;
  } else if (240 <= h && h < 300) {
    r = x;
    g2 = 0;
    b = c;
  } else if (300 <= h && h < 360) {
    r = c;
    g2 = 0;
    b = x;
  }
  r = Math.round((r + m) * 255).toString(16);
  g2 = Math.round((g2 + m) * 255).toString(16);
  b = Math.round((b + m) * 255).toString(16);
  a = Math.round(a * 255).toString(16);
  if (r.length == 1)
    r = "0" + r;
  if (g2.length == 1)
    g2 = "0" + g2;
  if (b.length == 1)
    b = "0" + b;
  if (a.length == 1)
    a = "0" + a;
  return "#" + r + g2 + b + a;
}
function __hslaToHexa(h, s, l, a = 1) {
  if (typeof h === "string") {
    if (!h.match(/^hsla?\(/)) {
      throw new Error("<red>[hslaToRgba]</red> When passing a string to the first parameter, it MUST be formatted like: hsla?(.*)");
    }
    h = __parseHsla(h);
  }
  if (typeof h === "object") {
    h = h.h;
    s = h.s;
    l = h.l;
    a = h.a;
  }
  return HSLAToHexA(h, s, l, a);
}
class SColorApplyParamsInterface extends SInterface {
  static get _definition() {
    return {
      desaturate: {
        type: "Number",
        default: 0,
        alias: "d",
        description: "Allows you to desaturate the color using a percentage"
      },
      saturate: {
        type: "Number",
        default: 0,
        alias: "s",
        description: "Allows you to saturate the color using a percentage"
      },
      greyscale: {
        type: "Boolean",
        default: false,
        alias: "g",
        description: "Allows you to get back the grayscale version of your color"
      },
      spin: {
        type: "Number",
        default: 0,
        description: "Spin the hue on the passed value (max 360)"
      },
      transparentize: {
        type: "Number",
        default: 0,
        description: "The amount of transparency to apply between 0-100|0-1"
      },
      alpha: {
        type: "Number",
        default: 0,
        alias: "a",
        description: "The new alpha value to apply between 0-100|0-1"
      },
      opacity: {
        type: "Number",
        default: 0,
        alias: "o",
        description: "The new alpha value to apply between 0-100|0-1"
      },
      opacify: {
        type: "Number",
        default: 0,
        description: "The amount of transparence to remove between 0-100|0-1"
      },
      darken: {
        type: "Number",
        default: 0,
        description: "The amount of darkness (of the nightmare of the shadow) to apply between 0-100"
      },
      lighten: {
        type: "Number",
        default: 0,
        alias: "l",
        description: "The amount of lightness (of the sky of the angels) to apply between 0-100"
      },
      invert: {
        type: "Boolean",
        default: false,
        alias: "i",
        description: "Specify if you want to invert the color to keep a good contrast ratio with a background for example"
      }
    };
  }
}
class SColorSettingsInterface extends SInterface {
  static get _definition() {
    return {
      format: {
        description: "Specify the default format of the color",
        type: "String",
        values: ["hex", "hexa", "rgb", "rgba", "hsl", "hsla"],
        default: "hex"
      }
    };
  }
}
class Contrast {
  constructor(foreground, background) {
    this.foreground = new HexColor(foreground);
    this.background = new HexColor(background);
    this.value = (() => {
      const foreground2 = this.foreground.toEightBitColor().luminosity();
      const background2 = this.background.toEightBitColor().luminosity();
      const L1 = Math.max(foreground2, background2);
      const L2 = Math.min(foreground2, background2);
      const OFFSET = 0.05;
      return (L1 + OFFSET) / (L2 + OFFSET);
    })();
  }
  /** Returns the luminosity contrast ratio. */
  valueOf() {
    return this.value;
  }
}
class EightBit {
  constructor(value) {
    this.value = Number(value);
  }
  /** Returns the current value, e.g. 255. */
  valueOf() {
    return this.value;
  }
  /** Convert from sRGB to linear RGB. */
  linearize() {
    const SCALE = 255;
    const value = this.value / SCALE;
    return value <= 0.03928 ? value / 12.92 : Math.pow((value + 0.055) / 1.055, 2.4);
  }
  /** Returns a Hex with the current value, e.g. Hex("#FF"). */
  toHex() {
    const value = this.value.toString(16).toUpperCase();
    return new Hex(`#${value}`);
  }
}
class EightBitColor {
  constructor(R2, G, B) {
    this.R = new EightBit(R2);
    this.G = new EightBit(G);
    this.B = new EightBit(B);
  }
  /** Returns the current red, green and blue values, e.g. { R: 255, G: 255, B: 255 }. */
  valueOf() {
    const R2 = this.R.valueOf();
    const G = this.G.valueOf();
    const B = this.B.valueOf();
    return { R: R2, G, B };
  }
  /** Returns the luminosity. */
  luminosity() {
    const R_COEFFICIENT = 0.2126;
    const G_COEFFICIENT = 0.7152;
    const B_COEFFICIENT = 0.0722;
    const R2 = this.R.linearize();
    const G = this.G.linearize();
    const B = this.B.linearize();
    return R_COEFFICIENT * R2 + G_COEFFICIENT * G + B_COEFFICIENT * B;
  }
  /** Returns a HexColor with the current value, e.g. Hex("#FFFFFF"). */
  toHexColor() {
    const R2 = this.R.toHex().valueOf();
    const G = this.G.toHex().valueOf();
    const B = this.B.toHex().valueOf();
    return new HexColor(`#${R2}${G}${B}`);
  }
}
function padStart(string, targetLength, padString) {
  if (string.toString().length >= targetLength) {
    return string;
  }
  return padStart(padString.concat(string), targetLength, padString);
}
class Hex {
  constructor(value) {
    this.value = value ? padStart(String(value).replace("#", "").toUpperCase(), 2, "0") : null;
  }
  /** Returns the current value, e.g. "FF". */
  valueOf() {
    return this.value;
  }
  /** Returns an EightBit with the current value, e.g. EightBit(255). */
  toEightBit() {
    const value = typeof this.value === "string" ? parseInt(this.value, 16) : null;
    return new EightBit(value);
  }
}
class HexColor {
  constructor(value) {
    this.value = (() => {
      if (!value) {
        return null;
      }
      const _value = (() => {
        switch (true) {
          case String(value).toLowerCase() === "black":
            return "000000";
          case String(value).toLowerCase() === "white":
            return "FFFFFF";
          default:
            return String(value).replace("#", "");
        }
      })();
      switch (_value.length) {
        case 2:
          return `${_value}${_value}${_value}`;
        case 3:
          return `${_value[0]}${_value[0]}${_value[1]}${_value[1]}${_value[2]}${_value[2]}`;
        default:
          return _value;
      }
    })();
    this.R = this.value ? new Hex(this.value.substr(0, 2)) : null;
    this.G = this.value ? new Hex(this.value.substr(2, 2)) : null;
    this.B = this.value ? new Hex(this.value.substr(4, 2)) : null;
  }
  /** Returns the current value, e.g. "FF". */
  valueOf() {
    return this.value;
  }
  /** Returns an EightBit with the current value, e.g. { R: 255, G: 255, B: 255 }. */
  toEightBitColor() {
    const R2 = this.R ? this.R.toEightBit().valueOf() : null;
    const G = this.G ? this.G.toEightBit().valueOf() : null;
    const B = this.B ? this.B.toEightBit().valueOf() : null;
    return new EightBitColor(R2, G, B);
  }
}
class SColor extends SClass {
  /**
   * @name            getContrastInfo
   * @type            Function
   * @static
   *
   * This static function allows you to get the contact informations regarding two colors.
   * You will get back an object containing informations about the color1, color2 and a "value"
   * that represent the contrast between your colors between 0 and 21.
   *
   * @param           {String|SColor}             color1          The color 1 to check
   * @param           {String|SColor}             color2          The color 2 to check
   * @return          {ISColorContrastInfo}                       The contrast informations
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static getContrastInfo(color1, color2) {
    let color1Instance, color2Instance;
    if (typeof color1 === "string") {
      color1Instance = new SColor(color1);
    }
    if (typeof color2 === "string") {
      color2Instance = new SColor(color2);
    }
    const contrast = new Contrast(color1Instance.toHexaString(), color2Instance.toHexaString());
    const finalContrastInfo = {
      background: Object.assign({}, color2Instance.toObject()),
      foreground: Object.assign({}, color1Instance.toObject()),
      value: contrast.value
    };
    return finalContrastInfo;
  }
  /**
   * @name                  constructor
   * @type                  Function
   *
   * Constructor
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  constructor(color, settings) {
    var _c2, _d2;
    super(__deepMerge(
      // @ts-ignore
      SColorSettingsInterface.defaults(),
      settings !== null && settings !== void 0 ? settings : {}
    ));
    this._originalSColor = null;
    this._h = 0;
    this._s = 0;
    this._l = 0;
    this._r = 0;
    this._g = 0;
    this._b = 0;
    this._a = 1;
    this._format = "hexa";
    color = this.getColor(color);
    this._originalSColor = color;
    if (typeof color === "string") {
      try {
        this._parse(color);
      } catch (e) {
      }
    } else {
      if (color.h !== void 0 && color.s !== void 0 && color.l !== void 0) {
        this._h = color.h;
        this._s = color.s;
        this._l = color.l;
        this._a = (_c2 = color.a) !== null && _c2 !== void 0 ? _c2 : 1;
      } else if (color.r !== void 0 && color.g !== void 0 && color.b !== void 0) {
        const converted = __rgbaToHsla(color.r, color.g, color.b, (_d2 = color.a) !== null && _d2 !== void 0 ? _d2 : 1);
        this._h = converted.h;
        this._s = converted.s;
        this._l = converted.l;
        this._a = converted.a;
      } else {
        console.error(color);
        throw new Error("Sorry but this passed value is not a valid color object or string...");
      }
    }
  }
  /**
   * @name            getColor
   * @type            Function
   *
   * This method take as parameter the passed color to the constructor and has to return the
   * actual real color like color from the static colors listed in the SColor class or maybe
   * from the Sugar configured colors
   */
  getColor(color) {
    if (typeof color == "string" && SColor.colors[color.toLowerCase()]) {
      return SColor.colors[color.toLowerCase()];
    }
    return color;
  }
  /**
   * @name            _parse
   * @type            Function
   * @private
   *
   * Parse
   *
   * @param       {object}      color       The color to parse like (#ff0000 | rgba(...) | hsl(...) | {r:255,r:140,b:23,a:40})
   * @return      {object}                  The rgba representation of the passed color
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  _parse(color) {
    color = color.replace(/\%/gm, "");
    color = __convert(color, "hsla");
    this.h = color.h;
    this.s = color.s;
    this.l = color.l;
    this.a = color.a;
    return color;
  }
  /**
   * @name              convert2
   * @type              Function
   * @private
   *
   * Concert color
   *
   * @param       	{string}      	format 	      	The format wanted as output like (rgba,hsla and hex)
   * @values        rgba, hsla, hex
   * @return      	{object} 	                			The color in wanted object format
   *
   * @example           js
   * myColor._convert2('rgba');
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  _convert2(format2) {
    switch (format2) {
      case "rgba":
      case "rgb":
        return __hslaToRgba(this._h, this._s, this._l, this._a);
      case "hsla":
      case "hsl":
        return {
          h: this._h,
          s: this._s,
          l: this._l,
          a: this._a
        };
      case "hexa":
        return __hslaToHexa(this._h, this._s, this._l, this._a);
      case "hex":
        return __hslaToHex(this._h, this._s, this._l);
    }
  }
  /**
   * @name                toHex
   * @type                Function
   *
   * To hex
   *
   * @return 	{string} 		The hex string representation
   *
   * @example           js
   * myColor.toHex();
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  toHex() {
    return this._convert2("hex");
  }
  /**
   * @name                toHexa
   * @type                Function
   *
   * To hex
   *
   * @return 	{string} 		The hex string representation
   *
   * @example           js
   * myColor.toHexa();
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  toHexa() {
    return this._convert2("hexa");
  }
  /**
   * @name            toHsl
   * @type            Function
   *
   * To hsl
   *
   * @return 	{object} 		The hsl object representation
   *
   * @example       js
   * myColor.toHsl();
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  toHsl() {
    return this._convert2("hsl");
  }
  /**
   * @name            toHsla
   * @type            Function
   *
   * To hsla
   *
   * @return 	{object} 		The hsla object representation
   *
   * @example       js
   * myColor.toHsla();
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  toHsla() {
    return this._convert2("hsla");
  }
  /**
   * @name            toRgb
   * @type            Function
   *
   * To rgb
   *
   * @return 	{object} 		The rgb object representation
   *
   * @example         js
   * myColor.toRgb();
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  toRgb() {
    return this._convert2("rgb");
  }
  /**
   * @name            toRgba
   * @type            Function
   *
   * To rgba
   *
   * @return 	{object} 		The rgba object representation
   *
   * @example         js
   * myColor.toRgba();
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  toRgba() {
    return this._convert2("rgba");
  }
  /**
   * @name            r
   * @type            Number
   *
   * Get/set the red value
   *
   * @example         js
   * myColor.r;
   * myColor.r = 128;
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get r() {
    return this._r;
  }
  set r(value) {
    value = parseInt(value);
    value = value > 255 ? 255 : value < 0 ? 0 : value;
    this._r = value;
    this._applyFromRgbaUpdate();
  }
  /**
   * @name              g
   * @type              Number
   *
   * Get/set the green value
   *
   * @example         js
   * myColor.g;
   * myColor.g = 20;
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get g() {
    return this._g;
  }
  set g(value) {
    value = parseInt(value);
    value = value > 255 ? 255 : value < 0 ? 0 : value;
    this._g = value;
    this._applyFromRgbaUpdate();
  }
  /**
   * @name              b
   * @type              Number
   *
   * Get/set the blue value
   *
   * @example           js
   * myColor.b;
   * myColor.b = 30;
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get b() {
    return this._b;
  }
  set b(value) {
    value = parseInt(value);
    value = value > 255 ? 255 : value < 0 ? 0 : value;
    this._b = value;
    this._applyFromRgbaUpdate();
  }
  /**
   * @name              a
   * @type              Number
   *
   * Get/set the alpha value
   *
   * @example       js
   * myColor.a;
   * myColor.a = 20;
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get a() {
    return this._a;
  }
  set a(value) {
    value = parseFloat(value);
    value = value > 1 ? 1 : value < 0 ? 0 : value;
    this._a = value;
  }
  /**
   * @name              h
   * @type              Number
   *
   * Get/set the hue
   *
   * @example         js
   * myColor.h;
   * myColor.h = 30;
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get h() {
    return this._h;
  }
  set h(value) {
    value = parseInt(value);
    value = value > 360 ? 360 : value < 0 ? 0 : value;
    this._h = value;
    this._applyFromHslaUpdate();
  }
  /**
   * @name              s
   * @type              Number
   *
   * The saturation value
   *
   * @example         js
   * myColor.s;
   * myColor.s = 20;
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get s() {
    return this._s;
  }
  set s(value) {
    value = parseInt(value);
    value = value > 100 ? 100 : value < 0 ? 0 : value;
    this._s = value;
    this._applyFromHslaUpdate();
  }
  /**
   * @name              l
   * @type              Number
   *
   * The luminence value
   *
   * @example             js
   * myColor.l;
   * myColor.l = 10;
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get l() {
    return this._l;
  }
  set l(value) {
    value = parseInt(value);
    value = value > 100 ? 100 : value < 0 ? 0 : value;
    this._l = value;
    this._applyFromHslaUpdate();
  }
  /**
   * @name          clone
   * @type          Function
   *
   * Clone the SColor instance
   *
   * @example         js
   * myColor.clone();
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  clone() {
    const newColor = new SColor({
      h: this._h,
      s: this._s,
      l: this._l,
      a: this._a
    });
    return newColor;
  }
  /**
   * @name          reset
   * @type          Function
   *
   * Reset to the original color
   *
   * @example         js
   * myColor.reset();
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  reset() {
    this._parse(this._originalSColor);
  }
  _applyFromHslaUpdate() {
    const rgba = __hslaToRgba(this._h, this._s, this._l, this._a);
    this._r = rgba.r;
    this._g = rgba.g;
    this._b = rgba.b;
    this._a = rgba.a;
  }
  _applyFromRgbaUpdate() {
    const hsla = __rgbaToHsla(this._r, this._g, this._b, this._a);
    this._h = hsla.h;
    this._s = hsla.s;
    this._l = hsla.l;
    this._a = hsla.a;
  }
  /**
   * @name          apply
   * @type          Function
   *
   * This method allows you to apply some updated to your color
   * using the parameters defined in the SColorApplyInterface like
   * for example "saturate", "desaturate", etc...
   *
   * @param         {String|ISColorApplyParams}          params       The parameters you want to apply
   * @return        {SColor}                    Returns you the same instance to maintain chainability
   *
   * @since         2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  apply(params) {
    const intRes = SColorApplyParamsInterface.apply(params);
    params = intRes;
    let colorInstance = this;
    Object.keys(params).forEach((action) => {
      const value = params[action];
      if (!value)
        return;
      if (!colorInstance[action] || typeof colorInstance[action] !== "function")
        return;
      if (action === "invert") {
        colorInstance.invert();
      } else {
        colorInstance[action](value);
      }
    });
    return colorInstance;
  }
  /**
   * @name                desaturate
   * @type                Function
   *
   * Desaturate
   *
   * @param         	{Number} 	          amount 	        	The amount of desaturation wanted between 0-100
   * @return 	        {SColor} 			                      	A new SColor instance or the actual one
   *
   * @example           js
   * myColor.desaturate(20);
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  desaturate(amount) {
    amount = parseInt(amount);
    this.s -= amount;
    return this;
  }
  /**
   * @name                saturate
   * @type                Function
   *
   * Saturate
   *
   * @param         	{Number}        	amount 	            	The amount of saturation wanted between 0-100
   * @return 	        {SColor} 			                         	A new SColor instance or the actual one
   *
   * @example         js
   * myColor.saturate(20);
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  saturate(amount) {
    amount = parseInt(amount);
    this.s += amount;
    return this;
  }
  /**
   * @name                      grayscale
   * @type                      Function
   *
   * Return a new SColor instance of the color to grayscale
   *
   * @return 	{SColor} 			A new SColor instance or the actual one
   *
   * @example           js
   * myColor.grayscale();
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  grayscale() {
    this.s = 0;
    return this;
  }
  /**
   * @name              spin
   * @type              Function
   *
   * Spin the hue on the passed value (max 360)
   *
   * @param             	{Number}            	amount 		          	The amount of hue spin wanted between 0-360
   * @return 	            {SColor} 				                          	A new SColor instance or the actual one
   *
   * @example           js
   * myColor.spin(230);
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  spin(amount) {
    amount = parseInt(amount);
    const hue = this.h;
    let newHue = hue + amount;
    if (newHue > 360) {
      newHue -= 360;
    }
    this.h = newHue;
    return this;
  }
  /**
   * @name                alpha
   * @type                Function
   *
   * Set the alpha
   *
   * @param           	{Number} 	            alpha 		            	The new alpha value to apply between 0-100|0-1
   * @return          	{SColor} 					                            A new SColor instance or the actual one
   *
   * @example           js
   * myColor.alpha(10);
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  alpha(alpha) {
    alpha = parseFloat(alpha);
    this.a = alpha;
    return this;
  }
  /**
   * @name                  darken
   * @type                  Function
   *
   * Darken
   *
   * @param                 	{Number} 	                amount 	                	The amount of darkness (of the nightmare of the shadow) to apply between 0-100
   * @return                	{SColor} 				                                    A new SColor instance or the actual one
   *
   * @example             js
   * myColor.darken(20);
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  darken(amount) {
    amount = parseInt(amount);
    this.l -= amount;
    if (this.l < 0)
      this.l = 0;
    else if (this.l > 100)
      this.l = 100;
    return this;
  }
  /**
   * @name                      lighten
   * @type                      Function
   *
   * Lighten
   *
   * @param 	              {Number} 	              amount 	                	The amount of lightness (of the sky of the angels) to apply between 0-100
   * @return                	{SColor} 			                                  	A new SColor instance or the actual one
   *
   * @example             js
   * myColor.lighten(20);
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  lighten(amount) {
    amount = parseInt(amount);
    this.l += amount;
    if (this.l < 0)
      this.l = 0;
    else if (this.l > 100)
      this.l = 100;
    return this;
  }
  /**
   * @name                invert
   * @type                Function
   *
   * Calculate the best color value that will have the best contrast ratio
   *
   * @return      {SColor}              The SColor instance that represent this new color
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  invert() {
    let lightness = this.l;
    if (this.l >= 50) {
      lightness -= 50;
    } else {
      lightness += 50;
    }
    this.l = lightness;
    if (this.l < 0)
      this.l = 0;
    else if (this.l > 100)
      this.l = 100;
    return this;
  }
  /**
   * @name                  toObject
   * @type                  Function
   *
   * To simple json object. This object can be injected in the constructor to recover the same color
   *
   * @return 	            {object} 	              	The object representation of the color (r,g,b,a,h,s,l)
   *
   * @example           js
   * myColor.toObject();
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  toObject() {
    return {
      h: this.h,
      l: this.l,
      s: this.s,
      r: this.r,
      g: this.b,
      b: this.b,
      a: this.a,
      hex: this.toHexString(),
      hexa: this.toHexaString(),
      rgb: this.toRgbString(),
      rgba: this.toRgbaString(),
      hsl: this.toHslString(),
      hsla: this.toHslaString()
    };
  }
  /**
   * @name                  toHexString
   * @type                  Function
   *
   * To hex string
   *
   * @return 	            {string} 	              	The hex string representation of the color
   *
   * @example           js
   * myColor.toHexString();
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  toHexString() {
    return this._convert2("hex");
  }
  /**
   * @name                  toHexaString
   * @type                  Function
   *
   * To hex string
   *
   * @return 	            {string} 	              	The hex string representation of the color
   *
   * @example           js
   * myColor.toHexaString();
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  toHexaString() {
    return this._convert2("hexa");
  }
  /**
   * @name                  toRgbString
   * @type                  Function
   *
   * To rgb string
   *
   * @return 	              {string} 	              	The rgb string representation of the color
   *
   * @example           js
   * myColor.toRgbString();
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  toRgbString() {
    return `rgb(${this._r},${this._g},${this._b})`;
  }
  /**
   * @name                  toRgbaString
   * @type                  Function
   *
   * To rgba string
   *
   * @return 	              {string} 	              	The rgba string representation of the color
   *
   * @example           js
   * myColor.toRgbaString();
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  toRgbaString() {
    return `rgba(${this._r},${this._g},${this._b},${this._a})`;
  }
  /**
   * @name                    toHslString
   * @type                    Function
   *
   * To hsl string
   *
   * @return 	              {string} 	              	The hsl string representation of the color
   *
   * @example             js
   * myColor.toHslString();
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  toHslString() {
    const hsl = this._convert2("hsl");
    return `hsl(${hsl.h},${hsl.s},${hsl.l})`;
  }
  /**
   * @name                    toHslaString
   * @type                    Function
   *
   * To hsla string
   *
   * @return 	              {string} 	              	The hsl string representation of the color
   *
   * @example             js
   * myColor.toHslaString();
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  toHslaString() {
    const hsla = this._convert2("hsla");
    return `hsla(${hsla.h},${hsla.s},${hsla.l},${hsla.a})`;
  }
  /**
   * @name                toString
   * @type                Function
   *
   * To string
   *
   * @param       {String}              [format=this.settings.format]                The format you want back
   * @values        hex,hsl,rgba
   * @return 	      {string} 		                                                      The rgba string representation of the color
   *
   * @example         js
   * myColor.toString();
   *
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  toString(format2 = this.settings.format) {
    switch (format2) {
      case "hex":
        return this.toHexString();
      case "hsl":
        return this.toHslString();
      case "hsla":
        return this.toHslaString();
      case "rgb":
        return this.toRgbString();
      case "rgba":
      default:
        return this.toRgbaString();
    }
  }
}
SColor.colors = {};
var knownCssProperties = {};
const properties = [
  "-epub-caption-side",
  "-epub-hyphens",
  "-epub-text-combine",
  "-epub-text-emphasis",
  "-epub-text-emphasis-color",
  "-epub-text-emphasis-style",
  "-epub-text-orientation",
  "-epub-text-transform",
  "-epub-word-break",
  "-epub-writing-mode",
  "-internal-text-autosizing-status",
  "accelerator",
  "accent-color",
  "-wap-accesskey",
  "additive-symbols",
  "align-content",
  "-webkit-align-content",
  "align-items",
  "-webkit-align-items",
  "align-self",
  "-webkit-align-self",
  "alignment-baseline",
  "all",
  "alt",
  "-webkit-alt",
  "animation",
  "animation-delay",
  "-moz-animation-delay",
  "-ms-animation-delay",
  "-webkit-animation-delay",
  "animation-direction",
  "-moz-animation-direction",
  "-ms-animation-direction",
  "-webkit-animation-direction",
  "animation-duration",
  "-moz-animation-duration",
  "-ms-animation-duration",
  "-webkit-animation-duration",
  "animation-fill-mode",
  "-moz-animation-fill-mode",
  "-ms-animation-fill-mode",
  "-webkit-animation-fill-mode",
  "animation-iteration-count",
  "-moz-animation-iteration-count",
  "-ms-animation-iteration-count",
  "-webkit-animation-iteration-count",
  "-moz-animation",
  "-ms-animation",
  "animation-name",
  "-moz-animation-name",
  "-ms-animation-name",
  "-webkit-animation-name",
  "animation-play-state",
  "-moz-animation-play-state",
  "-ms-animation-play-state",
  "-webkit-animation-play-state",
  "animation-timing-function",
  "-moz-animation-timing-function",
  "-ms-animation-timing-function",
  "-webkit-animation-timing-function",
  "-webkit-animation-trigger",
  "-webkit-animation",
  "app-region",
  "-webkit-app-region",
  "appearance",
  "-moz-appearance",
  "-webkit-appearance",
  "ascent-override",
  "aspect-ratio",
  "-webkit-aspect-ratio",
  "audio-level",
  "azimuth",
  "backdrop-filter",
  "-webkit-backdrop-filter",
  "backface-visibility",
  "-moz-backface-visibility",
  "-ms-backface-visibility",
  "-webkit-backface-visibility",
  "background",
  "background-attachment",
  "-webkit-background-attachment",
  "background-blend-mode",
  "background-clip",
  "-moz-background-clip",
  "-webkit-background-clip",
  "background-color",
  "-webkit-background-color",
  "-webkit-background-composite",
  "background-image",
  "-webkit-background-image",
  "-moz-background-inline-policy",
  "background-origin",
  "-moz-background-origin",
  "-webkit-background-origin",
  "background-position",
  "-webkit-background-position",
  "background-position-x",
  "-webkit-background-position-x",
  "background-position-y",
  "-webkit-background-position-y",
  "background-repeat",
  "-webkit-background-repeat",
  "background-repeat-x",
  "background-repeat-y",
  "background-size",
  "-moz-background-size",
  "-webkit-background-size",
  "-webkit-background",
  "base-palette",
  "baseline-shift",
  "baseline-source",
  "behavior",
  "-moz-binding",
  "block-ellipsis",
  "-ms-block-progression",
  "block-size",
  "block-step",
  "block-step-align",
  "block-step-insert",
  "block-step-round",
  "block-step-size",
  "bookmark-label",
  "bookmark-level",
  "bookmark-state",
  "border",
  "-webkit-border-after-color",
  "-webkit-border-after-style",
  "-webkit-border-after",
  "-webkit-border-after-width",
  "-webkit-border-before-color",
  "-webkit-border-before-style",
  "-webkit-border-before",
  "-webkit-border-before-width",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "-moz-border-bottom-colors",
  "border-bottom-left-radius",
  "-webkit-border-bottom-left-radius",
  "border-bottom-right-radius",
  "-webkit-border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-boundary",
  "border-collapse",
  "border-color",
  "-moz-border-end-color",
  "-webkit-border-end-color",
  "border-end-end-radius",
  "-moz-border-end",
  "border-end-start-radius",
  "-moz-border-end-style",
  "-webkit-border-end-style",
  "-webkit-border-end",
  "-moz-border-end-width",
  "-webkit-border-end-width",
  "-webkit-border-fit",
  "-webkit-border-horizontal-spacing",
  "border-image",
  "-moz-border-image",
  "-o-border-image",
  "border-image-outset",
  "-webkit-border-image-outset",
  "border-image-repeat",
  "-webkit-border-image-repeat",
  "border-image-slice",
  "-webkit-border-image-slice",
  "border-image-source",
  "-webkit-border-image-source",
  "-webkit-border-image",
  "border-image-width",
  "-webkit-border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "-moz-border-left-colors",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "-moz-border-radius-bottomleft",
  "-moz-border-radius-bottomright",
  "-moz-border-radius",
  "-moz-border-radius-topleft",
  "-moz-border-radius-topright",
  "-webkit-border-radius",
  "border-right",
  "border-right-color",
  "-moz-border-right-colors",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "-moz-border-start-color",
  "-webkit-border-start-color",
  "border-start-end-radius",
  "-moz-border-start",
  "border-start-start-radius",
  "-moz-border-start-style",
  "-webkit-border-start-style",
  "-webkit-border-start",
  "-moz-border-start-width",
  "-webkit-border-start-width",
  "border-style",
  "border-top",
  "border-top-color",
  "-moz-border-top-colors",
  "border-top-left-radius",
  "-webkit-border-top-left-radius",
  "border-top-right-radius",
  "-webkit-border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "-webkit-border-vertical-spacing",
  "border-width",
  "bottom",
  "-moz-box-align",
  "-webkit-box-align",
  "box-decoration-break",
  "-webkit-box-decoration-break",
  "-moz-box-direction",
  "-webkit-box-direction",
  "-webkit-box-flex-group",
  "-moz-box-flex",
  "-webkit-box-flex",
  "-webkit-box-lines",
  "-moz-box-ordinal-group",
  "-webkit-box-ordinal-group",
  "-moz-box-orient",
  "-webkit-box-orient",
  "-moz-box-pack",
  "-webkit-box-pack",
  "-webkit-box-reflect",
  "box-shadow",
  "-moz-box-shadow",
  "-webkit-box-shadow",
  "box-sizing",
  "-moz-box-sizing",
  "-webkit-box-sizing",
  "box-snap",
  "break-after",
  "break-before",
  "break-inside",
  "buffered-rendering",
  "caption-side",
  "caret",
  "caret-color",
  "caret-shape",
  "chains",
  "clear",
  "clip",
  "clip-path",
  "-webkit-clip-path",
  "clip-rule",
  "color",
  "color-adjust",
  "-webkit-color-correction",
  "-apple-color-filter",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "color-scheme",
  "-webkit-column-axis",
  "-webkit-column-break-after",
  "-webkit-column-break-before",
  "-webkit-column-break-inside",
  "column-count",
  "-moz-column-count",
  "-webkit-column-count",
  "column-fill",
  "-moz-column-fill",
  "-webkit-column-fill",
  "column-gap",
  "-moz-column-gap",
  "-webkit-column-gap",
  "column-progression",
  "-webkit-column-progression",
  "column-rule",
  "column-rule-color",
  "-moz-column-rule-color",
  "-webkit-column-rule-color",
  "-moz-column-rule",
  "column-rule-style",
  "-moz-column-rule-style",
  "-webkit-column-rule-style",
  "-webkit-column-rule",
  "column-rule-width",
  "-moz-column-rule-width",
  "-webkit-column-rule-width",
  "column-span",
  "-moz-column-span",
  "-webkit-column-span",
  "column-width",
  "-moz-column-width",
  "-webkit-column-width",
  "columns",
  "-moz-columns",
  "-webkit-columns",
  "-webkit-composition-fill-color",
  "-webkit-composition-frame-color",
  "contain",
  "contain-intrinsic-block-size",
  "contain-intrinsic-height",
  "contain-intrinsic-inline-size",
  "contain-intrinsic-size",
  "contain-intrinsic-width",
  "container",
  "container-name",
  "container-type",
  "content",
  "content-visibility",
  "-ms-content-zoom-chaining",
  "-ms-content-zoom-limit-max",
  "-ms-content-zoom-limit-min",
  "-ms-content-zoom-limit",
  "-ms-content-zoom-snap",
  "-ms-content-zoom-snap-points",
  "-ms-content-zoom-snap-type",
  "-ms-content-zooming",
  "continue",
  "counter-increment",
  "counter-reset",
  "counter-set",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "-webkit-cursor-visibility",
  "cx",
  "cy",
  "d",
  "-apple-dashboard-region",
  "-webkit-dashboard-region",
  "descent-override",
  "direction",
  "display",
  "display-align",
  "dominant-baseline",
  "elevation",
  "empty-cells",
  "enable-background",
  "epub-caption-side",
  "epub-hyphens",
  "epub-text-combine",
  "epub-text-emphasis",
  "epub-text-emphasis-color",
  "epub-text-emphasis-style",
  "epub-text-orientation",
  "epub-text-transform",
  "epub-word-break",
  "epub-writing-mode",
  "fallback",
  "fill",
  "fill-break",
  "fill-color",
  "fill-image",
  "fill-opacity",
  "fill-origin",
  "fill-position",
  "fill-repeat",
  "fill-rule",
  "fill-size",
  "filter",
  "-ms-filter",
  "-webkit-filter",
  "flex",
  "-ms-flex-align",
  "-webkit-flex-align",
  "flex-basis",
  "-webkit-flex-basis",
  "flex-direction",
  "-ms-flex-direction",
  "-webkit-flex-direction",
  "flex-flow",
  "-ms-flex-flow",
  "-webkit-flex-flow",
  "flex-grow",
  "-webkit-flex-grow",
  "-ms-flex-item-align",
  "-webkit-flex-item-align",
  "-ms-flex-line-pack",
  "-webkit-flex-line-pack",
  "-ms-flex",
  "-ms-flex-negative",
  "-ms-flex-order",
  "-webkit-flex-order",
  "-ms-flex-pack",
  "-webkit-flex-pack",
  "-ms-flex-positive",
  "-ms-flex-preferred-size",
  "flex-shrink",
  "-webkit-flex-shrink",
  "-webkit-flex",
  "flex-wrap",
  "-ms-flex-wrap",
  "-webkit-flex-wrap",
  "float",
  "float-defer",
  "-moz-float-edge",
  "float-offset",
  "float-reference",
  "flood-color",
  "flood-opacity",
  "flow",
  "flow-from",
  "-ms-flow-from",
  "-webkit-flow-from",
  "flow-into",
  "-ms-flow-into",
  "-webkit-flow-into",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "-moz-font-feature-settings",
  "-ms-font-feature-settings",
  "-webkit-font-feature-settings",
  "font-kerning",
  "-webkit-font-kerning",
  "font-language-override",
  "-moz-font-language-override",
  "font-optical-sizing",
  "font-palette",
  "font-size",
  "font-size-adjust",
  "-webkit-font-size-delta",
  "-webkit-font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-synthesis-small-caps",
  "font-synthesis-style",
  "font-synthesis-weight",
  "font-variant",
  "font-variant-alternates",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-emoji",
  "font-variant-ligatures",
  "-webkit-font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "footnote-display",
  "footnote-policy",
  "-moz-force-broken-image-icon",
  "forced-color-adjust",
  "gap",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "grid",
  "-webkit-grid-after",
  "grid-area",
  "grid-auto-columns",
  "-webkit-grid-auto-columns",
  "grid-auto-flow",
  "-webkit-grid-auto-flow",
  "grid-auto-rows",
  "-webkit-grid-auto-rows",
  "-webkit-grid-before",
  "grid-column",
  "-ms-grid-column-align",
  "grid-column-end",
  "grid-column-gap",
  "-ms-grid-column",
  "-ms-grid-column-span",
  "grid-column-start",
  "-webkit-grid-column",
  "-ms-grid-columns",
  "-webkit-grid-columns",
  "-webkit-grid-end",
  "grid-gap",
  "grid-row",
  "-ms-grid-row-align",
  "grid-row-end",
  "grid-row-gap",
  "-ms-grid-row",
  "-ms-grid-row-span",
  "grid-row-start",
  "-webkit-grid-row",
  "-ms-grid-rows",
  "-webkit-grid-rows",
  "-webkit-grid-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "-ms-high-contrast-adjust",
  "-webkit-highlight",
  "hyphenate-character",
  "-webkit-hyphenate-character",
  "-webkit-hyphenate-limit-after",
  "-webkit-hyphenate-limit-before",
  "hyphenate-limit-chars",
  "-ms-hyphenate-limit-chars",
  "hyphenate-limit-last",
  "hyphenate-limit-lines",
  "-ms-hyphenate-limit-lines",
  "-webkit-hyphenate-limit-lines",
  "hyphenate-limit-zone",
  "-ms-hyphenate-limit-zone",
  "hyphens",
  "-moz-hyphens",
  "-ms-hyphens",
  "-webkit-hyphens",
  "image-orientation",
  "-moz-image-region",
  "image-rendering",
  "image-resolution",
  "-ms-ime-align",
  "ime-mode",
  "inherits",
  "initial-letter",
  "initial-letter-align",
  "-webkit-initial-letter",
  "initial-letter-wrap",
  "initial-value",
  "inline-size",
  "inline-sizing",
  "input-format",
  "-wap-input-format",
  "-wap-input-required",
  "input-security",
  "inset",
  "inset-block",
  "inset-block-end",
  "inset-block-start",
  "inset-inline",
  "inset-inline-end",
  "inset-inline-start",
  "-ms-interpolation-mode",
  "isolation",
  "justify-content",
  "-webkit-justify-content",
  "justify-items",
  "-webkit-justify-items",
  "justify-self",
  "-webkit-justify-self",
  "kerning",
  "layout-flow",
  "layout-grid",
  "layout-grid-char",
  "layout-grid-line",
  "layout-grid-mode",
  "layout-grid-type",
  "leading-trim",
  "left",
  "letter-spacing",
  "lighting-color",
  "-webkit-line-align",
  "-webkit-line-box-contain",
  "line-break",
  "-webkit-line-break",
  "line-clamp",
  "-webkit-line-clamp",
  "line-gap-override",
  "line-grid",
  "-webkit-line-grid-snap",
  "-webkit-line-grid",
  "line-height",
  "line-height-step",
  "line-increment",
  "line-padding",
  "line-snap",
  "-webkit-line-snap",
  "-o-link",
  "-o-link-source",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "-webkit-locale",
  "-webkit-logical-height",
  "-webkit-logical-width",
  "margin",
  "-webkit-margin-after-collapse",
  "-webkit-margin-after",
  "-webkit-margin-before-collapse",
  "-webkit-margin-before",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "-webkit-margin-bottom-collapse",
  "margin-break",
  "-webkit-margin-collapse",
  "-moz-margin-end",
  "-webkit-margin-end",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "-moz-margin-start",
  "-webkit-margin-start",
  "margin-top",
  "-webkit-margin-top-collapse",
  "margin-trim",
  "marker",
  "marker-end",
  "marker-knockout-left",
  "marker-knockout-right",
  "marker-mid",
  "marker-offset",
  "marker-pattern",
  "marker-segment",
  "marker-side",
  "marker-start",
  "marks",
  "-wap-marquee-dir",
  "-webkit-marquee-direction",
  "-webkit-marquee-increment",
  "-wap-marquee-loop",
  "-webkit-marquee-repetition",
  "-wap-marquee-speed",
  "-webkit-marquee-speed",
  "-wap-marquee-style",
  "-webkit-marquee-style",
  "-webkit-marquee",
  "mask",
  "-webkit-mask-attachment",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "-webkit-mask-box-image-outset",
  "-webkit-mask-box-image-repeat",
  "-webkit-mask-box-image-slice",
  "-webkit-mask-box-image-source",
  "-webkit-mask-box-image",
  "-webkit-mask-box-image-width",
  "mask-clip",
  "-webkit-mask-clip",
  "mask-composite",
  "-webkit-mask-composite",
  "mask-image",
  "-webkit-mask-image",
  "mask-mode",
  "mask-origin",
  "-webkit-mask-origin",
  "mask-position",
  "-webkit-mask-position",
  "mask-position-x",
  "-webkit-mask-position-x",
  "mask-position-y",
  "-webkit-mask-position-y",
  "mask-repeat",
  "-webkit-mask-repeat",
  "-webkit-mask-repeat-x",
  "-webkit-mask-repeat-y",
  "mask-size",
  "-webkit-mask-size",
  "mask-source-type",
  "-webkit-mask-source-type",
  "mask-type",
  "-webkit-mask",
  "-webkit-match-nearest-mail-blockquote-color",
  "math-style",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-lines",
  "-webkit-max-logical-height",
  "-webkit-max-logical-width",
  "max-width",
  "max-zoom",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-intrinsic-sizing",
  "-webkit-min-logical-height",
  "-webkit-min-logical-width",
  "min-width",
  "min-zoom",
  "mix-blend-mode",
  "motion",
  "motion-offset",
  "motion-path",
  "motion-rotation",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "-webkit-nbsp-mode",
  "negative",
  "object-fit",
  "-o-object-fit",
  "object-overflow",
  "object-position",
  "-o-object-position",
  "object-view-box",
  "offset",
  "offset-anchor",
  "offset-block-end",
  "offset-block-start",
  "offset-distance",
  "offset-inline-end",
  "offset-inline-start",
  "offset-path",
  "offset-position",
  "offset-rotate",
  "offset-rotation",
  "opacity",
  "-moz-opacity",
  "-webkit-opacity",
  "order",
  "-webkit-order",
  "-moz-orient",
  "orientation",
  "orphans",
  "-moz-osx-font-smoothing",
  "outline",
  "outline-color",
  "-moz-outline-color",
  "-moz-outline",
  "outline-offset",
  "-moz-outline-offset",
  "-moz-outline-radius-bottomleft",
  "-moz-outline-radius-bottomright",
  "-moz-outline-radius",
  "-moz-outline-radius-topleft",
  "-moz-outline-radius-topright",
  "outline-style",
  "-moz-outline-style",
  "outline-width",
  "-moz-outline-width",
  "overflow",
  "overflow-anchor",
  "overflow-block",
  "overflow-clip-margin",
  "overflow-inline",
  "-webkit-overflow-scrolling",
  "-ms-overflow-style",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "override-colors",
  "overscroll-behavior",
  "overscroll-behavior-block",
  "overscroll-behavior-inline",
  "overscroll-behavior-x",
  "overscroll-behavior-y",
  "pad",
  "padding",
  "-webkit-padding-after",
  "-webkit-padding-before",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "-moz-padding-end",
  "-webkit-padding-end",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "-moz-padding-start",
  "-webkit-padding-start",
  "padding-top",
  "page",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "page-orientation",
  "paint-order",
  "pause",
  "pause-after",
  "pause-before",
  "-apple-pay-button-style",
  "-apple-pay-button-type",
  "pen-action",
  "perspective",
  "-moz-perspective",
  "-ms-perspective",
  "perspective-origin",
  "-moz-perspective-origin",
  "-ms-perspective-origin",
  "-webkit-perspective-origin",
  "perspective-origin-x",
  "-webkit-perspective-origin-x",
  "perspective-origin-y",
  "-webkit-perspective-origin-y",
  "-webkit-perspective",
  "pitch",
  "pitch-range",
  "place-content",
  "place-items",
  "place-self",
  "play-during",
  "pointer-events",
  "position",
  "prefix",
  "print-color-adjust",
  "-webkit-print-color-adjust",
  "property-name",
  "quotes",
  "r",
  "range",
  "-webkit-region-break-after",
  "-webkit-region-break-before",
  "-webkit-region-break-inside",
  "region-fragment",
  "-webkit-region-fragment",
  "-webkit-region-overflow",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "richness",
  "right",
  "rotate",
  "row-gap",
  "-webkit-rtl-ordering",
  "ruby-align",
  "ruby-merge",
  "ruby-overhang",
  "ruby-position",
  "-webkit-ruby-position",
  "running",
  "rx",
  "ry",
  "scale",
  "scroll-behavior",
  "-ms-scroll-chaining",
  "-ms-scroll-limit",
  "-ms-scroll-limit-x-max",
  "-ms-scroll-limit-x-min",
  "-ms-scroll-limit-y-max",
  "-ms-scroll-limit-y-min",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "-ms-scroll-rails",
  "scroll-snap-align",
  "scroll-snap-coordinate",
  "-webkit-scroll-snap-coordinate",
  "scroll-snap-destination",
  "-webkit-scroll-snap-destination",
  "scroll-snap-margin",
  "scroll-snap-margin-bottom",
  "scroll-snap-margin-left",
  "scroll-snap-margin-right",
  "scroll-snap-margin-top",
  "scroll-snap-points-x",
  "-ms-scroll-snap-points-x",
  "-webkit-scroll-snap-points-x",
  "scroll-snap-points-y",
  "-ms-scroll-snap-points-y",
  "-webkit-scroll-snap-points-y",
  "scroll-snap-stop",
  "scroll-snap-type",
  "-ms-scroll-snap-type",
  "-webkit-scroll-snap-type",
  "scroll-snap-type-x",
  "scroll-snap-type-y",
  "-ms-scroll-snap-x",
  "-ms-scroll-snap-y",
  "-ms-scroll-translation",
  "scrollbar-arrow-color",
  "scrollbar-base-color",
  "scrollbar-color",
  "scrollbar-dark-shadow-color",
  "scrollbar-darkshadow-color",
  "scrollbar-face-color",
  "scrollbar-gutter",
  "scrollbar-highlight-color",
  "scrollbar-shadow-color",
  "scrollbar-track-color",
  "scrollbar-width",
  "scrollbar3d-light-color",
  "scrollbar3dlight-color",
  "shape-image-threshold",
  "-webkit-shape-image-threshold",
  "shape-inside",
  "-webkit-shape-inside",
  "shape-margin",
  "-webkit-shape-margin",
  "shape-outside",
  "-webkit-shape-outside",
  "-webkit-shape-padding",
  "shape-rendering",
  "size",
  "size-adjust",
  "snap-height",
  "solid-color",
  "solid-opacity",
  "spatial-navigation-action",
  "spatial-navigation-contain",
  "spatial-navigation-function",
  "speak",
  "speak-as",
  "speak-header",
  "speak-numeral",
  "speak-punctuation",
  "speech-rate",
  "src",
  "-moz-stack-sizing",
  "stop-color",
  "stop-opacity",
  "stress",
  "string-set",
  "stroke",
  "stroke-align",
  "stroke-alignment",
  "stroke-break",
  "stroke-color",
  "stroke-dash-corner",
  "stroke-dash-justify",
  "stroke-dashadjust",
  "stroke-dasharray",
  "stroke-dashcorner",
  "stroke-dashoffset",
  "stroke-image",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-origin",
  "stroke-position",
  "stroke-repeat",
  "stroke-size",
  "stroke-width",
  "suffix",
  "supported-color-schemes",
  "-webkit-svg-shadow",
  "symbols",
  "syntax",
  "system",
  "tab-size",
  "-moz-tab-size",
  "-o-tab-size",
  "-o-table-baseline",
  "table-layout",
  "-webkit-tap-highlight-color",
  "text-align",
  "text-align-all",
  "text-align-last",
  "-moz-text-align-last",
  "text-anchor",
  "text-autospace",
  "-moz-text-blink",
  "-ms-text-combine-horizontal",
  "text-combine-upright",
  "-webkit-text-combine",
  "text-decoration",
  "text-decoration-blink",
  "text-decoration-color",
  "-moz-text-decoration-color",
  "-webkit-text-decoration-color",
  "text-decoration-line",
  "-moz-text-decoration-line",
  "text-decoration-line-through",
  "-webkit-text-decoration-line",
  "text-decoration-none",
  "text-decoration-overline",
  "text-decoration-skip",
  "text-decoration-skip-box",
  "text-decoration-skip-ink",
  "text-decoration-skip-inset",
  "text-decoration-skip-self",
  "text-decoration-skip-spaces",
  "-webkit-text-decoration-skip",
  "text-decoration-style",
  "-moz-text-decoration-style",
  "-webkit-text-decoration-style",
  "text-decoration-thickness",
  "text-decoration-underline",
  "-webkit-text-decoration",
  "-webkit-text-decorations-in-effect",
  "text-edge",
  "text-emphasis",
  "text-emphasis-color",
  "-webkit-text-emphasis-color",
  "text-emphasis-position",
  "-webkit-text-emphasis-position",
  "text-emphasis-skip",
  "text-emphasis-style",
  "-webkit-text-emphasis-style",
  "-webkit-text-emphasis",
  "-webkit-text-fill-color",
  "text-group-align",
  "text-indent",
  "text-justify",
  "text-justify-trim",
  "text-kashida",
  "text-kashida-space",
  "text-line-through",
  "text-line-through-color",
  "text-line-through-mode",
  "text-line-through-style",
  "text-line-through-width",
  "text-orientation",
  "-webkit-text-orientation",
  "text-overflow",
  "text-overline",
  "text-overline-color",
  "text-overline-mode",
  "text-overline-style",
  "text-overline-width",
  "text-rendering",
  "-webkit-text-security",
  "text-shadow",
  "text-size-adjust",
  "-moz-text-size-adjust",
  "-ms-text-size-adjust",
  "-webkit-text-size-adjust",
  "text-space-collapse",
  "text-space-trim",
  "text-spacing",
  "-webkit-text-stroke-color",
  "-webkit-text-stroke",
  "-webkit-text-stroke-width",
  "text-transform",
  "text-underline",
  "text-underline-color",
  "text-underline-mode",
  "text-underline-offset",
  "text-underline-position",
  "-webkit-text-underline-position",
  "text-underline-style",
  "text-underline-width",
  "text-wrap",
  "-webkit-text-zoom",
  "top",
  "touch-action",
  "touch-action-delay",
  "-ms-touch-action",
  "-webkit-touch-callout",
  "-ms-touch-select",
  "-apple-trailing-word",
  "transform",
  "transform-box",
  "-moz-transform",
  "-ms-transform",
  "-o-transform",
  "transform-origin",
  "-moz-transform-origin",
  "-ms-transform-origin",
  "-o-transform-origin",
  "-webkit-transform-origin",
  "transform-origin-x",
  "-webkit-transform-origin-x",
  "transform-origin-y",
  "-webkit-transform-origin-y",
  "transform-origin-z",
  "-webkit-transform-origin-z",
  "transform-style",
  "-moz-transform-style",
  "-ms-transform-style",
  "-webkit-transform-style",
  "-webkit-transform",
  "transition",
  "transition-delay",
  "-moz-transition-delay",
  "-ms-transition-delay",
  "-o-transition-delay",
  "-webkit-transition-delay",
  "transition-duration",
  "-moz-transition-duration",
  "-ms-transition-duration",
  "-o-transition-duration",
  "-webkit-transition-duration",
  "-moz-transition",
  "-ms-transition",
  "-o-transition",
  "transition-property",
  "-moz-transition-property",
  "-ms-transition-property",
  "-o-transition-property",
  "-webkit-transition-property",
  "transition-timing-function",
  "-moz-transition-timing-function",
  "-ms-transition-timing-function",
  "-o-transition-timing-function",
  "-webkit-transition-timing-function",
  "-webkit-transition",
  "translate",
  "uc-alt-skin",
  "uc-skin",
  "unicode-bidi",
  "unicode-range",
  "-webkit-user-drag",
  "-moz-user-focus",
  "-moz-user-input",
  "-moz-user-modify",
  "-webkit-user-modify",
  "user-select",
  "-moz-user-select",
  "-ms-user-select",
  "-webkit-user-select",
  "user-zoom",
  "vector-effect",
  "vertical-align",
  "viewport-fill",
  "viewport-fill-opacity",
  "viewport-fit",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "volume",
  "white-space",
  "-webkit-widget-region",
  "widows",
  "width",
  "will-change",
  "-moz-window-dragging",
  "-moz-window-shadow",
  "word-boundary-detection",
  "word-boundary-expansion",
  "word-break",
  "word-spacing",
  "word-wrap",
  "wrap-after",
  "wrap-before",
  "wrap-flow",
  "-ms-wrap-flow",
  "-webkit-wrap-flow",
  "wrap-inside",
  "-ms-wrap-margin",
  "-webkit-wrap-margin",
  "-webkit-wrap-padding",
  "-webkit-wrap-shape-inside",
  "-webkit-wrap-shape-outside",
  "wrap-through",
  "-ms-wrap-through",
  "-webkit-wrap-through",
  "-webkit-wrap",
  "writing-mode",
  "-webkit-writing-mode",
  "x",
  "y",
  "z-index",
  "zoom"
];
const require$$0$2 = {
  properties
};
knownCssProperties.all = require$$0$2.properties;
var __awaiter$j = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class shadesNameInterface extends SInterface {
  static get _definition() {
    return {
      saturate: {
        type: "Number|String",
        default: 0
      },
      desaturate: {
        type: "Number",
        default: 0
      },
      darken: {
        type: "Number",
        default: 0
      },
      lighten: {
        type: "Number",
        default: 0
      },
      spin: {
        type: "Number",
        default: 0
      },
      alpha: {
        type: "Number",
        default: 1
      }
    };
  }
}
class SThemeBase extends SEventEmitter2 {
  /**
   * @name            sortMedia
   * @type            Function
   * @static
   *
   * This function takes as input the "media" object of the `frontspec.json` file and sort the "queries"
   * depending on the "defaultAction" specified.
   *
   * @param       {Object}            media      The media object to process
   * @return      {Object}                        THe new media object with queries sorted correctly
   *
   * @since           2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static sortMedia(media) {
    var _a2;
    if (!media.defaultAction) {
      return media;
    }
    const queries = __sort((_a2 = media.queries) !== null && _a2 !== void 0 ? _a2 : {}, (a, b) => {
      if (media.defaultAction === "<=") {
        return a.value.minWidth < b.value.minWidth ? 1 : -1;
      } else if (media.defaultAction === ">=") {
        return a.value.minWidth > b.value.minWidth ? 1 : -1;
      }
      return 0;
    });
    media.queries = queries;
    return media;
  }
  /**
   * @name            id
   * @type            String
   *
   * Store the computed theme id builded from the theme name and theme variant
   *
   * @since   2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get id() {
    return `${this.theme}-${this.variant}`;
  }
  /**
   * @name      theme
   * @type      String
   * @static
   *
   * Store the current theme setted in the config.theme namespace
   *
   * @since     2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static get theme() {
    return SSugarConfig.get("theme.theme");
  }
  /**
   * @name      variant
   * @type      String
   * @static
   *
   * Store the current variant setted in the config.variant namespace
   *
   * @since     2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static get variant() {
    return SSugarConfig.get("theme.variant");
  }
  /**
   * @name      themesNames
   * @type      Object
   * @static
   *
   * Access the defined themes names
   *
   * @since     2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static get themesNames() {
    return Object.keys(SSugarConfig.get("theme.themes"));
  }
  /**
   * @name            isDark
   * @type            Function
   * @static
   *
   * This method returns true if the theme variant is dark, false if not
   *
   * @return      {Boolean}               true if variant is dark, false otherwise
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static isDark() {
    return this.variant === "dark";
  }
  /**
   * @name            isMobileFirst
   * @type            Function
   * @static
   *
   * This method returns true if the theme is configured to be mobile first.
   * Mobile first is true when the "config.theme.media.defaultAction" is set to "<="
   *
   * @return      {Boolean}               true if variant is dark, false otherwise
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static isMobileFirst() {
    return this.getSafe("media.defaultAction") === ">=";
  }
  /**
   * @name            getThemeMetas
   * @type            Function
   * @static
   *
   * This method allows you to get the theme metas like "name", "theme" and "variant" from the passed HTMLElement
   *
   * @return      {any}                               The theme metas object containing the "name", "theme" and "variant" properties
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static getThemeMetas() {
    var _a2;
    let defaultTheme = SSugarConfig.get("theme.theme"), defaultVariant = SSugarConfig.get("theme.variant");
    let theme = defaultTheme, variant = defaultVariant;
    const metas = (_a2 = SSugarConfig.get(`theme.themes.${theme}-${variant}.metas`)) !== null && _a2 !== void 0 ? _a2 : {};
    return __deepMerge({
      name: `${theme !== null && theme !== void 0 ? theme : defaultTheme}-${variant !== null && variant !== void 0 ? variant : defaultVariant}`,
      theme: theme !== null && theme !== void 0 ? theme : defaultTheme,
      variant: variant !== null && variant !== void 0 ? variant : defaultVariant
    }, metas);
  }
  /**
   * @name      themes
   * @type      Object
   * @static
   *
   * Access the defined themes
   *
   * @since     2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static get themes() {
    var _a2, _b2;
    const themes = SSugarConfig.get("theme.themes");
    const returnedThemes = {};
    for (let [themeName, themeObj] of Object.entries(themes)) {
      const parts = themeName.split("-"), name2 = parts[0], variant = (_a2 = parts[1]) !== null && _a2 !== void 0 ? _a2 : "light";
      if (!returnedThemes[name2]) {
        returnedThemes[name2] = {
          metas: (_b2 = themeObj.metas) !== null && _b2 !== void 0 ? _b2 : {},
          variants: {}
        };
      }
      if (!returnedThemes[name2].variants[variant]) {
        returnedThemes[name2].variants[variant] = themeObj;
      }
    }
    return returnedThemes;
  }
  static getTheme(theme, variant, settings) {
    var _a2, _b2;
    const themesNames = Object.keys(SSugarConfig.get("theme.themes"));
    theme = theme !== null && theme !== void 0 ? theme : (_a2 = this._firstGetedThemeSettings) === null || _a2 === void 0 ? void 0 : _a2.theme;
    variant = variant !== null && variant !== void 0 ? variant : (_b2 = this._firstGetedThemeSettings) === null || _b2 === void 0 ? void 0 : _b2.variant;
    if (!theme) {
      theme = SSugarConfig.get("theme.theme");
    }
    if (!variant) {
      variant = SSugarConfig.get("theme.variant");
    }
    if (!themesNames.includes(`${theme}-${variant}`)) {
      theme = SSugarConfig.get("theme.theme");
      variant = SSugarConfig.get("theme.variant");
    }
    if (!this._firstGetedThemeSettings) {
      this._firstGetedThemeSettings = {
        theme,
        variant,
        settings
      };
    }
    if (this._instanciatedThemes[`${theme}-${variant}`]) {
      return this._instanciatedThemes[`${theme}-${variant}`];
    }
    if (!themesNames[`${theme}-${variant}`]) {
      this._instanciatedThemes[`${theme}-${variant}`] = new this(theme, variant, settings);
    }
    return this._instanciatedThemes[`${theme}-${variant}`];
  }
  /**
   * @name            hash
   * @type            String
   * @static
   *
   * This hash accessor gives you access to the actual theme configuration hash.
   * You can specify a dot path to get the hash of a sub configuration
   *
   * @param           {String}            [dotPath='']            The dot path of the config you want to hash
   * @return          {String}                                    The generated hash for this config
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static hash(dotPath = "", settings) {
    const config2 = this.get(dotPath, settings);
    return objectHash(config2);
  }
  /**
   * @name        resolveFontSize
   * @type        Function
   * @static
   *
   * This method allows you to get back the actual final font-size value of the passed one
   *
   * @param       {any}           size        The size you want to resolve
   * @return      {any}                       The final resolved size
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static resolveFontSize(size, settings) {
    const theme = this.getTheme(settings === null || settings === void 0 ? void 0 : settings.theme, settings === null || settings === void 0 ? void 0 : settings.variant);
    return theme.resolveFontSize(size);
  }
  /**
   * @name        resolvePadding
   * @type        Function
   * @static
   *
   * This method allows you to get back the actual final padding value of the passed one
   *
   * @param       {any}           size        The size you want to resolve
   * @return      {any}                       The final resolved size
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static resolvePadding(size, settings) {
    const theme = this.getTheme(settings === null || settings === void 0 ? void 0 : settings.theme, settings === null || settings === void 0 ? void 0 : settings.variant);
    return theme.resolvePadding(size);
  }
  /**
   * @name        resolveMargin
   * @type        Function
   * @static
   *
   * This method allows you to get back the actual final margin value of the passed one
   *
   * @param       {any}           size        The size you want to resolve
   * @return      {any}                       The final resolved size
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static resolveMargin(size, settings) {
    const theme = this.getTheme(settings === null || settings === void 0 ? void 0 : settings.theme, settings === null || settings === void 0 ? void 0 : settings.variant);
    return theme.resolveMargin(size);
  }
  /**
   * @name        resolveBorderRadius
   * @type        Function
   * @static
   *
   * This method allows you to get back the actual final border-radius value of the passed one
   *
   * @param       {any}           size        The size you want to resolve
   * @return      {any}                       The final resolved size
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static resolveBorderRadius(size, settings) {
    const theme = this.getTheme(settings === null || settings === void 0 ? void 0 : settings.theme, settings === null || settings === void 0 ? void 0 : settings.variant);
    return theme.resolveBorderRadius(size);
  }
  /**
   * @name        resolveBorderWidth
   * @type        Function
   * @static
   *
   * This method allows you to get back the actual final border-width value of the passed one
   *
   * @param       {any}           size        The size you want to resolve
   * @return      {any}                       The final resolved size
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static resolveBorderWidth(size, settings) {
    const theme = this.getTheme(settings === null || settings === void 0 ? void 0 : settings.theme, settings === null || settings === void 0 ? void 0 : settings.variant);
    return theme.resolveBorderWidth(size);
  }
  /**
   * @name        resolveColor
   * @type        Function
   * @static
   *
   * This method allows you to get back the actual final value of a color with
   * his shade and modifier.
   * You can get back either a css variable or the actual color value by specifying
   * the "settings.return" setting.
   *
   * @param       {String}            color       The color you want to resolve
   * @param       {String}            [shade=null]      The color shade you want
   * @param       {String}            [modifier=null]     The modifier you want to apply. Can be something like "--darken 30%", etc...
   * @param       {ISThemeColorResolveColorSettings}      [settings={}]           Some settings
   * @return      {any}                       The final resolved color
   *
   * @setting         {'var'|'value'}         [return='value']        The return format you want
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static resolveColor(color, shade, modifier, settings) {
    const theme = this.getTheme(settings === null || settings === void 0 ? void 0 : settings.theme, settings === null || settings === void 0 ? void 0 : settings.variant);
    return theme.resolveColor(color, shade, modifier, settings);
  }
  /**
   * @name        cssVar
   * @type        Function
   *
   * This function take a simple theme dot path and returns the proper
   * variable string with the value fallback.
   *
   * @param       {String}        dotPath         The dot path theme variable you want
   * @return      {String}                        The proper css variable string that represent this value with his fallback just in case
   *
   * @example         js
   * import { cssVar } from '@coffeekraken/s-sugarcss-plugin';
   * cssVar('ui.button.padding'); // => var(--s-ui-button-padding, 1em 1.2em)
   *
   * @since       2.0.0
   * @author 	                Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static cssVar(dotPath, fallback = true, settings) {
    const theme = this.getTheme(settings === null || settings === void 0 ? void 0 : settings.theme, settings === null || settings === void 0 ? void 0 : settings.variant);
    dotPath = theme.proxyNonExistingUiDotpath(dotPath);
    let varName = `s-${dotPath.replace(/\./gm, "-").replace(/:/gm, "-").replace(/\?/gm, "").replace(/--/gm, "-")}`;
    varName = `--${__dashCase(varName)}`;
    let fb = theme.get(dotPath);
    if (!fallback || typeof fb === "string" && fb.includes(","))
      fb = 0;
    const v2 = `var(${varName}, ${fb})`;
    return v2;
  }
  /**
   * @name                resolveCssPropertyValue
   * @type                Function
   * @static
   *
   * This static method allows you to pass a css property with a value and get back his final value
   * resolved depending on the theme configuration.
   *
   * @param       {String}            property        The css property to resolve
   * @param       {any}               value           The css property value to resolve
   * @return      {any}                               The resolved css value
   *
   * @since       2.0.0
   * @author 	                Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static resolveCssPropertyValue(property, value, settings) {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h, _j;
    const dashProp = __dashCase(property);
    switch (dashProp) {
      case "font-family":
        const fontObj = this.get(`font.family.${value}`);
        return (_a2 = fontObj === null || fontObj === void 0 ? void 0 : fontObj.fontFamily) !== null && _a2 !== void 0 ? _a2 : value;
      case "font-size":
        return (_b2 = this.resolveFontSize(value, settings)) !== null && _b2 !== void 0 ? _b2 : value;
      case "color":
      case "background-color":
        let color = value, shade, modifier;
        if (Array.isArray(value) && value.length === 2) {
          color = value[0];
          shade = value[1];
        }
        if (Array.isArray(value) && value.length === 3) {
          color = value[0];
          shade = value[1];
          modifier = value[2];
        }
        return (_c2 = this.resolveColor(color, shade, modifier, Object.assign(Object.assign({}, settings !== null && settings !== void 0 ? settings : {}), { return: "value" }))) !== null && _c2 !== void 0 ? _c2 : value;
      case "border-radius":
      case "border-top-left-radius":
      case "border-top-right-radius":
      case "border-bottom-right-radius":
      case "border-bottom-left-radius":
        return (_d2 = this.resolveBorderRadius(value)) !== null && _d2 !== void 0 ? _d2 : value;
      case "border-width":
        return (_e2 = this.resolveBorderWidth(value)) !== null && _e2 !== void 0 ? _e2 : value;
      case "transition":
        return (_f2 = this.getSafe(`transition.${value}`)) !== null && _f2 !== void 0 ? _f2 : value;
      case "margin-inline":
      case "margin-block":
      case "margin-inline-start":
      case "margin-inline-end":
      case "margin-block-start":
      case "margin-block-end":
      case "margin":
      case "margin-top":
      case "margin-bottom":
      case "margin-left":
      case "margin-right":
        return (_g2 = this.resolveMargin(value)) !== null && _g2 !== void 0 ? _g2 : value;
      case "padding-inline":
      case "padding-block":
      case "padding-inline-start":
      case "padding-inline-end":
      case "padding-block-start":
      case "padding-block-end":
      case "padding":
      case "padding-top":
      case "padding-bottom":
      case "padding-left":
      case "padding-right":
        return (_h = this.resolvePadding(value)) !== null && _h !== void 0 ? _h : value;
      case "depth":
        return (_j = this.getSafe(`depth.${value}`, settings)) !== null && _j !== void 0 ? _j : value;
    }
    return value;
  }
  /**
   * @name                resolveCssObjectPropertiesValues
   * @type                Function
   * @static
   *
   * This static method allows you to passe a js object with some css properties and to
   * resolve each of these properties values using the `resolveCssPropertyValue` method
   *
   * @param       {Object}            object      The css properties object to resolve values from
   * @return      {Object}                        The css properties object with resolved values
   *
   * @since       2.0.0
   * @author 	                Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static resolveCssObjectPropertiesValues(object, settings) {
    const newObj = Object.assign({}, object);
    for (let [prop, value] of Object.entries(newObj)) {
      newObj[prop] = this.resolveCssPropertyValue(prop, value, settings);
    }
    return newObj;
  }
  /**
   * @name                jsObjectToCssProperties
   * @type                Function
   * @status              beta
   * @static
   *
   * This static method allows you to pass a javascript object that contain css properties
   * and it will returns the processed css string. Some properties can accept internal theme configuration
   * settings like `font-size`, `color`, etc...:
   *
   * - `font-family`
   * - `font-size`
   * - `color`
   * - `background-color`
   * - `border-radius`: And all border-radius properties like `border-top-left-radius`, etc...
   * - `border-width`
   * - `transition`
   * - `margin`: And all the margins properties like `margin-inline`, etc...
   * - `padding`: And all the paddings properties like `padding-block`, etc...
   * - `depth`: Special property that will apply nice shadows depending on your theme configuration
   * - `default-color`: Apply the default color using `@s.color` mixin
   *
   * @param           {Object}        jsObject        An object to convert to css string
   * @return          {String}                            The processed css string
   *
   * @since       2.0.0
   * @author 	                Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static jsObjectToCssProperties(jsObject, settings) {
    const finalSettings = __deepMerge({
      exclude: [],
      only: []
    }, settings);
    const propsStack = [];
    Object.keys(jsObject).forEach((prop) => {
      var _a2;
      if (finalSettings.exclude.indexOf(prop) !== -1)
        return;
      if (finalSettings.exclude.indexOf(__dashCase(prop)) !== -1)
        return;
      const originalProp = prop;
      prop = __dashCase(prop).trim();
      if (finalSettings.exclude.length && finalSettings.exclude.indexOf(prop) !== -1)
        return;
      if (finalSettings.only.length && finalSettings.only.indexOf(prop) === -1)
        return;
      const value = jsObject[originalProp];
      if (!value)
        return;
      const medias = Object.keys(this.get("media.queries"));
      if (medias.includes(originalProp)) {
        propsStack.push(`@s.media(${prop.replace(/^@/, "")}) {`);
        propsStack.push(this.jsObjectToCssProperties(value, finalSettings));
        propsStack.push(`}`);
      } else {
        switch (prop) {
          case "font-family":
            propsStack.push(`@s.font.family(${value});`);
            break;
          case "font-size":
            propsStack.push(`@s.font.size(${value});`);
            break;
          case "color":
          case "background-color":
            let color = value, shade, modifier;
            if (Array.isArray(value) && value.length === 2) {
              color = value[0];
              shade = value[1];
            }
            if (Array.isArray(value) && value.length === 3) {
              color = value[0];
              shade = value[1];
              modifier = value[2];
            }
            propsStack.push(`${prop}: ${(_a2 = this.resolveColor(color, shade, modifier, Object.assign(Object.assign({}, settings !== null && settings !== void 0 ? settings : {}), { return: "var" }))) !== null && _a2 !== void 0 ? _a2 : value};`);
            break;
          case "border-radius":
          case "border-top-left-radius":
          case "border-top-right-radius":
          case "border-bottom-right-radius":
          case "border-bottom-left-radius":
            propsStack.push(`border-radius: s.border.radius(${value});`);
            break;
          case "border-width":
            propsStack.push(`border-width: s.border.width(${value});`);
            break;
          case "transition":
            propsStack.push(`transition: s.transition(${value});`);
            break;
          case "margin-inline":
          case "margin-block":
          case "margin-inline-start":
          case "margin-inline-end":
          case "margin-block-start":
          case "margin-block-end":
          case "margin":
          case "margin-top":
          case "margin-bottom":
          case "margin-left":
          case "margin-right":
            propsStack.push(`${prop}: s.margin(${value});`);
            break;
          case "padding-inline":
          case "padding-block":
          case "padding-inline-start":
          case "padding-inline-end":
          case "padding-block-start":
          case "padding-block-end":
          case "padding":
          case "padding-top":
          case "padding-bottom":
          case "padding-left":
          case "padding-right":
            propsStack.push(`${prop}: s.padding(${value});`);
            break;
          case "depth":
            propsStack.push(`@s.depth(${value});`);
            break;
          case "default-color":
            propsStack.push(`@s.color(${value});`);
            break;
          default:
            const props = knownCssProperties.all;
            if (props.indexOf(prop) === -1)
              return;
            propsStack.push(`${prop}: ${value};`);
            break;
        }
      }
    });
    return propsStack.join("\n");
  }
  static jsConfigObjectToCssProperties(obj) {
    let vars = [];
    for (let [key, value] of Object.entries(__flatten(obj))) {
      if (__isColor(value)) {
        const color = key.match(/^color\.([a-zA-Z0-9]+)\./);
        if (!(color === null || color === void 0 ? void 0 : color[1]))
          continue;
        const props = this.remapCssColor(color[1], value);
        vars = [...vars, ...props.vars];
      }
      const varKey = key.replace(/\./gm, "-").replace(/:/gm, "-").replace(/\?/gm, "").replace(/--/gm, "-");
      let variable = `--s-${varKey}`;
      if (`${value}`.match(/:/)) {
        vars.push(`${variable}: "${value}";`);
      } else {
        vars.push(`${variable}: ${value};`);
      }
    }
    return vars;
  }
  /**
   * @name                remapCssColor
   * @type                Function
   * @status              beta
   * @static
   *
   * This static method allows you to remap a color to another and returns the needed css
   * variables string.
   *
   * @param           {String}            from            The color name you want to remap
   * @param           {String}            to              The color you want to assign
   * @return          {String}                            The generated css variables string
   *
   * @since       2.0.0
   * @author 	                Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static remapCssColor(from2, to2, settings) {
    const result2 = {
      vars: [],
      properties: {}
    };
    if (__isColor(to2)) {
      const color = new SColor(to2);
      result2.vars = [
        `${`--s-color-${from2}-h`}: ${color.h};`,
        `${`--s-color-${from2}-s`}: ${color.s};`,
        `${`--s-color-${from2}-l`}: ${color.l};`,
        `${`--s-color-${from2}-a`}: ${color.a};`
      ];
      result2.properties[`--s-color-${from2}-h`] = color.h;
      result2.properties[`--s-color-${from2}-s`] = color.s;
      result2.properties[`--s-color-${from2}-l`] = color.l;
      result2.properties[`--s-color-${from2}-a`] = color.a;
    } else {
      const toColorName = to2.split("-").slice(0, 1)[0], fromColorName = from2.split("-").slice(0, 1)[0];
      let toColorVariant = to2.split("-").pop();
      from2.split("-").pop();
      if (toColorName === toColorVariant)
        toColorVariant = void 0;
      let fromVariable = `--s-color-${fromColorName}`, toVariable = `--s-color-${toColorName}`;
      this.getTheme(settings === null || settings === void 0 ? void 0 : settings.theme, settings === null || settings === void 0 ? void 0 : settings.variant).loopOnColors((colorObj) => {
        if (colorObj.name === toColorName) {
          if (toColorVariant) {
            if (colorObj.shade === toColorVariant) {
              result2.vars.push(`${fromVariable}-saturation-offset: var(${toVariable}-${colorObj.shadeDash}-saturation-offset, 0);`);
              result2.properties[`${fromVariable}-saturation-offset`] = `var(${toVariable}-${colorObj.shadeDash}-saturation-offset, 0)`;
              result2.vars.push(`${fromVariable}-lightness-offset: var(${toVariable}-${colorObj.shadeDash}-lightness-offset, 0);`);
              result2.properties[`${fromVariable}-lightness-offset`] = `var(${toVariable}-${colorObj.shadeDash}-lightness-offset, 0)`;
              result2.vars.push(`${fromVariable}-a: var(${toVariable}-a, 1);`);
              result2.properties[`${fromVariable}-a`] = `var(${toVariable}-a, 1)`;
            }
          } else {
            if (!colorObj.shade && colorObj.value.color) {
              result2.vars.push(`${fromVariable}-h: var(${toVariable}-h);`);
              result2.properties[`${fromVariable}-h`] = `var(${toVariable}-h)`;
              result2.vars.push(`${fromVariable}-s: var(${toVariable}-s);`);
              result2.properties[`${fromVariable}-s`] = `var(${toVariable}-s)`;
              result2.vars.push(`${fromVariable}-l: var(${toVariable}-l);`);
              result2.properties[`${fromVariable}-l`] = `var(${toVariable}-l)`;
            } else {
              result2.vars.push(`${fromVariable}-${colorObj.shadeDash}-saturation-offset: var(${toVariable}-${colorObj.shadeDash}-saturation-offset, 0);`);
              result2.properties[`${fromVariable}-${colorObj.shadeDash}-saturation-offset`] = `var(${toVariable}-${colorObj.shadeDash}-saturation-offset, 0)`;
              result2.vars.push(`${fromVariable}-${colorObj.shadeDash}-lightness-offset: var(${toVariable}-${colorObj.shadeDash}-lightness-offset, 0);`);
              result2.properties[`${fromVariable}-${colorObj.shadeDash}-lightness-offset`] = `var(${toVariable}-${colorObj.shadeDash}-lightness-offset, 0)`;
              result2.vars.push(`${fromVariable}-a: var(${toVariable}-a, 1);`);
              result2.properties[`${fromVariable}-a`] = `var(${toVariable}-a, 1)`;
            }
          }
        }
      });
    }
    return result2;
  }
  /**
   * @name            toCssVars
   * @type            Function
   * @static
   *
   * This static method allows you to transform a theme/variant into css variables
   *
   * @param       {String}        theme           The theme name you want to transform
   * @param       {String}        variant         The theme variant you want to transform
   * @return      {String}                        The converted css variables string
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static toCssVars(settings) {
    const themeInstance = this.getTheme(settings === null || settings === void 0 ? void 0 : settings.theme, settings === null || settings === void 0 ? void 0 : settings.variant);
    if (!themeInstance)
      throw new Error(`Sorry but the requested theme "<yellow>${settings.theme}-${settings.variant}</yellow>" does not exists...`);
    let vars = [
      `--s-theme: ${themeInstance.theme};`,
      `--s-variant: ${themeInstance.variant};`
    ];
    themeInstance.loopOnColors((colorObj) => {
      const baseVariable = colorObj.value.variable;
      if (!colorObj.shade && colorObj.value.color) {
        vars.push(`${baseVariable}-h: ${colorObj.value.h};`);
        vars.push(`${baseVariable}-s: ${colorObj.value.s};`);
        vars.push(`${baseVariable}-l: ${colorObj.value.l};`);
        vars.push(`${baseVariable}-a: ${colorObj.value.a};`);
        vars.push(`${baseVariable}-origin-h: ${colorObj.value.h};`);
        vars.push(`${baseVariable}-origin-s: ${colorObj.value.s};`);
        vars.push(`${baseVariable}-origin-l: ${colorObj.value.l};`);
        vars.push(`${baseVariable}-origin-a: ${colorObj.value.a};`);
      } else if (colorObj.shade) {
        if (colorObj.value.saturate) {
          vars.push(`${baseVariable}-saturation-offset: ${colorObj.value.saturate};`);
        } else if (colorObj.value.desaturate) {
          vars.push(`${baseVariable}-saturation-offset: ${colorObj.value.desaturate * -1};`);
        } else {
          vars.push(`${baseVariable}-saturation-offset: 0;`);
        }
        if (colorObj.value.lighten) {
          vars.push(`${baseVariable}-lightness-offset: ${colorObj.value.lighten};`);
        } else if (colorObj.value.darken) {
          vars.push(`${baseVariable}-lightness-offset: ${colorObj.value.darken * -1};`);
        } else {
          vars.push(`${baseVariable}-lightness-offset: 0;`);
        }
        if (colorObj.value.alpha >= 0 && colorObj.value.alpha <= 1) {
          vars.push(`${baseVariable}-a: ${colorObj.value.alpha};`);
        }
      }
    });
    const themeObjWithoutColors = Object.assign({}, themeInstance.get("."));
    delete themeObjWithoutColors.color;
    const flattenedTheme = __flatten(themeObjWithoutColors);
    const keep = [
      "--s-easing",
      "--s-timing",
      "--s-transition",
      "--s-scale",
      "--s-opacity",
      "--s-width",
      "--s-height",
      "--s-depth",
      "--s-size",
      "--s-font",
      "--s-border",
      "--s-space",
      "--s-margin",
      "--s-padding",
      "--s-offsize",
      "--s-color",
      "--s-layout",
      "--s-shape",
      "--s-ui"
    ];
    Object.keys(flattenedTheme).forEach((key) => {
      const value = flattenedTheme[key];
      const varKey = key.replace(/\./gm, "-").replace(/:/gm, "-").replace(/\?/gm, "").replace(/--/gm, "-");
      let variable = `--${__dashCase(`s-${varKey}`)}`;
      let hasToKeep = false;
      for (let [i, startWith] of keep.entries()) {
        if (variable.startsWith(startWith)) {
          hasToKeep = true;
          break;
        }
      }
      if (!hasToKeep) {
        return;
      }
      if (`${value}`.match(/:/)) {
        vars.push(`${variable}: "${flattenedTheme[key]}";`);
      } else {
        vars.push(`${variable}: ${flattenedTheme[key]};`);
      }
    });
    return vars;
  }
  /**
   * @name            getSafe
   * @type            Function
   * @static
   *
   * This static method allows you to access the active theme config without throwing an error if it not exists
   *
   * @param       {String}        dotPath           The dot path of the config you want
   * @return      {any}                        The getted theme config
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static getSafe(dotPath, settings) {
    const instance = this.getTheme(settings === null || settings === void 0 ? void 0 : settings.theme, settings === null || settings === void 0 ? void 0 : settings.variant);
    return instance.get(dotPath, {
      preventThrow: true
    });
  }
  /**
   * @name            get
   * @type            Function
   * @static
   *
   * This static method allows you to access the active theme config
   *
   * @param       {String}        dotPath           The dot path of the config you want
   * @return      {any}                        The getted theme config
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static get(dotPath, settings) {
    const instance = this.getTheme(settings === null || settings === void 0 ? void 0 : settings.theme, settings === null || settings === void 0 ? void 0 : settings.variant);
    return instance.get(dotPath);
  }
  /**
   * @name            set
   * @type            Function
   * @static
   *
   * This static method allows you to set values of the active theme config
   *
   * @param       {String}        dotPath           The dot path of the config you want to set
   * @param       {any}         value             The value you want to set
   * @return      {STheme}                        The current theme instance
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static set(dotPath, value, settings) {
    const instance = this.getTheme(settings === null || settings === void 0 ? void 0 : settings.theme, settings === null || settings === void 0 ? void 0 : settings.variant);
    return instance.set(dotPath, value);
  }
  /**
   * @name        constructor
   * @type        Function
   * @constructor
   *
   * Constructor
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  constructor(theme, variant, settings) {
    super(__deepMerge({}, settings !== null && settings !== void 0 ? settings : {}));
    this._overridedConfig = {};
    this.theme = theme !== null && theme !== void 0 ? theme : SSugarConfig.get("theme.theme");
    this.variant = variant !== null && variant !== void 0 ? variant : SSugarConfig.get("theme.variant");
    if (!SSugarConfig.get(`theme.themes.${this.theme}-${this.variant}`)) {
      throw new Error(`Sorry but the requested theme "<yellow>${this.theme}-${this.variant}</yellow>" does not exists...`);
    }
  }
  /**
   * @name        themes
   * @type        String
   * @get
   *
   * Store the themes configuration
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get themes() {
    return SSugarConfig.get("theme.themes");
  }
  /**
   * @name          proxyNonExistingUiDotpath
   * @type          Function
   *
   * This method alloes you to get the actual dotpath for the passed one.
   * If you try to get "ui.range.borderRadius" and that this config does not exists in the
   * themeUi file(s), it will fallback to "ui.default.borderRadius"
   *
   * @param         {String}        dotPath         The dot path of the config you want to get
   * @return        {String}                           The actual correct dotpath
   *
   * @since         2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  proxyNonExistingUiDotpath(dotPath) {
    let value = get(this._config, dotPath);
    if (value === void 0 && dotPath.match(/^ui\.[a-zA-Z0-9]+\./)) {
      dotPath = dotPath.replace(/^ui\.[a-zA-Z0-9]+\./, "ui.default.");
    }
    return dotPath;
  }
  /**
   * @name          getSafe
   * @type          Function
   *
   * This method allows you to access a value of the current theme
   * using a dot path like "color.accent", etc...
   * This method will not throw an error if nothing's found
   *
   * @param         {String}        dotPath         The dot path of the config you want to get
   * @return        {Any}                           The value of the getted configuration
   *
   * @since         2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  getSafe(dotPath) {
    return this.get(dotPath, {
      preventThrow: true
    });
  }
  get _config() {
    this._cachedConfig = Object.assign({}, __deepMerge(SSugarConfig.get("theme.themes")[this.id], this._overridedConfig));
    return this._cachedConfig;
  }
  get(dotPath, settings = {}) {
    const finalSettings = __deepMerge({
      preventThrow: false,
      defaultFallback: true
    }, settings);
    dotPath = this.proxyNonExistingUiDotpath(dotPath);
    let value = get(this._config, dotPath);
    if (value && dotPath === "media") {
      value = this.constructor.sortMedia(value);
    }
    if (value === void 0 && !finalSettings.preventThrow) {
      throw new Error(`<red>[${this.constructor.name}]</red> Sorry but the requested "<yellow>${this.id}</yellow>" theme config "<cyan>${dotPath}</cyan>" does not exists...`);
    }
    return value;
  }
  /**
   * @name            getOverridedConfig
   * @type            any
   *
   * This method allows you to get the overrided config of the current theme.
   * These configs are the ones that are overrided by the use of the `set` method.
   *
   * @return         {Any}                           The overrided config of the current theme
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  getOverridedConfig() {
    return this._overridedConfig;
  }
  /**
   * @name            emitSavedEvent
   * @type            Function
   *
   * This method simply emit a "saved" event on the theme instance with details like the overrifed config.
   *
   * @return      {STheme}                        The current theme instance
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  emitSavedEvent() {
    this.emit("saved", {
      theme: this.theme,
      variant: this.variant,
      overridedConfig: Object.assign({}, this._overridedConfig)
    });
    return this;
  }
  /**
   * @name            hash
   * @type            String
   *
   * This hash accessor gives you access to the actual theme configuration hash.
   * You can specify a dot path to get the hash of a sub configuration
   *
   * @param           {String}            [dotPath='']            The dot path of the config you want to hash
   * @return          {String}                                    The generated hash for this config
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  hash(dotPath = "") {
    const config2 = this.get(dotPath);
    return objectHash(config2);
  }
  /**
   * @name        themesConfig
   * @type        ISThemesConfig
   *
   * Get access to the themes configuration
   *
   * @return      ISThemesConfig        The themes configuration
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  themesConfig() {
    return SSugarConfig.get("theme");
  }
  /**
   * @name            set
   * @type            Function
   *
   * This method allows you to set a value of the current theme.
   * Specify the value you want to set using the dotPath syntax like "color.accent.color", etc...
   *
   * @param       {String}        dotPath           The dot path of the config you want to set
   * @param       {any}           value               The value you want to set
   * @return      {STheme}                        The current theme instance
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  set(dotPath, value) {
    __set(this._overridedConfig, dotPath, value);
    this.emit("update", {
      dotPath,
      value
    });
    return this;
  }
  /**
   * @name            restore
   * @type            Function
   *
   * This method allows you to restore some configs by merging the passed ones with the overrided configs.
   *
   * @param       {any}           configs             The configs you want to restore
   * @return      {STheme}                        The current theme instance
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  restore(configs) {
    this._overridedConfig = __deepMerge(this._overridedConfig, configs !== null && configs !== void 0 ? configs : {});
    this.emit("restored", {
      overridedConfigs: Object.assign({}, this._overridedConfig)
    });
    return this;
  }
  /**
   * @name            clear
   * @type            Function
   *
   * This method allows you to clear the overrided configs and restore the default ones.
   *
   * @return      {STheme}                        The current theme instance
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  clear() {
    this._overridedConfig = {};
    return this;
  }
  /**
   * @name        baseColors
   * @type        Function
   *
   * This function returns a simple object with the base colors and their value
   * from the theme config.
   *
   * @return      {Record<string, ISThemeColor>}          The simple base colors map object
   *
   * @since     2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  baseColors() {
    const map2 = {};
    for (let [colorName2, colorValue] of Object.entries(this.get("color"))) {
      const c = new SColor(colorValue);
      map2[colorName2] = {
        color: colorValue,
        variable: `--${__dashCase(`s-color-${colorName2}`)}`,
        r: c.r,
        g: c.g,
        b: c.b,
        h: c.h,
        s: c.s,
        l: c.l,
        a: c.a
      };
    }
    return map2;
  }
  /**
   * @name        resolveFontSize
   * @type        Function
   *
   * This method allows you to get back the actual final font-size value of the passed one
   *
   * @param       {any}           size        The size you want to resolve
   * @return      {any}                       The final resolved size
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  resolveFontSize(size) {
    const defaultSize = this.get("font.size.default");
    const registeredValue = this.getSafe(`font.size.${size}`);
    if (registeredValue !== void 0) {
      if (typeof registeredValue === "number") {
        return `${defaultSize * registeredValue}px`;
      }
    } else if (typeof size === "number") {
      return `${defaultSize * size}`;
    }
    return registeredValue !== null && registeredValue !== void 0 ? registeredValue : size;
  }
  /**
   * @name        resolvePadding
   * @type        Function
   *
   * This method allows you to get back the actual final padding value of the passed one
   *
   * @param       {any}           size        The size you want to resolve
   * @return      {any}                       The final resolved size
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  resolvePadding(size) {
    const defaultSize = this.get("padding.default");
    const registeredValue = this.getSafe(`padding.${size}`);
    if (registeredValue !== void 0) {
      if (typeof registeredValue === "number") {
        return `${defaultSize * registeredValue}px`;
      }
    } else if (typeof size === "number") {
      return `${defaultSize * size}px`;
    }
    return registeredValue !== null && registeredValue !== void 0 ? registeredValue : size;
  }
  /**
   * @name        resolveMargin
   * @type        Function
   *
   * This method allows you to get back the actual final margin value of the passed one
   *
   * @param       {any}           size        The size you want to resolve
   * @return      {any}                       The final resolved size
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  resolveMargin(size) {
    const defaultSize = this.get("margin.default");
    const registeredValue = this.getSafe(`margin.${size}`);
    if (registeredValue !== void 0) {
      if (typeof registeredValue === "number") {
        return `${defaultSize * registeredValue}px`;
      }
    } else if (typeof size === "number") {
      return `${defaultSize * size}px`;
    }
    return registeredValue !== null && registeredValue !== void 0 ? registeredValue : size;
  }
  /**
   * @name        resolveBorderRadius
   * @type        Function
   *
   * This method allows you to get back the actual final border-radius value of the passed one
   *
   * @param       {any}           size        The size you want to resolve
   * @return      {any}                       The final resolved size
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  resolveBorderRadius(size) {
    const defaultSize = this.get("border.radius.default");
    const registeredValue = this.getSafe(`border.radius.${size}`);
    if (registeredValue !== void 0) {
      if (typeof registeredValue === "number") {
        return `${defaultSize * registeredValue}px`;
      }
    } else if (typeof size === "number") {
      return `${defaultSize * size}px`;
    }
    return registeredValue !== null && registeredValue !== void 0 ? registeredValue : size;
  }
  /**
   * @name        resolveBorderWidth
   * @type        Function
   *
   * This method allows you to get back the actual final border-radius value of the passed one
   *
   * @param       {any}           size        The size you want to resolve
   * @return      {any}                       The final resolved size
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  resolveBorderWidth(size) {
    const defaultSize = this.get("border.width.default");
    const registeredValue = this.getSafe(`border.width.${size}`);
    if (registeredValue !== void 0) {
      if (typeof registeredValue === "number") {
        return `${defaultSize * registeredValue}px`;
      }
    } else if (typeof size === "number") {
      return `${defaultSize * size}px`;
    }
    return registeredValue !== null && registeredValue !== void 0 ? registeredValue : size;
  }
  /**
   * @name        resolveColor
   * @type        Function
   *
   * This method allows you to get back the actual final value of a color with
   * his shade and modifier.
   * You can get back either a css variable or the actual color value by specifying
   * the "settings.return" setting.
   *
   * @param       {String}            color       The color you want to resolve
   * @param       {String}            [shade=null]      The color shade you want
   * @param       {String}            [modifier=null]     The modifier you want to apply. Can be something like "--darken 30%", etc...
   * @param       {ISThemeColorResolveColorSettings}      [settings={}]           Some settings
   * @return      {any}                       The final resolved color
   *
   * @setting         {'var'|'value'}         [return='value']        The return format you want
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  resolveColor(color, shade, modifier, settings) {
    var _a2, _b2;
    if (color.match(/^(hsla?|rgba?|hsv)\(/))
      return color;
    if (color.match(/^var\(--/))
      return color;
    const finalSettings = Object.assign({ return: "value" }, settings !== null && settings !== void 0 ? settings : {});
    let colorName2 = color;
    let shadeName = shade !== null && shade !== void 0 ? shade : "";
    let colorModifier = modifier !== null && modifier !== void 0 ? modifier : "";
    if (shadeName.match(/^--[a-zA-Z]+/)) {
      colorModifier = shadeName;
      shadeName = void 0;
    }
    let modifierParams = {};
    if (colorModifier) {
      modifierParams = shadesNameInterface.apply(colorModifier);
    }
    let finalValue;
    let colorInstance;
    if (__isColor(colorName2)) {
      colorInstance = new SColor(colorName2);
      if (colorModifier) {
        colorInstance.apply(colorModifier);
      }
    } else {
      const colorValue = (_a2 = this.getSafe(`color.${color}`)) !== null && _a2 !== void 0 ? _a2 : color;
      if (!shade && !modifier) {
        finalValue = colorValue;
      }
      colorInstance = new SColor(colorValue);
      if (shade) {
        let finalSchema = shade;
        if (typeof shade === "string") {
          finalSchema = this.getSafe(`shades.${shade}.color.${color}`);
          if (!finalSchema) {
            finalSchema = this.getSafe(`shades.${shade}`);
          }
        }
        if (finalSchema) {
          colorInstance = colorInstance.apply(finalSchema);
        }
      }
      if (modifier) {
        colorInstance = colorInstance.apply(modifier);
      }
    }
    switch (finalSettings.return) {
      case "object":
        finalValue = colorInstance.toObject();
        break;
      case "var":
        const colorVar = `--s-color-${colorName2}`;
        let shadeNameVar = `s-color-${colorName2}`;
        if (shadeName) {
          shadeNameVar += `-${__dashCase(shadeName)}`;
        }
        shadeNameVar = "--" + shadeNameVar.replace(/-{2,999}/gm, "-");
        finalValue = colorVar;
        const hParts = [
          `var(${colorVar}-h, 0)`,
          `var(${shadeNameVar}-spin ,${(_b2 = modifierParams.spin) !== null && _b2 !== void 0 ? _b2 : 0})`
        ];
        const sParts = [`var(${colorVar}-s, 0)`];
        if (shadeName) {
          sParts.push(`var(${shadeNameVar}-saturation-offset, 0)`);
        }
        let saturationOffset = modifierParams.saturate ? modifierParams.saturate : modifierParams.desaturate ? modifierParams.desaturate * -1 : void 0;
        if (saturationOffset !== void 0) {
          sParts.push(saturationOffset);
        }
        const lParts = [`var(${colorVar}-l, 0)`];
        if (shadeName) {
          lParts.push(`var(${shadeNameVar}-lightness-offset, 0)`);
        }
        let lightnessOffset = modifierParams.lighten ? modifierParams.lighten : modifierParams.darken ? modifierParams.darken * -1 : void 0;
        if (lightnessOffset !== void 0) {
          lParts.push(lightnessOffset);
        }
        let alpha = modifierParams.alpha !== void 0 ? modifierParams.alpha : 1;
        finalValue = `hsla(
                calc(
                    ${hParts.join(" + ")}
                ),
                calc(
                    (${sParts.join(" + ")}) * 1%
                ),
                calc(
                    (${lParts.join(" + ")}) * 1%
                ),
                ${modifierParams.alpha !== void 0 ? alpha : `var(${shadeNameVar}-a, 1)`}
                )`;
        finalValue = finalValue.replace(/(\n|\s{2,99999999})/gm, "").replace(/\t/gm, " ").replace(/\s?\+\s?/gm, " + ").replace(/\)\-\s?/gm, ") - ").replace(/\s?\*\s?/gm, " * ").replace(/\s?\/\s?/gm, " / ");
        break;
      case "value":
      default:
        finalValue = colorInstance.toString();
        break;
    }
    return finalValue;
  }
  /**
   * @name        loopOnColors
   * @type        Function
   * @async
   *
   * This utility function allows you to loop quickly and efficiently on
   * theme colors and their's modifiers defined
   *
   * @param       {Function}      callback            Specify the callback that will be called for each color with an object containing these properties:
   * - name       {String}        The name of the color like "accent", "complementary", etc...
   * - shade    {String}        The name of the variant like "background", "surface", etc...
   * - value      {ISThemeColor | ISThemeColorModifiers}        The actual color object
   *
   * @since             2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  loopOnColors(callback) {
    return __awaiter$j(this, void 0, void 0, function* () {
      const colorsObj = this.get("color"), shadessObj = this.get("shades");
      for (let [colorName2, colorValue] of Object.entries(colorsObj)) {
        const c = new SColor(colorValue);
        callback({
          name: colorName2,
          shade: "",
          // @ts-ignore
          value: {
            color: colorValue,
            variable: `--${__dashCase(`s-color-${colorName2}`)}`,
            r: c.r,
            g: c.g,
            b: c.b,
            h: c.h,
            s: c.s,
            l: c.l,
            a: c.a
          }
        });
        for (let [shadeName, shadeObj] of Object.entries(shadessObj)) {
          const newColor = c.apply(shadeObj, true);
          callback({
            name: colorName2,
            shade: shadeName,
            shadeDash: __dashCase(shadeName),
            value: Object.assign(Object.assign({ variable: `--${__dashCase(`s-color-${colorName2}-${shadeName}`)}` }, shadeObj), { r: newColor.r, g: newColor.g, b: newColor.b, h: newColor.h, s: newColor.s, l: newColor.l, a: newColor.a })
          });
          if (shadeObj.color) {
            for (let [
              shadesColorName,
              shadesObj
              // @ts-ignore
            ] of Object.entries(shadeObj.color)) {
              if (shadesColorName !== colorName2)
                continue;
              const newColor2 = c.apply(shadesObj, true);
              callback({
                name: shadesColorName,
                shade: shadeName,
                value: Object.assign(Object.assign({ variable: `--${__dashCase(`s-color-${shadesColorName}-${shadeName}`)}` }, shadesObj), { r: newColor2.r, g: newColor2.g, b: newColor2.b, h: newColor2.h, s: newColor2.s, l: newColor2.l, a: newColor2.a })
              });
            }
          }
        }
      }
      return true;
    });
  }
}
SThemeBase._instanciatedThemes = {};
window._console = {};
["log", "warn", "error", "success"].forEach((key) => {
  window._console[key] = console[key];
});
class STheme extends SThemeBase {
  /**
   * @name      theme
   * @type      String
   * @static
   * @get
   *
   * Store the current theme applied from the html tag context or from the config
   *
   * @since     2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static get theme() {
    var _a2;
    const themeAttr = (_a2 = document.querySelector("html")) === null || _a2 === void 0 ? void 0 : _a2.getAttribute("theme");
    if (!themeAttr) {
      return SFrontspec.get("theme.theme");
    }
    return themeAttr.split("-")[0];
  }
  /**
   * @name      variant
   * @type      String
   * @static
   * @get
   *
   * Store the current variant applied from the html tag context or from the config
   *
   * @since     2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static get variant() {
    var _a2;
    const themeAttr = (_a2 = document.querySelector("html")) === null || _a2 === void 0 ? void 0 : _a2.getAttribute("theme");
    if (!themeAttr) {
      return SFrontspec.get("theme.variant");
    }
    return themeAttr.split("-")[1];
  }
  static get cssSettings() {
    if (this._cssSettings) {
      return this._cssSettings;
    }
    const style = window.getComputedStyle(document.body, ":after");
    let settings;
    try {
      settings = JSON.parse(JSON.parse(style.content.toString()));
    } catch (e) {
    }
    this._cssSettings = settings;
    return this._cssSettings;
  }
  /**
   * @name            setTheme
   * @type            Function
   * @static
   *
   * This method allows you to set the current applied theme and get back an STheme instance
   *
   * @param               {String}            theme           The theme name to apply
   * @param               {String}            variant         The theme variant to apply
   * @param               {HTMLElement}       [$context=document.querySelector('html')]            The context element on which to apply the theme
   * @return          {STheme}                                    The STheme instance that represent the current applied theme
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static setTheme(theme, variant, $context = document.querySelector("html")) {
    STheme.applyTheme(theme, variant, $context);
    localStorage.setItem("s-theme", JSON.stringify({
      theme,
      variant
    }));
    const currentTheme = this.getCurrentTheme($context);
    if (variant) {
      currentTheme.state.variant = variant;
    }
    currentTheme.save();
    document.dispatchEvent(new CustomEvent("s-theme.change", {
      detail: {
        theme: currentTheme
      }
    }));
    return currentTheme;
  }
  /**
   * @name            applyTheme
   * @type            Function
   * @static
   *
   * This method allows you to apply a theme on a particular $context HTMLElement
   *
   * @param               {String}            theme           The theme name to apply
   * @param               {String}            variant         The theme variant to apply
   * @param               {HTMLElement}       [$context=document.querySelector('html')]            The context element on which to apply the theme
   * @return          {STheme}                                    The STheme instance that represent the current applied theme
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static applyTheme(theme, variant, $context = document.querySelector("html")) {
    __fastdom.mutate(() => {
      __clearTransmations(document.querySelector("html"), {
        timeout: 100
      });
      if (theme && variant) {
        $context.setAttribute("theme", `${theme}-${variant}`);
      } else if (theme) {
        $context.setAttribute("theme", `${theme}-${SFrontspec.get("theme.variant")}`);
      } else if (variant) {
        $context.setAttribute("theme", `${SFrontspec.get("theme.theme")}-${variant}`);
      }
    });
  }
  /**
   * @name            preferDark
   * @type            Function
   * @static
   *
   * This method just check if the user prefer the dark mode or not.
   *
   * @return      {Boolean}               true if prefer dark mode, false if not
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static preferDark() {
    return window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
  }
  /**
   * @name            setThemeVariant
   * @type            Function
   * @static
   *
   * This method allows you to set the current applied theme variant and get back an STheme instance
   *
   * @param               {String}            variant         The theme variant to apply
   * @param               {HTMLElement}       [$context=document.querySelector('html')]            The context element on which to apply the theme
   * @return          {STheme}                                    The STheme instance that represent the current applied theme
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static setThemeVariant(variant, $context = document.querySelector("html")) {
    return this.setTheme(void 0, variant, $context);
  }
  /**
   * @name            init
   * @type            Function
   * @static
   *
   * This method allows you to init the your STheme instance, restore savec updated if their some, etc...
   *
   * @return          {STheme}                                    The STheme instance that represent the current applied theme
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static init(settings) {
    const finalSettings = Object.assign({ $context: document.querySelector("html"), theme: void 0, variant: void 0 }, settings !== null && settings !== void 0 ? settings : {});
    let themeInstance;
    let savedTheme = {};
    try {
      savedTheme = JSON.parse(localStorage.getItem("s-theme"));
    } catch (e) {
    }
    if (savedTheme === null || savedTheme === void 0 ? void 0 : savedTheme.theme) {
      finalSettings.theme = savedTheme.theme;
    }
    if (savedTheme === null || savedTheme === void 0 ? void 0 : savedTheme.variant) {
      finalSettings.variant = savedTheme.variant;
    }
    STheme._defaultThemeMetas = {
      theme: finalSettings.theme,
      variant: finalSettings.variant
    };
    themeInstance = this.getCurrentTheme(finalSettings.$context, Object.assign({}, finalSettings));
    if (!document.env)
      document.env = {};
    if (!document.env.SUGAR)
      document.env.SUGAR = {};
    document.env.SUGAR.theme = themeInstance;
    STheme.applyTheme(themeInstance.theme, themeInstance.variant, finalSettings.$context);
    return themeInstance;
  }
  /**
   * @name            ensureIsInited
   * @type            Function
   * @static
   *
   * This method allows you to make sure the theme has been inited using the `__STheme.init()` static method.
   * If it's not the case, it will throw an error to make sure the developer knows why it's not working...
   *
   * @param           {Boolean}               [throwError=true]               Specify if you want this method to throw an error when the theme is not correctly inited
   * @return          {Boolean}                                    True if inited, false if not (and will thro)
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static ensureIsInited(throwError = true) {
    var _a2, _b2;
    if (!((_b2 = (_a2 = document.env) === null || _a2 === void 0 ? void 0 : _a2.SUGAR) === null || _b2 === void 0 ? void 0 : _b2.theme)) {
      if (throwError) {
        throw new Error(`<red>[STheme]</red> You must init your theme using the __STheme.init() static method...`);
      }
      return false;
    }
    return true;
  }
  /**
   * @name            getThemeMetas
   * @type            Function
   * @static
   *
   * This method allows you to get the theme metas like "name", "theme" and "variant" from the passed HTMLElement
   *
   * @param       {HTMLElement}       [$context=document.querySelector('html')]        The context from which to get the theme metas
   * @return      {any}                               The theme metas object containing the "name", "theme" and "variant" properties
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static getThemeMetas($context = document.querySelector("html")) {
    var _a2, _b2, _c2;
    let defaultTheme = (_a2 = STheme._defaultThemeMetas.theme) !== null && _a2 !== void 0 ? _a2 : SFrontspec.get("theme.theme"), defaultVariant = (_b2 = STheme._defaultThemeMetas.variant) !== null && _b2 !== void 0 ? _b2 : SFrontspec.get("theme.variant");
    let theme = defaultTheme, variant = defaultVariant;
    if ($context) {
      const computedStyle = getComputedStyle($context);
      const cssDefinedTheme = computedStyle.getPropertyValue("--s-theme"), cssDefinedVariant = computedStyle.getPropertyValue("--s-theme-variant");
      if (cssDefinedTheme) {
        theme = cssDefinedTheme.trim();
      }
      if (cssDefinedVariant) {
        variant = cssDefinedVariant.trim();
      }
    }
    const name2 = `${theme !== null && theme !== void 0 ? theme : defaultTheme}-${variant !== null && variant !== void 0 ? variant : defaultVariant}`;
    const metas = (_c2 = SFrontspec.get(`theme.themes.${name2}`)) !== null && _c2 !== void 0 ? _c2 : {};
    return __deepMerge({
      name: name2,
      theme: theme !== null && theme !== void 0 ? theme : defaultTheme,
      variant: variant !== null && variant !== void 0 ? variant : defaultVariant
    }, metas);
  }
  /**
   * @name            getCurrentTheme
   * @type            Function
   * @static
   *
   * This method allows you to get the current applied theme STheme instance
   *
   * @return          {STheme}                                    The STheme instance that represent the current applied theme
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  // @ts-ignore
  static getCurrentTheme($context = document.querySelector("html"), settings) {
    const themeMetas = STheme.getThemeMetas($context);
    return this.getTheme(themeMetas.theme, themeMetas.variant, settings);
  }
  /**
   * @name            applyCurrentColor
   * @type            Function
   * @static
   *
   * This static method allows you to apply a color on a particular context
   *
   * @param       {String}        color               The color name/code you want to apply
   * @param       {HTMLElement}       [$context=document.querySelector('html')]        The context on which to apply the color
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static applyCurrentColor(color, $context = document.querySelector("html")) {
    const vars = this.remapCssColor("current", color);
    for (let [key, value] of Object.entries(vars.properties)) {
      $context.style.setProperty(key, value);
    }
  }
  /**
   * @name        constructor
   * @type        Function
   * @constructor
   *
   * Constructor
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  constructor(theme, variant, settings) {
    super(theme, variant, __deepMerge({}, settings !== null && settings !== void 0 ? settings : {}));
    this.state = {
      overridedConfigs: {}
    };
    if (!SEnv2.is("production") && !__isInIframe()) {
      console.log(`<cyan>[STheme]</cyan> Initializing theme <cyan>${theme}</cyan> in <cyan>${variant}</cyan> variant`);
    }
    this.restore();
    if (!SEnv2.is("production") && !__isInIframe()) {
      console.log(`<cyan>[STheme]</cyan> Theme initialized <green>successfully</green>`);
    }
  }
  /**
   * @name            setColor
   * @type            Function
   *
   * THis method allows you to set a color for the theme that represent this instance
   *
   * @param           {String}            color                   The color you want to set
   * @param           {String}            value                   The color value you want to set
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  setColor(color, value) {
    this.set(`color.${color}.color`, value);
  }
  /**
   * @name            set
   * @type            Function
   *
   * This method allows you to set a value of the current theme.
   * Specify the value you want to set using the dotPath syntax like "color.accent.color", etc...
   *
   * @param       {String}        dotPath           The dot path of the config you want to set
   * @param       {any}           value               The value you want to set
   * @return      {STheme}                        The current theme instance
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  set(dotPath, value) {
    super.set(dotPath, value);
    this.applyState();
    this.save();
    return this;
  }
  /**
   * @name            getColor
   * @type            Function
   *
   * THis method allows you to access a particular theme color in a particular context
   *
   * @param           {String}            name            The color name you want to get
   * @param           {String}            [variant=null]     The color variant you want to get
   * @param           {HTMLElement}       [$context=document.querySelector('html')]        The context in which to get the color
   * @return          {SColor}                                    An SColor instance that you can make use of
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  getColor(name2, variant, $context = document.body) {
    const $elm = document.createElement("p");
    $elm.classList.add(`s-bc-${name2}${variant ? `-${variant}` : ""}`);
    const $wrapper = document.createElement("div");
    $wrapper.setAttribute("hidden", "true");
    $wrapper.setAttribute("theme", `${this.theme}-${this.variant}`);
    $wrapper.appendChild($elm);
    $context.appendChild($wrapper);
    const style = getComputedStyle($elm);
    const color = new SColor(style.backgroundColor);
    $wrapper.remove();
    return color;
  }
  /**
   * @name            isDarkMode
   * @type            Function
   *
   * This method returns true if the theme variant is dark, false if not
   *
   * @return      {Boolean}               true if variant is dark, false otherwise
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  isDark() {
    return this.variant === "dark";
  }
  /**
   * @name            applyState
   * @type            Function
   *
   * This method allows you to apply the overrided configs on your dom context.
   *
   * @param       {HTMLElement}       $context       The dom context on which to apply the overrided configs
   * @return      {STheme}              The current instance
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  applyState($context = document.body) {
    const properties2 = SThemeBase.jsConfigObjectToCssProperties(this.getOverridedConfig());
    this._applyOverridedConfigs(properties2, $context);
    return this;
  }
  /**
   * Apply the overrided configs from the state
   */
  _applyOverridedConfigs(properties2, $context = document.body) {
    if (!$context._sThemeOverridedConfigs) {
      $context._sThemeOverridedConfigs = {};
    }
    if (!$context._sThemeOverridedConfigs[this.id]) {
      $context._sThemeOverridedConfigs[this.id] = document.createElement("style");
      $context._sThemeOverridedConfigs[this.id].setAttribute("id", this.id);
      $context.appendChild($context._sThemeOverridedConfigs[this.id]);
    }
    let selector = `[theme="${this.theme}-${this.variant}"]`;
    if ($context === document.body) {
      selector += " body";
    }
    $context._sThemeOverridedConfigs[this.id].innerHTML = `
            ${selector} {
                ${properties2.join("\n")}
            }
        `;
  }
  save() {
    clearTimeout(this._saveTimeout);
    this._saveTimeout = setTimeout(() => {
      this.state.overridedConfigs = this._overridedConfig;
      console.log("save", this.state);
      localStorage.setItem(`s-theme-${this.theme}`, JSON.stringify(this.state));
      this.emitSavedEvent();
    }, 500);
    return this;
  }
  /**
   * @name            restore
   * @type            Function
   *
   * This method allows you to restore locally the current theme with the changes applied using the `set` method.
   *
   * @return      {STheme}                                The current theme instance
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  restore() {
    var _a2;
    let savedState = {};
    try {
      savedState = JSON.parse(
        // @ts-ignore
        (_a2 = localStorage.getItem(`s-theme-${this.theme}`)) !== null && _a2 !== void 0 ? _a2 : "{}"
      );
      this.state = savedState !== null && savedState !== void 0 ? savedState : {};
    } catch (e) {
      savedState = {};
    }
    super.restore(savedState.overridedConfigs);
    this.applyState();
    return this;
  }
  /**
   * @name            clear
   * @type            Function
   *
   * This method allows you to clear locally the current theme with the changes applied using the `set` method.
   *
   * @return      {STheme}                                The current theme instance
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  clear() {
    localStorage.removeItem(`s-theme-${this.theme}`);
    super.clear();
    this.state = {};
    this.applyState();
    this.constructor.setTheme();
    return this;
  }
}
STheme._defaultThemeMetas = {};
var _a$5;
if ((_a$5 = import.meta) === null || _a$5 === void 0 ? void 0 : _a$5.hot) {
  (void 0).on("sugar.update.css", (data2) => {
    var _a2, _b2;
    (_a2 = console.verbose) === null || _a2 === void 0 ? void 0 : _a2.call(console, `[SFront] Reloading css "${(_b2 = data2.srcRelPath) !== null && _b2 !== void 0 ? _b2 : data2}"`);
    reloadStylesheets();
  });
}
class SFront extends SClass {
  /**
   * @name            init
   * @type            Function
   * @static
   *
   * This method allows you to init the your SFront instance, restore savec updated if their some, etc...
   *
   * @return          {SFront}                                    The SFront instance that represent the current applied front
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static init(settings) {
    const finalSettings = Object.assign({ id: "default", lod: {}, classmap: {}, wireframe: {}, legal: {}, partytown: {}, theme: {} }, settings !== null && settings !== void 0 ? settings : {});
    let frontInstance = new this(finalSettings);
    if (!document.env)
      document.env = {};
    if (!document.env.SUGAR)
      document.env.SUGAR = {};
    document.env.SUGAR.front = frontInstance;
    return frontInstance;
  }
  /**
   * @name            ensureIsInited
   * @type            Function
   * @static
   *
   * This method allows you to make sure the front has been inited using the `__SFront.init()` static method.
   * If it's not the case, it will throw an error to make sure the developer knows why it's not working...
   *
   * @param           {Boolean}               [throwError=true]               Specify if you want this method to throw an error when the front is not correctly inited
   * @return          {Boolean}                                    True if inited, false if not (and will thro)
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static ensureIsInited(throwError = true) {
    var _a2, _b2;
    if (!((_b2 = (_a2 = document.env) === null || _a2 === void 0 ? void 0 : _a2.SUGAR) === null || _b2 === void 0 ? void 0 : _b2.front)) {
      if (throwError) {
        throw new Error(`<red>[SFront]</red> You must init your front using the __SFront.init() static method...`);
      }
      return false;
    }
    return true;
  }
  /**
   * @name        instance
   * @type        SFront
   * @static
   *
   * Access the default inited instance of the SFront class
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  static get instance() {
    return this._defaultInstance;
  }
  /**
   * @name        constructor
   * @type        Function
   * @constructor
   *
   * Constructor
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  constructor(settings) {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
    SLog.filter((log) => {
      if (settings.logs)
        return true;
      if (settings.logs === false)
        return false;
      if (__isInIframe() && ["log", "verbose"].includes(log.type))
        return false;
      return true;
    });
    new SStdio("default", new SStdioConsoleSource(), new SStdioBasicAdapter());
    if (!SEnv2.is("production") && !__isInIframe()) {
      const color = SEnv2.env.ENV === "production" ? "red" : SEnv2.env.ENV === "staging" ? "cyan" : "green";
      console.log(`<yellow>[SFront]</yellow> Current environment is "<${color}>${SEnv2.env.ENV}</${color}>"`);
      if ((_a2 = document.env) === null || _a2 === void 0 ? void 0 : _a2.PACKAGE) {
        console.log(`<yellow>[SFront]</yellow> Project "<cyan>${document.env.PACKAGE.name}</cyan>" in version "<yellow>${document.env.PACKAGE.version}</yellow>"`);
      }
      if ((_b2 = document.env) === null || _b2 === void 0 ? void 0 : _b2.CLASSMAP) {
        console.log(`<yellow>[SFront]</yellow> Using <yellow>classmap</yellow>"`);
      }
    }
    let frontspec;
    if ((settings === null || settings === void 0 ? void 0 : settings.frontspec) instanceof SFrontspec) {
      frontspec = settings === null || settings === void 0 ? void 0 : settings.frontspec;
    } else {
      frontspec = SFrontspec.init(settings === null || settings === void 0 ? void 0 : settings.frontspec);
    }
    let classmap;
    if (settings.classmap instanceof SClassmap) {
      classmap = settings.classmap;
    } else if (frontspec.get("classmap.enabled")) {
      classmap = SClassmap.init(settings.classmap);
    }
    let theme;
    if ((settings === null || settings === void 0 ? void 0 : settings.theme) instanceof STheme) {
      theme = settings === null || settings === void 0 ? void 0 : settings.theme;
    } else {
      theme = STheme.init(settings === null || settings === void 0 ? void 0 : settings.theme);
    }
    super(__deepMerge({
      id: "default",
      google: (_c2 = frontspec.get("google")) !== null && _c2 !== void 0 ? _c2 : {},
      partytown: (_d2 = frontspec.get("partytown")) !== null && _d2 !== void 0 ? _d2 : {},
      classmap: (_e2 = frontspec.get("classmap")) !== null && _e2 !== void 0 ? _e2 : {},
      lod: Object.assign({ stylesheet: "link#global" }, (_f2 = frontspec.get("lod")) !== null && _f2 !== void 0 ? _f2 : {}),
      wireframe: {
        enabled: void 0
      },
      legal: {
        cookieName: "s-legal",
        defaultMetas: {}
      }
    }, settings !== null && settings !== void 0 ? settings : {}));
    this._originalState = {
      lod: {
        level: void 0
      },
      wireframe: {
        enabled: void 0
      }
    };
    this.state = Object.assign({}, this._originalState);
    this.legal = {
      agree: false,
      metas: {}
    };
    this.classmap = classmap;
    this.frontspec = frontspec;
    this.theme = theme;
    if (this.settings.id === "default" && !this.constructor._defaultInstance) {
      this.constructor._defaultInstance = this;
    }
    document.addEventListener("s-front.legal.agree", () => {
      if (this.isLegalAgree()) {
        this._initTracking();
      }
    });
    this.restore();
    if (this.frontspec.get("lod.enabled")) {
      this._initLod();
    }
    if (((_g2 = this.state.wireframe) === null || _g2 === void 0 ? void 0 : _g2.enabled) || this.settings.wireframe.enabled && this.state.wireframe.enabled === void 0) {
      this.setWireframe(true);
    }
    this._initTracking();
  }
  /**
   * @name      wireframe
   * @type      { active: boolean }
   *
   * Get the current wireframe state
   *
   * @since     2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get wireframe() {
    var _a2;
    return {
      enabled: ((_a2 = this.state.wireframe) === null || _a2 === void 0 ? void 0 : _a2.enabled) !== void 0 ? this.state.wireframe.enabled : this.settings.wireframe.enabled
    };
  }
  /**
   * @name            setWireframe
   * @type            Function
   *
   * This method allows you to apply the wireframe mode
   *
   * @param              {Boolean}            enabled              true if want to activate the wireframe mode, false if want to desactivate it
   * @return          {STheme}                                    The STheme instance that represent the current applied theme
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  setWireframe(enabled) {
    var _a2, _b2;
    if (((_a2 = this.state.wireframe) === null || _a2 === void 0 ? void 0 : _a2.enabled) !== enabled) {
      (_b2 = console.verbose) === null || _b2 === void 0 ? void 0 : _b2.call(console, `<yellow>[wireframe]</yellow> ${enabled ? "<green>Activate</green>" : "<red>Desactivate</red>"} the wireframe mode`);
      if (!this.state.wireframe) {
        this.state.wireframe = {};
      }
      this.state.wireframe.enabled = enabled;
      this.save();
      document.dispatchEvent(new CustomEvent("s-front.wireframe.change", {
        detail: {
          enabled,
          theme: this
        }
      }));
    }
    document.querySelector("html").classList[enabled ? "add" : "remove"]("s-wireframe");
  }
  /**
   * @name      lod
   * @type      { level: number }
   *
   * Get the current lod (level of details)
   *
   * @since     2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  get lod() {
    var _a2;
    return {
      level: ((_a2 = this.state.lod) === null || _a2 === void 0 ? void 0 : _a2.level) !== void 0 ? this.state.lod.level : this.frontspec.get("lod.defaultLevel")
    };
  }
  /**
   * @name            setLod
   * @type            Function
   *
   * This method allows you to set the level of details you want on any HTMLElement context
   *
   * @param               {String|Number}     level           The level you want to set
   * @param               {Partial<ISThemeSetLodSettings>}        Some settings to configure your action
   * @return          {STheme}                                    The STheme instance that represent the current applied theme
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  setLod(level, settings) {
    var _a2;
    const lodSettings = this.frontspec.get("lod");
    if (!(lodSettings === null || lodSettings === void 0 ? void 0 : lodSettings.enabled)) {
      return;
    }
    const finalSettings = Object.assign({ $context: document.querySelector("html") }, settings !== null && settings !== void 0 ? settings : {});
    (_a2 = console.verbose) === null || _a2 === void 0 ? void 0 : _a2.call(console, `<yellow>[lod]</yellow> Set lod (level of details) to <cyan>${level}</cyan>`);
    level = parseInt(`${level}`);
    this.state.lod.level = level;
    this.save();
    let lodStylesheets = [], $stylesheet;
    if ((lodSettings === null || lodSettings === void 0 ? void 0 : lodSettings.method) === "file") {
      lodStylesheets = Array.from(document.querySelectorAll("link[s-lod]"));
      if (lodSettings.stylesheet instanceof HTMLLinkElement) {
        $stylesheet = lodSettings.stylesheet;
      } else if (typeof lodSettings.stylesheet === "string") {
        $stylesheet = document.querySelector(lodSettings.stylesheet);
      }
      lodStylesheets.forEach(($link) => {
        const l = parseInt($link.getAttribute("s-lod"));
        if (l > level) {
          $link.remove();
        }
      });
    }
    for (let i = 0; i <= 10; i++) {
      if (i > level) {
        finalSettings.$context.classList.remove(`s-lod-${i}`);
      }
    }
    for (let i = 0; i <= level; i++) {
      finalSettings.$context.classList.add("s-lod", `s-lod-${i}`);
      if ((lodSettings === null || lodSettings === void 0 ? void 0 : lodSettings.method) === "file" && $stylesheet) {
        if (i > 0 && !lodStylesheets.filter(($link) => {
          const l = parseInt($link.getAttribute("s-lod"));
          return l === i;
        }).length) {
          const $lodLink = $stylesheet.cloneNode();
          $lodLink.setAttribute("href", $stylesheet.getAttribute("href").replace(/([a-zA-Z0-9_-]+)\.css(\?.*)?/, `lod/$1.lod-${i}.css`));
          $lodLink.setAttribute("s-lod", i);
          document.head.appendChild($lodLink);
        }
      }
    }
    document.dispatchEvent(new CustomEvent("s-front.lod.change", {
      detail: {
        level,
        theme: this
      }
    }));
  }
  get lodConfig() {
    if (!this._lodConfig) {
      this._lodConfig = this.frontspec.get("lod");
    }
    return this._lodConfig;
  }
  /**
   * This method takes care of initializing the lod (level of details) features
   * like the "botLevel", lod by speedIndex, etc...
   */
  _initLod() {
    var _a2;
    if (!SEnv2.is("production") && !__isInIframe()) {
      console.log("<yellow>[SFront]</yellow> Initializing <magenta>lod</magenta> (level of details) with these settings", this.frontspec.get("lod"));
    }
    const isCrawler = __isCrawler();
    if (isCrawler && this.lodConfig.botLevel !== void 0) {
      this.setLod(this.lodConfig.botLevel);
    }
    if (this.state.lod.level !== void 0 && this.state.lod.level !== null) {
      this.setLod(this.state.lod.level);
      return;
    }
    this.setLod(this.frontspec.lod.defaultLevel);
    if (!isCrawler && this.state.lod.level === void 0 && this.frontspec.lod.defaultLevel === void 0) {
      const speedIndex$1 = speedIndex();
      let suitedLod = 0;
      for (let [lod, lodObj] of Object.entries((_a2 = this.lodConfig.levels) !== null && _a2 !== void 0 ? _a2 : {})) {
        if (lodObj.speedIndex > speedIndex$1) {
          break;
        }
        suitedLod = parseInt(lod);
      }
      this.setLod(suitedLod);
      return;
    }
  }
  /**
   * Check if the tracking has been inited or not
   */
  _isTrackingInited() {
    return document.querySelector("script#s-front-gtm") !== null;
  }
  /**
   * Init the tracking (google, partytown, etc...)
   */
  _initTracking() {
    var _a2, _b2, _c2, _d2;
    if (!this.isLegalAgree()) {
      if (!SEnv2.is("production") && !__isInIframe()) {
        console.log(`<yellow>[SFront]</yellow> You have a <magenta>google tag manager (gtm)</magenta> setted but the <cyan>legal terms</cyan> are not agreed. Tracking <red>disabled</red>.`);
      }
      return;
    }
    if (this._isTrackingInited()) {
      if (!SEnv2.is("production") && !__isInIframe()) {
        console.log(`<yellow>[SFront]</yellow> Tracking <magenta>google tag manager</magenta> already inited.`);
      }
      return;
    }
    if ((_b2 = (_a2 = this.frontspec) === null || _a2 === void 0 ? void 0 : _a2.google) === null || _b2 === void 0 ? void 0 : _b2.gtm) {
      this._initGtm();
    }
    if ((_d2 = (_c2 = this.frontspec) === null || _c2 === void 0 ? void 0 : _c2.partytown) === null || _d2 === void 0 ? void 0 : _d2.enabled) {
      this._initPartytown();
    }
  }
  /**
   * Init google tag manager
   */
  _initGtm() {
    var _a2;
    if (!SEnv2.is("production") && !__isInIframe()) {
      console.log(`<yellow>[SFront]</yellow> Initializing tracking through the <magenta>google tag manager</magenta> with this id "<cyan>${this.frontspec.google.gtm}</cyan>"`);
    }
    const gtmScript = `(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','${this.frontspec.google.gtm}');`;
    const $script = document.createElement("script");
    $script.innerHTML = gtmScript;
    $script.setAttribute("id", "s-front-gtm");
    $script.setAttribute("type", ((_a2 = this.frontspec.partytown) === null || _a2 === void 0 ? void 0 : _a2.enabled) ? "text/partytown" : "text/javascript");
    document.head.appendChild($script);
  }
  /**
   * This method takes care of initializing the partytoen feature.
   */
  _initPartytown() {
    var _a2, _b2;
    if (!((_b2 = (_a2 = this.frontspec) === null || _a2 === void 0 ? void 0 : _a2.google) === null || _b2 === void 0 ? void 0 : _b2.gtm)) {
      if (!SEnv2.is("production") && !__isInIframe()) {
        console.log(`<yellow>[SFront]</yellow> You have enabled <magenta>partytown</magenta> but you don't have specified any "<cyan>settings.frontspec.google.gtm</cyan>" tag manager id...'`);
        return;
      }
    }
    window.partytown = this.frontspec.partytown;
    if (!SEnv2.is("production") && !__isInIframe()) {
      console.log("<yellow>[SFront]</yellow> Initializing <magenta>partytown</magenta> with these settings", this.frontspec.partytown);
    }
    const snippetText = partytownSnippet();
    const $partytownScript = document.createElement("script");
    $partytownScript.innerHTML = snippetText;
    $partytownScript.setAttribute("type", "text/javascript");
    document.body.appendChild($partytownScript);
  }
  /**
   * @name            agreeLegal
   * @type            Function
   *
   * This method alows you to agree the legal of the website (cookies, etc...)
   * It will flag the state.legal.agree to "true" and save some legals settings
   * in the state.legal.metas object
   *
   * @event       s-front.legal.agree             Dispatched when the user agree the legal terms
   * @event       s-front.legal.change             Dispatched when the user legal has been changed
   *
   * @param       {Any}           metas           Some metas to save alongside the agree flag
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  agreeLegal(metas) {
    this.legal.agree = true;
    if (metas) {
      this.legal.metas = metas;
    }
    __setCookie(this.settings.legal.cookieName, Object.assign({}, this.legal));
    document.dispatchEvent(new CustomEvent("s-front.legal.agree", {
      detail: this.legal
    }));
    document.dispatchEvent(new CustomEvent("s-front.legal.change", {
      detail: Object.assign({ prop: "agree" }, this.legal)
    }));
  }
  /**
   * @name            disagreeLegal
   * @type            Function
   *
   * This method alows you to disagree the legal of the website (cookies, etc...)
   * It will flag the state.legal.agree to "false" without touching the "metas" to keep
   * the potential user legal settings saved for next time
   *
   * @event       s-front.legal.disagree             Dispatched when the user agree the legal terms
   * @event       s-front.legal.change             Dispatched when the user legal has been changed
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  disagreeLegal() {
    this.legal.agree = false;
    __setCookie(this.settings.legal.cookieName, Object.assign({}, this.legal));
    document.dispatchEvent(new CustomEvent("s-front.legal.disagree", {
      detail: {
        front: this
      }
    }));
    document.dispatchEvent(new CustomEvent("s-front.legal.change", {
      detail: Object.assign({ prop: "agree" }, this.legal)
    }));
  }
  /**
   * @name            setLegalMetas
   * @type            Function
   *
   * This method allows you to set some legal metas.
   * Note that this will make a deepMerge of the current metas and the passed ones.
   *
   * @event       s-front.legal.change             Dispatched when the user legal has been changed
   *
   * @param       {Any}           metas           Some metas to set
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  setLegalMetas(metas) {
    this.legal.metas = __deepMerge(this.legal.metas, metas);
    __setCookie(this.settings.legal.cookieName, Object.assign({}, this.legal));
    document.dispatchEvent(new CustomEvent("s-front.legal.change", {
      detail: Object.assign({ prop: "metas" }, this.legal)
    }));
  }
  /**
   * @name            getLegalMetas
   * @type            Function
   *
   * This method allows you to get the legal saved metas
   *
   * @return      {Any}               The legal metas saved
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  getLegalMetas() {
    var _a2, _b2;
    return (_b2 = (_a2 = __getCookie(this.settings.legal.cookieName)) === null || _a2 === void 0 ? void 0 : _a2.metas) !== null && _b2 !== void 0 ? _b2 : {};
  }
  /**
   * @name            isLegalAgree
   * @type            Function
   *
   * This method allows you to check if the legal are agree or not
   *
   * @return      {Boolean}       true if agree, false if not
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  isLegalAgree() {
    var _a2;
    return (_a2 = __getCookie(this.settings.legal.cookieName)) === null || _a2 === void 0 ? void 0 : _a2.agree;
  }
  save() {
    clearTimeout(this._saveTimeout);
    this._saveTimeout = setTimeout(() => {
      localStorage.setItem(`s-front-${this.settings.id}`, JSON.stringify(this.state));
    }, 500);
  }
  /**
   * @name            restore
   * @type            Function
   *
   * This method allows you to restore locally the current front with the changes applied using the `set` method.
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  restore() {
    try {
      const savedState = JSON.parse(
        // @ts-ignore
        localStorage.getItem(`s-front-${this.settings.id}`)
      );
      this.state = savedState !== null && savedState !== void 0 ? savedState : Object.assign({}, this._originalState);
    } catch (e) {
      this.state = Object.assign({}, this._originalState);
    }
  }
  /**
   * @name            clear
   * @type            Function
   *
   * This method allows you to clear locally the current front with the changes applied using the `set` method.
   *
   * @since           2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  clear() {
    localStorage.removeItem(`s-front-${this.settings.id}`);
    this.state = Object.assign({}, this._originalState);
  }
}
var __awaiter$i = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function define$i(props, name2 = "s-activate", settings = {}) {
  var _a2;
  __querySelectorLive(`[${name2}]`, ($elm) => __awaiter$i(this, void 0, void 0, function* () {
    const define2 = yield __vitePreload(() => import("./define-933547ed.js"), true ? [] : void 0);
    define2.default(props, name2);
  }), {
    when: (_a2 = settings.when) !== null && _a2 !== void 0 ? _a2 : "nearViewport",
    firstOnly: true
  });
}
var __awaiter$h = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function define$h(props, name2 = "s-appear", settings = {}) {
  var _a2;
  __querySelectorLive(`[${name2}]`, ($elm) => __awaiter$h(this, void 0, void 0, function* () {
    const define2 = yield __vitePreload(() => import("./define-91d79f1a.js"), true ? [] : void 0);
    define2.default(props, name2);
  }), {
    when: (_a2 = settings.when) !== null && _a2 !== void 0 ? _a2 : "nearViewport",
    firstOnly: true
  });
}
var __awaiter$g = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function define$g(props, tagName = "s-clipboard-copy", settings = {}) {
  var _a2;
  __querySelectorLive(tagName, ($elm) => __awaiter$g(this, void 0, void 0, function* () {
    const define2 = yield __vitePreload(() => Promise.resolve().then(() => define$8), true ? void 0 : void 0);
    define2.default(props, tagName, settings);
  }), {
    when: (_a2 = settings.when) !== null && _a2 !== void 0 ? _a2 : "nearViewport",
    firstOnly: true
  });
}
var __awaiter$f = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function define$f(props, name2 = "s-floating", settings = {}) {
  var _a2;
  __querySelectorLive(`[${name2}]`, ($elm) => __awaiter$f(this, void 0, void 0, function* () {
    const define2 = yield __vitePreload(() => import("./define-9cd71676.js"), true ? [] : void 0);
    define2.default(props, name2);
  }), {
    when: (_a2 = settings.when) !== null && _a2 !== void 0 ? _a2 : "nearViewport",
    firstOnly: true
  });
}
var __awaiter$e = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function define$e(props, name2 = "s-form-validate", settings = {}) {
  var _a2;
  __querySelectorLive(`[${name2}]`, ($elm) => __awaiter$e(this, void 0, void 0, function* () {
    const define2 = yield __vitePreload(() => import("./define-c53347d9.js"), true ? [] : void 0);
    define2.default(props, name2);
  }), {
    when: (_a2 = settings.when) !== null && _a2 !== void 0 ? _a2 : "nearViewport",
    firstOnly: true
  });
}
var __awaiter$d = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function define$d(props, name2 = "s-inline", settings = {}) {
  var _a2;
  __querySelectorLive(`[${name2}]`, ($elm) => __awaiter$d(this, void 0, void 0, function* () {
    const define2 = yield __vitePreload(() => import("./define-2ceeeb5f.js"), true ? [] : void 0);
    define2.default(props, name2);
  }), {
    when: (_a2 = settings.when) !== null && _a2 !== void 0 ? _a2 : "nearViewport",
    firstOnly: true
  });
}
let SMedia$1 = class SMedia extends SClass {
  get defaultAction() {
    return this._media.defaultAction;
  }
  get defaultMedia() {
    var _a2;
    return (_a2 = this._media.defaultMedia) !== null && _a2 !== void 0 ? _a2 : "desktop";
  }
  get medias() {
    return Object.keys(this._media.queries);
  }
  /**
   * @name            constructor
   * @type            Function
   * @constructor
   *
   * Constructor
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  constructor(settings = {}) {
    super(__deepMerge({}, settings));
  }
  /**
   * @name            countAreas
   * @type            Function
   *
   * This method allows you to count the number of area from a layout string like "1 2 _ 3 3"
   *
   * @param               {String}    layout      The layout string you want to count areas from
   * @return              {Number}                The count of areas in the passed layout string
   *
   * @since               2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  countAreas(layout) {
    const areas = [];
    layout.split(/(\\n|\s)/).map((l) => l.trim()).filter((l) => l !== "_" && l !== "").forEach((areaId) => {
      if (!areas.includes(areaId)) {
        areas.push(areaId);
      }
    });
    return areas.length;
  }
  /**
   * @name                buildQuery
   * @type                Function
   *
   * This static method allows you to built a media query by passing args like "mobile", ">tablet", etc...
   *
   * @param               {String}    query    The media query you want to build
   * @return              {String}                The builded media query (without brackets)
   *
   * @since               2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  buildQuery(queryString, settings) {
    var _a2;
    let currentQueryList = [];
    const finalSettings = {
      method: (_a2 = settings === null || settings === void 0 ? void 0 : settings.method) !== null && _a2 !== void 0 ? _a2 : "media",
      containerName: settings === null || settings === void 0 ? void 0 : settings.containerName
    };
    const queryAr = queryString.split(/(\s|\,)/gm).map((l) => l.trim()).filter((l) => l !== "" && l !== ",");
    queryAr.forEach((query2, i) => {
      if (query2 === "and" || query2 === "or") {
        currentQueryList.push(query2);
        return;
      }
      const firstChar = query2.slice(0, 1);
      const firstTwoChar = query2.slice(0, 2);
      const lastChar = query2.slice(-1);
      let action = this._media.defaultAction;
      let mediaName = query2;
      if (lastChar === "-" || lastChar === "|")
        mediaName = mediaName.slice(0, -1);
      if (firstTwoChar === ">=" || firstTwoChar === "<=" || firstTwoChar === "==") {
        mediaName = mediaName.slice(2);
        action = firstTwoChar;
      } else if (firstChar === "<" || firstChar === ">" || firstChar === "=") {
        mediaName = mediaName.slice(1);
        action = firstChar;
      }
      let mediaQueryConfig = this._media, sortedMedia = Object.keys(this._media.queries);
      if (typeof __parse(mediaName) === "number") {
        switch (action) {
          case ">":
          case ">=":
            mediaQueryConfig = {
              minWidth: mediaName,
              maxWidth: null
            };
            break;
          case "<":
          case "<=":
            mediaQueryConfig = {
              minWidth: null,
              maxWidth: mediaName
            };
            break;
          case "=":
            mediaQueryConfig = {
              minWidth: mediaName,
              maxWidth: mediaName
            };
            break;
        }
      } else {
        mediaQueryConfig = this._media.queries[mediaName];
        if (!mediaQueryConfig)
          throw new Error(`<red>[sugarcssPlugin.media]</red> Sorry but the requested media "<yellow>${mediaName}</yellow>" does not exists in the config. Here's the available medias: ${Object.keys(this._media.queries).map((l) => `<green>${l}</green>`).join(",")}`);
      }
      const queryList = [];
      Object.keys(mediaQueryConfig).forEach((prop) => {
        const dashProp = __dashCase(prop);
        let value = mediaQueryConfig[prop];
        if (!value) {
          if (prop === "minWidth") {
            value = 0;
          } else if (prop === "maxWidth") {
            value = 99999;
          }
        }
        if (["min-width", "max-width"].indexOf(dashProp) !== -1) {
          if (action === ">") {
            if (dashProp === "max-width") {
              let argName = "min-width";
              queryList.push(`(${argName}: ${value + 1}px)`);
            }
          } else if (action === "<") {
            if (dashProp === "min-width") {
              let argName = "max-width";
              queryList.push(`(${argName}: ${value}px)`);
            }
          } else if (action === "=") {
            queryList.push(`(${dashProp}: ${value}px)`);
          } else if (action === ">=") {
            if (sortedMedia.at(-1) === mediaName) {
              return;
            }
            if (dashProp === "min-width") {
              queryList.push(`(${dashProp}: ${value}px)`);
            }
          } else if (action === "<=") {
            if (sortedMedia[0] === mediaName) {
              return;
            }
            if (dashProp === "max-width") {
              queryList.push(`(${dashProp}: ${value}px)`);
            }
          } else {
            queryList.push(`(${dashProp}: ${value}px)`);
          }
        } else {
          queryList.push(`(${dashProp}: ${value}px)`);
        }
      });
      if (lastChar === "-") {
        queryList.push("(orientation: landscape)");
      } else if (lastChar === "|") {
        queryList.push("(orientation: portrait)");
      }
      currentQueryList.push(queryList.join(" and "));
    });
    currentQueryList = currentQueryList.filter((l) => l.trim() !== "");
    if (finalSettings.method === "container") {
      return `@container ${finalSettings.containerName} ${currentQueryList.join(" ")}`;
    }
    return `@media ${currentQueryList.join(" ")}`;
  }
  /**
   * @name            layoutCss
   * @type            Function
   *
   * This function takes a layout definition like "1 2 _ 3 3" and generate the css that will handle this layout.
   * You can as well pass some informations the gap wanted, the alignement, etc...
   *
   * @param       {String|Array}         layout            The layout string defintion you want to generate the css for like "1 2 _ 3 3". It can also be an associative array like ["desktop" : "1 2", "mobile" : "1 _ 2"]
   * @param       {Array}         [settings=null]      Some settings to configure your layout generation
   * @return      {String}                         The resulting css
   *
   * @setting         {String}        [method='container']        The method to use. By default, it will use the @container query over the @media one cause it offers more possibilities like resizing the ".s-viewport" element
   * @setting         {String}        [containerName='viewport']    The container name on which the @container query will refer to.
   * @setting         {String}        [selector='#layout']       A css selector used to target the correct section/div...
   * @setting         {String}        [gap=null]                 A gap value to apply on your layout
   * @setting         {Boolean}       [gapBetween=true]           Specify if you want the gap only between the cells or all around
   * @setting         {String}        [align='stretch']           The "align-items" value for your grid layout
   * @setting         {String}        [justify='stretch']         The "justify-items" value for your grid layout
   * @setting         {Boolean}       [minify=true]             Minify the output css or not
   * @setting         {Array}         [scope=['bare','lnf','gap','align','justify']]             The scope(s) you want to generate
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  layoutCss(layout, settings) {
    const finalSettings = Object.assign({ method: "container", containerName: "viewport", selector: "#layout", gap: null, gapBetween: true, align: "stretch", justify: "stretch", minify: false, scope: ["bare", "lnf", "gap", "align", "justify"] }, settings !== null && settings !== void 0 ? settings : {});
    if (typeof layout !== "string") {
      const finalCss = [];
      let defaultAction = "<=";
      if (this._media.defaultAction) {
        defaultAction = this._media.defaultAction;
      }
      const queries = this._media.queries;
      const keys3 = Object.keys(queries);
      const orderedLayouts = {};
      keys3.forEach((media) => {
        if (layout[media]) {
          let lay = layout[media];
          if (typeof lay !== "string") {
            lay = lay.layout;
          }
          orderedLayouts[media] = lay;
        }
      });
      let i = 0;
      for (let [media, lay] of Object.entries(orderedLayouts)) {
        if (defaultAction == ">=" && i >= keys3.length - 1) {
          media = null;
        } else if (defaultAction == "<=" && i == 0) {
          media = null;
        }
        i++;
        finalCss.push(__layoutCss(lay, Object.assign(Object.assign({}, finalSettings), { media })));
      }
      return finalCss.join("\n");
    }
    if (finalSettings.media == "default") {
      finalSettings.media = null;
    }
    const areas = [];
    const colsCountByArea = [];
    const rowsCountByArea = [];
    const areasCountedByLine = [];
    const areasCountedByCol = [];
    const colsStartByArea = [];
    const rowsStartByArea = [];
    const colsEndByArea = [];
    const rowsEndByArea = [];
    const rows = layout.split(/(\\n|_)/).map((l) => l.trim()).filter((l) => l !== "_" && l !== "");
    rows.length;
    let colsCount = 0;
    rows.forEach((row) => {
      const rowsCols = row.split(" ").map((l) => l.trim());
      if (rowsCols.length > colsCount) {
        colsCount = rowsCols.length;
      }
    });
    let currentCol = 0, currentRow = 0;
    rows.forEach((row) => {
      currentRow++;
      currentCol = 0;
      const rowCols = row.split(" ").map((l) => l.trim());
      rowCols.forEach((areaId) => {
        currentCol++;
        if (!areas.includes(areaId)) {
          areas.push(areaId);
        }
        if (!areasCountedByCol[`${currentCol}-${areaId}`]) {
          areasCountedByCol[`${currentCol}-${areaId}`] = true;
          const current = colsCountByArea[areaId] ? colsCountByArea[areaId] : 0;
          colsCountByArea[areaId] = current + 1;
        }
        if (!areasCountedByLine[`${currentRow}-${areaId}`]) {
          areasCountedByLine[`${currentRow}-${areaId}`] = true;
          const current = rowsCountByArea[areaId] ? rowsCountByArea[areaId] : 0;
          rowsCountByArea[areaId] = current + 1;
        }
      });
    });
    currentCol = 0;
    currentRow = 0;
    rows.forEach((row) => {
      currentRow++;
      currentCol = 0;
      const rowCols = row.split(" ").map((l) => l.trim());
      rowCols.forEach((areaId) => {
        currentCol++;
        if (!colsStartByArea[areaId]) {
          colsStartByArea[areaId] = currentCol;
        }
        if (!rowsStartByArea[areaId]) {
          rowsStartByArea[areaId] = currentRow;
        }
        colsEndByArea[areaId] = currentCol;
        rowsEndByArea[areaId] = currentRow;
      });
    });
    const colsStatement = [];
    for (let i = 0; i < colsCount; i++) {
      if (colsCount <= 1) {
        colsStatement.push("100%");
      } else {
        colsStatement.push("1fr");
      }
    }
    const vars = [`${finalSettings.selector} {`];
    if (finalSettings.scope.includes("bare")) {
      vars.push(`display: grid;`);
      vars.push(`grid-template-columns: ${colsStatement.join(" ")};`);
      vars.push(`grid-template-rows: auto;`);
    }
    if (finalSettings.scope.includes("align")) {
      vars.push(`align-items: ${finalSettings.align};`);
    }
    if (finalSettings.scope.includes("justify")) {
      vars.push(`justify-content: ${finalSettings.justify};`);
    }
    if (finalSettings.gap && finalSettings.scope.includes("gap")) {
      vars.push(`gap: ${finalSettings.gap};`);
    }
    vars.push("}");
    if (finalSettings.scope.includes("bare")) {
      areas.forEach((areaId, i) => {
        if (areaId === "x" || areaId === "-") {
          return;
        }
        vars.push(`${finalSettings.selector} > .s-layout_area-${areaId} {
                        grid-column-start: ${colsStartByArea[areaId]};
                        grid-column-end: ${colsEndByArea[areaId] + 1};
                        grid-row-start: ${rowsStartByArea[areaId]};
                        grid-row-end: ${rowsEndByArea[areaId] + 1};
            }`);
      });
    }
    if (finalSettings.media) {
      const query2 = this.buildQuery(this._media);
      vars.unshift(`${query2} {`);
      vars.push("}");
    }
    let css2 = vars.join(finalSettings.minify ? " " : "\n");
    if (finalSettings.minify) {
      css2 = css2.replace(/\n/gm, " ").replace(/\s{2,999}/gm, " ");
    }
    return {
      css: css2,
      areas
    };
  }
  /**
   * @name            sortQueries
   * @type            Function
   *
   * This function take as input the "media" property of the `frontspec.json` file and return
   * a new object mostly the same but with the "queries" object|array sorted depending on the
   * "defaultAction" property.
   *
   * @param     {Object}      media                      The frontspec "media" object
   * @return    {Object}                                  The same object with the "queries" sorted correctly
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  sortQueries(media = null) {
    if (media == null) {
      media = this.media;
    }
    if (!media.defaultAction) {
      return media;
    }
    const queries = __sort(media.queries, (a, b) => {
      if (media.defaultAction == "<=") {
        return a.value.minWidth < b.value.minWidth ? 1 : -1;
      } else if (media.defaultAction == ">=") {
        return a.value.minWidth > b.value.minWidth ? 1 : -1;
      }
      return 0;
    });
    const sortedQueries = {};
    for (let [m, query2] of Object.entries(queries)) {
      sortedQueries[m] = query2;
    }
    media.queries = sortedQueries;
    return media;
  }
};
class SMedia2 extends SMedia$1 {
  /**
   * @name            constructor
   * @type            Function
   * @constructor
   *
   * Constructor
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  constructor(media = "frontspec", settings = {}) {
    super(__deepMerge({}, settings));
    if (media === "frontspec") {
      this._media = SFrontspec.get("media");
    } else if (media) {
      this._media = media;
    } else {
      this._media = {
        defaultAction: "<=",
        defaultMedia: "desktop",
        method: "media",
        containerName: "viewport",
        queries: {
          mobile: {
            minWidth: 0,
            maxWidth: 639
          },
          tablet: {
            minWidth: 640,
            maxWidth: 1279
          },
          desktop: {
            minWidth: 1280,
            maxWidth: 2047
          },
          wide: {
            minWidth: 2048,
            maxWidth: null
          }
        }
      };
    }
    this._media = this.sortQueries(this._media);
  }
}
function __debounce(delay, fn2) {
  let timer = null;
  return function() {
    const context = this, args = arguments;
    clearTimeout(timer);
    timer = setTimeout(function() {
      fn2.apply(context, args);
    }, delay);
  };
}
var noop = function() {
};
var _undefined$1 = noop();
var isValue$5 = function(val) {
  return val !== _undefined$1 && val !== null;
};
var isValue$4 = isValue$5;
var forEach2 = Array.prototype.forEach, create = Object.create;
var process$1 = function(src2, obj) {
  var key;
  for (key in src2)
    obj[key] = src2[key];
};
var normalizeOptions = function(opts1) {
  var result2 = create(null);
  forEach2.call(arguments, function(options) {
    if (!isValue$4(options))
      return;
    process$1(Object(options), result2);
  });
  return result2;
};
var isImplemented$6 = function() {
  var sign2 = Math.sign;
  if (typeof sign2 !== "function")
    return false;
  return sign2(10) === 1 && sign2(-20) === -1;
};
var shim$4;
var hasRequiredShim$4;
function requireShim$4() {
  if (hasRequiredShim$4)
    return shim$4;
  hasRequiredShim$4 = 1;
  shim$4 = function(value) {
    value = Number(value);
    if (isNaN(value) || value === 0)
      return value;
    return value > 0 ? 1 : -1;
  };
  return shim$4;
}
var sign$1 = isImplemented$6() ? Math.sign : requireShim$4();
var sign = sign$1, abs = Math.abs, floor = Math.floor;
var toInteger$1 = function(value) {
  if (isNaN(value))
    return 0;
  value = Number(value);
  if (value === 0 || !isFinite(value))
    return value;
  return sign(value) * floor(abs(value));
};
var toInteger = toInteger$1, max = Math.max;
var toPosInteger = function(value) {
  return max(0, toInteger(value));
};
var validCallable = function(fn2) {
  if (typeof fn2 !== "function")
    throw new TypeError(fn2 + " is not a function");
  return fn2;
};
var isValue$3 = isValue$5;
var validValue = function(value) {
  if (!isValue$3(value))
    throw new TypeError("Cannot use null or undefined");
  return value;
};
var custom = { exports: {} };
var isImplemented$5 = function() {
  var assign2 = Object.assign, obj;
  if (typeof assign2 !== "function")
    return false;
  obj = { foo: "raz" };
  assign2(obj, { bar: "dwa" }, { trzy: "trzy" });
  return obj.foo + obj.bar + obj.trzy === "razdwatrzy";
};
var isImplemented$4;
var hasRequiredIsImplemented$3;
function requireIsImplemented$3() {
  if (hasRequiredIsImplemented$3)
    return isImplemented$4;
  hasRequiredIsImplemented$3 = 1;
  isImplemented$4 = function() {
    try {
      Object.keys("primitive");
      return true;
    } catch (e) {
      return false;
    }
  };
  return isImplemented$4;
}
var shim$3;
var hasRequiredShim$3;
function requireShim$3() {
  if (hasRequiredShim$3)
    return shim$3;
  hasRequiredShim$3 = 1;
  var isValue2 = isValue$5;
  var keys3 = Object.keys;
  shim$3 = function(object) {
    return keys3(isValue2(object) ? Object(object) : object);
  };
  return shim$3;
}
var keys2;
var hasRequiredKeys;
function requireKeys() {
  if (hasRequiredKeys)
    return keys2;
  hasRequiredKeys = 1;
  keys2 = requireIsImplemented$3()() ? Object.keys : requireShim$3();
  return keys2;
}
var shim$2;
var hasRequiredShim$2;
function requireShim$2() {
  if (hasRequiredShim$2)
    return shim$2;
  hasRequiredShim$2 = 1;
  var keys3 = requireKeys(), value = validValue, max2 = Math.max;
  shim$2 = function(dest, src2) {
    var error2, i, length = max2(arguments.length, 2), assign2;
    dest = Object(value(dest));
    assign2 = function(key) {
      try {
        dest[key] = src2[key];
      } catch (e) {
        if (!error2)
          error2 = e;
      }
    };
    for (i = 1; i < length; ++i) {
      src2 = arguments[i];
      keys3(src2).forEach(assign2);
    }
    if (error2 !== void 0)
      throw error2;
    return dest;
  };
  return shim$2;
}
var assign$1 = isImplemented$5() ? Object.assign : requireShim$2();
var isValue$2 = isValue$5;
var map = { function: true, object: true };
var isObject$1 = function(value) {
  return isValue$2(value) && map[typeof value] || false;
};
(function(module) {
  var assign2 = assign$1, isObject3 = isObject$1, isValue2 = isValue$5, captureStackTrace = Error.captureStackTrace;
  module.exports = function(message) {
    var err = new Error(message), code3 = arguments[1], ext2 = arguments[2];
    if (!isValue2(ext2)) {
      if (isObject3(code3)) {
        ext2 = code3;
        code3 = null;
      }
    }
    if (isValue2(ext2))
      assign2(err, ext2);
    if (isValue2(code3))
      err.code = code3;
    if (captureStackTrace)
      captureStackTrace(err, module.exports);
    return err;
  };
})(custom);
var test = function(arg1, arg2) {
  return arg2;
};
try {
  Object.defineProperty(test, "length", {
    configurable: true,
    writable: false,
    enumerable: false,
    value: 1
  });
} catch (ignore2) {
}
if (test.length === 1)
  ;
var d$2 = { exports: {} };
var _undefined = void 0;
var is$5 = function(value) {
  return value !== _undefined && value !== null;
};
var isValue$1 = is$5;
var possibleTypes = {
  "object": true,
  "function": true,
  "undefined": true
  /* document.all */
};
var is$4 = function(value) {
  if (!isValue$1(value))
    return false;
  return hasOwnProperty.call(possibleTypes, typeof value);
};
var isObject2 = is$4;
var is$3 = function(value) {
  if (!isObject2(value))
    return false;
  try {
    if (!value.constructor)
      return false;
    return value.constructor.prototype === value;
  } catch (error2) {
    return false;
  }
};
var isPrototype = is$3;
var is$2 = function(value) {
  if (typeof value !== "function")
    return false;
  if (!hasOwnProperty.call(value, "length"))
    return false;
  try {
    if (typeof value.length !== "number")
      return false;
    if (typeof value.call !== "function")
      return false;
    if (typeof value.apply !== "function")
      return false;
  } catch (error2) {
    return false;
  }
  return !isPrototype(value);
};
var isFunction$1 = is$2;
var classRe = /^\s*class[\s{/}]/, functionToString = Function.prototype.toString;
var is$1 = function(value) {
  if (!isFunction$1(value))
    return false;
  if (classRe.test(functionToString.call(value)))
    return false;
  return true;
};
var str = "razdwatrzy";
var isImplemented$3 = function() {
  if (typeof str.contains !== "function")
    return false;
  return str.contains("dwa") === true && str.contains("foo") === false;
};
var shim$1;
var hasRequiredShim$1;
function requireShim$1() {
  if (hasRequiredShim$1)
    return shim$1;
  hasRequiredShim$1 = 1;
  var indexOf = String.prototype.indexOf;
  shim$1 = function(searchString) {
    return indexOf.call(this, searchString, arguments[1]) > -1;
  };
  return shim$1;
}
var contains$1 = isImplemented$3() ? String.prototype.contains : requireShim$1();
var isValue = is$5, isPlainFunction = is$1, assign = assign$1, normalizeOpts = normalizeOptions, contains = contains$1;
var d$1 = d$2.exports = function(dscr, value) {
  var c, e, w, options, desc;
  if (arguments.length < 2 || typeof dscr !== "string") {
    options = value;
    value = dscr;
    dscr = null;
  } else {
    options = arguments[2];
  }
  if (isValue(dscr)) {
    c = contains.call(dscr, "c");
    e = contains.call(dscr, "e");
    w = contains.call(dscr, "w");
  } else {
    c = w = true;
    e = false;
  }
  desc = { value, configurable: c, enumerable: e, writable: w };
  return !options ? desc : assign(normalizeOpts(options), desc);
};
d$1.gs = function(dscr, get2, set2) {
  var c, e, options, desc;
  if (typeof dscr !== "string") {
    options = set2;
    set2 = get2;
    get2 = dscr;
    dscr = null;
  } else {
    options = arguments[3];
  }
  if (!isValue(get2)) {
    get2 = void 0;
  } else if (!isPlainFunction(get2)) {
    options = get2;
    get2 = set2 = void 0;
  } else if (!isValue(set2)) {
    set2 = void 0;
  } else if (!isPlainFunction(set2)) {
    options = set2;
    set2 = void 0;
  }
  if (isValue(dscr)) {
    c = contains.call(dscr, "c");
    e = contains.call(dscr, "e");
  } else {
    c = true;
    e = false;
  }
  desc = { get: get2, set: set2, configurable: c, enumerable: e };
  return !options ? desc : assign(normalizeOpts(options), desc);
};
var dExports = d$2.exports;
var eventEmitter = { exports: {} };
(function(module, exports) {
  var d2 = dExports, callable = validCallable, apply = Function.prototype.apply, call = Function.prototype.call, create2 = Object.create, defineProperty3 = Object.defineProperty, defineProperties2 = Object.defineProperties, hasOwnProperty2 = Object.prototype.hasOwnProperty, descriptor2 = { configurable: true, enumerable: false, writable: true }, on, once, off, emit, methods, descriptors, base;
  on = function(type, listener) {
    var data2;
    callable(listener);
    if (!hasOwnProperty2.call(this, "__ee__")) {
      data2 = descriptor2.value = create2(null);
      defineProperty3(this, "__ee__", descriptor2);
      descriptor2.value = null;
    } else {
      data2 = this.__ee__;
    }
    if (!data2[type])
      data2[type] = listener;
    else if (typeof data2[type] === "object")
      data2[type].push(listener);
    else
      data2[type] = [data2[type], listener];
    return this;
  };
  once = function(type, listener) {
    var once2, self2;
    callable(listener);
    self2 = this;
    on.call(this, type, once2 = function() {
      off.call(self2, type, once2);
      apply.call(listener, this, arguments);
    });
    once2.__eeOnceListener__ = listener;
    return this;
  };
  off = function(type, listener) {
    var data2, listeners, candidate, i;
    callable(listener);
    if (!hasOwnProperty2.call(this, "__ee__"))
      return this;
    data2 = this.__ee__;
    if (!data2[type])
      return this;
    listeners = data2[type];
    if (typeof listeners === "object") {
      for (i = 0; candidate = listeners[i]; ++i) {
        if (candidate === listener || candidate.__eeOnceListener__ === listener) {
          if (listeners.length === 2)
            data2[type] = listeners[i ? 0 : 1];
          else
            listeners.splice(i, 1);
        }
      }
    } else {
      if (listeners === listener || listeners.__eeOnceListener__ === listener) {
        delete data2[type];
      }
    }
    return this;
  };
  emit = function(type) {
    var i, l, listener, listeners, args;
    if (!hasOwnProperty2.call(this, "__ee__"))
      return;
    listeners = this.__ee__[type];
    if (!listeners)
      return;
    if (typeof listeners === "object") {
      l = arguments.length;
      args = new Array(l - 1);
      for (i = 1; i < l; ++i)
        args[i - 1] = arguments[i];
      listeners = listeners.slice();
      for (i = 0; listener = listeners[i]; ++i) {
        apply.call(listener, this, args);
      }
    } else {
      switch (arguments.length) {
        case 1:
          call.call(listeners, this);
          break;
        case 2:
          call.call(listeners, this, arguments[1]);
          break;
        case 3:
          call.call(listeners, this, arguments[1], arguments[2]);
          break;
        default:
          l = arguments.length;
          args = new Array(l - 1);
          for (i = 1; i < l; ++i) {
            args[i - 1] = arguments[i];
          }
          apply.call(listeners, this, args);
      }
    }
  };
  methods = {
    on,
    once,
    off,
    emit
  };
  descriptors = {
    on: d2(on),
    once: d2(once),
    off: d2(off),
    emit: d2(emit)
  };
  base = defineProperties2({}, descriptors);
  module.exports = exports = function(o) {
    return o == null ? create2(base) : defineProperties2(Object(o), descriptors);
  };
  exports.methods = methods;
})(eventEmitter, eventEmitter.exports);
var eventEmitterExports = eventEmitter.exports;
var isImplemented$2;
var hasRequiredIsImplemented$2;
function requireIsImplemented$2() {
  if (hasRequiredIsImplemented$2)
    return isImplemented$2;
  hasRequiredIsImplemented$2 = 1;
  isImplemented$2 = function() {
    var from2 = Array.from, arr, result2;
    if (typeof from2 !== "function")
      return false;
    arr = ["raz", "dwa"];
    result2 = from2(arr);
    return Boolean(result2 && result2 !== arr && result2[1] === "dwa");
  };
  return isImplemented$2;
}
var isImplemented$1;
var hasRequiredIsImplemented$1;
function requireIsImplemented$1() {
  if (hasRequiredIsImplemented$1)
    return isImplemented$1;
  hasRequiredIsImplemented$1 = 1;
  isImplemented$1 = function() {
    if (typeof globalThis !== "object")
      return false;
    if (!globalThis)
      return false;
    return globalThis.Array === Array;
  };
  return isImplemented$1;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation)
    return implementation;
  hasRequiredImplementation = 1;
  var naiveFallback = function() {
    if (typeof self === "object" && self)
      return self;
    if (typeof window === "object" && window)
      return window;
    throw new Error("Unable to resolve global `this`");
  };
  implementation = function() {
    if (this)
      return this;
    try {
      Object.defineProperty(Object.prototype, "__global__", {
        get: function() {
          return this;
        },
        configurable: true
      });
    } catch (error2) {
      return naiveFallback();
    }
    try {
      if (!__global__)
        return naiveFallback();
      return __global__;
    } finally {
      delete Object.prototype.__global__;
    }
  }();
  return implementation;
}
var globalThis_1;
var hasRequiredGlobalThis;
function requireGlobalThis() {
  if (hasRequiredGlobalThis)
    return globalThis_1;
  hasRequiredGlobalThis = 1;
  globalThis_1 = requireIsImplemented$1()() ? globalThis : requireImplementation();
  return globalThis_1;
}
var isImplemented;
var hasRequiredIsImplemented;
function requireIsImplemented() {
  if (hasRequiredIsImplemented)
    return isImplemented;
  hasRequiredIsImplemented = 1;
  var global2 = requireGlobalThis(), validTypes = { object: true, symbol: true };
  isImplemented = function() {
    var Symbol2 = global2.Symbol;
    var symbol;
    if (typeof Symbol2 !== "function")
      return false;
    symbol = Symbol2("test symbol");
    try {
      String(symbol);
    } catch (e) {
      return false;
    }
    if (!validTypes[typeof Symbol2.iterator])
      return false;
    if (!validTypes[typeof Symbol2.toPrimitive])
      return false;
    if (!validTypes[typeof Symbol2.toStringTag])
      return false;
    return true;
  };
  return isImplemented;
}
var isSymbol;
var hasRequiredIsSymbol;
function requireIsSymbol() {
  if (hasRequiredIsSymbol)
    return isSymbol;
  hasRequiredIsSymbol = 1;
  isSymbol = function(value) {
    if (!value)
      return false;
    if (typeof value === "symbol")
      return true;
    if (!value.constructor)
      return false;
    if (value.constructor.name !== "Symbol")
      return false;
    return value[value.constructor.toStringTag] === "Symbol";
  };
  return isSymbol;
}
var validateSymbol;
var hasRequiredValidateSymbol;
function requireValidateSymbol() {
  if (hasRequiredValidateSymbol)
    return validateSymbol;
  hasRequiredValidateSymbol = 1;
  var isSymbol2 = requireIsSymbol();
  validateSymbol = function(value) {
    if (!isSymbol2(value))
      throw new TypeError(value + " is not a symbol");
    return value;
  };
  return validateSymbol;
}
var generateName;
var hasRequiredGenerateName;
function requireGenerateName() {
  if (hasRequiredGenerateName)
    return generateName;
  hasRequiredGenerateName = 1;
  var d2 = dExports;
  var create2 = Object.create, defineProperty3 = Object.defineProperty, objPrototype = Object.prototype;
  var created = create2(null);
  generateName = function(desc) {
    var postfix = 0, name2, ie11BugWorkaround;
    while (created[desc + (postfix || "")])
      ++postfix;
    desc += postfix || "";
    created[desc] = true;
    name2 = "@@" + desc;
    defineProperty3(
      objPrototype,
      name2,
      d2.gs(null, function(value) {
        if (ie11BugWorkaround)
          return;
        ie11BugWorkaround = true;
        defineProperty3(this, name2, d2(value));
        ie11BugWorkaround = false;
      })
    );
    return name2;
  };
  return generateName;
}
var standardSymbols;
var hasRequiredStandardSymbols;
function requireStandardSymbols() {
  if (hasRequiredStandardSymbols)
    return standardSymbols;
  hasRequiredStandardSymbols = 1;
  var d2 = dExports, NativeSymbol = requireGlobalThis().Symbol;
  standardSymbols = function(SymbolPolyfill) {
    return Object.defineProperties(SymbolPolyfill, {
      // To ensure proper interoperability with other native functions (e.g. Array.from)
      // fallback to eventual native implementation of given symbol
      hasInstance: d2(
        "",
        NativeSymbol && NativeSymbol.hasInstance || SymbolPolyfill("hasInstance")
      ),
      isConcatSpreadable: d2(
        "",
        NativeSymbol && NativeSymbol.isConcatSpreadable || SymbolPolyfill("isConcatSpreadable")
      ),
      iterator: d2("", NativeSymbol && NativeSymbol.iterator || SymbolPolyfill("iterator")),
      match: d2("", NativeSymbol && NativeSymbol.match || SymbolPolyfill("match")),
      replace: d2("", NativeSymbol && NativeSymbol.replace || SymbolPolyfill("replace")),
      search: d2("", NativeSymbol && NativeSymbol.search || SymbolPolyfill("search")),
      species: d2("", NativeSymbol && NativeSymbol.species || SymbolPolyfill("species")),
      split: d2("", NativeSymbol && NativeSymbol.split || SymbolPolyfill("split")),
      toPrimitive: d2(
        "",
        NativeSymbol && NativeSymbol.toPrimitive || SymbolPolyfill("toPrimitive")
      ),
      toStringTag: d2(
        "",
        NativeSymbol && NativeSymbol.toStringTag || SymbolPolyfill("toStringTag")
      ),
      unscopables: d2(
        "",
        NativeSymbol && NativeSymbol.unscopables || SymbolPolyfill("unscopables")
      )
    });
  };
  return standardSymbols;
}
var symbolRegistry;
var hasRequiredSymbolRegistry;
function requireSymbolRegistry() {
  if (hasRequiredSymbolRegistry)
    return symbolRegistry;
  hasRequiredSymbolRegistry = 1;
  var d2 = dExports, validateSymbol2 = requireValidateSymbol();
  var registry = /* @__PURE__ */ Object.create(null);
  symbolRegistry = function(SymbolPolyfill) {
    return Object.defineProperties(SymbolPolyfill, {
      for: d2(function(key) {
        if (registry[key])
          return registry[key];
        return registry[key] = SymbolPolyfill(String(key));
      }),
      keyFor: d2(function(symbol) {
        var key;
        validateSymbol2(symbol);
        for (key in registry) {
          if (registry[key] === symbol)
            return key;
        }
        return void 0;
      })
    });
  };
  return symbolRegistry;
}
var polyfill;
var hasRequiredPolyfill;
function requirePolyfill() {
  if (hasRequiredPolyfill)
    return polyfill;
  hasRequiredPolyfill = 1;
  var d2 = dExports, validateSymbol2 = requireValidateSymbol(), NativeSymbol = requireGlobalThis().Symbol, generateName2 = requireGenerateName(), setupStandardSymbols = requireStandardSymbols(), setupSymbolRegistry = requireSymbolRegistry();
  var create2 = Object.create, defineProperties2 = Object.defineProperties, defineProperty3 = Object.defineProperty;
  var SymbolPolyfill, HiddenSymbol, isNativeSafe;
  if (typeof NativeSymbol === "function") {
    try {
      String(NativeSymbol());
      isNativeSafe = true;
    } catch (ignore2) {
    }
  } else {
    NativeSymbol = null;
  }
  HiddenSymbol = function Symbol2(description2) {
    if (this instanceof HiddenSymbol)
      throw new TypeError("Symbol is not a constructor");
    return SymbolPolyfill(description2);
  };
  polyfill = SymbolPolyfill = function Symbol2(description2) {
    var symbol;
    if (this instanceof Symbol2)
      throw new TypeError("Symbol is not a constructor");
    if (isNativeSafe)
      return NativeSymbol(description2);
    symbol = create2(HiddenSymbol.prototype);
    description2 = description2 === void 0 ? "" : String(description2);
    return defineProperties2(symbol, {
      __description__: d2("", description2),
      __name__: d2("", generateName2(description2))
    });
  };
  setupStandardSymbols(SymbolPolyfill);
  setupSymbolRegistry(SymbolPolyfill);
  defineProperties2(HiddenSymbol.prototype, {
    constructor: d2(SymbolPolyfill),
    toString: d2("", function() {
      return this.__name__;
    })
  });
  defineProperties2(SymbolPolyfill.prototype, {
    toString: d2(function() {
      return "Symbol (" + validateSymbol2(this).__description__ + ")";
    }),
    valueOf: d2(function() {
      return validateSymbol2(this);
    })
  });
  defineProperty3(
    SymbolPolyfill.prototype,
    SymbolPolyfill.toPrimitive,
    d2("", function() {
      var symbol = validateSymbol2(this);
      if (typeof symbol === "symbol")
        return symbol;
      return symbol.toString();
    })
  );
  defineProperty3(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d2("c", "Symbol"));
  defineProperty3(
    HiddenSymbol.prototype,
    SymbolPolyfill.toStringTag,
    d2("c", SymbolPolyfill.prototype[SymbolPolyfill.toStringTag])
  );
  defineProperty3(
    HiddenSymbol.prototype,
    SymbolPolyfill.toPrimitive,
    d2("c", SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive])
  );
  return polyfill;
}
var es6Symbol;
var hasRequiredEs6Symbol;
function requireEs6Symbol() {
  if (hasRequiredEs6Symbol)
    return es6Symbol;
  hasRequiredEs6Symbol = 1;
  es6Symbol = requireIsImplemented()() ? requireGlobalThis().Symbol : requirePolyfill();
  return es6Symbol;
}
var isArguments4;
var hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments)
    return isArguments4;
  hasRequiredIsArguments = 1;
  var objToString = Object.prototype.toString, id2 = objToString.call(function() {
    return arguments;
  }());
  isArguments4 = function(value) {
    return objToString.call(value) === id2;
  };
  return isArguments4;
}
var isFunction;
var hasRequiredIsFunction;
function requireIsFunction() {
  if (hasRequiredIsFunction)
    return isFunction;
  hasRequiredIsFunction = 1;
  var objToString = Object.prototype.toString, isFunctionStringTag = RegExp.prototype.test.bind(/^[object [A-Za-z0-9]*Function]$/);
  isFunction = function(value) {
    return typeof value === "function" && isFunctionStringTag(objToString.call(value));
  };
  return isFunction;
}
var isString2;
var hasRequiredIsString;
function requireIsString() {
  if (hasRequiredIsString)
    return isString2;
  hasRequiredIsString = 1;
  var objToString = Object.prototype.toString, id2 = objToString.call("");
  isString2 = function(value) {
    return typeof value === "string" || value && typeof value === "object" && (value instanceof String || objToString.call(value) === id2) || false;
  };
  return isString2;
}
var shim;
var hasRequiredShim;
function requireShim() {
  if (hasRequiredShim)
    return shim;
  hasRequiredShim = 1;
  var iteratorSymbol = requireEs6Symbol().iterator, isArguments5 = requireIsArguments(), isFunction2 = requireIsFunction(), toPosInt = toPosInteger, callable = validCallable, validValue$1 = validValue, isValue2 = isValue$5, isString3 = requireIsString(), isArray2 = Array.isArray, call = Function.prototype.call, desc = { configurable: true, enumerable: true, writable: true, value: null }, defineProperty3 = Object.defineProperty;
  shim = function(arrayLike) {
    var mapFn = arguments[1], thisArg = arguments[2], Context, i, j, arr, length, code3, iterator, result2, getIterator, value;
    arrayLike = Object(validValue$1(arrayLike));
    if (isValue2(mapFn))
      callable(mapFn);
    if (!this || this === Array || !isFunction2(this)) {
      if (!mapFn) {
        if (isArguments5(arrayLike)) {
          length = arrayLike.length;
          if (length !== 1)
            return Array.apply(null, arrayLike);
          arr = new Array(1);
          arr[0] = arrayLike[0];
          return arr;
        }
        if (isArray2(arrayLike)) {
          arr = new Array(length = arrayLike.length);
          for (i = 0; i < length; ++i)
            arr[i] = arrayLike[i];
          return arr;
        }
      }
      arr = [];
    } else {
      Context = this;
    }
    if (!isArray2(arrayLike)) {
      if ((getIterator = arrayLike[iteratorSymbol]) !== void 0) {
        iterator = callable(getIterator).call(arrayLike);
        if (Context)
          arr = new Context();
        result2 = iterator.next();
        i = 0;
        while (!result2.done) {
          value = mapFn ? call.call(mapFn, thisArg, result2.value, i) : result2.value;
          if (Context) {
            desc.value = value;
            defineProperty3(arr, i, desc);
          } else {
            arr[i] = value;
          }
          result2 = iterator.next();
          ++i;
        }
        length = i;
      } else if (isString3(arrayLike)) {
        length = arrayLike.length;
        if (Context)
          arr = new Context();
        for (i = 0, j = 0; i < length; ++i) {
          value = arrayLike[i];
          if (i + 1 < length) {
            code3 = value.charCodeAt(0);
            if (code3 >= 55296 && code3 <= 56319)
              value += arrayLike[++i];
          }
          value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
          if (Context) {
            desc.value = value;
            defineProperty3(arr, j, desc);
          } else {
            arr[j] = value;
          }
          ++j;
        }
        length = j;
      }
    }
    if (length === void 0) {
      length = toPosInt(arrayLike.length);
      if (Context)
        arr = new Context(length);
      for (i = 0; i < length; ++i) {
        value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
        if (Context) {
          desc.value = value;
          defineProperty3(arr, i, desc);
        } else {
          arr[i] = value;
        }
      }
    }
    if (Context) {
      desc.value = null;
      arr.length = length;
    }
    return arr;
  };
  return shim;
}
var from;
var hasRequiredFrom;
function requireFrom() {
  if (hasRequiredFrom)
    return from;
  hasRequiredFrom = 1;
  from = requireIsImplemented$2()() ? Array.from : requireShim();
  return from;
}
requireFrom();
var ee$1 = eventEmitterExports.methods;
ee$1.on;
ee$1.emit;
class SStoreLsAdapter {
  constructor(id2) {
    this.async = false;
    this._id = id2;
  }
  save(state) {
    window.localStorage.setItem(`state-${this._id}`, JSON.stringify(state));
  }
  load() {
    var _a2;
    return JSON.parse((_a2 = window.localStorage.getItem(`state-${this._id}`)) !== null && _a2 !== void 0 ? _a2 : "{}");
  }
}
var __awaiter$c = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SStateFsAdapter {
  constructor(id2, settings) {
    this.async = true;
    this._id = id2;
    this._settings = settings;
  }
  _init() {
    var _a2, _b2;
    return __awaiter$c(this, void 0, void 0, function* () {
      const { __packageTmpDir } = yield __vitePreload(() => import("./_exports-5f287af2.js"), true ? ["_exports-5f287af2.js","__vite-browser-external_fs-15d823eb.js"] : void 0);
      this._statesDir = (_b2 = (_a2 = this._settings) === null || _a2 === void 0 ? void 0 : _a2.folder) !== null && _b2 !== void 0 ? _b2 : `${__packageTmpDir()}/states`;
      this._stateFile = `${this._statesDir}/${this._id}.state.json`;
    });
  }
  save(state) {
    return new Promise((resolve2) => __awaiter$c(this, void 0, void 0, function* () {
      const _fs = yield __vitePreload(() => import("./__vite-browser-external_fs-15d823eb.js").then((n) => n.a), true ? [] : void 0);
      yield this._init();
      if (!_fs.existsSync(this._statesDir)) {
        _fs.mkdirSync(this._statesDir);
      }
      if (_fs.existsSync(this._stateFile)) {
        _fs.unlinkSync(this._stateFile);
      }
      _fs.writeFileSync(this._stateFile, JSON.stringify(state, null, 4));
      resolve2();
    }));
  }
  load() {
    return new Promise((resolve2) => __awaiter$c(this, void 0, void 0, function* () {
      const _fs = yield __vitePreload(() => import("./__vite-browser-external_fs-15d823eb.js").then((n) => n.a), true ? [] : void 0);
      yield this._init();
      let fileContent = "{}";
      if (_fs.existsSync(this._stateFile)) {
        fileContent = _fs.readFileSync(this._stateFile, "utf-8").toString();
      }
      resolve2(JSON.parse(fileContent));
    }));
  }
}
var __awaiter$b = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SStore extends SClass {
  /**
   * @name            constructor
   * @type            Function
   *
   * Constructor
   *
   * @since       2.0.0
   * @author    Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  constructor(object = {}, settings) {
    super(__deepMerge({
      watchDeep: true,
      save: false,
      excludeFromSave: []
    }, settings !== null && settings !== void 0 ? settings : {}));
    this.isStore = true;
    if (this.settings.save && !this.settings.id) {
      throw new Error(`You MUST set an id for your state when using the "save" setting. Pass an "id" in the settings...`);
    }
    if (this.settings.save && !this.settings.adapter) {
      if (__isNode$2()) {
        this.settings.adapter = new SStateFsAdapter(this.settings.id);
      } else {
        this.settings.adapter = new SStoreLsAdapter(this.settings.id);
      }
    }
    Object.assign(this, object);
    const proxy = __deepProxy(this, (actionObj) => {
      switch (actionObj.action) {
        case "set":
          if (__isPlainObject(actionObj.value)) {
            this._enrichObj(actionObj.value);
          }
          this._eventEmitter.emit(`set.${actionObj.path}`, actionObj);
          break;
        case "delete":
          this._eventEmitter.emit(`delete.${actionObj.path}`, actionObj);
          break;
      }
      if (this.settings.save) {
        clearTimeout(saveTimeout);
        saveTimeout = setTimeout(() => {
          const stateToSave = data.toJson();
          this.settings.excludeFromSave.forEach((prop) => {
            delete stateToSave[prop];
          });
          this.settings.adapter.save(stateToSave);
        });
      }
    }, {
      deep: this.settings.watchDeep
    });
    this._eventEmitter = new SEventEmitter2();
    if (this.settings.save) {
      if (this.settings.adapter.async) {
        (() => __awaiter$b(this, void 0, void 0, function* () {
          const restoredState = yield this.settings.adapter.load();
          __deepAssign(this, restoredState);
        }))();
      } else {
        const restoredState = this.settings.adapter.load();
        __deepAssign(this, restoredState);
      }
    }
    if (this.mount) {
      proxy.mount = this.mount.bind(this);
      setTimeout(() => {
        proxy.mount();
      });
    }
    return proxy;
  }
  _enrichObj(obj) {
    if (obj.length === void 0) {
      Object.defineProperty(obj, "length", {
        enumerable: false,
        get() {
          return Object.keys(obj).length;
        }
      });
    }
    if (obj.toJson === void 0) {
      Object.defineProperty(obj, "toJson", {
        enumerable: false,
        get() {
          return () => JSON.parse(JSON.stringify(obj));
        }
      });
    }
  }
  $set(props, handler, settings) {
    const finalSettings = Object.assign({ group: false, until: void 0 }, settings !== null && settings !== void 0 ? settings : {});
    if (!Array.isArray(props)) {
      props = [props];
    }
    let finalHandler = handler, items = [], ended = false;
    if (finalSettings.group) {
      finalHandler = __debounce(0, (...args) => {
        if (ended) {
          return;
        }
        handler(...args);
        items = [];
      });
    }
    const eventHandler2 = (updateObj, event) => {
      if (finalSettings.group) {
        items.push(updateObj);
        finalHandler(items);
      } else {
        setTimeout(() => {
          if (ended) {
            return;
          }
          finalHandler(updateObj, event);
        });
      }
    };
    props.forEach((prop) => {
      this._eventEmitter.on(`set.${prop}`, eventHandler2);
      if (finalSettings.until) {
        finalSettings.until.finally(() => {
          ended = true;
          this._eventEmitter.off(`set.${prop}`, eventHandler2);
        });
      }
    });
  }
  $delete(props, handler, settings) {
    const finalSettings = Object.assign({ group: false, until: void 0 }, settings !== null && settings !== void 0 ? settings : {});
    if (!Array.isArray(props)) {
      props = [props];
    }
    let finalHandler = handler, items = [], ended = false;
    if (finalSettings.group) {
      finalHandler = __debounce(0, (...args) => {
        if (ended) {
          return;
        }
        handler(...args);
        items = [];
      });
    }
    const eventHandler2 = (updateObj, event) => {
      if (finalSettings.group) {
        items.push(updateObj);
        finalHandler(items);
      } else {
        setTimeout(() => {
          if (ended) {
            return;
          }
          finalHandler(updateObj, event);
        });
      }
    };
    props.forEach((prop) => {
      this._eventEmitter.on(`delete.${prop}`, eventHandler2);
      if (finalSettings.until) {
        finalSettings.until.finally(() => {
          ended = true;
          this._eventEmitter.off(`set.${prop}`, eventHandler2);
        });
      }
    });
  }
}
class SComponentUtilsDefaultPropsInterface extends SInterface {
  static get _definition() {
    return {
      id: {
        description: "Specify an id for your component",
        type: "String",
        physical: true
      },
      // status: {
      //     description:
      //         'Specify the status of the component. Can be "pending", "mounting" or "mounted"',
      //     type: 'String',
      //     values: ['pending', 'mounting', 'mounted'],
      //     default: 'pending',
      //     physical: true,
      // },
      mountWhen: {
        description: "Specify when your component will be mounted",
        type: "String",
        values: WhenTriggers,
        default: "direct"
      },
      activeWhen: {
        description: "Specify when your component is active and when it is not",
        type: "String[]",
        values: ["inViewport", "lod"],
        default: ["inViewport", "lod"]
      },
      lod: {
        description: "Specify the minimum lod (level of details) from when this component is active",
        type: "Number"
      },
      adoptStyle: {
        description: "Specify if your component adopt the style of the global DOM. This worts only if you are using a shadowRoot element",
        type: "Boolean",
        default: true
        // physical: true,
      },
      saveState: {
        description: "Specify if you want to save the state of your component",
        type: "Boolean",
        default: false
      },
      lnf: {
        description: "Specify the lnf (look-and-feel) of your component. This is used by the css to style your component",
        type: "String",
        default: "default",
        physical: true
      },
      bare: {
        description: 'Specify if you want your component with only the bare styling. It just add the "s-bare" class on the component itself',
        type: "Boolean",
        default: false
      },
      responsive: {
        description: 'Specify some responsive properties. A "media" property is required and has to be either a media query, or a media query name defined in the config.themeMedia.queries theme setting',
        type: "Object",
        default: {}
      },
      prefixEvent: {
        description: 'Specify if you want the emitted events to be prefixed by the name of the feature/component like "s-slider.change" or not',
        type: "Boolean",
        default: true
      },
      verbose: {
        description: "Specify if you want this component/feature to log informations about activity or not",
        type: "Boolean",
        default: false
      }
    };
  }
}
class SComponentUtilsSettingsInterface extends SInterface {
  static get _definition() {
    return {
      name: {
        type: "String",
        description: "The name of the component/feature that will be used to generate className, etc..."
      },
      interface: {
        description: "Specify an SInterface class to use as our properties definition",
        type: "SInterface"
      },
      props: {
        description: "Specify a properties object to use as our properties definition",
        type: "Object"
      },
      style: {
        description: "Specify a style string to use as style to inject for our component",
        type: "String"
      },
      defaultProps: {
        description: "Pass an object that act as the default properties value for our component",
        type: "Object"
      },
      useTagNameForClassName: {
        type: "Boolean",
        description: 'Specify if the method "className" will generate a class using the node tagName additionaly to the passed "name" setting',
        default: true
      }
    };
  }
}
var __awaiter$a = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _a$4, _b$3, _c$3;
document._sDefaultProps = (_c$3 = (_b$3 = (_a$4 = window.top) === null || _a$4 === void 0 ? void 0 : _a$4.document) === null || _b$3 === void 0 ? void 0 : _b$3._sDefaultProps) !== null && _c$3 !== void 0 ? _c$3 : {};
class SComponentUtils extends SClass {
  get props() {
    var _a2, _b2;
    return (_b2 = (_a2 = this._props) !== null && _a2 !== void 0 ? _a2 : this.node.props) !== null && _b2 !== void 0 ? _b2 : SComponentUtilsDefaultPropsInterface.defaults();
  }
  /**
   * @name            name
   * @type            String
   *
   * Get the name of the node or feature that this component utils is
   * used by. Get from `settings.componentUtils.name` then throught the passed
   * node using his tagName property
   *
   * @since   2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  get name() {
    var _a2;
    return (_a2 = this.settings.name) !== null && _a2 !== void 0 ? _a2 : this.node.tagName.toLowerCase();
  }
  /**
   * @name            setDefaultProps
   * @type            Function
   * @static
   *
   * This static method allows you to set some default props for some particular
   * component(s). You can target components using simple css selectorl like "my-component#cool".
   * Once the component is instanciated, it will check if some defaults are specified and
   * extends them with the passed props.
   *
   * @param     {String|String[]}      selector      The selector to use to target elements on which these props will be applied
   * @param     {Any}         props         An object of props you want to set defaults for
   *
   * @since       2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  static setDefaultProps(selector, props) {
    selector = Array.isArray(selector) ? selector : [selector];
    selector.forEach((sel) => {
      var _a2;
      document._sDefaultProps[sel] = Object.assign(Object.assign({}, (_a2 = document._sDefaultProps[sel]) !== null && _a2 !== void 0 ? _a2 : {}), props);
    });
  }
  /**
   * @name            getDefaultProps
   * @type            Function
   * @static
   *
   * This static method allows you to get back some default props setted for a component/feature, etc...
   *
   * @param     {String|String[]}      selector      The selector to use to target elements on which these props will be applied
   * @return    {Any}                                 Some default props setted or an empty object
   *
   * @since       2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  static getDefaultProps(selector) {
    var _a2, _b2;
    return Object.assign(Object.assign({}, (_a2 = document._sDefaultProps["*"]) !== null && _a2 !== void 0 ? _a2 : {}), (_b2 = document._sDefaultProps[selector]) !== null && _b2 !== void 0 ? _b2 : {});
  }
  /**
   * @name        componentUtilsSettings
   * @type        ISComponentUtilsSettings
   * @get
   *
   * Access the component utils sertings
   *
   * @since           2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  get componentUtilsSettings() {
    return this.settings.componentUtils;
  }
  /**
   * @name            constructor
   * @type            Function
   * @constructor
   *
   * Constructor
   *
   * @since       2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  constructor(node, settings) {
    super(__deepMerge(SComponentUtilsSettingsInterface.defaults(), settings !== null && settings !== void 0 ? settings : {}));
    this.fastdom = __fastdom;
    this.state = "pending";
    this.DefaultPropsInterface = SComponentUtilsDefaultPropsInterface;
    this._isInViewport = false;
    this._mediaQueries = {};
    this.node = node;
    const whenInViewportPromise = __whenInViewport(this.node, {
      once: false
    });
    whenInViewportPromise.on("in", () => {
      this._isInViewport = true;
    }).on("out", () => {
      this._isInViewport = false;
    });
    if (this.props.bare) {
      this.node.classList.add("s-bare");
    }
    const styleStr = this.settings.style;
    this.injectStyle(styleStr !== null && styleStr !== void 0 ? styleStr : "");
  }
  /**
   * @name            setProps
   * @type            Function
   *
   * This method allows you to set the component props at componentUtils level
   * to be able to use them across methods.
   *
   * @param       {Any}           props           The props to be used
   *
   * @since          2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  setProps(props) {
    this._props = props;
  }
  /**
   * @name           props
   * @type            Any
   *
   * This property allows you to get back the current props object
   *
   * @return      {Any}           The current props object
   *
   * @since       2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  initProps(props, settings) {
    let finalProps = {}, PropsInterface = this.PropsInterface(settings.interface);
    for (let [prop, definition] of Object.entries(PropsInterface.definition)) {
      const camelProp = __camelCase(prop), dashProp = __dashCase(prop), attrValue = this.node.getAttribute(dashProp);
      if (attrValue !== null) {
        let rawValue = this.node.getAttribute(dashProp), value = rawValue;
        if (rawValue === null || rawValue.trim() === "") {
          value = true;
        } else {
          value = value;
        }
        finalProps[camelProp] = value;
      } else if (props[camelProp] !== void 0) {
        finalProps[camelProp] = props[camelProp];
      } else {
        finalProps[camelProp] = definition.default;
      }
    }
    finalProps = PropsInterface.apply(finalProps);
    const _this = this;
    const _props = Object.assign({}, finalProps);
    for (let [prop, value] of Object.entries(finalProps)) {
      Object.defineProperty(finalProps, prop, {
        enumarable: true,
        get() {
          return _props[prop];
        },
        set(value2) {
          if (settings.reflectAttributes) {
            const propDef = PropsInterface.definition[prop];
            if (propDef === null || propDef === void 0 ? void 0 : propDef.physical) {
              __fastdom.mutate(() => {
                if (value2 === false || value2 === void 0 || value2 === null) {
                  _this.node.removeAttribute(__dashCase(prop));
                } else {
                  _this.node.setAttribute(__dashCase(prop), String(value2));
                }
              });
            }
          }
          _props[prop] = value2;
        }
      });
      finalProps[prop] = value;
    }
    return finalProps;
  }
  /**
   * Check if an STheme instance has been instanciated
   */
  _isThemeAvailable() {
    var _a2, _b2;
    return ((_b2 = (_a2 = document.env) === null || _a2 === void 0 ? void 0 : _a2.SUGAR) === null || _b2 === void 0 ? void 0 : _b2.theme) !== void 0;
  }
  /**
   * Check if an sFront instance has been instanciated
   */
  _isFrontAvailable() {
    var _a2, _b2;
    return ((_b2 = (_a2 = document.env) === null || _a2 === void 0 ? void 0 : _a2.SUGAR) === null || _b2 === void 0 ? void 0 : _b2.front) !== void 0;
  }
  /**
   * Check if an SFrontspec instance has been instanciated
   */
  _isFrontspecAvailable() {
    var _a2, _b2;
    return ((_b2 = (_a2 = document.env) === null || _a2 === void 0 ? void 0 : _a2.SUGAR) === null || _b2 === void 0 ? void 0 : _b2.frontspec) !== void 0;
  }
  // /**
  //  * Init the cssPartial feature
  //  */
  // handleCssPartial() {
  //     // css partial if needed
  //     if (this.props.cssPartial) {
  //         this.node.setAttribute('partial', this.props.cssPartial);
  //         this.node.setAttribute('s-css', true);
  //     }
  // }
  /**
   * This method handle the passed props object and apply some behaviors
   * like the responsive props, etc...
   *
   * This will also set the "props" property in the instance.
   */
  handleProps(props, settings) {
    const finalSettings = Object.assign({ reflectAttributes: true, responsive: true }, settings !== null && settings !== void 0 ? settings : {});
    props = this.initProps(Object.assign(Object.assign({}, SComponentUtils.getDefaultProps(this.name.toLowerCase())), props), finalSettings);
    if (finalSettings.responsive) {
      this.makePropsResponsive(props);
    }
    this._props = props;
    return props;
  }
  /**
   * This method to handle the state object passed in the settings.
   * It will check if the state need to be saved, restored, etc...
   */
  handleState(state, settings) {
    var _a2;
    const finalStateSettings = Object.assign(Object.assign({ id: this.node.id }, (_a2 = this.settings.state) !== null && _a2 !== void 0 ? _a2 : {}), settings !== null && settings !== void 0 ? settings : {});
    Object.defineProperty(state, "preventSave", {
      enumerable: false,
      get() {
        return () => {
        };
      }
    });
    if (finalStateSettings.save && !finalStateSettings.id) {
      console.log("HTMLElement", this.node);
      throw new Error(`To save the state of your component, the HTMLElement must have an id...`);
    }
    let _state;
    if (state.isSState) {
      _state = state;
    } else {
      _state = new SStore(Object.assign({}, state), {
        id: finalStateSettings.id,
        save: finalStateSettings.save,
        excludeFromSave: ["status"]
      });
    }
    return _state;
  }
  /**
   * Check if some <responsive> tags are defined in the component, or if a "responsive" prop exists
   * to adapt properties depending on the viewport size.
   */
  makePropsResponsive(props) {
    var _a2, _b2, _c2, _d2, _e2;
    if (!this._isFrontAvailable() || !((_d2 = (_c2 = (_b2 = (_a2 = document.env) === null || _a2 === void 0 ? void 0 : _a2.SUGAR) === null || _b2 === void 0 ? void 0 : _b2.frontspec) === null || _c2 === void 0 ? void 0 : _c2.get) === null || _d2 === void 0 ? void 0 : _d2.call(_c2, "media.queries"))) {
      if (!this.constructor._isResponsivePropsWarningLogged) {
        this.constructor._isResponsivePropsWarningLogged = true;
        console.warn(`<red>[SComponentUtils]</red> To use responsive props on components and features, you MUST call the SFront.init() method in your main entry file as well as make sure you have a proper frontspec.json file with the "media.queries" specs...`);
      }
      return;
    }
    props.responsive = __deepMerge({
      // original: Object.assign({}, props),
    }, (_e2 = props.responsive) !== null && _e2 !== void 0 ? _e2 : {});
    Object.defineProperty(props, "toResetResponsiveProps", {
      enumerable: false,
      writable: true,
      value: {}
    });
    const $responsives = Array.from(this.node.children).filter(($child) => $child.tagName === "RESPONSIVE");
    if ($responsives.length) {
      $responsives.forEach(($responsive) => {
        const attrs = $responsive.attributes, responsiveProps = {};
        let media;
        Object.keys(attrs).forEach((key) => {
          var _a3, _b3, _c3;
          let value;
          if (((_a3 = attrs[key]) === null || _a3 === void 0 ? void 0 : _a3.nodeValue) !== void 0) {
            if (attrs[key].nodeValue === "")
              value = true;
            else
              value = attrs[key].nodeValue;
          }
          if (!value)
            return;
          const propName = (_c3 = (_b3 = attrs[key]) === null || _b3 === void 0 ? void 0 : _b3.name) !== null && _c3 !== void 0 ? _c3 : key;
          if (propName === "media") {
            media = value;
          } else {
            responsiveProps[__camelCase(propName)] = value;
          }
        });
        if (media) {
          if (!props.responsive[media]) {
            props.responsive[media] = {};
          }
          props.responsive[media] = responsiveProps;
        }
      });
    }
    if (Object.keys(props.responsive).length === 1 && props.responsive.original) {
      return;
    }
    window.addEventListener("resize", __debounce(100, () => {
      this._applyResponsiveProps(props);
    }));
    this._applyResponsiveProps(props);
  }
  _applyResponsiveProps(props = {}) {
    var _a2;
    let matchedMedia = [];
    const responsiveObj = Object.assign({}, props.responsive);
    const mediaInstance = new SMedia2();
    for (let [media, responsiveProps] of Object.entries(props.responsive)) {
      let applyProps = function() {
        for (let [key, value] of Object.entries(responsiveProps)) {
          props.toResetResponsiveProps[key] = props[key];
          props[key] = value;
        }
      };
      const queries = SFrontspec.get(`media.queries`);
      media.replace(/(<|>|=|\|)/gm, "");
      if (media === "toResetResponsiveProps") {
        continue;
      }
      if (media.match(/[a-zA-Z0-9<>=]/) && queries[media]) {
        let mediaQuery = this._mediaQueries[media];
        if (!mediaQuery) {
          this._mediaQueries[media] = mediaInstance.buildQuery(media);
          mediaQuery = this._mediaQueries[media];
        }
        if (window.matchMedia(mediaQuery.replace(/^@media\s/, "")).matches) {
          applyProps();
          matchedMedia.push(media);
        }
      } else {
        if (window.matchMedia(media).matches) {
          applyProps();
          matchedMedia.push(media);
        }
      }
    }
    if (!matchedMedia.length) {
      for (let [key, value] of Object.entries((_a2 = props.toResetResponsiveProps) !== null && _a2 !== void 0 ? _a2 : {})) {
        props[key] = value;
        delete props.toResetResponsiveProps[key];
      }
    }
    props.responsive = responsiveObj;
  }
  /**
   * @name           waitAndExecute
   * @type            Function
   * @async
   *
   * This async method allows you to wait for the component (node) has reached
   * his "mount" state. This state depends fully on the "mountWhen" property.
   * When the state has been reached, the passed callback will be executed.
   *
   * @param       {String|String[]}            when            When you want to execute the callback. Can be "direct", "inViewport", "nearViewport", "outOfViewport", "interact", "visible" or "stylesheetReady"
   * @param       {Function}          callback            The callback to execute
   * @return          {Promise}           A promise fullfilled when the component (node) has reached his "mount" state
   *
   * @since       2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  waitAndExecute(when, callback) {
    return new Promise((resolve2, reject) => __awaiter$a(this, void 0, void 0, function* () {
      var _a2;
      if (this.node.tagName.toLowerCase() !== "s-carpenter") {
        if (((_a2 = document.env) === null || _a2 === void 0 ? void 0 : _a2.CARPENTER) && !__isInIframe()) {
          return;
        }
      }
      if (!Array.isArray(when)) {
        when = [when];
      }
      if (this.props.lod !== void 0) {
        yield __when(this.node, `lod:${this.props.lod}`);
      }
      if (!when.includes("direct") && !when.includes("directly")) {
        yield __when(this.node, when);
      } else {
        yield __wait();
      }
      callback === null || callback === void 0 ? void 0 : callback(this.node);
      resolve2(this.node);
    }));
  }
  /**
   * @name           dispatchEvent
   * @type            Function
   * @async
   *
   * This method allows you to dispatch some CustomEvents from your component node itself.
   * 1. An event called "%componentName.%eventName"
   * 2. An event called "%componentName" with in the detail object a "eventType" property set to the event name
   * 3. An event called "%eventName" with in the detail object a "eventComponent" property set to the component name
   *
   * @param           {String}            eventName     The event name to dispatch
   * @param           {ISComponentUtilsDispatchSettings}          [settings={}]     The settings to use for the dispatch
   *
   * @since       2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  dispatchEvent(eventName, settings) {
    var _a2;
    const finalSettings = Object.assign({ $elm: this.node, bubbles: true, cancelable: true, detail: {} }, settings !== null && settings !== void 0 ? settings : {});
    const componentName = this.name;
    if ((_a2 = this.props) === null || _a2 === void 0 ? void 0 : _a2.prefixEvent) {
      finalSettings.$elm.dispatchEvent(new CustomEvent(`${componentName}.${eventName}`, finalSettings));
    } else {
      finalSettings.$elm.dispatchEvent(new CustomEvent(eventName, Object.assign(Object.assign({}, finalSettings), { detail: Object.assign(Object.assign({}, finalSettings.detail), { eventComponent: componentName }) })));
    }
    finalSettings.$elm.dispatchEvent(new CustomEvent(componentName, Object.assign(Object.assign({}, finalSettings), { detail: Object.assign(Object.assign({}, finalSettings.detail), { eventType: eventName }) })));
  }
  /**
   * @name        adoptStyleInShadowRoot
   * @type        Function
   * @async
   *
   * This method allows you to make the passed shadowRoot element adopt
   * the style of the passed context who's by default the document itself
   *
   * @param       {HTMLShadowRootElement}         $shadowRoot             The shadow root you want to adopt the $context styles
   * @param      {HTMLElement}                   [$context=document]     The context from which you want to adopt the styles
   * @return      {Promise}                                               Return a promise fullfilled when the styles have been adopted
   *
   * @since       2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  adoptStyleInShadowRoot($shadowRoot, $context) {
    return __adoptStyleInShadowRoot($shadowRoot, $context);
  }
  defaultProps(interf) {
    var _a2, _b2, _c2, _d2;
    if (this._defaultProps)
      return Object.assign({}, this._defaultProps);
    this._defaultProps = Object.assign({}, __deepMerge(
      // @ts-ignore
      SComponentUtilsDefaultPropsInterface.defaults(),
      (_a2 = this.settings.defaultProps) !== null && _a2 !== void 0 ? _a2 : {},
      (_b2 = this.constructor._defaultProps["*"]) !== null && _b2 !== void 0 ? _b2 : {},
      (_c2 = this.constructor._defaultProps[this.name]) !== null && _c2 !== void 0 ? _c2 : {},
      (_d2 = interf === null || interf === void 0 ? void 0 : interf.defaults()) !== null && _d2 !== void 0 ? _d2 : {}
    ));
    return this._defaultProps;
  }
  PropsInterface(interf) {
    var _a2, _b2;
    if (this._PropsInterface)
      return this._PropsInterface;
    class PropsInterface extends SInterface {
    }
    PropsInterface.definition = __deepMerge((_a2 = SComponentUtilsDefaultPropsInterface.definition) !== null && _a2 !== void 0 ? _a2 : {}, (_b2 = interf === null || interf === void 0 ? void 0 : interf.definition) !== null && _b2 !== void 0 ? _b2 : {});
    this._PropsInterface = PropsInterface;
    return this._PropsInterface;
  }
  injectStyle(css2, id2 = this.tagName) {
    if (this.constructor._injectedStyles.indexOf(id2) !== -1)
      return;
    this.constructor._injectedStyles.push(id2);
    __injectStyle(css2, {
      id: id2
    });
  }
  /**
   * @name            exposeApi
   * @type            Function
   *
   * This method allows you to pass a simple key value object
   * that tells binding of some methods on the actual dom node.
   *
   * @param       {Any}           apiObj          The simple key value pairs api object
   *
   * @since       2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  exposeApi(apiObj, ctx = this.node) {
    setTimeout(() => {
      let $on = this.node;
      Object.keys(apiObj).forEach((apiFnName) => {
        const apiFn = apiObj[apiFnName].bind(ctx);
        $on[apiFnName] = apiFn;
      });
    });
  }
  /**
   * @name          cls
   * @type          Function
   *
   * This method allows you to get a component ready class like my-component__something, etc...
   *
   * @param         {String}        cls         The class you want to process. Can be multiple classes separated by a space. If null, does not print any class at all but the "style" one
   * @return        {String}                    The generated class that you can apply
   *
   * @since         2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  cls(cls = "", style = "") {
    let clsString = "";
    if (cls !== null) {
      clsString = cls.split(" ").map((clsName) => {
        let clses = [];
        if (this.settings.useTagNameForClassName) {
          clses.push(`${this.node.tagName.toLowerCase()}${clsName && !clsName.match(/^(_{1,2}|-)/) ? "-" : ""}${clsName}`);
        }
        if (this.settings.name && this.node.tagName.toLowerCase() !== this.settings.name) {
          clses.push(`${this.settings.name.toLowerCase()}${clsName && !clsName.match(/^(_{1,2}|-)/) ? "-" : ""}${clsName}`);
        }
        clses = clses.map((c) => c.replace("---", "--"));
        return clses.join(" ");
      }).join(" ");
    }
    if (style) {
      clsString += ` ${style}`;
    }
    return clsString;
  }
  /**
   * @name          uCls
   * @type          Function
   *
   * This method returns you only 1 class that is based on the passed "name" and not on the "tagName".
   *
   * @param         {String}        cls         The class you want to process. Can be multiple classes separated by a space
   * @return        {String}                    The generated class that you can apply
   *
   * @since         2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  uCls(cls = "", style = "") {
    let clsString = cls.split(" ").map((clsName) => {
      const clses = [];
      if (this.settings.name && this.node.tagName.toLowerCase() !== this.settings.name) {
        clses.push(`${this.settings.name.toLowerCase()}${clsName && !clsName.match(/^_{1,2}/) ? "-" : ""}${clsName}`);
      } else {
        clses.push(`${this.node.tagName.toLowerCase()}${clsName && !clsName.match(/^_{1,2}/) ? "-" : ""}${clsName}`);
      }
      return clses.join(" ");
    }).join("");
    return clsString;
  }
  /**
   * @name      isMounted
   * @type      Function
   *
   * This method returns true if the component is mounted, false if not
   *
   * @return    {Boolean}       true if is mounted, false if not
   *
   * @since   2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  isMounted() {
    var _a2;
    return (_a2 = this.node) === null || _a2 === void 0 ? void 0 : _a2.hasAttribute("mounted");
  }
  /**
   * @name            isInViewport
   * @type            Function
   *
   * true if the component is in the viewport, false if not
   *
   * @since   2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  isInViewport() {
    return this._isInViewport;
  }
  /**
   * @name            isActive
   * @type            Function
   *
   * true if the component is active or not. A component is active when
   *
   * @since   2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  isActive() {
    if (this.props.activeWhen.includes("lod") && this.props.lod !== void 0 && this._isFrontAvailable() && SFront.instance.lod.level < this.props.lod) {
      return false;
    }
    if (this.props.activeWhen.includes("inViewport") && !this._isInViewport) {
      return false;
    }
    return true;
  }
}
SComponentUtils.fastdom = __fastdom;
SComponentUtils._isResponsivePropsWarningLogged = false;
SComponentUtils._injectedStyles = [];
var __awaiter$9 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SFeature extends SClass {
  /**
   * @name            setDefaultProps
   * @type            Function
   * @static
   *
   * This static method allows you to set some default props for some particular
   * component(s). You can target components using simple css selectorl like "my-component#cool".
   * Once the component is instanciated, it will check if some defaults are specified and
   * extends them with the passed props.
   *
   * @param     {String|String[]}      selector      The selector to use to target elements on which these props will be applied
   * @param     {Any}         props         An object of props you want to set defaults for
   *
   * @since       2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  static setDefaultProps(selector, props) {
    SComponentUtils.setDefaultProps(selector, props);
  }
  /**
   * @name              define
   * @type            Function
   * @static
   *
   * This static method allows you to register a new feature
   * associated with an HTMLElement attribute like "s-activate", etc...
   *
   * @param           {String}        name           The attribute that trigger the feature
   * @param           {SFeature}       feature                The actual feature class to use
   * @param           {Any}           [defaultProps={}]       Some default props to set for this feature
   *
   * @since           2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  static define(name2, featureCls, defaultProps = {}) {
    this.setDefaultProps(name2, defaultProps);
    __querySelectorLive(`[${name2}]`, ($elm) => {
      new featureCls(name2, $elm, SComponentUtils.getDefaultProps(name2));
    }, {
      // attributes: [name],
    });
  }
  /**
   * @name            constructor
   * @type            Function
   * @constructor
   *
   * Constructor
   *
   * @since       2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  constructor(name2, node, settings) {
    var _a2, _b2, _c2, _d2;
    super(settings);
    if (this.settings.style) {
      __injectStyle(this.settings.style, {
        id: `s-feature-${name2}`
      });
    }
    this.utils = new SComponentUtils(node, Object.assign(Object.assign(Object.assign({}, (_a2 = this.settings) !== null && _a2 !== void 0 ? _a2 : {}), (_b2 = this.settings.componentUtils) !== null && _b2 !== void 0 ? _b2 : {}), { useTagNameForClassName: false, name: name2 }));
    this.name = name2;
    this.node = node;
    this.props = this.utils.handleProps({}, {
      interface: (_c2 = this.settings.interface) !== null && _c2 !== void 0 ? _c2 : (_d2 = this.settings.componentUtils) === null || _d2 === void 0 ? void 0 : _d2.interface
    });
    this.node.classList.add(...this.utils.cls("").split(" "));
    this.utils.waitAndExecute(
      this.props.mountWhen,
      // @ts-ignore
      () => __awaiter$9(this, void 0, void 0, function* () {
        var _e2;
        yield (_e2 = this.mount) === null || _e2 === void 0 ? void 0 : _e2.call(this);
        this.props.mounted = true;
      })
    );
  }
}
class SLazyFeatureInterface extends SInterface {
  static get _definition() {
    return {};
  }
}
const __css$6 = "\n                @import url('https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css');\n            template[s-lazy] {\n    display: block;\n    height: calc(100 * var(--vh,1vh)) ;\n}\n";
var __awaiter$8 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SLazyFeature extends SFeature {
  constructor(name2, node, settings) {
    super(name2, node, __deepMerge({
      name: "s-lazy",
      interface: SLazyFeatureInterface,
      style: __css$6
    }, settings !== null && settings !== void 0 ? settings : {}));
  }
  mount() {
    var _a2, _b2;
    return __awaiter$8(this, void 0, void 0, function* () {
      let $content;
      if (this.node.tagName === "TEXTAREA") {
        const parser = new DOMParser();
        const html2 = this.node.value;
        const $dom = parser.parseFromString(html2, "text/html");
        $content = $dom.body.children[0];
        $dom.body.children[0];
      } else {
        $content = this.node.content;
        $content.children[0];
      }
      if (this.node.id) {
        (_b2 = (_a2 = $content.children[0]) === null || _a2 === void 0 ? void 0 : _a2.setAttribute) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, "id", this.node.id);
      }
      this.node.parentNode.insertBefore($content, this.node);
      this.node.remove();
    });
  }
}
function define$c(props = {}, name2 = "s-lazy") {
  SLazyFeature.define(name2, SLazyFeature, Object.assign({}, props));
}
var __awaiter$7 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function define$b(props, tagName = "s-scroll", settings = {}) {
  var _a2;
  __querySelectorLive(tagName, ($elm) => __awaiter$7(this, void 0, void 0, function* () {
    const define2 = yield __vitePreload(() => import("./define-2508a7a6.js"), true ? [] : void 0);
    define2.default(props, tagName, settings);
  }), {
    when: (_a2 = settings.when) !== null && _a2 !== void 0 ? _a2 : "nearViewport",
    firstOnly: true
  });
}
var __awaiter$6 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function define$a(props, name2 = "s-sugar", settings = {}) {
  var _a2;
  __querySelectorLive(`[${name2}]`, ($elm) => __awaiter$6(this, void 0, void 0, function* () {
    const define2 = yield __vitePreload(() => import("./define-d810f2de.js"), true ? [] : void 0);
    define2.default(props, name2);
  }), {
    when: (_a2 = settings.when) !== null && _a2 !== void 0 ? _a2 : "nearViewport",
    firstOnly: true
  });
}
function SPackEssentials() {
  define$g();
  define$b();
  define$a();
  define$c();
  define$i();
  define$h();
  define$f();
  define$e();
  define$d();
}
globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class WelcomeSlider {
  constructor($slider) {
    this._settings = {
      easing: "cubic-bezier(0.755, 0.000, 0.195, 0.985)",
      maxDelay: 0.3,
      maxDuration: 0.3,
      maxRotation: 360,
      maxTranslate: 100,
      translateXFactor: 1,
      translateYFactor: 0,
      rotationFactor: 0
    };
    this._slideIdx = 0;
    this._paused = false;
    this._$slider = $slider;
    this._$slides = Array.from($slider.children);
    this._$slides.forEach(($slide) => {
      __splitLetters($slide);
      $slide._$letters = Array.from(
        $slide.querySelectorAll(".s-split-letter")
      );
    });
    const $viewportAware = __querySelectorUp(
      this._$slider,
      "[viewport-aware]"
    );
    if ($viewportAware) {
      $viewportAware.addEventListener("viewport.in", () => {
        this._paused = false;
      });
      $viewportAware.addEventListener("viewport.out", () => {
        this._paused = true;
      });
    }
    this.goTo(this._slideIdx);
    $slider.addEventListener("pointerover", (e) => {
      this._paused = true;
    });
    $slider.addEventListener("pointerout", (e) => {
      this._paused = false;
    });
    this._$slider.setAttribute("ready", "true");
    setInterval(() => {
      if (this._paused) {
        return;
      }
      this.next();
    }, 5e3);
  }
  highlightLetter() {
    const $letter = __pickRandom(this.getCurrentSlideLetters() ?? []);
    if ($letter.innerHTML.trim() !== "░") {
      setTimeout(() => {
        this.highlightLetter();
      }, Math.random() * 500);
      return;
    }
    setTimeout(() => {
      this.highlightLetter();
    }, Math.random() * 500);
    $letter.classList.add("active");
    setTimeout(() => {
      $letter.classList.remove("active");
    }, Math.random() * 1e3);
  }
  getSlideByIdx(idx) {
    return this._$slides[idx];
  }
  getCurrentSlide() {
    return this._$slides[this._slideIdx];
  }
  getCurrentSlideLetters() {
    return this.getCurrentSlide()._$letters;
  }
  next() {
    const newSlideIdx = this._slideIdx + 1 >= this._$slides.length ? 0 : this._slideIdx + 1;
    this.goTo(newSlideIdx);
  }
  previous() {
    const newSlideIdx = this._slideIdx - 1 < 0 ? this._$slides.length - 1 : this._slideIdx - 1;
    this.goTo(newSlideIdx);
  }
  goTo(slideIdx) {
    const $currentSlide = this.getSlideByIdx(this._slideIdx);
    if ($currentSlide) {
      $currentSlide.classList.remove("active");
      this._slideOut($currentSlide);
    }
    const $newSlide = this.getSlideByIdx(slideIdx);
    $newSlide == null ? void 0 : $newSlide.classList.add("active");
    this._slideIn($newSlide);
    this._slideIdx = slideIdx;
  }
  _getTransformObj() {
    const y2 = (this._settings.maxTranslate * -1 + Math.round(
      Math.random() * this._settings.maxTranslate * 2
    )) * this._settings.translateYFactor, x = (this._settings.maxTranslate * -1 + Math.round(
      Math.random() * this._settings.maxTranslate * 2
    )) * this._settings.translateXFactor, rotation = (this._settings.maxRotation * -1 + Math.round(
      Math.random() * this._settings.maxRotation * 2
    )) * this._settings.rotationFactor, duration = Math.random() * this._settings.maxDuration, delay = Math.random() * this._settings.maxDelay;
    return {
      x,
      y: y2,
      rotation,
      duration,
      delay
    };
  }
  _applyTransformToLetter(transformObj, $letter) {
    $letter.style.display = "inline-block";
    $letter.style.opacity = 0;
    $letter.style.transformOrigin = "50% 50%";
    $letter.style.transition = `all ${transformObj.duration}s ${this._settings.easing} ${transformObj.delay}s`;
    $letter.style.transform = `translate(${transformObj.x}px, ${transformObj.y}px) rotateZ(${transformObj.rotation}deg)`;
  }
  _slideOut($slide) {
    $slide._$letters.forEach(($letter) => {
      if ($letter.innerHTML.trim()) {
        const transformObj = this._getTransformObj();
        this._applyTransformToLetter(transformObj, $letter);
      }
    });
  }
  _slideIn($slide) {
    $slide._$letters.forEach(($letter, i) => {
      const transformObj = this._getTransformObj();
      if ($letter.innerHTML.trim()) {
        this._applyTransformToLetter(transformObj, $letter);
        setTimeout(() => {
          $letter.style.transform = `translate(0px, 0px) rotateZ(0deg)`;
          $letter.style.opacity = 1;
        }, 1e3);
      }
    });
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const NODE_MODE = false;
const global$4 = window;
const supportsAdoptingStyleSheets = global$4.ShadowRoot && (global$4.ShadyCSS === void 0 || global$4.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
const constructionToken = Symbol();
const cssTagCache = /* @__PURE__ */ new WeakMap();
class CSSResult {
  constructor(cssText, strings, safeToken) {
    this["_$cssResult$"] = true;
    if (safeToken !== constructionToken) {
      throw new Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    }
    this.cssText = cssText;
    this._strings = strings;
  }
  // This is a getter so that it's lazy. In practice, this means stylesheets
  // are not created until the first element instance is made.
  get styleSheet() {
    let styleSheet = this._styleSheet;
    const strings = this._strings;
    if (supportsAdoptingStyleSheets && styleSheet === void 0) {
      const cacheable = strings !== void 0 && strings.length === 1;
      if (cacheable) {
        styleSheet = cssTagCache.get(strings);
      }
      if (styleSheet === void 0) {
        (this._styleSheet = styleSheet = new CSSStyleSheet()).replaceSync(this.cssText);
        if (cacheable) {
          cssTagCache.set(strings, styleSheet);
        }
      }
    }
    return styleSheet;
  }
  toString() {
    return this.cssText;
  }
}
const textFromCSSResult = (value) => {
  if (value["_$cssResult$"] === true) {
    return value.cssText;
  } else if (typeof value === "number") {
    return value;
  } else {
    throw new Error(`Value passed to 'css' function must be a 'css' function result: ${value}. Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.`);
  }
};
const unsafeCSS = (value) => new CSSResult(typeof value === "string" ? value : String(value), void 0, constructionToken);
const css$1 = (strings, ...values) => {
  const cssText = strings.length === 1 ? strings[0] : values.reduce((acc, v2, idx) => acc + textFromCSSResult(v2) + strings[idx + 1], strings[0]);
  return new CSSResult(cssText, strings, constructionToken);
};
const adoptStyles = (renderRoot, styles2) => {
  if (supportsAdoptingStyleSheets) {
    renderRoot.adoptedStyleSheets = styles2.map((s) => s instanceof CSSStyleSheet ? s : s.styleSheet);
  } else {
    styles2.forEach((s) => {
      const style = document.createElement("style");
      const nonce = global$4["litNonce"];
      if (nonce !== void 0) {
        style.setAttribute("nonce", nonce);
      }
      style.textContent = s.cssText;
      renderRoot.appendChild(style);
    });
  }
};
const cssResultFromStyleSheet = (sheet) => {
  let cssText = "";
  for (const rule of sheet.cssRules) {
    cssText += rule.cssText;
  }
  return unsafeCSS(cssText);
};
const getCompatibleStyle = supportsAdoptingStyleSheets || NODE_MODE ? (s) => s : (s) => s instanceof CSSStyleSheet ? cssResultFromStyleSheet(s) : s;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var _b$2, _c$2, _d$2;
var _e$1;
const global$3 = window;
let requestUpdateThenable;
let issueWarning$2;
const trustedTypes$1 = global$3.trustedTypes;
const emptyStringForBooleanAttribute$1 = trustedTypes$1 ? trustedTypes$1.emptyScript : "";
const polyfillSupport$2 = global$3.reactiveElementPolyfillSupportDevMode;
{
  const issuedWarnings = (_b$2 = global$3.litIssuedWarnings) !== null && _b$2 !== void 0 ? _b$2 : global$3.litIssuedWarnings = /* @__PURE__ */ new Set();
  issueWarning$2 = (code3, warning) => {
    warning += ` See https://lit.dev/msg/${code3} for more information.`;
    if (!issuedWarnings.has(warning)) {
      console.warn(warning);
      issuedWarnings.add(warning);
    }
  };
  issueWarning$2("dev-mode", `Lit is in dev mode. Not recommended for production!`);
  if (((_c$2 = global$3.ShadyDOM) === null || _c$2 === void 0 ? void 0 : _c$2.inUse) && polyfillSupport$2 === void 0) {
    issueWarning$2("polyfill-support-missing", `Shadow DOM is being polyfilled via \`ShadyDOM\` but the \`polyfill-support\` module has not been loaded.`);
  }
  requestUpdateThenable = (name2) => ({
    then: (onfulfilled, _onrejected) => {
      issueWarning$2("request-update-promise", `The \`requestUpdate\` method should no longer return a Promise but does so on \`${name2}\`. Use \`updateComplete\` instead.`);
      if (onfulfilled !== void 0) {
        onfulfilled(false);
      }
    }
  });
}
const debugLogEvent$1 = (event) => {
  const shouldEmit = global$3.emitLitDebugLogEvents;
  if (!shouldEmit) {
    return;
  }
  global$3.dispatchEvent(new CustomEvent("lit-debug", {
    detail: event
  }));
};
const JSCompiler_renameProperty = (prop, _obj) => prop;
const defaultConverter = {
  toAttribute(value, type) {
    switch (type) {
      case Boolean:
        value = value ? emptyStringForBooleanAttribute$1 : null;
        break;
      case Object:
      case Array:
        value = value == null ? value : JSON.stringify(value);
        break;
    }
    return value;
  },
  fromAttribute(value, type) {
    let fromValue = value;
    switch (type) {
      case Boolean:
        fromValue = value !== null;
        break;
      case Number:
        fromValue = value === null ? null : Number(value);
        break;
      case Object:
      case Array:
        try {
          fromValue = JSON.parse(value);
        } catch (e) {
          fromValue = null;
        }
        break;
    }
    return fromValue;
  }
};
const notEqual = (value, old) => {
  return old !== value && (old === old || value === value);
};
const defaultPropertyDeclaration = {
  attribute: true,
  type: String,
  converter: defaultConverter,
  reflect: false,
  hasChanged: notEqual
};
const finalized = "finalized";
class ReactiveElement extends HTMLElement {
  constructor() {
    super();
    this.__instanceProperties = /* @__PURE__ */ new Map();
    this.isUpdatePending = false;
    this.hasUpdated = false;
    this.__reflectingProperty = null;
    this._initialize();
  }
  /**
   * Adds an initializer function to the class that is called during instance
   * construction.
   *
   * This is useful for code that runs against a `ReactiveElement`
   * subclass, such as a decorator, that needs to do work for each
   * instance, such as setting up a `ReactiveController`.
   *
   * ```ts
   * const myDecorator = (target: typeof ReactiveElement, key: string) => {
   *   target.addInitializer((instance: ReactiveElement) => {
   *     // This is run during construction of the element
   *     new MyController(instance);
   *   });
   * }
   * ```
   *
   * Decorating a field will then cause each instance to run an initializer
   * that adds a controller:
   *
   * ```ts
   * class MyElement extends LitElement {
   *   @myDecorator foo;
   * }
   * ```
   *
   * Initializers are stored per-constructor. Adding an initializer to a
   * subclass does not add it to a superclass. Since initializers are run in
   * constructors, initializers will run in order of the class hierarchy,
   * starting with superclasses and progressing to the instance's class.
   *
   * @nocollapse
   */
  static addInitializer(initializer) {
    var _a2;
    this.finalize();
    ((_a2 = this._initializers) !== null && _a2 !== void 0 ? _a2 : this._initializers = []).push(initializer);
  }
  /**
   * Returns a list of attributes corresponding to the registered properties.
   * @nocollapse
   * @category attributes
   */
  static get observedAttributes() {
    this.finalize();
    const attributes = [];
    this.elementProperties.forEach((v2, p) => {
      const attr = this.__attributeNameForProperty(p, v2);
      if (attr !== void 0) {
        this.__attributeToPropertyMap.set(attr, p);
        attributes.push(attr);
      }
    });
    return attributes;
  }
  /**
   * Creates a property accessor on the element prototype if one does not exist
   * and stores a {@linkcode PropertyDeclaration} for the property with the
   * given options. The property setter calls the property's `hasChanged`
   * property option or uses a strict identity check to determine whether or not
   * to request an update.
   *
   * This method may be overridden to customize properties; however,
   * when doing so, it's important to call `super.createProperty` to ensure
   * the property is setup correctly. This method calls
   * `getPropertyDescriptor` internally to get a descriptor to install.
   * To customize what properties do when they are get or set, override
   * `getPropertyDescriptor`. To customize the options for a property,
   * implement `createProperty` like this:
   *
   * ```ts
   * static createProperty(name, options) {
   *   options = Object.assign(options, {myOption: true});
   *   super.createProperty(name, options);
   * }
   * ```
   *
   * @nocollapse
   * @category properties
   */
  static createProperty(name2, options = defaultPropertyDeclaration) {
    var _a2;
    if (options.state) {
      options.attribute = false;
    }
    this.finalize();
    this.elementProperties.set(name2, options);
    if (!options.noAccessor && !this.prototype.hasOwnProperty(name2)) {
      const key = typeof name2 === "symbol" ? Symbol() : `__${name2}`;
      const descriptor2 = this.getPropertyDescriptor(name2, key, options);
      if (descriptor2 !== void 0) {
        Object.defineProperty(this.prototype, name2, descriptor2);
        {
          if (!this.hasOwnProperty("__reactivePropertyKeys")) {
            this.__reactivePropertyKeys = new Set((_a2 = this.__reactivePropertyKeys) !== null && _a2 !== void 0 ? _a2 : []);
          }
          this.__reactivePropertyKeys.add(name2);
        }
      }
    }
  }
  /**
   * Returns a property descriptor to be defined on the given named property.
   * If no descriptor is returned, the property will not become an accessor.
   * For example,
   *
   * ```ts
   * class MyElement extends LitElement {
   *   static getPropertyDescriptor(name, key, options) {
   *     const defaultDescriptor =
   *         super.getPropertyDescriptor(name, key, options);
   *     const setter = defaultDescriptor.set;
   *     return {
   *       get: defaultDescriptor.get,
   *       set(value) {
   *         setter.call(this, value);
   *         // custom action.
   *       },
   *       configurable: true,
   *       enumerable: true
   *     }
   *   }
   * }
   * ```
   *
   * @nocollapse
   * @category properties
   */
  static getPropertyDescriptor(name2, key, options) {
    return {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      get() {
        return this[key];
      },
      set(value) {
        const oldValue = this[name2];
        this[key] = value;
        this.requestUpdate(name2, oldValue, options);
      },
      configurable: true,
      enumerable: true
    };
  }
  /**
   * Returns the property options associated with the given property.
   * These options are defined with a `PropertyDeclaration` via the `properties`
   * object or the `@property` decorator and are registered in
   * `createProperty(...)`.
   *
   * Note, this method should be considered "final" and not overridden. To
   * customize the options for a given property, override
   * {@linkcode createProperty}.
   *
   * @nocollapse
   * @final
   * @category properties
   */
  static getPropertyOptions(name2) {
    return this.elementProperties.get(name2) || defaultPropertyDeclaration;
  }
  /**
   * Creates property accessors for registered properties, sets up element
   * styling, and ensures any superclasses are also finalized. Returns true if
   * the element was finalized.
   * @nocollapse
   */
  static finalize() {
    if (this.hasOwnProperty(finalized)) {
      return false;
    }
    this[finalized] = true;
    const superCtor = Object.getPrototypeOf(this);
    superCtor.finalize();
    if (superCtor._initializers !== void 0) {
      this._initializers = [...superCtor._initializers];
    }
    this.elementProperties = new Map(superCtor.elementProperties);
    this.__attributeToPropertyMap = /* @__PURE__ */ new Map();
    if (this.hasOwnProperty(JSCompiler_renameProperty("properties"))) {
      const props = this.properties;
      const propKeys = [
        ...Object.getOwnPropertyNames(props),
        ...Object.getOwnPropertySymbols(props)
      ];
      for (const p of propKeys) {
        this.createProperty(p, props[p]);
      }
    }
    this.elementStyles = this.finalizeStyles(this.styles);
    {
      const warnRemovedOrRenamed = (name2, renamed = false) => {
        if (this.prototype.hasOwnProperty(name2)) {
          issueWarning$2(renamed ? "renamed-api" : "removed-api", `\`${name2}\` is implemented on class ${this.name}. It has been ${renamed ? "renamed" : "removed"} in this version of LitElement.`);
        }
      };
      warnRemovedOrRenamed("initialize");
      warnRemovedOrRenamed("requestUpdateInternal");
      warnRemovedOrRenamed("_getUpdateComplete", true);
    }
    return true;
  }
  /**
   * Takes the styles the user supplied via the `static styles` property and
   * returns the array of styles to apply to the element.
   * Override this method to integrate into a style management system.
   *
   * Styles are deduplicated preserving the _last_ instance in the list. This
   * is a performance optimization to avoid duplicated styles that can occur
   * especially when composing via subclassing. The last item is kept to try
   * to preserve the cascade order with the assumption that it's most important
   * that last added styles override previous styles.
   *
   * @nocollapse
   * @category styles
   */
  static finalizeStyles(styles2) {
    const elementStyles = [];
    if (Array.isArray(styles2)) {
      const set2 = new Set(styles2.flat(Infinity).reverse());
      for (const s of set2) {
        elementStyles.unshift(getCompatibleStyle(s));
      }
    } else if (styles2 !== void 0) {
      elementStyles.push(getCompatibleStyle(styles2));
    }
    return elementStyles;
  }
  /**
   * Returns the property name for the given attribute `name`.
   * @nocollapse
   */
  static __attributeNameForProperty(name2, options) {
    const attribute = options.attribute;
    return attribute === false ? void 0 : typeof attribute === "string" ? attribute : typeof name2 === "string" ? name2.toLowerCase() : void 0;
  }
  /**
   * Internal only override point for customizing work done when elements
   * are constructed.
   *
   * @internal
   */
  _initialize() {
    var _a2;
    this.__updatePromise = new Promise((res) => this.enableUpdating = res);
    this._$changedProperties = /* @__PURE__ */ new Map();
    this.__saveInstanceProperties();
    this.requestUpdate();
    (_a2 = this.constructor._initializers) === null || _a2 === void 0 ? void 0 : _a2.forEach((i) => i(this));
  }
  /**
   * Registers a `ReactiveController` to participate in the element's reactive
   * update cycle. The element automatically calls into any registered
   * controllers during its lifecycle callbacks.
   *
   * If the element is connected when `addController()` is called, the
   * controller's `hostConnected()` callback will be immediately called.
   * @category controllers
   */
  addController(controller) {
    var _a2, _b2;
    ((_a2 = this.__controllers) !== null && _a2 !== void 0 ? _a2 : this.__controllers = []).push(controller);
    if (this.renderRoot !== void 0 && this.isConnected) {
      (_b2 = controller.hostConnected) === null || _b2 === void 0 ? void 0 : _b2.call(controller);
    }
  }
  /**
   * Removes a `ReactiveController` from the element.
   * @category controllers
   */
  removeController(controller) {
    var _a2;
    (_a2 = this.__controllers) === null || _a2 === void 0 ? void 0 : _a2.splice(this.__controllers.indexOf(controller) >>> 0, 1);
  }
  /**
   * Fixes any properties set on the instance before upgrade time.
   * Otherwise these would shadow the accessor and break these properties.
   * The properties are stored in a Map which is played back after the
   * constructor runs. Note, on very old versions of Safari (<=9) or Chrome
   * (<=41), properties created for native platform properties like (`id` or
   * `name`) may not have default values set in the element constructor. On
   * these browsers native properties appear on instances and therefore their
   * default value will overwrite any element default (e.g. if the element sets
   * this.id = 'id' in the constructor, the 'id' will become '' since this is
   * the native platform default).
   */
  __saveInstanceProperties() {
    this.constructor.elementProperties.forEach((_v, p) => {
      if (this.hasOwnProperty(p)) {
        this.__instanceProperties.set(p, this[p]);
        delete this[p];
      }
    });
  }
  /**
   * Returns the node into which the element should render and by default
   * creates and returns an open shadowRoot. Implement to customize where the
   * element's DOM is rendered. For example, to render into the element's
   * childNodes, return `this`.
   *
   * @return Returns a node into which to render.
   * @category rendering
   */
  createRenderRoot() {
    var _a2;
    const renderRoot = (_a2 = this.shadowRoot) !== null && _a2 !== void 0 ? _a2 : this.attachShadow(this.constructor.shadowRootOptions);
    adoptStyles(renderRoot, this.constructor.elementStyles);
    return renderRoot;
  }
  /**
   * On first connection, creates the element's renderRoot, sets up
   * element styling, and enables updating.
   * @category lifecycle
   */
  connectedCallback() {
    var _a2;
    if (this.renderRoot === void 0) {
      this.renderRoot = this.createRenderRoot();
    }
    this.enableUpdating(true);
    (_a2 = this.__controllers) === null || _a2 === void 0 ? void 0 : _a2.forEach((c) => {
      var _a3;
      return (_a3 = c.hostConnected) === null || _a3 === void 0 ? void 0 : _a3.call(c);
    });
  }
  /**
   * Note, this method should be considered final and not overridden. It is
   * overridden on the element instance with a function that triggers the first
   * update.
   * @category updates
   */
  enableUpdating(_requestedUpdate) {
  }
  /**
   * Allows for `super.disconnectedCallback()` in extensions while
   * reserving the possibility of making non-breaking feature additions
   * when disconnecting at some point in the future.
   * @category lifecycle
   */
  disconnectedCallback() {
    var _a2;
    (_a2 = this.__controllers) === null || _a2 === void 0 ? void 0 : _a2.forEach((c) => {
      var _a3;
      return (_a3 = c.hostDisconnected) === null || _a3 === void 0 ? void 0 : _a3.call(c);
    });
  }
  /**
   * Synchronizes property values when attributes change.
   *
   * Specifically, when an attribute is set, the corresponding property is set.
   * You should rarely need to implement this callback. If this method is
   * overridden, `super.attributeChangedCallback(name, _old, value)` must be
   * called.
   *
   * See [using the lifecycle callbacks](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#using_the_lifecycle_callbacks)
   * on MDN for more information about the `attributeChangedCallback`.
   * @category attributes
   */
  attributeChangedCallback(name2, _old, value) {
    this._$attributeToProperty(name2, value);
  }
  __propertyToAttribute(name2, value, options = defaultPropertyDeclaration) {
    var _a2;
    const attr = this.constructor.__attributeNameForProperty(name2, options);
    if (attr !== void 0 && options.reflect === true) {
      const converter = ((_a2 = options.converter) === null || _a2 === void 0 ? void 0 : _a2.toAttribute) !== void 0 ? options.converter : defaultConverter;
      const attrValue = converter.toAttribute(value, options.type);
      if (this.constructor.enabledWarnings.indexOf("migration") >= 0 && attrValue === void 0) {
        issueWarning$2("undefined-attribute-value", `The attribute value for the ${name2} property is undefined on element ${this.localName}. The attribute will be removed, but in the previous version of \`ReactiveElement\`, the attribute would not have changed.`);
      }
      this.__reflectingProperty = name2;
      if (attrValue == null) {
        this.removeAttribute(attr);
      } else {
        this.setAttribute(attr, attrValue);
      }
      this.__reflectingProperty = null;
    }
  }
  /** @internal */
  _$attributeToProperty(name2, value) {
    var _a2;
    const ctor = this.constructor;
    const propName = ctor.__attributeToPropertyMap.get(name2);
    if (propName !== void 0 && this.__reflectingProperty !== propName) {
      const options = ctor.getPropertyOptions(propName);
      const converter = typeof options.converter === "function" ? { fromAttribute: options.converter } : ((_a2 = options.converter) === null || _a2 === void 0 ? void 0 : _a2.fromAttribute) !== void 0 ? options.converter : defaultConverter;
      this.__reflectingProperty = propName;
      this[propName] = converter.fromAttribute(
        value,
        options.type
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      );
      this.__reflectingProperty = null;
    }
  }
  /**
   * Requests an update which is processed asynchronously. This should be called
   * when an element should update based on some state not triggered by setting
   * a reactive property. In this case, pass no arguments. It should also be
   * called when manually implementing a property setter. In this case, pass the
   * property `name` and `oldValue` to ensure that any configured property
   * options are honored.
   *
   * @param name name of requesting property
   * @param oldValue old value of requesting property
   * @param options property options to use instead of the previously
   *     configured options
   * @category updates
   */
  requestUpdate(name2, oldValue, options) {
    let shouldRequestUpdate = true;
    if (name2 !== void 0) {
      options = options || this.constructor.getPropertyOptions(name2);
      const hasChanged = options.hasChanged || notEqual;
      if (hasChanged(this[name2], oldValue)) {
        if (!this._$changedProperties.has(name2)) {
          this._$changedProperties.set(name2, oldValue);
        }
        if (options.reflect === true && this.__reflectingProperty !== name2) {
          if (this.__reflectingProperties === void 0) {
            this.__reflectingProperties = /* @__PURE__ */ new Map();
          }
          this.__reflectingProperties.set(name2, options);
        }
      } else {
        shouldRequestUpdate = false;
      }
    }
    if (!this.isUpdatePending && shouldRequestUpdate) {
      this.__updatePromise = this.__enqueueUpdate();
    }
    return requestUpdateThenable(this.localName);
  }
  /**
   * Sets up the element to asynchronously update.
   */
  async __enqueueUpdate() {
    this.isUpdatePending = true;
    try {
      await this.__updatePromise;
    } catch (e) {
      Promise.reject(e);
    }
    const result2 = this.scheduleUpdate();
    if (result2 != null) {
      await result2;
    }
    return !this.isUpdatePending;
  }
  /**
   * Schedules an element update. You can override this method to change the
   * timing of updates by returning a Promise. The update will await the
   * returned Promise, and you should resolve the Promise to allow the update
   * to proceed. If this method is overridden, `super.scheduleUpdate()`
   * must be called.
   *
   * For instance, to schedule updates to occur just before the next frame:
   *
   * ```ts
   * override protected async scheduleUpdate(): Promise<unknown> {
   *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
   *   super.scheduleUpdate();
   * }
   * ```
   * @category updates
   */
  scheduleUpdate() {
    return this.performUpdate();
  }
  /**
   * Performs an element update. Note, if an exception is thrown during the
   * update, `firstUpdated` and `updated` will not be called.
   *
   * Call `performUpdate()` to immediately process a pending update. This should
   * generally not be needed, but it can be done in rare cases when you need to
   * update synchronously.
   *
   * Note: To ensure `performUpdate()` synchronously completes a pending update,
   * it should not be overridden. In LitElement 2.x it was suggested to override
   * `performUpdate()` to also customizing update scheduling. Instead, you should now
   * override `scheduleUpdate()`. For backwards compatibility with LitElement 2.x,
   * scheduling updates via `performUpdate()` continues to work, but will make
   * also calling `performUpdate()` to synchronously process updates difficult.
   *
   * @category updates
   */
  performUpdate() {
    var _a2, _b2;
    if (!this.isUpdatePending) {
      return;
    }
    debugLogEvent$1 === null || debugLogEvent$1 === void 0 ? void 0 : debugLogEvent$1({ kind: "update" });
    if (!this.hasUpdated) {
      {
        const shadowedProperties = [];
        (_a2 = this.constructor.__reactivePropertyKeys) === null || _a2 === void 0 ? void 0 : _a2.forEach((p) => {
          var _a3;
          if (this.hasOwnProperty(p) && !((_a3 = this.__instanceProperties) === null || _a3 === void 0 ? void 0 : _a3.has(p))) {
            shadowedProperties.push(p);
          }
        });
        if (shadowedProperties.length) {
          throw new Error(`The following properties on element ${this.localName} will not trigger updates as expected because they are set using class fields: ${shadowedProperties.join(", ")}. Native class fields and some compiled output will overwrite accessors used for detecting changes. See https://lit.dev/msg/class-field-shadowing for more information.`);
        }
      }
    }
    if (this.__instanceProperties) {
      this.__instanceProperties.forEach((v2, p) => this[p] = v2);
      this.__instanceProperties = void 0;
    }
    let shouldUpdate = false;
    const changedProperties = this._$changedProperties;
    try {
      shouldUpdate = this.shouldUpdate(changedProperties);
      if (shouldUpdate) {
        this.willUpdate(changedProperties);
        (_b2 = this.__controllers) === null || _b2 === void 0 ? void 0 : _b2.forEach((c) => {
          var _a3;
          return (_a3 = c.hostUpdate) === null || _a3 === void 0 ? void 0 : _a3.call(c);
        });
        this.update(changedProperties);
      } else {
        this.__markUpdated();
      }
    } catch (e) {
      shouldUpdate = false;
      this.__markUpdated();
      throw e;
    }
    if (shouldUpdate) {
      this._$didUpdate(changedProperties);
    }
  }
  /**
   * Invoked before `update()` to compute values needed during the update.
   *
   * Implement `willUpdate` to compute property values that depend on other
   * properties and are used in the rest of the update process.
   *
   * ```ts
   * willUpdate(changedProperties) {
   *   // only need to check changed properties for an expensive computation.
   *   if (changedProperties.has('firstName') || changedProperties.has('lastName')) {
   *     this.sha = computeSHA(`${this.firstName} ${this.lastName}`);
   *   }
   * }
   *
   * render() {
   *   return html`SHA: ${this.sha}`;
   * }
   * ```
   *
   * @category updates
   */
  willUpdate(_changedProperties) {
  }
  // Note, this is an override point for polyfill-support.
  // @internal
  _$didUpdate(changedProperties) {
    var _a2;
    (_a2 = this.__controllers) === null || _a2 === void 0 ? void 0 : _a2.forEach((c) => {
      var _a3;
      return (_a3 = c.hostUpdated) === null || _a3 === void 0 ? void 0 : _a3.call(c);
    });
    if (!this.hasUpdated) {
      this.hasUpdated = true;
      this.firstUpdated(changedProperties);
    }
    this.updated(changedProperties);
    if (this.isUpdatePending && this.constructor.enabledWarnings.indexOf("change-in-update") >= 0) {
      issueWarning$2("change-in-update", `Element ${this.localName} scheduled an update (generally because a property was set) after an update completed, causing a new update to be scheduled. This is inefficient and should be avoided unless the next update can only be scheduled as a side effect of the previous update.`);
    }
  }
  __markUpdated() {
    this._$changedProperties = /* @__PURE__ */ new Map();
    this.isUpdatePending = false;
  }
  /**
   * Returns a Promise that resolves when the element has completed updating.
   * The Promise value is a boolean that is `true` if the element completed the
   * update without triggering another update. The Promise result is `false` if
   * a property was set inside `updated()`. If the Promise is rejected, an
   * exception was thrown during the update.
   *
   * To await additional asynchronous work, override the `getUpdateComplete`
   * method. For example, it is sometimes useful to await a rendered element
   * before fulfilling this Promise. To do this, first await
   * `super.getUpdateComplete()`, then any subsequent state.
   *
   * @return A promise of a boolean that resolves to true if the update completed
   *     without triggering another update.
   * @category updates
   */
  get updateComplete() {
    return this.getUpdateComplete();
  }
  /**
   * Override point for the `updateComplete` promise.
   *
   * It is not safe to override the `updateComplete` getter directly due to a
   * limitation in TypeScript which means it is not possible to call a
   * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
   * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
   * This method should be overridden instead. For example:
   *
   * ```ts
   * class MyElement extends LitElement {
   *   override async getUpdateComplete() {
   *     const result = await super.getUpdateComplete();
   *     await this._myChild.updateComplete;
   *     return result;
   *   }
   * }
   * ```
   *
   * @return A promise of a boolean that resolves to true if the update completed
   *     without triggering another update.
   * @category updates
   */
  getUpdateComplete() {
    return this.__updatePromise;
  }
  /**
   * Controls whether or not `update()` should be called when the element requests
   * an update. By default, this method always returns `true`, but this can be
   * customized to control when to update.
   *
   * @param _changedProperties Map of changed properties with old values
   * @category updates
   */
  shouldUpdate(_changedProperties) {
    return true;
  }
  /**
   * Updates the element. This method reflects property values to attributes.
   * It can be overridden to render and keep updated element DOM.
   * Setting properties inside this method will *not* trigger
   * another update.
   *
   * @param _changedProperties Map of changed properties with old values
   * @category updates
   */
  update(_changedProperties) {
    if (this.__reflectingProperties !== void 0) {
      this.__reflectingProperties.forEach((v2, k) => this.__propertyToAttribute(k, this[k], v2));
      this.__reflectingProperties = void 0;
    }
    this.__markUpdated();
  }
  /**
   * Invoked whenever the element is updated. Implement to perform
   * post-updating tasks via DOM APIs, for example, focusing an element.
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * @param _changedProperties Map of changed properties with old values
   * @category updates
   */
  updated(_changedProperties) {
  }
  /**
   * Invoked when the element is first updated. Implement to perform one time
   * work on the element after update.
   *
   * ```ts
   * firstUpdated() {
   *   this.renderRoot.getElementById('my-text-area').focus();
   * }
   * ```
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * @param _changedProperties Map of changed properties with old values
   * @category updates
   */
  firstUpdated(_changedProperties) {
  }
}
_e$1 = finalized;
ReactiveElement[_e$1] = true;
ReactiveElement.elementProperties = /* @__PURE__ */ new Map();
ReactiveElement.elementStyles = [];
ReactiveElement.shadowRootOptions = { mode: "open" };
polyfillSupport$2 === null || polyfillSupport$2 === void 0 ? void 0 : polyfillSupport$2({ ReactiveElement });
{
  ReactiveElement.enabledWarnings = ["change-in-update"];
  const ensureOwnWarnings = function(ctor) {
    if (!ctor.hasOwnProperty(JSCompiler_renameProperty("enabledWarnings"))) {
      ctor.enabledWarnings = ctor.enabledWarnings.slice();
    }
  };
  ReactiveElement.enableWarning = function(warning) {
    ensureOwnWarnings(this);
    if (this.enabledWarnings.indexOf(warning) < 0) {
      this.enabledWarnings.push(warning);
    }
  };
  ReactiveElement.disableWarning = function(warning) {
    ensureOwnWarnings(this);
    const i = this.enabledWarnings.indexOf(warning);
    if (i >= 0) {
      this.enabledWarnings.splice(i, 1);
    }
  };
}
((_d$2 = global$3.reactiveElementVersions) !== null && _d$2 !== void 0 ? _d$2 : global$3.reactiveElementVersions = []).push("1.6.2");
if (global$3.reactiveElementVersions.length > 1) {
  issueWarning$2("multiple-versions", `Multiple versions of Lit loaded. Loading multiple versions is not recommended.`);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var _a$3, _b$1, _c$1, _d$1;
const global$2 = window;
const debugLogEvent = (event) => {
  const shouldEmit = global$2.emitLitDebugLogEvents;
  if (!shouldEmit) {
    return;
  }
  global$2.dispatchEvent(new CustomEvent("lit-debug", {
    detail: event
  }));
};
let debugLogRenderId = 0;
let issueWarning$1;
{
  (_a$3 = global$2.litIssuedWarnings) !== null && _a$3 !== void 0 ? _a$3 : global$2.litIssuedWarnings = /* @__PURE__ */ new Set();
  issueWarning$1 = (code3, warning) => {
    warning += code3 ? ` See https://lit.dev/msg/${code3} for more information.` : "";
    if (!global$2.litIssuedWarnings.has(warning)) {
      console.warn(warning);
      global$2.litIssuedWarnings.add(warning);
    }
  };
  issueWarning$1("dev-mode", `Lit is in dev mode. Not recommended for production!`);
}
const wrap = ((_b$1 = global$2.ShadyDOM) === null || _b$1 === void 0 ? void 0 : _b$1.inUse) && ((_c$1 = global$2.ShadyDOM) === null || _c$1 === void 0 ? void 0 : _c$1.noPatch) === true ? global$2.ShadyDOM.wrap : (node) => node;
const trustedTypes = global$2.trustedTypes;
const policy = trustedTypes ? trustedTypes.createPolicy("lit-html", {
  createHTML: (s) => s
}) : void 0;
const identityFunction = (value) => value;
const noopSanitizer = (_node, _name, _type) => identityFunction;
const setSanitizer = (newSanitizer) => {
  if (sanitizerFactoryInternal !== noopSanitizer) {
    throw new Error(`Attempted to overwrite existing lit-html security policy. setSanitizeDOMValueFactory should be called at most once.`);
  }
  sanitizerFactoryInternal = newSanitizer;
};
const _testOnlyClearSanitizerFactoryDoNotCallOrElse = () => {
  sanitizerFactoryInternal = noopSanitizer;
};
const createSanitizer = (node, name2, type) => {
  return sanitizerFactoryInternal(node, name2, type);
};
const boundAttributeSuffix = "$lit$";
const marker = `lit$${String(Math.random()).slice(9)}$`;
const markerMatch = "?" + marker;
const nodeMarker = `<${markerMatch}>`;
const d = document;
const createMarker = () => d.createComment("");
const isPrimitive = (value) => value === null || typeof value != "object" && typeof value != "function";
const isArray = Array.isArray;
const isIterable = (value) => isArray(value) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
typeof (value === null || value === void 0 ? void 0 : value[Symbol.iterator]) === "function";
const SPACE_CHAR = `[ 	
\f\r]`;
const ATTR_VALUE_CHAR = `[^ 	
\f\r"'\`<>=]`;
const NAME_CHAR = `[^\\s"'>=/]`;
const textEndRegex = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
const COMMENT_START = 1;
const TAG_NAME = 2;
const DYNAMIC_TAG_NAME = 3;
const commentEndRegex = /-->/g;
const comment2EndRegex = />/g;
const tagEndRegex = new RegExp(`>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|("|')|))|$)`, "g");
const ENTIRE_MATCH = 0;
const ATTRIBUTE_NAME = 1;
const SPACES_AND_EQUALS = 2;
const QUOTE_CHAR = 3;
const singleQuoteAttrEndRegex = /'/g;
const doubleQuoteAttrEndRegex = /"/g;
const rawTextElement = /^(?:script|style|textarea|title)$/i;
const HTML_RESULT$1 = 1;
const SVG_RESULT = 2;
const ATTRIBUTE_PART = 1;
const CHILD_PART = 2;
const PROPERTY_PART = 3;
const BOOLEAN_ATTRIBUTE_PART = 4;
const EVENT_PART = 5;
const ELEMENT_PART = 6;
const COMMENT_PART = 7;
const tag = (type) => (strings, ...values) => {
  if (strings.some((s) => s === void 0)) {
    console.warn("Some template strings are undefined.\nThis is probably caused by illegal octal escape sequences.");
  }
  return {
    // This property needs to remain unminified.
    ["_$litType$"]: type,
    strings,
    values
  };
};
const html = tag(HTML_RESULT$1);
const noChange = Symbol.for("lit-noChange");
const nothing = Symbol.for("lit-nothing");
const templateCache = /* @__PURE__ */ new WeakMap();
const walker = d.createTreeWalker(d, 129, null, false);
let sanitizerFactoryInternal = noopSanitizer;
function trustFromTemplateString(tsa, stringFromTSA) {
  if (!Array.isArray(tsa) || !tsa.hasOwnProperty("raw")) {
    let message = "invalid template strings array";
    {
      message = `
          Internal Error: expected template strings to be an array
          with a 'raw' field. Faking a template strings array by
          calling html or svg like an ordinary function is effectively
          the same as calling unsafeHtml and can lead to major security
          issues, e.g. opening your code up to XSS attacks.
          If you're using the html or svg tagged template functions normally
          and still seeing this error, please file a bug at
          https://github.com/lit/lit/issues/new?template=bug_report.md
          and include information about your build tooling, if any.
        `.trim().replace(/\n */g, "\n");
    }
    throw new Error(message);
  }
  return policy !== void 0 ? policy.createHTML(stringFromTSA) : stringFromTSA;
}
const getTemplateHtml = (strings, type) => {
  const l = strings.length - 1;
  const attrNames = [];
  let html2 = type === SVG_RESULT ? "<svg>" : "";
  let rawTextEndRegex;
  let regex2 = textEndRegex;
  for (let i = 0; i < l; i++) {
    const s = strings[i];
    let attrNameEndIndex = -1;
    let attrName;
    let lastIndex = 0;
    let match2;
    while (lastIndex < s.length) {
      regex2.lastIndex = lastIndex;
      match2 = regex2.exec(s);
      if (match2 === null) {
        break;
      }
      lastIndex = regex2.lastIndex;
      if (regex2 === textEndRegex) {
        if (match2[COMMENT_START] === "!--") {
          regex2 = commentEndRegex;
        } else if (match2[COMMENT_START] !== void 0) {
          regex2 = comment2EndRegex;
        } else if (match2[TAG_NAME] !== void 0) {
          if (rawTextElement.test(match2[TAG_NAME])) {
            rawTextEndRegex = new RegExp(`</${match2[TAG_NAME]}`, "g");
          }
          regex2 = tagEndRegex;
        } else if (match2[DYNAMIC_TAG_NAME] !== void 0) {
          {
            throw new Error("Bindings in tag names are not supported. Please use static templates instead. See https://lit.dev/docs/templates/expressions/#static-expressions");
          }
        }
      } else if (regex2 === tagEndRegex) {
        if (match2[ENTIRE_MATCH] === ">") {
          regex2 = rawTextEndRegex !== null && rawTextEndRegex !== void 0 ? rawTextEndRegex : textEndRegex;
          attrNameEndIndex = -1;
        } else if (match2[ATTRIBUTE_NAME] === void 0) {
          attrNameEndIndex = -2;
        } else {
          attrNameEndIndex = regex2.lastIndex - match2[SPACES_AND_EQUALS].length;
          attrName = match2[ATTRIBUTE_NAME];
          regex2 = match2[QUOTE_CHAR] === void 0 ? tagEndRegex : match2[QUOTE_CHAR] === '"' ? doubleQuoteAttrEndRegex : singleQuoteAttrEndRegex;
        }
      } else if (regex2 === doubleQuoteAttrEndRegex || regex2 === singleQuoteAttrEndRegex) {
        regex2 = tagEndRegex;
      } else if (regex2 === commentEndRegex || regex2 === comment2EndRegex) {
        regex2 = textEndRegex;
      } else {
        regex2 = tagEndRegex;
        rawTextEndRegex = void 0;
      }
    }
    {
      console.assert(attrNameEndIndex === -1 || regex2 === tagEndRegex || regex2 === singleQuoteAttrEndRegex || regex2 === doubleQuoteAttrEndRegex, "unexpected parse state B");
    }
    const end = regex2 === tagEndRegex && strings[i + 1].startsWith("/>") ? " " : "";
    html2 += regex2 === textEndRegex ? s + nodeMarker : attrNameEndIndex >= 0 ? (attrNames.push(attrName), s.slice(0, attrNameEndIndex) + boundAttributeSuffix + s.slice(attrNameEndIndex)) + marker + end : s + marker + (attrNameEndIndex === -2 ? (attrNames.push(void 0), i) : end);
  }
  const htmlResult = html2 + (strings[l] || "<?>") + (type === SVG_RESULT ? "</svg>" : "");
  return [trustFromTemplateString(strings, htmlResult), attrNames];
};
class Template {
  constructor({ strings, ["_$litType$"]: type }, options) {
    this.parts = [];
    let node;
    let nodeIndex = 0;
    let attrNameIndex = 0;
    const partCount = strings.length - 1;
    const parts = this.parts;
    const [html2, attrNames] = getTemplateHtml(strings, type);
    this.el = Template.createElement(html2, options);
    walker.currentNode = this.el.content;
    if (type === SVG_RESULT) {
      const content = this.el.content;
      const svgElement = content.firstChild;
      svgElement.remove();
      content.append(...svgElement.childNodes);
    }
    while ((node = walker.nextNode()) !== null && parts.length < partCount) {
      if (node.nodeType === 1) {
        {
          const tag2 = node.localName;
          if (/^(?:textarea|template)$/i.test(tag2) && node.innerHTML.includes(marker)) {
            const m = `Expressions are not supported inside \`${tag2}\` elements. See https://lit.dev/msg/expression-in-${tag2} for more information.`;
            if (tag2 === "template") {
              throw new Error(m);
            } else
              issueWarning$1("", m);
          }
        }
        if (node.hasAttributes()) {
          const attrsToRemove = [];
          for (const name2 of node.getAttributeNames()) {
            if (name2.endsWith(boundAttributeSuffix) || name2.startsWith(marker)) {
              const realName = attrNames[attrNameIndex++];
              attrsToRemove.push(name2);
              if (realName !== void 0) {
                const value = node.getAttribute(realName.toLowerCase() + boundAttributeSuffix);
                const statics = value.split(marker);
                const m = /([.?@])?(.*)/.exec(realName);
                parts.push({
                  type: ATTRIBUTE_PART,
                  index: nodeIndex,
                  name: m[2],
                  strings: statics,
                  ctor: m[1] === "." ? PropertyPart : m[1] === "?" ? BooleanAttributePart : m[1] === "@" ? EventPart : AttributePart
                });
              } else {
                parts.push({
                  type: ELEMENT_PART,
                  index: nodeIndex
                });
              }
            }
          }
          for (const name2 of attrsToRemove) {
            node.removeAttribute(name2);
          }
        }
        if (rawTextElement.test(node.tagName)) {
          const strings2 = node.textContent.split(marker);
          const lastIndex = strings2.length - 1;
          if (lastIndex > 0) {
            node.textContent = trustedTypes ? trustedTypes.emptyScript : "";
            for (let i = 0; i < lastIndex; i++) {
              node.append(strings2[i], createMarker());
              walker.nextNode();
              parts.push({ type: CHILD_PART, index: ++nodeIndex });
            }
            node.append(strings2[lastIndex], createMarker());
          }
        }
      } else if (node.nodeType === 8) {
        const data2 = node.data;
        if (data2 === markerMatch) {
          parts.push({ type: CHILD_PART, index: nodeIndex });
        } else {
          let i = -1;
          while ((i = node.data.indexOf(marker, i + 1)) !== -1) {
            parts.push({ type: COMMENT_PART, index: nodeIndex });
            i += marker.length - 1;
          }
        }
      }
      nodeIndex++;
    }
    debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
      kind: "template prep",
      template: this,
      clonableTemplate: this.el,
      parts: this.parts,
      strings
    });
  }
  // Overridden via `litHtmlPolyfillSupport` to provide platform support.
  /** @nocollapse */
  static createElement(html2, _options) {
    const el2 = d.createElement("template");
    el2.innerHTML = html2;
    return el2;
  }
}
function resolveDirective(part, value, parent = part, attributeIndex) {
  var _a2, _b2, _c2;
  var _d2;
  if (value === noChange) {
    return value;
  }
  let currentDirective = attributeIndex !== void 0 ? (_a2 = parent.__directives) === null || _a2 === void 0 ? void 0 : _a2[attributeIndex] : parent.__directive;
  const nextDirectiveConstructor = isPrimitive(value) ? void 0 : (
    // This property needs to remain unminified.
    value["_$litDirective$"]
  );
  if ((currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective.constructor) !== nextDirectiveConstructor) {
    (_b2 = currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective["_$notifyDirectiveConnectionChanged"]) === null || _b2 === void 0 ? void 0 : _b2.call(currentDirective, false);
    if (nextDirectiveConstructor === void 0) {
      currentDirective = void 0;
    } else {
      currentDirective = new nextDirectiveConstructor(part);
      currentDirective._$initialize(part, parent, attributeIndex);
    }
    if (attributeIndex !== void 0) {
      ((_c2 = (_d2 = parent).__directives) !== null && _c2 !== void 0 ? _c2 : _d2.__directives = [])[attributeIndex] = currentDirective;
    } else {
      parent.__directive = currentDirective;
    }
  }
  if (currentDirective !== void 0) {
    value = resolveDirective(part, currentDirective._$resolve(part, value.values), currentDirective, attributeIndex);
  }
  return value;
}
class TemplateInstance {
  constructor(template2, parent) {
    this._$parts = [];
    this._$disconnectableChildren = void 0;
    this._$template = template2;
    this._$parent = parent;
  }
  // Called by ChildPart parentNode getter
  get parentNode() {
    return this._$parent.parentNode;
  }
  // See comment in Disconnectable interface for why this is a getter
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  // This method is separate from the constructor because we need to return a
  // DocumentFragment and we don't want to hold onto it with an instance field.
  _clone(options) {
    var _a2;
    const { el: { content }, parts } = this._$template;
    const fragment = ((_a2 = options === null || options === void 0 ? void 0 : options.creationScope) !== null && _a2 !== void 0 ? _a2 : d).importNode(content, true);
    walker.currentNode = fragment;
    let node = walker.nextNode();
    let nodeIndex = 0;
    let partIndex = 0;
    let templatePart = parts[0];
    while (templatePart !== void 0) {
      if (nodeIndex === templatePart.index) {
        let part;
        if (templatePart.type === CHILD_PART) {
          part = new ChildPart(node, node.nextSibling, this, options);
        } else if (templatePart.type === ATTRIBUTE_PART) {
          part = new templatePart.ctor(node, templatePart.name, templatePart.strings, this, options);
        } else if (templatePart.type === ELEMENT_PART) {
          part = new ElementPart(node, this, options);
        }
        this._$parts.push(part);
        templatePart = parts[++partIndex];
      }
      if (nodeIndex !== (templatePart === null || templatePart === void 0 ? void 0 : templatePart.index)) {
        node = walker.nextNode();
        nodeIndex++;
      }
    }
    walker.currentNode = d;
    return fragment;
  }
  _update(values) {
    let i = 0;
    for (const part of this._$parts) {
      if (part !== void 0) {
        debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
          kind: "set part",
          part,
          value: values[i],
          valueIndex: i,
          values,
          templateInstance: this
        });
        if (part.strings !== void 0) {
          part._$setValue(values, part, i);
          i += part.strings.length - 2;
        } else {
          part._$setValue(values[i]);
        }
      }
      i++;
    }
  }
}
class ChildPart {
  constructor(startNode, endNode, parent, options) {
    var _a2;
    this.type = CHILD_PART;
    this._$committedValue = nothing;
    this._$disconnectableChildren = void 0;
    this._$startNode = startNode;
    this._$endNode = endNode;
    this._$parent = parent;
    this.options = options;
    this.__isConnected = (_a2 = options === null || options === void 0 ? void 0 : options.isConnected) !== null && _a2 !== void 0 ? _a2 : true;
    {
      this._textSanitizer = void 0;
    }
  }
  // See comment in Disconnectable interface for why this is a getter
  get _$isConnected() {
    var _a2, _b2;
    return (_b2 = (_a2 = this._$parent) === null || _a2 === void 0 ? void 0 : _a2._$isConnected) !== null && _b2 !== void 0 ? _b2 : this.__isConnected;
  }
  /**
   * The parent node into which the part renders its content.
   *
   * A ChildPart's content consists of a range of adjacent child nodes of
   * `.parentNode`, possibly bordered by 'marker nodes' (`.startNode` and
   * `.endNode`).
   *
   * - If both `.startNode` and `.endNode` are non-null, then the part's content
   * consists of all siblings between `.startNode` and `.endNode`, exclusively.
   *
   * - If `.startNode` is non-null but `.endNode` is null, then the part's
   * content consists of all siblings following `.startNode`, up to and
   * including the last child of `.parentNode`. If `.endNode` is non-null, then
   * `.startNode` will always be non-null.
   *
   * - If both `.endNode` and `.startNode` are null, then the part's content
   * consists of all child nodes of `.parentNode`.
   */
  get parentNode() {
    let parentNode = wrap(this._$startNode).parentNode;
    const parent = this._$parent;
    if (parent !== void 0 && (parentNode === null || parentNode === void 0 ? void 0 : parentNode.nodeType) === 11) {
      parentNode = parent.parentNode;
    }
    return parentNode;
  }
  /**
   * The part's leading marker node, if any. See `.parentNode` for more
   * information.
   */
  get startNode() {
    return this._$startNode;
  }
  /**
   * The part's trailing marker node, if any. See `.parentNode` for more
   * information.
   */
  get endNode() {
    return this._$endNode;
  }
  _$setValue(value, directiveParent = this) {
    var _a2;
    if (this.parentNode === null) {
      throw new Error(`This \`ChildPart\` has no \`parentNode\` and therefore cannot accept a value. This likely means the element containing the part was manipulated in an unsupported way outside of Lit's control such that the part's marker nodes were ejected from DOM. For example, setting the element's \`innerHTML\` or \`textContent\` can do this.`);
    }
    value = resolveDirective(this, value, directiveParent);
    if (isPrimitive(value)) {
      if (value === nothing || value == null || value === "") {
        if (this._$committedValue !== nothing) {
          debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
            kind: "commit nothing to child",
            start: this._$startNode,
            end: this._$endNode,
            parent: this._$parent,
            options: this.options
          });
          this._$clear();
        }
        this._$committedValue = nothing;
      } else if (value !== this._$committedValue && value !== noChange) {
        this._commitText(value);
      }
    } else if (value["_$litType$"] !== void 0) {
      this._commitTemplateResult(value);
    } else if (value.nodeType !== void 0) {
      if (((_a2 = this.options) === null || _a2 === void 0 ? void 0 : _a2.host) === value) {
        this._commitText(`[probable mistake: rendered a template's host in itself (commonly caused by writing \${this} in a template]`);
        console.warn(`Attempted to render the template host`, value, `inside itself. This is almost always a mistake, and in dev mode `, `we render some warning text. In production however, we'll `, `render it, which will usually result in an error, and sometimes `, `in the element disappearing from the DOM.`);
        return;
      }
      this._commitNode(value);
    } else if (isIterable(value)) {
      this._commitIterable(value);
    } else {
      this._commitText(value);
    }
  }
  _insert(node) {
    return wrap(wrap(this._$startNode).parentNode).insertBefore(node, this._$endNode);
  }
  _commitNode(value) {
    var _a2;
    if (this._$committedValue !== value) {
      this._$clear();
      if (sanitizerFactoryInternal !== noopSanitizer) {
        const parentNodeName = (_a2 = this._$startNode.parentNode) === null || _a2 === void 0 ? void 0 : _a2.nodeName;
        if (parentNodeName === "STYLE" || parentNodeName === "SCRIPT") {
          let message = "Forbidden";
          {
            if (parentNodeName === "STYLE") {
              message = `Lit does not support binding inside style nodes. This is a security risk, as style injection attacks can exfiltrate data and spoof UIs. Consider instead using css\`...\` literals to compose styles, and make do dynamic styling with css custom properties, ::parts, <slot>s, and by mutating the DOM rather than stylesheets.`;
            } else {
              message = `Lit does not support binding inside script nodes. This is a security risk, as it could allow arbitrary code execution.`;
            }
          }
          throw new Error(message);
        }
      }
      debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
        kind: "commit node",
        start: this._$startNode,
        parent: this._$parent,
        value,
        options: this.options
      });
      this._$committedValue = this._insert(value);
    }
  }
  _commitText(value) {
    if (this._$committedValue !== nothing && isPrimitive(this._$committedValue)) {
      const node = wrap(this._$startNode).nextSibling;
      {
        if (this._textSanitizer === void 0) {
          this._textSanitizer = createSanitizer(node, "data", "property");
        }
        value = this._textSanitizer(value);
      }
      debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
        kind: "commit text",
        node,
        value,
        options: this.options
      });
      node.data = value;
    } else {
      {
        const textNode = d.createTextNode("");
        this._commitNode(textNode);
        if (this._textSanitizer === void 0) {
          this._textSanitizer = createSanitizer(textNode, "data", "property");
        }
        value = this._textSanitizer(value);
        debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
          kind: "commit text",
          node: textNode,
          value,
          options: this.options
        });
        textNode.data = value;
      }
    }
    this._$committedValue = value;
  }
  _commitTemplateResult(result2) {
    var _a2;
    const { values, ["_$litType$"]: type } = result2;
    const template2 = typeof type === "number" ? this._$getTemplate(result2) : (type.el === void 0 && (type.el = Template.createElement(trustFromTemplateString(type.h, type.h[0]), this.options)), type);
    if (((_a2 = this._$committedValue) === null || _a2 === void 0 ? void 0 : _a2._$template) === template2) {
      debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
        kind: "template updating",
        template: template2,
        instance: this._$committedValue,
        parts: this._$committedValue._$parts,
        options: this.options,
        values
      });
      this._$committedValue._update(values);
    } else {
      const instance = new TemplateInstance(template2, this);
      const fragment = instance._clone(this.options);
      debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
        kind: "template instantiated",
        template: template2,
        instance,
        parts: instance._$parts,
        options: this.options,
        fragment,
        values
      });
      instance._update(values);
      debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
        kind: "template instantiated and updated",
        template: template2,
        instance,
        parts: instance._$parts,
        options: this.options,
        fragment,
        values
      });
      this._commitNode(fragment);
      this._$committedValue = instance;
    }
  }
  // Overridden via `litHtmlPolyfillSupport` to provide platform support.
  /** @internal */
  _$getTemplate(result2) {
    let template2 = templateCache.get(result2.strings);
    if (template2 === void 0) {
      templateCache.set(result2.strings, template2 = new Template(result2));
    }
    return template2;
  }
  _commitIterable(value) {
    if (!isArray(this._$committedValue)) {
      this._$committedValue = [];
      this._$clear();
    }
    const itemParts = this._$committedValue;
    let partIndex = 0;
    let itemPart;
    for (const item of value) {
      if (partIndex === itemParts.length) {
        itemParts.push(itemPart = new ChildPart(this._insert(createMarker()), this._insert(createMarker()), this, this.options));
      } else {
        itemPart = itemParts[partIndex];
      }
      itemPart._$setValue(item);
      partIndex++;
    }
    if (partIndex < itemParts.length) {
      this._$clear(itemPart && wrap(itemPart._$endNode).nextSibling, partIndex);
      itemParts.length = partIndex;
    }
  }
  /**
   * Removes the nodes contained within this Part from the DOM.
   *
   * @param start Start node to clear from, for clearing a subset of the part's
   *     DOM (used when truncating iterables)
   * @param from  When `start` is specified, the index within the iterable from
   *     which ChildParts are being removed, used for disconnecting directives in
   *     those Parts.
   *
   * @internal
   */
  _$clear(start = wrap(this._$startNode).nextSibling, from2) {
    var _a2;
    (_a2 = this._$notifyConnectionChanged) === null || _a2 === void 0 ? void 0 : _a2.call(this, false, true, from2);
    while (start && start !== this._$endNode) {
      const n = wrap(start).nextSibling;
      wrap(start).remove();
      start = n;
    }
  }
  /**
   * Implementation of RootPart's `isConnected`. Note that this metod
   * should only be called on `RootPart`s (the `ChildPart` returned from a
   * top-level `render()` call). It has no effect on non-root ChildParts.
   * @param isConnected Whether to set
   * @internal
   */
  setConnected(isConnected) {
    var _a2;
    if (this._$parent === void 0) {
      this.__isConnected = isConnected;
      (_a2 = this._$notifyConnectionChanged) === null || _a2 === void 0 ? void 0 : _a2.call(this, isConnected);
    } else {
      throw new Error("part.setConnected() may only be called on a RootPart returned from render().");
    }
  }
}
class AttributePart {
  constructor(element, name2, strings, parent, options) {
    this.type = ATTRIBUTE_PART;
    this._$committedValue = nothing;
    this._$disconnectableChildren = void 0;
    this.element = element;
    this.name = name2;
    this._$parent = parent;
    this.options = options;
    if (strings.length > 2 || strings[0] !== "" || strings[1] !== "") {
      this._$committedValue = new Array(strings.length - 1).fill(new String());
      this.strings = strings;
    } else {
      this._$committedValue = nothing;
    }
    {
      this._sanitizer = void 0;
    }
  }
  get tagName() {
    return this.element.tagName;
  }
  // See comment in Disconnectable interface for why this is a getter
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  /**
   * Sets the value of this part by resolving the value from possibly multiple
   * values and static strings and committing it to the DOM.
   * If this part is single-valued, `this._strings` will be undefined, and the
   * method will be called with a single value argument. If this part is
   * multi-value, `this._strings` will be defined, and the method is called
   * with the value array of the part's owning TemplateInstance, and an offset
   * into the value array from which the values should be read.
   * This method is overloaded this way to eliminate short-lived array slices
   * of the template instance values, and allow a fast-path for single-valued
   * parts.
   *
   * @param value The part value, or an array of values for multi-valued parts
   * @param valueIndex the index to start reading values from. `undefined` for
   *   single-valued parts
   * @param noCommit causes the part to not commit its value to the DOM. Used
   *   in hydration to prime attribute parts with their first-rendered value,
   *   but not set the attribute, and in SSR to no-op the DOM operation and
   *   capture the value for serialization.
   *
   * @internal
   */
  _$setValue(value, directiveParent = this, valueIndex, noCommit) {
    const strings = this.strings;
    let change = false;
    if (strings === void 0) {
      value = resolveDirective(this, value, directiveParent, 0);
      change = !isPrimitive(value) || value !== this._$committedValue && value !== noChange;
      if (change) {
        this._$committedValue = value;
      }
    } else {
      const values = value;
      value = strings[0];
      let i, v2;
      for (i = 0; i < strings.length - 1; i++) {
        v2 = resolveDirective(this, values[valueIndex + i], directiveParent, i);
        if (v2 === noChange) {
          v2 = this._$committedValue[i];
        }
        change || (change = !isPrimitive(v2) || v2 !== this._$committedValue[i]);
        if (v2 === nothing) {
          value = nothing;
        } else if (value !== nothing) {
          value += (v2 !== null && v2 !== void 0 ? v2 : "") + strings[i + 1];
        }
        this._$committedValue[i] = v2;
      }
    }
    if (change && !noCommit) {
      this._commitValue(value);
    }
  }
  /** @internal */
  _commitValue(value) {
    if (value === nothing) {
      wrap(this.element).removeAttribute(this.name);
    } else {
      {
        if (this._sanitizer === void 0) {
          this._sanitizer = sanitizerFactoryInternal(this.element, this.name, "attribute");
        }
        value = this._sanitizer(value !== null && value !== void 0 ? value : "");
      }
      debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
        kind: "commit attribute",
        element: this.element,
        name: this.name,
        value,
        options: this.options
      });
      wrap(this.element).setAttribute(this.name, value !== null && value !== void 0 ? value : "");
    }
  }
}
class PropertyPart extends AttributePart {
  constructor() {
    super(...arguments);
    this.type = PROPERTY_PART;
  }
  /** @internal */
  _commitValue(value) {
    {
      if (this._sanitizer === void 0) {
        this._sanitizer = sanitizerFactoryInternal(this.element, this.name, "property");
      }
      value = this._sanitizer(value);
    }
    debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
      kind: "commit property",
      element: this.element,
      name: this.name,
      value,
      options: this.options
    });
    this.element[this.name] = value === nothing ? void 0 : value;
  }
}
const emptyStringForBooleanAttribute = trustedTypes ? trustedTypes.emptyScript : "";
class BooleanAttributePart extends AttributePart {
  constructor() {
    super(...arguments);
    this.type = BOOLEAN_ATTRIBUTE_PART;
  }
  /** @internal */
  _commitValue(value) {
    debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
      kind: "commit boolean attribute",
      element: this.element,
      name: this.name,
      value: !!(value && value !== nothing),
      options: this.options
    });
    if (value && value !== nothing) {
      wrap(this.element).setAttribute(this.name, emptyStringForBooleanAttribute);
    } else {
      wrap(this.element).removeAttribute(this.name);
    }
  }
}
class EventPart extends AttributePart {
  constructor(element, name2, strings, parent, options) {
    super(element, name2, strings, parent, options);
    this.type = EVENT_PART;
    if (this.strings !== void 0) {
      throw new Error(`A \`<${element.localName}>\` has a \`@${name2}=...\` listener with invalid content. Event listeners in templates must have exactly one expression and no surrounding text.`);
    }
  }
  // EventPart does not use the base _$setValue/_resolveValue implementation
  // since the dirty checking is more complex
  /** @internal */
  _$setValue(newListener, directiveParent = this) {
    var _a2;
    newListener = (_a2 = resolveDirective(this, newListener, directiveParent, 0)) !== null && _a2 !== void 0 ? _a2 : nothing;
    if (newListener === noChange) {
      return;
    }
    const oldListener = this._$committedValue;
    const shouldRemoveListener = newListener === nothing && oldListener !== nothing || newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive;
    const shouldAddListener = newListener !== nothing && (oldListener === nothing || shouldRemoveListener);
    debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
      kind: "commit event listener",
      element: this.element,
      name: this.name,
      value: newListener,
      options: this.options,
      removeListener: shouldRemoveListener,
      addListener: shouldAddListener,
      oldListener
    });
    if (shouldRemoveListener) {
      this.element.removeEventListener(this.name, this, oldListener);
    }
    if (shouldAddListener) {
      this.element.addEventListener(this.name, this, newListener);
    }
    this._$committedValue = newListener;
  }
  handleEvent(event) {
    var _a2, _b2;
    if (typeof this._$committedValue === "function") {
      this._$committedValue.call((_b2 = (_a2 = this.options) === null || _a2 === void 0 ? void 0 : _a2.host) !== null && _b2 !== void 0 ? _b2 : this.element, event);
    } else {
      this._$committedValue.handleEvent(event);
    }
  }
}
class ElementPart {
  constructor(element, parent, options) {
    this.element = element;
    this.type = ELEMENT_PART;
    this._$disconnectableChildren = void 0;
    this._$parent = parent;
    this.options = options;
  }
  // See comment in Disconnectable interface for why this is a getter
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _$setValue(value) {
    debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
      kind: "commit to element binding",
      element: this.element,
      value,
      options: this.options
    });
    resolveDirective(this, value);
  }
}
const polyfillSupport$1 = global$2.litHtmlPolyfillSupportDevMode;
polyfillSupport$1 === null || polyfillSupport$1 === void 0 ? void 0 : polyfillSupport$1(Template, ChildPart);
((_d$1 = global$2.litHtmlVersions) !== null && _d$1 !== void 0 ? _d$1 : global$2.litHtmlVersions = []).push("2.7.5");
if (global$2.litHtmlVersions.length > 1) {
  issueWarning$1("multiple-versions", `Multiple versions of Lit loaded. Loading multiple versions is not recommended.`);
}
const render = (value, container, options) => {
  var _a2, _b2;
  if (container == null) {
    throw new TypeError(`The container to render into may not be ${container}`);
  }
  const renderId = debugLogRenderId++;
  const partOwnerNode = (_a2 = options === null || options === void 0 ? void 0 : options.renderBefore) !== null && _a2 !== void 0 ? _a2 : container;
  let part = partOwnerNode["_$litPart$"];
  debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
    kind: "begin render",
    id: renderId,
    value,
    container,
    options,
    part
  });
  if (part === void 0) {
    const endNode = (_b2 = options === null || options === void 0 ? void 0 : options.renderBefore) !== null && _b2 !== void 0 ? _b2 : null;
    partOwnerNode["_$litPart$"] = part = new ChildPart(container.insertBefore(createMarker(), endNode), endNode, void 0, options !== null && options !== void 0 ? options : {});
  }
  part._$setValue(value);
  debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({
    kind: "end render",
    id: renderId,
    value,
    container,
    options,
    part
  });
  return part;
};
{
  render.setSanitizer = setSanitizer;
  render.createSanitizer = createSanitizer;
  {
    render._testOnlyClearSanitizerFactoryDoNotCallOrElse = _testOnlyClearSanitizerFactoryDoNotCallOrElse;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var _a$2, _b, _c;
let issueWarning;
{
  const issuedWarnings = (_a$2 = globalThis.litIssuedWarnings) !== null && _a$2 !== void 0 ? _a$2 : globalThis.litIssuedWarnings = /* @__PURE__ */ new Set();
  issueWarning = (code3, warning) => {
    warning += ` See https://lit.dev/msg/${code3} for more information.`;
    if (!issuedWarnings.has(warning)) {
      console.warn(warning);
      issuedWarnings.add(warning);
    }
  };
}
class LitElement extends ReactiveElement {
  constructor() {
    super(...arguments);
    this.renderOptions = { host: this };
    this.__childPart = void 0;
  }
  /**
   * @category rendering
   */
  createRenderRoot() {
    var _a2;
    var _b2;
    const renderRoot = super.createRenderRoot();
    (_a2 = (_b2 = this.renderOptions).renderBefore) !== null && _a2 !== void 0 ? _a2 : _b2.renderBefore = renderRoot.firstChild;
    return renderRoot;
  }
  /**
   * Updates the element. This method reflects property values to attributes
   * and calls `render` to render DOM via lit-html. Setting properties inside
   * this method will *not* trigger another update.
   * @param changedProperties Map of changed properties with old values
   * @category updates
   */
  update(changedProperties) {
    const value = this.render();
    if (!this.hasUpdated) {
      this.renderOptions.isConnected = this.isConnected;
    }
    super.update(changedProperties);
    this.__childPart = render(value, this.renderRoot, this.renderOptions);
  }
  /**
   * Invoked when the component is added to the document's DOM.
   *
   * In `connectedCallback()` you should setup tasks that should only occur when
   * the element is connected to the document. The most common of these is
   * adding event listeners to nodes external to the element, like a keydown
   * event handler added to the window.
   *
   * ```ts
   * connectedCallback() {
   *   super.connectedCallback();
   *   addEventListener('keydown', this._handleKeydown);
   * }
   * ```
   *
   * Typically, anything done in `connectedCallback()` should be undone when the
   * element is disconnected, in `disconnectedCallback()`.
   *
   * @category lifecycle
   */
  connectedCallback() {
    var _a2;
    super.connectedCallback();
    (_a2 = this.__childPart) === null || _a2 === void 0 ? void 0 : _a2.setConnected(true);
  }
  /**
   * Invoked when the component is removed from the document's DOM.
   *
   * This callback is the main signal to the element that it may no longer be
   * used. `disconnectedCallback()` should ensure that nothing is holding a
   * reference to the element (such as event listeners added to nodes external
   * to the element), so that it is free to be garbage collected.
   *
   * ```ts
   * disconnectedCallback() {
   *   super.disconnectedCallback();
   *   window.removeEventListener('keydown', this._handleKeydown);
   * }
   * ```
   *
   * An element may be re-connected after being disconnected.
   *
   * @category lifecycle
   */
  disconnectedCallback() {
    var _a2;
    super.disconnectedCallback();
    (_a2 = this.__childPart) === null || _a2 === void 0 ? void 0 : _a2.setConnected(false);
  }
  /**
   * Invoked on each update to perform rendering tasks. This method may return
   * any value renderable by lit-html's `ChildPart` - typically a
   * `TemplateResult`. Setting properties inside this method will *not* trigger
   * the element to update.
   * @category rendering
   */
  render() {
    return noChange;
  }
}
LitElement["finalized"] = true;
LitElement["_$litElement$"] = true;
(_b = globalThis.litElementHydrateSupport) === null || _b === void 0 ? void 0 : _b.call(globalThis, { LitElement });
const polyfillSupport = globalThis.litElementPolyfillSupportDevMode;
polyfillSupport === null || polyfillSupport === void 0 ? void 0 : polyfillSupport({ LitElement });
{
  LitElement["finalize"] = function() {
    const finalized2 = ReactiveElement.finalize.call(this);
    if (!finalized2) {
      return false;
    }
    const warnRemovedOrRenamed = (obj, name2, renamed = false) => {
      if (obj.hasOwnProperty(name2)) {
        const ctorName2 = (typeof obj === "function" ? obj : obj.constructor).name;
        issueWarning(renamed ? "renamed-api" : "removed-api", `\`${name2}\` is implemented on class ${ctorName2}. It has been ${renamed ? "renamed" : "removed"} in this version of LitElement.`);
      }
    };
    warnRemovedOrRenamed(this, "render");
    warnRemovedOrRenamed(this, "getStyles", true);
    warnRemovedOrRenamed(this.prototype, "adoptStyles");
    return true;
  };
}
((_c = globalThis.litElementVersions) !== null && _c !== void 0 ? _c : globalThis.litElementVersions = []).push("3.3.2");
if (globalThis.litElementVersions.length > 1) {
  issueWarning("multiple-versions", `Multiple versions of Lit loaded. Loading multiple versions is not recommended.`);
}
var __awaiter$5 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SLitComponent extends LitElement {
  get state() {
    return this._state;
  }
  set state(state) {
    Object.assign(this._state, state);
  }
  /**
   * @name            define
   * @type            Function
   * @static
   *
   * This static method allows you to define a custom element just like the `customElement.define` does.
   * The trick is that this define method will not initialize the component directly. It will
   * wait until it is near the viewport before actually creating a new element names "%tagName-up".
   * This will be the custom element that is registered and that will replace your "%tagName" HTMLElement.
   *
   * @param
   * @param       {Any}           props          The initial props to apply to your custom element
   * @param       {String}        tagName         The tagname you want to search in the DOM
   *
   * @since       2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  static define(tagName, Cls, props = {}, settings = {}) {
    var _a2;
    SLitComponent.setDefaultProps(tagName, props);
    const win = (_a2 = settings.window) !== null && _a2 !== void 0 ? _a2 : window;
    if (win.customElements.get(tagName.toLowerCase())) {
      return;
    }
    win.customElements.define(tagName.toLowerCase(), class extends Cls {
    });
  }
  /**
   * @name            setDefaultProps
   * @type            Function
   * @static
   *
   * This static method allows you to set some default props for some particular
   * component(s). You can target components using simple css selectorl like "my-component#cool".
   * Once the component is instanciated, it will check if some defaults are specified and
   * extends them with the passed props.
   *
   * @param     {String|String[]}      selector      The selector to use to target elements on which these props will be applied
   * @param     {Any}         props         An object of props you want to set defaults for
   *
   * @since       2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  static setDefaultProps(selector, props) {
    SComponentUtils.setDefaultProps(selector, props);
  }
  static propertiesFromInterface(properties2, int) {
    var _a2;
    const propertiesObj = {};
    class SLitComponentPropsInterface extends SComponentUtilsDefaultPropsInterface {
    }
    SLitComponentPropsInterface.definition = Object.assign(Object.assign({}, SLitComponentPropsInterface.definition), (_a2 = int === null || int === void 0 ? void 0 : int.definition) !== null && _a2 !== void 0 ? _a2 : {});
    Object.keys(SLitComponentPropsInterface.definition).forEach((prop) => {
      var _a3, _b2, _c2, _d2, _e2, _f2, _g2, _h, _j, _k, _l2, _m2, _o2;
      const definition = SLitComponentPropsInterface.definition[prop];
      propertiesObj[prop] = Object.assign({}, (_a3 = definition.lit) !== null && _a3 !== void 0 ? _a3 : {});
      let type = String, typeStr = (_c2 = (_b2 = definition.type) === null || _b2 === void 0 ? void 0 : _b2.type) !== null && _c2 !== void 0 ? _c2 : definition.type;
      switch (typeStr.toLowerCase()) {
        case "boolean":
          type = Boolean;
          break;
        case "object":
          type = Object;
          break;
        case "number":
          type = Number;
          break;
        default:
          if (typeStr.match(/\[\]$/)) {
            type = Array;
          }
          break;
      }
      propertiesObj[prop].type = type;
      propertiesObj[prop].default = definition.default;
      propertiesObj[prop].attribute = __dashCase(prop);
      if (definition.physical || ((_f2 = (_e2 = (_d2 = definition.type) === null || _d2 === void 0 ? void 0 : _d2.type) === null || _e2 === void 0 ? void 0 : _e2.toLowerCase) === null || _f2 === void 0 ? void 0 : _f2.call(_e2)) === "boolean" || ((_h = (_g2 = definition.type) === null || _g2 === void 0 ? void 0 : _g2.toLowerCase) === null || _h === void 0 ? void 0 : _h.call(_g2)) === "boolean" || ((_l2 = (_k = (_j = definition.type) === null || _j === void 0 ? void 0 : _j.type) === null || _k === void 0 ? void 0 : _k.toLowerCase) === null || _l2 === void 0 ? void 0 : _l2.call(_k)) === "object" || ((_o2 = (_m2 = definition.type) === null || _m2 === void 0 ? void 0 : _m2.toLowerCase) === null || _o2 === void 0 ? void 0 : _o2.call(_m2)) === "object") {
        propertiesObj[prop].reflect = true;
      }
      propertiesObj[prop].converter = {
        fromAttribute: (value, type2) => {
          var _a4, _b3, _c3, _d3, _e3;
          const typeStr2 = (_c3 = (_b3 = (_a4 = definition.type) === null || _a4 === void 0 ? void 0 : _a4.type) === null || _b3 === void 0 ? void 0 : _b3.toLowerCase()) !== null && _c3 !== void 0 ? _c3 : (_d3 = definition.type) === null || _d3 === void 0 ? void 0 : _d3.toLowerCase();
          if (typeStr2 === "object" && typeof value === "string") {
            try {
              const json = JSON.parse(value);
              const finalJson = __deepMerge((_e3 = definition.default) !== null && _e3 !== void 0 ? _e3 : {}, json);
              return finalJson;
            } catch (e) {
              console.error(e);
            }
          }
          if (value === "true" || value === "")
            return true;
          if (value === "null")
            return null;
          if (value === "undefined")
            return void 0;
          if (value === "false")
            return false;
          return value;
        },
        toAttribute(value) {
          if (value === "false" || value === false || value === null) {
            return void 0;
          }
          if (typeof value !== "string" && typeof value !== "boolean") {
            try {
              const jsonStr = JSON.stringify(value);
              return jsonStr;
            } catch (e) {
            }
          }
          return value;
        }
      };
    });
    const props = Object.assign(Object.assign({}, propertiesObj), properties2 !== null && properties2 !== void 0 ? properties2 : {});
    return props;
  }
  /**
   * @name            constructor
   * @type            Function
   * @constructor
   *
   * Constructor
   *
   * @since       2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  constructor(settings = {}) {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h, _j, _k;
    super();
    this.settings = {};
    this.props = {};
    this._shouldUpdate = false;
    this._state = {};
    this.settings = __deepMerge({
      componentUtils: {},
      shadowDom: false,
      get rootNode() {
        var _a3;
        return (_a3 = this.shadowRoot) === null || _a3 === void 0 ? void 0 : _a3.querySelector("*:first-child");
      }
    }, settings);
    if (this.constructor.state) {
      this.state = Object.assign({}, this.constructor.state);
    } else {
      this.state = {};
    }
    if (!((_a2 = this.state) === null || _a2 === void 0 ? void 0 : _a2.status)) {
      this.state.status = "idle";
    }
    if (this.settings.shadowDom === false) {
      this.createRenderRoot = () => {
        return this;
      };
    }
    const doc = this._getDocumentFromElement(this);
    if (document !== doc && this.constructor.styles) {
      __injectStyle(this.constructor.styles, {
        rootNode: doc
      });
    }
    if (!SLitComponent._keepInjectedCssBeforeStylesheetLinksInited) {
      const $firstStylesheetLink = document.head.querySelector('link[rel="stylesheet"]');
      __querySelectorLive("style", ($style) => {
        if ($firstStylesheetLink) {
          document.head.insertBefore($style, $firstStylesheetLink);
        }
      }, {
        rootNode: document.head
      });
      SLitComponent._keepInjectedCssBeforeStylesheetLinksInited = true;
    }
    const nodeFirstUpdated = (_b2 = this.firstUpdated) === null || _b2 === void 0 ? void 0 : _b2.bind(this);
    this.firstUpdated = () => __awaiter$5(this, void 0, void 0, function* () {
      if (nodeFirstUpdated) {
        yield nodeFirstUpdated();
      }
      this.setAttribute("mounted", true);
    });
    const nodeShouldUpdate = (_c2 = this.shouldUpdate) === null || _c2 === void 0 ? void 0 : _c2.bind(this);
    this.shouldUpdate = () => {
      if (nodeShouldUpdate) {
        const res = nodeShouldUpdate();
        if (!res)
          return false;
      }
      return this._shouldUpdate;
    };
    this.utils = new SComponentUtils(this, Object.assign(Object.assign(Object.assign({}, (_d2 = this.settings) !== null && _d2 !== void 0 ? _d2 : {}), (_e2 = this.settings.componentUtils) !== null && _e2 !== void 0 ? _e2 : {}), { style: (_k = (_h = (_g2 = (_f2 = this.constructor.styles) === null || _f2 === void 0 ? void 0 : _f2.cssText) !== null && _g2 !== void 0 ? _g2 : this.settings.style) !== null && _h !== void 0 ? _h : (_j = this.settings.componentUtils) === null || _j === void 0 ? void 0 : _j.style) !== null && _k !== void 0 ? _k : "" }));
    (() => __awaiter$5(this, void 0, void 0, function* () {
      var _l2, _m2;
      const defaultProps = SComponentUtils.getDefaultProps(this.tagName.toLowerCase());
      const mountWhen = (_m2 = (_l2 = this.getAttribute("mount-when")) !== null && _l2 !== void 0 ? _l2 : defaultProps.mountWhen) !== null && _m2 !== void 0 ? _m2 : "direct";
      this.classList.add(...this.utils.cls("").split(" "));
      yield this.utils.waitAndExecute(mountWhen, () => {
        this._mount();
      });
    }))();
  }
  firstUpdated() {
    var _a2, _b2;
    super.firstUpdated();
    if ((_b2 = (_a2 = document.env) === null || _a2 === void 0 ? void 0 : _a2.SUGAR) === null || _b2 === void 0 ? void 0 : _b2.classmap) {
      document.env.SUGAR.classmap.patchDom(this);
    }
  }
  updated() {
    var _a2, _b2;
    if ((_b2 = (_a2 = document.env) === null || _a2 === void 0 ? void 0 : _a2.SUGAR) === null || _b2 === void 0 ? void 0 : _b2.classmap) {
      document.env.SUGAR.classmap.patchDom(this);
    }
  }
  _getDocumentFromElement($elm) {
    while ($elm.parentNode) {
      $elm = $elm.parentNode;
    }
    return $elm;
  }
  /**
   * @name            mount
   * @type            Function
   * @async
   *
   * This method allows you to actually mount your feature behavior.
   * It will be called depending on the "mountWhen" setting setted.
   *
   * @since           2.0.0
   * @author 		Olivier Bossel<olivier.bossel@gmail.com>
   */
  _mount() {
    var _a2, _b2, _c2;
    return __awaiter$5(this, void 0, void 0, function* () {
      const _this = this, defaultProps = SComponentUtils.getDefaultProps(this.tagName.toLowerCase());
      let properties2 = this.constructor.properties;
      if (!properties2) {
        properties2 = this.constructor.propertiesFromInterface();
      }
      let finalProps = {};
      for (let [prop, obj] of Object.entries(properties2)) {
        if (this[prop] !== void 0) {
          finalProps[prop] = this[prop];
        }
        Object.defineProperty(this.props, prop, {
          enumerable: true,
          get() {
            return _this[prop];
          },
          set(value) {
            var _a3;
            value = (_a3 = value === null || value === void 0 ? void 0 : value.value) !== null && _a3 !== void 0 ? _a3 : value;
            if (value && typeof value === "string") {
              try {
                _this[prop] = JSON.parse(value);
                return;
              } catch (e) {
              }
            }
            _this[prop] = value;
          }
        });
        if (finalProps[prop] === void 0 && this[prop] === void 0) {
          finalProps[prop] = (_a2 = defaultProps[prop]) !== null && _a2 !== void 0 ? _a2 : obj.default;
        }
      }
      const attrs = this.attributes;
      for (let [id2, attr] of Object.entries(attrs)) {
        if (attr.name.includes(".")) {
          __set(finalProps, __camelCase(attr.name), __parse(attr.value));
        }
      }
      if (this.settings.interface) {
        finalProps = this.settings.interface.apply(finalProps);
      }
      Object.assign(this.props, finalProps);
      this.utils.makePropsResponsive(this.props);
      if (this.props.verbose) {
        console.log(`[${this.tagName.toLowerCase()}]${this.id ? ` #${this.id} ` : " "}mounting`);
      }
      if (this.state) {
        const state = Object.assign({}, this.state);
        delete this.state;
        Object.defineProperty(this, "state", {
          enumerable: true,
          value: this.utils.handleState(state, {
            save: this.props.saveState
          })
        });
        this.state.$set("*", () => {
          this.requestUpdate();
        });
      }
      if (this.mount && typeof this.mount === "function") {
        yield this.mount();
      }
      this._shouldUpdate = true;
      this.requestUpdate();
      yield this.updateComplete;
      this.utils.injectStyle((_c2 = (_b2 = this.constructor.styles) === null || _b2 === void 0 ? void 0 : _b2.cssText) !== null && _c2 !== void 0 ? _c2 : "", this.tagName);
      if (this.props.adoptStyle && this.shadowRoot) {
        yield this.utils.adoptStyleInShadowRoot(this.shadowRoot);
      }
      return true;
    });
  }
}
SLitComponent._keepInjectedCssBeforeStylesheetLinksInited = false;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const PartType = {
  ATTRIBUTE: 1,
  CHILD: 2,
  PROPERTY: 3,
  BOOLEAN_ATTRIBUTE: 4,
  EVENT: 5,
  ELEMENT: 6
};
const directive = (c) => (...values) => ({
  // This property needs to remain unminified.
  ["_$litDirective$"]: c,
  values
});
class Directive {
  constructor(_partInfo) {
  }
  // See comment in Disconnectable interface for why this is a getter
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  /** @internal */
  _$initialize(part, parent, attributeIndex) {
    this.__part = part;
    this._$parent = parent;
    this.__attributeIndex = attributeIndex;
  }
  /** @internal */
  _$resolve(part, props) {
    return this.update(part, props);
  }
  update(_part, props) {
    return this.render(...props);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const HTML_RESULT = 1;
class UnsafeHTMLDirective extends Directive {
  constructor(partInfo) {
    super(partInfo);
    this._value = nothing;
    if (partInfo.type !== PartType.CHILD) {
      throw new Error(`${this.constructor.directiveName}() can only be used in child bindings`);
    }
  }
  render(value) {
    if (value === nothing || value == null) {
      this._templateResult = void 0;
      return this._value = value;
    }
    if (value === noChange) {
      return value;
    }
    if (typeof value != "string") {
      throw new Error(`${this.constructor.directiveName}() called with a non-string value`);
    }
    if (value === this._value) {
      return this._templateResult;
    }
    this._value = value;
    const strings = [value];
    strings.raw = strings;
    return this._templateResult = {
      // Cast to a known set of integers that satisfy ResultType so that we
      // don't have to export ResultType and possibly encourage this pattern.
      // This property needs to remain unminified.
      ["_$litType$"]: this.constructor.resultType,
      strings,
      values: []
    };
  }
}
UnsafeHTMLDirective.directiveName = "unsafeHTML";
UnsafeHTMLDirective.resultType = HTML_RESULT;
const unsafeHTML = directive(UnsafeHTMLDirective);
const _CkSettings = class _CkSettings extends SLitComponent {
  constructor() {
    super({
      shadowDom: false
    });
  }
  static get properties() {
    return SLitComponent.propertiesFromInterface();
  }
  async mount() {
    const json = await this.fetchMenu();
    this._packages = json.packages;
    this.requestUpdate();
  }
  async fetchMenu() {
    const response = await fetch(
      "https://cdnv2.coffeekraken.io/global/ck-menu.json",
      {
        mode: "cors",
        cache: "no-cache",
        credentials: "same-origin",
        headers: {
          "Content-Type": "application/json"
        },
        referrerPolicy: "no-referrer"
      }
    ), json = await response.json();
    return json;
  }
  render() {
    if (!this._packages) {
      return;
    }
    const h = html`
            <div class="s-dropdown-container">
                <button aria-label="Coffeekraken products">
                    <i class="s-icon:ui-menu-grid-solid"></i>
                </button>
                <div class="s-dropdown s-dropdown--bottom-end">
                    <ul class="_packages">
                        ${this._packages.map(
      (pkg) => html`
                                <li class="_package" ?disabled=${pkg.disabled}>
                                    <a
                                        href="${pkg.url}"
                                        title="Coffeekraken ${pkg.title}"
                                    >
                                        <div class="_icon">
                                            ${unsafeHTML(pkg.icon)}
                                        </div>
                                        <div class="_metas">
                                            <h3 class="_title">${pkg.title}</h3>
                                            <p class="_version">
                                                ${pkg.version}
                                            </p>
                                        </div>
                                    </a>
                                </li>
                            `
    )}
                    </ul>
                </div>
            </div>
        `;
    return h;
  }
};
_CkSettings.state = {};
let CkSettings = _CkSettings;
function define$9(props = {}, tagName = "ck-menu") {
  SLitComponent.define(tagName, CkSettings, {
    id: "ck-menu",
    ...props
  });
}
/*! clipboard-copy. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var clipboardCopy_1 = clipboardCopy;
function makeError() {
  return new DOMException("The request is not allowed", "NotAllowedError");
}
async function copyClipboardApi(text) {
  if (!navigator.clipboard) {
    throw makeError();
  }
  return navigator.clipboard.writeText(text);
}
async function copyExecCommand(text) {
  const span = document.createElement("span");
  span.textContent = text;
  span.style.whiteSpace = "pre";
  span.style.webkitUserSelect = "auto";
  span.style.userSelect = "all";
  document.body.appendChild(span);
  const selection = window.getSelection();
  const range2 = window.document.createRange();
  selection.removeAllRanges();
  range2.selectNode(span);
  selection.addRange(range2);
  let success = false;
  try {
    success = window.document.execCommand("copy");
  } finally {
    selection.removeAllRanges();
    window.document.body.removeChild(span);
  }
  if (!success)
    throw makeError();
}
async function clipboardCopy(text) {
  try {
    await copyClipboardApi(text);
  } catch (err) {
    try {
      await copyExecCommand(text);
    } catch (err2) {
      throw err2 || err || makeError();
    }
  }
}
const __copy = /* @__PURE__ */ getDefaultExportFromCjs(clipboardCopy_1);
function copy(text) {
  return __copy(text);
}
globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SClipboardCopyComponentInterface extends SInterface {
  static get _definition() {
    return {
      from: {
        description: 'Specify the element you want to copy from with a simple css selector. Try to get "value" first, then "innerHTML"',
        type: "String"
      },
      successTimeout: {
        description: 'Specify the duration for displaying the "success" icon',
        type: "Number",
        default: 700
      },
      errorTimeout: {
        description: 'Specify the duration for displaying the "error" icon',
        type: "Number",
        default: 3e3
      }
    };
  }
}
const __css$5 = "\n                @import url('https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css');\n            .s-clipboard-copy {\n    display: inline-block;\n    width: 1em;\n    height: 1em;\n    position: relative;\n    cursor: pointer;\n}\n\n    .s-clipboard-copy:not([mounted]) > * {\n        opacity: 0.001;\n        pointer-events: none;\n    }\n\n    .s-clipboard-copy .s-clipboard-copy_root {\n        width: 100%;\n        height: 100%;\n    }\n\n    .s-clipboard-copy .s-clipboard-copy_root[state='pending'] .icon-copy {\n            opacity: 1;\n        }\n\n    .s-clipboard-copy .s-clipboard-copy_root[state='copy'] .icon-copy {\n            opacity: 1;\n        }\n\n    .s-clipboard-copy .s-clipboard-copy_root[state='success'] .icon-success {\n            opacity: 1;\n        }\n\n    .s-clipboard-copy .s-clipboard-copy_root[state='error'] .icon-error {\n            opacity: 1;\n        }\n\n    .s-clipboard-copy svg {\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        display: block;\n        width: 1em;\n        height: 1em;\n        background-size: contain;\n        opacity: 0;\n        pointer-events: none;\n    }\n";
class SClipboardCopyComponent extends SLitComponent {
  static get properties() {
    return SLitComponent.propertiesFromInterface({}, SClipboardCopyComponentInterface);
  }
  static get styles() {
    return css$1`
            ${unsafeCSS(__css$5)}
        `;
  }
  static get state() {
    return {
      status: "pending"
    };
  }
  constructor() {
    super(__deepMerge({
      name: "s-clipboard-copy",
      interface: SClipboardCopyComponentInterface
    }));
  }
  _copyFromTarget() {
    var _a2;
    if (!this.props.from)
      return;
    let $elm = document.querySelector(this.props.from);
    if (!$elm) {
      $elm = document.querySelector(`#${this.props.from}`);
    }
    if (!$elm) {
      throw new Error(`[SClipboardCopy] The target element "${this.props.from}" does not exist`);
    }
    const text = (_a2 = $elm.value) !== null && _a2 !== void 0 ? _a2 : $elm.innerHTML;
    this.copy(text);
  }
  /**
   * @name                copy
   * @type                Function
   *
   * This method allows you to copy some text through the s-clipboard-copy component that will
   * update itself to display the copy state.
   *
   * @param       {String}            text            The text you want to copy
   *
   * @since           2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  copy(text) {
    this.state.status = "copy";
    setTimeout(() => {
      copy(text).then(() => {
        this.state.status = "success";
        setTimeout(() => {
          this.state.status = "pending";
        }, this.props.successTimeout);
      }).catch((e) => {
        this.state.status = "error";
        setTimeout(() => {
          this.state.status = "pending";
        }, this.props.errorTimeout);
      });
    });
  }
  render() {
    return html`
            <div
                @click=${() => {
      this._copyFromTarget();
    }}
                class="${this.utils.cls("_root")}"
                state="${this.state.status}"
            >
                <svg
                    ref="svg"
                    class="icon-copy"
                    width="20"
                    height="20"
                    viewBox="0 0 20 20"
                    fill="none"
                    xmlns="http://www.w3.org/2000/svg"
                >
                    <g clip-path="url(#clip0)">
                        <path
                            d="M4.55512 0.00402832L2.07324 2.4859H4.55512V0.00402832Z"
                            fill="currentColor"
                        />
                        <path
                            d="M14.9937 0H5.72598V3.65762H2.06836V17.0624H14.9937V0H14.9937ZM12.5801 11.3218H4.48195V10.1499H12.5801V11.3218ZM12.5801 8.83219H4.48195V7.66031H12.5801V8.83219ZM12.5801 6.34254H4.48195V5.17066H12.5801V6.34254Z"
                            fill="currentColor"
                        />
                        <path
                            d="M16.1655 2.93762V18.2343H5.00586V20H17.9312V2.93762H16.1655Z"
                            fill="currentColor"
                        />
                    </g>
                    <defs>
                        <clipPath id="clip0">
                            <rect width="20" height="20" fill="currentColor" />
                        </clipPath>
                    </defs>
                </svg>
                <svg
                    class="icon-success"
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                >
                    <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                    <polyline points="22 4 12 14.01 9 11.01"></polyline>
                </svg>
                <svg
                    class="icon-error"
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                >
                    <polygon
                        points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"
                    ></polygon>
                    <line x1="15" y1="9" x2="9" y2="15"></line>
                    <line x1="9" y1="9" x2="15" y2="15"></line>
                </svg>
            </div>
        `;
  }
}
function define$7(props = {}, tagName = "s-clipboard-copy", settings) {
  SClipboardCopyComponent.define(tagName, SClipboardCopyComponent, props, settings);
}
const define$8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: define$7
}, Symbol.toStringTag, { value: "Module" }));
function deepFreeze(obj) {
  if (obj instanceof Map) {
    obj.clear = obj.delete = obj.set = function() {
      throw new Error("map is read-only");
    };
  } else if (obj instanceof Set) {
    obj.add = obj.clear = obj.delete = function() {
      throw new Error("set is read-only");
    };
  }
  Object.freeze(obj);
  Object.getOwnPropertyNames(obj).forEach((name2) => {
    const prop = obj[name2];
    const type = typeof prop;
    if ((type === "object" || type === "function") && !Object.isFrozen(prop)) {
      deepFreeze(prop);
    }
  });
  return obj;
}
class Response {
  /**
   * @param {CompiledMode} mode
   */
  constructor(mode) {
    if (mode.data === void 0)
      mode.data = {};
    this.data = mode.data;
    this.isMatchIgnored = false;
  }
  ignoreMatch() {
    this.isMatchIgnored = true;
  }
}
function escapeHTML(value) {
  return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function inherit$1(original, ...objects) {
  const result2 = /* @__PURE__ */ Object.create(null);
  for (const key in original) {
    result2[key] = original[key];
  }
  objects.forEach(function(obj) {
    for (const key in obj) {
      result2[key] = obj[key];
    }
  });
  return (
    /** @type {T} */
    result2
  );
}
const SPAN_CLOSE = "</span>";
const emitsWrappingTags = (node) => {
  return !!node.scope;
};
const scopeToCSSClass = (name2, { prefix }) => {
  if (name2.startsWith("language:")) {
    return name2.replace("language:", "language-");
  }
  if (name2.includes(".")) {
    const pieces = name2.split(".");
    return [
      `${prefix}${pieces.shift()}`,
      ...pieces.map((x, i) => `${x}${"_".repeat(i + 1)}`)
    ].join(" ");
  }
  return `${prefix}${name2}`;
};
class HTMLRenderer {
  /**
   * Creates a new HTMLRenderer
   *
   * @param {Tree} parseTree - the parse tree (must support `walk` API)
   * @param {{classPrefix: string}} options
   */
  constructor(parseTree, options) {
    this.buffer = "";
    this.classPrefix = options.classPrefix;
    parseTree.walk(this);
  }
  /**
   * Adds texts to the output stream
   *
   * @param {string} text */
  addText(text) {
    this.buffer += escapeHTML(text);
  }
  /**
   * Adds a node open to the output stream (if needed)
   *
   * @param {Node} node */
  openNode(node) {
    if (!emitsWrappingTags(node))
      return;
    const className = scopeToCSSClass(
      node.scope,
      { prefix: this.classPrefix }
    );
    this.span(className);
  }
  /**
   * Adds a node close to the output stream (if needed)
   *
   * @param {Node} node */
  closeNode(node) {
    if (!emitsWrappingTags(node))
      return;
    this.buffer += SPAN_CLOSE;
  }
  /**
   * returns the accumulated buffer
  */
  value() {
    return this.buffer;
  }
  // helpers
  /**
   * Builds a span element
   *
   * @param {string} className */
  span(className) {
    this.buffer += `<span class="${className}">`;
  }
}
const newNode = (opts = {}) => {
  const result2 = { children: [] };
  Object.assign(result2, opts);
  return result2;
};
class TokenTree {
  constructor() {
    this.rootNode = newNode();
    this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  /** @param {Node} node */
  add(node) {
    this.top.children.push(node);
  }
  /** @param {string} scope */
  openNode(scope) {
    const node = newNode({ scope });
    this.add(node);
    this.stack.push(node);
  }
  closeNode() {
    if (this.stack.length > 1) {
      return this.stack.pop();
    }
    return void 0;
  }
  closeAllNodes() {
    while (this.closeNode())
      ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  /**
   * @typedef { import("./html_renderer").Renderer } Renderer
   * @param {Renderer} builder
   */
  walk(builder) {
    return this.constructor._walk(builder, this.rootNode);
  }
  /**
   * @param {Renderer} builder
   * @param {Node} node
   */
  static _walk(builder, node) {
    if (typeof node === "string") {
      builder.addText(node);
    } else if (node.children) {
      builder.openNode(node);
      node.children.forEach((child) => this._walk(builder, child));
      builder.closeNode(node);
    }
    return builder;
  }
  /**
   * @param {Node} node
   */
  static _collapse(node) {
    if (typeof node === "string")
      return;
    if (!node.children)
      return;
    if (node.children.every((el2) => typeof el2 === "string")) {
      node.children = [node.children.join("")];
    } else {
      node.children.forEach((child) => {
        TokenTree._collapse(child);
      });
    }
  }
}
class TokenTreeEmitter extends TokenTree {
  /**
   * @param {*} options
   */
  constructor(options) {
    super();
    this.options = options;
  }
  /**
   * @param {string} text
   */
  addText(text) {
    if (text === "") {
      return;
    }
    this.add(text);
  }
  /** @param {string} scope */
  startScope(scope) {
    this.openNode(scope);
  }
  endScope() {
    this.closeNode();
  }
  /**
   * @param {Emitter & {root: DataNode}} emitter
   * @param {string} name
   */
  __addSublanguage(emitter, name2) {
    const node = emitter.root;
    if (name2)
      node.scope = `language:${name2}`;
    this.add(node);
  }
  toHTML() {
    const renderer = new HTMLRenderer(this, this.options);
    return renderer.value();
  }
  finalize() {
    this.closeAllNodes();
    return true;
  }
}
function source(re) {
  if (!re)
    return null;
  if (typeof re === "string")
    return re;
  return re.source;
}
function lookahead(re) {
  return concat("(?=", re, ")");
}
function anyNumberOfTimes(re) {
  return concat("(?:", re, ")*");
}
function optional(re) {
  return concat("(?:", re, ")?");
}
function concat(...args) {
  const joined = args.map((x) => source(x)).join("");
  return joined;
}
function stripOptionsFromArgs(args) {
  const opts = args[args.length - 1];
  if (typeof opts === "object" && opts.constructor === Object) {
    args.splice(args.length - 1, 1);
    return opts;
  } else {
    return {};
  }
}
function either(...args) {
  const opts = stripOptionsFromArgs(args);
  const joined = "(" + (opts.capture ? "" : "?:") + args.map((x) => source(x)).join("|") + ")";
  return joined;
}
function countMatchGroups(re) {
  return new RegExp(re.toString() + "|").exec("").length - 1;
}
function startsWith(re, lexeme) {
  const match2 = re && re.exec(lexeme);
  return match2 && match2.index === 0;
}
const BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function _rewriteBackreferences(regexps, { joinWith }) {
  let numCaptures = 0;
  return regexps.map((regex2) => {
    numCaptures += 1;
    const offset2 = numCaptures;
    let re = source(regex2);
    let out = "";
    while (re.length > 0) {
      const match2 = BACKREF_RE.exec(re);
      if (!match2) {
        out += re;
        break;
      }
      out += re.substring(0, match2.index);
      re = re.substring(match2.index + match2[0].length);
      if (match2[0][0] === "\\" && match2[1]) {
        out += "\\" + String(Number(match2[1]) + offset2);
      } else {
        out += match2[0];
        if (match2[0] === "(") {
          numCaptures++;
        }
      }
    }
    return out;
  }).map((re) => `(${re})`).join(joinWith);
}
const MATCH_NOTHING_RE = /\b\B/;
const IDENT_RE$1 = "[a-zA-Z]\\w*";
const UNDERSCORE_IDENT_RE = "[a-zA-Z_]\\w*";
const NUMBER_RE = "\\b\\d+(\\.\\d+)?";
const C_NUMBER_RE = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
const BINARY_NUMBER_RE = "\\b(0b[01]+)";
const RE_STARTERS_RE = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
const SHEBANG = (opts = {}) => {
  const beginShebang = /^#![ ]*\//;
  if (opts.binary) {
    opts.begin = concat(
      beginShebang,
      /.*\b/,
      opts.binary,
      /\b.*/
    );
  }
  return inherit$1({
    scope: "meta",
    begin: beginShebang,
    end: /$/,
    relevance: 0,
    /** @type {ModeCallback} */
    "on:begin": (m, resp) => {
      if (m.index !== 0)
        resp.ignoreMatch();
    }
  }, opts);
};
const BACKSLASH_ESCAPE = {
  begin: "\\\\[\\s\\S]",
  relevance: 0
};
const APOS_STRING_MODE = {
  scope: "string",
  begin: "'",
  end: "'",
  illegal: "\\n",
  contains: [BACKSLASH_ESCAPE]
};
const QUOTE_STRING_MODE = {
  scope: "string",
  begin: '"',
  end: '"',
  illegal: "\\n",
  contains: [BACKSLASH_ESCAPE]
};
const PHRASAL_WORDS_MODE = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
};
const COMMENT = function(begin, end, modeOptions = {}) {
  const mode = inherit$1(
    {
      scope: "comment",
      begin,
      end,
      contains: []
    },
    modeOptions
  );
  mode.contains.push({
    scope: "doctag",
    // hack to avoid the space from being included. the space is necessary to
    // match here to prevent the plain text rule below from gobbling up doctags
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: true,
    relevance: 0
  });
  const ENGLISH_WORD = either(
    // list of common 1 and 2 letter words in English
    "I",
    "a",
    "is",
    "so",
    "us",
    "to",
    "at",
    "if",
    "in",
    "it",
    "on",
    // note: this is not an exhaustive list of contractions, just popular ones
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
    // contractions - can't we'd they're let's, etc
    /[A-Za-z]+[-][a-z]+/,
    // `no-way`, etc.
    /[A-Za-z][a-z]{2,}/
    // allow capitalized words at beginning of sentences
  );
  mode.contains.push(
    {
      // TODO: how to include ", (, ) without breaking grammars that use these for
      // comment delimiters?
      // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
      // ---
      // this tries to find sequences of 3 english words in a row (without any
      // "programming" type syntax) this gives us a strong signal that we've
      // TRULY found a comment - vs perhaps scanning with the wrong language.
      // It's possible to find something that LOOKS like the start of the
      // comment - but then if there is no readable text - good chance it is a
      // false match and not a comment.
      //
      // for a visual example please see:
      // https://github.com/highlightjs/highlight.js/issues/2827
      begin: concat(
        /[ ]+/,
        // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
        "(",
        ENGLISH_WORD,
        /[.]?[:]?([.][ ]|[ ])/,
        "){3}"
      )
      // look for 3 words in a row
    }
  );
  return mode;
};
const C_LINE_COMMENT_MODE = COMMENT("//", "$");
const C_BLOCK_COMMENT_MODE = COMMENT("/\\*", "\\*/");
const HASH_COMMENT_MODE = COMMENT("#", "$");
const NUMBER_MODE = {
  scope: "number",
  begin: NUMBER_RE,
  relevance: 0
};
const C_NUMBER_MODE = {
  scope: "number",
  begin: C_NUMBER_RE,
  relevance: 0
};
const BINARY_NUMBER_MODE = {
  scope: "number",
  begin: BINARY_NUMBER_RE,
  relevance: 0
};
const REGEXP_MODE = {
  scope: "regexp",
  begin: /\/(?=[^/\n]*\/)/,
  end: /\/[gimuy]*/,
  contains: [
    BACKSLASH_ESCAPE,
    {
      begin: /\[/,
      end: /\]/,
      relevance: 0,
      contains: [BACKSLASH_ESCAPE]
    }
  ]
};
const TITLE_MODE = {
  scope: "title",
  begin: IDENT_RE$1,
  relevance: 0
};
const UNDERSCORE_TITLE_MODE = {
  scope: "title",
  begin: UNDERSCORE_IDENT_RE,
  relevance: 0
};
const METHOD_GUARD = {
  // excludes method names from keyword processing
  begin: "\\.\\s*" + UNDERSCORE_IDENT_RE,
  relevance: 0
};
const END_SAME_AS_BEGIN = function(mode) {
  return Object.assign(
    mode,
    {
      /** @type {ModeCallback} */
      "on:begin": (m, resp) => {
        resp.data._beginMatch = m[1];
      },
      /** @type {ModeCallback} */
      "on:end": (m, resp) => {
        if (resp.data._beginMatch !== m[1])
          resp.ignoreMatch();
      }
    }
  );
};
var MODES$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  APOS_STRING_MODE,
  BACKSLASH_ESCAPE,
  BINARY_NUMBER_MODE,
  BINARY_NUMBER_RE,
  COMMENT,
  C_BLOCK_COMMENT_MODE,
  C_LINE_COMMENT_MODE,
  C_NUMBER_MODE,
  C_NUMBER_RE,
  END_SAME_AS_BEGIN,
  HASH_COMMENT_MODE,
  IDENT_RE: IDENT_RE$1,
  MATCH_NOTHING_RE,
  METHOD_GUARD,
  NUMBER_MODE,
  NUMBER_RE,
  PHRASAL_WORDS_MODE,
  QUOTE_STRING_MODE,
  REGEXP_MODE,
  RE_STARTERS_RE,
  SHEBANG,
  TITLE_MODE,
  UNDERSCORE_IDENT_RE,
  UNDERSCORE_TITLE_MODE
});
function skipIfHasPrecedingDot(match2, response) {
  const before = match2.input[match2.index - 1];
  if (before === ".") {
    response.ignoreMatch();
  }
}
function scopeClassName(mode, _parent) {
  if (mode.className !== void 0) {
    mode.scope = mode.className;
    delete mode.className;
  }
}
function beginKeywords(mode, parent) {
  if (!parent)
    return;
  if (!mode.beginKeywords)
    return;
  mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)";
  mode.__beforeBegin = skipIfHasPrecedingDot;
  mode.keywords = mode.keywords || mode.beginKeywords;
  delete mode.beginKeywords;
  if (mode.relevance === void 0)
    mode.relevance = 0;
}
function compileIllegal(mode, _parent) {
  if (!Array.isArray(mode.illegal))
    return;
  mode.illegal = either(...mode.illegal);
}
function compileMatch(mode, _parent) {
  if (!mode.match)
    return;
  if (mode.begin || mode.end)
    throw new Error("begin & end are not supported with match");
  mode.begin = mode.match;
  delete mode.match;
}
function compileRelevance(mode, _parent) {
  if (mode.relevance === void 0)
    mode.relevance = 1;
}
const beforeMatchExt = (mode, parent) => {
  if (!mode.beforeMatch)
    return;
  if (mode.starts)
    throw new Error("beforeMatch cannot be used with starts");
  const originalMode = Object.assign({}, mode);
  Object.keys(mode).forEach((key) => {
    delete mode[key];
  });
  mode.keywords = originalMode.keywords;
  mode.begin = concat(originalMode.beforeMatch, lookahead(originalMode.begin));
  mode.starts = {
    relevance: 0,
    contains: [
      Object.assign(originalMode, { endsParent: true })
    ]
  };
  mode.relevance = 0;
  delete originalMode.beforeMatch;
};
const COMMON_KEYWORDS = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  // common variable name
  "list",
  // common variable name
  "value"
  // common variable name
];
const DEFAULT_KEYWORD_SCOPE = "keyword";
function compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {
  const compiledKeywords = /* @__PURE__ */ Object.create(null);
  if (typeof rawKeywords === "string") {
    compileList(scopeName, rawKeywords.split(" "));
  } else if (Array.isArray(rawKeywords)) {
    compileList(scopeName, rawKeywords);
  } else {
    Object.keys(rawKeywords).forEach(function(scopeName2) {
      Object.assign(
        compiledKeywords,
        compileKeywords(rawKeywords[scopeName2], caseInsensitive, scopeName2)
      );
    });
  }
  return compiledKeywords;
  function compileList(scopeName2, keywordList) {
    if (caseInsensitive) {
      keywordList = keywordList.map((x) => x.toLowerCase());
    }
    keywordList.forEach(function(keyword) {
      const pair = keyword.split("|");
      compiledKeywords[pair[0]] = [scopeName2, scoreForKeyword(pair[0], pair[1])];
    });
  }
}
function scoreForKeyword(keyword, providedScore) {
  if (providedScore) {
    return Number(providedScore);
  }
  return commonKeyword(keyword) ? 0 : 1;
}
function commonKeyword(keyword) {
  return COMMON_KEYWORDS.includes(keyword.toLowerCase());
}
const seenDeprecations = {};
const error = (message) => {
  console.error(message);
};
const warn = (message, ...args) => {
  console.log(`WARN: ${message}`, ...args);
};
const deprecated = (version2, message) => {
  if (seenDeprecations[`${version2}/${message}`])
    return;
  console.log(`Deprecated as of ${version2}. ${message}`);
  seenDeprecations[`${version2}/${message}`] = true;
};
const MultiClassError = new Error();
function remapScopeNames(mode, regexes, { key }) {
  let offset2 = 0;
  const scopeNames = mode[key];
  const emit = {};
  const positions2 = {};
  for (let i = 1; i <= regexes.length; i++) {
    positions2[i + offset2] = scopeNames[i];
    emit[i + offset2] = true;
    offset2 += countMatchGroups(regexes[i - 1]);
  }
  mode[key] = positions2;
  mode[key]._emit = emit;
  mode[key]._multi = true;
}
function beginMultiClass(mode) {
  if (!Array.isArray(mode.begin))
    return;
  if (mode.skip || mode.excludeBegin || mode.returnBegin) {
    error("skip, excludeBegin, returnBegin not compatible with beginScope: {}");
    throw MultiClassError;
  }
  if (typeof mode.beginScope !== "object" || mode.beginScope === null) {
    error("beginScope must be object");
    throw MultiClassError;
  }
  remapScopeNames(mode, mode.begin, { key: "beginScope" });
  mode.begin = _rewriteBackreferences(mode.begin, { joinWith: "" });
}
function endMultiClass(mode) {
  if (!Array.isArray(mode.end))
    return;
  if (mode.skip || mode.excludeEnd || mode.returnEnd) {
    error("skip, excludeEnd, returnEnd not compatible with endScope: {}");
    throw MultiClassError;
  }
  if (typeof mode.endScope !== "object" || mode.endScope === null) {
    error("endScope must be object");
    throw MultiClassError;
  }
  remapScopeNames(mode, mode.end, { key: "endScope" });
  mode.end = _rewriteBackreferences(mode.end, { joinWith: "" });
}
function scopeSugar(mode) {
  if (mode.scope && typeof mode.scope === "object" && mode.scope !== null) {
    mode.beginScope = mode.scope;
    delete mode.scope;
  }
}
function MultiClass(mode) {
  scopeSugar(mode);
  if (typeof mode.beginScope === "string") {
    mode.beginScope = { _wrap: mode.beginScope };
  }
  if (typeof mode.endScope === "string") {
    mode.endScope = { _wrap: mode.endScope };
  }
  beginMultiClass(mode);
  endMultiClass(mode);
}
function compileLanguage(language) {
  function langRe(value, global2) {
    return new RegExp(
      source(value),
      "m" + (language.case_insensitive ? "i" : "") + (language.unicodeRegex ? "u" : "") + (global2 ? "g" : "")
    );
  }
  class MultiRegex {
    constructor() {
      this.matchIndexes = {};
      this.regexes = [];
      this.matchAt = 1;
      this.position = 0;
    }
    // @ts-ignore
    addRule(re, opts) {
      opts.position = this.position++;
      this.matchIndexes[this.matchAt] = opts;
      this.regexes.push([opts, re]);
      this.matchAt += countMatchGroups(re) + 1;
    }
    compile() {
      if (this.regexes.length === 0) {
        this.exec = () => null;
      }
      const terminators = this.regexes.map((el2) => el2[1]);
      this.matcherRe = langRe(_rewriteBackreferences(terminators, { joinWith: "|" }), true);
      this.lastIndex = 0;
    }
    /** @param {string} s */
    exec(s) {
      this.matcherRe.lastIndex = this.lastIndex;
      const match2 = this.matcherRe.exec(s);
      if (!match2) {
        return null;
      }
      const i = match2.findIndex((el2, i2) => i2 > 0 && el2 !== void 0);
      const matchData = this.matchIndexes[i];
      match2.splice(0, i);
      return Object.assign(match2, matchData);
    }
  }
  class ResumableMultiRegex {
    constructor() {
      this.rules = [];
      this.multiRegexes = [];
      this.count = 0;
      this.lastIndex = 0;
      this.regexIndex = 0;
    }
    // @ts-ignore
    getMatcher(index) {
      if (this.multiRegexes[index])
        return this.multiRegexes[index];
      const matcher = new MultiRegex();
      this.rules.slice(index).forEach(([re, opts]) => matcher.addRule(re, opts));
      matcher.compile();
      this.multiRegexes[index] = matcher;
      return matcher;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    // @ts-ignore
    addRule(re, opts) {
      this.rules.push([re, opts]);
      if (opts.type === "begin")
        this.count++;
    }
    /** @param {string} s */
    exec(s) {
      const m = this.getMatcher(this.regexIndex);
      m.lastIndex = this.lastIndex;
      let result2 = m.exec(s);
      if (this.resumingScanAtSamePosition()) {
        if (result2 && result2.index === this.lastIndex)
          ;
        else {
          const m2 = this.getMatcher(0);
          m2.lastIndex = this.lastIndex + 1;
          result2 = m2.exec(s);
        }
      }
      if (result2) {
        this.regexIndex += result2.position + 1;
        if (this.regexIndex === this.count) {
          this.considerAll();
        }
      }
      return result2;
    }
  }
  function buildModeRegex(mode) {
    const mm2 = new ResumableMultiRegex();
    mode.contains.forEach((term) => mm2.addRule(term.begin, { rule: term, type: "begin" }));
    if (mode.terminatorEnd) {
      mm2.addRule(mode.terminatorEnd, { type: "end" });
    }
    if (mode.illegal) {
      mm2.addRule(mode.illegal, { type: "illegal" });
    }
    return mm2;
  }
  function compileMode(mode, parent) {
    const cmode = (
      /** @type CompiledMode */
      mode
    );
    if (mode.isCompiled)
      return cmode;
    [
      scopeClassName,
      // do this early so compiler extensions generally don't have to worry about
      // the distinction between match/begin
      compileMatch,
      MultiClass,
      beforeMatchExt
    ].forEach((ext2) => ext2(mode, parent));
    language.compilerExtensions.forEach((ext2) => ext2(mode, parent));
    mode.__beforeBegin = null;
    [
      beginKeywords,
      // do this later so compiler extensions that come earlier have access to the
      // raw array if they wanted to perhaps manipulate it, etc.
      compileIllegal,
      // default to 1 relevance if not specified
      compileRelevance
    ].forEach((ext2) => ext2(mode, parent));
    mode.isCompiled = true;
    let keywordPattern = null;
    if (typeof mode.keywords === "object" && mode.keywords.$pattern) {
      mode.keywords = Object.assign({}, mode.keywords);
      keywordPattern = mode.keywords.$pattern;
      delete mode.keywords.$pattern;
    }
    keywordPattern = keywordPattern || /\w+/;
    if (mode.keywords) {
      mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
    }
    cmode.keywordPatternRe = langRe(keywordPattern, true);
    if (parent) {
      if (!mode.begin)
        mode.begin = /\B|\b/;
      cmode.beginRe = langRe(cmode.begin);
      if (!mode.end && !mode.endsWithParent)
        mode.end = /\B|\b/;
      if (mode.end)
        cmode.endRe = langRe(cmode.end);
      cmode.terminatorEnd = source(cmode.end) || "";
      if (mode.endsWithParent && parent.terminatorEnd) {
        cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd;
      }
    }
    if (mode.illegal)
      cmode.illegalRe = langRe(
        /** @type {RegExp | string} */
        mode.illegal
      );
    if (!mode.contains)
      mode.contains = [];
    mode.contains = [].concat(...mode.contains.map(function(c) {
      return expandOrCloneMode(c === "self" ? mode : c);
    }));
    mode.contains.forEach(function(c) {
      compileMode(
        /** @type Mode */
        c,
        cmode
      );
    });
    if (mode.starts) {
      compileMode(mode.starts, parent);
    }
    cmode.matcher = buildModeRegex(cmode);
    return cmode;
  }
  if (!language.compilerExtensions)
    language.compilerExtensions = [];
  if (language.contains && language.contains.includes("self")) {
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  }
  language.classNameAliases = inherit$1(language.classNameAliases || {});
  return compileMode(
    /** @type Mode */
    language
  );
}
function dependencyOnParent(mode) {
  if (!mode)
    return false;
  return mode.endsWithParent || dependencyOnParent(mode.starts);
}
function expandOrCloneMode(mode) {
  if (mode.variants && !mode.cachedVariants) {
    mode.cachedVariants = mode.variants.map(function(variant) {
      return inherit$1(mode, { variants: null }, variant);
    });
  }
  if (mode.cachedVariants) {
    return mode.cachedVariants;
  }
  if (dependencyOnParent(mode)) {
    return inherit$1(mode, { starts: mode.starts ? inherit$1(mode.starts) : null });
  }
  if (Object.isFrozen(mode)) {
    return inherit$1(mode);
  }
  return mode;
}
var version = "11.9.0";
class HTMLInjectionError extends Error {
  constructor(reason, html2) {
    super(reason);
    this.name = "HTMLInjectionError";
    this.html = html2;
  }
}
const escape$1 = escapeHTML;
const inherit = inherit$1;
const NO_MATCH = Symbol("nomatch");
const MAX_KEYWORD_HITS = 7;
const HLJS = function(hljs) {
  const languages = /* @__PURE__ */ Object.create(null);
  const aliases = /* @__PURE__ */ Object.create(null);
  const plugins = [];
  let SAFE_MODE = true;
  const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
  const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: "Plain text", contains: [] };
  let options = {
    ignoreUnescapedHTML: false,
    throwUnescapedHTML: false,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    // beta configuration options, subject to change, welcome to discuss
    // https://github.com/highlightjs/highlight.js/issues/1086
    __emitter: TokenTreeEmitter
  };
  function shouldNotHighlight(languageName) {
    return options.noHighlightRe.test(languageName);
  }
  function blockLanguage(block) {
    let classes = block.className + " ";
    classes += block.parentNode ? block.parentNode.className : "";
    const match2 = options.languageDetectRe.exec(classes);
    if (match2) {
      const language = getLanguage(match2[1]);
      if (!language) {
        warn(LANGUAGE_NOT_FOUND.replace("{}", match2[1]));
        warn("Falling back to no-highlight mode for this block.", block);
      }
      return language ? match2[1] : "no-highlight";
    }
    return classes.split(/\s+/).find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
  }
  function highlight2(codeOrLanguageName, optionsOrCode, ignoreIllegals) {
    let code3 = "";
    let languageName = "";
    if (typeof optionsOrCode === "object") {
      code3 = codeOrLanguageName;
      ignoreIllegals = optionsOrCode.ignoreIllegals;
      languageName = optionsOrCode.language;
    } else {
      deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
      deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
      languageName = codeOrLanguageName;
      code3 = optionsOrCode;
    }
    if (ignoreIllegals === void 0) {
      ignoreIllegals = true;
    }
    const context = {
      code: code3,
      language: languageName
    };
    fire("before:highlight", context);
    const result2 = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals);
    result2.code = context.code;
    fire("after:highlight", result2);
    return result2;
  }
  function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
    const keywordHits = /* @__PURE__ */ Object.create(null);
    function keywordData(mode, matchText) {
      return mode.keywords[matchText];
    }
    function processKeywords() {
      if (!top.keywords) {
        emitter.addText(modeBuffer);
        return;
      }
      let lastIndex = 0;
      top.keywordPatternRe.lastIndex = 0;
      let match2 = top.keywordPatternRe.exec(modeBuffer);
      let buf = "";
      while (match2) {
        buf += modeBuffer.substring(lastIndex, match2.index);
        const word = language.case_insensitive ? match2[0].toLowerCase() : match2[0];
        const data2 = keywordData(top, word);
        if (data2) {
          const [kind, keywordRelevance] = data2;
          emitter.addText(buf);
          buf = "";
          keywordHits[word] = (keywordHits[word] || 0) + 1;
          if (keywordHits[word] <= MAX_KEYWORD_HITS)
            relevance += keywordRelevance;
          if (kind.startsWith("_")) {
            buf += match2[0];
          } else {
            const cssClass = language.classNameAliases[kind] || kind;
            emitKeyword(match2[0], cssClass);
          }
        } else {
          buf += match2[0];
        }
        lastIndex = top.keywordPatternRe.lastIndex;
        match2 = top.keywordPatternRe.exec(modeBuffer);
      }
      buf += modeBuffer.substring(lastIndex);
      emitter.addText(buf);
    }
    function processSubLanguage() {
      if (modeBuffer === "")
        return;
      let result3 = null;
      if (typeof top.subLanguage === "string") {
        if (!languages[top.subLanguage]) {
          emitter.addText(modeBuffer);
          return;
        }
        result3 = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
        continuations[top.subLanguage] = /** @type {CompiledMode} */
        result3._top;
      } else {
        result3 = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
      }
      if (top.relevance > 0) {
        relevance += result3.relevance;
      }
      emitter.__addSublanguage(result3._emitter, result3.language);
    }
    function processBuffer() {
      if (top.subLanguage != null) {
        processSubLanguage();
      } else {
        processKeywords();
      }
      modeBuffer = "";
    }
    function emitKeyword(keyword, scope) {
      if (keyword === "")
        return;
      emitter.startScope(scope);
      emitter.addText(keyword);
      emitter.endScope();
    }
    function emitMultiClass(scope, match2) {
      let i = 1;
      const max2 = match2.length - 1;
      while (i <= max2) {
        if (!scope._emit[i]) {
          i++;
          continue;
        }
        const klass = language.classNameAliases[scope[i]] || scope[i];
        const text = match2[i];
        if (klass) {
          emitKeyword(text, klass);
        } else {
          modeBuffer = text;
          processKeywords();
          modeBuffer = "";
        }
        i++;
      }
    }
    function startNewMode(mode, match2) {
      if (mode.scope && typeof mode.scope === "string") {
        emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);
      }
      if (mode.beginScope) {
        if (mode.beginScope._wrap) {
          emitKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);
          modeBuffer = "";
        } else if (mode.beginScope._multi) {
          emitMultiClass(mode.beginScope, match2);
          modeBuffer = "";
        }
      }
      top = Object.create(mode, { parent: { value: top } });
      return top;
    }
    function endOfMode(mode, match2, matchPlusRemainder) {
      let matched = startsWith(mode.endRe, matchPlusRemainder);
      if (matched) {
        if (mode["on:end"]) {
          const resp = new Response(mode);
          mode["on:end"](match2, resp);
          if (resp.isMatchIgnored)
            matched = false;
        }
        if (matched) {
          while (mode.endsParent && mode.parent) {
            mode = mode.parent;
          }
          return mode;
        }
      }
      if (mode.endsWithParent) {
        return endOfMode(mode.parent, match2, matchPlusRemainder);
      }
    }
    function doIgnore(lexeme) {
      if (top.matcher.regexIndex === 0) {
        modeBuffer += lexeme[0];
        return 1;
      } else {
        resumeScanAtSamePosition = true;
        return 0;
      }
    }
    function doBeginMatch(match2) {
      const lexeme = match2[0];
      const newMode = match2.rule;
      const resp = new Response(newMode);
      const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
      for (const cb of beforeCallbacks) {
        if (!cb)
          continue;
        cb(match2, resp);
        if (resp.isMatchIgnored)
          return doIgnore(lexeme);
      }
      if (newMode.skip) {
        modeBuffer += lexeme;
      } else {
        if (newMode.excludeBegin) {
          modeBuffer += lexeme;
        }
        processBuffer();
        if (!newMode.returnBegin && !newMode.excludeBegin) {
          modeBuffer = lexeme;
        }
      }
      startNewMode(newMode, match2);
      return newMode.returnBegin ? 0 : lexeme.length;
    }
    function doEndMatch(match2) {
      const lexeme = match2[0];
      const matchPlusRemainder = codeToHighlight.substring(match2.index);
      const endMode = endOfMode(top, match2, matchPlusRemainder);
      if (!endMode) {
        return NO_MATCH;
      }
      const origin = top;
      if (top.endScope && top.endScope._wrap) {
        processBuffer();
        emitKeyword(lexeme, top.endScope._wrap);
      } else if (top.endScope && top.endScope._multi) {
        processBuffer();
        emitMultiClass(top.endScope, match2);
      } else if (origin.skip) {
        modeBuffer += lexeme;
      } else {
        if (!(origin.returnEnd || origin.excludeEnd)) {
          modeBuffer += lexeme;
        }
        processBuffer();
        if (origin.excludeEnd) {
          modeBuffer = lexeme;
        }
      }
      do {
        if (top.scope) {
          emitter.closeNode();
        }
        if (!top.skip && !top.subLanguage) {
          relevance += top.relevance;
        }
        top = top.parent;
      } while (top !== endMode.parent);
      if (endMode.starts) {
        startNewMode(endMode.starts, match2);
      }
      return origin.returnEnd ? 0 : lexeme.length;
    }
    function processContinuations() {
      const list2 = [];
      for (let current = top; current !== language; current = current.parent) {
        if (current.scope) {
          list2.unshift(current.scope);
        }
      }
      list2.forEach((item) => emitter.openNode(item));
    }
    let lastMatch = {};
    function processLexeme(textBeforeMatch, match2) {
      const lexeme = match2 && match2[0];
      modeBuffer += textBeforeMatch;
      if (lexeme == null) {
        processBuffer();
        return 0;
      }
      if (lastMatch.type === "begin" && match2.type === "end" && lastMatch.index === match2.index && lexeme === "") {
        modeBuffer += codeToHighlight.slice(match2.index, match2.index + 1);
        if (!SAFE_MODE) {
          const err = new Error(`0 width match regex (${languageName})`);
          err.languageName = languageName;
          err.badRule = lastMatch.rule;
          throw err;
        }
        return 1;
      }
      lastMatch = match2;
      if (match2.type === "begin") {
        return doBeginMatch(match2);
      } else if (match2.type === "illegal" && !ignoreIllegals) {
        const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.scope || "<unnamed>") + '"');
        err.mode = top;
        throw err;
      } else if (match2.type === "end") {
        const processed = doEndMatch(match2);
        if (processed !== NO_MATCH) {
          return processed;
        }
      }
      if (match2.type === "illegal" && lexeme === "") {
        return 1;
      }
      if (iterations > 1e5 && iterations > match2.index * 3) {
        const err = new Error("potential infinite loop, way more iterations than matches");
        throw err;
      }
      modeBuffer += lexeme;
      return lexeme.length;
    }
    const language = getLanguage(languageName);
    if (!language) {
      error(LANGUAGE_NOT_FOUND.replace("{}", languageName));
      throw new Error('Unknown language: "' + languageName + '"');
    }
    const md2 = compileLanguage(language);
    let result2 = "";
    let top = continuation || md2;
    const continuations = {};
    const emitter = new options.__emitter(options);
    processContinuations();
    let modeBuffer = "";
    let relevance = 0;
    let index = 0;
    let iterations = 0;
    let resumeScanAtSamePosition = false;
    try {
      if (!language.__emitTokens) {
        top.matcher.considerAll();
        for (; ; ) {
          iterations++;
          if (resumeScanAtSamePosition) {
            resumeScanAtSamePosition = false;
          } else {
            top.matcher.considerAll();
          }
          top.matcher.lastIndex = index;
          const match2 = top.matcher.exec(codeToHighlight);
          if (!match2)
            break;
          const beforeMatch = codeToHighlight.substring(index, match2.index);
          const processedCount = processLexeme(beforeMatch, match2);
          index = match2.index + processedCount;
        }
        processLexeme(codeToHighlight.substring(index));
      } else {
        language.__emitTokens(codeToHighlight, emitter);
      }
      emitter.finalize();
      result2 = emitter.toHTML();
      return {
        language: languageName,
        value: result2,
        relevance,
        illegal: false,
        _emitter: emitter,
        _top: top
      };
    } catch (err) {
      if (err.message && err.message.includes("Illegal")) {
        return {
          language: languageName,
          value: escape$1(codeToHighlight),
          illegal: true,
          relevance: 0,
          _illegalBy: {
            message: err.message,
            index,
            context: codeToHighlight.slice(index - 100, index + 100),
            mode: err.mode,
            resultSoFar: result2
          },
          _emitter: emitter
        };
      } else if (SAFE_MODE) {
        return {
          language: languageName,
          value: escape$1(codeToHighlight),
          illegal: false,
          relevance: 0,
          errorRaised: err,
          _emitter: emitter,
          _top: top
        };
      } else {
        throw err;
      }
    }
  }
  function justTextHighlightResult(code3) {
    const result2 = {
      value: escape$1(code3),
      illegal: false,
      relevance: 0,
      _top: PLAINTEXT_LANGUAGE,
      _emitter: new options.__emitter(options)
    };
    result2._emitter.addText(code3);
    return result2;
  }
  function highlightAuto(code3, languageSubset) {
    languageSubset = languageSubset || options.languages || Object.keys(languages);
    const plaintext = justTextHighlightResult(code3);
    const results = languageSubset.filter(getLanguage).filter(autoDetection).map(
      (name2) => _highlight(name2, code3, false)
    );
    results.unshift(plaintext);
    const sorted = results.sort((a, b) => {
      if (a.relevance !== b.relevance)
        return b.relevance - a.relevance;
      if (a.language && b.language) {
        if (getLanguage(a.language).supersetOf === b.language) {
          return 1;
        } else if (getLanguage(b.language).supersetOf === a.language) {
          return -1;
        }
      }
      return 0;
    });
    const [best, secondBest] = sorted;
    const result2 = best;
    result2.secondBest = secondBest;
    return result2;
  }
  function updateClassName(element, currentLang, resultLang) {
    const language = currentLang && aliases[currentLang] || resultLang;
    element.classList.add("hljs");
    element.classList.add(`language-${language}`);
  }
  function highlightElement(element) {
    let node = null;
    const language = blockLanguage(element);
    if (shouldNotHighlight(language))
      return;
    fire(
      "before:highlightElement",
      { el: element, language }
    );
    if (element.dataset.highlighted) {
      console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", element);
      return;
    }
    if (element.children.length > 0) {
      if (!options.ignoreUnescapedHTML) {
        console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk.");
        console.warn("https://github.com/highlightjs/highlight.js/wiki/security");
        console.warn("The element with unescaped HTML:");
        console.warn(element);
      }
      if (options.throwUnescapedHTML) {
        const err = new HTMLInjectionError(
          "One of your code blocks includes unescaped HTML.",
          element.innerHTML
        );
        throw err;
      }
    }
    node = element;
    const text = node.textContent;
    const result2 = language ? highlight2(text, { language, ignoreIllegals: true }) : highlightAuto(text);
    element.innerHTML = result2.value;
    element.dataset.highlighted = "yes";
    updateClassName(element, language, result2.language);
    element.result = {
      language: result2.language,
      // TODO: remove with version 11.0
      re: result2.relevance,
      relevance: result2.relevance
    };
    if (result2.secondBest) {
      element.secondBest = {
        language: result2.secondBest.language,
        relevance: result2.secondBest.relevance
      };
    }
    fire("after:highlightElement", { el: element, result: result2, text });
  }
  function configure(userOptions) {
    options = inherit(options, userOptions);
  }
  const initHighlighting = () => {
    highlightAll();
    deprecated("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function initHighlightingOnLoad() {
    highlightAll();
    deprecated("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  let wantsHighlight = false;
  function highlightAll() {
    if (document.readyState === "loading") {
      wantsHighlight = true;
      return;
    }
    const blocks = document.querySelectorAll(options.cssSelector);
    blocks.forEach(highlightElement);
  }
  function boot() {
    if (wantsHighlight)
      highlightAll();
  }
  if (typeof window !== "undefined" && window.addEventListener) {
    window.addEventListener("DOMContentLoaded", boot, false);
  }
  function registerLanguage(languageName, languageDefinition) {
    let lang = null;
    try {
      lang = languageDefinition(hljs);
    } catch (error$1) {
      error("Language definition for '{}' could not be registered.".replace("{}", languageName));
      if (!SAFE_MODE) {
        throw error$1;
      } else {
        error(error$1);
      }
      lang = PLAINTEXT_LANGUAGE;
    }
    if (!lang.name)
      lang.name = languageName;
    languages[languageName] = lang;
    lang.rawDefinition = languageDefinition.bind(null, hljs);
    if (lang.aliases) {
      registerAliases(lang.aliases, { languageName });
    }
  }
  function unregisterLanguage(languageName) {
    delete languages[languageName];
    for (const alias of Object.keys(aliases)) {
      if (aliases[alias] === languageName) {
        delete aliases[alias];
      }
    }
  }
  function listLanguages() {
    return Object.keys(languages);
  }
  function getLanguage(name2) {
    name2 = (name2 || "").toLowerCase();
    return languages[name2] || languages[aliases[name2]];
  }
  function registerAliases(aliasList, { languageName }) {
    if (typeof aliasList === "string") {
      aliasList = [aliasList];
    }
    aliasList.forEach((alias) => {
      aliases[alias.toLowerCase()] = languageName;
    });
  }
  function autoDetection(name2) {
    const lang = getLanguage(name2);
    return lang && !lang.disableAutodetect;
  }
  function upgradePluginAPI(plugin) {
    if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
      plugin["before:highlightElement"] = (data2) => {
        plugin["before:highlightBlock"](
          Object.assign({ block: data2.el }, data2)
        );
      };
    }
    if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
      plugin["after:highlightElement"] = (data2) => {
        plugin["after:highlightBlock"](
          Object.assign({ block: data2.el }, data2)
        );
      };
    }
  }
  function addPlugin(plugin) {
    upgradePluginAPI(plugin);
    plugins.push(plugin);
  }
  function removePlugin(plugin) {
    const index = plugins.indexOf(plugin);
    if (index !== -1) {
      plugins.splice(index, 1);
    }
  }
  function fire(event, args) {
    const cb = event;
    plugins.forEach(function(plugin) {
      if (plugin[cb]) {
        plugin[cb](args);
      }
    });
  }
  function deprecateHighlightBlock(el2) {
    deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
    deprecated("10.7.0", "Please use highlightElement now.");
    return highlightElement(el2);
  }
  Object.assign(hljs, {
    highlight: highlight2,
    highlightAuto,
    highlightAll,
    highlightElement,
    // TODO: Remove with v12 API
    highlightBlock: deprecateHighlightBlock,
    configure,
    initHighlighting,
    initHighlightingOnLoad,
    registerLanguage,
    unregisterLanguage,
    listLanguages,
    getLanguage,
    registerAliases,
    autoDetection,
    inherit,
    addPlugin,
    removePlugin
  });
  hljs.debugMode = function() {
    SAFE_MODE = false;
  };
  hljs.safeMode = function() {
    SAFE_MODE = true;
  };
  hljs.versionString = version;
  hljs.regex = {
    concat,
    lookahead,
    either,
    optional,
    anyNumberOfTimes
  };
  for (const key in MODES$1) {
    if (typeof MODES$1[key] === "object") {
      deepFreeze(MODES$1[key]);
    }
  }
  Object.assign(hljs, MODES$1);
  return hljs;
};
const highlight = HLJS({});
highlight.newInstance = () => HLJS({});
var core = highlight;
highlight.HighlightJS = highlight;
highlight.default = highlight;
const HighlightJS = /* @__PURE__ */ getDefaultExportFromCjs(core);
function bash(hljs) {
  const regex2 = hljs.regex;
  const VAR = {};
  const BRACED_VAR = {
    begin: /\$\{/,
    end: /\}/,
    contains: [
      "self",
      {
        begin: /:-/,
        contains: [VAR]
      }
      // default values
    ]
  };
  Object.assign(VAR, {
    className: "variable",
    variants: [
      { begin: regex2.concat(
        /\$[\w\d#@][\w\d_]*/,
        // negative look-ahead tries to avoid matching patterns that are not
        // Perl at all like $ident$, @ident@, etc.
        `(?![\\w\\d])(?![$])`
      ) },
      BRACED_VAR
    ]
  });
  const SUBST = {
    className: "subst",
    begin: /\$\(/,
    end: /\)/,
    contains: [hljs.BACKSLASH_ESCAPE]
  };
  const HERE_DOC = {
    begin: /<<-?\s*(?=\w+)/,
    starts: { contains: [
      hljs.END_SAME_AS_BEGIN({
        begin: /(\w+)/,
        end: /(\w+)/,
        className: "string"
      })
    ] }
  };
  const QUOTE_STRING = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [
      hljs.BACKSLASH_ESCAPE,
      VAR,
      SUBST
    ]
  };
  SUBST.contains.push(QUOTE_STRING);
  const ESCAPED_QUOTE = {
    match: /\\"/
  };
  const APOS_STRING = {
    className: "string",
    begin: /'/,
    end: /'/
  };
  const ESCAPED_APOS = {
    match: /\\'/
  };
  const ARITHMETIC = {
    begin: /\$?\(\(/,
    end: /\)\)/,
    contains: [
      {
        begin: /\d+#[0-9a-f]+/,
        className: "number"
      },
      hljs.NUMBER_MODE,
      VAR
    ]
  };
  const SH_LIKE_SHELLS = [
    "fish",
    "bash",
    "zsh",
    "sh",
    "csh",
    "ksh",
    "tcsh",
    "dash",
    "scsh"
  ];
  const KNOWN_SHEBANG = hljs.SHEBANG({
    binary: `(${SH_LIKE_SHELLS.join("|")})`,
    relevance: 10
  });
  const FUNCTION = {
    className: "function",
    begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
    returnBegin: true,
    contains: [hljs.inherit(hljs.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
    relevance: 0
  };
  const KEYWORDS2 = [
    "if",
    "then",
    "else",
    "elif",
    "fi",
    "for",
    "while",
    "until",
    "in",
    "do",
    "done",
    "case",
    "esac",
    "function",
    "select"
  ];
  const LITERALS2 = [
    "true",
    "false"
  ];
  const PATH_MODE = { match: /(\/[a-z._-]+)+/ };
  const SHELL_BUILT_INS = [
    "break",
    "cd",
    "continue",
    "eval",
    "exec",
    "exit",
    "export",
    "getopts",
    "hash",
    "pwd",
    "readonly",
    "return",
    "shift",
    "test",
    "times",
    "trap",
    "umask",
    "unset"
  ];
  const BASH_BUILT_INS = [
    "alias",
    "bind",
    "builtin",
    "caller",
    "command",
    "declare",
    "echo",
    "enable",
    "help",
    "let",
    "local",
    "logout",
    "mapfile",
    "printf",
    "read",
    "readarray",
    "source",
    "type",
    "typeset",
    "ulimit",
    "unalias"
  ];
  const ZSH_BUILT_INS = [
    "autoload",
    "bg",
    "bindkey",
    "bye",
    "cap",
    "chdir",
    "clone",
    "comparguments",
    "compcall",
    "compctl",
    "compdescribe",
    "compfiles",
    "compgroups",
    "compquote",
    "comptags",
    "comptry",
    "compvalues",
    "dirs",
    "disable",
    "disown",
    "echotc",
    "echoti",
    "emulate",
    "fc",
    "fg",
    "float",
    "functions",
    "getcap",
    "getln",
    "history",
    "integer",
    "jobs",
    "kill",
    "limit",
    "log",
    "noglob",
    "popd",
    "print",
    "pushd",
    "pushln",
    "rehash",
    "sched",
    "setcap",
    "setopt",
    "stat",
    "suspend",
    "ttyctl",
    "unfunction",
    "unhash",
    "unlimit",
    "unsetopt",
    "vared",
    "wait",
    "whence",
    "where",
    "which",
    "zcompile",
    "zformat",
    "zftp",
    "zle",
    "zmodload",
    "zparseopts",
    "zprof",
    "zpty",
    "zregexparse",
    "zsocket",
    "zstyle",
    "ztcp"
  ];
  const GNU_CORE_UTILS = [
    "chcon",
    "chgrp",
    "chown",
    "chmod",
    "cp",
    "dd",
    "df",
    "dir",
    "dircolors",
    "ln",
    "ls",
    "mkdir",
    "mkfifo",
    "mknod",
    "mktemp",
    "mv",
    "realpath",
    "rm",
    "rmdir",
    "shred",
    "sync",
    "touch",
    "truncate",
    "vdir",
    "b2sum",
    "base32",
    "base64",
    "cat",
    "cksum",
    "comm",
    "csplit",
    "cut",
    "expand",
    "fmt",
    "fold",
    "head",
    "join",
    "md5sum",
    "nl",
    "numfmt",
    "od",
    "paste",
    "ptx",
    "pr",
    "sha1sum",
    "sha224sum",
    "sha256sum",
    "sha384sum",
    "sha512sum",
    "shuf",
    "sort",
    "split",
    "sum",
    "tac",
    "tail",
    "tr",
    "tsort",
    "unexpand",
    "uniq",
    "wc",
    "arch",
    "basename",
    "chroot",
    "date",
    "dirname",
    "du",
    "echo",
    "env",
    "expr",
    "factor",
    // "false", // keyword literal already
    "groups",
    "hostid",
    "id",
    "link",
    "logname",
    "nice",
    "nohup",
    "nproc",
    "pathchk",
    "pinky",
    "printenv",
    "printf",
    "pwd",
    "readlink",
    "runcon",
    "seq",
    "sleep",
    "stat",
    "stdbuf",
    "stty",
    "tee",
    "test",
    "timeout",
    // "true", // keyword literal already
    "tty",
    "uname",
    "unlink",
    "uptime",
    "users",
    "who",
    "whoami",
    "yes"
  ];
  return {
    name: "Bash",
    aliases: ["sh"],
    keywords: {
      $pattern: /\b[a-z][a-z0-9._-]+\b/,
      keyword: KEYWORDS2,
      literal: LITERALS2,
      built_in: [
        ...SHELL_BUILT_INS,
        ...BASH_BUILT_INS,
        // Shell modifiers
        "set",
        "shopt",
        ...ZSH_BUILT_INS,
        ...GNU_CORE_UTILS
      ]
    },
    contains: [
      KNOWN_SHEBANG,
      // to catch known shells and boost relevancy
      hljs.SHEBANG(),
      // to catch unknown shells but still highlight the shebang
      FUNCTION,
      ARITHMETIC,
      hljs.HASH_COMMENT_MODE,
      HERE_DOC,
      PATH_MODE,
      QUOTE_STRING,
      ESCAPED_QUOTE,
      APOS_STRING,
      ESCAPED_APOS,
      VAR
    ]
  };
}
function twig(hljs) {
  const regex2 = hljs.regex;
  const FUNCTION_NAMES = [
    "absolute_url",
    "asset|0",
    "asset_version",
    "attribute",
    "block",
    "constant",
    "controller|0",
    "country_timezones",
    "csrf_token",
    "cycle",
    "date",
    "dump",
    "expression",
    "form|0",
    "form_end",
    "form_errors",
    "form_help",
    "form_label",
    "form_rest",
    "form_row",
    "form_start",
    "form_widget",
    "html_classes",
    "include",
    "is_granted",
    "logout_path",
    "logout_url",
    "max",
    "min",
    "parent",
    "path|0",
    "random",
    "range",
    "relative_path",
    "render",
    "render_esi",
    "source",
    "template_from_string",
    "url|0"
  ];
  const FILTERS = [
    "abs",
    "abbr_class",
    "abbr_method",
    "batch",
    "capitalize",
    "column",
    "convert_encoding",
    "country_name",
    "currency_name",
    "currency_symbol",
    "data_uri",
    "date",
    "date_modify",
    "default",
    "escape",
    "file_excerpt",
    "file_link",
    "file_relative",
    "filter",
    "first",
    "format",
    "format_args",
    "format_args_as_text",
    "format_currency",
    "format_date",
    "format_datetime",
    "format_file",
    "format_file_from_text",
    "format_number",
    "format_time",
    "html_to_markdown",
    "humanize",
    "inky_to_html",
    "inline_css",
    "join",
    "json_encode",
    "keys",
    "language_name",
    "last",
    "length",
    "locale_name",
    "lower",
    "map",
    "markdown",
    "markdown_to_html",
    "merge",
    "nl2br",
    "number_format",
    "raw",
    "reduce",
    "replace",
    "reverse",
    "round",
    "slice",
    "slug",
    "sort",
    "spaceless",
    "split",
    "striptags",
    "timezone_name",
    "title",
    "trans",
    "transchoice",
    "trim",
    "u|0",
    "upper",
    "url_encode",
    "yaml_dump",
    "yaml_encode"
  ];
  let TAG_NAMES = [
    "apply",
    "autoescape",
    "block",
    "cache",
    "deprecated",
    "do",
    "embed",
    "extends",
    "filter",
    "flush",
    "for",
    "form_theme",
    "from",
    "if",
    "import",
    "include",
    "macro",
    "sandbox",
    "set",
    "stopwatch",
    "trans",
    "trans_default_domain",
    "transchoice",
    "use",
    "verbatim",
    "with"
  ];
  TAG_NAMES = TAG_NAMES.concat(TAG_NAMES.map((t) => `end${t}`));
  const STRING = {
    scope: "string",
    variants: [
      {
        begin: /'/,
        end: /'/
      },
      {
        begin: /"/,
        end: /"/
      }
    ]
  };
  const NUMBER = {
    scope: "number",
    match: /\d+/
  };
  const PARAMS = {
    begin: /\(/,
    end: /\)/,
    excludeBegin: true,
    excludeEnd: true,
    contains: [
      STRING,
      NUMBER
    ]
  };
  const FUNCTIONS = {
    beginKeywords: FUNCTION_NAMES.join(" "),
    keywords: { name: FUNCTION_NAMES },
    relevance: 0,
    contains: [PARAMS]
  };
  const FILTER = {
    match: /\|(?=[A-Za-z_]+:?)/,
    beginScope: "punctuation",
    relevance: 0,
    contains: [
      {
        match: /[A-Za-z_]+:?/,
        keywords: FILTERS
      }
    ]
  };
  const tagNamed = (tagnames, { relevance }) => {
    return {
      beginScope: {
        1: "template-tag",
        3: "name"
      },
      relevance: relevance || 2,
      endScope: "template-tag",
      begin: [
        /\{%/,
        /\s*/,
        regex2.either(...tagnames)
      ],
      end: /%\}/,
      keywords: "in",
      contains: [
        FILTER,
        FUNCTIONS,
        STRING,
        NUMBER
      ]
    };
  };
  const CUSTOM_TAG_RE = /[a-z_]+/;
  const TAG = tagNamed(TAG_NAMES, { relevance: 2 });
  const CUSTOM_TAG = tagNamed([CUSTOM_TAG_RE], { relevance: 1 });
  return {
    name: "Twig",
    aliases: ["craftcms"],
    case_insensitive: true,
    subLanguage: "xml",
    contains: [
      hljs.COMMENT(/\{#/, /#\}/),
      TAG,
      CUSTOM_TAG,
      {
        className: "template-variable",
        begin: /\{\{/,
        end: /\}\}/,
        contains: [
          "self",
          FILTER,
          FUNCTIONS,
          STRING,
          NUMBER
        ]
      }
    ]
  };
}
const require$$0$1 = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "math",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rb",
  "rp",
  "rt",
  "rtc",
  "ruby",
  "s",
  "samp",
  "script",
  "search",
  "section",
  "select",
  "slot",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "svg",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr"
];
var htmlTags = require$$0$1;
const __htmlTags = /* @__PURE__ */ getDefaultExportFromCjs(htmlTags);
const require$$0 = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "link",
  "menuitem",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
var _void = require$$0;
const __selfClosingHtmlTags = /* @__PURE__ */ getDefaultExportFromCjs(_void);
const MODES = (hljs) => {
  return {
    IMPORTANT: {
      className: "meta",
      begin: "!important"
    },
    HEXCOLOR: {
      className: "number",
      begin: "#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})"
    },
    ATTRIBUTE_SELECTOR_MODE: {
      className: "selector-attr",
      begin: /\[/,
      end: /\]/,
      illegal: "$",
      contains: [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE]
    }
  };
};
const TAGS = [...__htmlTags, ...__selfClosingHtmlTags];
const MEDIA_FEATURES = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
];
const PSEUDO_CLASSES = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  "host",
  "host-context",
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  "nth-child",
  "nth-col",
  "nth-last-child",
  "nth-last-col",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
];
const PSEUDO_ELEMENTS = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
];
const ATTRIBUTES = knownCssProperties.all.reverse();
function css(hljs) {
  const modes = MODES(hljs);
  const PSEUDO_ELEMENTS$1 = PSEUDO_ELEMENTS;
  const PSEUDO_CLASSES$1 = PSEUDO_CLASSES;
  const AT_IDENTIFIER = "@[a-z-.]+";
  const AT_MODIFIERS = "and or not only";
  const IDENT_RE2 = "[a-zA-Z-.][a-zA-Z0-9_.-]*";
  const VARIABLE = {
    className: "variable",
    begin: "(\\$" + IDENT_RE2 + ")\\b"
  };
  const ret = {
    name: "CSS",
    case_insensitive: true,
    illegal: "[=/|']",
    contains: [
      {
        className: "sugar-function",
        begin: "sugar\\.[a-zA-Z0-9-_\\.]+",
        contains: [hljs.QUOTE_STRING_MODE, hljs.APOS_STRING_MODE]
      },
      {
        className: "sugar-mixin",
        begin: "@sugar\\.[a-zA-Z0-9-_\\.]+",
        contains: [hljs.QUOTE_STRING_MODE, hljs.APOS_STRING_MODE]
      },
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      {
        className: "selector-id",
        begin: "#[A-Za-z0-9_-]+",
        relevance: 0
      },
      {
        className: "selector-class",
        begin: "\\.[A-Za-z0-9_-]+",
        relevance: 0
      },
      modes.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-tag",
        begin: "\\b(" + TAGS.join("|") + ")\\b",
        // was there, before, but why?
        relevance: 0
      },
      {
        className: "selector-pseudo",
        begin: ":(" + PSEUDO_CLASSES$1.join("|") + ")"
      },
      {
        className: "selector-pseudo",
        begin: "::(" + PSEUDO_ELEMENTS$1.join("|") + ")"
      },
      VARIABLE,
      {
        // pseudo-selector params
        begin: /\(/,
        end: /\)/,
        contains: [hljs.NUMBER_MODE]
      },
      {
        className: "attribute",
        begin: "\\b(" + ATTRIBUTES.join("|") + ")\\b"
      },
      {
        begin: "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b"
      },
      // {
      //   begin: ':',
      //   end: ';',
      //   contains: [
      //     VARIABLE,
      //     modes.HEXCOLOR,
      //     hljs.NUMBER_MODE,
      //     hljs.QUOTE_STRING_MODE,
      //     hljs.APOS_STRING_MODE,
      //     modes.IMPORTANT
      //   ]
      // },
      // matching these here allows us to treat them more like regular CSS
      // rules so everything between the {} gets regular rule highlighting,
      // which is what we want for page and font-face
      {
        begin: "@(page|font-face)",
        lexemes: AT_IDENTIFIER,
        keywords: "@page @font-face"
      },
      {
        begin: "@",
        end: "[{;]",
        returnBegin: true,
        keywords: {
          $pattern: /[a-zA-Z-\.]+/,
          keyword: AT_MODIFIERS,
          attribute: MEDIA_FEATURES.join(" ")
        },
        contains: [
          {
            begin: AT_IDENTIFIER,
            className: "keyword"
          },
          {
            begin: /[a-zA-Z\.-]+(?=:)/,
            className: "attribute"
          },
          VARIABLE,
          hljs.QUOTE_STRING_MODE,
          hljs.APOS_STRING_MODE,
          modes.HEXCOLOR,
          hljs.NUMBER_MODE
        ]
      }
    ]
  };
  return ret;
}
const IDENT_RE = "[A-Za-z$_][0-9A-Za-z$_]*";
const KEYWORDS = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
];
const LITERALS = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
];
const TYPES = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
];
const ERROR_TYPES = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
];
const BUILT_IN_GLOBALS = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
];
const BUILT_IN_VARIABLES = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
];
const BUILT_INS = [].concat(
  BUILT_IN_GLOBALS,
  TYPES,
  ERROR_TYPES
);
function javascript(hljs) {
  const regex2 = hljs.regex;
  const hasClosingTag = (match2, { after }) => {
    const tag2 = "</" + match2[0].slice(1);
    const pos = match2.input.indexOf(tag2, after);
    return pos !== -1;
  };
  const IDENT_RE$12 = IDENT_RE;
  const FRAGMENT = {
    begin: "<>",
    end: "</>"
  };
  const XML_SELF_CLOSING = /<[A-Za-z0-9\\._:-]+\s*\/>/;
  const XML_TAG = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (match2, response) => {
      const afterMatchIndex = match2[0].length + match2.index;
      const nextChar = match2.input[afterMatchIndex];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        nextChar === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        nextChar === ","
      ) {
        response.ignoreMatch();
        return;
      }
      if (nextChar === ">") {
        if (!hasClosingTag(match2, { after: afterMatchIndex })) {
          response.ignoreMatch();
        }
      }
      let m;
      const afterMatch = match2.input.substring(afterMatchIndex);
      if (m = afterMatch.match(/^\s*=/)) {
        response.ignoreMatch();
        return;
      }
      if (m = afterMatch.match(/^\s+extends\s+/)) {
        if (m.index === 0) {
          response.ignoreMatch();
          return;
        }
      }
    }
  };
  const KEYWORDS$1 = {
    $pattern: IDENT_RE,
    keyword: KEYWORDS,
    literal: LITERALS,
    built_in: BUILT_INS,
    "variable.language": BUILT_IN_VARIABLES
  };
  const decimalDigits = "[0-9](_?[0-9])*";
  const frac = `\\.(${decimalDigits})`;
  const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
  const NUMBER = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})\\b` },
      { begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b` },
      // DecimalBigIntegerLiteral
      { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  };
  const SUBST = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: KEYWORDS$1,
    contains: []
    // defined later
  };
  const HTML_TEMPLATE = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: "xml"
    }
  };
  const CSS_TEMPLATE = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: "css"
    }
  };
  const GRAPHQL_TEMPLATE = {
    begin: "gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: "graphql"
    }
  };
  const TEMPLATE_STRING = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      hljs.BACKSLASH_ESCAPE,
      SUBST
    ]
  };
  const JSDOC_COMMENT = hljs.COMMENT(
    /\/\*\*(?!\/)/,
    "\\*/",
    {
      relevance: 0,
      contains: [
        {
          begin: "(?=@[A-Za-z]+)",
          relevance: 0,
          contains: [
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            },
            {
              className: "type",
              begin: "\\{",
              end: "\\}",
              excludeEnd: true,
              excludeBegin: true,
              relevance: 0
            },
            {
              className: "variable",
              begin: IDENT_RE$12 + "(?=\\s*(-)|$)",
              endsParent: true,
              relevance: 0
            },
            // eat spaces (not newlines) so we can find
            // types or variables
            {
              begin: /(?=[^\n])\s/,
              relevance: 0
            }
          ]
        }
      ]
    }
  );
  const COMMENT2 = {
    className: "comment",
    variants: [
      JSDOC_COMMENT,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.C_LINE_COMMENT_MODE
    ]
  };
  const SUBST_INTERNALS = [
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE,
    HTML_TEMPLATE,
    CSS_TEMPLATE,
    GRAPHQL_TEMPLATE,
    TEMPLATE_STRING,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    NUMBER
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  SUBST.contains = SUBST_INTERNALS.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: KEYWORDS$1,
    contains: [
      "self"
    ].concat(SUBST_INTERNALS)
  });
  const SUBST_AND_COMMENTS = [].concat(COMMENT2, SUBST.contains);
  const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
    // eat recursive parens in sub expressions
    {
      begin: /\(/,
      end: /\)/,
      keywords: KEYWORDS$1,
      contains: ["self"].concat(SUBST_AND_COMMENTS)
    }
  ]);
  const PARAMS = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: true,
    excludeEnd: true,
    keywords: KEYWORDS$1,
    contains: PARAMS_CONTAINS
  };
  const CLASS_OR_EXTENDS = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          IDENT_RE$12,
          /\s+/,
          /extends/,
          /\s+/,
          regex2.concat(IDENT_RE$12, "(", regex2.concat(/\./, IDENT_RE$12), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          IDENT_RE$12
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  };
  const CLASS_REFERENCE = {
    relevance: 0,
    match: regex2.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...TYPES,
        ...ERROR_TYPES
      ]
    }
  };
  const USE_STRICT = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  };
  const FUNCTION_DEFINITION = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          IDENT_RE$12,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [PARAMS],
    illegal: /%/
  };
  const UPPER_CASE_CONSTANT = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function noneOf(list2) {
    return regex2.concat("(?!", list2.join("|"), ")");
  }
  const FUNCTION_CALL = {
    match: regex2.concat(
      /\b/,
      noneOf([
        ...BUILT_IN_GLOBALS,
        "super",
        "import"
      ]),
      IDENT_RE$12,
      regex2.lookahead(/\(/)
    ),
    className: "title.function",
    relevance: 0
  };
  const PROPERTY_ACCESS = {
    begin: regex2.concat(/\./, regex2.lookahead(
      regex2.concat(IDENT_RE$12, /(?![0-9A-Za-z$_(])/)
    )),
    end: IDENT_RE$12,
    excludeBegin: true,
    keywords: "prototype",
    className: "property",
    relevance: 0
  };
  const GETTER_OR_SETTER = {
    match: [
      /get|set/,
      /\s+/,
      IDENT_RE$12,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      PARAMS
    ]
  };
  const FUNC_LEAD_IN_RE = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + hljs.UNDERSCORE_IDENT_RE + ")\\s*=>";
  const FUNCTION_VARIABLE = {
    match: [
      /const|var|let/,
      /\s+/,
      IDENT_RE$12,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      regex2.lookahead(FUNC_LEAD_IN_RE)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      PARAMS
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: KEYWORDS$1,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS, CLASS_REFERENCE },
    illegal: /#(?![$_A-z])/,
    contains: [
      hljs.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      USE_STRICT,
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      HTML_TEMPLATE,
      CSS_TEMPLATE,
      GRAPHQL_TEMPLATE,
      TEMPLATE_STRING,
      COMMENT2,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      NUMBER,
      CLASS_REFERENCE,
      {
        className: "attr",
        begin: IDENT_RE$12 + regex2.lookahead(":"),
        relevance: 0
      },
      FUNCTION_VARIABLE,
      {
        // "value" container
        begin: "(" + hljs.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          COMMENT2,
          hljs.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: FUNC_LEAD_IN_RE,
            returnBegin: true,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: hljs.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: true
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: true,
                    excludeEnd: true,
                    keywords: KEYWORDS$1,
                    contains: PARAMS_CONTAINS
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: FRAGMENT.begin, end: FRAGMENT.end },
              { match: XML_SELF_CLOSING },
              {
                begin: XML_TAG.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": XML_TAG.isTrulyOpeningTag,
                end: XML_TAG.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: XML_TAG.begin,
                end: XML_TAG.end,
                skip: true,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      FUNCTION_DEFINITION,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + hljs.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: true,
        label: "func.def",
        contains: [
          PARAMS,
          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$12, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      PROPERTY_ACCESS,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + IDENT_RE$12,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [PARAMS]
      },
      FUNCTION_CALL,
      UPPER_CASE_CONSTANT,
      CLASS_OR_EXTENDS,
      GETTER_OR_SETTER,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function php(hljs) {
  const regex2 = hljs.regex;
  const NOT_PERL_ETC = /(?![A-Za-z0-9])(?![$])/;
  const IDENT_RE2 = regex2.concat(
    /[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/,
    NOT_PERL_ETC
  );
  const PASCAL_CASE_CLASS_NAME_RE = regex2.concat(
    /(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/,
    NOT_PERL_ETC
  );
  const VARIABLE = {
    scope: "variable",
    match: "\\$+" + IDENT_RE2
  };
  const PREPROCESSOR = {
    scope: "meta",
    variants: [
      { begin: /<\?php/, relevance: 10 },
      // boost for obvious PHP
      { begin: /<\?=/ },
      // less relevant per PSR-1 which says not to use short-tags
      { begin: /<\?/, relevance: 0.1 },
      { begin: /\?>/ }
      // end php tag
    ]
  };
  const SUBST = {
    scope: "subst",
    variants: [
      { begin: /\$\w+/ },
      {
        begin: /\{\$/,
        end: /\}/
      }
    ]
  };
  const SINGLE_QUOTED = hljs.inherit(hljs.APOS_STRING_MODE, { illegal: null });
  const DOUBLE_QUOTED = hljs.inherit(hljs.QUOTE_STRING_MODE, {
    illegal: null,
    contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST)
  });
  const HEREDOC = {
    begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/,
    end: /[ \t]*(\w+)\b/,
    contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST),
    "on:begin": (m, resp) => {
      resp.data._beginMatch = m[1] || m[2];
    },
    "on:end": (m, resp) => {
      if (resp.data._beginMatch !== m[1])
        resp.ignoreMatch();
    }
  };
  const NOWDOC = hljs.END_SAME_AS_BEGIN({
    begin: /<<<[ \t]*'(\w+)'\n/,
    end: /[ \t]*(\w+)\b/
  });
  const WHITESPACE2 = "[ 	\n]";
  const STRING = {
    scope: "string",
    variants: [
      DOUBLE_QUOTED,
      SINGLE_QUOTED,
      HEREDOC,
      NOWDOC
    ]
  };
  const NUMBER = {
    scope: "number",
    variants: [
      { begin: `\\b0[bB][01]+(?:_[01]+)*\\b` },
      // Binary w/ underscore support
      { begin: `\\b0[oO][0-7]+(?:_[0-7]+)*\\b` },
      // Octals w/ underscore support
      { begin: `\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b` },
      // Hex w/ underscore support
      // Decimals w/ underscore support, with optional fragments and scientific exponent (e) suffix.
      { begin: `(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?` }
    ],
    relevance: 0
  };
  const LITERALS2 = [
    "false",
    "null",
    "true"
  ];
  const KWS = [
    // Magic constants:
    // <https://www.php.net/manual/en/language.constants.predefined.php>
    "__CLASS__",
    "__DIR__",
    "__FILE__",
    "__FUNCTION__",
    "__COMPILER_HALT_OFFSET__",
    "__LINE__",
    "__METHOD__",
    "__NAMESPACE__",
    "__TRAIT__",
    // Function that look like language construct or language construct that look like function:
    // List of keywords that may not require parenthesis
    "die",
    "echo",
    "exit",
    "include",
    "include_once",
    "print",
    "require",
    "require_once",
    // These are not language construct (function) but operate on the currently-executing function and can access the current symbol table
    // 'compact extract func_get_arg func_get_args func_num_args get_called_class get_parent_class ' +
    // Other keywords:
    // <https://www.php.net/manual/en/reserved.php>
    // <https://www.php.net/manual/en/language.types.type-juggling.php>
    "array",
    "abstract",
    "and",
    "as",
    "binary",
    "bool",
    "boolean",
    "break",
    "callable",
    "case",
    "catch",
    "class",
    "clone",
    "const",
    "continue",
    "declare",
    "default",
    "do",
    "double",
    "else",
    "elseif",
    "empty",
    "enddeclare",
    "endfor",
    "endforeach",
    "endif",
    "endswitch",
    "endwhile",
    "enum",
    "eval",
    "extends",
    "final",
    "finally",
    "float",
    "for",
    "foreach",
    "from",
    "global",
    "goto",
    "if",
    "implements",
    "instanceof",
    "insteadof",
    "int",
    "integer",
    "interface",
    "isset",
    "iterable",
    "list",
    "match|0",
    "mixed",
    "new",
    "never",
    "object",
    "or",
    "private",
    "protected",
    "public",
    "readonly",
    "real",
    "return",
    "string",
    "switch",
    "throw",
    "trait",
    "try",
    "unset",
    "use",
    "var",
    "void",
    "while",
    "xor",
    "yield"
  ];
  const BUILT_INS2 = [
    // Standard PHP library:
    // <https://www.php.net/manual/en/book.spl.php>
    "Error|0",
    "AppendIterator",
    "ArgumentCountError",
    "ArithmeticError",
    "ArrayIterator",
    "ArrayObject",
    "AssertionError",
    "BadFunctionCallException",
    "BadMethodCallException",
    "CachingIterator",
    "CallbackFilterIterator",
    "CompileError",
    "Countable",
    "DirectoryIterator",
    "DivisionByZeroError",
    "DomainException",
    "EmptyIterator",
    "ErrorException",
    "Exception",
    "FilesystemIterator",
    "FilterIterator",
    "GlobIterator",
    "InfiniteIterator",
    "InvalidArgumentException",
    "IteratorIterator",
    "LengthException",
    "LimitIterator",
    "LogicException",
    "MultipleIterator",
    "NoRewindIterator",
    "OutOfBoundsException",
    "OutOfRangeException",
    "OuterIterator",
    "OverflowException",
    "ParentIterator",
    "ParseError",
    "RangeException",
    "RecursiveArrayIterator",
    "RecursiveCachingIterator",
    "RecursiveCallbackFilterIterator",
    "RecursiveDirectoryIterator",
    "RecursiveFilterIterator",
    "RecursiveIterator",
    "RecursiveIteratorIterator",
    "RecursiveRegexIterator",
    "RecursiveTreeIterator",
    "RegexIterator",
    "RuntimeException",
    "SeekableIterator",
    "SplDoublyLinkedList",
    "SplFileInfo",
    "SplFileObject",
    "SplFixedArray",
    "SplHeap",
    "SplMaxHeap",
    "SplMinHeap",
    "SplObjectStorage",
    "SplObserver",
    "SplPriorityQueue",
    "SplQueue",
    "SplStack",
    "SplSubject",
    "SplTempFileObject",
    "TypeError",
    "UnderflowException",
    "UnexpectedValueException",
    "UnhandledMatchError",
    // Reserved interfaces:
    // <https://www.php.net/manual/en/reserved.interfaces.php>
    "ArrayAccess",
    "BackedEnum",
    "Closure",
    "Fiber",
    "Generator",
    "Iterator",
    "IteratorAggregate",
    "Serializable",
    "Stringable",
    "Throwable",
    "Traversable",
    "UnitEnum",
    "WeakReference",
    "WeakMap",
    // Reserved classes:
    // <https://www.php.net/manual/en/reserved.classes.php>
    "Directory",
    "__PHP_Incomplete_Class",
    "parent",
    "php_user_filter",
    "self",
    "static",
    "stdClass"
  ];
  const dualCase = (items) => {
    const result2 = [];
    items.forEach((item) => {
      result2.push(item);
      if (item.toLowerCase() === item) {
        result2.push(item.toUpperCase());
      } else {
        result2.push(item.toLowerCase());
      }
    });
    return result2;
  };
  const KEYWORDS2 = {
    keyword: KWS,
    literal: dualCase(LITERALS2),
    built_in: BUILT_INS2
  };
  const normalizeKeywords = (items) => {
    return items.map((item) => {
      return item.replace(/\|\d+$/, "");
    });
  };
  const CONSTRUCTOR_CALL = { variants: [
    {
      match: [
        /new/,
        regex2.concat(WHITESPACE2, "+"),
        // to prevent built ins from being confused as the class constructor call
        regex2.concat("(?!", normalizeKeywords(BUILT_INS2).join("\\b|"), "\\b)"),
        PASCAL_CASE_CLASS_NAME_RE
      ],
      scope: {
        1: "keyword",
        4: "title.class"
      }
    }
  ] };
  const CONSTANT_REFERENCE = regex2.concat(IDENT_RE2, "\\b(?!\\()");
  const LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON = { variants: [
    {
      match: [
        regex2.concat(
          /::/,
          regex2.lookahead(/(?!class\b)/)
        ),
        CONSTANT_REFERENCE
      ],
      scope: { 2: "variable.constant" }
    },
    {
      match: [
        /::/,
        /class/
      ],
      scope: { 2: "variable.language" }
    },
    {
      match: [
        PASCAL_CASE_CLASS_NAME_RE,
        regex2.concat(
          /::/,
          regex2.lookahead(/(?!class\b)/)
        ),
        CONSTANT_REFERENCE
      ],
      scope: {
        1: "title.class",
        3: "variable.constant"
      }
    },
    {
      match: [
        PASCAL_CASE_CLASS_NAME_RE,
        regex2.concat(
          "::",
          regex2.lookahead(/(?!class\b)/)
        )
      ],
      scope: { 1: "title.class" }
    },
    {
      match: [
        PASCAL_CASE_CLASS_NAME_RE,
        /::/,
        /class/
      ],
      scope: {
        1: "title.class",
        3: "variable.language"
      }
    }
  ] };
  const NAMED_ARGUMENT = {
    scope: "attr",
    match: regex2.concat(IDENT_RE2, regex2.lookahead(":"), regex2.lookahead(/(?!::)/))
  };
  const PARAMS_MODE = {
    relevance: 0,
    begin: /\(/,
    end: /\)/,
    keywords: KEYWORDS2,
    contains: [
      NAMED_ARGUMENT,
      VARIABLE,
      LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
      hljs.C_BLOCK_COMMENT_MODE,
      STRING,
      NUMBER,
      CONSTRUCTOR_CALL
    ]
  };
  const FUNCTION_INVOKE = {
    relevance: 0,
    match: [
      /\b/,
      // to prevent keywords from being confused as the function title
      regex2.concat("(?!fn\\b|function\\b|", normalizeKeywords(KWS).join("\\b|"), "|", normalizeKeywords(BUILT_INS2).join("\\b|"), "\\b)"),
      IDENT_RE2,
      regex2.concat(WHITESPACE2, "*"),
      regex2.lookahead(/(?=\()/)
    ],
    scope: { 3: "title.function.invoke" },
    contains: [PARAMS_MODE]
  };
  PARAMS_MODE.contains.push(FUNCTION_INVOKE);
  const ATTRIBUTE_CONTAINS = [
    NAMED_ARGUMENT,
    LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
    hljs.C_BLOCK_COMMENT_MODE,
    STRING,
    NUMBER,
    CONSTRUCTOR_CALL
  ];
  const ATTRIBUTES2 = {
    begin: regex2.concat(/#\[\s*/, PASCAL_CASE_CLASS_NAME_RE),
    beginScope: "meta",
    end: /]/,
    endScope: "meta",
    keywords: {
      literal: LITERALS2,
      keyword: [
        "new",
        "array"
      ]
    },
    contains: [
      {
        begin: /\[/,
        end: /]/,
        keywords: {
          literal: LITERALS2,
          keyword: [
            "new",
            "array"
          ]
        },
        contains: [
          "self",
          ...ATTRIBUTE_CONTAINS
        ]
      },
      ...ATTRIBUTE_CONTAINS,
      {
        scope: "meta",
        match: PASCAL_CASE_CLASS_NAME_RE
      }
    ]
  };
  return {
    case_insensitive: false,
    keywords: KEYWORDS2,
    contains: [
      ATTRIBUTES2,
      hljs.HASH_COMMENT_MODE,
      hljs.COMMENT("//", "$"),
      hljs.COMMENT(
        "/\\*",
        "\\*/",
        { contains: [
          {
            scope: "doctag",
            match: "@[A-Za-z]+"
          }
        ] }
      ),
      {
        match: /__halt_compiler\(\);/,
        keywords: "__halt_compiler",
        starts: {
          scope: "comment",
          end: hljs.MATCH_NOTHING_RE,
          contains: [
            {
              match: /\?>/,
              scope: "meta",
              endsParent: true
            }
          ]
        }
      },
      PREPROCESSOR,
      {
        scope: "variable.language",
        match: /\$this\b/
      },
      VARIABLE,
      FUNCTION_INVOKE,
      LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
      {
        match: [
          /const/,
          /\s/,
          IDENT_RE2
        ],
        scope: {
          1: "keyword",
          3: "variable.constant"
        }
      },
      CONSTRUCTOR_CALL,
      {
        scope: "function",
        relevance: 0,
        beginKeywords: "fn function",
        end: /[;{]/,
        excludeEnd: true,
        illegal: "[$%\\[]",
        contains: [
          { beginKeywords: "use" },
          hljs.UNDERSCORE_TITLE_MODE,
          {
            begin: "=>",
            // No markup, just a relevance booster
            endsParent: true
          },
          {
            scope: "params",
            begin: "\\(",
            end: "\\)",
            excludeBegin: true,
            excludeEnd: true,
            keywords: KEYWORDS2,
            contains: [
              "self",
              VARIABLE,
              LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
              hljs.C_BLOCK_COMMENT_MODE,
              STRING,
              NUMBER
            ]
          }
        ]
      },
      {
        scope: "class",
        variants: [
          {
            beginKeywords: "enum",
            illegal: /[($"]/
          },
          {
            beginKeywords: "class interface trait",
            illegal: /[:($"]/
          }
        ],
        relevance: 0,
        end: /\{/,
        excludeEnd: true,
        contains: [
          { beginKeywords: "extends implements" },
          hljs.UNDERSCORE_TITLE_MODE
        ]
      },
      // both use and namespace still use "old style" rules (vs multi-match)
      // because the namespace name can include `\` and we still want each
      // element to be treated as its own *individual* title
      {
        beginKeywords: "namespace",
        relevance: 0,
        end: ";",
        illegal: /[.']/,
        contains: [hljs.inherit(hljs.UNDERSCORE_TITLE_MODE, { scope: "title.class" })]
      },
      {
        beginKeywords: "use",
        relevance: 0,
        end: ";",
        contains: [
          // TODO: title.function vs title.class
          {
            match: /\b(as|const|function)\b/,
            scope: "keyword"
          },
          // TODO: could be title.class or title.function
          hljs.UNDERSCORE_TITLE_MODE
        ]
      },
      STRING,
      NUMBER
    ]
  };
}
function xml(hljs) {
  const regex2 = hljs.regex;
  const TAG_NAME_RE = regex2.concat(/[\p{L}_]/u, regex2.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u);
  const XML_IDENT_RE = /[\p{L}0-9._:-]+/u;
  const XML_ENTITIES = {
    className: "symbol",
    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
  };
  const XML_META_KEYWORDS = {
    begin: /\s/,
    contains: [
      {
        className: "keyword",
        begin: /#?[a-z_][a-z1-9_-]+/,
        illegal: /\n/
      }
    ]
  };
  const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {
    begin: /\(/,
    end: /\)/
  });
  const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, { className: "string" });
  const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, { className: "string" });
  const TAG_INTERNALS = {
    endsWithParent: true,
    illegal: /</,
    relevance: 0,
    contains: [
      {
        className: "attr",
        begin: XML_IDENT_RE,
        relevance: 0
      },
      {
        begin: /=\s*/,
        relevance: 0,
        contains: [
          {
            className: "string",
            endsParent: true,
            variants: [
              {
                begin: /"/,
                end: /"/,
                contains: [XML_ENTITIES]
              },
              {
                begin: /'/,
                end: /'/,
                contains: [XML_ENTITIES]
              },
              { begin: /[^\s"'=<>`]+/ }
            ]
          }
        ]
      }
    ]
  };
  return {
    name: "HTML, XML",
    aliases: [
      "html",
      "xhtml",
      "rss",
      "atom",
      "xjb",
      "xsd",
      "xsl",
      "plist",
      "wsf",
      "svg"
    ],
    case_insensitive: true,
    unicodeRegex: true,
    contains: [
      {
        className: "meta",
        begin: /<![a-z]/,
        end: />/,
        relevance: 10,
        contains: [
          XML_META_KEYWORDS,
          QUOTE_META_STRING_MODE,
          APOS_META_STRING_MODE,
          XML_META_PAR_KEYWORDS,
          {
            begin: /\[/,
            end: /\]/,
            contains: [
              {
                className: "meta",
                begin: /<![a-z]/,
                end: />/,
                contains: [
                  XML_META_KEYWORDS,
                  XML_META_PAR_KEYWORDS,
                  QUOTE_META_STRING_MODE,
                  APOS_META_STRING_MODE
                ]
              }
            ]
          }
        ]
      },
      hljs.COMMENT(
        /<!--/,
        /-->/,
        { relevance: 10 }
      ),
      {
        begin: /<!\[CDATA\[/,
        end: /\]\]>/,
        relevance: 10
      },
      XML_ENTITIES,
      // xml processing instructions
      {
        className: "meta",
        end: /\?>/,
        variants: [
          {
            begin: /<\?xml/,
            relevance: 10,
            contains: [
              QUOTE_META_STRING_MODE
            ]
          },
          {
            begin: /<\?[a-z][a-z0-9]+/
          }
        ]
      },
      {
        className: "tag",
        /*
        The lookahead pattern (?=...) ensures that 'begin' only matches
        '<style' as a single word, followed by a whitespace or an
        ending bracket.
        */
        begin: /<style(?=\s|>)/,
        end: />/,
        keywords: { name: "style" },
        contains: [TAG_INTERNALS],
        starts: {
          end: /<\/style>/,
          returnEnd: true,
          subLanguage: [
            "css",
            "xml"
          ]
        }
      },
      {
        className: "tag",
        // See the comment in the <style tag about the lookahead pattern
        begin: /<script(?=\s|>)/,
        end: />/,
        keywords: { name: "script" },
        contains: [TAG_INTERNALS],
        starts: {
          end: /<\/script>/,
          returnEnd: true,
          subLanguage: [
            "javascript",
            "handlebars",
            "xml"
          ]
        }
      },
      // we need this for now for jSX
      {
        className: "tag",
        begin: /<>|<\/>/
      },
      // open tag
      {
        className: "tag",
        begin: regex2.concat(
          /</,
          regex2.lookahead(regex2.concat(
            TAG_NAME_RE,
            // <tag/>
            // <tag>
            // <tag ...
            regex2.either(/\/>/, />/, /\s/)
          ))
        ),
        end: /\/?>/,
        contains: [
          {
            className: "name",
            begin: TAG_NAME_RE,
            relevance: 0,
            starts: TAG_INTERNALS
          }
        ]
      },
      // close tag
      {
        className: "tag",
        begin: regex2.concat(
          /<\//,
          regex2.lookahead(regex2.concat(
            TAG_NAME_RE,
            />/
          ))
        ),
        contains: [
          {
            className: "name",
            begin: TAG_NAME_RE,
            relevance: 0
          },
          {
            begin: />/,
            relevance: 0,
            endsParent: true
          }
        ]
      }
    ]
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const decorateProperty = ({ finisher, descriptor: descriptor2 }) => (protoOrDescriptor, name2) => {
  var _a2;
  if (name2 !== void 0) {
    const ctor = protoOrDescriptor.constructor;
    if (descriptor2 !== void 0) {
      Object.defineProperty(protoOrDescriptor, name2, descriptor2(name2));
    }
    finisher === null || finisher === void 0 ? void 0 : finisher(ctor, name2);
  } else {
    const key = (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (_a2 = protoOrDescriptor.originalKey) !== null && _a2 !== void 0 ? _a2 : protoOrDescriptor.key
    );
    const info = descriptor2 != void 0 ? {
      kind: "method",
      placement: "prototype",
      key,
      descriptor: descriptor2(protoOrDescriptor.key)
    } : { ...protoOrDescriptor, key };
    if (finisher != void 0) {
      info.finisher = function(ctor) {
        finisher(ctor, key);
      };
    }
    return info;
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function query(selector, cache2) {
  return decorateProperty({
    descriptor: (name2) => {
      const descriptor2 = {
        get() {
          var _a2, _b2;
          return (_b2 = (_a2 = this.renderRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(selector)) !== null && _b2 !== void 0 ? _b2 : null;
        },
        enumerable: true,
        configurable: true
      };
      if (cache2) {
        const key = typeof name2 === "symbol" ? Symbol() : `__${name2}`;
        descriptor2.get = function() {
          var _a2, _b2;
          if (this[key] === void 0) {
            this[key] = (_b2 = (_a2 = this.renderRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(selector)) !== null && _b2 !== void 0 ? _b2 : null;
          }
          return this[key];
        };
      }
      return descriptor2;
    }
  });
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var _a$1;
const global$1 = window;
((_a$1 = global$1.HTMLSlotElement) === null || _a$1 === void 0 ? void 0 : _a$1.prototype.assignedElements) != null ? (slot, opts) => slot.assignedElements(opts) : (slot, opts) => slot.assignedNodes(opts).filter((node) => node.nodeType === Node.ELEMENT_NODE);
class SCodeExampleComponentInterface extends SInterface {
  static get _definition() {
    return {
      active: {
        description: 'Specify which "tab" is active in case of multiple languages examples',
        type: "String"
      },
      toolbar: {
        description: 'Specify what you want in the toolbar. Currently available item is "copy"',
        type: "Array<String>",
        values: ["copy"],
        default: ["copy"]
      },
      toolbarPosition: {
        description: 'Specify the toolbar position. Can be "content" or "nav"',
        type: "String",
        values: ["content", "nav"],
        default: "nav"
      },
      languages: {
        description: 'Specify some languages that you want to support. Must be "[key]: language" object syntax. See [highlight.js doc](https://github.com/highlightjs/highlight.js/blob/main/SUPPORTED_LANGUAGES.md) for supported languages',
        type: "Object",
        default: {}
      },
      items: {
        description: "Specify the items to put in your code example",
        type: "Object[]",
        default: []
      },
      lines: {
        description: "Specify how many lines to display at max",
        type: "Number",
        default: 999,
        physical: true
      },
      moreLabel: {
        description: 'Specify the "show more" button label',
        type: "String",
        default: "Show more"
      },
      lessLabel: {
        description: 'Specigy the "show less" button label',
        type: "String",
        default: "Show less"
      },
      moreAction: {
        description: 'Specify the action to execute when click on the "more" button. Currently available action is "toggle"',
        values: ["toggle"],
        type: "String",
        default: "toggle"
      },
      more: {
        description: "Specify if you want to expand the more feature at start or not",
        type: "Boolean",
        default: false
      },
      scrollOnMore: {
        description: 'Specify if you want to scroll to the code when clicking on the "show more/less" button',
        type: "Boolean",
        default: true
      },
      scrollToSettings: {
        description: "Specify some scrollTo settings",
        type: "Object",
        default: {}
      }
    };
  }
}
var Te$2 = (e, r) => () => (r || e((r = { exports: {} }).exports, r), r.exports);
var pt$1 = Te$2((Vg, ou) => {
  var ur2 = function(e) {
    return e && e.Math == Math && e;
  };
  ou.exports = ur2(typeof globalThis == "object" && globalThis) || ur2(typeof window == "object" && window) || ur2(typeof self == "object" && self) || ur2(typeof global == "object" && global) || function() {
    return this;
  }() || Function("return this")();
});
var Dt$1 = Te$2((Wg, lu2) => {
  lu2.exports = function(e) {
    try {
      return !!e();
    } catch {
      return true;
    }
  };
});
var yt$2 = Te$2((Hg, cu) => {
  var wo2 = Dt$1();
  cu.exports = !wo2(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] != 7;
  });
});
var sr$2 = Te$2((Gg, pu) => {
  var _o2 = Dt$1();
  pu.exports = !_o2(function() {
    var e = (function() {
    }).bind();
    return typeof e != "function" || e.hasOwnProperty("prototype");
  });
});
var At$2 = Te$2((Ug, fu) => {
  var Po2 = sr$2(), ir2 = Function.prototype.call;
  fu.exports = Po2 ? ir2.bind(ir2) : function() {
    return ir2.apply(ir2, arguments);
  };
});
var gu = Te$2((du) => {
  var Du = {}.propertyIsEnumerable, mu = Object.getOwnPropertyDescriptor, Io2 = mu && !Du.call({ 1: 2 }, 1);
  du.f = Io2 ? function(r) {
    var t = mu(this, r);
    return !!t && t.enumerable;
  } : Du;
});
var ar$2 = Te$2((zg, yu) => {
  yu.exports = function(e, r) {
    return { enumerable: !(e & 1), configurable: !(e & 2), writable: !(e & 4), value: r };
  };
});
var mt$1 = Te$2((Xg, Cu) => {
  var hu = sr$2(), vu = Function.prototype, $r2 = vu.call, ko2 = hu && vu.bind.bind($r2, $r2);
  Cu.exports = hu ? ko2 : function(e) {
    return function() {
      return $r2.apply(e, arguments);
    };
  };
});
var Rt$2 = Te$2((Kg, Fu) => {
  var Eu = mt$1(), Lo2 = Eu({}.toString), Oo2 = Eu("".slice);
  Fu.exports = function(e) {
    return Oo2(Lo2(e), 8, -1);
  };
});
var Su = Te$2((Yg, Au) => {
  var jo2 = mt$1(), qo2 = Dt$1(), Mo2 = Rt$2(), Vr2 = Object, Ro2 = jo2("".split);
  Au.exports = qo2(function() {
    return !Vr2("z").propertyIsEnumerable(0);
  }) ? function(e) {
    return Mo2(e) == "String" ? Ro2(e, "") : Vr2(e);
  } : Vr2;
});
var or$2 = Te$2((Qg, xu) => {
  xu.exports = function(e) {
    return e == null;
  };
});
var Wr$1 = Te$2((Zg, bu) => {
  var $o2 = or$2(), Vo2 = TypeError;
  bu.exports = function(e) {
    if ($o2(e))
      throw Vo2("Can't call method on " + e);
    return e;
  };
});
var lr$1 = Te$2((e0, Tu) => {
  var Wo2 = Su(), Ho2 = Wr$1();
  Tu.exports = function(e) {
    return Wo2(Ho2(e));
  };
});
var Gr$1 = Te$2((t0, Bu) => {
  var Hr2 = typeof document == "object" && document.all, Go2 = typeof Hr2 > "u" && Hr2 !== void 0;
  Bu.exports = { all: Hr2, IS_HTMLDDA: Go2 };
});
var ot = Te$2((r0, wu) => {
  var Nu2 = Gr$1(), Uo2 = Nu2.all;
  wu.exports = Nu2.IS_HTMLDDA ? function(e) {
    return typeof e == "function" || e === Uo2;
  } : function(e) {
    return typeof e == "function";
  };
});
var St$1 = Te$2((n0, Iu) => {
  var _u2 = ot(), Pu = Gr$1(), Jo2 = Pu.all;
  Iu.exports = Pu.IS_HTMLDDA ? function(e) {
    return typeof e == "object" ? e !== null : _u2(e) || e === Jo2;
  } : function(e) {
    return typeof e == "object" ? e !== null : _u2(e);
  };
});
var $t = Te$2((u0, ku) => {
  var Ur2 = pt$1(), zo2 = ot(), Xo2 = function(e) {
    return zo2(e) ? e : void 0;
  };
  ku.exports = function(e, r) {
    return arguments.length < 2 ? Xo2(Ur2[e]) : Ur2[e] && Ur2[e][r];
  };
});
var Jr = Te$2((s0, Lu) => {
  var Ko2 = mt$1();
  Lu.exports = Ko2({}.isPrototypeOf);
});
var ju$1 = Te$2((i0, Ou) => {
  var Yo2 = $t();
  Ou.exports = Yo2("navigator", "userAgent") || "";
});
var Hu = Te$2((a0, Wu) => {
  var Vu = pt$1(), zr2 = ju$1(), qu = Vu.process, Mu = Vu.Deno, Ru = qu && qu.versions || Mu && Mu.version, $u2 = Ru && Ru.v8, dt2, cr2;
  $u2 && (dt2 = $u2.split("."), cr2 = dt2[0] > 0 && dt2[0] < 4 ? 1 : +(dt2[0] + dt2[1]));
  !cr2 && zr2 && (dt2 = zr2.match(/Edge\/(\d+)/), (!dt2 || dt2[1] >= 74) && (dt2 = zr2.match(/Chrome\/(\d+)/), dt2 && (cr2 = +dt2[1])));
  Wu.exports = cr2;
});
var Xr$1 = Te$2((o0, Uu) => {
  var Gu = Hu(), Qo2 = Dt$1();
  Uu.exports = !!Object.getOwnPropertySymbols && !Qo2(function() {
    var e = Symbol();
    return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && Gu && Gu < 41;
  });
});
var Kr$1 = Te$2((l0, Ju) => {
  var Zo2 = Xr$1();
  Ju.exports = Zo2 && !Symbol.sham && typeof Symbol.iterator == "symbol";
});
var Yr = Te$2((c0, zu) => {
  var el2 = $t(), tl2 = ot(), rl2 = Jr(), nl2 = Kr$1(), ul2 = Object;
  zu.exports = nl2 ? function(e) {
    return typeof e == "symbol";
  } : function(e) {
    var r = el2("Symbol");
    return tl2(r) && rl2(r.prototype, ul2(e));
  };
});
var pr$2 = Te$2((p0, Xu) => {
  var sl2 = String;
  Xu.exports = function(e) {
    try {
      return sl2(e);
    } catch {
      return "Object";
    }
  };
});
var Vt$1 = Te$2((f0, Ku) => {
  var il2 = ot(), al2 = pr$2(), ol2 = TypeError;
  Ku.exports = function(e) {
    if (il2(e))
      return e;
    throw ol2(al2(e) + " is not a function");
  };
});
var fr$2 = Te$2((D0, Yu) => {
  var ll2 = Vt$1(), cl2 = or$2();
  Yu.exports = function(e, r) {
    var t = e[r];
    return cl2(t) ? void 0 : ll2(t);
  };
});
var Zu = Te$2((m0, Qu) => {
  var Qr = At$2(), Zr2 = ot(), en2 = St$1(), pl2 = TypeError;
  Qu.exports = function(e, r) {
    var t, s;
    if (r === "string" && Zr2(t = e.toString) && !en2(s = Qr(t, e)) || Zr2(t = e.valueOf) && !en2(s = Qr(t, e)) || r !== "string" && Zr2(t = e.toString) && !en2(s = Qr(t, e)))
      return s;
    throw pl2("Can't convert object to primitive value");
  };
});
var ts$1 = Te$2((d0, es) => {
  es.exports = false;
});
var Dr$1 = Te$2((g0, ns2) => {
  var rs2 = pt$1(), fl2 = Object.defineProperty;
  ns2.exports = function(e, r) {
    try {
      fl2(rs2, e, { value: r, configurable: true, writable: true });
    } catch {
      rs2[e] = r;
    }
    return r;
  };
});
var mr$1 = Te$2((y0, ss2) => {
  var Dl2 = pt$1(), ml2 = Dr$1(), us2 = "__core-js_shared__", dl2 = Dl2[us2] || ml2(us2, {});
  ss2.exports = dl2;
});
var tn$1 = Te$2((h0, as2) => {
  var gl2 = ts$1(), is2 = mr$1();
  (as2.exports = function(e, r) {
    return is2[e] || (is2[e] = r !== void 0 ? r : {});
  })("versions", []).push({ version: "3.26.1", mode: gl2 ? "pure" : "global", copyright: "© 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE", source: "https://github.com/zloirock/core-js" });
});
var dr$3 = Te$2((v0, os2) => {
  var yl2 = Wr$1(), hl2 = Object;
  os2.exports = function(e) {
    return hl2(yl2(e));
  };
});
var Ct$1 = Te$2((C0, ls2) => {
  var vl2 = mt$1(), Cl2 = dr$3(), El2 = vl2({}.hasOwnProperty);
  ls2.exports = Object.hasOwn || function(r, t) {
    return El2(Cl2(r), t);
  };
});
var rn$1 = Te$2((E0, cs2) => {
  var Fl2 = mt$1(), Al2 = 0, Sl2 = Math.random(), xl2 = Fl2(1 .toString);
  cs2.exports = function(e) {
    return "Symbol(" + (e === void 0 ? "" : e) + ")_" + xl2(++Al2 + Sl2, 36);
  };
});
var bt$2 = Te$2((F0, ds2) => {
  var bl2 = pt$1(), Tl2 = tn$1(), ps2 = Ct$1(), Bl2 = rn$1(), fs2 = Xr$1(), ms2 = Kr$1(), Pt2 = Tl2("wks"), xt2 = bl2.Symbol, Ds2 = xt2 && xt2.for, Nl2 = ms2 ? xt2 : xt2 && xt2.withoutSetter || Bl2;
  ds2.exports = function(e) {
    if (!ps2(Pt2, e) || !(fs2 || typeof Pt2[e] == "string")) {
      var r = "Symbol." + e;
      fs2 && ps2(xt2, e) ? Pt2[e] = xt2[e] : ms2 && Ds2 ? Pt2[e] = Ds2(r) : Pt2[e] = Nl2(r);
    }
    return Pt2[e];
  };
});
var vs$2 = Te$2((A0, hs2) => {
  var wl2 = At$2(), gs2 = St$1(), ys2 = Yr(), _l2 = fr$2(), Pl2 = Zu(), Il2 = bt$2(), kl2 = TypeError, Ll2 = Il2("toPrimitive");
  hs2.exports = function(e, r) {
    if (!gs2(e) || ys2(e))
      return e;
    var t = _l2(e, Ll2), s;
    if (t) {
      if (r === void 0 && (r = "default"), s = wl2(t, e, r), !gs2(s) || ys2(s))
        return s;
      throw kl2("Can't convert object to primitive value");
    }
    return r === void 0 && (r = "number"), Pl2(e, r);
  };
});
var gr$2 = Te$2((S0, Cs2) => {
  var Ol2 = vs$2(), jl2 = Yr();
  Cs2.exports = function(e) {
    var r = Ol2(e, "string");
    return jl2(r) ? r : r + "";
  };
});
var As$2 = Te$2((x0, Fs2) => {
  var ql2 = pt$1(), Es2 = St$1(), nn2 = ql2.document, Ml2 = Es2(nn2) && Es2(nn2.createElement);
  Fs2.exports = function(e) {
    return Ml2 ? nn2.createElement(e) : {};
  };
});
var un$1 = Te$2((b0, Ss2) => {
  var Rl2 = yt$2(), $l2 = Dt$1(), Vl2 = As$2();
  Ss2.exports = !Rl2 && !$l2(function() {
    return Object.defineProperty(Vl2("div"), "a", { get: function() {
      return 7;
    } }).a != 7;
  });
});
var sn = Te$2((bs2) => {
  var Wl2 = yt$2(), Hl2 = At$2(), Gl2 = gu(), Ul2 = ar$2(), Jl2 = lr$1(), zl2 = gr$2(), Xl2 = Ct$1(), Kl2 = un$1(), xs2 = Object.getOwnPropertyDescriptor;
  bs2.f = Wl2 ? xs2 : function(r, t) {
    if (r = Jl2(r), t = zl2(t), Kl2)
      try {
        return xs2(r, t);
      } catch {
      }
    if (Xl2(r, t))
      return Ul2(!Hl2(Gl2.f, r, t), r[t]);
  };
});
var Bs$2 = Te$2((B0, Ts2) => {
  var Yl2 = yt$2(), Ql2 = Dt$1();
  Ts2.exports = Yl2 && Ql2(function() {
    return Object.defineProperty(function() {
    }, "prototype", { value: 42, writable: false }).prototype != 42;
  });
});
var Tt$1 = Te$2((N0, Ns2) => {
  var Zl2 = St$1(), ec = String, tc = TypeError;
  Ns2.exports = function(e) {
    if (Zl2(e))
      return e;
    throw tc(ec(e) + " is not an object");
  };
});
var It$2 = Te$2((_s2) => {
  var rc = yt$2(), nc = un$1(), uc = Bs$2(), yr2 = Tt$1(), ws2 = gr$2(), sc = TypeError, an2 = Object.defineProperty, ic = Object.getOwnPropertyDescriptor, on = "enumerable", ln2 = "configurable", cn2 = "writable";
  _s2.f = rc ? uc ? function(r, t, s) {
    if (yr2(r), t = ws2(t), yr2(s), typeof r == "function" && t === "prototype" && "value" in s && cn2 in s && !s[cn2]) {
      var a = ic(r, t);
      a && a[cn2] && (r[t] = s.value, s = { configurable: ln2 in s ? s[ln2] : a[ln2], enumerable: on in s ? s[on] : a[on], writable: false });
    }
    return an2(r, t, s);
  } : an2 : function(r, t, s) {
    if (yr2(r), t = ws2(t), yr2(s), nc)
      try {
        return an2(r, t, s);
      } catch {
      }
    if ("get" in s || "set" in s)
      throw sc("Accessors not supported");
    return "value" in s && (r[t] = s.value), r;
  };
});
var pn = Te$2((_0, Ps2) => {
  var ac = yt$2(), oc = It$2(), lc = ar$2();
  Ps2.exports = ac ? function(e, r, t) {
    return oc.f(e, r, lc(1, t));
  } : function(e, r, t) {
    return e[r] = t, e;
  };
});
var Ls$1 = Te$2((P0, ks2) => {
  var fn2 = yt$2(), cc = Ct$1(), Is2 = Function.prototype, pc = fn2 && Object.getOwnPropertyDescriptor, Dn2 = cc(Is2, "name"), fc = Dn2 && (function() {
  }).name === "something", Dc = Dn2 && (!fn2 || fn2 && pc(Is2, "name").configurable);
  ks2.exports = { EXISTS: Dn2, PROPER: fc, CONFIGURABLE: Dc };
});
var dn = Te$2((I0, Os2) => {
  var mc = mt$1(), dc = ot(), mn2 = mr$1(), gc = mc(Function.toString);
  dc(mn2.inspectSource) || (mn2.inspectSource = function(e) {
    return gc(e);
  });
  Os2.exports = mn2.inspectSource;
});
var Ms$2 = Te$2((k0, qs2) => {
  var yc = pt$1(), hc = ot(), js2 = yc.WeakMap;
  qs2.exports = hc(js2) && /native code/.test(String(js2));
});
var Vs$2 = Te$2((L0, $s2) => {
  var vc = tn$1(), Cc = rn$1(), Rs2 = vc("keys");
  $s2.exports = function(e) {
    return Rs2[e] || (Rs2[e] = Cc(e));
  };
});
var gn$1 = Te$2((O0, Ws2) => {
  Ws2.exports = {};
});
var Js$2 = Te$2((j0, Us2) => {
  var Ec = Ms$2(), Gs2 = pt$1(), Fc = St$1(), Ac = pn(), yn = Ct$1(), hn2 = mr$1(), Sc = Vs$2(), xc = gn$1(), Hs2 = "Object already initialized", vn2 = Gs2.TypeError, bc = Gs2.WeakMap, hr2, Wt, vr2, Tc = function(e) {
    return vr2(e) ? Wt(e) : hr2(e, {});
  }, Bc = function(e) {
    return function(r) {
      var t;
      if (!Fc(r) || (t = Wt(r)).type !== e)
        throw vn2("Incompatible receiver, " + e + " required");
      return t;
    };
  };
  Ec || hn2.state ? (gt2 = hn2.state || (hn2.state = new bc()), gt2.get = gt2.get, gt2.has = gt2.has, gt2.set = gt2.set, hr2 = function(e, r) {
    if (gt2.has(e))
      throw vn2(Hs2);
    return r.facade = e, gt2.set(e, r), r;
  }, Wt = function(e) {
    return gt2.get(e) || {};
  }, vr2 = function(e) {
    return gt2.has(e);
  }) : (Bt2 = Sc("state"), xc[Bt2] = true, hr2 = function(e, r) {
    if (yn(e, Bt2))
      throw vn2(Hs2);
    return r.facade = e, Ac(e, Bt2, r), r;
  }, Wt = function(e) {
    return yn(e, Bt2) ? e[Bt2] : {};
  }, vr2 = function(e) {
    return yn(e, Bt2);
  });
  var gt2, Bt2;
  Us2.exports = { set: hr2, get: Wt, has: vr2, enforce: Tc, getterFor: Bc };
});
var En = Te$2((q0, Xs2) => {
  var Nc = Dt$1(), wc = ot(), Cr2 = Ct$1(), Cn2 = yt$2(), _c2 = Ls$1().CONFIGURABLE, Pc = dn(), zs2 = Js$2(), Ic = zs2.enforce, kc = zs2.get, Er2 = Object.defineProperty, Lc = Cn2 && !Nc(function() {
    return Er2(function() {
    }, "length", { value: 8 }).length !== 8;
  }), Oc = String(String).split("String"), jc = Xs2.exports = function(e, r, t) {
    String(r).slice(0, 7) === "Symbol(" && (r = "[" + String(r).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), t && t.getter && (r = "get " + r), t && t.setter && (r = "set " + r), (!Cr2(e, "name") || _c2 && e.name !== r) && (Cn2 ? Er2(e, "name", { value: r, configurable: true }) : e.name = r), Lc && t && Cr2(t, "arity") && e.length !== t.arity && Er2(e, "length", { value: t.arity });
    try {
      t && Cr2(t, "constructor") && t.constructor ? Cn2 && Er2(e, "prototype", { writable: false }) : e.prototype && (e.prototype = void 0);
    } catch {
    }
    var s = Ic(e);
    return Cr2(s, "source") || (s.source = Oc.join(typeof r == "string" ? r : "")), e;
  };
  Function.prototype.toString = jc(function() {
    return wc(this) && kc(this).source || Pc(this);
  }, "toString");
});
var Ys$1 = Te$2((M0, Ks2) => {
  var qc = ot(), Mc = It$2(), Rc = En(), $c = Dr$1();
  Ks2.exports = function(e, r, t, s) {
    s || (s = {});
    var a = s.enumerable, n = s.name !== void 0 ? s.name : r;
    if (qc(t) && Rc(t, n, s), s.global)
      a ? e[r] = t : $c(r, t);
    else {
      try {
        s.unsafe ? e[r] && (a = true) : delete e[r];
      } catch {
      }
      a ? e[r] = t : Mc.f(e, r, { value: t, enumerable: false, configurable: !s.nonConfigurable, writable: !s.nonWritable });
    }
    return e;
  };
});
var Zs$1 = Te$2((R0, Qs2) => {
  var Vc = Math.ceil, Wc = Math.floor;
  Qs2.exports = Math.trunc || function(r) {
    var t = +r;
    return (t > 0 ? Wc : Vc)(t);
  };
});
var Fr$1 = Te$2(($0, ei) => {
  var Hc = Zs$1();
  ei.exports = function(e) {
    var r = +e;
    return r !== r || r === 0 ? 0 : Hc(r);
  };
});
var ri = Te$2((V0, ti2) => {
  var Gc = Fr$1(), Uc = Math.max, Jc = Math.min;
  ti2.exports = function(e, r) {
    var t = Gc(e);
    return t < 0 ? Uc(t + r, 0) : Jc(t, r);
  };
});
var ui = Te$2((W0, ni) => {
  var zc = Fr$1(), Xc = Math.min;
  ni.exports = function(e) {
    return e > 0 ? Xc(zc(e), 9007199254740991) : 0;
  };
});
var kt$2 = Te$2((H0, si) => {
  var Kc = ui();
  si.exports = function(e) {
    return Kc(e.length);
  };
});
var oi$1 = Te$2((G0, ai) => {
  var Yc = lr$1(), Qc = ri(), Zc = kt$2(), ii = function(e) {
    return function(r, t, s) {
      var a = Yc(r), n = Zc(a), u = Qc(s, n), i;
      if (e && t != t) {
        for (; n > u; )
          if (i = a[u++], i != i)
            return true;
      } else
        for (; n > u; u++)
          if ((e || u in a) && a[u] === t)
            return e || u || 0;
      return !e && -1;
    };
  };
  ai.exports = { includes: ii(true), indexOf: ii(false) };
});
var pi$1 = Te$2((U0, ci) => {
  var ep = mt$1(), Fn2 = Ct$1(), tp = lr$1(), rp = oi$1().indexOf, np = gn$1(), li = ep([].push);
  ci.exports = function(e, r) {
    var t = tp(e), s = 0, a = [], n;
    for (n in t)
      !Fn2(np, n) && Fn2(t, n) && li(a, n);
    for (; r.length > s; )
      Fn2(t, n = r[s++]) && (~rp(a, n) || li(a, n));
    return a;
  };
});
var Di = Te$2((J0, fi2) => {
  fi2.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
});
var di = Te$2((mi) => {
  var up = pi$1(), sp = Di(), ip = sp.concat("length", "prototype");
  mi.f = Object.getOwnPropertyNames || function(r) {
    return up(r, ip);
  };
});
var yi$1 = Te$2((gi) => {
  gi.f = Object.getOwnPropertySymbols;
});
var vi = Te$2((K0, hi) => {
  var ap = $t(), op = mt$1(), lp = di(), cp = yi$1(), pp = Tt$1(), fp = op([].concat);
  hi.exports = ap("Reflect", "ownKeys") || function(r) {
    var t = lp.f(pp(r)), s = cp.f;
    return s ? fp(t, s(r)) : t;
  };
});
var Fi$2 = Te$2((Y0, Ei) => {
  var Ci = Ct$1(), Dp = vi(), mp = sn(), dp = It$2();
  Ei.exports = function(e, r, t) {
    for (var s = Dp(r), a = dp.f, n = mp.f, u = 0; u < s.length; u++) {
      var i = s[u];
      !Ci(e, i) && !(t && Ci(t, i)) && a(e, i, n(r, i));
    }
  };
});
var Si$1 = Te$2((Q0, Ai2) => {
  var gp = Dt$1(), yp = ot(), hp = /#|\.prototype\./, Ht = function(e, r) {
    var t = Cp2[vp2(e)];
    return t == Fp ? true : t == Ep2 ? false : yp(r) ? gp(r) : !!r;
  }, vp2 = Ht.normalize = function(e) {
    return String(e).replace(hp, ".").toLowerCase();
  }, Cp2 = Ht.data = {}, Ep2 = Ht.NATIVE = "N", Fp = Ht.POLYFILL = "P";
  Ai2.exports = Ht;
});
var Gt$1 = Te$2((Z0, xi) => {
  var An = pt$1(), Ap2 = sn().f, Sp = pn(), xp = Ys$1(), bp = Dr$1(), Tp2 = Fi$2(), Bp = Si$1();
  xi.exports = function(e, r) {
    var t = e.target, s = e.global, a = e.stat, n, u, i, l, p, d2;
    if (s ? u = An : a ? u = An[t] || bp(t, {}) : u = (An[t] || {}).prototype, u)
      for (i in r) {
        if (p = r[i], e.dontCallGetSet ? (d2 = Ap2(u, i), l = d2 && d2.value) : l = u[i], n = Bp(s ? i : t + (a ? "." : "#") + i, e.forced), !n && l !== void 0) {
          if (typeof p == typeof l)
            continue;
          Tp2(p, l);
        }
        (e.sham || l && l.sham) && Sp(p, "sham", true), xp(u, i, p, e);
      }
  };
});
var Sn$2 = Te$2((ey, bi) => {
  var Np = Rt$2();
  bi.exports = Array.isArray || function(r) {
    return Np(r) == "Array";
  };
});
var Bi = Te$2((ty, Ti2) => {
  var wp = TypeError, _p = 9007199254740991;
  Ti2.exports = function(e) {
    if (e > _p)
      throw wp("Maximum allowed index exceeded");
    return e;
  };
});
var wi = Te$2((ry, Ni2) => {
  var Pp2 = Rt$2(), Ip = mt$1();
  Ni2.exports = function(e) {
    if (Pp2(e) === "Function")
      return Ip(e);
  };
});
var xn$2 = Te$2((ny, Pi) => {
  var _i2 = wi(), kp = Vt$1(), Lp = sr$2(), Op = _i2(_i2.bind);
  Pi.exports = function(e, r) {
    return kp(e), r === void 0 ? e : Lp ? Op(e, r) : function() {
      return e.apply(r, arguments);
    };
  };
});
var bn = Te$2((uy, ki) => {
  var jp = Sn$2(), qp = kt$2(), Mp = Bi(), Rp = xn$2(), Ii2 = function(e, r, t, s, a, n, u, i) {
    for (var l = a, p = 0, d2 = u ? Rp(u, i) : false, y2, g2; p < s; )
      p in t && (y2 = d2 ? d2(t[p], p, r) : t[p], n > 0 && jp(y2) ? (g2 = qp(y2), l = Ii2(e, r, y2, g2, l, n - 1) - 1) : (Mp(l + 1), e[l] = y2), l++), p++;
    return l;
  };
  ki.exports = Ii2;
});
var ji = Te$2((sy, Oi2) => {
  var $p = bt$2(), Vp = $p("toStringTag"), Li2 = {};
  Li2[Vp] = "z";
  Oi2.exports = String(Li2) === "[object z]";
});
var Tn = Te$2((iy, qi) => {
  var Wp = ji(), Hp = ot(), Ar2 = Rt$2(), Gp = bt$2(), Up = Gp("toStringTag"), Jp = Object, zp = Ar2(function() {
    return arguments;
  }()) == "Arguments", Xp = function(e, r) {
    try {
      return e[r];
    } catch {
    }
  };
  qi.exports = Wp ? Ar2 : function(e) {
    var r, t, s;
    return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (t = Xp(r = Jp(e), Up)) == "string" ? t : zp ? Ar2(r) : (s = Ar2(r)) == "Object" && Hp(r.callee) ? "Arguments" : s;
  };
});
var Hi = Te$2((ay, Wi2) => {
  var Kp = mt$1(), Yp = Dt$1(), Mi2 = ot(), Qp = Tn(), Zp = $t(), ef2 = dn(), Ri = function() {
  }, tf2 = [], $i2 = Zp("Reflect", "construct"), Bn2 = /^\s*(?:class|function)\b/, rf2 = Kp(Bn2.exec), nf2 = !Bn2.exec(Ri), Ut = function(r) {
    if (!Mi2(r))
      return false;
    try {
      return $i2(Ri, tf2, r), true;
    } catch {
      return false;
    }
  }, Vi2 = function(r) {
    if (!Mi2(r))
      return false;
    switch (Qp(r)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return false;
    }
    try {
      return nf2 || !!rf2(Bn2, ef2(r));
    } catch {
      return true;
    }
  };
  Vi2.sham = true;
  Wi2.exports = !$i2 || Yp(function() {
    var e;
    return Ut(Ut.call) || !Ut(Object) || !Ut(function() {
      e = true;
    }) || e;
  }) ? Vi2 : Ut;
});
var zi = Te$2((oy, Ji2) => {
  var Gi = Sn$2(), uf2 = Hi(), sf2 = St$1(), af2 = bt$2(), of2 = af2("species"), Ui2 = Array;
  Ji2.exports = function(e) {
    var r;
    return Gi(e) && (r = e.constructor, uf2(r) && (r === Ui2 || Gi(r.prototype)) ? r = void 0 : sf2(r) && (r = r[of2], r === null && (r = void 0))), r === void 0 ? Ui2 : r;
  };
});
var Nn$2 = Te$2((ly, Xi2) => {
  var lf2 = zi();
  Xi2.exports = function(e, r) {
    return new (lf2(e))(r === 0 ? 0 : r);
  };
});
var wn = Te$2((cy, Ki) => {
  Ki.exports = {};
});
var Qi$1 = Te$2((py, Yi2) => {
  var gf2 = bt$2(), yf2 = wn(), hf2 = gf2("iterator"), vf2 = Array.prototype;
  Yi2.exports = function(e) {
    return e !== void 0 && (yf2.Array === e || vf2[hf2] === e);
  };
});
var _n = Te$2((fy, ea2) => {
  var Cf2 = Tn(), Zi2 = fr$2(), Ef2 = or$2(), Ff2 = wn(), Af2 = bt$2(), Sf2 = Af2("iterator");
  ea2.exports = function(e) {
    if (!Ef2(e))
      return Zi2(e, Sf2) || Zi2(e, "@@iterator") || Ff2[Cf2(e)];
  };
});
var ra$1 = Te$2((Dy, ta2) => {
  var xf2 = At$2(), bf2 = Vt$1(), Tf2 = Tt$1(), Bf2 = pr$2(), Nf2 = _n(), wf2 = TypeError;
  ta2.exports = function(e, r) {
    var t = arguments.length < 2 ? Nf2(e) : r;
    if (bf2(t))
      return Tf2(xf2(t, e));
    throw wf2(Bf2(e) + " is not iterable");
  };
});
var sa = Te$2((my, ua) => {
  var _f2 = At$2(), na2 = Tt$1(), Pf2 = fr$2();
  ua.exports = function(e, r, t) {
    var s, a;
    na2(e);
    try {
      if (s = Pf2(e, "return"), !s) {
        if (r === "throw")
          throw t;
        return t;
      }
      s = _f2(s, e);
    } catch (n) {
      a = true, s = n;
    }
    if (r === "throw")
      throw t;
    if (a)
      throw s;
    return na2(s), t;
  };
});
var ca = Te$2((dy, la) => {
  var If2 = xn$2(), kf2 = At$2(), Lf2 = Tt$1(), Of2 = pr$2(), jf2 = Qi$1(), qf2 = kt$2(), ia = Jr(), Mf2 = ra$1(), Rf2 = _n(), aa = sa(), $f = TypeError, Sr2 = function(e, r) {
    this.stopped = e, this.result = r;
  }, oa = Sr2.prototype;
  la.exports = function(e, r, t) {
    var s = t && t.that, a = !!(t && t.AS_ENTRIES), n = !!(t && t.IS_RECORD), u = !!(t && t.IS_ITERATOR), i = !!(t && t.INTERRUPTED), l = If2(r, s), p, d2, y2, g2, c, f, E, _ = function(F) {
      return p && aa(p, "normal", F), new Sr2(true, F);
    }, w = function(F) {
      return a ? (Lf2(F), i ? l(F[0], F[1], _) : l(F[0], F[1])) : i ? l(F, _) : l(F);
    };
    if (n)
      p = e.iterator;
    else if (u)
      p = e;
    else {
      if (d2 = Rf2(e), !d2)
        throw $f(Of2(e) + " is not iterable");
      if (jf2(d2)) {
        for (y2 = 0, g2 = qf2(e); g2 > y2; y2++)
          if (c = w(e[y2]), c && ia(oa, c))
            return c;
        return new Sr2(false);
      }
      p = Mf2(e, d2);
    }
    for (f = n ? e.next : p.next; !(E = kf2(f, p)).done; ) {
      try {
        c = w(E.value);
      } catch (F) {
        aa(p, "throw", F);
      }
      if (typeof c == "object" && c && ia(oa, c))
        return c;
    }
    return new Sr2(false);
  };
});
var fa = Te$2((gy, pa) => {
  var Vf = gr$2(), Wf = It$2(), Hf = ar$2();
  pa.exports = function(e, r, t) {
    var s = Vf(r);
    s in e ? Wf.f(e, s, Hf(0, t)) : e[s] = t;
  };
});
var da = Te$2((yy, ma) => {
  var Da = En(), zf = It$2();
  ma.exports = function(e, r, t) {
    return t.get && Da(t.get, r, { getter: true }), t.set && Da(t.set, r, { setter: true }), zf.f(e, r, t);
  };
});
var ya = Te$2((hy, ga2) => {
  var Xf = Tt$1();
  ga2.exports = function() {
    var e = Xf(this), r = "";
    return e.hasIndices && (r += "d"), e.global && (r += "g"), e.ignoreCase && (r += "i"), e.multiline && (r += "m"), e.dotAll && (r += "s"), e.unicode && (r += "u"), e.unicodeSets && (r += "v"), e.sticky && (r += "y"), r;
  };
});
var Ca = Te$2(() => {
  var rD = Gt$1(), Pn2 = pt$1();
  rD({ global: true, forced: Pn2.globalThis !== Pn2 }, { globalThis: Pn2 });
});
var cf$2 = Gt$1(), pf$2 = bn(), ff$2 = Vt$1(), Df$1 = dr$3(), mf$2 = kt$2(), df$2 = Nn$2();
cf$2({ target: "Array", proto: true }, { flatMap: function(r) {
  var t = Df$1(this), s = mf$2(t), a;
  return ff$2(r), a = df$2(t, 0), a.length = pf$2(a, t, t, s, 0, 1, r, arguments.length > 1 ? arguments[1] : void 0), a;
} });
var Gf = Gt$1(), Uf = ca(), Jf = fa();
Gf({ target: "Object", stat: true }, { fromEntries: function(r) {
  var t = {};
  return Uf(r, function(s, a) {
    Jf(t, s, a);
  }, { AS_ENTRIES: true }), t;
} });
var Kf = pt$1(), Yf = yt$2(), Qf = da(), Zf = ya(), eD = Dt$1(), ha = Kf.RegExp, va$1 = ha.prototype, tD$1 = Yf && eD(function() {
  var e = true;
  try {
    ha(".", "d");
  } catch {
    e = false;
  }
  var r = {}, t = "", s = e ? "dgimsy" : "gimsy", a = function(l, p) {
    Object.defineProperty(r, l, { get: function() {
      return t += p, true;
    } });
  }, n = { dotAll: "s", global: "g", ignoreCase: "i", multiline: "m", sticky: "y" };
  e && (n.hasIndices = "d");
  for (var u in n)
    a(u, n[u]);
  var i = Object.getOwnPropertyDescriptor(va$1, "flags").get.call(r);
  return i !== s || t !== s;
});
tD$1 && Qf(va$1, "flags", { configurable: true, get: Zf });
Ca();
var nD$1 = Gt$1(), uD = bn(), sD$1 = dr$3(), iD$1 = kt$2(), aD$1 = Fr$1(), oD$1 = Nn$2();
nD$1({ target: "Array", proto: true }, { flat: function() {
  var r = arguments.length ? arguments[0] : void 0, t = sD$1(this), s = iD$1(t), a = oD$1(t, 0);
  return a.length = uD(a, t, t, s, 0, r === void 0 ? 1 : aD$1(r)), a;
} });
var lD = ["cliName", "cliCategory", "cliDescription"], cD = ["_"], pD = ["languageId"];
function $n(e, r) {
  if (e == null)
    return {};
  var t = fD(e, r), s, a;
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    for (a = 0; a < n.length; a++)
      s = n[a], !(r.indexOf(s) >= 0) && Object.prototype.propertyIsEnumerable.call(e, s) && (t[s] = e[s]);
  }
  return t;
}
function fD(e, r) {
  if (e == null)
    return {};
  var t = {}, s = Object.keys(e), a, n;
  for (n = 0; n < s.length; n++)
    a = s[n], !(r.indexOf(a) >= 0) && (t[a] = e[a]);
  return t;
}
var DD = Object.create, Nr$2 = Object.defineProperty, mD = Object.getOwnPropertyDescriptor, Vn = Object.getOwnPropertyNames, dD = Object.getPrototypeOf, gD = Object.prototype.hasOwnProperty, ht$1 = (e, r) => function() {
  return e && (r = (0, e[Vn(e)[0]])(e = 0)), r;
}, te$1 = (e, r) => function() {
  return r || (0, e[Vn(e)[0]])((r = { exports: {} }).exports, r), r.exports;
}, zt$1 = (e, r) => {
  for (var t in r)
    Nr$2(e, t, { get: r[t], enumerable: true });
}, Sa = (e, r, t, s) => {
  if (r && typeof r == "object" || typeof r == "function")
    for (let a of Vn(r))
      !gD.call(e, a) && a !== t && Nr$2(e, a, { get: () => r[a], enumerable: !(s = mD(r, a)) || s.enumerable });
  return e;
}, yD = (e, r, t) => (t = e != null ? DD(dD(e)) : {}, Sa(r || !e || !e.__esModule ? Nr$2(t, "default", { value: e, enumerable: true }) : t, e)), ft$2 = (e) => Sa(Nr$2({}, "__esModule", { value: true }), e), Nt$1, ne = ht$1({ "<define:process>"() {
  Nt$1 = { env: {}, argv: [] };
} }), xa = te$1({ "package.json"(e, r) {
  r.exports = { version: "2.8.8" };
} }), hD = te$1({ "node_modules/diff/lib/diff/base.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true }), e.default = r;
  function r() {
  }
  r.prototype = { diff: function(n, u) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, l = i.callback;
    typeof i == "function" && (l = i, i = {}), this.options = i;
    var p = this;
    function d2(N2) {
      return l ? (setTimeout(function() {
        l(void 0, N2);
      }, 0), true) : N2;
    }
    n = this.castInput(n), u = this.castInput(u), n = this.removeEmpty(this.tokenize(n)), u = this.removeEmpty(this.tokenize(u));
    var y2 = u.length, g2 = n.length, c = 1, f = y2 + g2, E = [{ newPos: -1, components: [] }], _ = this.extractCommon(E[0], u, n, 0);
    if (E[0].newPos + 1 >= y2 && _ + 1 >= g2)
      return d2([{ value: this.join(u), count: u.length }]);
    function w() {
      for (var N2 = -1 * c; N2 <= c; N2 += 2) {
        var x = void 0, I2 = E[N2 - 1], P = E[N2 + 1], $2 = (P ? P.newPos : 0) - N2;
        I2 && (E[N2 - 1] = void 0);
        var D = I2 && I2.newPos + 1 < y2, T = P && 0 <= $2 && $2 < g2;
        if (!D && !T) {
          E[N2] = void 0;
          continue;
        }
        if (!D || T && I2.newPos < P.newPos ? (x = s(P), p.pushComponent(x.components, void 0, true)) : (x = I2, x.newPos++, p.pushComponent(x.components, true, void 0)), $2 = p.extractCommon(x, u, n, N2), x.newPos + 1 >= y2 && $2 + 1 >= g2)
          return d2(t(p, x.components, u, n, p.useLongestToken));
        E[N2] = x;
      }
      c++;
    }
    if (l)
      (function N2() {
        setTimeout(function() {
          if (c > f)
            return l();
          w() || N2();
        }, 0);
      })();
    else
      for (; c <= f; ) {
        var F = w();
        if (F)
          return F;
      }
  }, pushComponent: function(n, u, i) {
    var l = n[n.length - 1];
    l && l.added === u && l.removed === i ? n[n.length - 1] = { count: l.count + 1, added: u, removed: i } : n.push({ count: 1, added: u, removed: i });
  }, extractCommon: function(n, u, i, l) {
    for (var p = u.length, d2 = i.length, y2 = n.newPos, g2 = y2 - l, c = 0; y2 + 1 < p && g2 + 1 < d2 && this.equals(u[y2 + 1], i[g2 + 1]); )
      y2++, g2++, c++;
    return c && n.components.push({ count: c }), n.newPos = y2, g2;
  }, equals: function(n, u) {
    return this.options.comparator ? this.options.comparator(n, u) : n === u || this.options.ignoreCase && n.toLowerCase() === u.toLowerCase();
  }, removeEmpty: function(n) {
    for (var u = [], i = 0; i < n.length; i++)
      n[i] && u.push(n[i]);
    return u;
  }, castInput: function(n) {
    return n;
  }, tokenize: function(n) {
    return n.split("");
  }, join: function(n) {
    return n.join("");
  } };
  function t(a, n, u, i, l) {
    for (var p = 0, d2 = n.length, y2 = 0, g2 = 0; p < d2; p++) {
      var c = n[p];
      if (c.removed) {
        if (c.value = a.join(i.slice(g2, g2 + c.count)), g2 += c.count, p && n[p - 1].added) {
          var E = n[p - 1];
          n[p - 1] = n[p], n[p] = E;
        }
      } else {
        if (!c.added && l) {
          var f = u.slice(y2, y2 + c.count);
          f = f.map(function(w, F) {
            var N2 = i[g2 + F];
            return N2.length > w.length ? N2 : w;
          }), c.value = a.join(f);
        } else
          c.value = a.join(u.slice(y2, y2 + c.count));
        y2 += c.count, c.added || (g2 += c.count);
      }
    }
    var _ = n[d2 - 1];
    return d2 > 1 && typeof _.value == "string" && (_.added || _.removed) && a.equals("", _.value) && (n[d2 - 2].value += _.value, n.pop()), n;
  }
  function s(a) {
    return { newPos: a.newPos, components: a.components.slice(0) };
  }
} }), vD = te$1({ "node_modules/diff/lib/diff/array.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true }), e.diffArrays = a, e.arrayDiff = void 0;
  var r = t(hD());
  function t(n) {
    return n && n.__esModule ? n : { default: n };
  }
  var s = new r.default();
  e.arrayDiff = s, s.tokenize = function(n) {
    return n.slice();
  }, s.join = s.removeEmpty = function(n) {
    return n;
  };
  function a(n, u, i) {
    return s.diff(n, u, i);
  }
} }), Wn$2 = te$1({ "src/document/doc-builders.js"(e, r) {
  ne();
  function t(C) {
    return { type: "concat", parts: C };
  }
  function s(C) {
    return { type: "indent", contents: C };
  }
  function a(C, o) {
    return { type: "align", contents: o, n: C };
  }
  function n(C) {
    let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return { type: "group", id: o.id, contents: C, break: Boolean(o.shouldBreak), expandedStates: o.expandedStates };
  }
  function u(C) {
    return a(Number.NEGATIVE_INFINITY, C);
  }
  function i(C) {
    return a({ type: "root" }, C);
  }
  function l(C) {
    return a(-1, C);
  }
  function p(C, o) {
    return n(C[0], Object.assign(Object.assign({}, o), {}, { expandedStates: C }));
  }
  function d2(C) {
    return { type: "fill", parts: C };
  }
  function y2(C, o) {
    let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return { type: "if-break", breakContents: C, flatContents: o, groupId: h.groupId };
  }
  function g2(C, o) {
    return { type: "indent-if-break", contents: C, groupId: o.groupId, negate: o.negate };
  }
  function c(C) {
    return { type: "line-suffix", contents: C };
  }
  var f = { type: "line-suffix-boundary" }, E = { type: "break-parent" }, _ = { type: "trim" }, w = { type: "line", hard: true }, F = { type: "line", hard: true, literal: true }, N2 = { type: "line" }, x = { type: "line", soft: true }, I2 = t([w, E]), P = t([F, E]), $2 = { type: "cursor", placeholder: Symbol("cursor") };
  function D(C, o) {
    let h = [];
    for (let v2 = 0; v2 < o.length; v2++)
      v2 !== 0 && h.push(C), h.push(o[v2]);
    return t(h);
  }
  function T(C, o, h) {
    let v2 = C;
    if (o > 0) {
      for (let S = 0; S < Math.floor(o / h); ++S)
        v2 = s(v2);
      v2 = a(o % h, v2), v2 = a(Number.NEGATIVE_INFINITY, v2);
    }
    return v2;
  }
  function m(C, o) {
    return { type: "label", label: C, contents: o };
  }
  r.exports = { concat: t, join: D, line: N2, softline: x, hardline: I2, literalline: P, group: n, conditionalGroup: p, fill: d2, lineSuffix: c, lineSuffixBoundary: f, cursor: $2, breakParent: E, ifBreak: y2, trim: _, indent: s, indentIfBreak: g2, align: a, addAlignmentToDoc: T, markAsRoot: i, dedentToRoot: u, dedent: l, hardlineWithoutBreakParent: w, literallineWithoutBreakParent: F, label: m };
} }), Hn = te$1({ "src/common/end-of-line.js"(e, r) {
  ne();
  function t(u) {
    let i = u.indexOf("\r");
    return i >= 0 ? u.charAt(i + 1) === `
` ? "crlf" : "cr" : "lf";
  }
  function s(u) {
    switch (u) {
      case "cr":
        return "\r";
      case "crlf":
        return `\r
`;
      default:
        return `
`;
    }
  }
  function a(u, i) {
    let l;
    switch (i) {
      case `
`:
        l = /\n/g;
        break;
      case "\r":
        l = /\r/g;
        break;
      case `\r
`:
        l = /\r\n/g;
        break;
      default:
        throw new Error(`Unexpected "eol" ${JSON.stringify(i)}.`);
    }
    let p = u.match(l);
    return p ? p.length : 0;
  }
  function n(u) {
    return u.replace(/\r\n?/g, `
`);
  }
  r.exports = { guessEndOfLine: t, convertEndOfLineToChars: s, countEndOfLineChars: a, normalizeEndOfLine: n };
} }), lt$1 = te$1({ "src/utils/get-last.js"(e, r) {
  ne();
  var t = (s) => s[s.length - 1];
  r.exports = t;
} });
function CD() {
  let { onlyFirst: e = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
  return new RegExp(r, e ? void 0 : "g");
}
var ED = ht$1({ "node_modules/strip-ansi/node_modules/ansi-regex/index.js"() {
  ne();
} });
function FD(e) {
  if (typeof e != "string")
    throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);
  return e.replace(CD(), "");
}
var AD = ht$1({ "node_modules/strip-ansi/index.js"() {
  ne(), ED();
} });
function SD(e) {
  return Number.isInteger(e) ? e >= 4352 && (e <= 4447 || e === 9001 || e === 9002 || 11904 <= e && e <= 12871 && e !== 12351 || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141) : false;
}
var xD = ht$1({ "node_modules/is-fullwidth-code-point/index.js"() {
  ne();
} }), bD = te$1({ "node_modules/emoji-regex/index.js"(e, r) {
  ne(), r.exports = function() {
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
  };
} }), ba = {};
zt$1(ba, { default: () => TD });
function TD(e) {
  if (typeof e != "string" || e.length === 0 || (e = FD(e), e.length === 0))
    return 0;
  e = e.replace((0, Ta.default)(), "  ");
  let r = 0;
  for (let t = 0; t < e.length; t++) {
    let s = e.codePointAt(t);
    s <= 31 || s >= 127 && s <= 159 || s >= 768 && s <= 879 || (s > 65535 && t++, r += SD(s) ? 2 : 1);
  }
  return r;
}
var Ta, BD = ht$1({ "node_modules/string-width/index.js"() {
  ne(), AD(), xD(), Ta = yD(bD());
} }), Ba = te$1({ "src/utils/get-string-width.js"(e, r) {
  ne();
  var t = (BD(), ft$2(ba)).default, s = /[^\x20-\x7F]/;
  function a(n) {
    return n ? s.test(n) ? t(n) : n.length : 0;
  }
  r.exports = a;
} }), Xt$2 = te$1({ "src/document/doc-utils.js"(e, r) {
  ne();
  var t = lt$1(), { literalline: s, join: a } = Wn$2(), n = (o) => Array.isArray(o) || o && o.type === "concat", u = (o) => {
    if (Array.isArray(o))
      return o;
    if (o.type !== "concat" && o.type !== "fill")
      throw new Error("Expect doc type to be `concat` or `fill`.");
    return o.parts;
  }, i = {};
  function l(o, h, v2, S) {
    let b = [o];
    for (; b.length > 0; ) {
      let B = b.pop();
      if (B === i) {
        v2(b.pop());
        continue;
      }
      if (v2 && b.push(B, i), !h || h(B) !== false)
        if (n(B) || B.type === "fill") {
          let k = u(B);
          for (let M2 = k.length, R2 = M2 - 1; R2 >= 0; --R2)
            b.push(k[R2]);
        } else if (B.type === "if-break")
          B.flatContents && b.push(B.flatContents), B.breakContents && b.push(B.breakContents);
        else if (B.type === "group" && B.expandedStates)
          if (S)
            for (let k = B.expandedStates.length, M2 = k - 1; M2 >= 0; --M2)
              b.push(B.expandedStates[M2]);
          else
            b.push(B.contents);
        else
          B.contents && b.push(B.contents);
    }
  }
  function p(o, h) {
    let v2 = /* @__PURE__ */ new Map();
    return S(o);
    function S(B) {
      if (v2.has(B))
        return v2.get(B);
      let k = b(B);
      return v2.set(B, k), k;
    }
    function b(B) {
      if (Array.isArray(B))
        return h(B.map(S));
      if (B.type === "concat" || B.type === "fill") {
        let k = B.parts.map(S);
        return h(Object.assign(Object.assign({}, B), {}, { parts: k }));
      }
      if (B.type === "if-break") {
        let k = B.breakContents && S(B.breakContents), M2 = B.flatContents && S(B.flatContents);
        return h(Object.assign(Object.assign({}, B), {}, { breakContents: k, flatContents: M2 }));
      }
      if (B.type === "group" && B.expandedStates) {
        let k = B.expandedStates.map(S), M2 = k[0];
        return h(Object.assign(Object.assign({}, B), {}, { contents: M2, expandedStates: k }));
      }
      if (B.contents) {
        let k = S(B.contents);
        return h(Object.assign(Object.assign({}, B), {}, { contents: k }));
      }
      return h(B);
    }
  }
  function d2(o, h, v2) {
    let S = v2, b = false;
    function B(k) {
      let M2 = h(k);
      if (M2 !== void 0 && (b = true, S = M2), b)
        return false;
    }
    return l(o, B), S;
  }
  function y2(o) {
    if (o.type === "group" && o.break || o.type === "line" && o.hard || o.type === "break-parent")
      return true;
  }
  function g2(o) {
    return d2(o, y2, false);
  }
  function c(o) {
    if (o.length > 0) {
      let h = t(o);
      !h.expandedStates && !h.break && (h.break = "propagated");
    }
    return null;
  }
  function f(o) {
    let h = /* @__PURE__ */ new Set(), v2 = [];
    function S(B) {
      if (B.type === "break-parent" && c(v2), B.type === "group") {
        if (v2.push(B), h.has(B))
          return false;
        h.add(B);
      }
    }
    function b(B) {
      B.type === "group" && v2.pop().break && c(v2);
    }
    l(o, S, b, true);
  }
  function E(o) {
    return o.type === "line" && !o.hard ? o.soft ? "" : " " : o.type === "if-break" ? o.flatContents || "" : o;
  }
  function _(o) {
    return p(o, E);
  }
  var w = (o, h) => o && o.type === "line" && o.hard && h && h.type === "break-parent";
  function F(o) {
    if (!o)
      return o;
    if (n(o) || o.type === "fill") {
      let h = u(o);
      for (; h.length > 1 && w(...h.slice(-2)); )
        h.length -= 2;
      if (h.length > 0) {
        let v2 = F(t(h));
        h[h.length - 1] = v2;
      }
      return Array.isArray(o) ? h : Object.assign(Object.assign({}, o), {}, { parts: h });
    }
    switch (o.type) {
      case "align":
      case "indent":
      case "indent-if-break":
      case "group":
      case "line-suffix":
      case "label": {
        let h = F(o.contents);
        return Object.assign(Object.assign({}, o), {}, { contents: h });
      }
      case "if-break": {
        let h = F(o.breakContents), v2 = F(o.flatContents);
        return Object.assign(Object.assign({}, o), {}, { breakContents: h, flatContents: v2 });
      }
    }
    return o;
  }
  function N2(o) {
    return F(I2(o));
  }
  function x(o) {
    switch (o.type) {
      case "fill":
        if (o.parts.every((v2) => v2 === ""))
          return "";
        break;
      case "group":
        if (!o.contents && !o.id && !o.break && !o.expandedStates)
          return "";
        if (o.contents.type === "group" && o.contents.id === o.id && o.contents.break === o.break && o.contents.expandedStates === o.expandedStates)
          return o.contents;
        break;
      case "align":
      case "indent":
      case "indent-if-break":
      case "line-suffix":
        if (!o.contents)
          return "";
        break;
      case "if-break":
        if (!o.flatContents && !o.breakContents)
          return "";
        break;
    }
    if (!n(o))
      return o;
    let h = [];
    for (let v2 of u(o)) {
      if (!v2)
        continue;
      let [S, ...b] = n(v2) ? u(v2) : [v2];
      typeof S == "string" && typeof t(h) == "string" ? h[h.length - 1] += S : h.push(S), h.push(...b);
    }
    return h.length === 0 ? "" : h.length === 1 ? h[0] : Array.isArray(o) ? h : Object.assign(Object.assign({}, o), {}, { parts: h });
  }
  function I2(o) {
    return p(o, (h) => x(h));
  }
  function P(o) {
    let h = [], v2 = o.filter(Boolean);
    for (; v2.length > 0; ) {
      let S = v2.shift();
      if (S) {
        if (n(S)) {
          v2.unshift(...u(S));
          continue;
        }
        if (h.length > 0 && typeof t(h) == "string" && typeof S == "string") {
          h[h.length - 1] += S;
          continue;
        }
        h.push(S);
      }
    }
    return h;
  }
  function $2(o) {
    return p(o, (h) => Array.isArray(h) ? P(h) : h.parts ? Object.assign(Object.assign({}, h), {}, { parts: P(h.parts) }) : h);
  }
  function D(o) {
    return p(o, (h) => typeof h == "string" && h.includes(`
`) ? T(h) : h);
  }
  function T(o) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s;
    return a(h, o.split(`
`)).parts;
  }
  function m(o) {
    if (o.type === "line")
      return true;
  }
  function C(o) {
    return d2(o, m, false);
  }
  r.exports = { isConcat: n, getDocParts: u, willBreak: g2, traverseDoc: l, findInDoc: d2, mapDoc: p, propagateBreaks: f, removeLines: _, stripTrailingHardline: N2, normalizeParts: P, normalizeDoc: $2, cleanDoc: I2, replaceTextEndOfLine: T, replaceEndOfLine: D, canBreak: C };
} }), ND = te$1({ "src/document/doc-printer.js"(e, r) {
  ne();
  var { convertEndOfLineToChars: t } = Hn(), s = lt$1(), a = Ba(), { fill: n, cursor: u, indent: i } = Wn$2(), { isConcat: l, getDocParts: p } = Xt$2(), d2, y2 = 1, g2 = 2;
  function c() {
    return { value: "", length: 0, queue: [] };
  }
  function f(x, I2) {
    return _(x, { type: "indent" }, I2);
  }
  function E(x, I2, P) {
    return I2 === Number.NEGATIVE_INFINITY ? x.root || c() : I2 < 0 ? _(x, { type: "dedent" }, P) : I2 ? I2.type === "root" ? Object.assign(Object.assign({}, x), {}, { root: x }) : _(x, { type: typeof I2 == "string" ? "stringAlign" : "numberAlign", n: I2 }, P) : x;
  }
  function _(x, I2, P) {
    let $2 = I2.type === "dedent" ? x.queue.slice(0, -1) : [...x.queue, I2], D = "", T = 0, m = 0, C = 0;
    for (let k of $2)
      switch (k.type) {
        case "indent":
          v2(), P.useTabs ? o(1) : h(P.tabWidth);
          break;
        case "stringAlign":
          v2(), D += k.n, T += k.n.length;
          break;
        case "numberAlign":
          m += 1, C += k.n;
          break;
        default:
          throw new Error(`Unexpected type '${k.type}'`);
      }
    return b(), Object.assign(Object.assign({}, x), {}, { value: D, length: T, queue: $2 });
    function o(k) {
      D += "	".repeat(k), T += P.tabWidth * k;
    }
    function h(k) {
      D += " ".repeat(k), T += k;
    }
    function v2() {
      P.useTabs ? S() : b();
    }
    function S() {
      m > 0 && o(m), B();
    }
    function b() {
      C > 0 && h(C), B();
    }
    function B() {
      m = 0, C = 0;
    }
  }
  function w(x) {
    if (x.length === 0)
      return 0;
    let I2 = 0;
    for (; x.length > 0 && typeof s(x) == "string" && /^[\t ]*$/.test(s(x)); )
      I2 += x.pop().length;
    if (x.length > 0 && typeof s(x) == "string") {
      let P = s(x).replace(/[\t ]*$/, "");
      I2 += s(x).length - P.length, x[x.length - 1] = P;
    }
    return I2;
  }
  function F(x, I2, P, $2, D) {
    let T = I2.length, m = [x], C = [];
    for (; P >= 0; ) {
      if (m.length === 0) {
        if (T === 0)
          return true;
        m.push(I2[--T]);
        continue;
      }
      let { mode: o, doc: h } = m.pop();
      if (typeof h == "string")
        C.push(h), P -= a(h);
      else if (l(h) || h.type === "fill") {
        let v2 = p(h);
        for (let S = v2.length - 1; S >= 0; S--)
          m.push({ mode: o, doc: v2[S] });
      } else
        switch (h.type) {
          case "indent":
          case "align":
          case "indent-if-break":
          case "label":
            m.push({ mode: o, doc: h.contents });
            break;
          case "trim":
            P += w(C);
            break;
          case "group": {
            if (D && h.break)
              return false;
            let v2 = h.break ? y2 : o, S = h.expandedStates && v2 === y2 ? s(h.expandedStates) : h.contents;
            m.push({ mode: v2, doc: S });
            break;
          }
          case "if-break": {
            let S = (h.groupId ? d2[h.groupId] || g2 : o) === y2 ? h.breakContents : h.flatContents;
            S && m.push({ mode: o, doc: S });
            break;
          }
          case "line":
            if (o === y2 || h.hard)
              return true;
            h.soft || (C.push(" "), P--);
            break;
          case "line-suffix":
            $2 = true;
            break;
          case "line-suffix-boundary":
            if ($2)
              return false;
            break;
        }
    }
    return false;
  }
  function N2(x, I2) {
    d2 = {};
    let P = I2.printWidth, $2 = t(I2.endOfLine), D = 0, T = [{ ind: c(), mode: y2, doc: x }], m = [], C = false, o = [];
    for (; T.length > 0; ) {
      let { ind: v2, mode: S, doc: b } = T.pop();
      if (typeof b == "string") {
        let B = $2 !== `
` ? b.replace(/\n/g, $2) : b;
        m.push(B), D += a(B);
      } else if (l(b)) {
        let B = p(b);
        for (let k = B.length - 1; k >= 0; k--)
          T.push({ ind: v2, mode: S, doc: B[k] });
      } else
        switch (b.type) {
          case "cursor":
            m.push(u.placeholder);
            break;
          case "indent":
            T.push({ ind: f(v2, I2), mode: S, doc: b.contents });
            break;
          case "align":
            T.push({ ind: E(v2, b.n, I2), mode: S, doc: b.contents });
            break;
          case "trim":
            D -= w(m);
            break;
          case "group":
            switch (S) {
              case g2:
                if (!C) {
                  T.push({ ind: v2, mode: b.break ? y2 : g2, doc: b.contents });
                  break;
                }
              case y2: {
                C = false;
                let B = { ind: v2, mode: g2, doc: b.contents }, k = P - D, M2 = o.length > 0;
                if (!b.break && F(B, T, k, M2))
                  T.push(B);
                else if (b.expandedStates) {
                  let R2 = s(b.expandedStates);
                  if (b.break) {
                    T.push({ ind: v2, mode: y2, doc: R2 });
                    break;
                  } else
                    for (let q = 1; q < b.expandedStates.length + 1; q++)
                      if (q >= b.expandedStates.length) {
                        T.push({ ind: v2, mode: y2, doc: R2 });
                        break;
                      } else {
                        let J = b.expandedStates[q], L = { ind: v2, mode: g2, doc: J };
                        if (F(L, T, k, M2)) {
                          T.push(L);
                          break;
                        }
                      }
                } else
                  T.push({ ind: v2, mode: y2, doc: b.contents });
                break;
              }
            }
            b.id && (d2[b.id] = s(T).mode);
            break;
          case "fill": {
            let B = P - D, { parts: k } = b;
            if (k.length === 0)
              break;
            let [M2, R2] = k, q = { ind: v2, mode: g2, doc: M2 }, J = { ind: v2, mode: y2, doc: M2 }, L = F(q, [], B, o.length > 0, true);
            if (k.length === 1) {
              L ? T.push(q) : T.push(J);
              break;
            }
            let Q = { ind: v2, mode: g2, doc: R2 }, V = { ind: v2, mode: y2, doc: R2 };
            if (k.length === 2) {
              L ? T.push(Q, q) : T.push(V, J);
              break;
            }
            k.splice(0, 2);
            let j = { ind: v2, mode: S, doc: n(k) }, Y = k[0];
            F({ ind: v2, mode: g2, doc: [M2, R2, Y] }, [], B, o.length > 0, true) ? T.push(j, Q, q) : L ? T.push(j, V, q) : T.push(j, V, J);
            break;
          }
          case "if-break":
          case "indent-if-break": {
            let B = b.groupId ? d2[b.groupId] : S;
            if (B === y2) {
              let k = b.type === "if-break" ? b.breakContents : b.negate ? b.contents : i(b.contents);
              k && T.push({ ind: v2, mode: S, doc: k });
            }
            if (B === g2) {
              let k = b.type === "if-break" ? b.flatContents : b.negate ? i(b.contents) : b.contents;
              k && T.push({ ind: v2, mode: S, doc: k });
            }
            break;
          }
          case "line-suffix":
            o.push({ ind: v2, mode: S, doc: b.contents });
            break;
          case "line-suffix-boundary":
            o.length > 0 && T.push({ ind: v2, mode: S, doc: { type: "line", hard: true } });
            break;
          case "line":
            switch (S) {
              case g2:
                if (b.hard)
                  C = true;
                else {
                  b.soft || (m.push(" "), D += 1);
                  break;
                }
              case y2:
                if (o.length > 0) {
                  T.push({ ind: v2, mode: S, doc: b }, ...o.reverse()), o.length = 0;
                  break;
                }
                b.literal ? v2.root ? (m.push($2, v2.root.value), D = v2.root.length) : (m.push($2), D = 0) : (D -= w(m), m.push($2 + v2.value), D = v2.length);
                break;
            }
            break;
          case "label":
            T.push({ ind: v2, mode: S, doc: b.contents });
            break;
        }
      T.length === 0 && o.length > 0 && (T.push(...o.reverse()), o.length = 0);
    }
    let h = m.indexOf(u.placeholder);
    if (h !== -1) {
      let v2 = m.indexOf(u.placeholder, h + 1), S = m.slice(0, h).join(""), b = m.slice(h + 1, v2).join(""), B = m.slice(v2 + 1).join("");
      return { formatted: S + b + B, cursorNodeStart: S.length, cursorNodeText: b };
    }
    return { formatted: m.join("") };
  }
  r.exports = { printDocToString: N2 };
} }), wD = te$1({ "src/document/doc-debug.js"(e, r) {
  ne();
  var { isConcat: t, getDocParts: s } = Xt$2();
  function a(u) {
    if (!u)
      return "";
    if (t(u)) {
      let i = [];
      for (let l of s(u))
        if (t(l))
          i.push(...a(l).parts);
        else {
          let p = a(l);
          p !== "" && i.push(p);
        }
      return { type: "concat", parts: i };
    }
    return u.type === "if-break" ? Object.assign(Object.assign({}, u), {}, { breakContents: a(u.breakContents), flatContents: a(u.flatContents) }) : u.type === "group" ? Object.assign(Object.assign({}, u), {}, { contents: a(u.contents), expandedStates: u.expandedStates && u.expandedStates.map(a) }) : u.type === "fill" ? { type: "fill", parts: u.parts.map(a) } : u.contents ? Object.assign(Object.assign({}, u), {}, { contents: a(u.contents) }) : u;
  }
  function n(u) {
    let i = /* @__PURE__ */ Object.create(null), l = /* @__PURE__ */ new Set();
    return p(a(u));
    function p(y2, g2, c) {
      if (typeof y2 == "string")
        return JSON.stringify(y2);
      if (t(y2)) {
        let f = s(y2).map(p).filter(Boolean);
        return f.length === 1 ? f[0] : `[${f.join(", ")}]`;
      }
      if (y2.type === "line") {
        let f = Array.isArray(c) && c[g2 + 1] && c[g2 + 1].type === "break-parent";
        return y2.literal ? f ? "literalline" : "literallineWithoutBreakParent" : y2.hard ? f ? "hardline" : "hardlineWithoutBreakParent" : y2.soft ? "softline" : "line";
      }
      if (y2.type === "break-parent")
        return Array.isArray(c) && c[g2 - 1] && c[g2 - 1].type === "line" && c[g2 - 1].hard ? void 0 : "breakParent";
      if (y2.type === "trim")
        return "trim";
      if (y2.type === "indent")
        return "indent(" + p(y2.contents) + ")";
      if (y2.type === "align")
        return y2.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + p(y2.contents) + ")" : y2.n < 0 ? "dedent(" + p(y2.contents) + ")" : y2.n.type === "root" ? "markAsRoot(" + p(y2.contents) + ")" : "align(" + JSON.stringify(y2.n) + ", " + p(y2.contents) + ")";
      if (y2.type === "if-break")
        return "ifBreak(" + p(y2.breakContents) + (y2.flatContents ? ", " + p(y2.flatContents) : "") + (y2.groupId ? (y2.flatContents ? "" : ', ""') + `, { groupId: ${d2(y2.groupId)} }` : "") + ")";
      if (y2.type === "indent-if-break") {
        let f = [];
        y2.negate && f.push("negate: true"), y2.groupId && f.push(`groupId: ${d2(y2.groupId)}`);
        let E = f.length > 0 ? `, { ${f.join(", ")} }` : "";
        return `indentIfBreak(${p(y2.contents)}${E})`;
      }
      if (y2.type === "group") {
        let f = [];
        y2.break && y2.break !== "propagated" && f.push("shouldBreak: true"), y2.id && f.push(`id: ${d2(y2.id)}`);
        let E = f.length > 0 ? `, { ${f.join(", ")} }` : "";
        return y2.expandedStates ? `conditionalGroup([${y2.expandedStates.map((_) => p(_)).join(",")}]${E})` : `group(${p(y2.contents)}${E})`;
      }
      if (y2.type === "fill")
        return `fill([${y2.parts.map((f) => p(f)).join(", ")}])`;
      if (y2.type === "line-suffix")
        return "lineSuffix(" + p(y2.contents) + ")";
      if (y2.type === "line-suffix-boundary")
        return "lineSuffixBoundary";
      if (y2.type === "label")
        return `label(${JSON.stringify(y2.label)}, ${p(y2.contents)})`;
      throw new Error("Unknown doc type " + y2.type);
    }
    function d2(y2) {
      if (typeof y2 != "symbol")
        return JSON.stringify(String(y2));
      if (y2 in i)
        return i[y2];
      let g2 = String(y2).slice(7, -1) || "symbol";
      for (let c = 0; ; c++) {
        let f = g2 + (c > 0 ? ` #${c}` : "");
        if (!l.has(f))
          return l.add(f), i[y2] = `Symbol.for(${JSON.stringify(f)})`;
      }
    }
  }
  r.exports = { printDocToDebug: n };
} }), qe = te$1({ "src/document/index.js"(e, r) {
  ne(), r.exports = { builders: Wn$2(), printer: ND(), utils: Xt$2(), debug: wD() };
} }), Na = {};
zt$1(Na, { default: () => _D });
function _D(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
var PD = ht$1({ "node_modules/escape-string-regexp/index.js"() {
  ne();
} }), wa$1 = te$1({ "node_modules/semver/internal/debug.js"(e, r) {
  ne();
  var t = typeof Nt$1 == "object" && Nt$1.env && Nt$1.env.NODE_DEBUG && /\bsemver\b/i.test(Nt$1.env.NODE_DEBUG) ? function() {
    for (var s = arguments.length, a = new Array(s), n = 0; n < s; n++)
      a[n] = arguments[n];
    return console.error("SEMVER", ...a);
  } : () => {
  };
  r.exports = t;
} }), _a = te$1({ "node_modules/semver/internal/constants.js"(e, r) {
  ne();
  var t = "2.0.0", s = 256, a = Number.MAX_SAFE_INTEGER || 9007199254740991, n = 16;
  r.exports = { SEMVER_SPEC_VERSION: t, MAX_LENGTH: s, MAX_SAFE_INTEGER: a, MAX_SAFE_COMPONENT_LENGTH: n };
} }), ID = te$1({ "node_modules/semver/internal/re.js"(e, r) {
  ne();
  var { MAX_SAFE_COMPONENT_LENGTH: t } = _a(), s = wa$1();
  e = r.exports = {};
  var a = e.re = [], n = e.src = [], u = e.t = {}, i = 0, l = (p, d2, y2) => {
    let g2 = i++;
    s(p, g2, d2), u[p] = g2, n[g2] = d2, a[g2] = new RegExp(d2, y2 ? "g" : void 0);
  };
  l("NUMERICIDENTIFIER", "0|[1-9]\\d*"), l("NUMERICIDENTIFIERLOOSE", "[0-9]+"), l("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), l("MAINVERSION", `(${n[u.NUMERICIDENTIFIER]})\\.(${n[u.NUMERICIDENTIFIER]})\\.(${n[u.NUMERICIDENTIFIER]})`), l("MAINVERSIONLOOSE", `(${n[u.NUMERICIDENTIFIERLOOSE]})\\.(${n[u.NUMERICIDENTIFIERLOOSE]})\\.(${n[u.NUMERICIDENTIFIERLOOSE]})`), l("PRERELEASEIDENTIFIER", `(?:${n[u.NUMERICIDENTIFIER]}|${n[u.NONNUMERICIDENTIFIER]})`), l("PRERELEASEIDENTIFIERLOOSE", `(?:${n[u.NUMERICIDENTIFIERLOOSE]}|${n[u.NONNUMERICIDENTIFIER]})`), l("PRERELEASE", `(?:-(${n[u.PRERELEASEIDENTIFIER]}(?:\\.${n[u.PRERELEASEIDENTIFIER]})*))`), l("PRERELEASELOOSE", `(?:-?(${n[u.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${n[u.PRERELEASEIDENTIFIERLOOSE]})*))`), l("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), l("BUILD", `(?:\\+(${n[u.BUILDIDENTIFIER]}(?:\\.${n[u.BUILDIDENTIFIER]})*))`), l("FULLPLAIN", `v?${n[u.MAINVERSION]}${n[u.PRERELEASE]}?${n[u.BUILD]}?`), l("FULL", `^${n[u.FULLPLAIN]}$`), l("LOOSEPLAIN", `[v=\\s]*${n[u.MAINVERSIONLOOSE]}${n[u.PRERELEASELOOSE]}?${n[u.BUILD]}?`), l("LOOSE", `^${n[u.LOOSEPLAIN]}$`), l("GTLT", "((?:<|>)?=?)"), l("XRANGEIDENTIFIERLOOSE", `${n[u.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), l("XRANGEIDENTIFIER", `${n[u.NUMERICIDENTIFIER]}|x|X|\\*`), l("XRANGEPLAIN", `[v=\\s]*(${n[u.XRANGEIDENTIFIER]})(?:\\.(${n[u.XRANGEIDENTIFIER]})(?:\\.(${n[u.XRANGEIDENTIFIER]})(?:${n[u.PRERELEASE]})?${n[u.BUILD]}?)?)?`), l("XRANGEPLAINLOOSE", `[v=\\s]*(${n[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[u.XRANGEIDENTIFIERLOOSE]})(?:${n[u.PRERELEASELOOSE]})?${n[u.BUILD]}?)?)?`), l("XRANGE", `^${n[u.GTLT]}\\s*${n[u.XRANGEPLAIN]}$`), l("XRANGELOOSE", `^${n[u.GTLT]}\\s*${n[u.XRANGEPLAINLOOSE]}$`), l("COERCE", `(^|[^\\d])(\\d{1,${t}})(?:\\.(\\d{1,${t}}))?(?:\\.(\\d{1,${t}}))?(?:$|[^\\d])`), l("COERCERTL", n[u.COERCE], true), l("LONETILDE", "(?:~>?)"), l("TILDETRIM", `(\\s*)${n[u.LONETILDE]}\\s+`, true), e.tildeTrimReplace = "$1~", l("TILDE", `^${n[u.LONETILDE]}${n[u.XRANGEPLAIN]}$`), l("TILDELOOSE", `^${n[u.LONETILDE]}${n[u.XRANGEPLAINLOOSE]}$`), l("LONECARET", "(?:\\^)"), l("CARETTRIM", `(\\s*)${n[u.LONECARET]}\\s+`, true), e.caretTrimReplace = "$1^", l("CARET", `^${n[u.LONECARET]}${n[u.XRANGEPLAIN]}$`), l("CARETLOOSE", `^${n[u.LONECARET]}${n[u.XRANGEPLAINLOOSE]}$`), l("COMPARATORLOOSE", `^${n[u.GTLT]}\\s*(${n[u.LOOSEPLAIN]})$|^$`), l("COMPARATOR", `^${n[u.GTLT]}\\s*(${n[u.FULLPLAIN]})$|^$`), l("COMPARATORTRIM", `(\\s*)${n[u.GTLT]}\\s*(${n[u.LOOSEPLAIN]}|${n[u.XRANGEPLAIN]})`, true), e.comparatorTrimReplace = "$1$2$3", l("HYPHENRANGE", `^\\s*(${n[u.XRANGEPLAIN]})\\s+-\\s+(${n[u.XRANGEPLAIN]})\\s*$`), l("HYPHENRANGELOOSE", `^\\s*(${n[u.XRANGEPLAINLOOSE]})\\s+-\\s+(${n[u.XRANGEPLAINLOOSE]})\\s*$`), l("STAR", "(<|>)?=?\\s*\\*"), l("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), l("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
} }), kD = te$1({ "node_modules/semver/internal/parse-options.js"(e, r) {
  ne();
  var t = ["includePrerelease", "loose", "rtl"], s = (a) => a ? typeof a != "object" ? { loose: true } : t.filter((n) => a[n]).reduce((n, u) => (n[u] = true, n), {}) : {};
  r.exports = s;
} }), LD$1 = te$1({ "node_modules/semver/internal/identifiers.js"(e, r) {
  ne();
  var t = /^[0-9]+$/, s = (n, u) => {
    let i = t.test(n), l = t.test(u);
    return i && l && (n = +n, u = +u), n === u ? 0 : i && !l ? -1 : l && !i ? 1 : n < u ? -1 : 1;
  }, a = (n, u) => s(u, n);
  r.exports = { compareIdentifiers: s, rcompareIdentifiers: a };
} }), OD = te$1({ "node_modules/semver/classes/semver.js"(e, r) {
  ne();
  var t = wa$1(), { MAX_LENGTH: s, MAX_SAFE_INTEGER: a } = _a(), { re: n, t: u } = ID(), i = kD(), { compareIdentifiers: l } = LD$1(), p = class {
    constructor(d2, y2) {
      if (y2 = i(y2), d2 instanceof p) {
        if (d2.loose === !!y2.loose && d2.includePrerelease === !!y2.includePrerelease)
          return d2;
        d2 = d2.version;
      } else if (typeof d2 != "string")
        throw new TypeError(`Invalid Version: ${d2}`);
      if (d2.length > s)
        throw new TypeError(`version is longer than ${s} characters`);
      t("SemVer", d2, y2), this.options = y2, this.loose = !!y2.loose, this.includePrerelease = !!y2.includePrerelease;
      let g2 = d2.trim().match(y2.loose ? n[u.LOOSE] : n[u.FULL]);
      if (!g2)
        throw new TypeError(`Invalid Version: ${d2}`);
      if (this.raw = d2, this.major = +g2[1], this.minor = +g2[2], this.patch = +g2[3], this.major > a || this.major < 0)
        throw new TypeError("Invalid major version");
      if (this.minor > a || this.minor < 0)
        throw new TypeError("Invalid minor version");
      if (this.patch > a || this.patch < 0)
        throw new TypeError("Invalid patch version");
      g2[4] ? this.prerelease = g2[4].split(".").map((c) => {
        if (/^[0-9]+$/.test(c)) {
          let f = +c;
          if (f >= 0 && f < a)
            return f;
        }
        return c;
      }) : this.prerelease = [], this.build = g2[5] ? g2[5].split(".") : [], this.format();
    }
    format() {
      return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
    }
    toString() {
      return this.version;
    }
    compare(d2) {
      if (t("SemVer.compare", this.version, this.options, d2), !(d2 instanceof p)) {
        if (typeof d2 == "string" && d2 === this.version)
          return 0;
        d2 = new p(d2, this.options);
      }
      return d2.version === this.version ? 0 : this.compareMain(d2) || this.comparePre(d2);
    }
    compareMain(d2) {
      return d2 instanceof p || (d2 = new p(d2, this.options)), l(this.major, d2.major) || l(this.minor, d2.minor) || l(this.patch, d2.patch);
    }
    comparePre(d2) {
      if (d2 instanceof p || (d2 = new p(d2, this.options)), this.prerelease.length && !d2.prerelease.length)
        return -1;
      if (!this.prerelease.length && d2.prerelease.length)
        return 1;
      if (!this.prerelease.length && !d2.prerelease.length)
        return 0;
      let y2 = 0;
      do {
        let g2 = this.prerelease[y2], c = d2.prerelease[y2];
        if (t("prerelease compare", y2, g2, c), g2 === void 0 && c === void 0)
          return 0;
        if (c === void 0)
          return 1;
        if (g2 === void 0)
          return -1;
        if (g2 === c)
          continue;
        return l(g2, c);
      } while (++y2);
    }
    compareBuild(d2) {
      d2 instanceof p || (d2 = new p(d2, this.options));
      let y2 = 0;
      do {
        let g2 = this.build[y2], c = d2.build[y2];
        if (t("prerelease compare", y2, g2, c), g2 === void 0 && c === void 0)
          return 0;
        if (c === void 0)
          return 1;
        if (g2 === void 0)
          return -1;
        if (g2 === c)
          continue;
        return l(g2, c);
      } while (++y2);
    }
    inc(d2, y2) {
      switch (d2) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", y2);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", y2);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", y2), this.inc("pre", y2);
          break;
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", y2), this.inc("pre", y2);
          break;
        case "major":
          (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0)
            this.prerelease = [0];
          else {
            let g2 = this.prerelease.length;
            for (; --g2 >= 0; )
              typeof this.prerelease[g2] == "number" && (this.prerelease[g2]++, g2 = -2);
            g2 === -1 && this.prerelease.push(0);
          }
          y2 && (l(this.prerelease[0], y2) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [y2, 0]) : this.prerelease = [y2, 0]);
          break;
        default:
          throw new Error(`invalid increment argument: ${d2}`);
      }
      return this.format(), this.raw = this.version, this;
    }
  };
  r.exports = p;
} }), Gn$1 = te$1({ "node_modules/semver/functions/compare.js"(e, r) {
  ne();
  var t = OD(), s = (a, n, u) => new t(a, u).compare(new t(n, u));
  r.exports = s;
} }), jD$1 = te$1({ "node_modules/semver/functions/lt.js"(e, r) {
  ne();
  var t = Gn$1(), s = (a, n, u) => t(a, n, u) < 0;
  r.exports = s;
} }), qD = te$1({ "node_modules/semver/functions/gte.js"(e, r) {
  ne();
  var t = Gn$1(), s = (a, n, u) => t(a, n, u) >= 0;
  r.exports = s;
} }), MD$1 = te$1({ "src/utils/arrayify.js"(e, r) {
  ne(), r.exports = (t, s) => Object.entries(t).map((a) => {
    let [n, u] = a;
    return Object.assign({ [s]: n }, u);
  });
} }), RD = te$1({ "node_modules/outdent/lib/index.js"(e, r) {
  ne(), Object.defineProperty(e, "__esModule", { value: true }), e.outdent = void 0;
  function t() {
    for (var F = [], N2 = 0; N2 < arguments.length; N2++)
      F[N2] = arguments[N2];
  }
  function s() {
    return typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : a();
  }
  function a() {
    return { add: t, delete: t, get: t, set: t, has: function(F) {
      return false;
    } };
  }
  var n = Object.prototype.hasOwnProperty, u = function(F, N2) {
    return n.call(F, N2);
  };
  function i(F, N2) {
    for (var x in N2)
      u(N2, x) && (F[x] = N2[x]);
    return F;
  }
  var l = /^[ \t]*(?:\r\n|\r|\n)/, p = /(?:\r\n|\r|\n)[ \t]*$/, d2 = /^(?:[\r\n]|$)/, y2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, g2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
  function c(F, N2, x) {
    var I2 = 0, P = F[0].match(y2);
    P && (I2 = P[1].length);
    var $2 = "(\\r\\n|\\r|\\n).{0," + I2 + "}", D = new RegExp($2, "g");
    N2 && (F = F.slice(1));
    var T = x.newline, m = x.trimLeadingNewline, C = x.trimTrailingNewline, o = typeof T == "string", h = F.length, v2 = F.map(function(S, b) {
      return S = S.replace(D, "$1"), b === 0 && m && (S = S.replace(l, "")), b === h - 1 && C && (S = S.replace(p, "")), o && (S = S.replace(/\r\n|\n|\r/g, function(B) {
        return T;
      })), S;
    });
    return v2;
  }
  function f(F, N2) {
    for (var x = "", I2 = 0, P = F.length; I2 < P; I2++)
      x += F[I2], I2 < P - 1 && (x += N2[I2]);
    return x;
  }
  function E(F) {
    return u(F, "raw") && u(F, "length");
  }
  function _(F) {
    var N2 = s(), x = s();
    function I2($2) {
      for (var D = [], T = 1; T < arguments.length; T++)
        D[T - 1] = arguments[T];
      if (E($2)) {
        var m = $2, C = (D[0] === I2 || D[0] === w) && g2.test(m[0]) && d2.test(m[1]), o = C ? x : N2, h = o.get(m);
        if (h || (h = c(m, C, F), o.set(m, h)), D.length === 0)
          return h[0];
        var v2 = f(h, C ? D.slice(1) : D);
        return v2;
      } else
        return _(i(i({}, F), $2 || {}));
    }
    var P = i(I2, { string: function($2) {
      return c([$2], false, F)[0];
    } });
    return P;
  }
  var w = _({ trimLeadingNewline: true, trimTrailingNewline: true });
  if (e.outdent = w, e.default = w, typeof r < "u")
    try {
      r.exports = w, Object.defineProperty(w, "__esModule", { value: true }), w.default = w, w.outdent = w;
    } catch {
    }
} }), $D$1 = te$1({ "src/main/core-options.js"(e, r) {
  ne();
  var { outdent: t } = RD(), s = "Config", a = "Editor", n = "Format", u = "Other", i = "Output", l = "Global", p = "Special", d2 = { cursorOffset: { since: "1.4.0", category: p, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: a }, endOfLine: { since: "1.15.0", category: l, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: t`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        ` }] }, filepath: { since: "1.4.0", category: p, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: u, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: p, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: u }, parser: { since: "0.0.10", category: l, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (y2) => typeof y2 == "string" || typeof y2 == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "acorn", since: "2.6.0", description: "JavaScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: l, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (y2) => typeof y2 == "string" || typeof y2 == "object", cliName: "plugin", cliCategory: s }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: l, description: t`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (y2) => typeof y2 == "string" || typeof y2 == "object", cliName: "plugin-search-dir", cliCategory: s }, printWidth: { since: "0.0.0", category: l, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: p, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a }, rangeStart: { since: "1.4.0", category: p, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a }, requirePragma: { since: "1.7.0", category: p, type: "boolean", default: false, description: t`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: u }, tabWidth: { type: "int", category: l, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: l, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: l, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
  r.exports = { CATEGORY_CONFIG: s, CATEGORY_EDITOR: a, CATEGORY_FORMAT: n, CATEGORY_OTHER: u, CATEGORY_OUTPUT: i, CATEGORY_GLOBAL: l, CATEGORY_SPECIAL: p, options: d2 };
} }), Un$1 = te$1({ "src/main/support.js"(e, r) {
  ne();
  var t = { compare: Gn$1(), lt: jD$1(), gte: qD() }, s = MD$1(), a = xa().version, n = $D$1().options;
  function u() {
    let { plugins: l = [], showUnreleased: p = false, showDeprecated: d2 = false, showInternal: y2 = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, g2 = a.split("-", 1)[0], c = l.flatMap((F) => F.languages || []).filter(E), f = s(Object.assign({}, ...l.map((F) => {
      let { options: N2 } = F;
      return N2;
    }), n), "name").filter((F) => E(F) && _(F)).sort((F, N2) => F.name === N2.name ? 0 : F.name < N2.name ? -1 : 1).map(w).map((F) => {
      F = Object.assign({}, F), Array.isArray(F.default) && (F.default = F.default.length === 1 ? F.default[0].value : F.default.filter(E).sort((x, I2) => t.compare(I2.since, x.since))[0].value), Array.isArray(F.choices) && (F.choices = F.choices.filter((x) => E(x) && _(x)), F.name === "parser" && i(F, c, l));
      let N2 = Object.fromEntries(l.filter((x) => x.defaultOptions && x.defaultOptions[F.name] !== void 0).map((x) => [x.name, x.defaultOptions[F.name]]));
      return Object.assign(Object.assign({}, F), {}, { pluginDefaults: N2 });
    });
    return { languages: c, options: f };
    function E(F) {
      return p || !("since" in F) || F.since && t.gte(g2, F.since);
    }
    function _(F) {
      return d2 || !("deprecated" in F) || F.deprecated && t.lt(g2, F.deprecated);
    }
    function w(F) {
      if (y2)
        return F;
      return $n(F, lD);
    }
  }
  function i(l, p, d2) {
    let y2 = new Set(l.choices.map((g2) => g2.value));
    for (let g2 of p)
      if (g2.parsers) {
        for (let c of g2.parsers)
          if (!y2.has(c)) {
            y2.add(c);
            let f = d2.find((_) => _.parsers && _.parsers[c]), E = g2.name;
            f && f.name && (E += ` (plugin: ${f.name})`), l.choices.push({ value: c, description: E });
          }
      }
  }
  r.exports = { getSupportInfo: u };
} }), Jn$1 = te$1({ "src/utils/is-non-empty-array.js"(e, r) {
  ne();
  function t(s) {
    return Array.isArray(s) && s.length > 0;
  }
  r.exports = t;
} }), wr$2 = te$1({ "src/utils/text/skip.js"(e, r) {
  ne();
  function t(i) {
    return (l, p, d2) => {
      let y2 = d2 && d2.backwards;
      if (p === false)
        return false;
      let { length: g2 } = l, c = p;
      for (; c >= 0 && c < g2; ) {
        let f = l.charAt(c);
        if (i instanceof RegExp) {
          if (!i.test(f))
            return c;
        } else if (!i.includes(f))
          return c;
        y2 ? c-- : c++;
      }
      return c === -1 || c === g2 ? c : false;
    };
  }
  var s = t(/\s/), a = t(" 	"), n = t(",; 	"), u = t(/[^\n\r]/);
  r.exports = { skipWhitespace: s, skipSpaces: a, skipToLineEnd: n, skipEverythingButNewLine: u };
} }), Pa = te$1({ "src/utils/text/skip-inline-comment.js"(e, r) {
  ne();
  function t(s, a) {
    if (a === false)
      return false;
    if (s.charAt(a) === "/" && s.charAt(a + 1) === "*") {
      for (let n = a + 2; n < s.length; ++n)
        if (s.charAt(n) === "*" && s.charAt(n + 1) === "/")
          return n + 2;
    }
    return a;
  }
  r.exports = t;
} }), Ia = te$1({ "src/utils/text/skip-trailing-comment.js"(e, r) {
  ne();
  var { skipEverythingButNewLine: t } = wr$2();
  function s(a, n) {
    return n === false ? false : a.charAt(n) === "/" && a.charAt(n + 1) === "/" ? t(a, n) : n;
  }
  r.exports = s;
} }), ka = te$1({ "src/utils/text/skip-newline.js"(e, r) {
  ne();
  function t(s, a, n) {
    let u = n && n.backwards;
    if (a === false)
      return false;
    let i = s.charAt(a);
    if (u) {
      if (s.charAt(a - 1) === "\r" && i === `
`)
        return a - 2;
      if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
        return a - 1;
    } else {
      if (i === "\r" && s.charAt(a + 1) === `
`)
        return a + 2;
      if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
        return a + 1;
    }
    return a;
  }
  r.exports = t;
} }), VD$1 = te$1({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e, r) {
  ne();
  var t = Pa(), s = ka(), a = Ia(), { skipSpaces: n } = wr$2();
  function u(i, l) {
    let p = null, d2 = l;
    for (; d2 !== p; )
      p = d2, d2 = n(i, d2), d2 = t(i, d2), d2 = a(i, d2), d2 = s(i, d2);
    return d2;
  }
  r.exports = u;
} }), Ue$2 = te$1({ "src/common/util.js"(e, r) {
  ne();
  var { default: t } = (PD(), ft$2(Na)), s = lt$1(), { getSupportInfo: a } = Un$1(), n = Jn$1(), u = Ba(), { skipWhitespace: i, skipSpaces: l, skipToLineEnd: p, skipEverythingButNewLine: d2 } = wr$2(), y2 = Pa(), g2 = Ia(), c = ka(), f = VD$1(), E = (V) => V[V.length - 2];
  function _(V) {
    return (j, Y, ie2) => {
      let ee2 = ie2 && ie2.backwards;
      if (Y === false)
        return false;
      let { length: ce2 } = j, W = Y;
      for (; W >= 0 && W < ce2; ) {
        let K2 = j.charAt(W);
        if (V instanceof RegExp) {
          if (!V.test(K2))
            return W;
        } else if (!V.includes(K2))
          return W;
        ee2 ? W-- : W++;
      }
      return W === -1 || W === ce2 ? W : false;
    };
  }
  function w(V, j) {
    let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, ie2 = l(V, Y.backwards ? j - 1 : j, Y), ee2 = c(V, ie2, Y);
    return ie2 !== ee2;
  }
  function F(V, j, Y) {
    for (let ie2 = j; ie2 < Y; ++ie2)
      if (V.charAt(ie2) === `
`)
        return true;
    return false;
  }
  function N2(V, j, Y) {
    let ie2 = Y(j) - 1;
    ie2 = l(V, ie2, { backwards: true }), ie2 = c(V, ie2, { backwards: true }), ie2 = l(V, ie2, { backwards: true });
    let ee2 = c(V, ie2, { backwards: true });
    return ie2 !== ee2;
  }
  function x(V, j) {
    let Y = null, ie2 = j;
    for (; ie2 !== Y; )
      Y = ie2, ie2 = p(V, ie2), ie2 = y2(V, ie2), ie2 = l(V, ie2);
    return ie2 = g2(V, ie2), ie2 = c(V, ie2), ie2 !== false && w(V, ie2);
  }
  function I2(V, j, Y) {
    return x(V, Y(j));
  }
  function P(V, j, Y) {
    return f(V, Y(j));
  }
  function $2(V, j, Y) {
    return V.charAt(P(V, j, Y));
  }
  function D(V, j) {
    let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return l(V, Y.backwards ? j - 1 : j, Y) !== j;
  }
  function T(V, j) {
    let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, ie2 = 0;
    for (let ee2 = Y; ee2 < V.length; ++ee2)
      V[ee2] === "	" ? ie2 = ie2 + j - ie2 % j : ie2++;
    return ie2;
  }
  function m(V, j) {
    let Y = V.lastIndexOf(`
`);
    return Y === -1 ? 0 : T(V.slice(Y + 1).match(/^[\t ]*/)[0], j);
  }
  function C(V, j) {
    let Y = { quote: '"', regex: /"/g, escaped: "&quot;" }, ie2 = { quote: "'", regex: /'/g, escaped: "&apos;" }, ee2 = j === "'" ? ie2 : Y, ce2 = ee2 === ie2 ? Y : ie2, W = ee2;
    if (V.includes(ee2.quote) || V.includes(ce2.quote)) {
      let K2 = (V.match(ee2.regex) || []).length, de = (V.match(ce2.regex) || []).length;
      W = K2 > de ? ce2 : ee2;
    }
    return W;
  }
  function o(V, j) {
    let Y = V.slice(1, -1), ie2 = j.parser === "json" || j.parser === "json5" && j.quoteProps === "preserve" && !j.singleQuote ? '"' : j.__isInHtmlAttribute ? "'" : C(Y, j.singleQuote ? "'" : '"').quote;
    return h(Y, ie2, !(j.parser === "css" || j.parser === "less" || j.parser === "scss" || j.__embeddedInHtml));
  }
  function h(V, j, Y) {
    let ie2 = j === '"' ? "'" : '"', ee2 = /\\(.)|(["'])/gs, ce2 = V.replace(ee2, (W, K2, de) => K2 === ie2 ? K2 : de === j ? "\\" + de : de || (Y && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(K2) ? K2 : "\\" + K2));
    return j + ce2 + j;
  }
  function v2(V) {
    return V.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
  }
  function S(V, j) {
    let Y = V.match(new RegExp(`(${t(j)})+`, "g"));
    return Y === null ? 0 : Y.reduce((ie2, ee2) => Math.max(ie2, ee2.length / j.length), 0);
  }
  function b(V, j) {
    let Y = V.match(new RegExp(`(${t(j)})+`, "g"));
    if (Y === null)
      return 0;
    let ie2 = /* @__PURE__ */ new Map(), ee2 = 0;
    for (let ce2 of Y) {
      let W = ce2.length / j.length;
      ie2.set(W, true), W > ee2 && (ee2 = W);
    }
    for (let ce2 = 1; ce2 < ee2; ce2++)
      if (!ie2.get(ce2))
        return ce2;
    return ee2 + 1;
  }
  function B(V, j) {
    (V.comments || (V.comments = [])).push(j), j.printed = false, j.nodeDescription = Q(V);
  }
  function k(V, j) {
    j.leading = true, j.trailing = false, B(V, j);
  }
  function M2(V, j, Y) {
    j.leading = false, j.trailing = false, Y && (j.marker = Y), B(V, j);
  }
  function R2(V, j) {
    j.leading = false, j.trailing = true, B(V, j);
  }
  function q(V, j) {
    let { languages: Y } = a({ plugins: j.plugins }), ie2 = Y.find((ee2) => {
      let { name: ce2 } = ee2;
      return ce2.toLowerCase() === V;
    }) || Y.find((ee2) => {
      let { aliases: ce2 } = ee2;
      return Array.isArray(ce2) && ce2.includes(V);
    }) || Y.find((ee2) => {
      let { extensions: ce2 } = ee2;
      return Array.isArray(ce2) && ce2.includes(`.${V}`);
    });
    return ie2 && ie2.parsers[0];
  }
  function J(V) {
    return V && V.type === "front-matter";
  }
  function L(V) {
    let j = /* @__PURE__ */ new WeakMap();
    return function(Y) {
      return j.has(Y) || j.set(Y, Symbol(V)), j.get(Y);
    };
  }
  function Q(V) {
    let j = V.type || V.kind || "(unknown type)", Y = String(V.name || V.id && (typeof V.id == "object" ? V.id.name : V.id) || V.key && (typeof V.key == "object" ? V.key.name : V.key) || V.value && (typeof V.value == "object" ? "" : String(V.value)) || V.operator || "");
    return Y.length > 20 && (Y = Y.slice(0, 19) + "…"), j + (Y ? " " + Y : "");
  }
  r.exports = { inferParserByLanguage: q, getStringWidth: u, getMaxContinuousCount: S, getMinNotPresentContinuousCount: b, getPenultimate: E, getLast: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: f, getNextNonSpaceNonCommentCharacterIndex: P, getNextNonSpaceNonCommentCharacter: $2, skip: _, skipWhitespace: i, skipSpaces: l, skipToLineEnd: p, skipEverythingButNewLine: d2, skipInlineComment: y2, skipTrailingComment: g2, skipNewline: c, isNextLineEmptyAfterIndex: x, isNextLineEmpty: I2, isPreviousLineEmpty: N2, hasNewline: w, hasNewlineInRange: F, hasSpaces: D, getAlignmentSize: T, getIndentSize: m, getPreferredQuote: C, printString: o, printNumber: v2, makeString: h, addLeadingComment: k, addDanglingComment: M2, addTrailingComment: R2, isFrontMatterNode: J, isNonEmptyArray: n, createGroupIdMapper: L };
} }), La = {};
zt$1(La, { basename: () => Ra$1, default: () => Va, delimiter: () => On, dirname: () => Ma, extname: () => $a, isAbsolute: () => Xn$1, join: () => ja, normalize: () => zn$2, relative: () => qa, resolve: () => Br$1, sep: () => Ln$2 });
function Oa$1(e, r) {
  for (var t = 0, s = e.length - 1; s >= 0; s--) {
    var a = e[s];
    a === "." ? e.splice(s, 1) : a === ".." ? (e.splice(s, 1), t++) : t && (e.splice(s, 1), t--);
  }
  if (r)
    for (; t--; t)
      e.unshift("..");
  return e;
}
function Br$1() {
  for (var e = "", r = false, t = arguments.length - 1; t >= -1 && !r; t--) {
    var s = t >= 0 ? arguments[t] : "/";
    if (typeof s != "string")
      throw new TypeError("Arguments to path.resolve must be strings");
    if (!s)
      continue;
    e = s + "/" + e, r = s.charAt(0) === "/";
  }
  return e = Oa$1(Kn(e.split("/"), function(a) {
    return !!a;
  }), !r).join("/"), (r ? "/" : "") + e || ".";
}
function zn$2(e) {
  var r = Xn$1(e), t = Wa(e, -1) === "/";
  return e = Oa$1(Kn(e.split("/"), function(s) {
    return !!s;
  }), !r).join("/"), !e && !r && (e = "."), e && t && (e += "/"), (r ? "/" : "") + e;
}
function Xn$1(e) {
  return e.charAt(0) === "/";
}
function ja() {
  var e = Array.prototype.slice.call(arguments, 0);
  return zn$2(Kn(e, function(r, t) {
    if (typeof r != "string")
      throw new TypeError("Arguments to path.join must be strings");
    return r;
  }).join("/"));
}
function qa(e, r) {
  e = Br$1(e).substr(1), r = Br$1(r).substr(1);
  function t(p) {
    for (var d2 = 0; d2 < p.length && p[d2] === ""; d2++)
      ;
    for (var y2 = p.length - 1; y2 >= 0 && p[y2] === ""; y2--)
      ;
    return d2 > y2 ? [] : p.slice(d2, y2 - d2 + 1);
  }
  for (var s = t(e.split("/")), a = t(r.split("/")), n = Math.min(s.length, a.length), u = n, i = 0; i < n; i++)
    if (s[i] !== a[i]) {
      u = i;
      break;
    }
  for (var l = [], i = u; i < s.length; i++)
    l.push("..");
  return l = l.concat(a.slice(u)), l.join("/");
}
function Ma(e) {
  var r = _r$1(e), t = r[0], s = r[1];
  return !t && !s ? "." : (s && (s = s.substr(0, s.length - 1)), t + s);
}
function Ra$1(e, r) {
  var t = _r$1(e)[2];
  return r && t.substr(-1 * r.length) === r && (t = t.substr(0, t.length - r.length)), t;
}
function $a(e) {
  return _r$1(e)[3];
}
function Kn(e, r) {
  if (e.filter)
    return e.filter(r);
  for (var t = [], s = 0; s < e.length; s++)
    r(e[s], s, e) && t.push(e[s]);
  return t;
}
var Ea, _r$1, Ln$2, On, Va, Wa, WD$1 = ht$1({ "node-modules-polyfills:path"() {
  ne(), Ea = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, _r$1 = function(e) {
    return Ea.exec(e).slice(1);
  }, Ln$2 = "/", On = ":", Va = { extname: $a, basename: Ra$1, dirname: Ma, sep: Ln$2, delimiter: On, relative: qa, join: ja, isAbsolute: Xn$1, normalize: zn$2, resolve: Br$1 }, Wa = "ab".substr(-1) === "b" ? function(e, r, t) {
    return e.substr(r, t);
  } : function(e, r, t) {
    return r < 0 && (r = e.length + r), e.substr(r, t);
  };
} }), HD$1 = te$1({ "node-modules-polyfills-commonjs:path"(e, r) {
  ne();
  var t = (WD$1(), ft$2(La));
  if (t && t.default) {
    r.exports = t.default;
    for (let s in t)
      r.exports[s] = t[s];
  } else
    t && (r.exports = t);
} }), Kt$1 = te$1({ "src/common/errors.js"(e, r) {
  ne();
  var t = class extends Error {
  }, s = class extends Error {
  }, a = class extends Error {
  }, n = class extends Error {
  };
  r.exports = { ConfigError: t, DebugError: s, UndefinedParserError: a, ArgExpansionBailout: n };
} }), vt$1 = {};
zt$1(vt$1, { __assign: () => Tr$1, __asyncDelegator: () => nm, __asyncGenerator: () => rm, __asyncValues: () => um, __await: () => Jt$1, __awaiter: () => KD$1, __classPrivateFieldGet: () => om, __classPrivateFieldSet: () => lm, __createBinding: () => QD$1, __decorate: () => JD$1, __exportStar: () => ZD$1, __extends: () => GD$1, __generator: () => YD$1, __importDefault: () => am, __importStar: () => im, __makeTemplateObject: () => sm, __metadata: () => XD$1, __param: () => zD$1, __read: () => Ha, __rest: () => UD$1, __spread: () => em, __spreadArrays: () => tm, __values: () => jn });
function GD$1(e, r) {
  br$1(e, r);
  function t() {
    this.constructor = e;
  }
  e.prototype = r === null ? Object.create(r) : (t.prototype = r.prototype, new t());
}
function UD$1(e, r) {
  var t = {};
  for (var s in e)
    Object.prototype.hasOwnProperty.call(e, s) && r.indexOf(s) < 0 && (t[s] = e[s]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, s = Object.getOwnPropertySymbols(e); a < s.length; a++)
      r.indexOf(s[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[a]) && (t[s[a]] = e[s[a]]);
  return t;
}
function JD$1(e, r, t, s) {
  var a = arguments.length, n = a < 3 ? r : s === null ? s = Object.getOwnPropertyDescriptor(r, t) : s, u;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(e, r, t, s);
  else
    for (var i = e.length - 1; i >= 0; i--)
      (u = e[i]) && (n = (a < 3 ? u(n) : a > 3 ? u(r, t, n) : u(r, t)) || n);
  return a > 3 && n && Object.defineProperty(r, t, n), n;
}
function zD$1(e, r) {
  return function(t, s) {
    r(t, s, e);
  };
}
function XD$1(e, r) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(e, r);
}
function KD$1(e, r, t, s) {
  function a(n) {
    return n instanceof t ? n : new t(function(u) {
      u(n);
    });
  }
  return new (t || (t = Promise))(function(n, u) {
    function i(d2) {
      try {
        p(s.next(d2));
      } catch (y2) {
        u(y2);
      }
    }
    function l(d2) {
      try {
        p(s.throw(d2));
      } catch (y2) {
        u(y2);
      }
    }
    function p(d2) {
      d2.done ? n(d2.value) : a(d2.value).then(i, l);
    }
    p((s = s.apply(e, r || [])).next());
  });
}
function YD$1(e, r) {
  var t = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, s, a, n, u;
  return u = { next: i(0), throw: i(1), return: i(2) }, typeof Symbol == "function" && (u[Symbol.iterator] = function() {
    return this;
  }), u;
  function i(p) {
    return function(d2) {
      return l([p, d2]);
    };
  }
  function l(p) {
    if (s)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (s = 1, a && (n = p[0] & 2 ? a.return : p[0] ? a.throw || ((n = a.return) && n.call(a), 0) : a.next) && !(n = n.call(a, p[1])).done)
          return n;
        switch (a = 0, n && (p = [p[0] & 2, n.value]), p[0]) {
          case 0:
          case 1:
            n = p;
            break;
          case 4:
            return t.label++, { value: p[1], done: false };
          case 5:
            t.label++, a = p[1], p = [0];
            continue;
          case 7:
            p = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (p[0] === 6 || p[0] === 2)) {
              t = 0;
              continue;
            }
            if (p[0] === 3 && (!n || p[1] > n[0] && p[1] < n[3])) {
              t.label = p[1];
              break;
            }
            if (p[0] === 6 && t.label < n[1]) {
              t.label = n[1], n = p;
              break;
            }
            if (n && t.label < n[2]) {
              t.label = n[2], t.ops.push(p);
              break;
            }
            n[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        p = r.call(e, t);
      } catch (d2) {
        p = [6, d2], a = 0;
      } finally {
        s = n = 0;
      }
    if (p[0] & 5)
      throw p[1];
    return { value: p[0] ? p[1] : void 0, done: true };
  }
}
function QD$1(e, r, t, s) {
  s === void 0 && (s = t), e[s] = r[t];
}
function ZD$1(e, r) {
  for (var t in e)
    t !== "default" && !r.hasOwnProperty(t) && (r[t] = e[t]);
}
function jn(e) {
  var r = typeof Symbol == "function" && Symbol.iterator, t = r && e[r], s = 0;
  if (t)
    return t.call(e);
  if (e && typeof e.length == "number")
    return { next: function() {
      return e && s >= e.length && (e = void 0), { value: e && e[s++], done: !e };
    } };
  throw new TypeError(r ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Ha(e, r) {
  var t = typeof Symbol == "function" && e[Symbol.iterator];
  if (!t)
    return e;
  var s = t.call(e), a, n = [], u;
  try {
    for (; (r === void 0 || r-- > 0) && !(a = s.next()).done; )
      n.push(a.value);
  } catch (i) {
    u = { error: i };
  } finally {
    try {
      a && !a.done && (t = s.return) && t.call(s);
    } finally {
      if (u)
        throw u.error;
    }
  }
  return n;
}
function em() {
  for (var e = [], r = 0; r < arguments.length; r++)
    e = e.concat(Ha(arguments[r]));
  return e;
}
function tm() {
  for (var e = 0, r = 0, t = arguments.length; r < t; r++)
    e += arguments[r].length;
  for (var s = Array(e), a = 0, r = 0; r < t; r++)
    for (var n = arguments[r], u = 0, i = n.length; u < i; u++, a++)
      s[a] = n[u];
  return s;
}
function Jt$1(e) {
  return this instanceof Jt$1 ? (this.v = e, this) : new Jt$1(e);
}
function rm(e, r, t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var s = t.apply(e, r || []), a, n = [];
  return a = {}, u("next"), u("throw"), u("return"), a[Symbol.asyncIterator] = function() {
    return this;
  }, a;
  function u(g2) {
    s[g2] && (a[g2] = function(c) {
      return new Promise(function(f, E) {
        n.push([g2, c, f, E]) > 1 || i(g2, c);
      });
    });
  }
  function i(g2, c) {
    try {
      l(s[g2](c));
    } catch (f) {
      y2(n[0][3], f);
    }
  }
  function l(g2) {
    g2.value instanceof Jt$1 ? Promise.resolve(g2.value.v).then(p, d2) : y2(n[0][2], g2);
  }
  function p(g2) {
    i("next", g2);
  }
  function d2(g2) {
    i("throw", g2);
  }
  function y2(g2, c) {
    g2(c), n.shift(), n.length && i(n[0][0], n[0][1]);
  }
}
function nm(e) {
  var r, t;
  return r = {}, s("next"), s("throw", function(a) {
    throw a;
  }), s("return"), r[Symbol.iterator] = function() {
    return this;
  }, r;
  function s(a, n) {
    r[a] = e[a] ? function(u) {
      return (t = !t) ? { value: Jt$1(e[a](u)), done: a === "return" } : n ? n(u) : u;
    } : n;
  }
}
function um(e) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = e[Symbol.asyncIterator], t;
  return r ? r.call(e) : (e = typeof jn == "function" ? jn(e) : e[Symbol.iterator](), t = {}, s("next"), s("throw"), s("return"), t[Symbol.asyncIterator] = function() {
    return this;
  }, t);
  function s(n) {
    t[n] = e[n] && function(u) {
      return new Promise(function(i, l) {
        u = e[n](u), a(i, l, u.done, u.value);
      });
    };
  }
  function a(n, u, i, l) {
    Promise.resolve(l).then(function(p) {
      n({ value: p, done: i });
    }, u);
  }
}
function sm(e, r) {
  return Object.defineProperty ? Object.defineProperty(e, "raw", { value: r }) : e.raw = r, e;
}
function im(e) {
  if (e && e.__esModule)
    return e;
  var r = {};
  if (e != null)
    for (var t in e)
      Object.hasOwnProperty.call(e, t) && (r[t] = e[t]);
  return r.default = e, r;
}
function am(e) {
  return e && e.__esModule ? e : { default: e };
}
function om(e, r) {
  if (!r.has(e))
    throw new TypeError("attempted to get private field on non-instance");
  return r.get(e);
}
function lm(e, r, t) {
  if (!r.has(e))
    throw new TypeError("attempted to set private field on non-instance");
  return r.set(e, t), t;
}
var br$1, Tr$1, Et$1 = ht$1({ "node_modules/tslib/tslib.es6.js"() {
  ne(), br$1 = function(e, r) {
    return br$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, s) {
      t.__proto__ = s;
    } || function(t, s) {
      for (var a in s)
        s.hasOwnProperty(a) && (t[a] = s[a]);
    }, br$1(e, r);
  }, Tr$1 = function() {
    return Tr$1 = Object.assign || function(r) {
      for (var t, s = 1, a = arguments.length; s < a; s++) {
        t = arguments[s];
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]);
      }
      return r;
    }, Tr$1.apply(this, arguments);
  };
} }), Ga = te$1({ "node_modules/vnopts/lib/descriptors/api.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true }), e.apiDescriptor = { key: (r) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(r) ? r : JSON.stringify(r), value(r) {
    if (r === null || typeof r != "object")
      return JSON.stringify(r);
    if (Array.isArray(r))
      return `[${r.map((s) => e.apiDescriptor.value(s)).join(", ")}]`;
    let t = Object.keys(r);
    return t.length === 0 ? "{}" : `{ ${t.map((s) => `${e.apiDescriptor.key(s)}: ${e.apiDescriptor.value(r[s])}`).join(", ")} }`;
  }, pair: (r) => {
    let { key: t, value: s } = r;
    return e.apiDescriptor.value({ [t]: s });
  } };
} }), cm = te$1({ "node_modules/vnopts/lib/descriptors/index.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = (Et$1(), ft$2(vt$1));
  r.__exportStar(Ga(), e);
} }), Pr = te$1({ "scripts/build/shims/chalk.cjs"(e, r) {
  ne();
  var t = (s) => s;
  t.grey = t, t.red = t, t.bold = t, t.yellow = t, t.blue = t, t.default = t, r.exports = t;
} }), Ua$1 = te$1({ "node_modules/vnopts/lib/handlers/deprecated/common.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Pr();
  e.commonDeprecatedHandler = (t, s, a) => {
    let { descriptor: n } = a, u = [`${r.default.yellow(typeof t == "string" ? n.key(t) : n.pair(t))} is deprecated`];
    return s && u.push(`we now treat it as ${r.default.blue(typeof s == "string" ? n.key(s) : n.pair(s))}`), u.join("; ") + ".";
  };
} }), pm = te$1({ "node_modules/vnopts/lib/handlers/deprecated/index.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = (Et$1(), ft$2(vt$1));
  r.__exportStar(Ua$1(), e);
} }), fm = te$1({ "node_modules/vnopts/lib/handlers/invalid/common.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Pr();
  e.commonInvalidHandler = (t, s, a) => [`Invalid ${r.default.red(a.descriptor.key(t))} value.`, `Expected ${r.default.blue(a.schemas[t].expected(a))},`, `but received ${r.default.red(a.descriptor.value(s))}.`].join(" ");
} }), Ja = te$1({ "node_modules/vnopts/lib/handlers/invalid/index.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = (Et$1(), ft$2(vt$1));
  r.__exportStar(fm(), e);
} }), Dm = te$1({ "node_modules/vnopts/node_modules/leven/index.js"(e, r) {
  ne();
  var t = [], s = [];
  r.exports = function(a, n) {
    if (a === n)
      return 0;
    var u = a;
    a.length > n.length && (a = n, n = u);
    var i = a.length, l = n.length;
    if (i === 0)
      return l;
    if (l === 0)
      return i;
    for (; i > 0 && a.charCodeAt(~-i) === n.charCodeAt(~-l); )
      i--, l--;
    if (i === 0)
      return l;
    for (var p = 0; p < i && a.charCodeAt(p) === n.charCodeAt(p); )
      p++;
    if (i -= p, l -= p, i === 0)
      return l;
    for (var d2, y2, g2, c, f = 0, E = 0; f < i; )
      s[p + f] = a.charCodeAt(p + f), t[f] = ++f;
    for (; E < l; )
      for (d2 = n.charCodeAt(p + E), g2 = E++, y2 = E, f = 0; f < i; f++)
        c = d2 === s[p + f] ? g2 : g2 + 1, g2 = t[f], y2 = t[f] = g2 > y2 ? c > y2 ? y2 + 1 : c : c > g2 ? g2 + 1 : c;
    return y2;
  };
} }), za = te$1({ "node_modules/vnopts/lib/handlers/unknown/leven.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Pr(), t = Dm();
  e.levenUnknownHandler = (s, a, n) => {
    let { descriptor: u, logger: i, schemas: l } = n, p = [`Ignored unknown option ${r.default.yellow(u.pair({ key: s, value: a }))}.`], d2 = Object.keys(l).sort().find((y2) => t(s, y2) < 3);
    d2 && p.push(`Did you mean ${r.default.blue(u.key(d2))}?`), i.warn(p.join(" "));
  };
} }), mm = te$1({ "node_modules/vnopts/lib/handlers/unknown/index.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = (Et$1(), ft$2(vt$1));
  r.__exportStar(za(), e);
} }), dm = te$1({ "node_modules/vnopts/lib/handlers/index.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = (Et$1(), ft$2(vt$1));
  r.__exportStar(pm(), e), r.__exportStar(Ja(), e), r.__exportStar(mm(), e);
} }), Ft$1 = te$1({ "node_modules/vnopts/lib/schema.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
  function t(n, u) {
    let i = new n(u), l = Object.create(i);
    for (let p of r)
      p in u && (l[p] = a(u[p], i, s.prototype[p].length));
    return l;
  }
  e.createSchema = t;
  var s = class {
    constructor(n) {
      this.name = n.name;
    }
    static create(n) {
      return t(this, n);
    }
    default(n) {
    }
    expected(n) {
      return "nothing";
    }
    validate(n, u) {
      return false;
    }
    deprecated(n, u) {
      return false;
    }
    forward(n, u) {
    }
    redirect(n, u) {
    }
    overlap(n, u, i) {
      return n;
    }
    preprocess(n, u) {
      return n;
    }
    postprocess(n, u) {
      return n;
    }
  };
  e.Schema = s;
  function a(n, u, i) {
    return typeof n == "function" ? function() {
      for (var l = arguments.length, p = new Array(l), d2 = 0; d2 < l; d2++)
        p[d2] = arguments[d2];
      return n(...p.slice(0, i - 1), u, ...p.slice(i - 1));
    } : () => n;
  }
} }), gm = te$1({ "node_modules/vnopts/lib/schemas/alias.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Ft$1(), t = class extends r.Schema {
    constructor(s) {
      super(s), this._sourceName = s.sourceName;
    }
    expected(s) {
      return s.schemas[this._sourceName].expected(s);
    }
    validate(s, a) {
      return a.schemas[this._sourceName].validate(s, a);
    }
    redirect(s, a) {
      return this._sourceName;
    }
  };
  e.AliasSchema = t;
} }), ym = te$1({ "node_modules/vnopts/lib/schemas/any.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Ft$1(), t = class extends r.Schema {
    expected() {
      return "anything";
    }
    validate() {
      return true;
    }
  };
  e.AnySchema = t;
} }), hm = te$1({ "node_modules/vnopts/lib/schemas/array.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = (Et$1(), ft$2(vt$1)), t = Ft$1(), s = class extends t.Schema {
    constructor(n) {
      var { valueSchema: u, name: i = u.name } = n, l = r.__rest(n, ["valueSchema", "name"]);
      super(Object.assign({}, l, { name: i })), this._valueSchema = u;
    }
    expected(n) {
      return `an array of ${this._valueSchema.expected(n)}`;
    }
    validate(n, u) {
      if (!Array.isArray(n))
        return false;
      let i = [];
      for (let l of n) {
        let p = u.normalizeValidateResult(this._valueSchema.validate(l, u), l);
        p !== true && i.push(p.value);
      }
      return i.length === 0 ? true : { value: i };
    }
    deprecated(n, u) {
      let i = [];
      for (let l of n) {
        let p = u.normalizeDeprecatedResult(this._valueSchema.deprecated(l, u), l);
        p !== false && i.push(...p.map((d2) => {
          let { value: y2 } = d2;
          return { value: [y2] };
        }));
      }
      return i;
    }
    forward(n, u) {
      let i = [];
      for (let l of n) {
        let p = u.normalizeForwardResult(this._valueSchema.forward(l, u), l);
        i.push(...p.map(a));
      }
      return i;
    }
    redirect(n, u) {
      let i = [], l = [];
      for (let p of n) {
        let d2 = u.normalizeRedirectResult(this._valueSchema.redirect(p, u), p);
        "remain" in d2 && i.push(d2.remain), l.push(...d2.redirect.map(a));
      }
      return i.length === 0 ? { redirect: l } : { redirect: l, remain: i };
    }
    overlap(n, u) {
      return n.concat(u);
    }
  };
  e.ArraySchema = s;
  function a(n) {
    let { from: u, to: i } = n;
    return { from: [u], to: i };
  }
} }), vm = te$1({ "node_modules/vnopts/lib/schemas/boolean.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Ft$1(), t = class extends r.Schema {
    expected() {
      return "true or false";
    }
    validate(s) {
      return typeof s == "boolean";
    }
  };
  e.BooleanSchema = t;
} }), Yn = te$1({ "node_modules/vnopts/lib/utils.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  function r(c, f) {
    let E = /* @__PURE__ */ Object.create(null);
    for (let _ of c) {
      let w = _[f];
      if (E[w])
        throw new Error(`Duplicate ${f} ${JSON.stringify(w)}`);
      E[w] = _;
    }
    return E;
  }
  e.recordFromArray = r;
  function t(c, f) {
    let E = /* @__PURE__ */ new Map();
    for (let _ of c) {
      let w = _[f];
      if (E.has(w))
        throw new Error(`Duplicate ${f} ${JSON.stringify(w)}`);
      E.set(w, _);
    }
    return E;
  }
  e.mapFromArray = t;
  function s() {
    let c = /* @__PURE__ */ Object.create(null);
    return (f) => {
      let E = JSON.stringify(f);
      return c[E] ? true : (c[E] = true, false);
    };
  }
  e.createAutoChecklist = s;
  function a(c, f) {
    let E = [], _ = [];
    for (let w of c)
      f(w) ? E.push(w) : _.push(w);
    return [E, _];
  }
  e.partition = a;
  function n(c) {
    return c === Math.floor(c);
  }
  e.isInt = n;
  function u(c, f) {
    if (c === f)
      return 0;
    let E = typeof c, _ = typeof f, w = ["undefined", "object", "boolean", "number", "string"];
    return E !== _ ? w.indexOf(E) - w.indexOf(_) : E !== "string" ? Number(c) - Number(f) : c.localeCompare(f);
  }
  e.comparePrimitive = u;
  function i(c) {
    return c === void 0 ? {} : c;
  }
  e.normalizeDefaultResult = i;
  function l(c, f) {
    return c === true ? true : c === false ? { value: f } : c;
  }
  e.normalizeValidateResult = l;
  function p(c, f) {
    let E = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    return c === false ? false : c === true ? E ? true : [{ value: f }] : "value" in c ? [c] : c.length === 0 ? false : c;
  }
  e.normalizeDeprecatedResult = p;
  function d2(c, f) {
    return typeof c == "string" || "key" in c ? { from: f, to: c } : "from" in c ? { from: c.from, to: c.to } : { from: f, to: c.to };
  }
  e.normalizeTransferResult = d2;
  function y2(c, f) {
    return c === void 0 ? [] : Array.isArray(c) ? c.map((E) => d2(E, f)) : [d2(c, f)];
  }
  e.normalizeForwardResult = y2;
  function g2(c, f) {
    let E = y2(typeof c == "object" && "redirect" in c ? c.redirect : c, f);
    return E.length === 0 ? { remain: f, redirect: E } : typeof c == "object" && "remain" in c ? { remain: c.remain, redirect: E } : { redirect: E };
  }
  e.normalizeRedirectResult = g2;
} }), Cm = te$1({ "node_modules/vnopts/lib/schemas/choice.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Ft$1(), t = Yn(), s = class extends r.Schema {
    constructor(a) {
      super(a), this._choices = t.mapFromArray(a.choices.map((n) => n && typeof n == "object" ? n : { value: n }), "value");
    }
    expected(a) {
      let { descriptor: n } = a, u = Array.from(this._choices.keys()).map((p) => this._choices.get(p)).filter((p) => !p.deprecated).map((p) => p.value).sort(t.comparePrimitive).map(n.value), i = u.slice(0, -2), l = u.slice(-2);
      return i.concat(l.join(" or ")).join(", ");
    }
    validate(a) {
      return this._choices.has(a);
    }
    deprecated(a) {
      let n = this._choices.get(a);
      return n && n.deprecated ? { value: a } : false;
    }
    forward(a) {
      let n = this._choices.get(a);
      return n ? n.forward : void 0;
    }
    redirect(a) {
      let n = this._choices.get(a);
      return n ? n.redirect : void 0;
    }
  };
  e.ChoiceSchema = s;
} }), Xa$1 = te$1({ "node_modules/vnopts/lib/schemas/number.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Ft$1(), t = class extends r.Schema {
    expected() {
      return "a number";
    }
    validate(s, a) {
      return typeof s == "number";
    }
  };
  e.NumberSchema = t;
} }), Em = te$1({ "node_modules/vnopts/lib/schemas/integer.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Yn(), t = Xa$1(), s = class extends t.NumberSchema {
    expected() {
      return "an integer";
    }
    validate(a, n) {
      return n.normalizeValidateResult(super.validate(a, n), a) === true && r.isInt(a);
    }
  };
  e.IntegerSchema = s;
} }), Fm = te$1({ "node_modules/vnopts/lib/schemas/string.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Ft$1(), t = class extends r.Schema {
    expected() {
      return "a string";
    }
    validate(s) {
      return typeof s == "string";
    }
  };
  e.StringSchema = t;
} }), Am = te$1({ "node_modules/vnopts/lib/schemas/index.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = (Et$1(), ft$2(vt$1));
  r.__exportStar(gm(), e), r.__exportStar(ym(), e), r.__exportStar(hm(), e), r.__exportStar(vm(), e), r.__exportStar(Cm(), e), r.__exportStar(Em(), e), r.__exportStar(Xa$1(), e), r.__exportStar(Fm(), e);
} }), Sm = te$1({ "node_modules/vnopts/lib/defaults.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Ga(), t = Ua$1(), s = Ja(), a = za();
  e.defaultDescriptor = r.apiDescriptor, e.defaultUnknownHandler = a.levenUnknownHandler, e.defaultInvalidHandler = s.commonInvalidHandler, e.defaultDeprecatedHandler = t.commonDeprecatedHandler;
} }), xm = te$1({ "node_modules/vnopts/lib/normalize.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Sm(), t = Yn();
  e.normalize = (a, n, u) => new s(n, u).normalize(a);
  var s = class {
    constructor(a, n) {
      let { logger: u = console, descriptor: i = r.defaultDescriptor, unknown: l = r.defaultUnknownHandler, invalid: p = r.defaultInvalidHandler, deprecated: d2 = r.defaultDeprecatedHandler } = n || {};
      this._utils = { descriptor: i, logger: u || { warn: () => {
      } }, schemas: t.recordFromArray(a, "name"), normalizeDefaultResult: t.normalizeDefaultResult, normalizeDeprecatedResult: t.normalizeDeprecatedResult, normalizeForwardResult: t.normalizeForwardResult, normalizeRedirectResult: t.normalizeRedirectResult, normalizeValidateResult: t.normalizeValidateResult }, this._unknownHandler = l, this._invalidHandler = p, this._deprecatedHandler = d2, this.cleanHistory();
    }
    cleanHistory() {
      this._hasDeprecationWarned = t.createAutoChecklist();
    }
    normalize(a) {
      let n = {}, u = [a], i = () => {
        for (; u.length !== 0; ) {
          let l = u.shift(), p = this._applyNormalization(l, n);
          u.push(...p);
        }
      };
      i();
      for (let l of Object.keys(this._utils.schemas)) {
        let p = this._utils.schemas[l];
        if (!(l in n)) {
          let d2 = t.normalizeDefaultResult(p.default(this._utils));
          "value" in d2 && u.push({ [l]: d2.value });
        }
      }
      i();
      for (let l of Object.keys(this._utils.schemas)) {
        let p = this._utils.schemas[l];
        l in n && (n[l] = p.postprocess(n[l], this._utils));
      }
      return n;
    }
    _applyNormalization(a, n) {
      let u = [], [i, l] = t.partition(Object.keys(a), (p) => p in this._utils.schemas);
      for (let p of i) {
        let d2 = this._utils.schemas[p], y2 = d2.preprocess(a[p], this._utils), g2 = t.normalizeValidateResult(d2.validate(y2, this._utils), y2);
        if (g2 !== true) {
          let { value: w } = g2, F = this._invalidHandler(p, w, this._utils);
          throw typeof F == "string" ? new Error(F) : F;
        }
        let c = (w) => {
          let { from: F, to: N2 } = w;
          u.push(typeof N2 == "string" ? { [N2]: F } : { [N2.key]: N2.value });
        }, f = (w) => {
          let { value: F, redirectTo: N2 } = w, x = t.normalizeDeprecatedResult(d2.deprecated(F, this._utils), y2, true);
          if (x !== false)
            if (x === true)
              this._hasDeprecationWarned(p) || this._utils.logger.warn(this._deprecatedHandler(p, N2, this._utils));
            else
              for (let { value: I2 } of x) {
                let P = { key: p, value: I2 };
                if (!this._hasDeprecationWarned(P)) {
                  let $2 = typeof N2 == "string" ? { key: N2, value: I2 } : N2;
                  this._utils.logger.warn(this._deprecatedHandler(P, $2, this._utils));
                }
              }
        };
        t.normalizeForwardResult(d2.forward(y2, this._utils), y2).forEach(c);
        let _ = t.normalizeRedirectResult(d2.redirect(y2, this._utils), y2);
        if (_.redirect.forEach(c), "remain" in _) {
          let w = _.remain;
          n[p] = p in n ? d2.overlap(n[p], w, this._utils) : w, f({ value: w });
        }
        for (let { from: w, to: F } of _.redirect)
          f({ value: w, redirectTo: F });
      }
      for (let p of l) {
        let d2 = a[p], y2 = this._unknownHandler(p, d2, this._utils);
        if (y2)
          for (let g2 of Object.keys(y2)) {
            let c = { [g2]: y2[g2] };
            g2 in this._utils.schemas ? u.push(c) : Object.assign(n, c);
          }
      }
      return u;
    }
  };
  e.Normalizer = s;
} }), bm = te$1({ "node_modules/vnopts/lib/index.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = (Et$1(), ft$2(vt$1));
  r.__exportStar(cm(), e), r.__exportStar(dm(), e), r.__exportStar(Am(), e), r.__exportStar(xm(), e), r.__exportStar(Ft$1(), e);
} }), Tm$1 = te$1({ "src/main/options-normalizer.js"(e, r) {
  ne();
  var t = bm(), s = lt$1(), a = { key: (g2) => g2.length === 1 ? `-${g2}` : `--${g2}`, value: (g2) => t.apiDescriptor.value(g2), pair: (g2) => {
    let { key: c, value: f } = g2;
    return f === false ? `--no-${c}` : f === true ? a.key(c) : f === "" ? `${a.key(c)} without an argument` : `${a.key(c)}=${f}`;
  } }, n = (g2) => {
    let { colorsModule: c, levenshteinDistance: f } = g2;
    return class extends t.ChoiceSchema {
      constructor(_) {
        let { name: w, flags: F } = _;
        super({ name: w, choices: F }), this._flags = [...F].sort();
      }
      preprocess(_, w) {
        if (typeof _ == "string" && _.length > 0 && !this._flags.includes(_)) {
          let F = this._flags.find((N2) => f(N2, _) < 3);
          if (F)
            return w.logger.warn([`Unknown flag ${c.yellow(w.descriptor.value(_))},`, `did you mean ${c.blue(w.descriptor.value(F))}?`].join(" ")), F;
        }
        return _;
      }
      expected() {
        return "a flag";
      }
    };
  }, u;
  function i(g2, c) {
    let { logger: f = false, isCLI: E = false, passThrough: _ = false, colorsModule: w = null, levenshteinDistance: F = null } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, N2 = _ ? Array.isArray(_) ? (T, m) => _.includes(T) ? { [T]: m } : void 0 : (T, m) => ({ [T]: m }) : (T, m, C) => {
      let o = C.schemas, v2 = $n(o, cD);
      return t.levenUnknownHandler(T, m, Object.assign(Object.assign({}, C), {}, { schemas: v2 }));
    }, x = E ? a : t.apiDescriptor, I2 = l(c, { isCLI: E, colorsModule: w, levenshteinDistance: F }), P = new t.Normalizer(I2, { logger: f, unknown: N2, descriptor: x }), $2 = f !== false;
    $2 && u && (P._hasDeprecationWarned = u);
    let D = P.normalize(g2);
    return $2 && (u = P._hasDeprecationWarned), E && D["plugin-search"] === false && (D["plugin-search-dir"] = false), D;
  }
  function l(g2, c) {
    let { isCLI: f, colorsModule: E, levenshteinDistance: _ } = c, w = [];
    f && w.push(t.AnySchema.create({ name: "_" }));
    for (let F of g2)
      w.push(p(F, { isCLI: f, optionInfos: g2, colorsModule: E, levenshteinDistance: _ })), F.alias && f && w.push(t.AliasSchema.create({ name: F.alias, sourceName: F.name }));
    return w;
  }
  function p(g2, c) {
    let { isCLI: f, optionInfos: E, colorsModule: _, levenshteinDistance: w } = c, { name: F } = g2;
    if (F === "plugin-search-dir" || F === "pluginSearchDirs")
      return t.AnySchema.create({ name: F, preprocess(P) {
        return P === false || (P = Array.isArray(P) ? P : [P]), P;
      }, validate(P) {
        return P === false ? true : P.every(($2) => typeof $2 == "string");
      }, expected() {
        return "false or paths to plugin search dir";
      } });
    let N2 = { name: F }, x, I2 = {};
    switch (g2.type) {
      case "int":
        x = t.IntegerSchema, f && (N2.preprocess = Number);
        break;
      case "string":
        x = t.StringSchema;
        break;
      case "choice":
        x = t.ChoiceSchema, N2.choices = g2.choices.map((P) => typeof P == "object" && P.redirect ? Object.assign(Object.assign({}, P), {}, { redirect: { to: { key: g2.name, value: P.redirect } } }) : P);
        break;
      case "boolean":
        x = t.BooleanSchema;
        break;
      case "flag":
        x = n({ colorsModule: _, levenshteinDistance: w }), N2.flags = E.flatMap((P) => [P.alias, P.description && P.name, P.oppositeDescription && `no-${P.name}`].filter(Boolean));
        break;
      case "path":
        x = t.StringSchema;
        break;
      default:
        throw new Error(`Unexpected type ${g2.type}`);
    }
    if (g2.exception ? N2.validate = (P, $2, D) => g2.exception(P) || $2.validate(P, D) : N2.validate = (P, $2, D) => P === void 0 || $2.validate(P, D), g2.redirect && (I2.redirect = (P) => P ? { to: { key: g2.redirect.option, value: g2.redirect.value } } : void 0), g2.deprecated && (I2.deprecated = true), f && !g2.array) {
      let P = N2.preprocess || (($2) => $2);
      N2.preprocess = ($2, D, T) => D.preprocess(P(Array.isArray($2) ? s($2) : $2), T);
    }
    return g2.array ? t.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, f ? { preprocess: (P) => Array.isArray(P) ? P : [P] } : {}), I2), {}, { valueSchema: x.create(N2) })) : x.create(Object.assign(Object.assign({}, N2), I2));
  }
  function d2(g2, c, f) {
    return i(g2, c, f);
  }
  function y2(g2, c, f) {
    return i(g2, c, Object.assign({ isCLI: true }, f));
  }
  r.exports = { normalizeApiOptions: d2, normalizeCliOptions: y2 };
} }), ut$1 = te$1({ "src/language-js/loc.js"(e, r) {
  ne();
  var t = Jn$1();
  function s(l) {
    var p, d2;
    let y2 = l.range ? l.range[0] : l.start, g2 = (p = (d2 = l.declaration) === null || d2 === void 0 ? void 0 : d2.decorators) !== null && p !== void 0 ? p : l.decorators;
    return t(g2) ? Math.min(s(g2[0]), y2) : y2;
  }
  function a(l) {
    return l.range ? l.range[1] : l.end;
  }
  function n(l, p) {
    let d2 = s(l);
    return Number.isInteger(d2) && d2 === s(p);
  }
  function u(l, p) {
    let d2 = a(l);
    return Number.isInteger(d2) && d2 === a(p);
  }
  function i(l, p) {
    return n(l, p) && u(l, p);
  }
  r.exports = { locStart: s, locEnd: a, hasSameLocStart: n, hasSameLoc: i };
} }), Bm = te$1({ "src/main/load-parser.js"(e, r) {
  ne(), r.exports = () => {
  };
} }), Nm = te$1({ "scripts/build/shims/babel-highlight.cjs"(e, r) {
  ne();
  var t = Pr(), s = { shouldHighlight: () => false, getChalk: () => t };
  r.exports = s;
} }), wm = te$1({ "node_modules/@babel/code-frame/lib/index.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true }), e.codeFrameColumns = u, e.default = i;
  var r = Nm(), t = false;
  function s(l) {
    return { gutter: l.grey, marker: l.red.bold, message: l.red.bold };
  }
  var a = /\r\n|[\n\r\u2028\u2029]/;
  function n(l, p, d2) {
    let y2 = Object.assign({ column: 0, line: -1 }, l.start), g2 = Object.assign({}, y2, l.end), { linesAbove: c = 2, linesBelow: f = 3 } = d2 || {}, E = y2.line, _ = y2.column, w = g2.line, F = g2.column, N2 = Math.max(E - (c + 1), 0), x = Math.min(p.length, w + f);
    E === -1 && (N2 = 0), w === -1 && (x = p.length);
    let I2 = w - E, P = {};
    if (I2)
      for (let $2 = 0; $2 <= I2; $2++) {
        let D = $2 + E;
        if (!_)
          P[D] = true;
        else if ($2 === 0) {
          let T = p[D - 1].length;
          P[D] = [_, T - _ + 1];
        } else if ($2 === I2)
          P[D] = [0, F];
        else {
          let T = p[D - $2].length;
          P[D] = [0, T];
        }
      }
    else
      _ === F ? _ ? P[E] = [_, 0] : P[E] = true : P[E] = [_, F - _];
    return { start: N2, end: x, markerLines: P };
  }
  function u(l, p) {
    let d2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, y2 = (d2.highlightCode || d2.forceColor) && (0, r.shouldHighlight)(d2), g2 = (0, r.getChalk)(d2), c = s(g2), f = ($2, D) => y2 ? $2(D) : D, E = l.split(a), { start: _, end: w, markerLines: F } = n(p, E, d2), N2 = p.start && typeof p.start.column == "number", x = String(w).length, P = (y2 ? (0, r.default)(l, d2) : l).split(a, w).slice(_, w).map(($2, D) => {
      let T = _ + 1 + D, C = ` ${` ${T}`.slice(-x)} |`, o = F[T], h = !F[T + 1];
      if (o) {
        let v2 = "";
        if (Array.isArray(o)) {
          let S = $2.slice(0, Math.max(o[0] - 1, 0)).replace(/[^\t]/g, " "), b = o[1] || 1;
          v2 = [`
 `, f(c.gutter, C.replace(/\d/g, " ")), " ", S, f(c.marker, "^").repeat(b)].join(""), h && d2.message && (v2 += " " + f(c.message, d2.message));
        }
        return [f(c.marker, ">"), f(c.gutter, C), $2.length > 0 ? ` ${$2}` : "", v2].join("");
      } else
        return ` ${f(c.gutter, C)}${$2.length > 0 ? ` ${$2}` : ""}`;
    }).join(`
`);
    return d2.message && !N2 && (P = `${" ".repeat(x + 1)}${d2.message}
${P}`), y2 ? g2.reset(P) : P;
  }
  function i(l, p, d2) {
    let y2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (!t) {
      t = true;
      let c = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (Nt$1.emitWarning)
        Nt$1.emitWarning(c, "DeprecationWarning");
      else {
        let f = new Error(c);
        f.name = "DeprecationWarning", console.warn(new Error(c));
      }
    }
    return d2 = Math.max(d2, 0), u(l, { start: { column: d2, line: p } }, y2);
  }
} }), Qn$1 = te$1({ "src/main/parser.js"(e, r) {
  ne();
  var { ConfigError: t } = Kt$1(), s = ut$1();
  Bm();
  var { locStart: n, locEnd: u } = s, i = Object.getOwnPropertyNames, l = Object.getOwnPropertyDescriptor;
  function p(g2) {
    let c = {};
    for (let f of g2.plugins)
      if (f.parsers)
        for (let E of i(f.parsers))
          Object.defineProperty(c, E, l(f.parsers, E));
    return c;
  }
  function d2(g2) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : p(g2);
    if (typeof g2.parser == "function")
      return { parse: g2.parser, astFormat: "estree", locStart: n, locEnd: u };
    if (typeof g2.parser == "string") {
      if (Object.prototype.hasOwnProperty.call(c, g2.parser))
        return c[g2.parser];
      throw new t(`Couldn't resolve parser "${g2.parser}". Parsers must be explicitly added to the standalone bundle.`);
    }
  }
  function y2(g2, c) {
    let f = p(c), E = Object.defineProperties({}, Object.fromEntries(Object.keys(f).map((w) => [w, { enumerable: true, get() {
      return f[w].parse;
    } }]))), _ = d2(c, f);
    try {
      return _.preprocess && (g2 = _.preprocess(g2, c)), { text: g2, ast: _.parse(g2, E, c) };
    } catch (w) {
      let { loc: F } = w;
      if (F) {
        let { codeFrameColumns: N2 } = wm();
        throw w.codeFrame = N2(g2, F, { highlightCode: true }), w.message += `
` + w.codeFrame, w;
      }
      throw w;
    }
  }
  r.exports = { parse: y2, resolveParser: d2 };
} }), Ka$1 = te$1({ "src/main/options.js"(e, r) {
  ne();
  var t = HD$1(), { UndefinedParserError: s } = Kt$1(), { getSupportInfo: a } = Un$1(), n = Tm$1(), { resolveParser: u } = Qn$1(), i = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
  function l(y2) {
    let g2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, c = Object.assign({}, y2), f = a({ plugins: y2.plugins, showUnreleased: true, showDeprecated: true }).options, E = Object.assign(Object.assign({}, i), Object.fromEntries(f.filter((x) => x.default !== void 0).map((x) => [x.name, x.default])));
    if (!c.parser) {
      if (!c.filepath)
        (g2.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), c.parser = "babel";
      else if (c.parser = d2(c.filepath, c.plugins), !c.parser)
        throw new s(`No parser could be inferred for file: ${c.filepath}`);
    }
    let _ = u(n.normalizeApiOptions(c, [f.find((x) => x.name === "parser")], { passThrough: true, logger: false }));
    c.astFormat = _.astFormat, c.locEnd = _.locEnd, c.locStart = _.locStart;
    let w = p(c);
    c.printer = w.printers[c.astFormat];
    let F = Object.fromEntries(f.filter((x) => x.pluginDefaults && x.pluginDefaults[w.name] !== void 0).map((x) => [x.name, x.pluginDefaults[w.name]])), N2 = Object.assign(Object.assign({}, E), F);
    for (let [x, I2] of Object.entries(N2))
      (c[x] === null || c[x] === void 0) && (c[x] = I2);
    return c.parser === "json" && (c.trailingComma = "none"), n.normalizeApiOptions(c, f, Object.assign({ passThrough: Object.keys(i) }, g2));
  }
  function p(y2) {
    let { astFormat: g2 } = y2;
    if (!g2)
      throw new Error("getPlugin() requires astFormat to be set");
    let c = y2.plugins.find((f) => f.printers && f.printers[g2]);
    if (!c)
      throw new Error(`Couldn't find plugin for AST format "${g2}"`);
    return c;
  }
  function d2(y2, g2) {
    let c = t.basename(y2).toLowerCase(), E = a({ plugins: g2 }).languages.filter((_) => _.since !== null).find((_) => _.extensions && _.extensions.some((w) => c.endsWith(w)) || _.filenames && _.filenames.some((w) => w.toLowerCase() === c));
    return E && E.parsers[0];
  }
  r.exports = { normalize: l, hiddenDefaults: i, inferParser: d2 };
} }), _m = te$1({ "src/main/massage-ast.js"(e, r) {
  ne();
  function t(s, a, n) {
    if (Array.isArray(s))
      return s.map((p) => t(p, a, n)).filter(Boolean);
    if (!s || typeof s != "object")
      return s;
    let u = a.printer.massageAstNode, i;
    u && u.ignoredProperties ? i = u.ignoredProperties : i = /* @__PURE__ */ new Set();
    let l = {};
    for (let [p, d2] of Object.entries(s))
      !i.has(p) && typeof d2 != "function" && (l[p] = t(d2, a, s));
    if (u) {
      let p = u(s, l, n);
      if (p === null)
        return;
      if (p)
        return p;
    }
    return l;
  }
  r.exports = t;
} }), Yt$1 = te$1({ "scripts/build/shims/assert.cjs"(e, r) {
  ne();
  var t = () => {
  };
  t.ok = t, t.strictEqual = t, r.exports = t;
} }), et = te$1({ "src/main/comments.js"(e, r) {
  ne();
  var t = Yt$1(), { builders: { line: s, hardline: a, breakParent: n, indent: u, lineSuffix: i, join: l, cursor: p } } = qe(), { hasNewline: d2, skipNewline: y2, skipSpaces: g2, isPreviousLineEmpty: c, addLeadingComment: f, addDanglingComment: E, addTrailingComment: _ } = Ue$2(), w = /* @__PURE__ */ new WeakMap();
  function F(k, M2, R2) {
    if (!k)
      return;
    let { printer: q, locStart: J, locEnd: L } = M2;
    if (R2) {
      if (q.canAttachComment && q.canAttachComment(k)) {
        let V;
        for (V = R2.length - 1; V >= 0 && !(J(R2[V]) <= J(k) && L(R2[V]) <= L(k)); --V)
          ;
        R2.splice(V + 1, 0, k);
        return;
      }
    } else if (w.has(k))
      return w.get(k);
    let Q = q.getCommentChildNodes && q.getCommentChildNodes(k, M2) || typeof k == "object" && Object.entries(k).filter((V) => {
      let [j] = V;
      return j !== "enclosingNode" && j !== "precedingNode" && j !== "followingNode" && j !== "tokens" && j !== "comments" && j !== "parent";
    }).map((V) => {
      let [, j] = V;
      return j;
    });
    if (Q) {
      R2 || (R2 = [], w.set(k, R2));
      for (let V of Q)
        F(V, M2, R2);
      return R2;
    }
  }
  function N2(k, M2, R2, q) {
    let { locStart: J, locEnd: L } = R2, Q = J(M2), V = L(M2), j = F(k, R2), Y, ie2, ee2 = 0, ce2 = j.length;
    for (; ee2 < ce2; ) {
      let W = ee2 + ce2 >> 1, K2 = j[W], de = J(K2), ue2 = L(K2);
      if (de <= Q && V <= ue2)
        return N2(K2, M2, R2, K2);
      if (ue2 <= Q) {
        Y = K2, ee2 = W + 1;
        continue;
      }
      if (V <= de) {
        ie2 = K2, ce2 = W;
        continue;
      }
      throw new Error("Comment location overlaps with node location");
    }
    if (q && q.type === "TemplateLiteral") {
      let { quasis: W } = q, K2 = C(W, M2, R2);
      Y && C(W, Y, R2) !== K2 && (Y = null), ie2 && C(W, ie2, R2) !== K2 && (ie2 = null);
    }
    return { enclosingNode: q, precedingNode: Y, followingNode: ie2 };
  }
  var x = () => false;
  function I2(k, M2, R2, q) {
    if (!Array.isArray(k))
      return;
    let J = [], { locStart: L, locEnd: Q, printer: { handleComments: V = {} } } = q, { avoidAstMutation: j, ownLine: Y = x, endOfLine: ie2 = x, remaining: ee2 = x } = V, ce2 = k.map((W, K2) => Object.assign(Object.assign({}, N2(M2, W, q)), {}, { comment: W, text: R2, options: q, ast: M2, isLastComment: k.length - 1 === K2 }));
    for (let [W, K2] of ce2.entries()) {
      let { comment: de, precedingNode: ue2, enclosingNode: Fe2, followingNode: z, text: U2, options: Z, ast: se2, isLastComment: fe2 } = K2;
      if (Z.parser === "json" || Z.parser === "json5" || Z.parser === "__js_expression" || Z.parser === "__vue_expression" || Z.parser === "__vue_ts_expression") {
        if (L(de) - L(se2) <= 0) {
          f(se2, de);
          continue;
        }
        if (Q(de) - Q(se2) >= 0) {
          _(se2, de);
          continue;
        }
      }
      let ge2;
      if (j ? ge2 = [K2] : (de.enclosingNode = Fe2, de.precedingNode = ue2, de.followingNode = z, ge2 = [de, U2, Z, se2, fe2]), $2(U2, Z, ce2, W))
        de.placement = "ownLine", Y(...ge2) || (z ? f(z, de) : ue2 ? _(ue2, de) : E(Fe2 || se2, de));
      else if (D(U2, Z, ce2, W))
        de.placement = "endOfLine", ie2(...ge2) || (ue2 ? _(ue2, de) : z ? f(z, de) : E(Fe2 || se2, de));
      else if (de.placement = "remaining", !ee2(...ge2))
        if (ue2 && z) {
          let he2 = J.length;
          he2 > 0 && J[he2 - 1].followingNode !== z && T(J, U2, Z), J.push(K2);
        } else
          ue2 ? _(ue2, de) : z ? f(z, de) : E(Fe2 || se2, de);
    }
    if (T(J, R2, q), !j)
      for (let W of k)
        delete W.precedingNode, delete W.enclosingNode, delete W.followingNode;
  }
  var P = (k) => !/[\S\n\u2028\u2029]/.test(k);
  function $2(k, M2, R2, q) {
    let { comment: J, precedingNode: L } = R2[q], { locStart: Q, locEnd: V } = M2, j = Q(J);
    if (L)
      for (let Y = q - 1; Y >= 0; Y--) {
        let { comment: ie2, precedingNode: ee2 } = R2[Y];
        if (ee2 !== L || !P(k.slice(V(ie2), j)))
          break;
        j = Q(ie2);
      }
    return d2(k, j, { backwards: true });
  }
  function D(k, M2, R2, q) {
    let { comment: J, followingNode: L } = R2[q], { locStart: Q, locEnd: V } = M2, j = V(J);
    if (L)
      for (let Y = q + 1; Y < R2.length; Y++) {
        let { comment: ie2, followingNode: ee2 } = R2[Y];
        if (ee2 !== L || !P(k.slice(j, Q(ie2))))
          break;
        j = V(ie2);
      }
    return d2(k, j);
  }
  function T(k, M2, R2) {
    let q = k.length;
    if (q === 0)
      return;
    let { precedingNode: J, followingNode: L, enclosingNode: Q } = k[0], V = R2.printer.getGapRegex && R2.printer.getGapRegex(Q) || /^[\s(]*$/, j = R2.locStart(L), Y;
    for (Y = q; Y > 0; --Y) {
      let { comment: ie2, precedingNode: ee2, followingNode: ce2 } = k[Y - 1];
      t.strictEqual(ee2, J), t.strictEqual(ce2, L);
      let W = M2.slice(R2.locEnd(ie2), j);
      if (V.test(W))
        j = R2.locStart(ie2);
      else
        break;
    }
    for (let [ie2, { comment: ee2 }] of k.entries())
      ie2 < Y ? _(J, ee2) : f(L, ee2);
    for (let ie2 of [J, L])
      ie2.comments && ie2.comments.length > 1 && ie2.comments.sort((ee2, ce2) => R2.locStart(ee2) - R2.locStart(ce2));
    k.length = 0;
  }
  function m(k, M2) {
    let R2 = k.getValue();
    return R2.printed = true, M2.printer.printComment(k, M2);
  }
  function C(k, M2, R2) {
    let q = R2.locStart(M2) - 1;
    for (let J = 1; J < k.length; ++J)
      if (q < R2.locStart(k[J]))
        return J - 1;
    return 0;
  }
  function o(k, M2) {
    let R2 = k.getValue(), q = [m(k, M2)], { printer: J, originalText: L, locStart: Q, locEnd: V } = M2;
    if (J.isBlockComment && J.isBlockComment(R2)) {
      let ie2 = d2(L, V(R2)) ? d2(L, Q(R2), { backwards: true }) ? a : s : " ";
      q.push(ie2);
    } else
      q.push(a);
    let Y = y2(L, g2(L, V(R2)));
    return Y !== false && d2(L, Y) && q.push(a), q;
  }
  function h(k, M2) {
    let R2 = k.getValue(), q = m(k, M2), { printer: J, originalText: L, locStart: Q } = M2, V = J.isBlockComment && J.isBlockComment(R2);
    if (d2(L, Q(R2), { backwards: true })) {
      let Y = c(L, R2, Q);
      return i([a, Y ? a : "", q]);
    }
    let j = [" ", q];
    return V || (j = [i(j), n]), j;
  }
  function v2(k, M2, R2, q) {
    let J = [], L = k.getValue();
    return !L || !L.comments || (k.each(() => {
      let Q = k.getValue();
      !Q.leading && !Q.trailing && (!q || q(Q)) && J.push(m(k, M2));
    }, "comments"), J.length === 0) ? "" : R2 ? l(a, J) : u([a, l(a, J)]);
  }
  function S(k, M2, R2) {
    let q = k.getValue();
    if (!q)
      return {};
    let J = q.comments || [];
    R2 && (J = J.filter((j) => !R2.has(j)));
    let L = q === M2.cursorNode;
    if (J.length === 0) {
      let j = L ? p : "";
      return { leading: j, trailing: j };
    }
    let Q = [], V = [];
    return k.each(() => {
      let j = k.getValue();
      if (R2 && R2.has(j))
        return;
      let { leading: Y, trailing: ie2 } = j;
      Y ? Q.push(o(k, M2)) : ie2 && V.push(h(k, M2));
    }, "comments"), L && (Q.unshift(p), V.push(p)), { leading: Q, trailing: V };
  }
  function b(k, M2, R2, q) {
    let { leading: J, trailing: L } = S(k, R2, q);
    return !J && !L ? M2 : [J, M2, L];
  }
  function B(k) {
    if (k)
      for (let M2 of k) {
        if (!M2.printed)
          throw new Error('Comment "' + M2.value.trim() + '" was not printed. Please report this error!');
        delete M2.printed;
      }
  }
  r.exports = { attach: I2, printComments: b, printCommentsSeparately: S, printDanglingComments: v2, getSortedChildNodes: F, ensureAllCommentsPrinted: B };
} }), Pm = te$1({ "src/common/ast-path.js"(e, r) {
  ne();
  var t = lt$1();
  function s(u, i) {
    let l = a(u.stack, i);
    return l === -1 ? null : u.stack[l];
  }
  function a(u, i) {
    for (let l = u.length - 1; l >= 0; l -= 2) {
      let p = u[l];
      if (p && !Array.isArray(p) && --i < 0)
        return l;
    }
    return -1;
  }
  var n = class {
    constructor(u) {
      this.stack = [u];
    }
    getName() {
      let { stack: u } = this, { length: i } = u;
      return i > 1 ? u[i - 2] : null;
    }
    getValue() {
      return t(this.stack);
    }
    getNode() {
      let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return s(this, u);
    }
    getParentNode() {
      let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return s(this, u + 1);
    }
    call(u) {
      let { stack: i } = this, { length: l } = i, p = t(i);
      for (var d2 = arguments.length, y2 = new Array(d2 > 1 ? d2 - 1 : 0), g2 = 1; g2 < d2; g2++)
        y2[g2 - 1] = arguments[g2];
      for (let f of y2)
        p = p[f], i.push(f, p);
      let c = u(this);
      return i.length = l, c;
    }
    callParent(u) {
      let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, l = a(this.stack, i + 1), p = this.stack.splice(l + 1), d2 = u(this);
      return this.stack.push(...p), d2;
    }
    each(u) {
      let { stack: i } = this, { length: l } = i, p = t(i);
      for (var d2 = arguments.length, y2 = new Array(d2 > 1 ? d2 - 1 : 0), g2 = 1; g2 < d2; g2++)
        y2[g2 - 1] = arguments[g2];
      for (let c of y2)
        p = p[c], i.push(c, p);
      for (let c = 0; c < p.length; ++c)
        i.push(c, p[c]), u(this, c, p), i.length -= 2;
      i.length = l;
    }
    map(u) {
      let i = [];
      for (var l = arguments.length, p = new Array(l > 1 ? l - 1 : 0), d2 = 1; d2 < l; d2++)
        p[d2 - 1] = arguments[d2];
      return this.each((y2, g2, c) => {
        i[g2] = u(y2, g2, c);
      }, ...p), i;
    }
    try(u) {
      let { stack: i } = this, l = [...i];
      try {
        return u();
      } finally {
        i.length = 0, i.push(...l);
      }
    }
    match() {
      let u = this.stack.length - 1, i = null, l = this.stack[u--];
      for (var p = arguments.length, d2 = new Array(p), y2 = 0; y2 < p; y2++)
        d2[y2] = arguments[y2];
      for (let g2 of d2) {
        if (l === void 0)
          return false;
        let c = null;
        if (typeof i == "number" && (c = i, i = this.stack[u--], l = this.stack[u--]), g2 && !g2(l, i, c))
          return false;
        i = this.stack[u--], l = this.stack[u--];
      }
      return true;
    }
    findAncestor(u) {
      let i = this.stack.length - 1, l = null, p = this.stack[i--];
      for (; p; ) {
        let d2 = null;
        if (typeof l == "number" && (d2 = l, l = this.stack[i--], p = this.stack[i--]), l !== null && u(p, l, d2))
          return p;
        l = this.stack[i--], p = this.stack[i--];
      }
    }
  };
  r.exports = n;
} }), Im = te$1({ "src/main/multiparser.js"(e, r) {
  ne();
  var { utils: { stripTrailingHardline: t } } = qe(), { normalize: s } = Ka$1(), a = et();
  function n(i, l, p, d2) {
    if (p.printer.embed && p.embeddedLanguageFormatting === "auto")
      return p.printer.embed(i, l, (y2, g2, c) => u(y2, g2, p, d2, c), p);
  }
  function u(i, l, p, d2) {
    let { stripTrailingHardline: y2 = false } = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {}, g2 = s(Object.assign(Object.assign(Object.assign({}, p), l), {}, { parentParser: p.parser, originalText: i }), { passThrough: true }), c = Qn$1().parse(i, g2), { ast: f } = c;
    i = c.text;
    let E = f.comments;
    delete f.comments, a.attach(E, f, i, g2), g2[Symbol.for("comments")] = E || [], g2[Symbol.for("tokens")] = f.tokens || [];
    let _ = d2(f, g2);
    return a.ensureAllCommentsPrinted(E), y2 ? typeof _ == "string" ? _.replace(/(?:\r?\n)*$/, "") : t(_) : _;
  }
  r.exports = { printSubtree: n };
} }), km = te$1({ "src/main/ast-to-doc.js"(e, r) {
  ne();
  var t = Pm(), { builders: { hardline: s, addAlignmentToDoc: a }, utils: { propagateBreaks: n } } = qe(), { printComments: u } = et(), i = Im();
  function l(y2, g2) {
    let c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, { printer: f } = g2;
    f.preprocess && (y2 = f.preprocess(y2, g2));
    let E = /* @__PURE__ */ new Map(), _ = new t(y2), w = F();
    return c > 0 && (w = a([s, w], c, g2.tabWidth)), n(w), w;
    function F(x, I2) {
      return x === void 0 || x === _ ? N2(I2) : Array.isArray(x) ? _.call(() => N2(I2), ...x) : _.call(() => N2(I2), x);
    }
    function N2(x) {
      let I2 = _.getValue(), P = I2 && typeof I2 == "object" && x === void 0;
      if (P && E.has(I2))
        return E.get(I2);
      let $2 = d2(_, g2, F, x);
      return P && E.set(I2, $2), $2;
    }
  }
  function p(y2, g2) {
    let { originalText: c, [Symbol.for("comments")]: f, locStart: E, locEnd: _ } = g2, w = E(y2), F = _(y2), N2 = /* @__PURE__ */ new Set();
    for (let x of f)
      E(x) >= w && _(x) <= F && (x.printed = true, N2.add(x));
    return { doc: c.slice(w, F), printedComments: N2 };
  }
  function d2(y2, g2, c, f) {
    let E = y2.getValue(), { printer: _ } = g2, w, F;
    if (_.hasPrettierIgnore && _.hasPrettierIgnore(y2))
      ({ doc: w, printedComments: F } = p(E, g2));
    else {
      if (E)
        try {
          w = i.printSubtree(y2, c, g2, l);
        } catch (N2) {
          if (globalThis.PRETTIER_DEBUG)
            throw N2;
        }
      w || (w = _.print(y2, g2, c, f));
    }
    return (!_.willPrintOwnComments || !_.willPrintOwnComments(y2, g2)) && (w = u(y2, w, g2, F)), w;
  }
  r.exports = l;
} }), Lm = te$1({ "src/main/range-util.js"(e, r) {
  ne();
  var t = Yt$1(), s = et(), a = (f) => {
    let { parser: E } = f;
    return E === "json" || E === "json5" || E === "json-stringify";
  };
  function n(f, E) {
    let _ = [f.node, ...f.parentNodes], w = /* @__PURE__ */ new Set([E.node, ...E.parentNodes]);
    return _.find((F) => d2.has(F.type) && w.has(F));
  }
  function u(f) {
    let E = f.length - 1;
    for (; ; ) {
      let _ = f[E];
      if (_ && (_.type === "Program" || _.type === "File"))
        E--;
      else
        break;
    }
    return f.slice(0, E + 1);
  }
  function i(f, E, _) {
    let { locStart: w, locEnd: F } = _, N2 = f.node, x = E.node;
    if (N2 === x)
      return { startNode: N2, endNode: x };
    let I2 = w(f.node);
    for (let $2 of u(E.parentNodes))
      if (w($2) >= I2)
        x = $2;
      else
        break;
    let P = F(E.node);
    for (let $2 of u(f.parentNodes)) {
      if (F($2) <= P)
        N2 = $2;
      else
        break;
      if (N2 === x)
        break;
    }
    return { startNode: N2, endNode: x };
  }
  function l(f, E, _, w) {
    let F = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], N2 = arguments.length > 5 ? arguments[5] : void 0, { locStart: x, locEnd: I2 } = _, P = x(f), $2 = I2(f);
    if (!(E > $2 || E < P || N2 === "rangeEnd" && E === P || N2 === "rangeStart" && E === $2)) {
      for (let D of s.getSortedChildNodes(f, _)) {
        let T = l(D, E, _, w, [f, ...F], N2);
        if (T)
          return T;
      }
      if (!w || w(f, F[0]))
        return { node: f, parentNodes: F };
    }
  }
  function p(f, E) {
    return E !== "DeclareExportDeclaration" && f !== "TypeParameterDeclaration" && (f === "Directive" || f === "TypeAlias" || f === "TSExportAssignment" || f.startsWith("Declare") || f.startsWith("TSDeclare") || f.endsWith("Statement") || f.endsWith("Declaration"));
  }
  var d2 = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), y2 = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
  function g2(f, E, _) {
    if (!E)
      return false;
    switch (f.parser) {
      case "flow":
      case "babel":
      case "babel-flow":
      case "babel-ts":
      case "typescript":
      case "acorn":
      case "espree":
      case "meriyah":
      case "__babel_estree":
        return p(E.type, _ && _.type);
      case "json":
      case "json5":
      case "json-stringify":
        return d2.has(E.type);
      case "graphql":
        return y2.has(E.kind);
      case "vue":
        return E.tag !== "root";
    }
    return false;
  }
  function c(f, E, _) {
    let { rangeStart: w, rangeEnd: F, locStart: N2, locEnd: x } = E;
    t.ok(F > w);
    let I2 = f.slice(w, F).search(/\S/), P = I2 === -1;
    if (!P)
      for (w += I2; F > w && !/\S/.test(f[F - 1]); --F)
        ;
    let $2 = l(_, w, E, (C, o) => g2(E, C, o), [], "rangeStart"), D = P ? $2 : l(_, F, E, (C) => g2(E, C), [], "rangeEnd");
    if (!$2 || !D)
      return { rangeStart: 0, rangeEnd: 0 };
    let T, m;
    if (a(E)) {
      let C = n($2, D);
      T = C, m = C;
    } else
      ({ startNode: T, endNode: m } = i($2, D, E));
    return { rangeStart: Math.min(N2(T), N2(m)), rangeEnd: Math.max(x(T), x(m)) };
  }
  r.exports = { calculateRange: c, findNodeAtOffset: l };
} }), Om = te$1({ "src/main/core.js"(e, r) {
  ne();
  var { diffArrays: t } = vD(), { printer: { printDocToString: s }, debug: { printDocToDebug: a } } = qe(), { getAlignmentSize: n } = Ue$2(), { guessEndOfLine: u, convertEndOfLineToChars: i, countEndOfLineChars: l, normalizeEndOfLine: p } = Hn(), d2 = Ka$1().normalize, y2 = _m(), g2 = et(), c = Qn$1(), f = km(), E = Lm(), _ = "\uFEFF", w = Symbol("cursor");
  function F(m, C, o) {
    let h = C.comments;
    return h && (delete C.comments, g2.attach(h, C, m, o)), o[Symbol.for("comments")] = h || [], o[Symbol.for("tokens")] = C.tokens || [], o.originalText = m, h;
  }
  function N2(m, C) {
    let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    if (!m || m.trim().length === 0)
      return { formatted: "", cursorOffset: -1, comments: [] };
    let { ast: h, text: v2 } = c.parse(m, C);
    if (C.cursorOffset >= 0) {
      let k = E.findNodeAtOffset(h, C.cursorOffset, C);
      k && k.node && (C.cursorNode = k.node);
    }
    let S = F(v2, h, C), b = f(h, C, o), B = s(b, C);
    if (g2.ensureAllCommentsPrinted(S), o > 0) {
      let k = B.formatted.trim();
      B.cursorNodeStart !== void 0 && (B.cursorNodeStart -= B.formatted.indexOf(k)), B.formatted = k + i(C.endOfLine);
    }
    if (C.cursorOffset >= 0) {
      let k, M2, R2, q, J;
      if (C.cursorNode && B.cursorNodeText ? (k = C.locStart(C.cursorNode), M2 = v2.slice(k, C.locEnd(C.cursorNode)), R2 = C.cursorOffset - k, q = B.cursorNodeStart, J = B.cursorNodeText) : (k = 0, M2 = v2, R2 = C.cursorOffset, q = 0, J = B.formatted), M2 === J)
        return { formatted: B.formatted, cursorOffset: q + R2, comments: S };
      let L = [...M2];
      L.splice(R2, 0, w);
      let Q = [...J], V = t(L, Q), j = q;
      for (let Y of V)
        if (Y.removed) {
          if (Y.value.includes(w))
            break;
        } else
          j += Y.count;
      return { formatted: B.formatted, cursorOffset: j, comments: S };
    }
    return { formatted: B.formatted, cursorOffset: -1, comments: S };
  }
  function x(m, C) {
    let { ast: o, text: h } = c.parse(m, C), { rangeStart: v2, rangeEnd: S } = E.calculateRange(h, C, o), b = h.slice(v2, S), B = Math.min(v2, h.lastIndexOf(`
`, v2) + 1), k = h.slice(B, v2).match(/^\s*/)[0], M2 = n(k, C.tabWidth), R2 = N2(b, Object.assign(Object.assign({}, C), {}, { rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: C.cursorOffset > v2 && C.cursorOffset <= S ? C.cursorOffset - v2 : -1, endOfLine: "lf" }), M2), q = R2.formatted.trimEnd(), { cursorOffset: J } = C;
    J > S ? J += q.length - b.length : R2.cursorOffset >= 0 && (J = R2.cursorOffset + v2);
    let L = h.slice(0, v2) + q + h.slice(S);
    if (C.endOfLine !== "lf") {
      let Q = i(C.endOfLine);
      J >= 0 && Q === `\r
` && (J += l(L.slice(0, J), `
`)), L = L.replace(/\n/g, Q);
    }
    return { formatted: L, cursorOffset: J, comments: R2.comments };
  }
  function I2(m, C, o) {
    return typeof C != "number" || Number.isNaN(C) || C < 0 || C > m.length ? o : C;
  }
  function P(m, C) {
    let { cursorOffset: o, rangeStart: h, rangeEnd: v2 } = C;
    return o = I2(m, o, -1), h = I2(m, h, 0), v2 = I2(m, v2, m.length), Object.assign(Object.assign({}, C), {}, { cursorOffset: o, rangeStart: h, rangeEnd: v2 });
  }
  function $2(m, C) {
    let { cursorOffset: o, rangeStart: h, rangeEnd: v2, endOfLine: S } = P(m, C), b = m.charAt(0) === _;
    if (b && (m = m.slice(1), o--, h--, v2--), S === "auto" && (S = u(m)), m.includes("\r")) {
      let B = (k) => l(m.slice(0, Math.max(k, 0)), `\r
`);
      o -= B(o), h -= B(h), v2 -= B(v2), m = p(m);
    }
    return { hasBOM: b, text: m, options: P(m, Object.assign(Object.assign({}, C), {}, { cursorOffset: o, rangeStart: h, rangeEnd: v2, endOfLine: S })) };
  }
  function D(m, C) {
    let o = c.resolveParser(C);
    return !o.hasPragma || o.hasPragma(m);
  }
  function T(m, C) {
    let { hasBOM: o, text: h, options: v2 } = $2(m, d2(C));
    if (v2.rangeStart >= v2.rangeEnd && h !== "" || v2.requirePragma && !D(h, v2))
      return { formatted: m, cursorOffset: C.cursorOffset, comments: [] };
    let S;
    return v2.rangeStart > 0 || v2.rangeEnd < h.length ? S = x(h, v2) : (!v2.requirePragma && v2.insertPragma && v2.printer.insertPragma && !D(h, v2) && (h = v2.printer.insertPragma(h)), S = N2(h, v2)), o && (S.formatted = _ + S.formatted, S.cursorOffset >= 0 && S.cursorOffset++), S;
  }
  r.exports = { formatWithCursor: T, parse(m, C, o) {
    let { text: h, options: v2 } = $2(m, d2(C)), S = c.parse(h, v2);
    return o && (S.ast = y2(S.ast, v2)), S;
  }, formatAST(m, C) {
    C = d2(C);
    let o = f(m, C);
    return s(o, C);
  }, formatDoc(m, C) {
    return T(a(m), Object.assign(Object.assign({}, C), {}, { parser: "__js_expression" })).formatted;
  }, printToDoc(m, C) {
    C = d2(C);
    let { ast: o, text: h } = c.parse(m, C);
    return F(h, o, C), f(o, C);
  }, printDocToString(m, C) {
    return s(m, d2(C));
  } };
} }), jm = te$1({ "src/common/util-shared.js"(e, r) {
  ne();
  var { getMaxContinuousCount: t, getStringWidth: s, getAlignmentSize: a, getIndentSize: n, skip: u, skipWhitespace: i, skipSpaces: l, skipNewline: p, skipToLineEnd: d2, skipEverythingButNewLine: y2, skipInlineComment: g2, skipTrailingComment: c, hasNewline: f, hasNewlineInRange: E, hasSpaces: _, isNextLineEmpty: w, isNextLineEmptyAfterIndex: F, isPreviousLineEmpty: N2, getNextNonSpaceNonCommentCharacterIndex: x, makeString: I2, addLeadingComment: P, addDanglingComment: $2, addTrailingComment: D } = Ue$2();
  r.exports = { getMaxContinuousCount: t, getStringWidth: s, getAlignmentSize: a, getIndentSize: n, skip: u, skipWhitespace: i, skipSpaces: l, skipNewline: p, skipToLineEnd: d2, skipEverythingButNewLine: y2, skipInlineComment: g2, skipTrailingComment: c, hasNewline: f, hasNewlineInRange: E, hasSpaces: _, isNextLineEmpty: w, isNextLineEmptyAfterIndex: F, isPreviousLineEmpty: N2, getNextNonSpaceNonCommentCharacterIndex: x, makeString: I2, addLeadingComment: P, addDanglingComment: $2, addTrailingComment: D };
} }), wt$1 = te$1({ "src/utils/create-language.js"(e, r) {
  ne(), r.exports = function(t, s) {
    let { languageId: a } = t, n = $n(t, pD);
    return Object.assign(Object.assign({ linguistLanguageId: a }, n), s(t));
  };
} }), qm = te$1({ "node_modules/esutils/lib/ast.js"(e, r) {
  ne(), function() {
    function t(l) {
      if (l == null)
        return false;
      switch (l.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "CallExpression":
        case "ConditionalExpression":
        case "FunctionExpression":
        case "Identifier":
        case "Literal":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "ObjectExpression":
        case "SequenceExpression":
        case "ThisExpression":
        case "UnaryExpression":
        case "UpdateExpression":
          return true;
      }
      return false;
    }
    function s(l) {
      if (l == null)
        return false;
      switch (l.type) {
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "WhileStatement":
          return true;
      }
      return false;
    }
    function a(l) {
      if (l == null)
        return false;
      switch (l.type) {
        case "BlockStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "ForInStatement":
        case "ForStatement":
        case "IfStatement":
        case "LabeledStatement":
        case "ReturnStatement":
        case "SwitchStatement":
        case "ThrowStatement":
        case "TryStatement":
        case "VariableDeclaration":
        case "WhileStatement":
        case "WithStatement":
          return true;
      }
      return false;
    }
    function n(l) {
      return a(l) || l != null && l.type === "FunctionDeclaration";
    }
    function u(l) {
      switch (l.type) {
        case "IfStatement":
          return l.alternate != null ? l.alternate : l.consequent;
        case "LabeledStatement":
        case "ForStatement":
        case "ForInStatement":
        case "WhileStatement":
        case "WithStatement":
          return l.body;
      }
      return null;
    }
    function i(l) {
      var p;
      if (l.type !== "IfStatement" || l.alternate == null)
        return false;
      p = l.consequent;
      do {
        if (p.type === "IfStatement" && p.alternate == null)
          return true;
        p = u(p);
      } while (p);
      return false;
    }
    r.exports = { isExpression: t, isStatement: a, isIterationStatement: s, isSourceElement: n, isProblematicIfStatement: i, trailingStatement: u };
  }();
} }), Ya = te$1({ "node_modules/esutils/lib/code.js"(e, r) {
  ne(), function() {
    var t, s, a, n, u, i;
    s = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, t = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ };
    function l(F) {
      return 48 <= F && F <= 57;
    }
    function p(F) {
      return 48 <= F && F <= 57 || 97 <= F && F <= 102 || 65 <= F && F <= 70;
    }
    function d2(F) {
      return F >= 48 && F <= 55;
    }
    a = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279];
    function y2(F) {
      return F === 32 || F === 9 || F === 11 || F === 12 || F === 160 || F >= 5760 && a.indexOf(F) >= 0;
    }
    function g2(F) {
      return F === 10 || F === 13 || F === 8232 || F === 8233;
    }
    function c(F) {
      if (F <= 65535)
        return String.fromCharCode(F);
      var N2 = String.fromCharCode(Math.floor((F - 65536) / 1024) + 55296), x = String.fromCharCode((F - 65536) % 1024 + 56320);
      return N2 + x;
    }
    for (n = new Array(128), i = 0; i < 128; ++i)
      n[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i === 36 || i === 95;
    for (u = new Array(128), i = 0; i < 128; ++i)
      u[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i >= 48 && i <= 57 || i === 36 || i === 95;
    function f(F) {
      return F < 128 ? n[F] : s.NonAsciiIdentifierStart.test(c(F));
    }
    function E(F) {
      return F < 128 ? u[F] : s.NonAsciiIdentifierPart.test(c(F));
    }
    function _(F) {
      return F < 128 ? n[F] : t.NonAsciiIdentifierStart.test(c(F));
    }
    function w(F) {
      return F < 128 ? u[F] : t.NonAsciiIdentifierPart.test(c(F));
    }
    r.exports = { isDecimalDigit: l, isHexDigit: p, isOctalDigit: d2, isWhiteSpace: y2, isLineTerminator: g2, isIdentifierStartES5: f, isIdentifierPartES5: E, isIdentifierStartES6: _, isIdentifierPartES6: w };
  }();
} }), Mm = te$1({ "node_modules/esutils/lib/keyword.js"(e, r) {
  ne(), function() {
    var t = Ya();
    function s(f) {
      switch (f) {
        case "implements":
        case "interface":
        case "package":
        case "private":
        case "protected":
        case "public":
        case "static":
        case "let":
          return true;
        default:
          return false;
      }
    }
    function a(f, E) {
      return !E && f === "yield" ? false : n(f, E);
    }
    function n(f, E) {
      if (E && s(f))
        return true;
      switch (f.length) {
        case 2:
          return f === "if" || f === "in" || f === "do";
        case 3:
          return f === "var" || f === "for" || f === "new" || f === "try";
        case 4:
          return f === "this" || f === "else" || f === "case" || f === "void" || f === "with" || f === "enum";
        case 5:
          return f === "while" || f === "break" || f === "catch" || f === "throw" || f === "const" || f === "yield" || f === "class" || f === "super";
        case 6:
          return f === "return" || f === "typeof" || f === "delete" || f === "switch" || f === "export" || f === "import";
        case 7:
          return f === "default" || f === "finally" || f === "extends";
        case 8:
          return f === "function" || f === "continue" || f === "debugger";
        case 10:
          return f === "instanceof";
        default:
          return false;
      }
    }
    function u(f, E) {
      return f === "null" || f === "true" || f === "false" || a(f, E);
    }
    function i(f, E) {
      return f === "null" || f === "true" || f === "false" || n(f, E);
    }
    function l(f) {
      return f === "eval" || f === "arguments";
    }
    function p(f) {
      var E, _, w;
      if (f.length === 0 || (w = f.charCodeAt(0), !t.isIdentifierStartES5(w)))
        return false;
      for (E = 1, _ = f.length; E < _; ++E)
        if (w = f.charCodeAt(E), !t.isIdentifierPartES5(w))
          return false;
      return true;
    }
    function d2(f, E) {
      return (f - 55296) * 1024 + (E - 56320) + 65536;
    }
    function y2(f) {
      var E, _, w, F, N2;
      if (f.length === 0)
        return false;
      for (N2 = t.isIdentifierStartES6, E = 0, _ = f.length; E < _; ++E) {
        if (w = f.charCodeAt(E), 55296 <= w && w <= 56319) {
          if (++E, E >= _ || (F = f.charCodeAt(E), !(56320 <= F && F <= 57343)))
            return false;
          w = d2(w, F);
        }
        if (!N2(w))
          return false;
        N2 = t.isIdentifierPartES6;
      }
      return true;
    }
    function g2(f, E) {
      return p(f) && !u(f, E);
    }
    function c(f, E) {
      return y2(f) && !i(f, E);
    }
    r.exports = { isKeywordES5: a, isKeywordES6: n, isReservedWordES5: u, isReservedWordES6: i, isRestrictedWord: l, isIdentifierNameES5: p, isIdentifierNameES6: y2, isIdentifierES5: g2, isIdentifierES6: c };
  }();
} }), Rm = te$1({ "node_modules/esutils/lib/utils.js"(e) {
  ne(), function() {
    e.ast = qm(), e.code = Ya(), e.keyword = Mm();
  }();
} }), _t$2 = te$1({ "src/language-js/utils/is-block-comment.js"(e, r) {
  ne();
  var t = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]), s = (a) => t.has(a == null ? void 0 : a.type);
  r.exports = s;
} }), $m = te$1({ "src/language-js/utils/is-node-matches.js"(e, r) {
  ne();
  function t(a, n) {
    let u = n.split(".");
    for (let i = u.length - 1; i >= 0; i--) {
      let l = u[i];
      if (i === 0)
        return a.type === "Identifier" && a.name === l;
      if (a.type !== "MemberExpression" || a.optional || a.computed || a.property.type !== "Identifier" || a.property.name !== l)
        return false;
      a = a.object;
    }
  }
  function s(a, n) {
    return n.some((u) => t(a, u));
  }
  r.exports = s;
} }), Ke$1 = te$1({ "src/language-js/utils/index.js"(e, r) {
  ne();
  var t = Rm().keyword.isIdentifierNameES5, { getLast: s, hasNewline: a, skipWhitespace: n, isNonEmptyArray: u, isNextLineEmptyAfterIndex: i, getStringWidth: l } = Ue$2(), { locStart: p, locEnd: d2, hasSameLocStart: y2 } = ut$1(), g2 = _t$2(), c = $m(), f = "(?:(?=.)\\s)", E = new RegExp(`^${f}*:`), _ = new RegExp(`^${f}*::`);
  function w(O) {
    var me2, _e2;
    return ((me2 = O.extra) === null || me2 === void 0 ? void 0 : me2.parenthesized) && g2((_e2 = O.trailingComments) === null || _e2 === void 0 ? void 0 : _e2[0]) && E.test(O.trailingComments[0].value);
  }
  function F(O) {
    let me2 = O == null ? void 0 : O[0];
    return g2(me2) && _.test(me2.value);
  }
  function N2(O, me2) {
    if (!O || typeof O != "object")
      return false;
    if (Array.isArray(O))
      return O.some((He2) => N2(He2, me2));
    let _e2 = me2(O);
    return typeof _e2 == "boolean" ? _e2 : Object.values(O).some((He2) => N2(He2, me2));
  }
  function x(O) {
    return O.type === "AssignmentExpression" || O.type === "BinaryExpression" || O.type === "LogicalExpression" || O.type === "NGPipeExpression" || O.type === "ConditionalExpression" || de(O) || ue2(O) || O.type === "SequenceExpression" || O.type === "TaggedTemplateExpression" || O.type === "BindExpression" || O.type === "UpdateExpression" && !O.prefix || st2(O) || O.type === "TSNonNullExpression";
  }
  function I2(O) {
    var me2, _e2, He2, Ge2, it2, Qe;
    return O.expressions ? O.expressions[0] : (me2 = (_e2 = (He2 = (Ge2 = (it2 = (Qe = O.left) !== null && Qe !== void 0 ? Qe : O.test) !== null && it2 !== void 0 ? it2 : O.callee) !== null && Ge2 !== void 0 ? Ge2 : O.object) !== null && He2 !== void 0 ? He2 : O.tag) !== null && _e2 !== void 0 ? _e2 : O.argument) !== null && me2 !== void 0 ? me2 : O.expression;
  }
  function P(O, me2) {
    if (me2.expressions)
      return ["expressions", 0];
    if (me2.left)
      return ["left"];
    if (me2.test)
      return ["test"];
    if (me2.object)
      return ["object"];
    if (me2.callee)
      return ["callee"];
    if (me2.tag)
      return ["tag"];
    if (me2.argument)
      return ["argument"];
    if (me2.expression)
      return ["expression"];
    throw new Error("Unexpected node has no left side.");
  }
  function $2(O) {
    return O = new Set(O), (me2) => O.has(me2 == null ? void 0 : me2.type);
  }
  var D = $2(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose"]), T = $2(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
  function m(O) {
    let me2 = O.getParentNode();
    return O.getName() === "declaration" && T(me2) ? me2 : null;
  }
  var C = $2(["BooleanLiteral", "DirectiveLiteral", "Literal", "NullLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "RegExpLiteral", "StringLiteral", "TemplateLiteral", "TSTypeLiteral", "JSXText"]);
  function o(O) {
    return O.type === "NumericLiteral" || O.type === "Literal" && typeof O.value == "number";
  }
  function h(O) {
    return O.type === "UnaryExpression" && (O.operator === "+" || O.operator === "-") && o(O.argument);
  }
  function v2(O) {
    return O.type === "StringLiteral" || O.type === "Literal" && typeof O.value == "string";
  }
  var S = $2(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]), b = $2(["FunctionExpression", "ArrowFunctionExpression"]);
  function B(O) {
    return O.type === "FunctionExpression" || O.type === "ArrowFunctionExpression" && O.body.type === "BlockStatement";
  }
  function k(O) {
    return de(O) && O.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(O.callee.name);
  }
  var M2 = $2(["JSXElement", "JSXFragment"]);
  function R2(O, me2) {
    if (O.parentParser !== "markdown" && O.parentParser !== "mdx")
      return false;
    let _e2 = me2.getNode();
    if (!_e2.expression || !M2(_e2.expression))
      return false;
    let He2 = me2.getParentNode();
    return He2.type === "Program" && He2.body.length === 1;
  }
  function q(O) {
    return O.kind === "get" || O.kind === "set";
  }
  function J(O) {
    return q(O) || y2(O, O.value);
  }
  function L(O) {
    return (O.type === "ObjectTypeProperty" || O.type === "ObjectTypeInternalSlot") && O.value.type === "FunctionTypeAnnotation" && !O.static && !J(O);
  }
  function Q(O) {
    return (O.type === "TypeAnnotation" || O.type === "TSTypeAnnotation") && O.typeAnnotation.type === "FunctionTypeAnnotation" && !O.static && !y2(O, O.typeAnnotation);
  }
  var V = $2(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
  function j(O) {
    return ue2(O) || O.type === "BindExpression" && Boolean(O.object);
  }
  var Y = /* @__PURE__ */ new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
  function ie2(O) {
    return O ? !!((O.type === "GenericTypeAnnotation" || O.type === "TSTypeReference") && !O.typeParameters || Y.has(O.type)) : false;
  }
  function ee2(O) {
    let me2 = /^(?:before|after)(?:Each|All)$/;
    return O.callee.type === "Identifier" && me2.test(O.callee.name) && O.arguments.length === 1;
  }
  var ce2 = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
  function W(O) {
    return c(O, ce2);
  }
  function K2(O, me2) {
    if (O.type !== "CallExpression")
      return false;
    if (O.arguments.length === 1) {
      if (k(O) && me2 && K2(me2))
        return b(O.arguments[0]);
      if (ee2(O))
        return k(O.arguments[0]);
    } else if ((O.arguments.length === 2 || O.arguments.length === 3) && (O.arguments[0].type === "TemplateLiteral" || v2(O.arguments[0])) && W(O.callee))
      return O.arguments[2] && !o(O.arguments[2]) ? false : (O.arguments.length === 2 ? b(O.arguments[1]) : B(O.arguments[1]) && ve2(O.arguments[1]).length <= 1) || k(O.arguments[1]);
    return false;
  }
  var de = $2(["CallExpression", "OptionalCallExpression"]), ue2 = $2(["MemberExpression", "OptionalMemberExpression"]);
  function Fe2(O) {
    let me2 = "expressions";
    O.type === "TSTemplateLiteralType" && (me2 = "types");
    let _e2 = O[me2];
    return _e2.length === 0 ? false : _e2.every((He2) => {
      if (Me2(He2))
        return false;
      if (He2.type === "Identifier" || He2.type === "ThisExpression")
        return true;
      if (ue2(He2)) {
        let Ge2 = He2;
        for (; ue2(Ge2); )
          if (Ge2.property.type !== "Identifier" && Ge2.property.type !== "Literal" && Ge2.property.type !== "StringLiteral" && Ge2.property.type !== "NumericLiteral" || (Ge2 = Ge2.object, Me2(Ge2)))
            return false;
        return Ge2.type === "Identifier" || Ge2.type === "ThisExpression";
      }
      return false;
    });
  }
  function z(O, me2) {
    return O === "+" || O === "-" ? O + me2 : me2;
  }
  function U2(O, me2) {
    let _e2 = p(me2), He2 = n(O, d2(me2));
    return He2 !== false && O.slice(_e2, _e2 + 2) === "/*" && O.slice(He2, He2 + 2) === "*/";
  }
  function Z(O, me2) {
    return M2(me2) ? Oe2(me2) : Me2(me2, be2.Leading, (_e2) => a(O, d2(_e2)));
  }
  function se2(O, me2) {
    return me2.parser !== "json" && v2(O.key) && oe(O.key).slice(1, -1) === O.key.value && (t(O.key.value) && !(me2.parser === "babel-ts" && O.type === "ClassProperty" || me2.parser === "typescript" && O.type === "PropertyDefinition") || fe2(O.key.value) && String(Number(O.key.value)) === O.key.value && (me2.parser === "babel" || me2.parser === "acorn" || me2.parser === "espree" || me2.parser === "meriyah" || me2.parser === "__babel_estree"));
  }
  function fe2(O) {
    return /^(?:\d+|\d+\.\d+)$/.test(O);
  }
  function ge2(O, me2) {
    let _e2 = /^[fx]?(?:describe|it|test)$/;
    return me2.type === "TaggedTemplateExpression" && me2.quasi === O && me2.tag.type === "MemberExpression" && me2.tag.property.type === "Identifier" && me2.tag.property.name === "each" && (me2.tag.object.type === "Identifier" && _e2.test(me2.tag.object.name) || me2.tag.object.type === "MemberExpression" && me2.tag.object.property.type === "Identifier" && (me2.tag.object.property.name === "only" || me2.tag.object.property.name === "skip") && me2.tag.object.object.type === "Identifier" && _e2.test(me2.tag.object.object.name));
  }
  function he2(O) {
    return O.quasis.some((me2) => me2.value.raw.includes(`
`));
  }
  function we2(O, me2) {
    return (O.type === "TemplateLiteral" && he2(O) || O.type === "TaggedTemplateExpression" && he2(O.quasi)) && !a(me2, p(O), { backwards: true });
  }
  function ke2(O) {
    if (!Me2(O))
      return false;
    let me2 = s(ae2(O, be2.Dangling));
    return me2 && !g2(me2);
  }
  function Re2(O) {
    if (O.length <= 1)
      return false;
    let me2 = 0;
    for (let _e2 of O)
      if (b(_e2)) {
        if (me2 += 1, me2 > 1)
          return true;
      } else if (de(_e2)) {
        for (let He2 of _e2.arguments)
          if (b(He2))
            return true;
      }
    return false;
  }
  function Ne2(O) {
    let me2 = O.getValue(), _e2 = O.getParentNode();
    return de(me2) && de(_e2) && _e2.callee === me2 && me2.arguments.length > _e2.arguments.length && _e2.arguments.length > 0;
  }
  function Pe2(O, me2) {
    if (me2 >= 2)
      return false;
    let _e2 = (Qe) => Pe2(Qe, me2 + 1), He2 = O.type === "Literal" && "regex" in O && O.regex.pattern || O.type === "RegExpLiteral" && O.pattern;
    if (He2 && l(He2) > 5)
      return false;
    if (O.type === "Literal" || O.type === "BigIntLiteral" || O.type === "DecimalLiteral" || O.type === "BooleanLiteral" || O.type === "NullLiteral" || O.type === "NumericLiteral" || O.type === "RegExpLiteral" || O.type === "StringLiteral" || O.type === "Identifier" || O.type === "ThisExpression" || O.type === "Super" || O.type === "PrivateName" || O.type === "PrivateIdentifier" || O.type === "ArgumentPlaceholder" || O.type === "Import")
      return true;
    if (O.type === "TemplateLiteral")
      return O.quasis.every((Qe) => !Qe.value.raw.includes(`
`)) && O.expressions.every(_e2);
    if (O.type === "ObjectExpression")
      return O.properties.every((Qe) => !Qe.computed && (Qe.shorthand || Qe.value && _e2(Qe.value)));
    if (O.type === "ArrayExpression")
      return O.elements.every((Qe) => Qe === null || _e2(Qe));
    if (tt(O))
      return (O.type === "ImportExpression" || Pe2(O.callee, me2)) && Ye2(O).every(_e2);
    if (ue2(O))
      return Pe2(O.object, me2) && Pe2(O.property, me2);
    let Ge2 = { "!": true, "-": true, "+": true, "~": true };
    if (O.type === "UnaryExpression" && Ge2[O.operator])
      return Pe2(O.argument, me2);
    let it2 = { "++": true, "--": true };
    return O.type === "UpdateExpression" && it2[O.operator] ? Pe2(O.argument, me2) : O.type === "TSNonNullExpression" ? Pe2(O.expression, me2) : false;
  }
  function oe(O) {
    var me2, _e2;
    return (me2 = (_e2 = O.extra) === null || _e2 === void 0 ? void 0 : _e2.raw) !== null && me2 !== void 0 ? me2 : O.raw;
  }
  function H(O) {
    return O;
  }
  function pe2(O) {
    return O.filepath && /\.tsx$/i.test(O.filepath);
  }
  function X(O) {
    let me2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "es5";
    return O.trailingComma === "es5" && me2 === "es5" || O.trailingComma === "all" && (me2 === "all" || me2 === "es5");
  }
  function le2(O, me2) {
    switch (O.type) {
      case "BinaryExpression":
      case "LogicalExpression":
      case "AssignmentExpression":
      case "NGPipeExpression":
        return le2(O.left, me2);
      case "MemberExpression":
      case "OptionalMemberExpression":
        return le2(O.object, me2);
      case "TaggedTemplateExpression":
        return O.tag.type === "FunctionExpression" ? false : le2(O.tag, me2);
      case "CallExpression":
      case "OptionalCallExpression":
        return O.callee.type === "FunctionExpression" ? false : le2(O.callee, me2);
      case "ConditionalExpression":
        return le2(O.test, me2);
      case "UpdateExpression":
        return !O.prefix && le2(O.argument, me2);
      case "BindExpression":
        return O.object && le2(O.object, me2);
      case "SequenceExpression":
        return le2(O.expressions[0], me2);
      case "TSSatisfiesExpression":
      case "TSAsExpression":
      case "TSNonNullExpression":
        return le2(O.expression, me2);
      default:
        return me2(O);
    }
  }
  var Ae2 = { "==": true, "!=": true, "===": true, "!==": true }, Ee = { "*": true, "/": true, "%": true }, De2 = { ">>": true, ">>>": true, "<<": true };
  function A(O, me2) {
    return !(re(me2) !== re(O) || O === "**" || Ae2[O] && Ae2[me2] || me2 === "%" && Ee[O] || O === "%" && Ee[me2] || me2 !== O && Ee[me2] && Ee[O] || De2[O] && De2[me2]);
  }
  var G = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((O, me2) => O.map((_e2) => [_e2, me2])));
  function re(O) {
    return G.get(O);
  }
  function ye2(O) {
    return Boolean(De2[O]) || O === "|" || O === "^" || O === "&";
  }
  function Ce2(O) {
    var me2;
    if (O.rest)
      return true;
    let _e2 = ve2(O);
    return ((me2 = s(_e2)) === null || me2 === void 0 ? void 0 : me2.type) === "RestElement";
  }
  var Be = /* @__PURE__ */ new WeakMap();
  function ve2(O) {
    if (Be.has(O))
      return Be.get(O);
    let me2 = [];
    return O.this && me2.push(O.this), Array.isArray(O.parameters) ? me2.push(...O.parameters) : Array.isArray(O.params) && me2.push(...O.params), O.rest && me2.push(O.rest), Be.set(O, me2), me2;
  }
  function ze(O, me2) {
    let _e2 = O.getValue(), He2 = 0, Ge2 = (it2) => me2(it2, He2++);
    _e2.this && O.call(Ge2, "this"), Array.isArray(_e2.parameters) ? O.each(Ge2, "parameters") : Array.isArray(_e2.params) && O.each(Ge2, "params"), _e2.rest && O.call(Ge2, "rest");
  }
  var xe2 = /* @__PURE__ */ new WeakMap();
  function Ye2(O) {
    if (xe2.has(O))
      return xe2.get(O);
    let me2 = O.arguments;
    return O.type === "ImportExpression" && (me2 = [O.source], O.attributes && me2.push(O.attributes)), xe2.set(O, me2), me2;
  }
  function Se2(O, me2) {
    let _e2 = O.getValue();
    _e2.type === "ImportExpression" ? (O.call((He2) => me2(He2, 0), "source"), _e2.attributes && O.call((He2) => me2(He2, 1), "attributes")) : O.each(me2, "arguments");
  }
  function Ie2(O) {
    return O.value.trim() === "prettier-ignore" && !O.unignore;
  }
  function Oe2(O) {
    return O && (O.prettierIgnore || Me2(O, be2.PrettierIgnore));
  }
  function Je2(O) {
    let me2 = O.getValue();
    return Oe2(me2);
  }
  var be2 = { Leading: 1 << 1, Trailing: 1 << 2, Dangling: 1 << 3, Block: 1 << 4, Line: 1 << 5, PrettierIgnore: 1 << 6, First: 1 << 7, Last: 1 << 8 }, je2 = (O, me2) => {
    if (typeof O == "function" && (me2 = O, O = 0), O || me2)
      return (_e2, He2, Ge2) => !(O & be2.Leading && !_e2.leading || O & be2.Trailing && !_e2.trailing || O & be2.Dangling && (_e2.leading || _e2.trailing) || O & be2.Block && !g2(_e2) || O & be2.Line && !D(_e2) || O & be2.First && He2 !== 0 || O & be2.Last && He2 !== Ge2.length - 1 || O & be2.PrettierIgnore && !Ie2(_e2) || me2 && !me2(_e2));
  };
  function Me2(O, me2, _e2) {
    if (!u(O == null ? void 0 : O.comments))
      return false;
    let He2 = je2(me2, _e2);
    return He2 ? O.comments.some(He2) : true;
  }
  function ae2(O, me2, _e2) {
    if (!Array.isArray(O == null ? void 0 : O.comments))
      return [];
    let He2 = je2(me2, _e2);
    return He2 ? O.comments.filter(He2) : O.comments;
  }
  var nt = (O, me2) => {
    let { originalText: _e2 } = me2;
    return i(_e2, d2(O));
  };
  function tt(O) {
    return de(O) || O.type === "NewExpression" || O.type === "ImportExpression";
  }
  function Ve2(O) {
    return O && (O.type === "ObjectProperty" || O.type === "Property" && !O.method && O.kind === "init");
  }
  function We2(O) {
    return Boolean(O.__isUsingHackPipeline);
  }
  var Xe = Symbol("ifWithoutBlockAndSameLineComment");
  function st2(O) {
    return O.type === "TSAsExpression" || O.type === "TSSatisfiesExpression";
  }
  r.exports = { getFunctionParameters: ve2, iterateFunctionParametersPath: ze, getCallArguments: Ye2, iterateCallArgumentsPath: Se2, hasRestParameter: Ce2, getLeftSide: I2, getLeftSidePathName: P, getParentExportDeclaration: m, getTypeScriptMappedTypeModifier: z, hasFlowAnnotationComment: F, hasFlowShorthandAnnotationComment: w, hasLeadingOwnLineComment: Z, hasNakedLeftSide: x, hasNode: N2, hasIgnoreComment: Je2, hasNodeIgnoreComment: Oe2, identity: H, isBinaryish: V, isCallLikeExpression: tt, isEnabledHackPipeline: We2, isLineComment: D, isPrettierIgnoreComment: Ie2, isCallExpression: de, isMemberExpression: ue2, isExportDeclaration: T, isFlowAnnotationComment: U2, isFunctionCompositionArgs: Re2, isFunctionNotation: J, isFunctionOrArrowExpression: b, isGetterOrSetter: q, isJestEachTemplateLiteral: ge2, isJsxNode: M2, isLiteral: C, isLongCurriedCallExpression: Ne2, isSimpleCallArgument: Pe2, isMemberish: j, isNumericLiteral: o, isSignedNumericLiteral: h, isObjectProperty: Ve2, isObjectType: S, isObjectTypePropertyAFunction: L, isSimpleType: ie2, isSimpleNumber: fe2, isSimpleTemplateLiteral: Fe2, isStringLiteral: v2, isStringPropSafeToUnquote: se2, isTemplateOnItsOwnLine: we2, isTestCall: K2, isTheOnlyJsxElementInMarkdown: R2, isTSXFile: pe2, isTypeAnnotationAFunction: Q, isNextLineEmpty: nt, needsHardlineAfterDanglingComment: ke2, rawText: oe, shouldPrintComma: X, isBitwiseOperator: ye2, shouldFlatten: A, startsWithNoLookaheadToken: le2, getPrecedence: re, hasComment: Me2, getComments: ae2, CommentCheckFlags: be2, markerForIfWithoutBlockAndSameLineComment: Xe, isTSTypeExpression: st2 };
} }), Lt$2 = te$1({ "src/language-js/print/template-literal.js"(e, r) {
  ne();
  var t = lt$1(), { getStringWidth: s, getIndentSize: a } = Ue$2(), { builders: { join: n, hardline: u, softline: i, group: l, indent: p, align: d2, lineSuffixBoundary: y2, addAlignmentToDoc: g2 }, printer: { printDocToString: c }, utils: { mapDoc: f } } = qe(), { isBinaryish: E, isJestEachTemplateLiteral: _, isSimpleTemplateLiteral: w, hasComment: F, isMemberExpression: N2, isTSTypeExpression: x } = Ke$1();
  function I2(C, o, h) {
    let v2 = C.getValue();
    if (v2.type === "TemplateLiteral" && _(v2, C.getParentNode())) {
      let R2 = P(C, h, o);
      if (R2)
        return R2;
    }
    let b = "expressions";
    v2.type === "TSTemplateLiteralType" && (b = "types");
    let B = [], k = C.map(o, b), M2 = w(v2);
    return M2 && (k = k.map((R2) => c(R2, Object.assign(Object.assign({}, h), {}, { printWidth: Number.POSITIVE_INFINITY })).formatted)), B.push(y2, "`"), C.each((R2) => {
      let q = R2.getName();
      if (B.push(o()), q < k.length) {
        let { tabWidth: J } = h, L = R2.getValue(), Q = a(L.value.raw, J), V = k[q];
        if (!M2) {
          let Y = v2[b][q];
          (F(Y) || N2(Y) || Y.type === "ConditionalExpression" || Y.type === "SequenceExpression" || x(Y) || E(Y)) && (V = [p([i, V]), i]);
        }
        let j = Q === 0 && L.value.raw.endsWith(`
`) ? d2(Number.NEGATIVE_INFINITY, V) : g2(V, Q, J);
        B.push(l(["${", j, y2, "}"]));
      }
    }, "quasis"), B.push("`"), B;
  }
  function P(C, o, h) {
    let v2 = C.getNode(), S = v2.quasis[0].value.raw.trim().split(/\s*\|\s*/);
    if (S.length > 1 || S.some((b) => b.length > 0)) {
      o.__inJestEach = true;
      let b = C.map(h, "expressions");
      o.__inJestEach = false;
      let B = [], k = b.map((L) => "${" + c(L, Object.assign(Object.assign({}, o), {}, { printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" })).formatted + "}"), M2 = [{ hasLineBreak: false, cells: [] }];
      for (let L = 1; L < v2.quasis.length; L++) {
        let Q = t(M2), V = k[L - 1];
        Q.cells.push(V), V.includes(`
`) && (Q.hasLineBreak = true), v2.quasis[L].value.raw.includes(`
`) && M2.push({ hasLineBreak: false, cells: [] });
      }
      let R2 = Math.max(S.length, ...M2.map((L) => L.cells.length)), q = Array.from({ length: R2 }).fill(0), J = [{ cells: S }, ...M2.filter((L) => L.cells.length > 0)];
      for (let { cells: L } of J.filter((Q) => !Q.hasLineBreak))
        for (let [Q, V] of L.entries())
          q[Q] = Math.max(q[Q], s(V));
      return B.push(y2, "`", p([u, n(u, J.map((L) => n(" | ", L.cells.map((Q, V) => L.hasLineBreak ? Q : Q + " ".repeat(q[V] - s(Q))))))]), u, "`"), B;
    }
  }
  function $2(C, o) {
    let h = C.getValue(), v2 = o();
    return F(h) && (v2 = l([p([i, v2]), i])), ["${", v2, y2, "}"];
  }
  function D(C, o) {
    return C.map((h) => $2(h, o), "expressions");
  }
  function T(C, o) {
    return f(C, (h) => typeof h == "string" ? o ? h.replace(/(\\*)`/g, "$1$1\\`") : m(h) : h);
  }
  function m(C) {
    return C.replace(/([\\`]|\${)/g, "\\$1");
  }
  r.exports = { printTemplateLiteral: I2, printTemplateExpressions: D, escapeTemplateCharacters: T, uncookTemplateElementValue: m };
} }), Vm = te$1({ "src/language-js/embed/markdown.js"(e, r) {
  ne();
  var { builders: { indent: t, softline: s, literalline: a, dedentToRoot: n } } = qe(), { escapeTemplateCharacters: u } = Lt$2();
  function i(p, d2, y2) {
    let c = p.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (w, F) => "\\".repeat(F.length / 2) + "`"), f = l(c), E = f !== "";
    E && (c = c.replace(new RegExp(`^${f}`, "gm"), ""));
    let _ = u(y2(c, { parser: "markdown", __inJsTemplate: true }, { stripTrailingHardline: true }), true);
    return ["`", E ? t([s, _]) : [a, n(_)], s, "`"];
  }
  function l(p) {
    let d2 = p.match(/^([^\S\n]*)\S/m);
    return d2 === null ? "" : d2[1];
  }
  r.exports = i;
} }), Wm = te$1({ "src/language-js/embed/css.js"(e, r) {
  ne();
  var { isNonEmptyArray: t } = Ue$2(), { builders: { indent: s, hardline: a, softline: n }, utils: { mapDoc: u, replaceEndOfLine: i, cleanDoc: l } } = qe(), { printTemplateExpressions: p } = Lt$2();
  function d2(c, f, E) {
    let _ = c.getValue(), w = _.quasis.map((P) => P.value.raw), F = 0, N2 = w.reduce((P, $2, D) => D === 0 ? $2 : P + "@prettier-placeholder-" + F++ + "-id" + $2, ""), x = E(N2, { parser: "scss" }, { stripTrailingHardline: true }), I2 = p(c, f);
    return y2(x, _, I2);
  }
  function y2(c, f, E) {
    if (f.quasis.length === 1 && !f.quasis[0].value.raw.trim())
      return "``";
    let w = g2(c, E);
    if (!w)
      throw new Error("Couldn't insert all the expressions");
    return ["`", s([a, w]), n, "`"];
  }
  function g2(c, f) {
    if (!t(f))
      return c;
    let E = 0, _ = u(l(c), (w) => typeof w != "string" || !w.includes("@prettier-placeholder") ? w : w.split(/@prettier-placeholder-(\d+)-id/).map((F, N2) => N2 % 2 === 0 ? i(F) : (E++, f[F])));
    return f.length === E ? _ : null;
  }
  r.exports = d2;
} }), Hm = te$1({ "src/language-js/embed/graphql.js"(e, r) {
  ne();
  var { builders: { indent: t, join: s, hardline: a } } = qe(), { escapeTemplateCharacters: n, printTemplateExpressions: u } = Lt$2();
  function i(p, d2, y2) {
    let g2 = p.getValue(), c = g2.quasis.length;
    if (c === 1 && g2.quasis[0].value.raw.trim() === "")
      return "``";
    let f = u(p, d2), E = [];
    for (let _ = 0; _ < c; _++) {
      let w = g2.quasis[_], F = _ === 0, N2 = _ === c - 1, x = w.value.cooked, I2 = x.split(`
`), P = I2.length, $2 = f[_], D = P > 2 && I2[0].trim() === "" && I2[1].trim() === "", T = P > 2 && I2[P - 1].trim() === "" && I2[P - 2].trim() === "", m = I2.every((o) => /^\s*(?:#[^\n\r]*)?$/.test(o));
      if (!N2 && /#[^\n\r]*$/.test(I2[P - 1]))
        return null;
      let C = null;
      m ? C = l(I2) : C = y2(x, { parser: "graphql" }, { stripTrailingHardline: true }), C ? (C = n(C, false), !F && D && E.push(""), E.push(C), !N2 && T && E.push("")) : !F && !N2 && D && E.push(""), $2 && E.push($2);
    }
    return ["`", t([a, s(a, E)]), a, "`"];
  }
  function l(p) {
    let d2 = [], y2 = false, g2 = p.map((c) => c.trim());
    for (let [c, f] of g2.entries())
      f !== "" && (g2[c - 1] === "" && y2 ? d2.push([a, f]) : d2.push(f), y2 = true);
    return d2.length === 0 ? null : s(a, d2);
  }
  r.exports = i;
} }), Gm = te$1({ "src/language-js/embed/html.js"(e, r) {
  ne();
  var { builders: { indent: t, line: s, hardline: a, group: n }, utils: { mapDoc: u } } = qe(), { printTemplateExpressions: i, uncookTemplateElementValue: l } = Lt$2(), p = 0;
  function d2(y2, g2, c, f, E) {
    let { parser: _ } = E, w = y2.getValue(), F = p;
    p = p + 1 >>> 0;
    let N2 = (h) => `PRETTIER_HTML_PLACEHOLDER_${h}_${F}_IN_JS`, x = w.quasis.map((h, v2, S) => v2 === S.length - 1 ? h.value.cooked : h.value.cooked + N2(v2)).join(""), I2 = i(y2, g2);
    if (I2.length === 0 && x.trim().length === 0)
      return "``";
    let P = new RegExp(N2("(\\d+)"), "g"), $2 = 0, D = c(x, { parser: _, __onHtmlRoot(h) {
      $2 = h.children.length;
    } }, { stripTrailingHardline: true }), T = u(D, (h) => {
      if (typeof h != "string")
        return h;
      let v2 = [], S = h.split(P);
      for (let b = 0; b < S.length; b++) {
        let B = S[b];
        if (b % 2 === 0) {
          B && (B = l(B), f.__embeddedInHtml && (B = B.replace(/<\/(script)\b/gi, "<\\/$1")), v2.push(B));
          continue;
        }
        let k = Number(B);
        v2.push(I2[k]);
      }
      return v2;
    }), m = /^\s/.test(x) ? " " : "", C = /\s$/.test(x) ? " " : "", o = f.htmlWhitespaceSensitivity === "ignore" ? a : m && C ? s : null;
    return n(o ? ["`", t([o, n(T)]), o, "`"] : ["`", m, $2 > 1 ? t(n(T)) : n(T), C, "`"]);
  }
  r.exports = d2;
} }), Um = te$1({ "src/language-js/embed.js"(e, r) {
  ne();
  var { hasComment: t, CommentCheckFlags: s, isObjectProperty: a } = Ke$1(), n = Vm(), u = Wm(), i = Hm(), l = Gm();
  function p(D) {
    if (g2(D) || _(D) || w(D) || c(D))
      return "css";
    if (x(D))
      return "graphql";
    if (P(D))
      return "html";
    if (f(D))
      return "angular";
    if (y2(D))
      return "markdown";
  }
  function d2(D, T, m, C) {
    let o = D.getValue();
    if (o.type !== "TemplateLiteral" || $2(o))
      return;
    let h = p(D);
    if (h) {
      if (h === "markdown")
        return n(D, T, m);
      if (h === "css")
        return u(D, T, m);
      if (h === "graphql")
        return i(D, T, m);
      if (h === "html" || h === "angular")
        return l(D, T, m, C, { parser: h });
    }
  }
  function y2(D) {
    let T = D.getValue(), m = D.getParentNode();
    return m && m.type === "TaggedTemplateExpression" && T.quasis.length === 1 && m.tag.type === "Identifier" && (m.tag.name === "md" || m.tag.name === "markdown");
  }
  function g2(D) {
    let T = D.getValue(), m = D.getParentNode(), C = D.getParentNode(1);
    return C && T.quasis && m.type === "JSXExpressionContainer" && C.type === "JSXElement" && C.openingElement.name.name === "style" && C.openingElement.attributes.some((o) => o.name.name === "jsx") || m && m.type === "TaggedTemplateExpression" && m.tag.type === "Identifier" && m.tag.name === "css" || m && m.type === "TaggedTemplateExpression" && m.tag.type === "MemberExpression" && m.tag.object.name === "css" && (m.tag.property.name === "global" || m.tag.property.name === "resolve");
  }
  function c(D) {
    return D.match((T) => T.type === "TemplateLiteral", (T, m) => T.type === "ArrayExpression" && m === "elements", (T, m) => a(T) && T.key.type === "Identifier" && T.key.name === "styles" && m === "value", ...E);
  }
  function f(D) {
    return D.match((T) => T.type === "TemplateLiteral", (T, m) => a(T) && T.key.type === "Identifier" && T.key.name === "template" && m === "value", ...E);
  }
  var E = [(D, T) => D.type === "ObjectExpression" && T === "properties", (D, T) => D.type === "CallExpression" && D.callee.type === "Identifier" && D.callee.name === "Component" && T === "arguments", (D, T) => D.type === "Decorator" && T === "expression"];
  function _(D) {
    let T = D.getParentNode();
    if (!T || T.type !== "TaggedTemplateExpression")
      return false;
    let m = T.tag.type === "ParenthesizedExpression" ? T.tag.expression : T.tag;
    switch (m.type) {
      case "MemberExpression":
        return F(m.object) || N2(m);
      case "CallExpression":
        return F(m.callee) || m.callee.type === "MemberExpression" && (m.callee.object.type === "MemberExpression" && (F(m.callee.object.object) || N2(m.callee.object)) || m.callee.object.type === "CallExpression" && F(m.callee.object.callee));
      case "Identifier":
        return m.name === "css";
      default:
        return false;
    }
  }
  function w(D) {
    let T = D.getParentNode(), m = D.getParentNode(1);
    return m && T.type === "JSXExpressionContainer" && m.type === "JSXAttribute" && m.name.type === "JSXIdentifier" && m.name.name === "css";
  }
  function F(D) {
    return D.type === "Identifier" && D.name === "styled";
  }
  function N2(D) {
    return /^[A-Z]/.test(D.object.name) && D.property.name === "extend";
  }
  function x(D) {
    let T = D.getValue(), m = D.getParentNode();
    return I2(T, "GraphQL") || m && (m.type === "TaggedTemplateExpression" && (m.tag.type === "MemberExpression" && m.tag.object.name === "graphql" && m.tag.property.name === "experimental" || m.tag.type === "Identifier" && (m.tag.name === "gql" || m.tag.name === "graphql")) || m.type === "CallExpression" && m.callee.type === "Identifier" && m.callee.name === "graphql");
  }
  function I2(D, T) {
    return t(D, s.Block | s.Leading, (m) => {
      let { value: C } = m;
      return C === ` ${T} `;
    });
  }
  function P(D) {
    return I2(D.getValue(), "HTML") || D.match((T) => T.type === "TemplateLiteral", (T, m) => T.type === "TaggedTemplateExpression" && T.tag.type === "Identifier" && T.tag.name === "html" && m === "quasi");
  }
  function $2(D) {
    let { quasis: T } = D;
    return T.some((m) => {
      let { value: { cooked: C } } = m;
      return C === null;
    });
  }
  r.exports = d2;
} }), Jm = te$1({ "src/language-js/clean.js"(e, r) {
  ne();
  var t = _t$2(), s = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), a = (u) => {
    for (let i of u.quasis)
      delete i.value;
  };
  function n(u, i, l) {
    if (u.type === "Program" && delete i.sourceType, (u.type === "BigIntLiteral" || u.type === "BigIntLiteralTypeAnnotation") && i.value && (i.value = i.value.toLowerCase()), (u.type === "BigIntLiteral" || u.type === "Literal") && i.bigint && (i.bigint = i.bigint.toLowerCase()), u.type === "DecimalLiteral" && (i.value = Number(i.value)), u.type === "Literal" && i.decimal && (i.decimal = Number(i.decimal)), u.type === "EmptyStatement" || u.type === "JSXText" || u.type === "JSXExpressionContainer" && (u.expression.type === "Literal" || u.expression.type === "StringLiteral") && u.expression.value === " ")
      return null;
    if ((u.type === "Property" || u.type === "ObjectProperty" || u.type === "MethodDefinition" || u.type === "ClassProperty" || u.type === "ClassMethod" || u.type === "PropertyDefinition" || u.type === "TSDeclareMethod" || u.type === "TSPropertySignature" || u.type === "ObjectTypeProperty") && typeof u.key == "object" && u.key && (u.key.type === "Literal" || u.key.type === "NumericLiteral" || u.key.type === "StringLiteral" || u.key.type === "Identifier") && delete i.key, u.type === "JSXElement" && u.openingElement.name.name === "style" && u.openingElement.attributes.some((y2) => y2.name.name === "jsx"))
      for (let { type: y2, expression: g2 } of i.children)
        y2 === "JSXExpressionContainer" && g2.type === "TemplateLiteral" && a(g2);
    u.type === "JSXAttribute" && u.name.name === "css" && u.value.type === "JSXExpressionContainer" && u.value.expression.type === "TemplateLiteral" && a(i.value.expression), u.type === "JSXAttribute" && u.value && u.value.type === "Literal" && /["']|&quot;|&apos;/.test(u.value.value) && (i.value.value = i.value.value.replace(/["']|&quot;|&apos;/g, '"'));
    let p = u.expression || u.callee;
    if (u.type === "Decorator" && p.type === "CallExpression" && p.callee.name === "Component" && p.arguments.length === 1) {
      let y2 = u.expression.arguments[0].properties;
      for (let [g2, c] of i.expression.arguments[0].properties.entries())
        switch (y2[g2].key.name) {
          case "styles":
            c.value.type === "ArrayExpression" && a(c.value.elements[0]);
            break;
          case "template":
            c.value.type === "TemplateLiteral" && a(c.value);
            break;
        }
    }
    if (u.type === "TaggedTemplateExpression" && (u.tag.type === "MemberExpression" || u.tag.type === "Identifier" && (u.tag.name === "gql" || u.tag.name === "graphql" || u.tag.name === "css" || u.tag.name === "md" || u.tag.name === "markdown" || u.tag.name === "html") || u.tag.type === "CallExpression") && a(i.quasi), u.type === "TemplateLiteral") {
      var d2;
      (((d2 = u.leadingComments) === null || d2 === void 0 ? void 0 : d2.some((g2) => t(g2) && ["GraphQL", "HTML"].some((c) => g2.value === ` ${c} `))) || l.type === "CallExpression" && l.callee.name === "graphql" || !u.leadingComments) && a(i);
    }
    if (u.type === "InterpreterDirective" && (i.value = i.value.trimEnd()), (u.type === "TSIntersectionType" || u.type === "TSUnionType") && u.types.length === 1)
      return i.types[0];
  }
  n.ignoredProperties = s, r.exports = n;
} }), Qa$1 = {};
zt$1(Qa$1, { EOL: () => Rn$3, arch: () => zm, cpus: () => so$1, default: () => co$2, endianness: () => Za, freemem: () => no$1, getNetworkInterfaces: () => lo$2, hostname: () => eo$1, loadavg: () => to$2, networkInterfaces: () => oo$2, platform: () => Xm, release: () => ao$2, tmpDir: () => qn$1, tmpdir: () => Mn$3, totalmem: () => uo$2, type: () => io$1, uptime: () => ro$1 });
function Za() {
  if (typeof xr$2 > "u") {
    var e = new ArrayBuffer(2), r = new Uint8Array(e), t = new Uint16Array(e);
    if (r[0] = 1, r[1] = 2, t[0] === 258)
      xr$2 = "BE";
    else if (t[0] === 513)
      xr$2 = "LE";
    else
      throw new Error("unable to figure out endianess");
  }
  return xr$2;
}
function eo$1() {
  return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
}
function to$2() {
  return [];
}
function ro$1() {
  return 0;
}
function no$1() {
  return Number.MAX_VALUE;
}
function uo$2() {
  return Number.MAX_VALUE;
}
function so$1() {
  return [];
}
function io$1() {
  return "Browser";
}
function ao$2() {
  return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
}
function oo$2() {
}
function lo$2() {
}
function zm() {
  return "javascript";
}
function Xm() {
  return "browser";
}
function qn$1() {
  return "/tmp";
}
var xr$2, Mn$3, Rn$3, co$2, Km = ht$1({ "node-modules-polyfills:os"() {
  ne(), Mn$3 = qn$1, Rn$3 = `
`, co$2 = { EOL: Rn$3, tmpdir: Mn$3, tmpDir: qn$1, networkInterfaces: oo$2, getNetworkInterfaces: lo$2, release: ao$2, type: io$1, cpus: so$1, totalmem: uo$2, freemem: no$1, uptime: ro$1, loadavg: to$2, hostname: eo$1, endianness: Za };
} }), Ym = te$1({ "node-modules-polyfills-commonjs:os"(e, r) {
  ne();
  var t = (Km(), ft$2(Qa$1));
  if (t && t.default) {
    r.exports = t.default;
    for (let s in t)
      r.exports[s] = t[s];
  } else
    t && (r.exports = t);
} }), Qm = te$1({ "node_modules/detect-newline/index.js"(e, r) {
  ne();
  var t = (s) => {
    if (typeof s != "string")
      throw new TypeError("Expected a string");
    let a = s.match(/(?:\r?\n)/g) || [];
    if (a.length === 0)
      return;
    let n = a.filter((i) => i === `\r
`).length, u = a.length - n;
    return n > u ? `\r
` : `
`;
  };
  r.exports = t, r.exports.graceful = (s) => typeof s == "string" && t(s) || `
`;
} }), Zm = te$1({ "node_modules/jest-docblock/build/index.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true }), e.extract = c, e.parse = E, e.parseWithComments = _, e.print = w, e.strip = f;
  function r() {
    let N2 = Ym();
    return r = function() {
      return N2;
    }, N2;
  }
  function t() {
    let N2 = s(Qm());
    return t = function() {
      return N2;
    }, N2;
  }
  function s(N2) {
    return N2 && N2.__esModule ? N2 : { default: N2 };
  }
  var a = /\*\/$/, n = /^\/\*\*?/, u = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, i = /(^|\s+)\/\/([^\r\n]*)/g, l = /^(\r?\n)+/, p = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, d2 = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, y2 = /(\r?\n|^) *\* ?/g, g2 = [];
  function c(N2) {
    let x = N2.match(u);
    return x ? x[0].trimLeft() : "";
  }
  function f(N2) {
    let x = N2.match(u);
    return x && x[0] ? N2.substring(x[0].length) : N2;
  }
  function E(N2) {
    return _(N2).pragmas;
  }
  function _(N2) {
    let x = (0, t().default)(N2) || r().EOL;
    N2 = N2.replace(n, "").replace(a, "").replace(y2, "$1");
    let I2 = "";
    for (; I2 !== N2; )
      I2 = N2, N2 = N2.replace(p, `${x}$1 $2${x}`);
    N2 = N2.replace(l, "").trimRight();
    let P = /* @__PURE__ */ Object.create(null), $2 = N2.replace(d2, "").replace(l, "").trimRight(), D;
    for (; D = d2.exec(N2); ) {
      let T = D[2].replace(i, "");
      typeof P[D[1]] == "string" || Array.isArray(P[D[1]]) ? P[D[1]] = g2.concat(P[D[1]], T) : P[D[1]] = T;
    }
    return { comments: $2, pragmas: P };
  }
  function w(N2) {
    let { comments: x = "", pragmas: I2 = {} } = N2, P = (0, t().default)(x) || r().EOL, $2 = "/**", D = " *", T = " */", m = Object.keys(I2), C = m.map((h) => F(h, I2[h])).reduce((h, v2) => h.concat(v2), []).map((h) => `${D} ${h}${P}`).join("");
    if (!x) {
      if (m.length === 0)
        return "";
      if (m.length === 1 && !Array.isArray(I2[m[0]])) {
        let h = I2[m[0]];
        return `${$2} ${F(m[0], h)[0]}${T}`;
      }
    }
    let o = x.split(P).map((h) => `${D} ${h}`).join(P) + P;
    return $2 + P + (x ? o : "") + (x && m.length ? D + P : "") + C + T;
  }
  function F(N2, x) {
    return g2.concat(x).map((I2) => `@${N2} ${I2}`.trim());
  }
} }), ed = te$1({ "src/language-js/utils/get-shebang.js"(e, r) {
  ne();
  function t(s) {
    if (!s.startsWith("#!"))
      return "";
    let a = s.indexOf(`
`);
    return a === -1 ? s : s.slice(0, a);
  }
  r.exports = t;
} }), po$2 = te$1({ "src/language-js/pragma.js"(e, r) {
  ne();
  var { parseWithComments: t, strip: s, extract: a, print: n } = Zm(), { normalizeEndOfLine: u } = Hn(), i = ed();
  function l(y2) {
    let g2 = i(y2);
    g2 && (y2 = y2.slice(g2.length + 1));
    let c = a(y2), { pragmas: f, comments: E } = t(c);
    return { shebang: g2, text: y2, pragmas: f, comments: E };
  }
  function p(y2) {
    let g2 = Object.keys(l(y2).pragmas);
    return g2.includes("prettier") || g2.includes("format");
  }
  function d2(y2) {
    let { shebang: g2, text: c, pragmas: f, comments: E } = l(y2), _ = s(c), w = n({ pragmas: Object.assign({ format: "" }, f), comments: E.trimStart() });
    return (g2 ? `${g2}
` : "") + u(w) + (_.startsWith(`
`) ? `
` : `

`) + _;
  }
  r.exports = { hasPragma: p, insertPragma: d2 };
} }), td = te$1({ "src/language-js/utils/is-type-cast-comment.js"(e, r) {
  ne();
  var t = _t$2();
  function s(a) {
    return t(a) && a.value[0] === "*" && /@(?:type|satisfies)\b/.test(a.value);
  }
  r.exports = s;
} }), fo$2 = te$1({ "src/language-js/comments.js"(e, r) {
  ne();
  var { getLast: t, hasNewline: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: a, getNextNonSpaceNonCommentCharacter: n, hasNewlineInRange: u, addLeadingComment: i, addTrailingComment: l, addDanglingComment: p, getNextNonSpaceNonCommentCharacterIndex: d2, isNonEmptyArray: y2 } = Ue$2(), { getFunctionParameters: g2, isPrettierIgnoreComment: c, isJsxNode: f, hasFlowShorthandAnnotationComment: E, hasFlowAnnotationComment: _, hasIgnoreComment: w, isCallLikeExpression: F, getCallArguments: N2, isCallExpression: x, isMemberExpression: I2, isObjectProperty: P, isLineComment: $2, getComments: D, CommentCheckFlags: T, markerForIfWithoutBlockAndSameLineComment: m } = Ke$1(), { locStart: C, locEnd: o } = ut$1(), h = _t$2(), v2 = td();
  function S(De2) {
    return [H, Fe2, Q, q, J, L, ie2, he2, se2, ge2, we2, ke2, ce2, z, U2].some((A) => A(De2));
  }
  function b(De2) {
    return [R2, Fe2, V, we2, q, J, L, ie2, z, Z, fe2, ge2, Pe2, U2, X].some((A) => A(De2));
  }
  function B(De2) {
    return [H, q, J, j, ue2, ce2, ge2, de, K2, pe2, U2, oe].some((A) => A(De2));
  }
  function k(De2, A) {
    let G = (De2.body || De2.properties).find((re) => {
      let { type: ye2 } = re;
      return ye2 !== "EmptyStatement";
    });
    G ? i(G, A) : p(De2, A);
  }
  function M2(De2, A) {
    De2.type === "BlockStatement" ? k(De2, A) : i(De2, A);
  }
  function R2(De2) {
    let { comment: A, followingNode: G } = De2;
    return G && v2(A) ? (i(G, A), true) : false;
  }
  function q(De2) {
    let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye2, text: Ce2 } = De2;
    if ((re == null ? void 0 : re.type) !== "IfStatement" || !ye2)
      return false;
    if (n(Ce2, A, o) === ")")
      return l(G, A), true;
    if (G === re.consequent && ye2 === re.alternate) {
      if (G.type === "BlockStatement")
        l(G, A);
      else {
        let ve2 = A.type === "SingleLine" || A.loc.start.line === A.loc.end.line, ze = A.loc.start.line === G.loc.start.line;
        ve2 && ze ? p(G, A, m) : p(re, A);
      }
      return true;
    }
    return ye2.type === "BlockStatement" ? (k(ye2, A), true) : ye2.type === "IfStatement" ? (M2(ye2.consequent, A), true) : re.consequent === ye2 ? (i(ye2, A), true) : false;
  }
  function J(De2) {
    let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye2, text: Ce2 } = De2;
    return (re == null ? void 0 : re.type) !== "WhileStatement" || !ye2 ? false : n(Ce2, A, o) === ")" ? (l(G, A), true) : ye2.type === "BlockStatement" ? (k(ye2, A), true) : re.body === ye2 ? (i(ye2, A), true) : false;
  }
  function L(De2) {
    let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye2 } = De2;
    return (re == null ? void 0 : re.type) !== "TryStatement" && (re == null ? void 0 : re.type) !== "CatchClause" || !ye2 ? false : re.type === "CatchClause" && G ? (l(G, A), true) : ye2.type === "BlockStatement" ? (k(ye2, A), true) : ye2.type === "TryStatement" ? (M2(ye2.finalizer, A), true) : ye2.type === "CatchClause" ? (M2(ye2.body, A), true) : false;
  }
  function Q(De2) {
    let { comment: A, enclosingNode: G, followingNode: re } = De2;
    return I2(G) && (re == null ? void 0 : re.type) === "Identifier" ? (i(G, A), true) : false;
  }
  function V(De2) {
    let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye2, text: Ce2 } = De2, Be = G && !u(Ce2, o(G), C(A));
    return (!G || !Be) && ((re == null ? void 0 : re.type) === "ConditionalExpression" || (re == null ? void 0 : re.type) === "TSConditionalType") && ye2 ? (i(ye2, A), true) : false;
  }
  function j(De2) {
    let { comment: A, precedingNode: G, enclosingNode: re } = De2;
    return P(re) && re.shorthand && re.key === G && re.value.type === "AssignmentPattern" ? (l(re.value.left, A), true) : false;
  }
  var Y = /* @__PURE__ */ new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
  function ie2(De2) {
    let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye2 } = De2;
    if (Y.has(re == null ? void 0 : re.type)) {
      if (y2(re.decorators) && !(ye2 && ye2.type === "Decorator"))
        return l(t(re.decorators), A), true;
      if (re.body && ye2 === re.body)
        return k(re.body, A), true;
      if (ye2) {
        if (re.superClass && ye2 === re.superClass && G && (G === re.id || G === re.typeParameters))
          return l(G, A), true;
        for (let Ce2 of ["implements", "extends", "mixins"])
          if (re[Ce2] && ye2 === re[Ce2][0])
            return G && (G === re.id || G === re.typeParameters || G === re.superClass) ? l(G, A) : p(re, A, Ce2), true;
      }
    }
    return false;
  }
  var ee2 = /* @__PURE__ */ new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty"]);
  function ce2(De2) {
    let { comment: A, precedingNode: G, enclosingNode: re, text: ye2 } = De2;
    return re && G && n(ye2, A, o) === "(" && (re.type === "Property" || re.type === "TSDeclareMethod" || re.type === "TSAbstractMethodDefinition") && G.type === "Identifier" && re.key === G && n(ye2, G, o) !== ":" || (G == null ? void 0 : G.type) === "Decorator" && ee2.has(re == null ? void 0 : re.type) ? (l(G, A), true) : false;
  }
  var W = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
  function K2(De2) {
    let { comment: A, precedingNode: G, enclosingNode: re, text: ye2 } = De2;
    return n(ye2, A, o) !== "(" ? false : G && W.has(re == null ? void 0 : re.type) ? (l(G, A), true) : false;
  }
  function de(De2) {
    let { comment: A, enclosingNode: G, text: re } = De2;
    if ((G == null ? void 0 : G.type) !== "ArrowFunctionExpression")
      return false;
    let ye2 = d2(re, A, o);
    return ye2 !== false && re.slice(ye2, ye2 + 2) === "=>" ? (p(G, A), true) : false;
  }
  function ue2(De2) {
    let { comment: A, enclosingNode: G, text: re } = De2;
    return n(re, A, o) !== ")" ? false : G && (le2(G) && g2(G).length === 0 || F(G) && N2(G).length === 0) ? (p(G, A), true) : ((G == null ? void 0 : G.type) === "MethodDefinition" || (G == null ? void 0 : G.type) === "TSAbstractMethodDefinition") && g2(G.value).length === 0 ? (p(G.value, A), true) : false;
  }
  function Fe2(De2) {
    let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye2, text: Ce2 } = De2;
    if ((G == null ? void 0 : G.type) === "FunctionTypeParam" && (re == null ? void 0 : re.type) === "FunctionTypeAnnotation" && (ye2 == null ? void 0 : ye2.type) !== "FunctionTypeParam" || ((G == null ? void 0 : G.type) === "Identifier" || (G == null ? void 0 : G.type) === "AssignmentPattern") && re && le2(re) && n(Ce2, A, o) === ")")
      return l(G, A), true;
    if ((re == null ? void 0 : re.type) === "FunctionDeclaration" && (ye2 == null ? void 0 : ye2.type) === "BlockStatement") {
      let Be = (() => {
        let ve2 = g2(re);
        if (ve2.length > 0)
          return a(Ce2, o(t(ve2)));
        let ze = a(Ce2, o(re.id));
        return ze !== false && a(Ce2, ze + 1);
      })();
      if (C(A) > Be)
        return k(ye2, A), true;
    }
    return false;
  }
  function z(De2) {
    let { comment: A, enclosingNode: G } = De2;
    return (G == null ? void 0 : G.type) === "LabeledStatement" ? (i(G, A), true) : false;
  }
  function U2(De2) {
    let { comment: A, enclosingNode: G } = De2;
    return ((G == null ? void 0 : G.type) === "ContinueStatement" || (G == null ? void 0 : G.type) === "BreakStatement") && !G.label ? (l(G, A), true) : false;
  }
  function Z(De2) {
    let { comment: A, precedingNode: G, enclosingNode: re } = De2;
    return x(re) && G && re.callee === G && re.arguments.length > 0 ? (i(re.arguments[0], A), true) : false;
  }
  function se2(De2) {
    let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye2 } = De2;
    return (re == null ? void 0 : re.type) === "UnionTypeAnnotation" || (re == null ? void 0 : re.type) === "TSUnionType" ? (c(A) && (ye2.prettierIgnore = true, A.unignore = true), G ? (l(G, A), true) : false) : (((ye2 == null ? void 0 : ye2.type) === "UnionTypeAnnotation" || (ye2 == null ? void 0 : ye2.type) === "TSUnionType") && c(A) && (ye2.types[0].prettierIgnore = true, A.unignore = true), false);
  }
  function fe2(De2) {
    let { comment: A, enclosingNode: G } = De2;
    return P(G) ? (i(G, A), true) : false;
  }
  function ge2(De2) {
    let { comment: A, enclosingNode: G, followingNode: re, ast: ye2, isLastComment: Ce2 } = De2;
    return ye2 && ye2.body && ye2.body.length === 0 ? (Ce2 ? p(ye2, A) : i(ye2, A), true) : (G == null ? void 0 : G.type) === "Program" && (G == null ? void 0 : G.body.length) === 0 && !y2(G.directives) ? (Ce2 ? p(G, A) : i(G, A), true) : (re == null ? void 0 : re.type) === "Program" && (re == null ? void 0 : re.body.length) === 0 && (G == null ? void 0 : G.type) === "ModuleExpression" ? (p(re, A), true) : false;
  }
  function he2(De2) {
    let { comment: A, enclosingNode: G } = De2;
    return (G == null ? void 0 : G.type) === "ForInStatement" || (G == null ? void 0 : G.type) === "ForOfStatement" ? (i(G, A), true) : false;
  }
  function we2(De2) {
    let { comment: A, precedingNode: G, enclosingNode: re, text: ye2 } = De2;
    if ((re == null ? void 0 : re.type) === "ImportSpecifier" || (re == null ? void 0 : re.type) === "ExportSpecifier")
      return i(re, A), true;
    let Ce2 = (G == null ? void 0 : G.type) === "ImportSpecifier" && (re == null ? void 0 : re.type) === "ImportDeclaration", Be = (G == null ? void 0 : G.type) === "ExportSpecifier" && (re == null ? void 0 : re.type) === "ExportNamedDeclaration";
    return (Ce2 || Be) && s(ye2, o(A)) ? (l(G, A), true) : false;
  }
  function ke2(De2) {
    let { comment: A, enclosingNode: G } = De2;
    return (G == null ? void 0 : G.type) === "AssignmentPattern" ? (i(G, A), true) : false;
  }
  var Re2 = /* @__PURE__ */ new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]), Ne2 = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
  function Pe2(De2) {
    let { comment: A, enclosingNode: G, followingNode: re } = De2;
    return Re2.has(G == null ? void 0 : G.type) && re && (Ne2.has(re.type) || h(A)) ? (i(re, A), true) : false;
  }
  function oe(De2) {
    let { comment: A, enclosingNode: G, followingNode: re, text: ye2 } = De2;
    return !re && ((G == null ? void 0 : G.type) === "TSMethodSignature" || (G == null ? void 0 : G.type) === "TSDeclareFunction" || (G == null ? void 0 : G.type) === "TSAbstractMethodDefinition") && n(ye2, A, o) === ";" ? (l(G, A), true) : false;
  }
  function H(De2) {
    let { comment: A, enclosingNode: G, followingNode: re } = De2;
    if (c(A) && (G == null ? void 0 : G.type) === "TSMappedType" && (re == null ? void 0 : re.type) === "TSTypeParameter" && re.constraint)
      return G.prettierIgnore = true, A.unignore = true, true;
  }
  function pe2(De2) {
    let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye2 } = De2;
    return (re == null ? void 0 : re.type) !== "TSMappedType" ? false : (ye2 == null ? void 0 : ye2.type) === "TSTypeParameter" && ye2.name ? (i(ye2.name, A), true) : (G == null ? void 0 : G.type) === "TSTypeParameter" && G.constraint ? (l(G.constraint, A), true) : false;
  }
  function X(De2) {
    let { comment: A, enclosingNode: G, followingNode: re } = De2;
    return !G || G.type !== "SwitchCase" || G.test || !re || re !== G.consequent[0] ? false : (re.type === "BlockStatement" && $2(A) ? k(re, A) : p(G, A), true);
  }
  function le2(De2) {
    return De2.type === "ArrowFunctionExpression" || De2.type === "FunctionExpression" || De2.type === "FunctionDeclaration" || De2.type === "ObjectMethod" || De2.type === "ClassMethod" || De2.type === "TSDeclareFunction" || De2.type === "TSCallSignatureDeclaration" || De2.type === "TSConstructSignatureDeclaration" || De2.type === "TSMethodSignature" || De2.type === "TSConstructorType" || De2.type === "TSFunctionType" || De2.type === "TSDeclareMethod";
  }
  function Ae2(De2, A) {
    if ((A.parser === "typescript" || A.parser === "flow" || A.parser === "acorn" || A.parser === "espree" || A.parser === "meriyah" || A.parser === "__babel_estree") && De2.type === "MethodDefinition" && De2.value && De2.value.type === "FunctionExpression" && g2(De2.value).length === 0 && !De2.value.returnType && !y2(De2.value.typeParameters) && De2.value.body)
      return [...De2.decorators || [], De2.key, De2.value.body];
  }
  function Ee(De2) {
    let A = De2.getValue(), G = De2.getParentNode(), re = (ye2) => _(D(ye2, T.Leading)) || _(D(ye2, T.Trailing));
    return (A && (f(A) || E(A) || x(G) && re(A)) || G && (G.type === "JSXSpreadAttribute" || G.type === "JSXSpreadChild" || G.type === "UnionTypeAnnotation" || G.type === "TSUnionType" || (G.type === "ClassDeclaration" || G.type === "ClassExpression") && G.superClass === A)) && (!w(De2) || G.type === "UnionTypeAnnotation" || G.type === "TSUnionType");
  }
  r.exports = { handleOwnLineComment: S, handleEndOfLineComment: b, handleRemainingComment: B, getCommentChildNodes: Ae2, willPrintOwnComments: Ee };
} }), Ot$1 = te$1({ "src/language-js/needs-parens.js"(e, r) {
  ne();
  var t = lt$1(), s = Jn$1(), { getFunctionParameters: a, getLeftSidePathName: n, hasFlowShorthandAnnotationComment: u, hasNakedLeftSide: i, hasNode: l, isBitwiseOperator: p, startsWithNoLookaheadToken: d2, shouldFlatten: y2, getPrecedence: g2, isCallExpression: c, isMemberExpression: f, isObjectProperty: E, isTSTypeExpression: _ } = Ke$1();
  function w(D, T) {
    let m = D.getParentNode();
    if (!m)
      return false;
    let C = D.getName(), o = D.getNode();
    if (T.__isInHtmlInterpolation && !T.bracketSpacing && I2(o) && P(D))
      return true;
    if (F(o))
      return false;
    if (T.parser !== "flow" && u(D.getValue()))
      return true;
    if (o.type === "Identifier") {
      if (o.extra && o.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(o.name) || C === "left" && (o.name === "async" && !m.await || o.name === "let") && m.type === "ForOfStatement")
        return true;
      if (o.name === "let") {
        var h;
        let S = (h = D.findAncestor((b) => b.type === "ForOfStatement")) === null || h === void 0 ? void 0 : h.left;
        if (S && d2(S, (b) => b === o))
          return true;
      }
      if (C === "object" && o.name === "let" && m.type === "MemberExpression" && m.computed && !m.optional) {
        let S = D.findAncestor((B) => B.type === "ExpressionStatement" || B.type === "ForStatement" || B.type === "ForInStatement"), b = S ? S.type === "ExpressionStatement" ? S.expression : S.type === "ForStatement" ? S.init : S.left : void 0;
        if (b && d2(b, (B) => B === o))
          return true;
      }
      return false;
    }
    if (o.type === "ObjectExpression" || o.type === "FunctionExpression" || o.type === "ClassExpression" || o.type === "DoExpression") {
      var v2;
      let S = (v2 = D.findAncestor((b) => b.type === "ExpressionStatement")) === null || v2 === void 0 ? void 0 : v2.expression;
      if (S && d2(S, (b) => b === o))
        return true;
    }
    switch (m.type) {
      case "ParenthesizedExpression":
        return false;
      case "ClassDeclaration":
      case "ClassExpression": {
        if (C === "superClass" && (o.type === "ArrowFunctionExpression" || o.type === "AssignmentExpression" || o.type === "AwaitExpression" || o.type === "BinaryExpression" || o.type === "ConditionalExpression" || o.type === "LogicalExpression" || o.type === "NewExpression" || o.type === "ObjectExpression" || o.type === "SequenceExpression" || o.type === "TaggedTemplateExpression" || o.type === "UnaryExpression" || o.type === "UpdateExpression" || o.type === "YieldExpression" || o.type === "TSNonNullExpression"))
          return true;
        break;
      }
      case "ExportDefaultDeclaration":
        return $2(D, T) || o.type === "SequenceExpression";
      case "Decorator": {
        if (C === "expression") {
          if (f(o) && o.computed)
            return true;
          let S = false, b = false, B = o;
          for (; B; )
            switch (B.type) {
              case "MemberExpression":
                b = true, B = B.object;
                break;
              case "CallExpression":
                if (b || S)
                  return T.parser !== "typescript";
                S = true, B = B.callee;
                break;
              case "Identifier":
                return false;
              case "TaggedTemplateExpression":
                return T.parser !== "typescript";
              default:
                return true;
            }
          return true;
        }
        break;
      }
      case "ArrowFunctionExpression": {
        if (C === "body" && o.type !== "SequenceExpression" && d2(o, (S) => S.type === "ObjectExpression"))
          return true;
        break;
      }
    }
    switch (o.type) {
      case "UpdateExpression":
        if (m.type === "UnaryExpression")
          return o.prefix && (o.operator === "++" && m.operator === "+" || o.operator === "--" && m.operator === "-");
      case "UnaryExpression":
        switch (m.type) {
          case "UnaryExpression":
            return o.operator === m.operator && (o.operator === "+" || o.operator === "-");
          case "BindExpression":
            return true;
          case "MemberExpression":
          case "OptionalMemberExpression":
            return C === "object";
          case "TaggedTemplateExpression":
            return true;
          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return C === "callee";
          case "BinaryExpression":
            return C === "left" && m.operator === "**";
          case "TSNonNullExpression":
            return true;
          default:
            return false;
        }
      case "BinaryExpression": {
        if (m.type === "UpdateExpression" || o.operator === "in" && N2(D))
          return true;
        if (o.operator === "|>" && o.extra && o.extra.parenthesized) {
          let S = D.getParentNode(1);
          if (S.type === "BinaryExpression" && S.operator === "|>")
            return true;
        }
      }
      case "TSTypeAssertion":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "LogicalExpression":
        switch (m.type) {
          case "TSSatisfiesExpression":
          case "TSAsExpression":
            return !_(o);
          case "ConditionalExpression":
            return _(o);
          case "CallExpression":
          case "NewExpression":
          case "OptionalCallExpression":
            return C === "callee";
          case "ClassExpression":
          case "ClassDeclaration":
            return C === "superClass";
          case "TSTypeAssertion":
          case "TaggedTemplateExpression":
          case "UnaryExpression":
          case "JSXSpreadAttribute":
          case "SpreadElement":
          case "SpreadProperty":
          case "BindExpression":
          case "AwaitExpression":
          case "TSNonNullExpression":
          case "UpdateExpression":
            return true;
          case "MemberExpression":
          case "OptionalMemberExpression":
            return C === "object";
          case "AssignmentExpression":
          case "AssignmentPattern":
            return C === "left" && (o.type === "TSTypeAssertion" || _(o));
          case "LogicalExpression":
            if (o.type === "LogicalExpression")
              return m.operator !== o.operator;
          case "BinaryExpression": {
            let { operator: S, type: b } = o;
            if (!S && b !== "TSTypeAssertion")
              return true;
            let B = g2(S), k = m.operator, M2 = g2(k);
            return M2 > B || C === "right" && M2 === B || M2 === B && !y2(k, S) ? true : M2 < B && S === "%" ? k === "+" || k === "-" : !!p(k);
          }
          default:
            return false;
        }
      case "SequenceExpression":
        switch (m.type) {
          case "ReturnStatement":
            return false;
          case "ForStatement":
            return false;
          case "ExpressionStatement":
            return C !== "expression";
          case "ArrowFunctionExpression":
            return C !== "body";
          default:
            return true;
        }
      case "YieldExpression":
        if (m.type === "UnaryExpression" || m.type === "AwaitExpression" || _(m) || m.type === "TSNonNullExpression")
          return true;
      case "AwaitExpression":
        switch (m.type) {
          case "TaggedTemplateExpression":
          case "UnaryExpression":
          case "LogicalExpression":
          case "SpreadElement":
          case "SpreadProperty":
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "BindExpression":
            return true;
          case "MemberExpression":
          case "OptionalMemberExpression":
            return C === "object";
          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return C === "callee";
          case "ConditionalExpression":
            return C === "test";
          case "BinaryExpression":
            return !(!o.argument && m.operator === "|>");
          default:
            return false;
        }
      case "TSConditionalType":
      case "TSFunctionType":
      case "TSConstructorType":
        if (C === "extendsType" && m.type === "TSConditionalType") {
          if (o.type === "TSConditionalType")
            return true;
          let { typeAnnotation: S } = o.returnType || o.typeAnnotation;
          if (S.type === "TSTypePredicate" && S.typeAnnotation && (S = S.typeAnnotation.typeAnnotation), S.type === "TSInferType" && S.typeParameter.constraint)
            return true;
        }
        if (C === "checkType" && m.type === "TSConditionalType")
          return true;
      case "TSUnionType":
      case "TSIntersectionType":
        if ((m.type === "TSUnionType" || m.type === "TSIntersectionType") && m.types.length > 1 && (!o.types || o.types.length > 1))
          return true;
      case "TSInferType":
        if (o.type === "TSInferType" && m.type === "TSRestType")
          return false;
      case "TSTypeOperator":
        return m.type === "TSArrayType" || m.type === "TSOptionalType" || m.type === "TSRestType" || C === "objectType" && m.type === "TSIndexedAccessType" || m.type === "TSTypeOperator" || m.type === "TSTypeAnnotation" && D.getParentNode(1).type.startsWith("TSJSDoc");
      case "TSTypeQuery":
        return C === "objectType" && m.type === "TSIndexedAccessType" || C === "elementType" && m.type === "TSArrayType";
      case "TypeofTypeAnnotation":
        return C === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType") || C === "elementType" && m.type === "ArrayTypeAnnotation";
      case "ArrayTypeAnnotation":
        return m.type === "NullableTypeAnnotation";
      case "IntersectionTypeAnnotation":
      case "UnionTypeAnnotation":
        return m.type === "ArrayTypeAnnotation" || m.type === "NullableTypeAnnotation" || m.type === "IntersectionTypeAnnotation" || m.type === "UnionTypeAnnotation" || C === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType");
      case "NullableTypeAnnotation":
        return m.type === "ArrayTypeAnnotation" || C === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType");
      case "FunctionTypeAnnotation": {
        let S = m.type === "NullableTypeAnnotation" ? D.getParentNode(1) : m;
        return S.type === "UnionTypeAnnotation" || S.type === "IntersectionTypeAnnotation" || S.type === "ArrayTypeAnnotation" || C === "objectType" && (S.type === "IndexedAccessType" || S.type === "OptionalIndexedAccessType") || S.type === "NullableTypeAnnotation" || m.type === "FunctionTypeParam" && m.name === null && a(o).some((b) => b.typeAnnotation && b.typeAnnotation.type === "NullableTypeAnnotation");
      }
      case "OptionalIndexedAccessType":
        return C === "objectType" && m.type === "IndexedAccessType";
      case "StringLiteral":
      case "NumericLiteral":
      case "Literal":
        if (typeof o.value == "string" && m.type === "ExpressionStatement" && !m.directive) {
          let S = D.getParentNode(1);
          return S.type === "Program" || S.type === "BlockStatement";
        }
        return C === "object" && m.type === "MemberExpression" && typeof o.value == "number";
      case "AssignmentExpression": {
        let S = D.getParentNode(1);
        return C === "body" && m.type === "ArrowFunctionExpression" ? true : C === "key" && (m.type === "ClassProperty" || m.type === "PropertyDefinition") && m.computed || (C === "init" || C === "update") && m.type === "ForStatement" ? false : m.type === "ExpressionStatement" ? o.left.type === "ObjectPattern" : !(C === "key" && m.type === "TSPropertySignature" || m.type === "AssignmentExpression" || m.type === "SequenceExpression" && S && S.type === "ForStatement" && (S.init === m || S.update === m) || C === "value" && m.type === "Property" && S && S.type === "ObjectPattern" && S.properties.includes(m) || m.type === "NGChainedExpression");
      }
      case "ConditionalExpression":
        switch (m.type) {
          case "TaggedTemplateExpression":
          case "UnaryExpression":
          case "SpreadElement":
          case "SpreadProperty":
          case "BinaryExpression":
          case "LogicalExpression":
          case "NGPipeExpression":
          case "ExportDefaultDeclaration":
          case "AwaitExpression":
          case "JSXSpreadAttribute":
          case "TSTypeAssertion":
          case "TypeCastExpression":
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
            return true;
          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return C === "callee";
          case "ConditionalExpression":
            return C === "test";
          case "MemberExpression":
          case "OptionalMemberExpression":
            return C === "object";
          default:
            return false;
        }
      case "FunctionExpression":
        switch (m.type) {
          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return C === "callee";
          case "TaggedTemplateExpression":
            return true;
          default:
            return false;
        }
      case "ArrowFunctionExpression":
        switch (m.type) {
          case "BinaryExpression":
            return m.operator !== "|>" || o.extra && o.extra.parenthesized;
          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return C === "callee";
          case "MemberExpression":
          case "OptionalMemberExpression":
            return C === "object";
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "BindExpression":
          case "TaggedTemplateExpression":
          case "UnaryExpression":
          case "LogicalExpression":
          case "AwaitExpression":
          case "TSTypeAssertion":
            return true;
          case "ConditionalExpression":
            return C === "test";
          default:
            return false;
        }
      case "ClassExpression":
        if (s(o.decorators))
          return true;
        switch (m.type) {
          case "NewExpression":
            return C === "callee";
          default:
            return false;
        }
      case "OptionalMemberExpression":
      case "OptionalCallExpression": {
        let S = D.getParentNode(1);
        if (C === "object" && m.type === "MemberExpression" || C === "callee" && (m.type === "CallExpression" || m.type === "NewExpression") || m.type === "TSNonNullExpression" && S.type === "MemberExpression" && S.object === m)
          return true;
      }
      case "CallExpression":
      case "MemberExpression":
      case "TaggedTemplateExpression":
      case "TSNonNullExpression":
        if (C === "callee" && (m.type === "BindExpression" || m.type === "NewExpression")) {
          let S = o;
          for (; S; )
            switch (S.type) {
              case "CallExpression":
              case "OptionalCallExpression":
                return true;
              case "MemberExpression":
              case "OptionalMemberExpression":
              case "BindExpression":
                S = S.object;
                break;
              case "TaggedTemplateExpression":
                S = S.tag;
                break;
              case "TSNonNullExpression":
                S = S.expression;
                break;
              default:
                return false;
            }
        }
        return false;
      case "BindExpression":
        return C === "callee" && (m.type === "BindExpression" || m.type === "NewExpression") || C === "object" && f(m);
      case "NGPipeExpression":
        return !(m.type === "NGRoot" || m.type === "NGMicrosyntaxExpression" || m.type === "ObjectProperty" && !(o.extra && o.extra.parenthesized) || m.type === "ArrayExpression" || c(m) && m.arguments[C] === o || C === "right" && m.type === "NGPipeExpression" || C === "property" && m.type === "MemberExpression" || m.type === "AssignmentExpression");
      case "JSXFragment":
      case "JSXElement":
        return C === "callee" || C === "left" && m.type === "BinaryExpression" && m.operator === "<" || m.type !== "ArrayExpression" && m.type !== "ArrowFunctionExpression" && m.type !== "AssignmentExpression" && m.type !== "AssignmentPattern" && m.type !== "BinaryExpression" && m.type !== "NewExpression" && m.type !== "ConditionalExpression" && m.type !== "ExpressionStatement" && m.type !== "JsExpressionRoot" && m.type !== "JSXAttribute" && m.type !== "JSXElement" && m.type !== "JSXExpressionContainer" && m.type !== "JSXFragment" && m.type !== "LogicalExpression" && !c(m) && !E(m) && m.type !== "ReturnStatement" && m.type !== "ThrowStatement" && m.type !== "TypeCastExpression" && m.type !== "VariableDeclarator" && m.type !== "YieldExpression";
      case "TypeAnnotation":
        return C === "returnType" && m.type === "ArrowFunctionExpression" && x(o);
    }
    return false;
  }
  function F(D) {
    return D.type === "BlockStatement" || D.type === "BreakStatement" || D.type === "ClassBody" || D.type === "ClassDeclaration" || D.type === "ClassMethod" || D.type === "ClassProperty" || D.type === "PropertyDefinition" || D.type === "ClassPrivateProperty" || D.type === "ContinueStatement" || D.type === "DebuggerStatement" || D.type === "DeclareClass" || D.type === "DeclareExportAllDeclaration" || D.type === "DeclareExportDeclaration" || D.type === "DeclareFunction" || D.type === "DeclareInterface" || D.type === "DeclareModule" || D.type === "DeclareModuleExports" || D.type === "DeclareVariable" || D.type === "DoWhileStatement" || D.type === "EnumDeclaration" || D.type === "ExportAllDeclaration" || D.type === "ExportDefaultDeclaration" || D.type === "ExportNamedDeclaration" || D.type === "ExpressionStatement" || D.type === "ForInStatement" || D.type === "ForOfStatement" || D.type === "ForStatement" || D.type === "FunctionDeclaration" || D.type === "IfStatement" || D.type === "ImportDeclaration" || D.type === "InterfaceDeclaration" || D.type === "LabeledStatement" || D.type === "MethodDefinition" || D.type === "ReturnStatement" || D.type === "SwitchStatement" || D.type === "ThrowStatement" || D.type === "TryStatement" || D.type === "TSDeclareFunction" || D.type === "TSEnumDeclaration" || D.type === "TSImportEqualsDeclaration" || D.type === "TSInterfaceDeclaration" || D.type === "TSModuleDeclaration" || D.type === "TSNamespaceExportDeclaration" || D.type === "TypeAlias" || D.type === "VariableDeclaration" || D.type === "WhileStatement" || D.type === "WithStatement";
  }
  function N2(D) {
    let T = 0, m = D.getValue();
    for (; m; ) {
      let C = D.getParentNode(T++);
      if (C && C.type === "ForStatement" && C.init === m)
        return true;
      m = C;
    }
    return false;
  }
  function x(D) {
    return l(D, (T) => T.type === "ObjectTypeAnnotation" && l(T, (m) => m.type === "FunctionTypeAnnotation" || void 0) || void 0);
  }
  function I2(D) {
    switch (D.type) {
      case "ObjectExpression":
        return true;
      default:
        return false;
    }
  }
  function P(D) {
    let T = D.getValue(), m = D.getParentNode(), C = D.getName();
    switch (m.type) {
      case "NGPipeExpression":
        if (typeof C == "number" && m.arguments[C] === T && m.arguments.length - 1 === C)
          return D.callParent(P);
        break;
      case "ObjectProperty":
        if (C === "value") {
          let o = D.getParentNode(1);
          return t(o.properties) === m;
        }
        break;
      case "BinaryExpression":
      case "LogicalExpression":
        if (C === "right")
          return D.callParent(P);
        break;
      case "ConditionalExpression":
        if (C === "alternate")
          return D.callParent(P);
        break;
      case "UnaryExpression":
        if (m.prefix)
          return D.callParent(P);
        break;
    }
    return false;
  }
  function $2(D, T) {
    let m = D.getValue(), C = D.getParentNode();
    return m.type === "FunctionExpression" || m.type === "ClassExpression" ? C.type === "ExportDefaultDeclaration" || !w(D, T) : !i(m) || C.type !== "ExportDefaultDeclaration" && w(D, T) ? false : D.call((o) => $2(o, T), ...n(D, m));
  }
  r.exports = w;
} }), Do$1 = te$1({ "src/language-js/print-preprocess.js"(e, r) {
  ne();
  function t(s, a) {
    switch (a.parser) {
      case "json":
      case "json5":
      case "json-stringify":
      case "__js_expression":
      case "__vue_expression":
      case "__vue_ts_expression":
        return Object.assign(Object.assign({}, s), {}, { type: a.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: s, comments: [], rootMarker: a.rootMarker });
      default:
        return s;
    }
  }
  r.exports = t;
} }), rd = te$1({ "src/language-js/print/html-binding.js"(e, r) {
  ne();
  var { builders: { join: t, line: s, group: a, softline: n, indent: u } } = qe();
  function i(p, d2, y2) {
    let g2 = p.getValue();
    if (d2.__onHtmlBindingRoot && p.getName() === null && d2.__onHtmlBindingRoot(g2, d2), g2.type === "File") {
      if (d2.__isVueForBindingLeft)
        return p.call((c) => {
          let f = t([",", s], c.map(y2, "params")), { params: E } = c.getValue();
          return E.length === 1 ? f : ["(", u([n, a(f)]), n, ")"];
        }, "program", "body", 0);
      if (d2.__isVueBindings)
        return p.call((c) => t([",", s], c.map(y2, "params")), "program", "body", 0);
    }
  }
  function l(p) {
    switch (p.type) {
      case "MemberExpression":
        switch (p.property.type) {
          case "Identifier":
          case "NumericLiteral":
          case "StringLiteral":
            return l(p.object);
        }
        return false;
      case "Identifier":
        return true;
      default:
        return false;
    }
  }
  r.exports = { isVueEventBindingExpression: l, printHtmlBinding: i };
} }), Zn = te$1({ "src/language-js/print/binaryish.js"(e, r) {
  ne();
  var { printComments: t } = et(), { getLast: s } = Ue$2(), { builders: { join: a, line: n, softline: u, group: i, indent: l, align: p, indentIfBreak: d2 }, utils: { cleanDoc: y2, getDocParts: g2, isConcat: c } } = qe(), { hasLeadingOwnLineComment: f, isBinaryish: E, isJsxNode: _, shouldFlatten: w, hasComment: F, CommentCheckFlags: N2, isCallExpression: x, isMemberExpression: I2, isObjectProperty: P, isEnabledHackPipeline: $2 } = Ke$1(), D = 0;
  function T(o, h, v2) {
    let S = o.getValue(), b = o.getParentNode(), B = o.getParentNode(1), k = S !== b.body && (b.type === "IfStatement" || b.type === "WhileStatement" || b.type === "SwitchStatement" || b.type === "DoWhileStatement"), M2 = $2(h) && S.operator === "|>", R2 = m(o, v2, h, false, k);
    if (k)
      return R2;
    if (M2)
      return i(R2);
    if (x(b) && b.callee === S || b.type === "UnaryExpression" || I2(b) && !b.computed)
      return i([l([u, ...R2]), u]);
    let q = b.type === "ReturnStatement" || b.type === "ThrowStatement" || b.type === "JSXExpressionContainer" && B.type === "JSXAttribute" || S.operator !== "|" && b.type === "JsExpressionRoot" || S.type !== "NGPipeExpression" && (b.type === "NGRoot" && h.parser === "__ng_binding" || b.type === "NGMicrosyntaxExpression" && B.type === "NGMicrosyntax" && B.body.length === 1) || S === b.body && b.type === "ArrowFunctionExpression" || S !== b.body && b.type === "ForStatement" || b.type === "ConditionalExpression" && B.type !== "ReturnStatement" && B.type !== "ThrowStatement" && !x(B) || b.type === "TemplateLiteral", J = b.type === "AssignmentExpression" || b.type === "VariableDeclarator" || b.type === "ClassProperty" || b.type === "PropertyDefinition" || b.type === "TSAbstractPropertyDefinition" || b.type === "ClassPrivateProperty" || P(b), L = E(S.left) && w(S.operator, S.left.operator);
    if (q || C(S) && !L || !C(S) && J)
      return i(R2);
    if (R2.length === 0)
      return "";
    let Q = _(S.right), V = R2.findIndex((W) => typeof W != "string" && !Array.isArray(W) && W.type === "group"), j = R2.slice(0, V === -1 ? 1 : V + 1), Y = R2.slice(j.length, Q ? -1 : void 0), ie2 = Symbol("logicalChain-" + ++D), ee2 = i([...j, l(Y)], { id: ie2 });
    if (!Q)
      return ee2;
    let ce2 = s(R2);
    return i([ee2, d2(ce2, { groupId: ie2 })]);
  }
  function m(o, h, v2, S, b) {
    let B = o.getValue();
    if (!E(B))
      return [i(h())];
    let k = [];
    w(B.operator, B.left.operator) ? k = o.call((Y) => m(Y, h, v2, true, b), "left") : k.push(i(h("left")));
    let M2 = C(B), R2 = (B.operator === "|>" || B.type === "NGPipeExpression" || B.operator === "|" && v2.parser === "__vue_expression") && !f(v2.originalText, B.right), q = B.type === "NGPipeExpression" ? "|" : B.operator, J = B.type === "NGPipeExpression" && B.arguments.length > 0 ? i(l([n, ": ", a([n, ": "], o.map(h, "arguments").map((Y) => p(2, i(Y))))])) : "", L;
    if (M2)
      L = [q, " ", h("right"), J];
    else {
      let ie2 = $2(v2) && q === "|>" ? o.call((ee2) => m(ee2, h, v2, true, b), "right") : h("right");
      L = [R2 ? n : "", q, R2 ? " " : n, ie2, J];
    }
    let Q = o.getParentNode(), V = F(B.left, N2.Trailing | N2.Line), j = V || !(b && B.type === "LogicalExpression") && Q.type !== B.type && B.left.type !== B.type && B.right.type !== B.type;
    if (k.push(R2 ? "" : " ", j ? i(L, { shouldBreak: V }) : L), S && F(B)) {
      let Y = y2(t(o, k, v2));
      return c(Y) || Y.type === "fill" ? g2(Y) : [Y];
    }
    return k;
  }
  function C(o) {
    return o.type !== "LogicalExpression" ? false : !!(o.right.type === "ObjectExpression" && o.right.properties.length > 0 || o.right.type === "ArrayExpression" && o.right.elements.length > 0 || _(o.right));
  }
  r.exports = { printBinaryishExpression: T, shouldInlineLogicalExpression: C };
} }), nd = te$1({ "src/language-js/print/angular.js"(e, r) {
  ne();
  var { builders: { join: t, line: s, group: a } } = qe(), { hasNode: n, hasComment: u, getComments: i } = Ke$1(), { printBinaryishExpression: l } = Zn();
  function p(g2, c, f) {
    let E = g2.getValue();
    if (E.type.startsWith("NG"))
      switch (E.type) {
        case "NGRoot":
          return [f("node"), u(E.node) ? " //" + i(E.node)[0].value.trimEnd() : ""];
        case "NGPipeExpression":
          return l(g2, c, f);
        case "NGChainedExpression":
          return a(t([";", s], g2.map((_) => y2(_) ? f() : ["(", f(), ")"], "expressions")));
        case "NGEmptyExpression":
          return "";
        case "NGQuotedExpression":
          return [E.prefix, ": ", E.value.trim()];
        case "NGMicrosyntax":
          return g2.map((_, w) => [w === 0 ? "" : d2(_.getValue(), w, E) ? " " : [";", s], f()], "body");
        case "NGMicrosyntaxKey":
          return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(E.name) ? E.name : JSON.stringify(E.name);
        case "NGMicrosyntaxExpression":
          return [f("expression"), E.alias === null ? "" : [" as ", f("alias")]];
        case "NGMicrosyntaxKeyedExpression": {
          let _ = g2.getName(), w = g2.getParentNode(), F = d2(E, _, w) || (_ === 1 && (E.key.name === "then" || E.key.name === "else") || _ === 2 && E.key.name === "else" && w.body[_ - 1].type === "NGMicrosyntaxKeyedExpression" && w.body[_ - 1].key.name === "then") && w.body[0].type === "NGMicrosyntaxExpression";
          return [f("key"), F ? " " : ": ", f("expression")];
        }
        case "NGMicrosyntaxLet":
          return ["let ", f("key"), E.value === null ? "" : [" = ", f("value")]];
        case "NGMicrosyntaxAs":
          return [f("key"), " as ", f("alias")];
        default:
          throw new Error(`Unknown Angular node type: ${JSON.stringify(E.type)}.`);
      }
  }
  function d2(g2, c, f) {
    return g2.type === "NGMicrosyntaxKeyedExpression" && g2.key.name === "of" && c === 1 && f.body[0].type === "NGMicrosyntaxLet" && f.body[0].value === null;
  }
  function y2(g2) {
    return n(g2.getValue(), (c) => {
      switch (c.type) {
        case void 0:
          return false;
        case "CallExpression":
        case "OptionalCallExpression":
        case "AssignmentExpression":
          return true;
      }
    });
  }
  r.exports = { printAngular: p };
} }), ud = te$1({ "src/language-js/print/jsx.js"(e, r) {
  ne();
  var { printComments: t, printDanglingComments: s, printCommentsSeparately: a } = et(), { builders: { line: n, hardline: u, softline: i, group: l, indent: p, conditionalGroup: d2, fill: y2, ifBreak: g2, lineSuffixBoundary: c, join: f }, utils: { willBreak: E } } = qe(), { getLast: _, getPreferredQuote: w } = Ue$2(), { isJsxNode: F, rawText: N2, isCallExpression: x, isStringLiteral: I2, isBinaryish: P, hasComment: $2, CommentCheckFlags: D, hasNodeIgnoreComment: T } = Ke$1(), m = Ot$1(), { willPrintOwnComments: C } = fo$2(), o = (U2) => U2 === "" || U2 === n || U2 === u || U2 === i;
  function h(U2, Z, se2) {
    let fe2 = U2.getValue();
    if (fe2.type === "JSXElement" && de(fe2))
      return [se2("openingElement"), se2("closingElement")];
    let ge2 = fe2.type === "JSXElement" ? se2("openingElement") : se2("openingFragment"), he2 = fe2.type === "JSXElement" ? se2("closingElement") : se2("closingFragment");
    if (fe2.children.length === 1 && fe2.children[0].type === "JSXExpressionContainer" && (fe2.children[0].expression.type === "TemplateLiteral" || fe2.children[0].expression.type === "TaggedTemplateExpression"))
      return [ge2, ...U2.map(se2, "children"), he2];
    fe2.children = fe2.children.map((A) => Fe2(A) ? { type: "JSXText", value: " ", raw: " " } : A);
    let we2 = fe2.children.some(F), ke2 = fe2.children.filter((A) => A.type === "JSXExpressionContainer").length > 1, Re2 = fe2.type === "JSXElement" && fe2.openingElement.attributes.length > 1, Ne2 = E(ge2) || we2 || Re2 || ke2, Pe2 = U2.getParentNode().rootMarker === "mdx", oe = Z.singleQuote ? "{' '}" : '{" "}', H = Pe2 ? " " : g2([oe, i], " "), pe2 = fe2.openingElement && fe2.openingElement.name && fe2.openingElement.name.name === "fbt", X = v2(U2, Z, se2, H, pe2), le2 = fe2.children.some((A) => ue2(A));
    for (let A = X.length - 2; A >= 0; A--) {
      let G = X[A] === "" && X[A + 1] === "", re = X[A] === u && X[A + 1] === "" && X[A + 2] === u, ye2 = (X[A] === i || X[A] === u) && X[A + 1] === "" && X[A + 2] === H, Ce2 = X[A] === H && X[A + 1] === "" && (X[A + 2] === i || X[A + 2] === u), Be = X[A] === H && X[A + 1] === "" && X[A + 2] === H, ve2 = X[A] === i && X[A + 1] === "" && X[A + 2] === u || X[A] === u && X[A + 1] === "" && X[A + 2] === i;
      re && le2 || G || ye2 || Be || ve2 ? X.splice(A, 2) : Ce2 && X.splice(A + 1, 2);
    }
    for (; X.length > 0 && o(_(X)); )
      X.pop();
    for (; X.length > 1 && o(X[0]) && o(X[1]); )
      X.shift(), X.shift();
    let Ae2 = [];
    for (let [A, G] of X.entries()) {
      if (G === H) {
        if (A === 1 && X[A - 1] === "") {
          if (X.length === 2) {
            Ae2.push(oe);
            continue;
          }
          Ae2.push([oe, u]);
          continue;
        } else if (A === X.length - 1) {
          Ae2.push(oe);
          continue;
        } else if (X[A - 1] === "" && X[A - 2] === u) {
          Ae2.push(oe);
          continue;
        }
      }
      Ae2.push(G), E(G) && (Ne2 = true);
    }
    let Ee = le2 ? y2(Ae2) : l(Ae2, { shouldBreak: true });
    if (Pe2)
      return Ee;
    let De2 = l([ge2, p([u, Ee]), u, he2]);
    return Ne2 ? De2 : d2([l([ge2, ...X, he2]), De2]);
  }
  function v2(U2, Z, se2, fe2, ge2) {
    let he2 = [];
    return U2.each((we2, ke2, Re2) => {
      let Ne2 = we2.getValue();
      if (Ne2.type === "JSXText") {
        let Pe2 = N2(Ne2);
        if (ue2(Ne2)) {
          let oe = Pe2.split(ce2);
          if (oe[0] === "") {
            if (he2.push(""), oe.shift(), /\n/.test(oe[0])) {
              let pe2 = Re2[ke2 + 1];
              he2.push(b(ge2, oe[1], Ne2, pe2));
            } else
              he2.push(fe2);
            oe.shift();
          }
          let H;
          if (_(oe) === "" && (oe.pop(), H = oe.pop()), oe.length === 0)
            return;
          for (let [pe2, X] of oe.entries())
            pe2 % 2 === 1 ? he2.push(n) : he2.push(X);
          if (H !== void 0)
            if (/\n/.test(H)) {
              let pe2 = Re2[ke2 + 1];
              he2.push(b(ge2, _(he2), Ne2, pe2));
            } else
              he2.push(fe2);
          else {
            let pe2 = Re2[ke2 + 1];
            he2.push(S(ge2, _(he2), Ne2, pe2));
          }
        } else
          /\n/.test(Pe2) ? Pe2.match(/\n/g).length > 1 && he2.push("", u) : he2.push("", fe2);
      } else {
        let Pe2 = se2();
        he2.push(Pe2);
        let oe = Re2[ke2 + 1];
        if (oe && ue2(oe)) {
          let pe2 = K2(N2(oe)).split(ce2)[0];
          he2.push(S(ge2, pe2, Ne2, oe));
        } else
          he2.push(u);
      }
    }, "children"), he2;
  }
  function S(U2, Z, se2, fe2) {
    return U2 ? "" : se2.type === "JSXElement" && !se2.closingElement || fe2 && fe2.type === "JSXElement" && !fe2.closingElement ? Z.length === 1 ? i : u : i;
  }
  function b(U2, Z, se2, fe2) {
    return U2 ? u : Z.length === 1 ? se2.type === "JSXElement" && !se2.closingElement || fe2 && fe2.type === "JSXElement" && !fe2.closingElement ? u : i : u;
  }
  function B(U2, Z, se2) {
    let fe2 = U2.getParentNode();
    if (!fe2 || { ArrayExpression: true, JSXAttribute: true, JSXElement: true, JSXExpressionContainer: true, JSXFragment: true, ExpressionStatement: true, CallExpression: true, OptionalCallExpression: true, ConditionalExpression: true, JsExpressionRoot: true }[fe2.type])
      return Z;
    let he2 = U2.match(void 0, (ke2) => ke2.type === "ArrowFunctionExpression", x, (ke2) => ke2.type === "JSXExpressionContainer"), we2 = m(U2, se2);
    return l([we2 ? "" : g2("("), p([i, Z]), i, we2 ? "" : g2(")")], { shouldBreak: he2 });
  }
  function k(U2, Z, se2) {
    let fe2 = U2.getValue(), ge2 = [];
    if (ge2.push(se2("name")), fe2.value) {
      let he2;
      if (I2(fe2.value)) {
        let ke2 = N2(fe2.value).slice(1, -1).replace(/&apos;/g, "'").replace(/&quot;/g, '"'), { escaped: Re2, quote: Ne2, regex: Pe2 } = w(ke2, Z.jsxSingleQuote ? "'" : '"');
        ke2 = ke2.replace(Pe2, Re2);
        let { leading: oe, trailing: H } = U2.call(() => a(U2, Z), "value");
        he2 = [oe, Ne2, ke2, Ne2, H];
      } else
        he2 = se2("value");
      ge2.push("=", he2);
    }
    return ge2;
  }
  function M2(U2, Z, se2) {
    let fe2 = U2.getValue(), ge2 = (he2, we2) => he2.type === "JSXEmptyExpression" || !$2(he2) && (he2.type === "ArrayExpression" || he2.type === "ObjectExpression" || he2.type === "ArrowFunctionExpression" || he2.type === "AwaitExpression" && (ge2(he2.argument, he2) || he2.argument.type === "JSXElement") || x(he2) || he2.type === "FunctionExpression" || he2.type === "TemplateLiteral" || he2.type === "TaggedTemplateExpression" || he2.type === "DoExpression" || F(we2) && (he2.type === "ConditionalExpression" || P(he2)));
    return ge2(fe2.expression, U2.getParentNode(0)) ? l(["{", se2("expression"), c, "}"]) : l(["{", p([i, se2("expression")]), i, c, "}"]);
  }
  function R2(U2, Z, se2) {
    let fe2 = U2.getValue(), ge2 = fe2.name && $2(fe2.name) || fe2.typeParameters && $2(fe2.typeParameters);
    if (fe2.selfClosing && fe2.attributes.length === 0 && !ge2)
      return ["<", se2("name"), se2("typeParameters"), " />"];
    if (fe2.attributes && fe2.attributes.length === 1 && fe2.attributes[0].value && I2(fe2.attributes[0].value) && !fe2.attributes[0].value.value.includes(`
`) && !ge2 && !$2(fe2.attributes[0]))
      return l(["<", se2("name"), se2("typeParameters"), " ", ...U2.map(se2, "attributes"), fe2.selfClosing ? " />" : ">"]);
    let he2 = fe2.attributes && fe2.attributes.some((ke2) => ke2.value && I2(ke2.value) && ke2.value.value.includes(`
`)), we2 = Z.singleAttributePerLine && fe2.attributes.length > 1 ? u : n;
    return l(["<", se2("name"), se2("typeParameters"), p(U2.map(() => [we2, se2()], "attributes")), ...q(fe2, Z, ge2)], { shouldBreak: he2 });
  }
  function q(U2, Z, se2) {
    return U2.selfClosing ? [n, "/>"] : J(U2, Z, se2) ? [">"] : [i, ">"];
  }
  function J(U2, Z, se2) {
    let fe2 = U2.attributes.length > 0 && $2(_(U2.attributes), D.Trailing);
    return U2.attributes.length === 0 && !se2 || (Z.bracketSameLine || Z.jsxBracketSameLine) && (!se2 || U2.attributes.length > 0) && !fe2;
  }
  function L(U2, Z, se2) {
    let fe2 = U2.getValue(), ge2 = [];
    ge2.push("</");
    let he2 = se2("name");
    return $2(fe2.name, D.Leading | D.Line) ? ge2.push(p([u, he2]), u) : $2(fe2.name, D.Leading | D.Block) ? ge2.push(" ", he2) : ge2.push(he2), ge2.push(">"), ge2;
  }
  function Q(U2, Z) {
    let se2 = U2.getValue(), fe2 = $2(se2), ge2 = $2(se2, D.Line), he2 = se2.type === "JSXOpeningFragment";
    return [he2 ? "<" : "</", p([ge2 ? u : fe2 && !he2 ? " " : "", s(U2, Z, true)]), ge2 ? u : "", ">"];
  }
  function V(U2, Z, se2) {
    let fe2 = t(U2, h(U2, Z, se2), Z);
    return B(U2, fe2, Z);
  }
  function j(U2, Z) {
    let se2 = U2.getValue(), fe2 = $2(se2, D.Line);
    return [s(U2, Z, !fe2), fe2 ? u : ""];
  }
  function Y(U2, Z, se2) {
    let fe2 = U2.getValue();
    return ["{", U2.call((ge2) => {
      let he2 = ["...", se2()], we2 = ge2.getValue();
      return !$2(we2) || !C(ge2) ? he2 : [p([i, t(ge2, he2, Z)]), i];
    }, fe2.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
  }
  function ie2(U2, Z, se2) {
    let fe2 = U2.getValue();
    if (fe2.type.startsWith("JSX"))
      switch (fe2.type) {
        case "JSXAttribute":
          return k(U2, Z, se2);
        case "JSXIdentifier":
          return String(fe2.name);
        case "JSXNamespacedName":
          return f(":", [se2("namespace"), se2("name")]);
        case "JSXMemberExpression":
          return f(".", [se2("object"), se2("property")]);
        case "JSXSpreadAttribute":
          return Y(U2, Z, se2);
        case "JSXSpreadChild":
          return Y(U2, Z, se2);
        case "JSXExpressionContainer":
          return M2(U2, Z, se2);
        case "JSXFragment":
        case "JSXElement":
          return V(U2, Z, se2);
        case "JSXOpeningElement":
          return R2(U2, Z, se2);
        case "JSXClosingElement":
          return L(U2, Z, se2);
        case "JSXOpeningFragment":
        case "JSXClosingFragment":
          return Q(U2, Z);
        case "JSXEmptyExpression":
          return j(U2, Z);
        case "JSXText":
          throw new Error("JSXText should be handled by JSXElement");
        default:
          throw new Error(`Unknown JSX node type: ${JSON.stringify(fe2.type)}.`);
      }
  }
  var ee2 = ` 
\r	`, ce2 = new RegExp("([" + ee2 + "]+)"), W = new RegExp("[^" + ee2 + "]"), K2 = (U2) => U2.replace(new RegExp("(?:^" + ce2.source + "|" + ce2.source + "$)"), "");
  function de(U2) {
    if (U2.children.length === 0)
      return true;
    if (U2.children.length > 1)
      return false;
    let Z = U2.children[0];
    return Z.type === "JSXText" && !ue2(Z);
  }
  function ue2(U2) {
    return U2.type === "JSXText" && (W.test(N2(U2)) || !/\n/.test(N2(U2)));
  }
  function Fe2(U2) {
    return U2.type === "JSXExpressionContainer" && I2(U2.expression) && U2.expression.value === " " && !$2(U2.expression);
  }
  function z(U2) {
    let Z = U2.getValue(), se2 = U2.getParentNode();
    if (!se2 || !Z || !F(Z) || !F(se2))
      return false;
    let fe2 = se2.children.indexOf(Z), ge2 = null;
    for (let he2 = fe2; he2 > 0; he2--) {
      let we2 = se2.children[he2 - 1];
      if (!(we2.type === "JSXText" && !ue2(we2))) {
        ge2 = we2;
        break;
      }
    }
    return ge2 && ge2.type === "JSXExpressionContainer" && ge2.expression.type === "JSXEmptyExpression" && T(ge2.expression);
  }
  r.exports = { hasJsxIgnoreComment: z, printJsx: ie2 };
} }), ct$1 = te$1({ "src/language-js/print/misc.js"(e, r) {
  ne();
  var { isNonEmptyArray: t } = Ue$2(), { builders: { indent: s, join: a, line: n } } = qe(), { isFlowAnnotationComment: u } = Ke$1();
  function i(_) {
    let w = _.getValue();
    return !w.optional || w.type === "Identifier" && w === _.getParentNode().key ? "" : w.type === "OptionalCallExpression" || w.type === "OptionalMemberExpression" && w.computed ? "?." : "?";
  }
  function l(_) {
    return _.getValue().definite || _.match(void 0, (w, F) => F === "id" && w.type === "VariableDeclarator" && w.definite) ? "!" : "";
  }
  function p(_, w, F) {
    let N2 = _.getValue();
    return N2.typeArguments ? F("typeArguments") : N2.typeParameters ? F("typeParameters") : "";
  }
  function d2(_, w, F) {
    let N2 = _.getValue();
    if (!N2.typeAnnotation)
      return "";
    let x = _.getParentNode(), I2 = x.type === "DeclareFunction" && x.id === N2;
    return u(w.originalText, N2.typeAnnotation) ? [" /*: ", F("typeAnnotation"), " */"] : [I2 ? "" : ": ", F("typeAnnotation")];
  }
  function y2(_, w, F) {
    return ["::", F("callee")];
  }
  function g2(_, w, F) {
    let N2 = _.getValue();
    return t(N2.modifiers) ? [a(" ", _.map(F, "modifiers")), " "] : "";
  }
  function c(_, w, F) {
    return _.type === "EmptyStatement" ? ";" : _.type === "BlockStatement" || F ? [" ", w] : s([n, w]);
  }
  function f(_, w, F) {
    return ["...", F("argument"), d2(_, w, F)];
  }
  function E(_, w) {
    let F = _.slice(1, -1);
    if (F.includes('"') || F.includes("'"))
      return _;
    let N2 = w.singleQuote ? "'" : '"';
    return N2 + F + N2;
  }
  r.exports = { printOptionalToken: i, printDefiniteToken: l, printFunctionTypeParameters: p, printBindExpressionCallee: y2, printTypeScriptModifiers: g2, printTypeAnnotation: d2, printRestSpread: f, adjustClause: c, printDirective: E };
} }), Qt = te$1({ "src/language-js/print/array.js"(e, r) {
  ne();
  var { printDanglingComments: t } = et(), { builders: { line: s, softline: a, hardline: n, group: u, indent: i, ifBreak: l, fill: p } } = qe(), { getLast: d2, hasNewline: y2 } = Ue$2(), { shouldPrintComma: g2, hasComment: c, CommentCheckFlags: f, isNextLineEmpty: E, isNumericLiteral: _, isSignedNumericLiteral: w } = Ke$1(), { locStart: F } = ut$1(), { printOptionalToken: N2, printTypeAnnotation: x } = ct$1();
  function I2(T, m, C) {
    let o = T.getValue(), h = [], v2 = o.type === "TupleExpression" ? "#[" : "[", S = "]";
    if (o.elements.length === 0)
      c(o, f.Dangling) ? h.push(u([v2, t(T, m), a, S])) : h.push(v2, S);
    else {
      let b = d2(o.elements), B = !(b && b.type === "RestElement"), k = b === null, M2 = Symbol("array"), R2 = !m.__inJestEach && o.elements.length > 1 && o.elements.every((L, Q, V) => {
        let j = L && L.type;
        if (j !== "ArrayExpression" && j !== "ObjectExpression")
          return false;
        let Y = V[Q + 1];
        if (Y && j !== Y.type)
          return false;
        let ie2 = j === "ArrayExpression" ? "elements" : "properties";
        return L[ie2] && L[ie2].length > 1;
      }), q = P(o, m), J = B ? k ? "," : g2(m) ? q ? l(",", "", { groupId: M2 }) : l(",") : "" : "";
      h.push(u([v2, i([a, q ? D(T, m, C, J) : [$2(T, m, "elements", C), J], t(T, m, true)]), a, S], { shouldBreak: R2, id: M2 }));
    }
    return h.push(N2(T), x(T, m, C)), h;
  }
  function P(T, m) {
    return T.elements.length > 1 && T.elements.every((C) => C && (_(C) || w(C) && !c(C.argument)) && !c(C, f.Trailing | f.Line, (o) => !y2(m.originalText, F(o), { backwards: true })));
  }
  function $2(T, m, C, o) {
    let h = [], v2 = [];
    return T.each((S) => {
      h.push(v2, u(o())), v2 = [",", s], S.getValue() && E(S.getValue(), m) && v2.push(a);
    }, C), h;
  }
  function D(T, m, C, o) {
    let h = [];
    return T.each((v2, S, b) => {
      let B = S === b.length - 1;
      h.push([C(), B ? o : ","]), B || h.push(E(v2.getValue(), m) ? [n, n] : c(b[S + 1], f.Leading | f.Line) ? n : s);
    }, "elements"), p(h);
  }
  r.exports = { printArray: I2, printArrayItems: $2, isConciselyPrintedArray: P };
} }), mo$2 = te$1({ "src/language-js/print/call-arguments.js"(e, r) {
  ne();
  var { printDanglingComments: t } = et(), { getLast: s, getPenultimate: a } = Ue$2(), { getFunctionParameters: n, hasComment: u, CommentCheckFlags: i, isFunctionCompositionArgs: l, isJsxNode: p, isLongCurriedCallExpression: d2, shouldPrintComma: y2, getCallArguments: g2, iterateCallArgumentsPath: c, isNextLineEmpty: f, isCallExpression: E, isStringLiteral: _, isObjectProperty: w, isTSTypeExpression: F } = Ke$1(), { builders: { line: N2, hardline: x, softline: I2, group: P, indent: $2, conditionalGroup: D, ifBreak: T, breakParent: m }, utils: { willBreak: C } } = qe(), { ArgExpansionBailout: o } = Kt$1(), { isConciselyPrintedArray: h } = Qt();
  function v2(q, J, L) {
    let Q = q.getValue(), V = Q.type === "ImportExpression", j = g2(Q);
    if (j.length === 0)
      return ["(", t(q, J, true), ")"];
    if (k(j))
      return ["(", L(["arguments", 0]), ", ", L(["arguments", 1]), ")"];
    let Y = false, ie2 = false, ee2 = j.length - 1, ce2 = [];
    c(q, (z, U2) => {
      let Z = z.getNode(), se2 = [L()];
      U2 === ee2 || (f(Z, J) ? (U2 === 0 && (ie2 = true), Y = true, se2.push(",", x, x)) : se2.push(",", N2)), ce2.push(se2);
    });
    let W = !(V || Q.callee && Q.callee.type === "Import") && y2(J, "all") ? "," : "";
    function K2() {
      return P(["(", $2([N2, ...ce2]), W, N2, ")"], { shouldBreak: true });
    }
    if (Y || q.getParentNode().type !== "Decorator" && l(j))
      return K2();
    let de = B(j), ue2 = b(j, J);
    if (de || ue2) {
      if (de ? ce2.slice(1).some(C) : ce2.slice(0, -1).some(C))
        return K2();
      let z = [];
      try {
        q.try(() => {
          c(q, (U2, Z) => {
            de && Z === 0 && (z = [[L([], { expandFirstArg: true }), ce2.length > 1 ? "," : "", ie2 ? x : N2, ie2 ? x : ""], ...ce2.slice(1)]), ue2 && Z === ee2 && (z = [...ce2.slice(0, -1), L([], { expandLastArg: true })]);
          });
        });
      } catch (U2) {
        if (U2 instanceof o)
          return K2();
        throw U2;
      }
      return [ce2.some(C) ? m : "", D([["(", ...z, ")"], de ? ["(", P(z[0], { shouldBreak: true }), ...z.slice(1), ")"] : ["(", ...ce2.slice(0, -1), P(s(z), { shouldBreak: true }), ")"], K2()])];
    }
    let Fe2 = ["(", $2([I2, ...ce2]), T(W), I2, ")"];
    return d2(q) ? Fe2 : P(Fe2, { shouldBreak: ce2.some(C) || Y });
  }
  function S(q) {
    let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    return q.type === "ObjectExpression" && (q.properties.length > 0 || u(q)) || q.type === "ArrayExpression" && (q.elements.length > 0 || u(q)) || q.type === "TSTypeAssertion" && S(q.expression) || F(q) && S(q.expression) || q.type === "FunctionExpression" || q.type === "ArrowFunctionExpression" && (!q.returnType || !q.returnType.typeAnnotation || q.returnType.typeAnnotation.type !== "TSTypeReference" || M2(q.body)) && (q.body.type === "BlockStatement" || q.body.type === "ArrowFunctionExpression" && S(q.body, true) || q.body.type === "ObjectExpression" || q.body.type === "ArrayExpression" || !J && (E(q.body) || q.body.type === "ConditionalExpression") || p(q.body)) || q.type === "DoExpression" || q.type === "ModuleExpression";
  }
  function b(q, J) {
    let L = s(q), Q = a(q);
    return !u(L, i.Leading) && !u(L, i.Trailing) && S(L) && (!Q || Q.type !== L.type) && (q.length !== 2 || Q.type !== "ArrowFunctionExpression" || L.type !== "ArrayExpression") && !(q.length > 1 && L.type === "ArrayExpression" && h(L, J));
  }
  function B(q) {
    if (q.length !== 2)
      return false;
    let [J, L] = q;
    return J.type === "ModuleExpression" && R2(L) ? true : !u(J) && (J.type === "FunctionExpression" || J.type === "ArrowFunctionExpression" && J.body.type === "BlockStatement") && L.type !== "FunctionExpression" && L.type !== "ArrowFunctionExpression" && L.type !== "ConditionalExpression" && !S(L);
  }
  function k(q) {
    return q.length === 2 && q[0].type === "ArrowFunctionExpression" && n(q[0]).length === 0 && q[0].body.type === "BlockStatement" && q[1].type === "ArrayExpression" && !q.some((J) => u(J));
  }
  function M2(q) {
    return q.type === "BlockStatement" && (q.body.some((J) => J.type !== "EmptyStatement") || u(q, i.Dangling));
  }
  function R2(q) {
    return q.type === "ObjectExpression" && q.properties.length === 1 && w(q.properties[0]) && q.properties[0].key.type === "Identifier" && q.properties[0].key.name === "type" && _(q.properties[0].value) && q.properties[0].value.value === "module";
  }
  r.exports = v2;
} }), go$2 = te$1({ "src/language-js/print/member.js"(e, r) {
  ne();
  var { builders: { softline: t, group: s, indent: a, label: n } } = qe(), { isNumericLiteral: u, isMemberExpression: i, isCallExpression: l } = Ke$1(), { printOptionalToken: p } = ct$1();
  function d2(g2, c, f) {
    let E = g2.getValue(), _ = g2.getParentNode(), w, F = 0;
    do
      w = g2.getParentNode(F), F++;
    while (w && (i(w) || w.type === "TSNonNullExpression"));
    let N2 = f("object"), x = y2(g2, c, f), I2 = w && (w.type === "NewExpression" || w.type === "BindExpression" || w.type === "AssignmentExpression" && w.left.type !== "Identifier") || E.computed || E.object.type === "Identifier" && E.property.type === "Identifier" && !i(_) || (_.type === "AssignmentExpression" || _.type === "VariableDeclarator") && (l(E.object) && E.object.arguments.length > 0 || E.object.type === "TSNonNullExpression" && l(E.object.expression) && E.object.expression.arguments.length > 0 || N2.label === "member-chain");
    return n(N2.label === "member-chain" ? "member-chain" : "member", [N2, I2 ? x : s(a([t, x]))]);
  }
  function y2(g2, c, f) {
    let E = f("property"), _ = g2.getValue(), w = p(g2);
    return _.computed ? !_.property || u(_.property) ? [w, "[", E, "]"] : s([w, "[", a([t, E]), t, "]"]) : [w, ".", E];
  }
  r.exports = { printMemberExpression: d2, printMemberLookup: y2 };
} }), sd = te$1({ "src/language-js/print/member-chain.js"(e, r) {
  ne();
  var { printComments: t } = et(), { getLast: s, isNextLineEmptyAfterIndex: a, getNextNonSpaceNonCommentCharacterIndex: n } = Ue$2(), u = Ot$1(), { isCallExpression: i, isMemberExpression: l, isFunctionOrArrowExpression: p, isLongCurriedCallExpression: d2, isMemberish: y2, isNumericLiteral: g2, isSimpleCallArgument: c, hasComment: f, CommentCheckFlags: E, isNextLineEmpty: _ } = Ke$1(), { locEnd: w } = ut$1(), { builders: { join: F, hardline: N2, group: x, indent: I2, conditionalGroup: P, breakParent: $2, label: D }, utils: { willBreak: T } } = qe(), m = mo$2(), { printMemberLookup: C } = go$2(), { printOptionalToken: o, printFunctionTypeParameters: h, printBindExpressionCallee: v2 } = ct$1();
  function S(b, B, k) {
    let M2 = b.getParentNode(), R2 = !M2 || M2.type === "ExpressionStatement", q = [];
    function J(Ne2) {
      let { originalText: Pe2 } = B, oe = n(Pe2, Ne2, w);
      return Pe2.charAt(oe) === ")" ? oe !== false && a(Pe2, oe + 1) : _(Ne2, B);
    }
    function L(Ne2) {
      let Pe2 = Ne2.getValue();
      i(Pe2) && (y2(Pe2.callee) || i(Pe2.callee)) ? (q.unshift({ node: Pe2, printed: [t(Ne2, [o(Ne2), h(Ne2, B, k), m(Ne2, B, k)], B), J(Pe2) ? N2 : ""] }), Ne2.call((oe) => L(oe), "callee")) : y2(Pe2) ? (q.unshift({ node: Pe2, needsParens: u(Ne2, B), printed: t(Ne2, l(Pe2) ? C(Ne2, B, k) : v2(Ne2, B, k), B) }), Ne2.call((oe) => L(oe), "object")) : Pe2.type === "TSNonNullExpression" ? (q.unshift({ node: Pe2, printed: t(Ne2, "!", B) }), Ne2.call((oe) => L(oe), "expression")) : q.unshift({ node: Pe2, printed: k() });
    }
    let Q = b.getValue();
    q.unshift({ node: Q, printed: [o(b), h(b, B, k), m(b, B, k)] }), Q.callee && b.call((Ne2) => L(Ne2), "callee");
    let V = [], j = [q[0]], Y = 1;
    for (; Y < q.length && (q[Y].node.type === "TSNonNullExpression" || i(q[Y].node) || l(q[Y].node) && q[Y].node.computed && g2(q[Y].node.property)); ++Y)
      j.push(q[Y]);
    if (!i(q[0].node))
      for (; Y + 1 < q.length && (y2(q[Y].node) && y2(q[Y + 1].node)); ++Y)
        j.push(q[Y]);
    V.push(j), j = [];
    let ie2 = false;
    for (; Y < q.length; ++Y) {
      if (ie2 && y2(q[Y].node)) {
        if (q[Y].node.computed && g2(q[Y].node.property)) {
          j.push(q[Y]);
          continue;
        }
        V.push(j), j = [], ie2 = false;
      }
      (i(q[Y].node) || q[Y].node.type === "ImportExpression") && (ie2 = true), j.push(q[Y]), f(q[Y].node, E.Trailing) && (V.push(j), j = [], ie2 = false);
    }
    j.length > 0 && V.push(j);
    function ee2(Ne2) {
      return /^[A-Z]|^[$_]+$/.test(Ne2);
    }
    function ce2(Ne2) {
      return Ne2.length <= B.tabWidth;
    }
    function W(Ne2) {
      let Pe2 = Ne2[1].length > 0 && Ne2[1][0].node.computed;
      if (Ne2[0].length === 1) {
        let H = Ne2[0][0].node;
        return H.type === "ThisExpression" || H.type === "Identifier" && (ee2(H.name) || R2 && ce2(H.name) || Pe2);
      }
      let oe = s(Ne2[0]).node;
      return l(oe) && oe.property.type === "Identifier" && (ee2(oe.property.name) || Pe2);
    }
    let K2 = V.length >= 2 && !f(V[1][0].node) && W(V);
    function de(Ne2) {
      let Pe2 = Ne2.map((oe) => oe.printed);
      return Ne2.length > 0 && s(Ne2).needsParens ? ["(", ...Pe2, ")"] : Pe2;
    }
    function ue2(Ne2) {
      return Ne2.length === 0 ? "" : I2(x([N2, F(N2, Ne2.map(de))]));
    }
    let Fe2 = V.map(de), z = Fe2, U2 = K2 ? 3 : 2, Z = V.flat(), se2 = Z.slice(1, -1).some((Ne2) => f(Ne2.node, E.Leading)) || Z.slice(0, -1).some((Ne2) => f(Ne2.node, E.Trailing)) || V[U2] && f(V[U2][0].node, E.Leading);
    if (V.length <= U2 && !se2)
      return d2(b) ? z : x(z);
    let fe2 = s(V[K2 ? 1 : 0]).node, ge2 = !i(fe2) && J(fe2), he2 = [de(V[0]), K2 ? V.slice(1, 2).map(de) : "", ge2 ? N2 : "", ue2(V.slice(K2 ? 2 : 1))], we2 = q.map((Ne2) => {
      let { node: Pe2 } = Ne2;
      return Pe2;
    }).filter(i);
    function ke2() {
      let Ne2 = s(s(V)).node, Pe2 = s(Fe2);
      return i(Ne2) && T(Pe2) && we2.slice(0, -1).some((oe) => oe.arguments.some(p));
    }
    let Re2;
    return se2 || we2.length > 2 && we2.some((Ne2) => !Ne2.arguments.every((Pe2) => c(Pe2, 0))) || Fe2.slice(0, -1).some(T) || ke2() ? Re2 = x(he2) : Re2 = [T(z) || ge2 ? $2 : "", P([z, he2])], D("member-chain", Re2);
  }
  r.exports = S;
} }), yo$2 = te$1({ "src/language-js/print/call-expression.js"(e, r) {
  ne();
  var { builders: { join: t, group: s } } = qe(), a = Ot$1(), { getCallArguments: n, hasFlowAnnotationComment: u, isCallExpression: i, isMemberish: l, isStringLiteral: p, isTemplateOnItsOwnLine: d2, isTestCall: y2, iterateCallArgumentsPath: g2 } = Ke$1(), c = sd(), f = mo$2(), { printOptionalToken: E, printFunctionTypeParameters: _ } = ct$1();
  function w(N2, x, I2) {
    let P = N2.getValue(), $2 = N2.getParentNode(), D = P.type === "NewExpression", T = P.type === "ImportExpression", m = E(N2), C = n(P);
    if (C.length > 0 && (!T && !D && F(P, $2) || C.length === 1 && d2(C[0], x.originalText) || !D && y2(P, $2))) {
      let v2 = [];
      return g2(N2, () => {
        v2.push(I2());
      }), [D ? "new " : "", I2("callee"), m, _(N2, x, I2), "(", t(", ", v2), ")"];
    }
    let o = (x.parser === "babel" || x.parser === "babel-flow") && P.callee && P.callee.type === "Identifier" && u(P.callee.trailingComments);
    if (o && (P.callee.trailingComments[0].printed = true), !T && !D && l(P.callee) && !N2.call((v2) => a(v2, x), "callee"))
      return c(N2, x, I2);
    let h = [D ? "new " : "", T ? "import" : I2("callee"), m, o ? `/*:: ${P.callee.trailingComments[0].value.slice(2).trim()} */` : "", _(N2, x, I2), f(N2, x, I2)];
    return T || i(P.callee) ? s(h) : h;
  }
  function F(N2, x) {
    if (N2.callee.type !== "Identifier")
      return false;
    if (N2.callee.name === "require")
      return true;
    if (N2.callee.name === "define") {
      let I2 = n(N2);
      return x.type === "ExpressionStatement" && (I2.length === 1 || I2.length === 2 && I2[0].type === "ArrayExpression" || I2.length === 3 && p(I2[0]) && I2[1].type === "ArrayExpression");
    }
    return false;
  }
  r.exports = { printCallExpression: w };
} }), Zt = te$1({ "src/language-js/print/assignment.js"(e, r) {
  ne();
  var { isNonEmptyArray: t, getStringWidth: s } = Ue$2(), { builders: { line: a, group: n, indent: u, indentIfBreak: i, lineSuffixBoundary: l }, utils: { cleanDoc: p, willBreak: d2, canBreak: y2 } } = qe(), { hasLeadingOwnLineComment: g2, isBinaryish: c, isStringLiteral: f, isLiteral: E, isNumericLiteral: _, isCallExpression: w, isMemberExpression: F, getCallArguments: N2, rawText: x, hasComment: I2, isSignedNumericLiteral: P, isObjectProperty: $2 } = Ke$1(), { shouldInlineLogicalExpression: D } = Zn(), { printCallExpression: T } = yo$2();
  function m(W, K2, de, ue2, Fe2, z) {
    let U2 = h(W, K2, de, ue2, z), Z = de(z, { assignmentLayout: U2 });
    switch (U2) {
      case "break-after-operator":
        return n([n(ue2), Fe2, n(u([a, Z]))]);
      case "never-break-after-operator":
        return n([n(ue2), Fe2, " ", Z]);
      case "fluid": {
        let se2 = Symbol("assignment");
        return n([n(ue2), Fe2, n(u(a), { id: se2 }), l, i(Z, { groupId: se2 })]);
      }
      case "break-lhs":
        return n([ue2, Fe2, " ", n(Z)]);
      case "chain":
        return [n(ue2), Fe2, a, Z];
      case "chain-tail":
        return [n(ue2), Fe2, u([a, Z])];
      case "chain-tail-arrow-chain":
        return [n(ue2), Fe2, Z];
      case "only-left":
        return ue2;
    }
  }
  function C(W, K2, de) {
    let ue2 = W.getValue();
    return m(W, K2, de, de("left"), [" ", ue2.operator], "right");
  }
  function o(W, K2, de) {
    return m(W, K2, de, de("id"), " =", "init");
  }
  function h(W, K2, de, ue2, Fe2) {
    let z = W.getValue(), U2 = z[Fe2];
    if (!U2)
      return "only-left";
    let Z = !b(U2);
    if (W.match(b, B, (he2) => !Z || he2.type !== "ExpressionStatement" && he2.type !== "VariableDeclaration"))
      return Z ? U2.type === "ArrowFunctionExpression" && U2.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
    if (!Z && b(U2.right) || g2(K2.originalText, U2))
      return "break-after-operator";
    if (U2.type === "CallExpression" && U2.callee.name === "require" || K2.parser === "json5" || K2.parser === "json")
      return "never-break-after-operator";
    if (S(z) || k(z) || q(z) || J(z) && y2(ue2))
      return "break-lhs";
    let ge2 = ie2(z, ue2, K2);
    return W.call(() => v2(W, K2, de, ge2), Fe2) ? "break-after-operator" : ge2 || U2.type === "TemplateLiteral" || U2.type === "TaggedTemplateExpression" || U2.type === "BooleanLiteral" || _(U2) || U2.type === "ClassExpression" ? "never-break-after-operator" : "fluid";
  }
  function v2(W, K2, de, ue2) {
    let Fe2 = W.getValue();
    if (c(Fe2) && !D(Fe2))
      return true;
    switch (Fe2.type) {
      case "StringLiteralTypeAnnotation":
      case "SequenceExpression":
        return true;
      case "ConditionalExpression": {
        let { test: Z } = Fe2;
        return c(Z) && !D(Z);
      }
      case "ClassExpression":
        return t(Fe2.decorators);
    }
    if (ue2)
      return false;
    let z = Fe2, U2 = [];
    for (; ; )
      if (z.type === "UnaryExpression")
        z = z.argument, U2.push("argument");
      else if (z.type === "TSNonNullExpression")
        z = z.expression, U2.push("expression");
      else
        break;
    return !!(f(z) || W.call(() => V(W, K2, de), ...U2));
  }
  function S(W) {
    if (B(W)) {
      let K2 = W.left || W.id;
      return K2.type === "ObjectPattern" && K2.properties.length > 2 && K2.properties.some((de) => $2(de) && (!de.shorthand || de.value && de.value.type === "AssignmentPattern"));
    }
    return false;
  }
  function b(W) {
    return W.type === "AssignmentExpression";
  }
  function B(W) {
    return b(W) || W.type === "VariableDeclarator";
  }
  function k(W) {
    let K2 = M2(W);
    if (t(K2)) {
      let de = W.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
      if (K2.length > 1 && K2.some((ue2) => ue2[de] || ue2.default))
        return true;
    }
    return false;
  }
  function M2(W) {
    return R2(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
  }
  function R2(W) {
    return W.type === "TSTypeAliasDeclaration" || W.type === "TypeAlias";
  }
  function q(W) {
    if (W.type !== "VariableDeclarator")
      return false;
    let { typeAnnotation: K2 } = W.id;
    if (!K2 || !K2.typeAnnotation)
      return false;
    let de = L(K2.typeAnnotation);
    return t(de) && de.length > 1 && de.some((ue2) => t(L(ue2)) || ue2.type === "TSConditionalType");
  }
  function J(W) {
    return W.type === "VariableDeclarator" && W.init && W.init.type === "ArrowFunctionExpression";
  }
  function L(W) {
    return Q(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
  }
  function Q(W) {
    return W.type === "TSTypeReference" || W.type === "GenericTypeAnnotation";
  }
  function V(W, K2, de) {
    let ue2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, Fe2 = W.getValue(), z = () => V(W, K2, de, true);
    if (Fe2.type === "TSNonNullExpression")
      return W.call(z, "expression");
    if (w(Fe2)) {
      if (T(W, K2, de).label === "member-chain")
        return false;
      let Z = N2(Fe2);
      return !(Z.length === 0 || Z.length === 1 && Y(Z[0], K2)) || ee2(Fe2, de) ? false : W.call(z, "callee");
    }
    return F(Fe2) ? W.call(z, "object") : ue2 && (Fe2.type === "Identifier" || Fe2.type === "ThisExpression");
  }
  var j = 0.25;
  function Y(W, K2) {
    let { printWidth: de } = K2;
    if (I2(W))
      return false;
    let ue2 = de * j;
    if (W.type === "ThisExpression" || W.type === "Identifier" && W.name.length <= ue2 || P(W) && !I2(W.argument))
      return true;
    let Fe2 = W.type === "Literal" && "regex" in W && W.regex.pattern || W.type === "RegExpLiteral" && W.pattern;
    return Fe2 ? Fe2.length <= ue2 : f(W) ? x(W).length <= ue2 : W.type === "TemplateLiteral" ? W.expressions.length === 0 && W.quasis[0].value.raw.length <= ue2 && !W.quasis[0].value.raw.includes(`
`) : E(W);
  }
  function ie2(W, K2, de) {
    if (!$2(W))
      return false;
    K2 = p(K2);
    let ue2 = 3;
    return typeof K2 == "string" && s(K2) < de.tabWidth + ue2;
  }
  function ee2(W, K2) {
    let de = ce2(W);
    if (t(de)) {
      if (de.length > 1)
        return true;
      if (de.length === 1) {
        let Fe2 = de[0];
        if (Fe2.type === "TSUnionType" || Fe2.type === "UnionTypeAnnotation" || Fe2.type === "TSIntersectionType" || Fe2.type === "IntersectionTypeAnnotation" || Fe2.type === "TSTypeLiteral" || Fe2.type === "ObjectTypeAnnotation")
          return true;
      }
      let ue2 = W.typeParameters ? "typeParameters" : "typeArguments";
      if (d2(K2(ue2)))
        return true;
    }
    return false;
  }
  function ce2(W) {
    return W.typeParameters && W.typeParameters.params || W.typeArguments && W.typeArguments.params;
  }
  r.exports = { printVariableDeclarator: o, printAssignmentExpression: C, printAssignment: m, isArrowFunctionVariableDeclarator: J };
} }), Ir = te$1({ "src/language-js/print/function-parameters.js"(e, r) {
  ne();
  var { getNextNonSpaceNonCommentCharacter: t } = Ue$2(), { printDanglingComments: s } = et(), { builders: { line: a, hardline: n, softline: u, group: i, indent: l, ifBreak: p }, utils: { removeLines: d2, willBreak: y2 } } = qe(), { getFunctionParameters: g2, iterateFunctionParametersPath: c, isSimpleType: f, isTestCall: E, isTypeAnnotationAFunction: _, isObjectType: w, isObjectTypePropertyAFunction: F, hasRestParameter: N2, shouldPrintComma: x, hasComment: I2, isNextLineEmpty: P } = Ke$1(), { locEnd: $2 } = ut$1(), { ArgExpansionBailout: D } = Kt$1(), { printFunctionTypeParameters: T } = ct$1();
  function m(v2, S, b, B, k) {
    let M2 = v2.getValue(), R2 = g2(M2), q = k ? T(v2, b, S) : "";
    if (R2.length === 0)
      return [q, "(", s(v2, b, true, (ie2) => t(b.originalText, ie2, $2) === ")"), ")"];
    let J = v2.getParentNode(), L = E(J), Q = C(M2), V = [];
    if (c(v2, (ie2, ee2) => {
      let ce2 = ee2 === R2.length - 1;
      ce2 && M2.rest && V.push("..."), V.push(S()), !ce2 && (V.push(","), L || Q ? V.push(" ") : P(R2[ee2], b) ? V.push(n, n) : V.push(a));
    }), B) {
      if (y2(q) || y2(V))
        throw new D();
      return i([d2(q), "(", d2(V), ")"]);
    }
    let j = R2.every((ie2) => !ie2.decorators);
    return Q && j ? [q, "(", ...V, ")"] : L ? [q, "(", ...V, ")"] : (F(J) || _(J) || J.type === "TypeAlias" || J.type === "UnionTypeAnnotation" || J.type === "TSUnionType" || J.type === "IntersectionTypeAnnotation" || J.type === "FunctionTypeAnnotation" && J.returnType === M2) && R2.length === 1 && R2[0].name === null && M2.this !== R2[0] && R2[0].typeAnnotation && M2.typeParameters === null && f(R2[0].typeAnnotation) && !M2.rest ? b.arrowParens === "always" ? ["(", ...V, ")"] : V : [q, "(", l([u, ...V]), p(!N2(M2) && x(b, "all") ? "," : ""), u, ")"];
  }
  function C(v2) {
    if (!v2)
      return false;
    let S = g2(v2);
    if (S.length !== 1)
      return false;
    let [b] = S;
    return !I2(b) && (b.type === "ObjectPattern" || b.type === "ArrayPattern" || b.type === "Identifier" && b.typeAnnotation && (b.typeAnnotation.type === "TypeAnnotation" || b.typeAnnotation.type === "TSTypeAnnotation") && w(b.typeAnnotation.typeAnnotation) || b.type === "FunctionTypeParam" && w(b.typeAnnotation) || b.type === "AssignmentPattern" && (b.left.type === "ObjectPattern" || b.left.type === "ArrayPattern") && (b.right.type === "Identifier" || b.right.type === "ObjectExpression" && b.right.properties.length === 0 || b.right.type === "ArrayExpression" && b.right.elements.length === 0));
  }
  function o(v2) {
    let S;
    return v2.returnType ? (S = v2.returnType, S.typeAnnotation && (S = S.typeAnnotation)) : v2.typeAnnotation && (S = v2.typeAnnotation), S;
  }
  function h(v2, S) {
    let b = o(v2);
    if (!b)
      return false;
    let B = v2.typeParameters && v2.typeParameters.params;
    if (B) {
      if (B.length > 1)
        return false;
      if (B.length === 1) {
        let k = B[0];
        if (k.constraint || k.default)
          return false;
      }
    }
    return g2(v2).length === 1 && (w(b) || y2(S));
  }
  r.exports = { printFunctionParameters: m, shouldHugFunctionParameters: C, shouldGroupFunctionParameters: h };
} }), kr = te$1({ "src/language-js/print/type-annotation.js"(e, r) {
  ne();
  var { printComments: t, printDanglingComments: s } = et(), { isNonEmptyArray: a } = Ue$2(), { builders: { group: n, join: u, line: i, softline: l, indent: p, align: d2, ifBreak: y2 } } = qe(), g2 = Ot$1(), { locStart: c } = ut$1(), { isSimpleType: f, isObjectType: E, hasLeadingOwnLineComment: _, isObjectTypePropertyAFunction: w, shouldPrintComma: F } = Ke$1(), { printAssignment: N2 } = Zt(), { printFunctionParameters: x, shouldGroupFunctionParameters: I2 } = Ir(), { printArrayItems: P } = Qt();
  function $2(b) {
    if (f(b) || E(b))
      return true;
    if (b.type === "UnionTypeAnnotation" || b.type === "TSUnionType") {
      let B = b.types.filter((M2) => M2.type === "VoidTypeAnnotation" || M2.type === "TSVoidKeyword" || M2.type === "NullLiteralTypeAnnotation" || M2.type === "TSNullKeyword").length, k = b.types.some((M2) => M2.type === "ObjectTypeAnnotation" || M2.type === "TSTypeLiteral" || M2.type === "GenericTypeAnnotation" || M2.type === "TSTypeReference");
      if (b.types.length - 1 === B && k)
        return true;
    }
    return false;
  }
  function D(b, B, k) {
    let M2 = B.semi ? ";" : "", R2 = b.getValue(), q = [];
    return q.push("opaque type ", k("id"), k("typeParameters")), R2.supertype && q.push(": ", k("supertype")), R2.impltype && q.push(" = ", k("impltype")), q.push(M2), q;
  }
  function T(b, B, k) {
    let M2 = B.semi ? ";" : "", R2 = b.getValue(), q = [];
    R2.declare && q.push("declare "), q.push("type ", k("id"), k("typeParameters"));
    let J = R2.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
    return [N2(b, B, k, q, " =", J), M2];
  }
  function m(b, B, k) {
    let M2 = b.getValue(), R2 = b.map(k, "types"), q = [], J = false;
    for (let L = 0; L < R2.length; ++L)
      L === 0 ? q.push(R2[L]) : E(M2.types[L - 1]) && E(M2.types[L]) ? q.push([" & ", J ? p(R2[L]) : R2[L]]) : !E(M2.types[L - 1]) && !E(M2.types[L]) ? q.push(p([" &", i, R2[L]])) : (L > 1 && (J = true), q.push(" & ", L > 1 ? p(R2[L]) : R2[L]));
    return n(q);
  }
  function C(b, B, k) {
    let M2 = b.getValue(), R2 = b.getParentNode(), q = R2.type !== "TypeParameterInstantiation" && R2.type !== "TSTypeParameterInstantiation" && R2.type !== "GenericTypeAnnotation" && R2.type !== "TSTypeReference" && R2.type !== "TSTypeAssertion" && R2.type !== "TupleTypeAnnotation" && R2.type !== "TSTupleType" && !(R2.type === "FunctionTypeParam" && !R2.name && b.getParentNode(1).this !== R2) && !((R2.type === "TypeAlias" || R2.type === "VariableDeclarator" || R2.type === "TSTypeAliasDeclaration") && _(B.originalText, M2)), J = $2(M2), L = b.map((j) => {
      let Y = k();
      return J || (Y = d2(2, Y)), t(j, Y, B);
    }, "types");
    if (J)
      return u(" | ", L);
    let Q = q && !_(B.originalText, M2), V = [y2([Q ? i : "", "| "]), u([i, "| "], L)];
    return g2(b, B) ? n([p(V), l]) : R2.type === "TupleTypeAnnotation" && R2.types.length > 1 || R2.type === "TSTupleType" && R2.elementTypes.length > 1 ? n([p([y2(["(", l]), V]), l, y2(")")]) : n(q ? p(V) : V);
  }
  function o(b, B, k) {
    let M2 = b.getValue(), R2 = [], q = b.getParentNode(0), J = b.getParentNode(1), L = b.getParentNode(2), Q = M2.type === "TSFunctionType" || !((q.type === "ObjectTypeProperty" || q.type === "ObjectTypeInternalSlot") && !q.variance && !q.optional && c(q) === c(M2) || q.type === "ObjectTypeCallProperty" || L && L.type === "DeclareFunction"), V = Q && (q.type === "TypeAnnotation" || q.type === "TSTypeAnnotation"), j = V && Q && (q.type === "TypeAnnotation" || q.type === "TSTypeAnnotation") && J.type === "ArrowFunctionExpression";
    w(q) && (Q = true, V = true), j && R2.push("(");
    let Y = x(b, k, B, false, true), ie2 = M2.returnType || M2.predicate || M2.typeAnnotation ? [Q ? " => " : ": ", k("returnType"), k("predicate"), k("typeAnnotation")] : "", ee2 = I2(M2, ie2);
    return R2.push(ee2 ? n(Y) : Y), ie2 && R2.push(ie2), j && R2.push(")"), n(R2);
  }
  function h(b, B, k) {
    let M2 = b.getValue(), R2 = M2.type === "TSTupleType" ? "elementTypes" : "types", q = M2[R2], J = a(q), L = J ? l : "";
    return n(["[", p([L, P(b, B, R2, k)]), y2(J && F(B, "all") ? "," : ""), s(b, B, true), L, "]"]);
  }
  function v2(b, B, k) {
    let M2 = b.getValue(), R2 = M2.type === "OptionalIndexedAccessType" && M2.optional ? "?.[" : "[";
    return [k("objectType"), R2, k("indexType"), "]"];
  }
  function S(b, B, k) {
    let M2 = b.getValue();
    return [M2.postfix ? "" : k, B("typeAnnotation"), M2.postfix ? k : ""];
  }
  r.exports = { printOpaqueType: D, printTypeAlias: T, printIntersectionType: m, printUnionType: C, printFunctionType: o, printTupleType: h, printIndexedAccessType: v2, shouldHugType: $2, printJSDocType: S };
} }), Lr$1 = te$1({ "src/language-js/print/type-parameters.js"(e, r) {
  ne();
  var { printDanglingComments: t } = et(), { builders: { join: s, line: a, hardline: n, softline: u, group: i, indent: l, ifBreak: p } } = qe(), { isTestCall: d2, hasComment: y2, CommentCheckFlags: g2, isTSXFile: c, shouldPrintComma: f, getFunctionParameters: E, isObjectType: _, getTypeScriptMappedTypeModifier: w } = Ke$1(), { createGroupIdMapper: F } = Ue$2(), { shouldHugType: N2 } = kr(), { isArrowFunctionVariableDeclarator: x } = Zt(), I2 = F("typeParameters");
  function P(T, m, C, o) {
    let h = T.getValue();
    if (!h[o])
      return "";
    if (!Array.isArray(h[o]))
      return C(o);
    let v2 = T.getNode(2), S = v2 && d2(v2), b = T.match((M2) => !(M2[o].length === 1 && _(M2[o][0])), void 0, (M2, R2) => R2 === "typeAnnotation", (M2) => M2.type === "Identifier", x);
    if (h[o].length === 0 || !b && (S || h[o].length === 1 && (h[o][0].type === "NullableTypeAnnotation" || N2(h[o][0]))))
      return ["<", s(", ", T.map(C, o)), $2(T, m), ">"];
    let k = h.type === "TSTypeParameterInstantiation" ? "" : E(h).length === 1 && c(m) && !h[o][0].constraint && T.getParentNode().type === "ArrowFunctionExpression" ? "," : f(m, "all") ? p(",") : "";
    return i(["<", l([u, s([",", a], T.map(C, o))]), k, u, ">"], { id: I2(h) });
  }
  function $2(T, m) {
    let C = T.getValue();
    if (!y2(C, g2.Dangling))
      return "";
    let o = !y2(C, g2.Line), h = t(T, m, o);
    return o ? h : [h, n];
  }
  function D(T, m, C) {
    let o = T.getValue(), h = [o.type === "TSTypeParameter" && o.const ? "const " : ""], v2 = T.getParentNode();
    return v2.type === "TSMappedType" ? (v2.readonly && h.push(w(v2.readonly, "readonly"), " "), h.push("[", C("name")), o.constraint && h.push(" in ", C("constraint")), v2.nameType && h.push(" as ", T.callParent(() => C("nameType"))), h.push("]"), h) : (o.variance && h.push(C("variance")), o.in && h.push("in "), o.out && h.push("out "), h.push(C("name")), o.bound && h.push(": ", C("bound")), o.constraint && h.push(" extends ", C("constraint")), o.default && h.push(" = ", C("default")), h);
  }
  r.exports = { printTypeParameter: D, printTypeParameters: P, getTypeParametersGroupId: I2 };
} }), er$1 = te$1({ "src/language-js/print/property.js"(e, r) {
  ne();
  var { printComments: t } = et(), { printString: s, printNumber: a } = Ue$2(), { isNumericLiteral: n, isSimpleNumber: u, isStringLiteral: i, isStringPropSafeToUnquote: l, rawText: p } = Ke$1(), { printAssignment: d2 } = Zt(), y2 = /* @__PURE__ */ new WeakMap();
  function g2(f, E, _) {
    let w = f.getNode();
    if (w.computed)
      return ["[", _("key"), "]"];
    let F = f.getParentNode(), { key: N2 } = w;
    if (E.quoteProps === "consistent" && !y2.has(F)) {
      let x = (F.properties || F.body || F.members).some((I2) => !I2.computed && I2.key && i(I2.key) && !l(I2, E));
      y2.set(F, x);
    }
    if ((N2.type === "Identifier" || n(N2) && u(a(p(N2))) && String(N2.value) === a(p(N2)) && !(E.parser === "typescript" || E.parser === "babel-ts")) && (E.parser === "json" || E.quoteProps === "consistent" && y2.get(F))) {
      let x = s(JSON.stringify(N2.type === "Identifier" ? N2.name : N2.value.toString()), E);
      return f.call((I2) => t(I2, x, E), "key");
    }
    return l(w, E) && (E.quoteProps === "as-needed" || E.quoteProps === "consistent" && !y2.get(F)) ? f.call((x) => t(x, /^\d/.test(N2.value) ? a(N2.value) : N2.value, E), "key") : _("key");
  }
  function c(f, E, _) {
    return f.getValue().shorthand ? _("value") : d2(f, E, _, g2(f, E, _), ":", "value");
  }
  r.exports = { printProperty: c, printPropertyKey: g2 };
} }), Or = te$1({ "src/language-js/print/function.js"(e, r) {
  ne();
  var t = Yt$1(), { printDanglingComments: s, printCommentsSeparately: a } = et(), n = lt$1(), { getNextNonSpaceNonCommentCharacterIndex: u } = Ue$2(), { builders: { line: i, softline: l, group: p, indent: d2, ifBreak: y2, hardline: g2, join: c, indentIfBreak: f }, utils: { removeLines: E, willBreak: _ } } = qe(), { ArgExpansionBailout: w } = Kt$1(), { getFunctionParameters: F, hasLeadingOwnLineComment: N2, isFlowAnnotationComment: x, isJsxNode: I2, isTemplateOnItsOwnLine: P, shouldPrintComma: $2, startsWithNoLookaheadToken: D, isBinaryish: T, isLineComment: m, hasComment: C, getComments: o, CommentCheckFlags: h, isCallLikeExpression: v2, isCallExpression: S, getCallArguments: b, hasNakedLeftSide: B, getLeftSide: k } = Ke$1(), { locEnd: M2 } = ut$1(), { printFunctionParameters: R2, shouldGroupFunctionParameters: q } = Ir(), { printPropertyKey: J } = er$1(), { printFunctionTypeParameters: L } = ct$1();
  function Q(U2, Z, se2, fe2) {
    let ge2 = U2.getValue(), he2 = false;
    if ((ge2.type === "FunctionDeclaration" || ge2.type === "FunctionExpression") && fe2 && fe2.expandLastArg) {
      let Pe2 = U2.getParentNode();
      S(Pe2) && b(Pe2).length > 1 && (he2 = true);
    }
    let we2 = [];
    ge2.type === "TSDeclareFunction" && ge2.declare && we2.push("declare "), ge2.async && we2.push("async "), ge2.generator ? we2.push("function* ") : we2.push("function "), ge2.id && we2.push(Z("id"));
    let ke2 = R2(U2, Z, se2, he2), Re2 = K2(U2, Z, se2), Ne2 = q(ge2, Re2);
    return we2.push(L(U2, se2, Z), p([Ne2 ? p(ke2) : ke2, Re2]), ge2.body ? " " : "", Z("body")), se2.semi && (ge2.declare || !ge2.body) && we2.push(";"), we2;
  }
  function V(U2, Z, se2) {
    let fe2 = U2.getNode(), { kind: ge2 } = fe2, he2 = fe2.value || fe2, we2 = [];
    return !ge2 || ge2 === "init" || ge2 === "method" || ge2 === "constructor" ? he2.async && we2.push("async ") : (t.ok(ge2 === "get" || ge2 === "set"), we2.push(ge2, " ")), he2.generator && we2.push("*"), we2.push(J(U2, Z, se2), fe2.optional || fe2.key.optional ? "?" : ""), fe2 === he2 ? we2.push(j(U2, Z, se2)) : he2.type === "FunctionExpression" ? we2.push(U2.call((ke2) => j(ke2, Z, se2), "value")) : we2.push(se2("value")), we2;
  }
  function j(U2, Z, se2) {
    let fe2 = U2.getNode(), ge2 = R2(U2, se2, Z), he2 = K2(U2, se2, Z), we2 = q(fe2, he2), ke2 = [L(U2, Z, se2), p([we2 ? p(ge2) : ge2, he2])];
    return fe2.body ? ke2.push(" ", se2("body")) : ke2.push(Z.semi ? ";" : ""), ke2;
  }
  function Y(U2, Z, se2, fe2) {
    let ge2 = U2.getValue(), he2 = [];
    if (ge2.async && he2.push("async "), W(U2, Z))
      he2.push(se2(["params", 0]));
    else {
      let ke2 = fe2 && (fe2.expandLastArg || fe2.expandFirstArg), Re2 = K2(U2, se2, Z);
      if (ke2) {
        if (_(Re2))
          throw new w();
        Re2 = p(E(Re2));
      }
      he2.push(p([R2(U2, se2, Z, ke2, true), Re2]));
    }
    let we2 = s(U2, Z, true, (ke2) => {
      let Re2 = u(Z.originalText, ke2, M2);
      return Re2 !== false && Z.originalText.slice(Re2, Re2 + 2) === "=>";
    });
    return we2 && he2.push(" ", we2), he2;
  }
  function ie2(U2, Z, se2, fe2, ge2, he2) {
    let we2 = U2.getName(), ke2 = U2.getParentNode(), Re2 = v2(ke2) && we2 === "callee", Ne2 = Boolean(Z && Z.assignmentLayout), Pe2 = he2.body.type !== "BlockStatement" && he2.body.type !== "ObjectExpression" && he2.body.type !== "SequenceExpression", oe = Re2 && Pe2 || Z && Z.assignmentLayout === "chain-tail-arrow-chain", H = Symbol("arrow-chain");
    return he2.body.type === "SequenceExpression" && (ge2 = p(["(", d2([l, ge2]), l, ")"])), p([p(d2([Re2 || Ne2 ? l : "", p(c([" =>", i], se2), { shouldBreak: fe2 })]), { id: H, shouldBreak: oe }), " =>", f(Pe2 ? d2([i, ge2]) : [" ", ge2], { groupId: H }), Re2 ? y2(l, "", { groupId: H }) : ""]);
  }
  function ee2(U2, Z, se2, fe2) {
    let ge2 = U2.getValue(), he2 = [], we2 = [], ke2 = false;
    if (function H() {
      let pe2 = Y(U2, Z, se2, fe2);
      if (he2.length === 0)
        he2.push(pe2);
      else {
        let { leading: X, trailing: le2 } = a(U2, Z);
        he2.push([X, pe2]), we2.unshift(le2);
      }
      ke2 = ke2 || ge2.returnType && F(ge2).length > 0 || ge2.typeParameters || F(ge2).some((X) => X.type !== "Identifier"), ge2.body.type !== "ArrowFunctionExpression" || fe2 && fe2.expandLastArg ? we2.unshift(se2("body", fe2)) : (ge2 = ge2.body, U2.call(H, "body"));
    }(), he2.length > 1)
      return ie2(U2, fe2, he2, ke2, we2, ge2);
    let Re2 = he2;
    if (Re2.push(" =>"), !N2(Z.originalText, ge2.body) && (ge2.body.type === "ArrayExpression" || ge2.body.type === "ObjectExpression" || ge2.body.type === "BlockStatement" || I2(ge2.body) || P(ge2.body, Z.originalText) || ge2.body.type === "ArrowFunctionExpression" || ge2.body.type === "DoExpression"))
      return p([...Re2, " ", we2]);
    if (ge2.body.type === "SequenceExpression")
      return p([...Re2, p([" (", d2([l, we2]), l, ")"])]);
    let Ne2 = (fe2 && fe2.expandLastArg || U2.getParentNode().type === "JSXExpressionContainer") && !C(ge2), Pe2 = fe2 && fe2.expandLastArg && $2(Z, "all"), oe = ge2.body.type === "ConditionalExpression" && !D(ge2.body, (H) => H.type === "ObjectExpression");
    return p([...Re2, p([d2([i, oe ? y2("", "(") : "", we2, oe ? y2("", ")") : ""]), Ne2 ? [y2(Pe2 ? "," : ""), l] : ""])]);
  }
  function ce2(U2) {
    let Z = F(U2);
    return Z.length === 1 && !U2.typeParameters && !C(U2, h.Dangling) && Z[0].type === "Identifier" && !Z[0].typeAnnotation && !C(Z[0]) && !Z[0].optional && !U2.predicate && !U2.returnType;
  }
  function W(U2, Z) {
    if (Z.arrowParens === "always")
      return false;
    if (Z.arrowParens === "avoid") {
      let se2 = U2.getValue();
      return ce2(se2);
    }
    return false;
  }
  function K2(U2, Z, se2) {
    let fe2 = U2.getValue(), ge2 = Z("returnType");
    if (fe2.returnType && x(se2.originalText, fe2.returnType))
      return [" /*: ", ge2, " */"];
    let he2 = [ge2];
    return fe2.returnType && fe2.returnType.typeAnnotation && he2.unshift(": "), fe2.predicate && he2.push(fe2.returnType ? " " : ": ", Z("predicate")), he2;
  }
  function de(U2, Z, se2) {
    let fe2 = U2.getValue(), ge2 = Z.semi ? ";" : "", he2 = [];
    fe2.argument && (z(Z, fe2.argument) ? he2.push([" (", d2([g2, se2("argument")]), g2, ")"]) : T(fe2.argument) || fe2.argument.type === "SequenceExpression" ? he2.push(p([y2(" (", " "), d2([l, se2("argument")]), l, y2(")")])) : he2.push(" ", se2("argument")));
    let we2 = o(fe2), ke2 = n(we2), Re2 = ke2 && m(ke2);
    return Re2 && he2.push(ge2), C(fe2, h.Dangling) && he2.push(" ", s(U2, Z, true)), Re2 || he2.push(ge2), he2;
  }
  function ue2(U2, Z, se2) {
    return ["return", de(U2, Z, se2)];
  }
  function Fe2(U2, Z, se2) {
    return ["throw", de(U2, Z, se2)];
  }
  function z(U2, Z) {
    if (N2(U2.originalText, Z))
      return true;
    if (B(Z)) {
      let se2 = Z, fe2;
      for (; fe2 = k(se2); )
        if (se2 = fe2, N2(U2.originalText, se2))
          return true;
    }
    return false;
  }
  r.exports = { printFunction: Q, printArrowFunction: ee2, printMethod: V, printReturnStatement: ue2, printThrowStatement: Fe2, printMethodInternal: j, shouldPrintParamsWithoutParens: W };
} }), eu = te$1({ "src/language-js/print/decorators.js"(e, r) {
  ne();
  var { isNonEmptyArray: t, hasNewline: s } = Ue$2(), { builders: { line: a, hardline: n, join: u, breakParent: i, group: l } } = qe(), { locStart: p, locEnd: d2 } = ut$1(), { getParentExportDeclaration: y2 } = Ke$1();
  function g2(w, F, N2) {
    let x = w.getValue();
    return l([u(a, w.map(N2, "decorators")), E(x, F) ? n : a]);
  }
  function c(w, F, N2) {
    return [u(n, w.map(N2, "declaration", "decorators")), n];
  }
  function f(w, F, N2) {
    let x = w.getValue(), { decorators: I2 } = x;
    if (!t(I2) || _(w.getParentNode()))
      return;
    let P = x.type === "ClassExpression" || x.type === "ClassDeclaration" || E(x, F);
    return [y2(w) ? n : P ? i : "", u(a, w.map(N2, "decorators")), a];
  }
  function E(w, F) {
    return w.decorators.some((N2) => s(F.originalText, d2(N2)));
  }
  function _(w) {
    if (w.type !== "ExportDefaultDeclaration" && w.type !== "ExportNamedDeclaration" && w.type !== "DeclareExportDeclaration")
      return false;
    let F = w.declaration && w.declaration.decorators;
    return t(F) && p(w) === p(F[0]);
  }
  r.exports = { printDecorators: f, printClassMemberDecorators: g2, printDecoratorsBeforeExport: c, hasDecoratorsBeforeExport: _ };
} }), tr$2 = te$1({ "src/language-js/print/class.js"(e, r) {
  ne();
  var { isNonEmptyArray: t, createGroupIdMapper: s } = Ue$2(), { printComments: a, printDanglingComments: n } = et(), { builders: { join: u, line: i, hardline: l, softline: p, group: d2, indent: y2, ifBreak: g2 } } = qe(), { hasComment: c, CommentCheckFlags: f } = Ke$1(), { getTypeParametersGroupId: E } = Lr$1(), { printMethod: _ } = Or(), { printOptionalToken: w, printTypeAnnotation: F, printDefiniteToken: N2 } = ct$1(), { printPropertyKey: x } = er$1(), { printAssignment: I2 } = Zt(), { printClassMemberDecorators: P } = eu();
  function $2(b, B, k) {
    let M2 = b.getValue(), R2 = [];
    M2.declare && R2.push("declare "), M2.abstract && R2.push("abstract "), R2.push("class");
    let q = M2.id && c(M2.id, f.Trailing) || M2.typeParameters && c(M2.typeParameters, f.Trailing) || M2.superClass && c(M2.superClass) || t(M2.extends) || t(M2.mixins) || t(M2.implements), J = [], L = [];
    if (M2.id && J.push(" ", k("id")), J.push(k("typeParameters")), M2.superClass) {
      let Q = [h(b, B, k), k("superTypeParameters")], V = b.call((j) => ["extends ", a(j, Q, B)], "superClass");
      q ? L.push(i, d2(V)) : L.push(" ", V);
    } else
      L.push(o(b, B, k, "extends"));
    if (L.push(o(b, B, k, "mixins"), o(b, B, k, "implements")), q) {
      let Q;
      C(M2) ? Q = [...J, y2(L)] : Q = y2([...J, L]), R2.push(d2(Q, { id: D(M2) }));
    } else
      R2.push(...J, ...L);
    return R2.push(" ", k("body")), R2;
  }
  var D = s("heritageGroup");
  function T(b) {
    return g2(l, "", { groupId: D(b) });
  }
  function m(b) {
    return ["superClass", "extends", "mixins", "implements"].filter((B) => Boolean(b[B])).length > 1;
  }
  function C(b) {
    return b.typeParameters && !c(b.typeParameters, f.Trailing | f.Line) && !m(b);
  }
  function o(b, B, k, M2) {
    let R2 = b.getValue();
    if (!t(R2[M2]))
      return "";
    let q = n(b, B, true, (J) => {
      let { marker: L } = J;
      return L === M2;
    });
    return [C(R2) ? g2(" ", i, { groupId: E(R2.typeParameters) }) : i, q, q && l, M2, d2(y2([i, u([",", i], b.map(k, M2))]))];
  }
  function h(b, B, k) {
    let M2 = k("superClass");
    return b.getParentNode().type === "AssignmentExpression" ? d2(g2(["(", y2([p, M2]), p, ")"], M2)) : M2;
  }
  function v2(b, B, k) {
    let M2 = b.getValue(), R2 = [];
    return t(M2.decorators) && R2.push(P(b, B, k)), M2.accessibility && R2.push(M2.accessibility + " "), M2.readonly && R2.push("readonly "), M2.declare && R2.push("declare "), M2.static && R2.push("static "), (M2.type === "TSAbstractMethodDefinition" || M2.abstract) && R2.push("abstract "), M2.override && R2.push("override "), R2.push(_(b, B, k)), R2;
  }
  function S(b, B, k) {
    let M2 = b.getValue(), R2 = [], q = B.semi ? ";" : "";
    return t(M2.decorators) && R2.push(P(b, B, k)), M2.accessibility && R2.push(M2.accessibility + " "), M2.declare && R2.push("declare "), M2.static && R2.push("static "), (M2.type === "TSAbstractPropertyDefinition" || M2.type === "TSAbstractAccessorProperty" || M2.abstract) && R2.push("abstract "), M2.override && R2.push("override "), M2.readonly && R2.push("readonly "), M2.variance && R2.push(k("variance")), (M2.type === "ClassAccessorProperty" || M2.type === "AccessorProperty" || M2.type === "TSAbstractAccessorProperty") && R2.push("accessor "), R2.push(x(b, B, k), w(b), N2(b), F(b, B, k)), [I2(b, B, k, R2, " =", "value"), q];
  }
  r.exports = { printClass: $2, printClassMethod: v2, printClassProperty: S, printHardlineAfterHeritage: T };
} }), ho$2 = te$1({ "src/language-js/print/interface.js"(e, r) {
  ne();
  var { isNonEmptyArray: t } = Ue$2(), { builders: { join: s, line: a, group: n, indent: u, ifBreak: i } } = qe(), { hasComment: l, identity: p, CommentCheckFlags: d2 } = Ke$1(), { getTypeParametersGroupId: y2 } = Lr$1(), { printTypeScriptModifiers: g2 } = ct$1();
  function c(f, E, _) {
    let w = f.getValue(), F = [];
    w.declare && F.push("declare "), w.type === "TSInterfaceDeclaration" && F.push(w.abstract ? "abstract " : "", g2(f, E, _)), F.push("interface");
    let N2 = [], x = [];
    w.type !== "InterfaceTypeAnnotation" && N2.push(" ", _("id"), _("typeParameters"));
    let I2 = w.typeParameters && !l(w.typeParameters, d2.Trailing | d2.Line);
    return t(w.extends) && x.push(I2 ? i(" ", a, { groupId: y2(w.typeParameters) }) : a, "extends ", (w.extends.length === 1 ? p : u)(s([",", a], f.map(_, "extends")))), w.id && l(w.id, d2.Trailing) || t(w.extends) ? I2 ? F.push(n([...N2, u(x)])) : F.push(n(u([...N2, ...x]))) : F.push(...N2, ...x), F.push(" ", _("body")), n(F);
  }
  r.exports = { printInterface: c };
} }), vo$2 = te$1({ "src/language-js/print/module.js"(e, r) {
  ne();
  var { isNonEmptyArray: t } = Ue$2(), { builders: { softline: s, group: a, indent: n, join: u, line: i, ifBreak: l, hardline: p } } = qe(), { printDanglingComments: d2 } = et(), { hasComment: y2, CommentCheckFlags: g2, shouldPrintComma: c, needsHardlineAfterDanglingComment: f, isStringLiteral: E, rawText: _ } = Ke$1(), { locStart: w, hasSameLoc: F } = ut$1(), { hasDecoratorsBeforeExport: N2, printDecoratorsBeforeExport: x } = eu();
  function I2(S, b, B) {
    let k = S.getValue(), M2 = b.semi ? ";" : "", R2 = [], { importKind: q } = k;
    return R2.push("import"), q && q !== "value" && R2.push(" ", q), R2.push(m(S, b, B), T(S, b, B), o(S, b, B), M2), R2;
  }
  function P(S, b, B) {
    let k = S.getValue(), M2 = [];
    N2(k) && M2.push(x(S, b, B));
    let { type: R2, exportKind: q, declaration: J } = k;
    return M2.push("export"), (k.default || R2 === "ExportDefaultDeclaration") && M2.push(" default"), y2(k, g2.Dangling) && (M2.push(" ", d2(S, b, true)), f(k) && M2.push(p)), J ? M2.push(" ", B("declaration")) : M2.push(q === "type" ? " type" : "", m(S, b, B), T(S, b, B), o(S, b, B)), D(k, b) && M2.push(";"), M2;
  }
  function $2(S, b, B) {
    let k = S.getValue(), M2 = b.semi ? ";" : "", R2 = [], { exportKind: q, exported: J } = k;
    return R2.push("export"), q === "type" && R2.push(" type"), R2.push(" *"), J && R2.push(" as ", B("exported")), R2.push(T(S, b, B), o(S, b, B), M2), R2;
  }
  function D(S, b) {
    if (!b.semi)
      return false;
    let { type: B, declaration: k } = S, M2 = S.default || B === "ExportDefaultDeclaration";
    if (!k)
      return true;
    let { type: R2 } = k;
    return !!(M2 && R2 !== "ClassDeclaration" && R2 !== "FunctionDeclaration" && R2 !== "TSInterfaceDeclaration" && R2 !== "DeclareClass" && R2 !== "DeclareFunction" && R2 !== "TSDeclareFunction" && R2 !== "EnumDeclaration");
  }
  function T(S, b, B) {
    let k = S.getValue();
    if (!k.source)
      return "";
    let M2 = [];
    return C(k, b) || M2.push(" from"), M2.push(" ", B("source")), M2;
  }
  function m(S, b, B) {
    let k = S.getValue();
    if (C(k, b))
      return "";
    let M2 = [" "];
    if (t(k.specifiers)) {
      let R2 = [], q = [];
      S.each(() => {
        let J = S.getValue().type;
        if (J === "ExportNamespaceSpecifier" || J === "ExportDefaultSpecifier" || J === "ImportNamespaceSpecifier" || J === "ImportDefaultSpecifier")
          R2.push(B());
        else if (J === "ExportSpecifier" || J === "ImportSpecifier")
          q.push(B());
        else
          throw new Error(`Unknown specifier type ${JSON.stringify(J)}`);
      }, "specifiers"), M2.push(u(", ", R2)), q.length > 0 && (R2.length > 0 && M2.push(", "), q.length > 1 || R2.length > 0 || k.specifiers.some((L) => y2(L)) ? M2.push(a(["{", n([b.bracketSpacing ? i : s, u([",", i], q)]), l(c(b) ? "," : ""), b.bracketSpacing ? i : s, "}"])) : M2.push(["{", b.bracketSpacing ? " " : "", ...q, b.bracketSpacing ? " " : "", "}"]));
    } else
      M2.push("{}");
    return M2;
  }
  function C(S, b) {
    let { type: B, importKind: k, source: M2, specifiers: R2 } = S;
    return B !== "ImportDeclaration" || t(R2) || k === "type" ? false : !/{\s*}/.test(b.originalText.slice(w(S), w(M2)));
  }
  function o(S, b, B) {
    let k = S.getNode();
    return t(k.assertions) ? [" assert {", b.bracketSpacing ? " " : "", u(", ", S.map(B, "assertions")), b.bracketSpacing ? " " : "", "}"] : "";
  }
  function h(S, b, B) {
    let k = S.getNode(), { type: M2 } = k, R2 = [], q = M2 === "ImportSpecifier" ? k.importKind : k.exportKind;
    q && q !== "value" && R2.push(q, " ");
    let J = M2.startsWith("Import"), L = J ? "imported" : "local", Q = J ? "local" : "exported", V = k[L], j = k[Q], Y = "", ie2 = "";
    return M2 === "ExportNamespaceSpecifier" || M2 === "ImportNamespaceSpecifier" ? Y = "*" : V && (Y = B(L)), j && !v2(k) && (ie2 = B(Q)), R2.push(Y, Y && ie2 ? " as " : "", ie2), R2;
  }
  function v2(S) {
    if (S.type !== "ImportSpecifier" && S.type !== "ExportSpecifier")
      return false;
    let { local: b, [S.type === "ImportSpecifier" ? "imported" : "exported"]: B } = S;
    if (b.type !== B.type || !F(b, B))
      return false;
    if (E(b))
      return b.value === B.value && _(b) === _(B);
    switch (b.type) {
      case "Identifier":
        return b.name === B.name;
      default:
        return false;
    }
  }
  r.exports = { printImportDeclaration: I2, printExportDeclaration: P, printExportAllDeclaration: $2, printModuleSpecifier: h };
} }), tu = te$1({ "src/language-js/print/object.js"(e, r) {
  ne();
  var { printDanglingComments: t } = et(), { builders: { line: s, softline: a, group: n, indent: u, ifBreak: i, hardline: l } } = qe(), { getLast: p, hasNewlineInRange: d2, hasNewline: y2, isNonEmptyArray: g2 } = Ue$2(), { shouldPrintComma: c, hasComment: f, getComments: E, CommentCheckFlags: _, isNextLineEmpty: w } = Ke$1(), { locStart: F, locEnd: N2 } = ut$1(), { printOptionalToken: x, printTypeAnnotation: I2 } = ct$1(), { shouldHugFunctionParameters: P } = Ir(), { shouldHugType: $2 } = kr(), { printHardlineAfterHeritage: D } = tr$2();
  function T(m, C, o) {
    let h = C.semi ? ";" : "", v2 = m.getValue(), S;
    v2.type === "TSTypeLiteral" ? S = "members" : v2.type === "TSInterfaceBody" ? S = "body" : S = "properties";
    let b = v2.type === "ObjectTypeAnnotation", B = [S];
    b && B.push("indexers", "callProperties", "internalSlots");
    let k = B.map((W) => v2[W][0]).sort((W, K2) => F(W) - F(K2))[0], M2 = m.getParentNode(0), R2 = b && M2 && (M2.type === "InterfaceDeclaration" || M2.type === "DeclareInterface" || M2.type === "DeclareClass") && m.getName() === "body", q = v2.type === "TSInterfaceBody" || R2 || v2.type === "ObjectPattern" && M2.type !== "FunctionDeclaration" && M2.type !== "FunctionExpression" && M2.type !== "ArrowFunctionExpression" && M2.type !== "ObjectMethod" && M2.type !== "ClassMethod" && M2.type !== "ClassPrivateMethod" && M2.type !== "AssignmentPattern" && M2.type !== "CatchClause" && v2.properties.some((W) => W.value && (W.value.type === "ObjectPattern" || W.value.type === "ArrayPattern")) || v2.type !== "ObjectPattern" && k && d2(C.originalText, F(v2), F(k)), J = R2 ? ";" : v2.type === "TSInterfaceBody" || v2.type === "TSTypeLiteral" ? i(h, ";") : ",", L = v2.type === "RecordExpression" ? "#{" : v2.exact ? "{|" : "{", Q = v2.exact ? "|}" : "}", V = [];
    for (let W of B)
      m.each((K2) => {
        let de = K2.getValue();
        V.push({ node: de, printed: o(), loc: F(de) });
      }, W);
    B.length > 1 && V.sort((W, K2) => W.loc - K2.loc);
    let j = [], Y = V.map((W) => {
      let K2 = [...j, n(W.printed)];
      return j = [J, s], (W.node.type === "TSPropertySignature" || W.node.type === "TSMethodSignature" || W.node.type === "TSConstructSignatureDeclaration") && f(W.node, _.PrettierIgnore) && j.shift(), w(W.node, C) && j.push(l), K2;
    });
    if (v2.inexact) {
      let W;
      if (f(v2, _.Dangling)) {
        let K2 = f(v2, _.Line);
        W = [t(m, C, true), K2 || y2(C.originalText, N2(p(E(v2)))) ? l : s, "..."];
      } else
        W = ["..."];
      Y.push([...j, ...W]);
    }
    let ie2 = p(v2[S]), ee2 = !(v2.inexact || ie2 && ie2.type === "RestElement" || ie2 && (ie2.type === "TSPropertySignature" || ie2.type === "TSCallSignatureDeclaration" || ie2.type === "TSMethodSignature" || ie2.type === "TSConstructSignatureDeclaration") && f(ie2, _.PrettierIgnore)), ce2;
    if (Y.length === 0) {
      if (!f(v2, _.Dangling))
        return [L, Q, I2(m, C, o)];
      ce2 = n([L, t(m, C), a, Q, x(m), I2(m, C, o)]);
    } else
      ce2 = [R2 && g2(v2.properties) ? D(M2) : "", L, u([C.bracketSpacing ? s : a, ...Y]), i(ee2 && (J !== "," || c(C)) ? J : ""), C.bracketSpacing ? s : a, Q, x(m), I2(m, C, o)];
    return m.match((W) => W.type === "ObjectPattern" && !W.decorators, (W, K2, de) => P(W) && (K2 === "params" || K2 === "parameters" || K2 === "this" || K2 === "rest") && de === 0) || m.match($2, (W, K2) => K2 === "typeAnnotation", (W, K2) => K2 === "typeAnnotation", (W, K2, de) => P(W) && (K2 === "params" || K2 === "parameters" || K2 === "this" || K2 === "rest") && de === 0) || !q && m.match((W) => W.type === "ObjectPattern", (W) => W.type === "AssignmentExpression" || W.type === "VariableDeclarator") ? ce2 : n(ce2, { shouldBreak: q });
  }
  r.exports = { printObject: T };
} }), id = te$1({ "src/language-js/print/flow.js"(e, r) {
  ne();
  var t = Yt$1(), { printDanglingComments: s } = et(), { printString: a, printNumber: n } = Ue$2(), { builders: { hardline: u, softline: i, group: l, indent: p } } = qe(), { getParentExportDeclaration: d2, isFunctionNotation: y2, isGetterOrSetter: g2, rawText: c, shouldPrintComma: f } = Ke$1(), { locStart: E, locEnd: _ } = ut$1(), { replaceTextEndOfLine: w } = Xt$2(), { printClass: F } = tr$2(), { printOpaqueType: N2, printTypeAlias: x, printIntersectionType: I2, printUnionType: P, printFunctionType: $2, printTupleType: D, printIndexedAccessType: T } = kr(), { printInterface: m } = ho$2(), { printTypeParameter: C, printTypeParameters: o } = Lr$1(), { printExportDeclaration: h, printExportAllDeclaration: v2 } = vo$2(), { printArrayItems: S } = Qt(), { printObject: b } = tu(), { printPropertyKey: B } = er$1(), { printOptionalToken: k, printTypeAnnotation: M2, printRestSpread: R2 } = ct$1();
  function q(L, Q, V) {
    let j = L.getValue(), Y = Q.semi ? ";" : "", ie2 = [];
    switch (j.type) {
      case "DeclareClass":
        return J(L, F(L, Q, V));
      case "DeclareFunction":
        return J(L, ["function ", V("id"), j.predicate ? " " : "", V("predicate"), Y]);
      case "DeclareModule":
        return J(L, ["module ", V("id"), " ", V("body")]);
      case "DeclareModuleExports":
        return J(L, ["module.exports", ": ", V("typeAnnotation"), Y]);
      case "DeclareVariable":
        return J(L, ["var ", V("id"), Y]);
      case "DeclareOpaqueType":
        return J(L, N2(L, Q, V));
      case "DeclareInterface":
        return J(L, m(L, Q, V));
      case "DeclareTypeAlias":
        return J(L, x(L, Q, V));
      case "DeclareExportDeclaration":
        return J(L, h(L, Q, V));
      case "DeclareExportAllDeclaration":
        return J(L, v2(L, Q, V));
      case "OpaqueType":
        return N2(L, Q, V);
      case "TypeAlias":
        return x(L, Q, V);
      case "IntersectionTypeAnnotation":
        return I2(L, Q, V);
      case "UnionTypeAnnotation":
        return P(L, Q, V);
      case "FunctionTypeAnnotation":
        return $2(L, Q, V);
      case "TupleTypeAnnotation":
        return D(L, Q, V);
      case "GenericTypeAnnotation":
        return [V("id"), o(L, Q, V, "typeParameters")];
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        return T(L, Q, V);
      case "TypeAnnotation":
        return V("typeAnnotation");
      case "TypeParameter":
        return C(L, Q, V);
      case "TypeofTypeAnnotation":
        return ["typeof ", V("argument")];
      case "ExistsTypeAnnotation":
        return "*";
      case "EmptyTypeAnnotation":
        return "empty";
      case "MixedTypeAnnotation":
        return "mixed";
      case "ArrayTypeAnnotation":
        return [V("elementType"), "[]"];
      case "BooleanLiteralTypeAnnotation":
        return String(j.value);
      case "EnumDeclaration":
        return ["enum ", V("id"), " ", V("body")];
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody": {
        if (j.type === "EnumSymbolBody" || j.explicitType) {
          let ee2 = null;
          switch (j.type) {
            case "EnumBooleanBody":
              ee2 = "boolean";
              break;
            case "EnumNumberBody":
              ee2 = "number";
              break;
            case "EnumStringBody":
              ee2 = "string";
              break;
            case "EnumSymbolBody":
              ee2 = "symbol";
              break;
          }
          ie2.push("of ", ee2, " ");
        }
        if (j.members.length === 0 && !j.hasUnknownMembers)
          ie2.push(l(["{", s(L, Q), i, "}"]));
        else {
          let ee2 = j.members.length > 0 ? [u, S(L, Q, "members", V), j.hasUnknownMembers || f(Q) ? "," : ""] : [];
          ie2.push(l(["{", p([...ee2, ...j.hasUnknownMembers ? [u, "..."] : []]), s(L, Q, true), u, "}"]));
        }
        return ie2;
      }
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
        return [V("id"), " = ", typeof j.init == "object" ? V("init") : String(j.init)];
      case "EnumDefaultedMember":
        return V("id");
      case "FunctionTypeParam": {
        let ee2 = j.name ? V("name") : L.getParentNode().this === j ? "this" : "";
        return [ee2, k(L), ee2 ? ": " : "", V("typeAnnotation")];
      }
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
        return m(L, Q, V);
      case "ClassImplements":
      case "InterfaceExtends":
        return [V("id"), V("typeParameters")];
      case "NullableTypeAnnotation":
        return ["?", V("typeAnnotation")];
      case "Variance": {
        let { kind: ee2 } = j;
        return t.ok(ee2 === "plus" || ee2 === "minus"), ee2 === "plus" ? "+" : "-";
      }
      case "ObjectTypeCallProperty":
        return j.static && ie2.push("static "), ie2.push(V("value")), ie2;
      case "ObjectTypeIndexer":
        return [j.static ? "static " : "", j.variance ? V("variance") : "", "[", V("id"), j.id ? ": " : "", V("key"), "]: ", V("value")];
      case "ObjectTypeProperty": {
        let ee2 = "";
        return j.proto ? ee2 = "proto " : j.static && (ee2 = "static "), [ee2, g2(j) ? j.kind + " " : "", j.variance ? V("variance") : "", B(L, Q, V), k(L), y2(j) ? "" : ": ", V("value")];
      }
      case "ObjectTypeAnnotation":
        return b(L, Q, V);
      case "ObjectTypeInternalSlot":
        return [j.static ? "static " : "", "[[", V("id"), "]]", k(L), j.method ? "" : ": ", V("value")];
      case "ObjectTypeSpreadProperty":
        return R2(L, Q, V);
      case "QualifiedTypeofIdentifier":
      case "QualifiedTypeIdentifier":
        return [V("qualification"), ".", V("id")];
      case "StringLiteralTypeAnnotation":
        return w(a(c(j), Q));
      case "NumberLiteralTypeAnnotation":
        t.strictEqual(typeof j.value, "number");
      case "BigIntLiteralTypeAnnotation":
        return j.extra ? n(j.extra.raw) : n(j.raw);
      case "TypeCastExpression":
        return ["(", V("expression"), M2(L, Q, V), ")"];
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation": {
        let ee2 = o(L, Q, V, "params");
        if (Q.parser === "flow") {
          let ce2 = E(j), W = _(j), K2 = Q.originalText.lastIndexOf("/*", ce2), de = Q.originalText.indexOf("*/", W);
          if (K2 !== -1 && de !== -1) {
            let ue2 = Q.originalText.slice(K2 + 2, de).trim();
            if (ue2.startsWith("::") && !ue2.includes("/*") && !ue2.includes("*/"))
              return ["/*:: ", ee2, " */"];
          }
        }
        return ee2;
      }
      case "InferredPredicate":
        return "%checks";
      case "DeclaredPredicate":
        return ["%checks(", V("value"), ")"];
      case "AnyTypeAnnotation":
        return "any";
      case "BooleanTypeAnnotation":
        return "boolean";
      case "BigIntTypeAnnotation":
        return "bigint";
      case "NullLiteralTypeAnnotation":
        return "null";
      case "NumberTypeAnnotation":
        return "number";
      case "SymbolTypeAnnotation":
        return "symbol";
      case "StringTypeAnnotation":
        return "string";
      case "VoidTypeAnnotation":
        return "void";
      case "ThisTypeAnnotation":
        return "this";
      case "Node":
      case "Printable":
      case "SourceLocation":
      case "Position":
      case "Statement":
      case "Function":
      case "Pattern":
      case "Expression":
      case "Declaration":
      case "Specifier":
      case "NamedSpecifier":
      case "Comment":
      case "MemberTypeAnnotation":
      case "Type":
        throw new Error("unprintable type: " + JSON.stringify(j.type));
    }
  }
  function J(L, Q) {
    let V = d2(L);
    return V ? (t.strictEqual(V.type, "DeclareExportDeclaration"), Q) : ["declare ", Q];
  }
  r.exports = { printFlow: q };
} }), ad = te$1({ "src/language-js/utils/is-ts-keyword-type.js"(e, r) {
  ne();
  function t(s) {
    let { type: a } = s;
    return a.startsWith("TS") && a.endsWith("Keyword");
  }
  r.exports = t;
} }), Co$2 = te$1({ "src/language-js/print/ternary.js"(e, r) {
  ne();
  var { hasNewlineInRange: t } = Ue$2(), { isJsxNode: s, getComments: a, isCallExpression: n, isMemberExpression: u, isTSTypeExpression: i } = Ke$1(), { locStart: l, locEnd: p } = ut$1(), d2 = _t$2(), { builders: { line: y2, softline: g2, group: c, indent: f, align: E, ifBreak: _, dedent: w, breakParent: F } } = qe();
  function N2(D) {
    let T = [D];
    for (let m = 0; m < T.length; m++) {
      let C = T[m];
      for (let o of ["test", "consequent", "alternate"]) {
        let h = C[o];
        if (s(h))
          return true;
        h.type === "ConditionalExpression" && T.push(h);
      }
    }
    return false;
  }
  function x(D, T, m) {
    let C = D.getValue(), o = C.type === "ConditionalExpression", h = o ? "alternate" : "falseType", v2 = D.getParentNode(), S = o ? m("test") : [m("checkType"), " ", "extends", " ", m("extendsType")];
    return v2.type === C.type && v2[h] === C ? E(2, S) : S;
  }
  var I2 = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
  function P(D) {
    let T = D.getValue();
    if (T.type !== "ConditionalExpression")
      return false;
    let m, C = T;
    for (let o = 0; !m; o++) {
      let h = D.getParentNode(o);
      if (n(h) && h.callee === C || u(h) && h.object === C || h.type === "TSNonNullExpression" && h.expression === C) {
        C = h;
        continue;
      }
      h.type === "NewExpression" && h.callee === C || i(h) && h.expression === C ? (m = D.getParentNode(o + 1), C = h) : m = h;
    }
    return C === T ? false : m[I2.get(m.type)] === C;
  }
  function $2(D, T, m) {
    let C = D.getValue(), o = C.type === "ConditionalExpression", h = o ? "consequent" : "trueType", v2 = o ? "alternate" : "falseType", S = o ? ["test"] : ["checkType", "extendsType"], b = C[h], B = C[v2], k = [], M2 = false, R2 = D.getParentNode(), q = R2.type === C.type && S.some((ue2) => R2[ue2] === C), J = R2.type === C.type && !q, L, Q, V = 0;
    do
      Q = L || C, L = D.getParentNode(V), V++;
    while (L && L.type === C.type && S.every((ue2) => L[ue2] !== Q));
    let j = L || R2, Y = Q;
    if (o && (s(C[S[0]]) || s(b) || s(B) || N2(Y))) {
      M2 = true, J = true;
      let ue2 = (z) => [_("("), f([g2, z]), g2, _(")")], Fe2 = (z) => z.type === "NullLiteral" || z.type === "Literal" && z.value === null || z.type === "Identifier" && z.name === "undefined";
      k.push(" ? ", Fe2(b) ? m(h) : ue2(m(h)), " : ", B.type === C.type || Fe2(B) ? m(v2) : ue2(m(v2)));
    } else {
      let ue2 = [y2, "? ", b.type === C.type ? _("", "(") : "", E(2, m(h)), b.type === C.type ? _("", ")") : "", y2, ": ", B.type === C.type ? m(v2) : E(2, m(v2))];
      k.push(R2.type !== C.type || R2[v2] === C || q ? ue2 : T.useTabs ? w(f(ue2)) : E(Math.max(0, T.tabWidth - 2), ue2));
    }
    let ee2 = [...S.map((ue2) => a(C[ue2])), a(b), a(B)].flat().some((ue2) => d2(ue2) && t(T.originalText, l(ue2), p(ue2))), ce2 = (ue2) => R2 === j ? c(ue2, { shouldBreak: ee2 }) : ee2 ? [ue2, F] : ue2, W = !M2 && (u(R2) || R2.type === "NGPipeExpression" && R2.left === C) && !R2.computed, K2 = P(D), de = ce2([x(D, T, m), J ? k : f(k), o && W && !K2 ? g2 : ""]);
    return q || K2 ? c([f([g2, de]), g2]) : de;
  }
  r.exports = { printTernary: $2 };
} }), Eo$2 = te$1({ "src/language-js/print/statement.js"(e, r) {
  ne();
  var { builders: { hardline: t } } = qe(), s = Ot$1(), { getLeftSidePathName: a, hasNakedLeftSide: n, isJsxNode: u, isTheOnlyJsxElementInMarkdown: i, hasComment: l, CommentCheckFlags: p, isNextLineEmpty: d2 } = Ke$1(), { shouldPrintParamsWithoutParens: y2 } = Or();
  function g2(x, I2, P, $2) {
    let D = x.getValue(), T = [], m = D.type === "ClassBody", C = c(D[$2]);
    return x.each((o, h, v2) => {
      let S = o.getValue();
      if (S.type === "EmptyStatement")
        return;
      let b = P();
      !I2.semi && !m && !i(I2, o) && f(o, I2) ? l(S, p.Leading) ? T.push(P([], { needsSemi: true })) : T.push(";", b) : T.push(b), !I2.semi && m && F(S) && N2(S, v2[h + 1]) && T.push(";"), S !== C && (T.push(t), d2(S, I2) && T.push(t));
    }, $2), T;
  }
  function c(x) {
    for (let I2 = x.length - 1; I2 >= 0; I2--) {
      let P = x[I2];
      if (P.type !== "EmptyStatement")
        return P;
    }
  }
  function f(x, I2) {
    return x.getNode().type !== "ExpressionStatement" ? false : x.call(($2) => E($2, I2), "expression");
  }
  function E(x, I2) {
    let P = x.getValue();
    switch (P.type) {
      case "ParenthesizedExpression":
      case "TypeCastExpression":
      case "ArrayExpression":
      case "ArrayPattern":
      case "TemplateLiteral":
      case "TemplateElement":
      case "RegExpLiteral":
        return true;
      case "ArrowFunctionExpression": {
        if (!y2(x, I2))
          return true;
        break;
      }
      case "UnaryExpression": {
        let { prefix: $2, operator: D } = P;
        if ($2 && (D === "+" || D === "-"))
          return true;
        break;
      }
      case "BindExpression": {
        if (!P.object)
          return true;
        break;
      }
      case "Literal": {
        if (P.regex)
          return true;
        break;
      }
      default:
        if (u(P))
          return true;
    }
    return s(x, I2) ? true : n(P) ? x.call(($2) => E($2, I2), ...a(x, P)) : false;
  }
  function _(x, I2, P) {
    return g2(x, I2, P, "body");
  }
  function w(x, I2, P) {
    return g2(x, I2, P, "consequent");
  }
  var F = (x) => {
    let { type: I2 } = x;
    return I2 === "ClassProperty" || I2 === "PropertyDefinition" || I2 === "ClassPrivateProperty" || I2 === "ClassAccessorProperty" || I2 === "AccessorProperty" || I2 === "TSAbstractPropertyDefinition" || I2 === "TSAbstractAccessorProperty";
  };
  function N2(x, I2) {
    let { type: P, name: $2 } = x.key;
    if (!x.computed && P === "Identifier" && ($2 === "static" || $2 === "get" || $2 === "set" || $2 === "accessor") && !x.value && !x.typeAnnotation)
      return true;
    if (!I2 || I2.static || I2.accessibility)
      return false;
    if (!I2.computed) {
      let D = I2.key && I2.key.name;
      if (D === "in" || D === "instanceof")
        return true;
    }
    if (F(I2) && I2.variance && !I2.static && !I2.declare)
      return true;
    switch (I2.type) {
      case "ClassProperty":
      case "PropertyDefinition":
      case "TSAbstractPropertyDefinition":
        return I2.computed;
      case "MethodDefinition":
      case "TSAbstractMethodDefinition":
      case "ClassMethod":
      case "ClassPrivateMethod": {
        if ((I2.value ? I2.value.async : I2.async) || I2.kind === "get" || I2.kind === "set")
          return false;
        let T = I2.value ? I2.value.generator : I2.generator;
        return !!(I2.computed || T);
      }
      case "TSIndexSignature":
        return true;
    }
    return false;
  }
  r.exports = { printBody: _, printSwitchCaseConsequent: w };
} }), Fo$1 = te$1({ "src/language-js/print/block.js"(e, r) {
  ne();
  var { printDanglingComments: t } = et(), { isNonEmptyArray: s } = Ue$2(), { builders: { hardline: a, indent: n } } = qe(), { hasComment: u, CommentCheckFlags: i, isNextLineEmpty: l } = Ke$1(), { printHardlineAfterHeritage: p } = tr$2(), { printBody: d2 } = Eo$2();
  function y2(c, f, E) {
    let _ = c.getValue(), w = [];
    if (_.type === "StaticBlock" && w.push("static "), _.type === "ClassBody" && s(_.body)) {
      let N2 = c.getParentNode();
      w.push(p(N2));
    }
    w.push("{");
    let F = g2(c, f, E);
    if (F)
      w.push(n([a, F]), a);
    else {
      let N2 = c.getParentNode(), x = c.getParentNode(1);
      N2.type === "ArrowFunctionExpression" || N2.type === "FunctionExpression" || N2.type === "FunctionDeclaration" || N2.type === "ObjectMethod" || N2.type === "ClassMethod" || N2.type === "ClassPrivateMethod" || N2.type === "ForStatement" || N2.type === "WhileStatement" || N2.type === "DoWhileStatement" || N2.type === "DoExpression" || N2.type === "CatchClause" && !x.finalizer || N2.type === "TSModuleDeclaration" || N2.type === "TSDeclareFunction" || _.type === "StaticBlock" || _.type === "ClassBody" || w.push(a);
    }
    return w.push("}"), w;
  }
  function g2(c, f, E) {
    let _ = c.getValue(), w = s(_.directives), F = _.body.some((I2) => I2.type !== "EmptyStatement"), N2 = u(_, i.Dangling);
    if (!w && !F && !N2)
      return "";
    let x = [];
    if (w && c.each((I2, P, $2) => {
      x.push(E()), (P < $2.length - 1 || F || N2) && (x.push(a), l(I2.getValue(), f) && x.push(a));
    }, "directives"), F && x.push(d2(c, f, E)), N2 && x.push(t(c, f, true)), _.type === "Program") {
      let I2 = c.getParentNode();
      (!I2 || I2.type !== "ModuleExpression") && x.push(a);
    }
    return x;
  }
  r.exports = { printBlock: y2, printBlockBody: g2 };
} }), od = te$1({ "src/language-js/print/typescript.js"(e, r) {
  ne();
  var { printDanglingComments: t } = et(), { hasNewlineInRange: s } = Ue$2(), { builders: { join: a, line: n, hardline: u, softline: i, group: l, indent: p, conditionalGroup: d2, ifBreak: y2 } } = qe(), { isStringLiteral: g2, getTypeScriptMappedTypeModifier: c, shouldPrintComma: f, isCallExpression: E, isMemberExpression: _ } = Ke$1(), w = ad(), { locStart: F, locEnd: N2 } = ut$1(), { printOptionalToken: x, printTypeScriptModifiers: I2 } = ct$1(), { printTernary: P } = Co$2(), { printFunctionParameters: $2, shouldGroupFunctionParameters: D } = Ir(), { printTemplateLiteral: T } = Lt$2(), { printArrayItems: m } = Qt(), { printObject: C } = tu(), { printClassProperty: o, printClassMethod: h } = tr$2(), { printTypeParameter: v2, printTypeParameters: S } = Lr$1(), { printPropertyKey: b } = er$1(), { printFunction: B, printMethodInternal: k } = Or(), { printInterface: M2 } = ho$2(), { printBlock: R2 } = Fo$1(), { printTypeAlias: q, printIntersectionType: J, printUnionType: L, printFunctionType: Q, printTupleType: V, printIndexedAccessType: j, printJSDocType: Y } = kr();
  function ie2(ee2, ce2, W) {
    let K2 = ee2.getValue();
    if (!K2.type.startsWith("TS"))
      return;
    if (w(K2))
      return K2.type.slice(2, -7).toLowerCase();
    let de = ce2.semi ? ";" : "", ue2 = [];
    switch (K2.type) {
      case "TSThisType":
        return "this";
      case "TSTypeAssertion": {
        let Fe2 = !(K2.expression.type === "ArrayExpression" || K2.expression.type === "ObjectExpression"), z = l(["<", p([i, W("typeAnnotation")]), i, ">"]), U2 = [y2("("), p([i, W("expression")]), i, y2(")")];
        return Fe2 ? d2([[z, W("expression")], [z, l(U2, { shouldBreak: true })], [z, W("expression")]]) : l([z, W("expression")]);
      }
      case "TSDeclareFunction":
        return B(ee2, W, ce2);
      case "TSExportAssignment":
        return ["export = ", W("expression"), de];
      case "TSModuleBlock":
        return R2(ee2, ce2, W);
      case "TSInterfaceBody":
      case "TSTypeLiteral":
        return C(ee2, ce2, W);
      case "TSTypeAliasDeclaration":
        return q(ee2, ce2, W);
      case "TSQualifiedName":
        return a(".", [W("left"), W("right")]);
      case "TSAbstractMethodDefinition":
      case "TSDeclareMethod":
        return h(ee2, ce2, W);
      case "TSAbstractAccessorProperty":
      case "TSAbstractPropertyDefinition":
        return o(ee2, ce2, W);
      case "TSInterfaceHeritage":
      case "TSExpressionWithTypeArguments":
        return ue2.push(W("expression")), K2.typeParameters && ue2.push(W("typeParameters")), ue2;
      case "TSTemplateLiteralType":
        return T(ee2, W, ce2);
      case "TSNamedTupleMember":
        return [W("label"), K2.optional ? "?" : "", ": ", W("elementType")];
      case "TSRestType":
        return ["...", W("typeAnnotation")];
      case "TSOptionalType":
        return [W("typeAnnotation"), "?"];
      case "TSInterfaceDeclaration":
        return M2(ee2, ce2, W);
      case "TSClassImplements":
        return [W("expression"), W("typeParameters")];
      case "TSTypeParameterDeclaration":
      case "TSTypeParameterInstantiation":
        return S(ee2, ce2, W, "params");
      case "TSTypeParameter":
        return v2(ee2, ce2, W);
      case "TSSatisfiesExpression":
      case "TSAsExpression": {
        let Fe2 = K2.type === "TSAsExpression" ? "as" : "satisfies";
        ue2.push(W("expression"), ` ${Fe2} `, W("typeAnnotation"));
        let z = ee2.getParentNode();
        return E(z) && z.callee === K2 || _(z) && z.object === K2 ? l([p([i, ...ue2]), i]) : ue2;
      }
      case "TSArrayType":
        return [W("elementType"), "[]"];
      case "TSPropertySignature":
        return K2.readonly && ue2.push("readonly "), ue2.push(b(ee2, ce2, W), x(ee2)), K2.typeAnnotation && ue2.push(": ", W("typeAnnotation")), K2.initializer && ue2.push(" = ", W("initializer")), ue2;
      case "TSParameterProperty":
        return K2.accessibility && ue2.push(K2.accessibility + " "), K2.export && ue2.push("export "), K2.static && ue2.push("static "), K2.override && ue2.push("override "), K2.readonly && ue2.push("readonly "), ue2.push(W("parameter")), ue2;
      case "TSTypeQuery":
        return ["typeof ", W("exprName"), W("typeParameters")];
      case "TSIndexSignature": {
        let Fe2 = ee2.getParentNode(), z = K2.parameters.length > 1 ? y2(f(ce2) ? "," : "") : "", U2 = l([p([i, a([", ", i], ee2.map(W, "parameters"))]), z, i]);
        return [K2.export ? "export " : "", K2.accessibility ? [K2.accessibility, " "] : "", K2.static ? "static " : "", K2.readonly ? "readonly " : "", K2.declare ? "declare " : "", "[", K2.parameters ? U2 : "", K2.typeAnnotation ? "]: " : "]", K2.typeAnnotation ? W("typeAnnotation") : "", Fe2.type === "ClassBody" ? de : ""];
      }
      case "TSTypePredicate":
        return [K2.asserts ? "asserts " : "", W("parameterName"), K2.typeAnnotation ? [" is ", W("typeAnnotation")] : ""];
      case "TSNonNullExpression":
        return [W("expression"), "!"];
      case "TSImportType":
        return [K2.isTypeOf ? "typeof " : "", "import(", W(K2.parameter ? "parameter" : "argument"), ")", K2.qualifier ? [".", W("qualifier")] : "", S(ee2, ce2, W, "typeParameters")];
      case "TSLiteralType":
        return W("literal");
      case "TSIndexedAccessType":
        return j(ee2, ce2, W);
      case "TSConstructSignatureDeclaration":
      case "TSCallSignatureDeclaration":
      case "TSConstructorType": {
        if (K2.type === "TSConstructorType" && K2.abstract && ue2.push("abstract "), K2.type !== "TSCallSignatureDeclaration" && ue2.push("new "), ue2.push(l($2(ee2, W, ce2, false, true))), K2.returnType || K2.typeAnnotation) {
          let Fe2 = K2.type === "TSConstructorType";
          ue2.push(Fe2 ? " => " : ": ", W("returnType"), W("typeAnnotation"));
        }
        return ue2;
      }
      case "TSTypeOperator":
        return [K2.operator, " ", W("typeAnnotation")];
      case "TSMappedType": {
        let Fe2 = s(ce2.originalText, F(K2), N2(K2));
        return l(["{", p([ce2.bracketSpacing ? n : i, W("typeParameter"), K2.optional ? c(K2.optional, "?") : "", K2.typeAnnotation ? ": " : "", W("typeAnnotation"), y2(de)]), t(ee2, ce2, true), ce2.bracketSpacing ? n : i, "}"], { shouldBreak: Fe2 });
      }
      case "TSMethodSignature": {
        let Fe2 = K2.kind && K2.kind !== "method" ? `${K2.kind} ` : "";
        ue2.push(K2.accessibility ? [K2.accessibility, " "] : "", Fe2, K2.export ? "export " : "", K2.static ? "static " : "", K2.readonly ? "readonly " : "", K2.abstract ? "abstract " : "", K2.declare ? "declare " : "", K2.computed ? "[" : "", W("key"), K2.computed ? "]" : "", x(ee2));
        let z = $2(ee2, W, ce2, false, true), U2 = K2.returnType ? "returnType" : "typeAnnotation", Z = K2[U2], se2 = Z ? W(U2) : "", fe2 = D(K2, se2);
        return ue2.push(fe2 ? l(z) : z), Z && ue2.push(": ", l(se2)), l(ue2);
      }
      case "TSNamespaceExportDeclaration":
        return ue2.push("export as namespace ", W("id")), ce2.semi && ue2.push(";"), l(ue2);
      case "TSEnumDeclaration":
        return K2.declare && ue2.push("declare "), K2.modifiers && ue2.push(I2(ee2, ce2, W)), K2.const && ue2.push("const "), ue2.push("enum ", W("id"), " "), K2.members.length === 0 ? ue2.push(l(["{", t(ee2, ce2), i, "}"])) : ue2.push(l(["{", p([u, m(ee2, ce2, "members", W), f(ce2, "es5") ? "," : ""]), t(ee2, ce2, true), u, "}"])), ue2;
      case "TSEnumMember":
        return K2.computed ? ue2.push("[", W("id"), "]") : ue2.push(W("id")), K2.initializer && ue2.push(" = ", W("initializer")), ue2;
      case "TSImportEqualsDeclaration":
        return K2.isExport && ue2.push("export "), ue2.push("import "), K2.importKind && K2.importKind !== "value" && ue2.push(K2.importKind, " "), ue2.push(W("id"), " = ", W("moduleReference")), ce2.semi && ue2.push(";"), l(ue2);
      case "TSExternalModuleReference":
        return ["require(", W("expression"), ")"];
      case "TSModuleDeclaration": {
        let Fe2 = ee2.getParentNode(), z = g2(K2.id), U2 = Fe2.type === "TSModuleDeclaration", Z = K2.body && K2.body.type === "TSModuleDeclaration";
        if (U2)
          ue2.push(".");
        else {
          K2.declare && ue2.push("declare "), ue2.push(I2(ee2, ce2, W));
          let se2 = ce2.originalText.slice(F(K2), F(K2.id));
          K2.id.type === "Identifier" && K2.id.name === "global" && !/namespace|module/.test(se2) || ue2.push(z || /(?:^|\s)module(?:\s|$)/.test(se2) ? "module " : "namespace ");
        }
        return ue2.push(W("id")), Z ? ue2.push(W("body")) : K2.body ? ue2.push(" ", l(W("body"))) : ue2.push(de), ue2;
      }
      case "TSConditionalType":
        return P(ee2, ce2, W);
      case "TSInferType":
        return ["infer", " ", W("typeParameter")];
      case "TSIntersectionType":
        return J(ee2, ce2, W);
      case "TSUnionType":
        return L(ee2, ce2, W);
      case "TSFunctionType":
        return Q(ee2, ce2, W);
      case "TSTupleType":
        return V(ee2, ce2, W);
      case "TSTypeReference":
        return [W("typeName"), S(ee2, ce2, W, "typeParameters")];
      case "TSTypeAnnotation":
        return W("typeAnnotation");
      case "TSEmptyBodyFunctionExpression":
        return k(ee2, ce2, W);
      case "TSJSDocAllType":
        return "*";
      case "TSJSDocUnknownType":
        return "?";
      case "TSJSDocNullableType":
        return Y(ee2, W, "?");
      case "TSJSDocNonNullableType":
        return Y(ee2, W, "!");
      case "TSInstantiationExpression":
        return [W("expression"), W("typeParameters")];
      default:
        throw new Error(`Unknown TypeScript node type: ${JSON.stringify(K2.type)}.`);
    }
  }
  r.exports = { printTypescript: ie2 };
} }), ld = te$1({ "src/language-js/print/comment.js"(e, r) {
  ne();
  var { hasNewline: t } = Ue$2(), { builders: { join: s, hardline: a }, utils: { replaceTextEndOfLine: n } } = qe(), { isLineComment: u } = Ke$1(), { locStart: i, locEnd: l } = ut$1(), p = _t$2();
  function d2(c, f) {
    let E = c.getValue();
    if (u(E))
      return f.originalText.slice(i(E), l(E)).trimEnd();
    if (p(E)) {
      if (y2(E)) {
        let F = g2(E);
        return E.trailing && !t(f.originalText, i(E), { backwards: true }) ? [a, F] : F;
      }
      let _ = l(E), w = f.originalText.slice(_ - 3, _) === "*-/";
      return ["/*", n(E.value), w ? "*-/" : "*/"];
    }
    throw new Error("Not a comment: " + JSON.stringify(E));
  }
  function y2(c) {
    let f = `*${c.value}*`.split(`
`);
    return f.length > 1 && f.every((E) => E.trim()[0] === "*");
  }
  function g2(c) {
    let f = c.value.split(`
`);
    return ["/*", s(a, f.map((E, _) => _ === 0 ? E.trimEnd() : " " + (_ < f.length - 1 ? E.trim() : E.trimStart()))), "*/"];
  }
  r.exports = { printComment: d2 };
} }), cd = te$1({ "src/language-js/print/literal.js"(e, r) {
  ne();
  var { printString: t, printNumber: s } = Ue$2(), { replaceTextEndOfLine: a } = Xt$2(), { printDirective: n } = ct$1();
  function u(d2, y2) {
    let g2 = d2.getNode();
    switch (g2.type) {
      case "RegExpLiteral":
        return p(g2);
      case "BigIntLiteral":
        return l(g2.bigint || g2.extra.raw);
      case "NumericLiteral":
        return s(g2.extra.raw);
      case "StringLiteral":
        return a(t(g2.extra.raw, y2));
      case "NullLiteral":
        return "null";
      case "BooleanLiteral":
        return String(g2.value);
      case "DecimalLiteral":
        return s(g2.value) + "m";
      case "Literal": {
        if (g2.regex)
          return p(g2.regex);
        if (g2.bigint)
          return l(g2.raw);
        if (g2.decimal)
          return s(g2.decimal) + "m";
        let { value: c } = g2;
        return typeof c == "number" ? s(g2.raw) : typeof c == "string" ? i(d2) ? n(g2.raw, y2) : a(t(g2.raw, y2)) : String(c);
      }
    }
  }
  function i(d2) {
    if (d2.getName() !== "expression")
      return;
    let y2 = d2.getParentNode();
    return y2.type === "ExpressionStatement" && y2.directive;
  }
  function l(d2) {
    return d2.toLowerCase();
  }
  function p(d2) {
    let { pattern: y2, flags: g2 } = d2;
    return g2 = [...g2].sort().join(""), `/${y2}/${g2}`;
  }
  r.exports = { printLiteral: u };
} }), pd = te$1({ "src/language-js/printer-estree.js"(e, r) {
  ne();
  var { printDanglingComments: t } = et(), { hasNewline: s } = Ue$2(), { builders: { join: a, line: n, hardline: u, softline: i, group: l, indent: p }, utils: { replaceTextEndOfLine: d2 } } = qe(), y2 = Um(), g2 = Jm(), { insertPragma: c } = po$2(), f = fo$2(), E = Ot$1(), _ = Do$1(), { hasFlowShorthandAnnotationComment: w, hasComment: F, CommentCheckFlags: N2, isTheOnlyJsxElementInMarkdown: x, isLineComment: I2, isNextLineEmpty: P, needsHardlineAfterDanglingComment: $2, hasIgnoreComment: D, isCallExpression: T, isMemberExpression: m, markerForIfWithoutBlockAndSameLineComment: C } = Ke$1(), { locStart: o, locEnd: h } = ut$1(), v2 = _t$2(), { printHtmlBinding: S, isVueEventBindingExpression: b } = rd(), { printAngular: B } = nd(), { printJsx: k, hasJsxIgnoreComment: M2 } = ud(), { printFlow: R2 } = id(), { printTypescript: q } = od(), { printOptionalToken: J, printBindExpressionCallee: L, printTypeAnnotation: Q, adjustClause: V, printRestSpread: j, printDefiniteToken: Y, printDirective: ie2 } = ct$1(), { printImportDeclaration: ee2, printExportDeclaration: ce2, printExportAllDeclaration: W, printModuleSpecifier: K2 } = vo$2(), { printTernary: de } = Co$2(), { printTemplateLiteral: ue2 } = Lt$2(), { printArray: Fe2 } = Qt(), { printObject: z } = tu(), { printClass: U2, printClassMethod: Z, printClassProperty: se2 } = tr$2(), { printProperty: fe2 } = er$1(), { printFunction: ge2, printArrowFunction: he2, printMethod: we2, printReturnStatement: ke2, printThrowStatement: Re2 } = Or(), { printCallExpression: Ne2 } = yo$2(), { printVariableDeclarator: Pe2, printAssignmentExpression: oe } = Zt(), { printBinaryishExpression: H } = Zn(), { printSwitchCaseConsequent: pe2 } = Eo$2(), { printMemberExpression: X } = go$2(), { printBlock: le2, printBlockBody: Ae2 } = Fo$1(), { printComment: Ee } = ld(), { printLiteral: De2 } = cd(), { printDecorators: A } = eu();
  function G(Ce2, Be, ve2, ze) {
    let xe2 = re(Ce2, Be, ve2, ze);
    if (!xe2)
      return "";
    let Ye2 = Ce2.getValue(), { type: Se2 } = Ye2;
    if (Se2 === "ClassMethod" || Se2 === "ClassPrivateMethod" || Se2 === "ClassProperty" || Se2 === "ClassAccessorProperty" || Se2 === "AccessorProperty" || Se2 === "TSAbstractAccessorProperty" || Se2 === "PropertyDefinition" || Se2 === "TSAbstractPropertyDefinition" || Se2 === "ClassPrivateProperty" || Se2 === "MethodDefinition" || Se2 === "TSAbstractMethodDefinition" || Se2 === "TSDeclareMethod")
      return xe2;
    let Ie2 = [xe2], Oe2 = A(Ce2, Be, ve2), Je2 = Ye2.type === "ClassExpression" && Oe2;
    if (Oe2 && (Ie2 = [...Oe2, xe2], !Je2))
      return l(Ie2);
    if (!E(Ce2, Be))
      return ze && ze.needsSemi && Ie2.unshift(";"), Ie2.length === 1 && Ie2[0] === xe2 ? xe2 : Ie2;
    if (Je2 && (Ie2 = [p([n, ...Ie2])]), Ie2.unshift("("), ze && ze.needsSemi && Ie2.unshift(";"), w(Ye2)) {
      let [je2] = Ye2.trailingComments;
      Ie2.push(" /*", je2.value.trimStart(), "*/"), je2.printed = true;
    }
    return Je2 && Ie2.push(n), Ie2.push(")"), Ie2;
  }
  function re(Ce2, Be, ve2, ze) {
    let xe2 = Ce2.getValue(), Ye2 = Be.semi ? ";" : "";
    if (!xe2)
      return "";
    if (typeof xe2 == "string")
      return xe2;
    for (let Ie2 of [De2, S, B, k, R2, q]) {
      let Oe2 = Ie2(Ce2, Be, ve2);
      if (typeof Oe2 < "u")
        return Oe2;
    }
    let Se2 = [];
    switch (xe2.type) {
      case "JsExpressionRoot":
        return ve2("node");
      case "JsonRoot":
        return [ve2("node"), u];
      case "File":
        return xe2.program && xe2.program.interpreter && Se2.push(ve2(["program", "interpreter"])), Se2.push(ve2("program")), Se2;
      case "Program":
        return Ae2(Ce2, Be, ve2);
      case "EmptyStatement":
        return "";
      case "ExpressionStatement": {
        if (Be.parser === "__vue_event_binding" || Be.parser === "__vue_ts_event_binding") {
          let Oe2 = Ce2.getParentNode();
          if (Oe2.type === "Program" && Oe2.body.length === 1 && Oe2.body[0] === xe2)
            return [ve2("expression"), b(xe2.expression) ? ";" : ""];
        }
        let Ie2 = t(Ce2, Be, true, (Oe2) => {
          let { marker: Je2 } = Oe2;
          return Je2 === C;
        });
        return [ve2("expression"), x(Be, Ce2) ? "" : Ye2, Ie2 ? [" ", Ie2] : ""];
      }
      case "ParenthesizedExpression":
        return !F(xe2.expression) && (xe2.expression.type === "ObjectExpression" || xe2.expression.type === "ArrayExpression") ? ["(", ve2("expression"), ")"] : l(["(", p([i, ve2("expression")]), i, ")"]);
      case "AssignmentExpression":
        return oe(Ce2, Be, ve2);
      case "VariableDeclarator":
        return Pe2(Ce2, Be, ve2);
      case "BinaryExpression":
      case "LogicalExpression":
        return H(Ce2, Be, ve2);
      case "AssignmentPattern":
        return [ve2("left"), " = ", ve2("right")];
      case "OptionalMemberExpression":
      case "MemberExpression":
        return X(Ce2, Be, ve2);
      case "MetaProperty":
        return [ve2("meta"), ".", ve2("property")];
      case "BindExpression":
        return xe2.object && Se2.push(ve2("object")), Se2.push(l(p([i, L(Ce2, Be, ve2)]))), Se2;
      case "Identifier":
        return [xe2.name, J(Ce2), Y(Ce2), Q(Ce2, Be, ve2)];
      case "V8IntrinsicIdentifier":
        return ["%", xe2.name];
      case "SpreadElement":
      case "SpreadElementPattern":
      case "SpreadProperty":
      case "SpreadPropertyPattern":
      case "RestElement":
        return j(Ce2, Be, ve2);
      case "FunctionDeclaration":
      case "FunctionExpression":
        return ge2(Ce2, ve2, Be, ze);
      case "ArrowFunctionExpression":
        return he2(Ce2, Be, ve2, ze);
      case "YieldExpression":
        return Se2.push("yield"), xe2.delegate && Se2.push("*"), xe2.argument && Se2.push(" ", ve2("argument")), Se2;
      case "AwaitExpression": {
        if (Se2.push("await"), xe2.argument) {
          Se2.push(" ", ve2("argument"));
          let Ie2 = Ce2.getParentNode();
          if (T(Ie2) && Ie2.callee === xe2 || m(Ie2) && Ie2.object === xe2) {
            Se2 = [p([i, ...Se2]), i];
            let Oe2 = Ce2.findAncestor((Je2) => Je2.type === "AwaitExpression" || Je2.type === "BlockStatement");
            if (!Oe2 || Oe2.type !== "AwaitExpression")
              return l(Se2);
          }
        }
        return Se2;
      }
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        return ce2(Ce2, Be, ve2);
      case "ExportAllDeclaration":
        return W(Ce2, Be, ve2);
      case "ImportDeclaration":
        return ee2(Ce2, Be, ve2);
      case "ImportSpecifier":
      case "ExportSpecifier":
      case "ImportNamespaceSpecifier":
      case "ExportNamespaceSpecifier":
      case "ImportDefaultSpecifier":
      case "ExportDefaultSpecifier":
        return K2(Ce2, Be, ve2);
      case "ImportAttribute":
        return [ve2("key"), ": ", ve2("value")];
      case "Import":
        return "import";
      case "BlockStatement":
      case "StaticBlock":
      case "ClassBody":
        return le2(Ce2, Be, ve2);
      case "ThrowStatement":
        return Re2(Ce2, Be, ve2);
      case "ReturnStatement":
        return ke2(Ce2, Be, ve2);
      case "NewExpression":
      case "ImportExpression":
      case "OptionalCallExpression":
      case "CallExpression":
        return Ne2(Ce2, Be, ve2);
      case "ObjectExpression":
      case "ObjectPattern":
      case "RecordExpression":
        return z(Ce2, Be, ve2);
      case "ObjectProperty":
      case "Property":
        return xe2.method || xe2.kind === "get" || xe2.kind === "set" ? we2(Ce2, Be, ve2) : fe2(Ce2, Be, ve2);
      case "ObjectMethod":
        return we2(Ce2, Be, ve2);
      case "Decorator":
        return ["@", ve2("expression")];
      case "ArrayExpression":
      case "ArrayPattern":
      case "TupleExpression":
        return Fe2(Ce2, Be, ve2);
      case "SequenceExpression": {
        let Ie2 = Ce2.getParentNode(0);
        if (Ie2.type === "ExpressionStatement" || Ie2.type === "ForStatement") {
          let Oe2 = [];
          return Ce2.each((Je2, be2) => {
            be2 === 0 ? Oe2.push(ve2()) : Oe2.push(",", p([n, ve2()]));
          }, "expressions"), l(Oe2);
        }
        return l(a([",", n], Ce2.map(ve2, "expressions")));
      }
      case "ThisExpression":
        return "this";
      case "Super":
        return "super";
      case "Directive":
        return [ve2("value"), Ye2];
      case "DirectiveLiteral":
        return ie2(xe2.extra.raw, Be);
      case "UnaryExpression":
        return Se2.push(xe2.operator), /[a-z]$/.test(xe2.operator) && Se2.push(" "), F(xe2.argument) ? Se2.push(l(["(", p([i, ve2("argument")]), i, ")"])) : Se2.push(ve2("argument")), Se2;
      case "UpdateExpression":
        return Se2.push(ve2("argument"), xe2.operator), xe2.prefix && Se2.reverse(), Se2;
      case "ConditionalExpression":
        return de(Ce2, Be, ve2);
      case "VariableDeclaration": {
        let Ie2 = Ce2.map(ve2, "declarations"), Oe2 = Ce2.getParentNode(), Je2 = Oe2.type === "ForStatement" || Oe2.type === "ForInStatement" || Oe2.type === "ForOfStatement", be2 = xe2.declarations.some((Me2) => Me2.init), je2;
        return Ie2.length === 1 && !F(xe2.declarations[0]) ? je2 = Ie2[0] : Ie2.length > 0 && (je2 = p(Ie2[0])), Se2 = [xe2.declare ? "declare " : "", xe2.kind, je2 ? [" ", je2] : "", p(Ie2.slice(1).map((Me2) => [",", be2 && !Je2 ? u : n, Me2]))], Je2 && Oe2.body !== xe2 || Se2.push(Ye2), l(Se2);
      }
      case "WithStatement":
        return l(["with (", ve2("object"), ")", V(xe2.body, ve2("body"))]);
      case "IfStatement": {
        let Ie2 = V(xe2.consequent, ve2("consequent")), Oe2 = l(["if (", l([p([i, ve2("test")]), i]), ")", Ie2]);
        if (Se2.push(Oe2), xe2.alternate) {
          let Je2 = F(xe2.consequent, N2.Trailing | N2.Line) || $2(xe2), be2 = xe2.consequent.type === "BlockStatement" && !Je2;
          Se2.push(be2 ? " " : u), F(xe2, N2.Dangling) && Se2.push(t(Ce2, Be, true), Je2 ? u : " "), Se2.push("else", l(V(xe2.alternate, ve2("alternate"), xe2.alternate.type === "IfStatement")));
        }
        return Se2;
      }
      case "ForStatement": {
        let Ie2 = V(xe2.body, ve2("body")), Oe2 = t(Ce2, Be, true), Je2 = Oe2 ? [Oe2, i] : "";
        return !xe2.init && !xe2.test && !xe2.update ? [Je2, l(["for (;;)", Ie2])] : [Je2, l(["for (", l([p([i, ve2("init"), ";", n, ve2("test"), ";", n, ve2("update")]), i]), ")", Ie2])];
      }
      case "WhileStatement":
        return l(["while (", l([p([i, ve2("test")]), i]), ")", V(xe2.body, ve2("body"))]);
      case "ForInStatement":
        return l(["for (", ve2("left"), " in ", ve2("right"), ")", V(xe2.body, ve2("body"))]);
      case "ForOfStatement":
        return l(["for", xe2.await ? " await" : "", " (", ve2("left"), " of ", ve2("right"), ")", V(xe2.body, ve2("body"))]);
      case "DoWhileStatement": {
        let Ie2 = V(xe2.body, ve2("body"));
        return Se2 = [l(["do", Ie2])], xe2.body.type === "BlockStatement" ? Se2.push(" ") : Se2.push(u), Se2.push("while (", l([p([i, ve2("test")]), i]), ")", Ye2), Se2;
      }
      case "DoExpression":
        return [xe2.async ? "async " : "", "do ", ve2("body")];
      case "BreakStatement":
        return Se2.push("break"), xe2.label && Se2.push(" ", ve2("label")), Se2.push(Ye2), Se2;
      case "ContinueStatement":
        return Se2.push("continue"), xe2.label && Se2.push(" ", ve2("label")), Se2.push(Ye2), Se2;
      case "LabeledStatement":
        return xe2.body.type === "EmptyStatement" ? [ve2("label"), ":;"] : [ve2("label"), ": ", ve2("body")];
      case "TryStatement":
        return ["try ", ve2("block"), xe2.handler ? [" ", ve2("handler")] : "", xe2.finalizer ? [" finally ", ve2("finalizer")] : ""];
      case "CatchClause":
        if (xe2.param) {
          let Ie2 = F(xe2.param, (Je2) => !v2(Je2) || Je2.leading && s(Be.originalText, h(Je2)) || Je2.trailing && s(Be.originalText, o(Je2), { backwards: true })), Oe2 = ve2("param");
          return ["catch ", Ie2 ? ["(", p([i, Oe2]), i, ") "] : ["(", Oe2, ") "], ve2("body")];
        }
        return ["catch ", ve2("body")];
      case "SwitchStatement":
        return [l(["switch (", p([i, ve2("discriminant")]), i, ")"]), " {", xe2.cases.length > 0 ? p([u, a(u, Ce2.map((Ie2, Oe2, Je2) => {
          let be2 = Ie2.getValue();
          return [ve2(), Oe2 !== Je2.length - 1 && P(be2, Be) ? u : ""];
        }, "cases"))]) : "", u, "}"];
      case "SwitchCase": {
        xe2.test ? Se2.push("case ", ve2("test"), ":") : Se2.push("default:"), F(xe2, N2.Dangling) && Se2.push(" ", t(Ce2, Be, true));
        let Ie2 = xe2.consequent.filter((Oe2) => Oe2.type !== "EmptyStatement");
        if (Ie2.length > 0) {
          let Oe2 = pe2(Ce2, Be, ve2);
          Se2.push(Ie2.length === 1 && Ie2[0].type === "BlockStatement" ? [" ", Oe2] : p([u, Oe2]));
        }
        return Se2;
      }
      case "DebuggerStatement":
        return ["debugger", Ye2];
      case "ClassDeclaration":
      case "ClassExpression":
        return U2(Ce2, Be, ve2);
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "MethodDefinition":
        return Z(Ce2, Be, ve2);
      case "ClassProperty":
      case "PropertyDefinition":
      case "ClassPrivateProperty":
      case "ClassAccessorProperty":
      case "AccessorProperty":
        return se2(Ce2, Be, ve2);
      case "TemplateElement":
        return d2(xe2.value.raw);
      case "TemplateLiteral":
        return ue2(Ce2, ve2, Be);
      case "TaggedTemplateExpression":
        return [ve2("tag"), ve2("typeParameters"), ve2("quasi")];
      case "PrivateIdentifier":
        return ["#", ve2("name")];
      case "PrivateName":
        return ["#", ve2("id")];
      case "InterpreterDirective":
        return Se2.push("#!", xe2.value, u), P(xe2, Be) && Se2.push(u), Se2;
      case "TopicReference":
        return "%";
      case "ArgumentPlaceholder":
        return "?";
      case "ModuleExpression": {
        Se2.push("module {");
        let Ie2 = ve2("body");
        return Ie2 && Se2.push(p([u, Ie2]), u), Se2.push("}"), Se2;
      }
      default:
        throw new Error("unknown type: " + JSON.stringify(xe2.type));
    }
  }
  function ye2(Ce2) {
    return Ce2.type && !v2(Ce2) && !I2(Ce2) && Ce2.type !== "EmptyStatement" && Ce2.type !== "TemplateElement" && Ce2.type !== "Import" && Ce2.type !== "TSEmptyBodyFunctionExpression";
  }
  r.exports = { preprocess: _, print: G, embed: y2, insertPragma: c, massageAstNode: g2, hasPrettierIgnore(Ce2) {
    return D(Ce2) || M2(Ce2);
  }, willPrintOwnComments: f.willPrintOwnComments, canAttachComment: ye2, printComment: Ee, isBlockComment: v2, handleComments: { avoidAstMutation: true, ownLine: f.handleOwnLineComment, endOfLine: f.handleEndOfLineComment, remaining: f.handleRemainingComment }, getCommentChildNodes: f.getCommentChildNodes };
} }), fd = te$1({ "src/language-js/printer-estree-json.js"(e, r) {
  ne();
  var { builders: { hardline: t, indent: s, join: a } } = qe(), n = Do$1();
  function u(d2, y2, g2) {
    let c = d2.getValue();
    switch (c.type) {
      case "JsonRoot":
        return [g2("node"), t];
      case "ArrayExpression": {
        if (c.elements.length === 0)
          return "[]";
        let f = d2.map(() => d2.getValue() === null ? "null" : g2(), "elements");
        return ["[", s([t, a([",", t], f)]), t, "]"];
      }
      case "ObjectExpression":
        return c.properties.length === 0 ? "{}" : ["{", s([t, a([",", t], d2.map(g2, "properties"))]), t, "}"];
      case "ObjectProperty":
        return [g2("key"), ": ", g2("value")];
      case "UnaryExpression":
        return [c.operator === "+" ? "" : c.operator, g2("argument")];
      case "NullLiteral":
        return "null";
      case "BooleanLiteral":
        return c.value ? "true" : "false";
      case "StringLiteral":
        return JSON.stringify(c.value);
      case "NumericLiteral":
        return i(d2) ? JSON.stringify(String(c.value)) : JSON.stringify(c.value);
      case "Identifier":
        return i(d2) ? JSON.stringify(c.name) : c.name;
      case "TemplateLiteral":
        return g2(["quasis", 0]);
      case "TemplateElement":
        return JSON.stringify(c.value.cooked);
      default:
        throw new Error("unknown type: " + JSON.stringify(c.type));
    }
  }
  function i(d2) {
    return d2.getName() === "key" && d2.getParentNode().type === "ObjectProperty";
  }
  var l = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
  function p(d2, y2) {
    let { type: g2 } = d2;
    if (g2 === "ObjectProperty") {
      let { key: c } = d2;
      c.type === "Identifier" ? y2.key = { type: "StringLiteral", value: c.name } : c.type === "NumericLiteral" && (y2.key = { type: "StringLiteral", value: String(c.value) });
      return;
    }
    if (g2 === "UnaryExpression" && d2.operator === "+")
      return y2.argument;
    if (g2 === "ArrayExpression") {
      for (let [c, f] of d2.elements.entries())
        f === null && y2.elements.splice(c, 0, { type: "NullLiteral" });
      return;
    }
    if (g2 === "TemplateLiteral")
      return { type: "StringLiteral", value: d2.quasis[0].value.cooked };
  }
  p.ignoredProperties = l, r.exports = { preprocess: n, print: u, massageAstNode: p };
} }), jt = te$1({ "src/common/common-options.js"(e, r) {
  ne();
  var t = "Common";
  r.exports = { bracketSpacing: { since: "0.0.0", category: t, type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: t, type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { since: "1.8.2", category: t, type: "choice", default: [{ since: "1.8.2", value: true }, { since: "1.9.0", value: "preserve" }], description: "How to wrap prose.", choices: [{ since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width." }, { since: "1.9.0", value: "never", description: "Do not wrap prose." }, { since: "1.9.0", value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { since: "2.4.0", category: t, type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { since: "2.6.0", category: t, type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
} }), Dd = te$1({ "src/language-js/options.js"(e, r) {
  ne();
  var t = jt(), s = "JavaScript";
  r.exports = { arrowParens: { since: "1.9.0", category: s, type: "choice", default: [{ since: "1.9.0", value: "avoid" }, { since: "2.0.0", value: "always" }], description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: t.bracketSameLine, bracketSpacing: t.bracketSpacing, jsxBracketSameLine: { since: "0.17.0", category: s, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { since: "1.0.0", category: s, type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, singleQuote: t.singleQuote, jsxSingleQuote: { since: "1.15.0", category: s, type: "boolean", default: false, description: "Use single quotes in JSX." }, quoteProps: { since: "1.17.0", category: s, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { since: "0.0.0", category: s, type: "choice", default: [{ since: "0.0.0", value: false }, { since: "0.19.0", value: "none" }, { since: "2.0.0", value: "es5" }], description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }, { value: "all", description: "Trailing commas wherever possible (including function arguments)." }] }, singleAttributePerLine: t.singleAttributePerLine };
} }), md = te$1({ "src/language-js/parse/parsers.js"() {
  ne();
} }), In = te$1({ "node_modules/linguist-languages/data/JavaScript.json"(e, r) {
  r.exports = { name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], languageId: 183 };
} }), dd = te$1({ "node_modules/linguist-languages/data/TypeScript.json"(e, r) {
  r.exports = { name: "TypeScript", type: "programming", color: "#3178c6", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts", ".cts", ".mts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378 };
} }), gd = te$1({ "node_modules/linguist-languages/data/TSX.json"(e, r) {
  r.exports = { name: "TSX", type: "programming", color: "#3178c6", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924 };
} }), Fa = te$1({ "node_modules/linguist-languages/data/JSON.json"(e, r) {
  r.exports = { name: "JSON", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"], languageId: 174 };
} }), yd = te$1({ "node_modules/linguist-languages/data/JSON with Comments.json"(e, r) {
  r.exports = { name: "JSON with Comments", type: "data", color: "#292929", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".code-snippets", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [".babelrc", ".devcontainer.json", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"], languageId: 423 };
} }), hd = te$1({ "node_modules/linguist-languages/data/JSON5.json"(e, r) {
  r.exports = { name: "JSON5", type: "data", color: "#267CB9", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175 };
} }), vd = te$1({ "src/language-js/index.js"(e, r) {
  ne();
  var t = wt$1(), s = pd(), a = fd(), n = Dd(), u = md(), i = [t(In(), (p) => ({ since: "0.0.0", parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: [...p.interpreters, "zx"], extensions: [...p.extensions.filter((d2) => d2 !== ".jsx"), ".wxs"] })), t(In(), () => ({ name: "Flow", since: "0.0.0", parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"] })), t(In(), () => ({ name: "JSX", since: "0.0.0", parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], aliases: void 0, filenames: void 0, extensions: [".jsx"], group: "JavaScript", interpreters: void 0, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0 })), t(dd(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] })), t(gd(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] })), t(Fa(), () => ({ name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [".importmap"], filenames: ["package.json", "package-lock.json", "composer.json"] })), t(Fa(), (p) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], extensions: p.extensions.filter((d2) => d2 !== ".jsonl") })), t(yd(), (p) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: [...p.filenames, ".eslintrc", ".swcrc"] })), t(hd(), () => ({ since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"] }))], l = { estree: s, "estree-json": a };
  r.exports = { languages: i, options: n, printers: l, parsers: u };
} }), Cd = te$1({ "src/language-css/clean.js"(e, r) {
  ne();
  var { isFrontMatterNode: t } = Ue$2(), s = lt$1(), a = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
  function n(i, l, p) {
    if (t(i) && i.lang === "yaml" && delete l.value, i.type === "css-comment" && p.type === "css-root" && p.nodes.length > 0 && ((p.nodes[0] === i || t(p.nodes[0]) && p.nodes[1] === i) && (delete l.text, /^\*\s*@(?:format|prettier)\s*$/.test(i.text)) || p.type === "css-root" && s(p.nodes) === i))
      return null;
    if (i.type === "value-root" && delete l.text, (i.type === "media-query" || i.type === "media-query-list" || i.type === "media-feature-expression") && delete l.value, i.type === "css-rule" && delete l.params, i.type === "selector-combinator" && (l.value = l.value.replace(/\s+/g, " ")), i.type === "media-feature" && (l.value = l.value.replace(/ /g, "")), (i.type === "value-word" && (i.isColor && i.isHex || ["initial", "inherit", "unset", "revert"].includes(l.value.replace().toLowerCase())) || i.type === "media-feature" || i.type === "selector-root-invalid" || i.type === "selector-pseudo") && (l.value = l.value.toLowerCase()), i.type === "css-decl" && (l.prop = l.prop.toLowerCase()), (i.type === "css-atrule" || i.type === "css-import") && (l.name = l.name.toLowerCase()), i.type === "value-number" && (l.unit = l.unit.toLowerCase()), (i.type === "media-feature" || i.type === "media-keyword" || i.type === "media-type" || i.type === "media-unknown" || i.type === "media-url" || i.type === "media-value" || i.type === "selector-attribute" || i.type === "selector-string" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "value-string") && l.value && (l.value = u(l.value)), i.type === "selector-attribute" && (l.attribute = l.attribute.trim(), l.namespace && typeof l.namespace == "string" && (l.namespace = l.namespace.trim(), l.namespace.length === 0 && (l.namespace = true)), l.value && (l.value = l.value.trim().replace(/^["']|["']$/g, ""), delete l.quoted)), (i.type === "media-value" || i.type === "media-type" || i.type === "value-number" || i.type === "selector-root-invalid" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "selector-tag") && l.value && (l.value = l.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (d2, y2, g2) => {
      let c = Number(y2);
      return Number.isNaN(c) ? d2 : c + g2.toLowerCase();
    })), i.type === "selector-tag") {
      let d2 = i.value.toLowerCase();
      ["from", "to"].includes(d2) && (l.value = d2);
    }
    if (i.type === "css-atrule" && i.name.toLowerCase() === "supports" && delete l.value, i.type === "selector-unknown" && delete l.value, i.type === "value-comma_group") {
      let d2 = i.groups.findIndex((y2) => y2.type === "value-number" && y2.unit === "...");
      d2 !== -1 && (l.groups[d2].unit = "", l.groups.splice(d2 + 1, 0, { type: "value-word", value: "...", isColor: false, isHex: false }));
    }
    if (i.type === "value-comma_group" && i.groups.some((d2) => d2.type === "value-atword" && d2.value.endsWith("[") || d2.type === "value-word" && d2.value.startsWith("]")))
      return { type: "value-atword", value: i.groups.map((d2) => d2.value).join(""), group: { open: null, close: null, groups: [], type: "value-paren_group" } };
  }
  n.ignoredProperties = a;
  function u(i) {
    return i.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1");
  }
  r.exports = n;
} }), ru = te$1({ "src/utils/front-matter/print.js"(e, r) {
  ne();
  var { builders: { hardline: t, markAsRoot: s } } = qe();
  function a(n, u) {
    if (n.lang === "yaml") {
      let i = n.value.trim(), l = i ? u(i, { parser: "yaml" }, { stripTrailingHardline: true }) : "";
      return s([n.startDelimiter, t, l, l ? t : "", n.endDelimiter]);
    }
  }
  r.exports = a;
} }), Ed = te$1({ "src/language-css/embed.js"(e, r) {
  ne();
  var { builders: { hardline: t } } = qe(), s = ru();
  function a(n, u, i) {
    let l = n.getValue();
    if (l.type === "front-matter") {
      let p = s(l, i);
      return p ? [p, t] : "";
    }
  }
  r.exports = a;
} }), Ao$2 = te$1({ "src/utils/front-matter/parse.js"(e, r) {
  ne();
  var t = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
  function s(a) {
    let n = a.match(t);
    if (!n)
      return { content: a };
    let { startDelimiter: u, language: i, value: l = "", endDelimiter: p } = n.groups, d2 = i.trim() || "yaml";
    if (u === "+++" && (d2 = "toml"), d2 !== "yaml" && u !== p)
      return { content: a };
    let [y2] = n;
    return { frontMatter: { type: "front-matter", lang: d2, value: l, startDelimiter: u, endDelimiter: p, raw: y2.replace(/\n$/, "") }, content: y2.replace(/[^\n]/g, " ") + a.slice(y2.length) };
  }
  r.exports = s;
} }), Fd = te$1({ "src/language-css/pragma.js"(e, r) {
  ne();
  var t = po$2(), s = Ao$2();
  function a(u) {
    return t.hasPragma(s(u).content);
  }
  function n(u) {
    let { frontMatter: i, content: l } = s(u);
    return (i ? i.raw + `

` : "") + t.insertPragma(l);
  }
  r.exports = { hasPragma: a, insertPragma: n };
} }), Ad = te$1({ "src/language-css/utils/index.js"(e, r) {
  ne();
  var t = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
  function s(z, U2) {
    let Z = Array.isArray(U2) ? U2 : [U2], se2 = -1, fe2;
    for (; fe2 = z.getParentNode(++se2); )
      if (Z.includes(fe2.type))
        return se2;
    return -1;
  }
  function a(z, U2) {
    let Z = s(z, U2);
    return Z === -1 ? null : z.getParentNode(Z);
  }
  function n(z) {
    var U2;
    let Z = a(z, "css-decl");
    return Z == null || (U2 = Z.prop) === null || U2 === void 0 ? void 0 : U2.toLowerCase();
  }
  var u = /* @__PURE__ */ new Set(["initial", "inherit", "unset", "revert"]);
  function i(z) {
    return u.has(z.toLowerCase());
  }
  function l(z, U2) {
    let Z = a(z, "css-atrule");
    return (Z == null ? void 0 : Z.name) && Z.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(U2.toLowerCase());
  }
  function p(z) {
    return z.includes("$") || z.includes("@") || z.includes("#") || z.startsWith("%") || z.startsWith("--") || z.startsWith(":--") || z.includes("(") && z.includes(")") ? z : z.toLowerCase();
  }
  function d2(z, U2) {
    var Z;
    let se2 = a(z, "value-func");
    return (se2 == null || (Z = se2.value) === null || Z === void 0 ? void 0 : Z.toLowerCase()) === U2;
  }
  function y2(z) {
    var U2;
    let Z = a(z, "css-rule"), se2 = Z == null || (U2 = Z.raws) === null || U2 === void 0 ? void 0 : U2.selector;
    return se2 && (se2.startsWith(":import") || se2.startsWith(":export"));
  }
  function g2(z, U2) {
    let Z = Array.isArray(U2) ? U2 : [U2], se2 = a(z, "css-atrule");
    return se2 && Z.includes(se2.name.toLowerCase());
  }
  function c(z) {
    let U2 = z.getValue(), Z = a(z, "css-atrule");
    return (Z == null ? void 0 : Z.name) === "import" && U2.groups[0].value === "url" && U2.groups.length === 2;
  }
  function f(z) {
    return z.type === "value-func" && z.value.toLowerCase() === "url";
  }
  function E(z, U2) {
    var Z;
    let se2 = (Z = z.getParentNode()) === null || Z === void 0 ? void 0 : Z.nodes;
    return se2 && se2.indexOf(U2) === se2.length - 1;
  }
  function _(z) {
    let { selector: U2 } = z;
    return U2 ? typeof U2 == "string" && /^@.+:.*$/.test(U2) || U2.value && /^@.+:.*$/.test(U2.value) : false;
  }
  function w(z) {
    return z.type === "value-word" && ["from", "through", "end"].includes(z.value);
  }
  function F(z) {
    return z.type === "value-word" && ["and", "or", "not"].includes(z.value);
  }
  function N2(z) {
    return z.type === "value-word" && z.value === "in";
  }
  function x(z) {
    return z.type === "value-operator" && z.value === "*";
  }
  function I2(z) {
    return z.type === "value-operator" && z.value === "/";
  }
  function P(z) {
    return z.type === "value-operator" && z.value === "+";
  }
  function $2(z) {
    return z.type === "value-operator" && z.value === "-";
  }
  function D(z) {
    return z.type === "value-operator" && z.value === "%";
  }
  function T(z) {
    return x(z) || I2(z) || P(z) || $2(z) || D(z);
  }
  function m(z) {
    return z.type === "value-word" && ["==", "!="].includes(z.value);
  }
  function C(z) {
    return z.type === "value-word" && ["<", ">", "<=", ">="].includes(z.value);
  }
  function o(z) {
    return z.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(z.name);
  }
  function h(z) {
    var U2;
    return ((U2 = z.raws) === null || U2 === void 0 ? void 0 : U2.params) && /^\(\s*\)$/.test(z.raws.params);
  }
  function v2(z) {
    return z.name.startsWith("prettier-placeholder");
  }
  function S(z) {
    return z.prop.startsWith("@prettier-placeholder");
  }
  function b(z, U2) {
    return z.value === "$$" && z.type === "value-func" && (U2 == null ? void 0 : U2.type) === "value-word" && !U2.raws.before;
  }
  function B(z) {
    var U2, Z;
    return ((U2 = z.value) === null || U2 === void 0 ? void 0 : U2.type) === "value-root" && ((Z = z.value.group) === null || Z === void 0 ? void 0 : Z.type) === "value-value" && z.prop.toLowerCase() === "composes";
  }
  function k(z) {
    var U2, Z, se2;
    return ((U2 = z.value) === null || U2 === void 0 || (Z = U2.group) === null || Z === void 0 || (se2 = Z.group) === null || se2 === void 0 ? void 0 : se2.type) === "value-paren_group" && z.value.group.group.open !== null && z.value.group.group.close !== null;
  }
  function M2(z) {
    var U2;
    return ((U2 = z.raws) === null || U2 === void 0 ? void 0 : U2.before) === "";
  }
  function R2(z) {
    var U2, Z;
    return z.type === "value-comma_group" && ((U2 = z.groups) === null || U2 === void 0 || (Z = U2[1]) === null || Z === void 0 ? void 0 : Z.type) === "value-colon";
  }
  function q(z) {
    var U2;
    return z.type === "value-paren_group" && ((U2 = z.groups) === null || U2 === void 0 ? void 0 : U2[0]) && R2(z.groups[0]);
  }
  function J(z) {
    var U2;
    let Z = z.getValue();
    if (Z.groups.length === 0)
      return false;
    let se2 = z.getParentNode(1);
    if (!q(Z) && !(se2 && q(se2)))
      return false;
    let fe2 = a(z, "css-decl");
    return !!(fe2 != null && (U2 = fe2.prop) !== null && U2 !== void 0 && U2.startsWith("$") || q(se2) || se2.type === "value-func");
  }
  function L(z) {
    return z.type === "value-comment" && z.inline;
  }
  function Q(z) {
    return z.type === "value-word" && z.value === "#";
  }
  function V(z) {
    return z.type === "value-word" && z.value === "{";
  }
  function j(z) {
    return z.type === "value-word" && z.value === "}";
  }
  function Y(z) {
    return ["value-word", "value-atword"].includes(z.type);
  }
  function ie2(z) {
    return (z == null ? void 0 : z.type) === "value-colon";
  }
  function ee2(z, U2) {
    if (!R2(U2))
      return false;
    let { groups: Z } = U2, se2 = Z.indexOf(z);
    return se2 === -1 ? false : ie2(Z[se2 + 1]);
  }
  function ce2(z) {
    return z.value && ["not", "and", "or"].includes(z.value.toLowerCase());
  }
  function W(z) {
    return z.type !== "value-func" ? false : t.has(z.value.toLowerCase());
  }
  function K2(z) {
    return /\/\//.test(z.split(/[\n\r]/).pop());
  }
  function de(z) {
    return (z == null ? void 0 : z.type) === "value-atword" && z.value.startsWith("prettier-placeholder-");
  }
  function ue2(z, U2) {
    var Z, se2;
    if (((Z = z.open) === null || Z === void 0 ? void 0 : Z.value) !== "(" || ((se2 = z.close) === null || se2 === void 0 ? void 0 : se2.value) !== ")" || z.groups.some((fe2) => fe2.type !== "value-comma_group"))
      return false;
    if (U2.type === "value-comma_group") {
      let fe2 = U2.groups.indexOf(z) - 1, ge2 = U2.groups[fe2];
      if ((ge2 == null ? void 0 : ge2.type) === "value-word" && ge2.value === "with")
        return true;
    }
    return false;
  }
  function Fe2(z) {
    var U2, Z;
    return z.type === "value-paren_group" && ((U2 = z.open) === null || U2 === void 0 ? void 0 : U2.value) === "(" && ((Z = z.close) === null || Z === void 0 ? void 0 : Z.value) === ")";
  }
  r.exports = { getAncestorCounter: s, getAncestorNode: a, getPropOfDeclNode: n, maybeToLowerCase: p, insideValueFunctionNode: d2, insideICSSRuleNode: y2, insideAtRuleNode: g2, insideURLFunctionInImportAtRuleNode: c, isKeyframeAtRuleKeywords: l, isWideKeywords: i, isLastNode: E, isSCSSControlDirectiveNode: o, isDetachedRulesetDeclarationNode: _, isRelationalOperatorNode: C, isEqualityOperatorNode: m, isMultiplicationNode: x, isDivisionNode: I2, isAdditionNode: P, isSubtractionNode: $2, isModuloNode: D, isMathOperatorNode: T, isEachKeywordNode: N2, isForKeywordNode: w, isURLFunctionNode: f, isIfElseKeywordNode: F, hasComposesNode: B, hasParensAroundNode: k, hasEmptyRawBefore: M2, isDetachedRulesetCallNode: h, isTemplatePlaceholderNode: v2, isTemplatePropNode: S, isPostcssSimpleVarNode: b, isKeyValuePairNode: R2, isKeyValuePairInParenGroupNode: q, isKeyInValuePairNode: ee2, isSCSSMapItemNode: J, isInlineValueCommentNode: L, isHashNode: Q, isLeftCurlyBraceNode: V, isRightCurlyBraceNode: j, isWordNode: Y, isColonNode: ie2, isMediaAndSupportsKeywords: ce2, isColorAdjusterFuncNode: W, lastLineHasInlineComment: K2, isAtWordPlaceholderNode: de, isConfigurationNode: ue2, isParenGroupNode: Fe2 };
} }), Sd = te$1({ "src/utils/line-column-to-index.js"(e, r) {
  ne(), r.exports = function(t, s) {
    let a = 0;
    for (let n = 0; n < t.line - 1; ++n)
      a = s.indexOf(`
`, a) + 1;
    return a + t.column;
  };
} }), xd = te$1({ "src/language-css/loc.js"(e, r) {
  ne();
  var { skipEverythingButNewLine: t } = wr$2(), s = lt$1(), a = Sd();
  function n(c, f) {
    return typeof c.sourceIndex == "number" ? c.sourceIndex : c.source ? a(c.source.start, f) - 1 : null;
  }
  function u(c, f) {
    if (c.type === "css-comment" && c.inline)
      return t(f, c.source.startOffset);
    let E = c.nodes && s(c.nodes);
    return E && c.source && !c.source.end && (c = E), c.source && c.source.end ? a(c.source.end, f) : null;
  }
  function i(c, f) {
    c.source && (c.source.startOffset = n(c, f), c.source.endOffset = u(c, f));
    for (let E in c) {
      let _ = c[E];
      E === "source" || !_ || typeof _ != "object" || (_.type === "value-root" || _.type === "value-unknown" ? l(_, p(c), _.text || _.value) : i(_, f));
    }
  }
  function l(c, f, E) {
    c.source && (c.source.startOffset = n(c, E) + f, c.source.endOffset = u(c, E) + f);
    for (let _ in c) {
      let w = c[_];
      _ === "source" || !w || typeof w != "object" || l(w, f, E);
    }
  }
  function p(c) {
    let f = c.source.startOffset;
    return typeof c.prop == "string" && (f += c.prop.length), c.type === "css-atrule" && typeof c.name == "string" && (f += 1 + c.name.length + c.raws.afterName.match(/^\s*:?\s*/)[0].length), c.type !== "css-atrule" && c.raws && typeof c.raws.between == "string" && (f += c.raws.between.length), f;
  }
  function d2(c) {
    let f = "initial", E = "initial", _, w = false, F = [];
    for (let N2 = 0; N2 < c.length; N2++) {
      let x = c[N2];
      switch (f) {
        case "initial":
          if (x === "'") {
            f = "single-quotes";
            continue;
          }
          if (x === '"') {
            f = "double-quotes";
            continue;
          }
          if ((x === "u" || x === "U") && c.slice(N2, N2 + 4).toLowerCase() === "url(") {
            f = "url", N2 += 3;
            continue;
          }
          if (x === "*" && c[N2 - 1] === "/") {
            f = "comment-block";
            continue;
          }
          if (x === "/" && c[N2 - 1] === "/") {
            f = "comment-inline", _ = N2 - 1;
            continue;
          }
          continue;
        case "single-quotes":
          if (x === "'" && c[N2 - 1] !== "\\" && (f = E, E = "initial"), x === `
` || x === "\r")
            return c;
          continue;
        case "double-quotes":
          if (x === '"' && c[N2 - 1] !== "\\" && (f = E, E = "initial"), x === `
` || x === "\r")
            return c;
          continue;
        case "url":
          if (x === ")" && (f = "initial"), x === `
` || x === "\r")
            return c;
          if (x === "'") {
            f = "single-quotes", E = "url";
            continue;
          }
          if (x === '"') {
            f = "double-quotes", E = "url";
            continue;
          }
          continue;
        case "comment-block":
          x === "/" && c[N2 - 1] === "*" && (f = "initial");
          continue;
        case "comment-inline":
          (x === '"' || x === "'" || x === "*") && (w = true), (x === `
` || x === "\r") && (w && F.push([_, N2]), f = "initial", w = false);
          continue;
      }
    }
    for (let [N2, x] of F)
      c = c.slice(0, N2) + c.slice(N2, x).replace(/["'*]/g, " ") + c.slice(x);
    return c;
  }
  function y2(c) {
    return c.source.startOffset;
  }
  function g2(c) {
    return c.source.endOffset;
  }
  r.exports = { locStart: y2, locEnd: g2, calculateLoc: i, replaceQuotesInInlineComments: d2 };
} }), bd = te$1({ "src/language-css/utils/is-less-parser.js"(e, r) {
  ne();
  function t(s) {
    return s.parser === "css" || s.parser === "less";
  }
  r.exports = t;
} }), Td = te$1({ "src/language-css/utils/is-scss.js"(e, r) {
  ne();
  function t(s, a) {
    return s === "less" || s === "scss" ? s === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(a);
  }
  r.exports = t;
} }), Bd = te$1({ "src/language-css/utils/css-units.evaluate.js"(e, r) {
  r.exports = { em: "em", rem: "rem", ex: "ex", rex: "rex", cap: "cap", rcap: "rcap", ch: "ch", rch: "rch", ic: "ic", ric: "ric", lh: "lh", rlh: "rlh", vw: "vw", svw: "svw", lvw: "lvw", dvw: "dvw", vh: "vh", svh: "svh", lvh: "lvh", dvh: "dvh", vi: "vi", svi: "svi", lvi: "lvi", dvi: "dvi", vb: "vb", svb: "svb", lvb: "lvb", dvb: "dvb", vmin: "vmin", svmin: "svmin", lvmin: "lvmin", dvmin: "dvmin", vmax: "vmax", svmax: "svmax", lvmax: "lvmax", dvmax: "dvmax", cm: "cm", mm: "mm", q: "Q", in: "in", pt: "pt", pc: "pc", px: "px", deg: "deg", grad: "grad", rad: "rad", turn: "turn", s: "s", ms: "ms", hz: "Hz", khz: "kHz", dpi: "dpi", dpcm: "dpcm", dppx: "dppx", x: "x" };
} }), Nd = te$1({ "src/language-css/utils/print-unit.js"(e, r) {
  ne();
  var t = Bd();
  function s(a) {
    let n = a.toLowerCase();
    return Object.prototype.hasOwnProperty.call(t, n) ? t[n] : a;
  }
  r.exports = s;
} }), wd = te$1({ "src/language-css/printer-postcss.js"(e, r) {
  ne();
  var t = lt$1(), { printNumber: s, printString: a, hasNewline: n, isFrontMatterNode: u, isNextLineEmpty: i, isNonEmptyArray: l } = Ue$2(), { builders: { join: p, line: d2, hardline: y2, softline: g2, group: c, fill: f, indent: E, dedent: _, ifBreak: w, breakParent: F }, utils: { removeLines: N2, getDocParts: x } } = qe(), I2 = Cd(), P = Ed(), { insertPragma: $2 } = Fd(), { getAncestorNode: D, getPropOfDeclNode: T, maybeToLowerCase: m, insideValueFunctionNode: C, insideICSSRuleNode: o, insideAtRuleNode: h, insideURLFunctionInImportAtRuleNode: v2, isKeyframeAtRuleKeywords: S, isWideKeywords: b, isLastNode: B, isSCSSControlDirectiveNode: k, isDetachedRulesetDeclarationNode: M2, isRelationalOperatorNode: R2, isEqualityOperatorNode: q, isMultiplicationNode: J, isDivisionNode: L, isAdditionNode: Q, isSubtractionNode: V, isMathOperatorNode: j, isEachKeywordNode: Y, isForKeywordNode: ie2, isURLFunctionNode: ee2, isIfElseKeywordNode: ce2, hasComposesNode: W, hasParensAroundNode: K2, hasEmptyRawBefore: de, isKeyValuePairNode: ue2, isKeyInValuePairNode: Fe2, isDetachedRulesetCallNode: z, isTemplatePlaceholderNode: U2, isTemplatePropNode: Z, isPostcssSimpleVarNode: se2, isSCSSMapItemNode: fe2, isInlineValueCommentNode: ge2, isHashNode: he2, isLeftCurlyBraceNode: we2, isRightCurlyBraceNode: ke2, isWordNode: Re2, isColonNode: Ne2, isMediaAndSupportsKeywords: Pe2, isColorAdjusterFuncNode: oe, lastLineHasInlineComment: H, isAtWordPlaceholderNode: pe2, isConfigurationNode: X, isParenGroupNode: le2 } = Ad(), { locStart: Ae2, locEnd: Ee } = xd(), De2 = bd(), A = Td(), G = Nd();
  function re(be2) {
    return be2.trailingComma === "es5" || be2.trailingComma === "all";
  }
  function ye2(be2, je2, Me2) {
    let ae2 = be2.getValue();
    if (!ae2)
      return "";
    if (typeof ae2 == "string")
      return ae2;
    switch (ae2.type) {
      case "front-matter":
        return [ae2.raw, y2];
      case "css-root": {
        let Ve2 = Ce2(be2, je2, Me2), We2 = ae2.raws.after.trim();
        return We2.startsWith(";") && (We2 = We2.slice(1).trim()), [Ve2, We2 ? ` ${We2}` : "", x(Ve2).length > 0 ? y2 : ""];
      }
      case "css-comment": {
        let Ve2 = ae2.inline || ae2.raws.inline, We2 = je2.originalText.slice(Ae2(ae2), Ee(ae2));
        return Ve2 ? We2.trimEnd() : We2;
      }
      case "css-rule":
        return [Me2("selector"), ae2.important ? " !important" : "", ae2.nodes ? [ae2.selector && ae2.selector.type === "selector-unknown" && H(ae2.selector.value) ? d2 : " ", "{", ae2.nodes.length > 0 ? E([y2, Ce2(be2, je2, Me2)]) : "", y2, "}", M2(ae2) ? ";" : ""] : ";"];
      case "css-decl": {
        let Ve2 = be2.getParentNode(), { between: We2 } = ae2.raws, Xe = We2.trim(), st2 = Xe === ":", O = W(ae2) ? N2(Me2("value")) : Me2("value");
        return !st2 && H(Xe) && (O = E([y2, _(O)])), [ae2.raws.before.replace(/[\s;]/g, ""), Ve2.type === "css-atrule" && Ve2.variable || o(be2) ? ae2.prop : m(ae2.prop), Xe.startsWith("//") ? " " : "", Xe, ae2.extend ? "" : " ", De2(je2) && ae2.extend && ae2.selector ? ["extend(", Me2("selector"), ")"] : "", O, ae2.raws.important ? ae2.raws.important.replace(/\s*!\s*important/i, " !important") : ae2.important ? " !important" : "", ae2.raws.scssDefault ? ae2.raws.scssDefault.replace(/\s*!default/i, " !default") : ae2.scssDefault ? " !default" : "", ae2.raws.scssGlobal ? ae2.raws.scssGlobal.replace(/\s*!global/i, " !global") : ae2.scssGlobal ? " !global" : "", ae2.nodes ? [" {", E([g2, Ce2(be2, je2, Me2)]), g2, "}"] : Z(ae2) && !Ve2.raws.semicolon && je2.originalText[Ee(ae2) - 1] !== ";" ? "" : je2.__isHTMLStyleAttribute && B(be2, ae2) ? w(";") : ";"];
      }
      case "css-atrule": {
        let Ve2 = be2.getParentNode(), We2 = U2(ae2) && !Ve2.raws.semicolon && je2.originalText[Ee(ae2) - 1] !== ";";
        if (De2(je2)) {
          if (ae2.mixin)
            return [Me2("selector"), ae2.important ? " !important" : "", We2 ? "" : ";"];
          if (ae2.function)
            return [ae2.name, Me2("params"), We2 ? "" : ";"];
          if (ae2.variable)
            return ["@", ae2.name, ": ", ae2.value ? Me2("value") : "", ae2.raws.between.trim() ? ae2.raws.between.trim() + " " : "", ae2.nodes ? ["{", E([ae2.nodes.length > 0 ? g2 : "", Ce2(be2, je2, Me2)]), g2, "}"] : "", We2 ? "" : ";"];
        }
        return ["@", z(ae2) || ae2.name.endsWith(":") ? ae2.name : m(ae2.name), ae2.params ? [z(ae2) ? "" : U2(ae2) ? ae2.raws.afterName === "" ? "" : ae2.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(ae2.raws.afterName) ? [y2, y2] : /^\s*\n/.test(ae2.raws.afterName) ? y2 : " " : " ", Me2("params")] : "", ae2.selector ? E([" ", Me2("selector")]) : "", ae2.value ? c([" ", Me2("value"), k(ae2) ? K2(ae2) ? " " : d2 : ""]) : ae2.name === "else" ? " " : "", ae2.nodes ? [k(ae2) ? "" : ae2.selector && !ae2.selector.nodes && typeof ae2.selector.value == "string" && H(ae2.selector.value) || !ae2.selector && typeof ae2.params == "string" && H(ae2.params) ? d2 : " ", "{", E([ae2.nodes.length > 0 ? g2 : "", Ce2(be2, je2, Me2)]), g2, "}"] : We2 ? "" : ";"];
      }
      case "media-query-list": {
        let Ve2 = [];
        return be2.each((We2) => {
          let Xe = We2.getValue();
          Xe.type === "media-query" && Xe.value === "" || Ve2.push(Me2());
        }, "nodes"), c(E(p(d2, Ve2)));
      }
      case "media-query":
        return [p(" ", be2.map(Me2, "nodes")), B(be2, ae2) ? "" : ","];
      case "media-type":
        return Oe2(Se2(ae2.value, je2));
      case "media-feature-expression":
        return ae2.nodes ? ["(", ...be2.map(Me2, "nodes"), ")"] : ae2.value;
      case "media-feature":
        return m(Se2(ae2.value.replace(/ +/g, " "), je2));
      case "media-colon":
        return [ae2.value, " "];
      case "media-value":
        return Oe2(Se2(ae2.value, je2));
      case "media-keyword":
        return Se2(ae2.value, je2);
      case "media-url":
        return Se2(ae2.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), je2);
      case "media-unknown":
        return ae2.value;
      case "selector-root":
        return c([h(be2, "custom-selector") ? [D(be2, "css-atrule").customSelector, d2] : "", p([",", h(be2, ["extend", "custom-selector", "nest"]) ? d2 : y2], be2.map(Me2, "nodes"))]);
      case "selector-selector":
        return c(E(be2.map(Me2, "nodes")));
      case "selector-comment":
        return ae2.value;
      case "selector-string":
        return Se2(ae2.value, je2);
      case "selector-tag": {
        let Ve2 = be2.getParentNode(), We2 = Ve2 && Ve2.nodes.indexOf(ae2), Xe = We2 && Ve2.nodes[We2 - 1];
        return [ae2.namespace ? [ae2.namespace === true ? "" : ae2.namespace.trim(), "|"] : "", Xe.type === "selector-nesting" ? ae2.value : Oe2(S(be2, ae2.value) ? ae2.value.toLowerCase() : ae2.value)];
      }
      case "selector-id":
        return ["#", ae2.value];
      case "selector-class":
        return [".", Oe2(Se2(ae2.value, je2))];
      case "selector-attribute": {
        var nt;
        return ["[", ae2.namespace ? [ae2.namespace === true ? "" : ae2.namespace.trim(), "|"] : "", ae2.attribute.trim(), (nt = ae2.operator) !== null && nt !== void 0 ? nt : "", ae2.value ? Ie2(Se2(ae2.value.trim(), je2), je2) : "", ae2.insensitive ? " i" : "", "]"];
      }
      case "selector-combinator": {
        if (ae2.value === "+" || ae2.value === ">" || ae2.value === "~" || ae2.value === ">>>") {
          let Xe = be2.getParentNode();
          return [Xe.type === "selector-selector" && Xe.nodes[0] === ae2 ? "" : d2, ae2.value, B(be2, ae2) ? "" : " "];
        }
        let Ve2 = ae2.value.trim().startsWith("(") ? d2 : "", We2 = Oe2(Se2(ae2.value.trim(), je2)) || d2;
        return [Ve2, We2];
      }
      case "selector-universal":
        return [ae2.namespace ? [ae2.namespace === true ? "" : ae2.namespace.trim(), "|"] : "", ae2.value];
      case "selector-pseudo":
        return [m(ae2.value), l(ae2.nodes) ? c(["(", E([g2, p([",", d2], be2.map(Me2, "nodes"))]), g2, ")"]) : ""];
      case "selector-nesting":
        return ae2.value;
      case "selector-unknown": {
        let Ve2 = D(be2, "css-rule");
        if (Ve2 && Ve2.isSCSSNesterProperty)
          return Oe2(Se2(m(ae2.value), je2));
        let We2 = be2.getParentNode();
        if (We2.raws && We2.raws.selector) {
          let st2 = Ae2(We2), O = st2 + We2.raws.selector.length;
          return je2.originalText.slice(st2, O).trim();
        }
        let Xe = be2.getParentNode(1);
        if (We2.type === "value-paren_group" && Xe && Xe.type === "value-func" && Xe.value === "selector") {
          let st2 = Ee(We2.open) + 1, O = Ae2(We2.close), me2 = je2.originalText.slice(st2, O).trim();
          return H(me2) ? [F, me2] : me2;
        }
        return ae2.value;
      }
      case "value-value":
      case "value-root":
        return Me2("group");
      case "value-comment":
        return je2.originalText.slice(Ae2(ae2), Ee(ae2));
      case "value-comma_group": {
        let Ve2 = be2.getParentNode(), We2 = be2.getParentNode(1), Xe = T(be2), st2 = Xe && Ve2.type === "value-value" && (Xe === "grid" || Xe.startsWith("grid-template")), O = D(be2, "css-atrule"), me2 = O && k(O), _e2 = ae2.groups.some((at2) => ge2(at2)), He2 = be2.map(Me2, "groups"), Ge2 = [], it2 = C(be2, "url"), Qe = false, rt2 = false;
        for (let at2 = 0; at2 < ae2.groups.length; ++at2) {
          var tt;
          Ge2.push(He2[at2]);
          let Ze2 = ae2.groups[at2 - 1], Le = ae2.groups[at2], $e2 = ae2.groups[at2 + 1], nr2 = ae2.groups[at2 + 2];
          if (it2) {
            ($e2 && Q($e2) || Q(Le)) && Ge2.push(" ");
            continue;
          }
          if (h(be2, "forward") && Le.type === "value-word" && Le.value && Ze2 !== void 0 && Ze2.type === "value-word" && Ze2.value === "as" && $e2.type === "value-operator" && $e2.value === "*" || !$e2 || Le.type === "value-word" && Le.value.endsWith("-") && pe2($e2))
            continue;
          if (Le.type === "value-string" && Le.quoted) {
            let Mr2 = Le.value.lastIndexOf("#{"), Rr2 = Le.value.lastIndexOf("}");
            Mr2 !== -1 && Rr2 !== -1 ? Qe = Mr2 > Rr2 : Mr2 !== -1 ? Qe = true : Rr2 !== -1 && (Qe = false);
          }
          if (Qe || Ne2(Le) || Ne2($e2) || Le.type === "value-atword" && (Le.value === "" || Le.value.endsWith("[")) || $e2.type === "value-word" && $e2.value.startsWith("]") || Le.value === "~" || Le.value && Le.value.includes("\\") && $e2 && $e2.type !== "value-comment" || Ze2 && Ze2.value && Ze2.value.indexOf("\\") === Ze2.value.length - 1 && Le.type === "value-operator" && Le.value === "/" || Le.value === "\\" || se2(Le, $e2) || he2(Le) || we2(Le) || ke2($e2) || we2($e2) && de($e2) || ke2(Le) && de($e2) || Le.value === "--" && he2($e2))
            continue;
          let qr = j(Le), su = j($e2);
          if ((qr && he2($e2) || su && ke2(Le)) && de($e2) || !Ze2 && L(Le) || C(be2, "calc") && (Q(Le) || Q($e2) || V(Le) || V($e2)) && de($e2))
            continue;
          let No2 = (Q(Le) || V(Le)) && at2 === 0 && ($e2.type === "value-number" || $e2.isHex) && We2 && oe(We2) && !de($e2), iu = nr2 && nr2.type === "value-func" || nr2 && Re2(nr2) || Le.type === "value-func" || Re2(Le), au = $e2.type === "value-func" || Re2($e2) || Ze2 && Ze2.type === "value-func" || Ze2 && Re2(Ze2);
          if (!(!(J($e2) || J(Le)) && !C(be2, "calc") && !No2 && (L($e2) && !iu || L(Le) && !au || Q($e2) && !iu || Q(Le) && !au || V($e2) || V(Le)) && (de($e2) || qr && (!Ze2 || Ze2 && j(Ze2)))) && !((je2.parser === "scss" || je2.parser === "less") && qr && Le.value === "-" && le2($e2) && Ee(Le) === Ae2($e2.open) && $e2.open.value === "(")) {
            if (ge2(Le)) {
              if (Ve2.type === "value-paren_group") {
                Ge2.push(_(y2));
                continue;
              }
              Ge2.push(y2);
              continue;
            }
            if (me2 && (q($e2) || R2($e2) || ce2($e2) || Y(Le) || ie2(Le))) {
              Ge2.push(" ");
              continue;
            }
            if (O && O.name.toLowerCase() === "namespace") {
              Ge2.push(" ");
              continue;
            }
            if (st2) {
              Le.source && $e2.source && Le.source.start.line !== $e2.source.start.line ? (Ge2.push(y2), rt2 = true) : Ge2.push(" ");
              continue;
            }
            if (su) {
              Ge2.push(" ");
              continue;
            }
            if (!($e2 && $e2.value === "...") && !(pe2(Le) && pe2($e2) && Ee(Le) === Ae2($e2))) {
              if (pe2(Le) && le2($e2) && Ee(Le) === Ae2($e2.open)) {
                Ge2.push(g2);
                continue;
              }
              if (Le.value === "with" && le2($e2)) {
                Ge2.push(" ");
                continue;
              }
              (tt = Le.value) !== null && tt !== void 0 && tt.endsWith("#") && $e2.value === "{" && le2($e2.group) || Ge2.push(d2);
            }
          }
        }
        return _e2 && Ge2.push(F), rt2 && Ge2.unshift(y2), me2 ? c(E(Ge2)) : v2(be2) ? c(f(Ge2)) : c(E(f(Ge2)));
      }
      case "value-paren_group": {
        let Ve2 = be2.getParentNode();
        if (Ve2 && ee2(Ve2) && (ae2.groups.length === 1 || ae2.groups.length > 0 && ae2.groups[0].type === "value-comma_group" && ae2.groups[0].groups.length > 0 && ae2.groups[0].groups[0].type === "value-word" && ae2.groups[0].groups[0].value.startsWith("data:")))
          return [ae2.open ? Me2("open") : "", p(",", be2.map(Me2, "groups")), ae2.close ? Me2("close") : ""];
        if (!ae2.open) {
          let it2 = be2.map(Me2, "groups"), Qe = [];
          for (let rt2 = 0; rt2 < it2.length; rt2++)
            rt2 !== 0 && Qe.push([",", d2]), Qe.push(it2[rt2]);
          return c(E(f(Qe)));
        }
        let We2 = fe2(be2), Xe = t(ae2.groups), st2 = Xe && Xe.type === "value-comment", O = Fe2(ae2, Ve2), me2 = X(ae2, Ve2), _e2 = me2 || We2 && !O, He2 = me2 || O, Ge2 = c([ae2.open ? Me2("open") : "", E([g2, p([d2], be2.map((it2, Qe) => {
          let rt2 = it2.getValue(), at2 = Qe === ae2.groups.length - 1, Ze2 = [Me2(), at2 ? "" : ","];
          if (ue2(rt2) && rt2.type === "value-comma_group" && rt2.groups && rt2.groups[0].type !== "value-paren_group" && rt2.groups[2] && rt2.groups[2].type === "value-paren_group") {
            let Le = x(Ze2[0].contents.contents);
            Le[1] = c(Le[1]), Ze2 = [c(_(Ze2))];
          }
          if (!at2 && rt2.type === "value-comma_group" && l(rt2.groups)) {
            let Le = t(rt2.groups);
            !Le.source && Le.close && (Le = Le.close), Le.source && i(je2.originalText, Le, Ee) && Ze2.push(y2);
          }
          return Ze2;
        }, "groups"))]), w(!st2 && A(je2.parser, je2.originalText) && We2 && re(je2) ? "," : ""), g2, ae2.close ? Me2("close") : ""], { shouldBreak: _e2 });
        return He2 ? _(Ge2) : Ge2;
      }
      case "value-func":
        return [ae2.value, h(be2, "supports") && Pe2(ae2) ? " " : "", Me2("group")];
      case "value-paren":
        return ae2.value;
      case "value-number":
        return [Je2(ae2.value), G(ae2.unit)];
      case "value-operator":
        return ae2.value;
      case "value-word":
        return ae2.isColor && ae2.isHex || b(ae2.value) ? ae2.value.toLowerCase() : ae2.value;
      case "value-colon": {
        let Ve2 = be2.getParentNode(), We2 = Ve2 && Ve2.groups.indexOf(ae2), Xe = We2 && Ve2.groups[We2 - 1];
        return [ae2.value, Xe && typeof Xe.value == "string" && t(Xe.value) === "\\" || C(be2, "url") ? "" : d2];
      }
      case "value-comma":
        return [ae2.value, " "];
      case "value-string":
        return a(ae2.raws.quote + ae2.value + ae2.raws.quote, je2);
      case "value-atword":
        return ["@", ae2.value];
      case "value-unicode-range":
        return ae2.value;
      case "value-unknown":
        return ae2.value;
      default:
        throw new Error(`Unknown postcss type ${JSON.stringify(ae2.type)}`);
    }
  }
  function Ce2(be2, je2, Me2) {
    let ae2 = [];
    return be2.each((nt, tt, Ve2) => {
      let We2 = Ve2[tt - 1];
      if (We2 && We2.type === "css-comment" && We2.text.trim() === "prettier-ignore") {
        let Xe = nt.getValue();
        ae2.push(je2.originalText.slice(Ae2(Xe), Ee(Xe)));
      } else
        ae2.push(Me2());
      tt !== Ve2.length - 1 && (Ve2[tt + 1].type === "css-comment" && !n(je2.originalText, Ae2(Ve2[tt + 1]), { backwards: true }) && !u(Ve2[tt]) || Ve2[tt + 1].type === "css-atrule" && Ve2[tt + 1].name === "else" && Ve2[tt].type !== "css-comment" ? ae2.push(" ") : (ae2.push(je2.__isHTMLStyleAttribute ? d2 : y2), i(je2.originalText, nt.getValue(), Ee) && !u(Ve2[tt]) && ae2.push(y2)));
    }, "nodes"), ae2;
  }
  var Be = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, ve2 = /(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g, ze = /[A-Za-z]+/g, xe2 = /[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g, Ye2 = new RegExp(Be.source + `|(${xe2.source})?(${ve2.source})(${ze.source})?`, "g");
  function Se2(be2, je2) {
    return be2.replace(Be, (Me2) => a(Me2, je2));
  }
  function Ie2(be2, je2) {
    let Me2 = je2.singleQuote ? "'" : '"';
    return be2.includes('"') || be2.includes("'") ? be2 : Me2 + be2 + Me2;
  }
  function Oe2(be2) {
    return be2.replace(Ye2, (je2, Me2, ae2, nt, tt) => !ae2 && nt ? Je2(nt) + m(tt || "") : je2);
  }
  function Je2(be2) {
    return s(be2).replace(/\.0(?=$|e)/, "");
  }
  r.exports = { print: ye2, embed: P, insertPragma: $2, massageAstNode: I2 };
} }), _d = te$1({ "src/language-css/options.js"(e, r) {
  ne();
  var t = jt();
  r.exports = { singleQuote: t.singleQuote };
} }), Pd = te$1({ "src/language-css/parsers.js"() {
  ne();
} }), Id = te$1({ "node_modules/linguist-languages/data/CSS.json"(e, r) {
  r.exports = { name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css"], languageId: 50 };
} }), kd = te$1({ "node_modules/linguist-languages/data/PostCSS.json"(e, r) {
  r.exports = { name: "PostCSS", type: "markup", color: "#dc3a0c", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", languageId: 262764437 };
} }), Ld = te$1({ "node_modules/linguist-languages/data/Less.json"(e, r) {
  r.exports = { name: "Less", type: "markup", color: "#1d365d", aliases: ["less-css"], extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198 };
} }), Od = te$1({ "node_modules/linguist-languages/data/SCSS.json"(e, r) {
  r.exports = { name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], languageId: 329 };
} }), jd = te$1({ "src/language-css/index.js"(e, r) {
  ne();
  var t = wt$1(), s = wd(), a = _d(), n = Pd(), u = [t(Id(), (l) => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"], extensions: [...l.extensions, ".wxss"] })), t(kd(), () => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"] })), t(Ld(), () => ({ since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"] })), t(Od(), () => ({ since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"] }))], i = { postcss: s };
  r.exports = { languages: u, options: a, printers: i, parsers: n };
} }), qd = te$1({ "src/language-handlebars/loc.js"(e, r) {
  ne();
  function t(a) {
    return a.loc.start.offset;
  }
  function s(a) {
    return a.loc.end.offset;
  }
  r.exports = { locStart: t, locEnd: s };
} }), Md = te$1({ "src/language-handlebars/clean.js"(e, r) {
  ne();
  function t(s, a) {
    if (s.type === "TextNode") {
      let n = s.chars.trim();
      if (!n)
        return null;
      a.chars = n.replace(/[\t\n\f\r ]+/g, " ");
    }
    s.type === "AttrNode" && s.name.toLowerCase() === "class" && delete a.value;
  }
  t.ignoredProperties = /* @__PURE__ */ new Set(["loc", "selfClosing"]), r.exports = t;
} }), Rd = te$1({ "src/language-handlebars/html-void-elements.evaluate.js"(e, r) {
  r.exports = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
} }), $d = te$1({ "src/language-handlebars/utils.js"(e, r) {
  ne();
  var t = lt$1(), s = Rd();
  function a(x) {
    let I2 = x.getValue(), P = x.getParentNode(0);
    return !!(g2(x, ["ElementNode"]) && t(P.children) === I2 || g2(x, ["Block"]) && t(P.body) === I2);
  }
  function n(x) {
    return x.toUpperCase() === x;
  }
  function u(x) {
    return y2(x, ["ElementNode"]) && typeof x.tag == "string" && !x.tag.startsWith(":") && (n(x.tag[0]) || x.tag.includes("."));
  }
  var i = new Set(s);
  function l(x) {
    return i.has(x.toLowerCase()) && !n(x[0]);
  }
  function p(x) {
    return x.selfClosing === true || l(x.tag) || u(x) && x.children.every((I2) => d2(I2));
  }
  function d2(x) {
    return y2(x, ["TextNode"]) && !/\S/.test(x.chars);
  }
  function y2(x, I2) {
    return x && I2.includes(x.type);
  }
  function g2(x, I2) {
    let P = x.getParentNode(0);
    return y2(P, I2);
  }
  function c(x, I2) {
    let P = _(x);
    return y2(P, I2);
  }
  function f(x, I2) {
    let P = w(x);
    return y2(P, I2);
  }
  function E(x, I2) {
    var P, $2, D, T;
    let m = x.getValue(), C = (P = x.getParentNode(0)) !== null && P !== void 0 ? P : {}, o = ($2 = (D = (T = C.children) !== null && T !== void 0 ? T : C.body) !== null && D !== void 0 ? D : C.parts) !== null && $2 !== void 0 ? $2 : [], h = o.indexOf(m);
    return h !== -1 && o[h + I2];
  }
  function _(x) {
    let I2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    return E(x, -I2);
  }
  function w(x) {
    return E(x, 1);
  }
  function F(x) {
    return y2(x, ["MustacheCommentStatement"]) && typeof x.value == "string" && x.value.trim() === "prettier-ignore";
  }
  function N2(x) {
    let I2 = x.getValue(), P = _(x, 2);
    return F(I2) || F(P);
  }
  r.exports = { getNextNode: w, getPreviousNode: _, hasPrettierIgnore: N2, isLastNodeOfSiblings: a, isNextNodeOfSomeType: f, isNodeOfSomeType: y2, isParentOfSomeType: g2, isPreviousNodeOfSomeType: c, isVoid: p, isWhitespaceNode: d2 };
} }), Vd = te$1({ "src/language-handlebars/printer-glimmer.js"(e, r) {
  ne();
  var { builders: { dedent: t, fill: s, group: a, hardline: n, ifBreak: u, indent: i, join: l, line: p, softline: d2 }, utils: { getDocParts: y2, replaceTextEndOfLine: g2 } } = qe(), { getPreferredQuote: c, isNonEmptyArray: f } = Ue$2(), { locStart: E, locEnd: _ } = qd(), w = Md(), { getNextNode: F, getPreviousNode: N2, hasPrettierIgnore: x, isLastNodeOfSiblings: I2, isNextNodeOfSomeType: P, isNodeOfSomeType: $2, isParentOfSomeType: D, isPreviousNodeOfSomeType: T, isVoid: m, isWhitespaceNode: C } = $d(), o = 2;
  function h(H, pe2, X) {
    let le2 = H.getValue();
    if (!le2)
      return "";
    if (x(H))
      return pe2.originalText.slice(E(le2), _(le2));
    let Ae2 = pe2.singleQuote ? "'" : '"';
    switch (le2.type) {
      case "Block":
      case "Program":
      case "Template":
        return a(H.map(X, "body"));
      case "ElementNode": {
        let Ee = a(S(H, X)), De2 = pe2.htmlWhitespaceSensitivity === "ignore" && P(H, ["ElementNode"]) ? d2 : "";
        if (m(le2))
          return [Ee, De2];
        let A = ["</", le2.tag, ">"];
        return le2.children.length === 0 ? [Ee, i(A), De2] : pe2.htmlWhitespaceSensitivity === "ignore" ? [Ee, i(b(H, pe2, X)), n, i(A), De2] : [Ee, i(a(b(H, pe2, X))), i(A), De2];
      }
      case "BlockStatement": {
        let Ee = H.getParentNode(1);
        return Ee && Ee.inverse && Ee.inverse.body.length === 1 && Ee.inverse.body[0] === le2 && Ee.inverse.body[0].path.parts[0] === Ee.path.parts[0] ? [ie2(H, X, Ee.inverse.body[0].path.parts[0]), de(H, X, pe2), ue2(H, X, pe2)] : [j(H, X), a([de(H, X, pe2), ue2(H, X, pe2), ee2(H, X, pe2)])];
      }
      case "ElementModifierStatement":
        return a(["{{", Re2(H, X), "}}"]);
      case "MustacheStatement":
        return a([k(le2), Re2(H, X), M2(le2)]);
      case "SubExpression":
        return a(["(", ke2(H, X), d2, ")"]);
      case "AttrNode": {
        let Ee = le2.value.type === "TextNode";
        if (Ee && le2.value.chars === "" && E(le2.value) === _(le2.value))
          return le2.name;
        let A = Ee ? c(le2.value.chars, Ae2).quote : le2.value.type === "ConcatStatement" ? c(le2.value.parts.filter((re) => re.type === "TextNode").map((re) => re.chars).join(""), Ae2).quote : "", G = X("value");
        return [le2.name, "=", A, le2.name === "class" && A ? a(i(G)) : G, A];
      }
      case "ConcatStatement":
        return H.map(X, "parts");
      case "Hash":
        return l(p, H.map(X, "pairs"));
      case "HashPair":
        return [le2.key, "=", X("value")];
      case "TextNode": {
        let Ee = le2.chars.replace(/{{/g, "\\{{"), De2 = U2(H);
        if (De2) {
          if (De2 === "class") {
            let Ye2 = Ee.trim().split(/\s+/).join(" "), Se2 = false, Ie2 = false;
            return D(H, ["ConcatStatement"]) && (T(H, ["MustacheStatement"]) && /^\s/.test(Ee) && (Se2 = true), P(H, ["MustacheStatement"]) && /\s$/.test(Ee) && Ye2 !== "" && (Ie2 = true)), [Se2 ? p : "", Ye2, Ie2 ? p : ""];
          }
          return g2(Ee);
        }
        let G = /^[\t\n\f\r ]*$/.test(Ee), re = !N2(H), ye2 = !F(H);
        if (pe2.htmlWhitespaceSensitivity !== "ignore") {
          let Ye2 = /^[\t\n\f\r ]*/, Se2 = /[\t\n\f\r ]*$/, Ie2 = ye2 && D(H, ["Template"]), Oe2 = re && D(H, ["Template"]);
          if (G) {
            if (Oe2 || Ie2)
              return "";
            let ae2 = [p], nt = Z(Ee);
            return nt && (ae2 = ge2(nt)), I2(H) && (ae2 = ae2.map((tt) => t(tt))), ae2;
          }
          let [Je2] = Ee.match(Ye2), [be2] = Ee.match(Se2), je2 = [];
          if (Je2) {
            je2 = [p];
            let ae2 = Z(Je2);
            ae2 && (je2 = ge2(ae2)), Ee = Ee.replace(Ye2, "");
          }
          let Me2 = [];
          if (be2) {
            if (!Ie2) {
              Me2 = [p];
              let ae2 = Z(be2);
              ae2 && (Me2 = ge2(ae2)), I2(H) && (Me2 = Me2.map((nt) => t(nt)));
            }
            Ee = Ee.replace(Se2, "");
          }
          return [...je2, s(Fe2(Ee)), ...Me2];
        }
        let Ce2 = Z(Ee), Be = se2(Ee), ve2 = fe2(Ee);
        if ((re || ye2) && G && D(H, ["Block", "ElementNode", "Template"]))
          return "";
        G && Ce2 ? (Be = Math.min(Ce2, o), ve2 = 0) : (P(H, ["BlockStatement", "ElementNode"]) && (ve2 = Math.max(ve2, 1)), T(H, ["BlockStatement", "ElementNode"]) && (Be = Math.max(Be, 1)));
        let ze = "", xe2 = "";
        return ve2 === 0 && P(H, ["MustacheStatement"]) && (xe2 = " "), Be === 0 && T(H, ["MustacheStatement"]) && (ze = " "), re && (Be = 0, ze = ""), ye2 && (ve2 = 0, xe2 = ""), Ee = Ee.replace(/^[\t\n\f\r ]+/g, ze).replace(/[\t\n\f\r ]+$/, xe2), [...ge2(Be), s(Fe2(Ee)), ...ge2(ve2)];
      }
      case "MustacheCommentStatement": {
        let Ee = E(le2), De2 = _(le2), A = pe2.originalText.charAt(Ee + 2) === "~", G = pe2.originalText.charAt(De2 - 3) === "~", re = le2.value.includes("}}") ? "--" : "";
        return ["{{", A ? "~" : "", "!", re, le2.value, re, G ? "~" : "", "}}"];
      }
      case "PathExpression":
        return le2.original;
      case "BooleanLiteral":
        return String(le2.value);
      case "CommentStatement":
        return ["<!--", le2.value, "-->"];
      case "StringLiteral": {
        if (we2(H)) {
          let Ee = pe2.singleQuote ? '"' : "'";
          return he2(le2.value, Ee);
        }
        return he2(le2.value, Ae2);
      }
      case "NumberLiteral":
        return String(le2.value);
      case "UndefinedLiteral":
        return "undefined";
      case "NullLiteral":
        return "null";
      default:
        throw new Error("unknown glimmer type: " + JSON.stringify(le2.type));
    }
  }
  function v2(H, pe2) {
    return E(H) - E(pe2);
  }
  function S(H, pe2) {
    let X = H.getValue(), le2 = ["attributes", "modifiers", "comments"].filter((Ee) => f(X[Ee])), Ae2 = le2.flatMap((Ee) => X[Ee]).sort(v2);
    for (let Ee of le2)
      H.each((De2) => {
        let A = Ae2.indexOf(De2.getValue());
        Ae2.splice(A, 1, [p, pe2()]);
      }, Ee);
    return f(X.blockParams) && Ae2.push(p, oe(X)), ["<", X.tag, i(Ae2), B(X)];
  }
  function b(H, pe2, X) {
    let Ae2 = H.getValue().children.every((Ee) => C(Ee));
    return pe2.htmlWhitespaceSensitivity === "ignore" && Ae2 ? "" : H.map((Ee, De2) => {
      let A = X();
      return De2 === 0 && pe2.htmlWhitespaceSensitivity === "ignore" ? [d2, A] : A;
    }, "children");
  }
  function B(H) {
    return m(H) ? u([d2, "/>"], [" />", d2]) : u([d2, ">"], ">");
  }
  function k(H) {
    let pe2 = H.escaped === false ? "{{{" : "{{", X = H.strip && H.strip.open ? "~" : "";
    return [pe2, X];
  }
  function M2(H) {
    let pe2 = H.escaped === false ? "}}}" : "}}";
    return [H.strip && H.strip.close ? "~" : "", pe2];
  }
  function R2(H) {
    let pe2 = k(H), X = H.openStrip.open ? "~" : "";
    return [pe2, X, "#"];
  }
  function q(H) {
    let pe2 = M2(H);
    return [H.openStrip.close ? "~" : "", pe2];
  }
  function J(H) {
    let pe2 = k(H), X = H.closeStrip.open ? "~" : "";
    return [pe2, X, "/"];
  }
  function L(H) {
    let pe2 = M2(H);
    return [H.closeStrip.close ? "~" : "", pe2];
  }
  function Q(H) {
    let pe2 = k(H), X = H.inverseStrip.open ? "~" : "";
    return [pe2, X];
  }
  function V(H) {
    let pe2 = M2(H);
    return [H.inverseStrip.close ? "~" : "", pe2];
  }
  function j(H, pe2) {
    let X = H.getValue(), le2 = [], Ae2 = Pe2(H, pe2);
    return Ae2 && le2.push(a(Ae2)), f(X.program.blockParams) && le2.push(oe(X.program)), a([R2(X), Ne2(H, pe2), le2.length > 0 ? i([p, l(p, le2)]) : "", d2, q(X)]);
  }
  function Y(H, pe2) {
    return [pe2.htmlWhitespaceSensitivity === "ignore" ? n : "", Q(H), "else", V(H)];
  }
  function ie2(H, pe2, X) {
    let le2 = H.getValue(), Ae2 = H.getParentNode(1);
    return a([Q(Ae2), ["else", " ", X], i([p, a(Pe2(H, pe2)), ...f(le2.program.blockParams) ? [p, oe(le2.program)] : []]), d2, V(Ae2)]);
  }
  function ee2(H, pe2, X) {
    let le2 = H.getValue();
    return X.htmlWhitespaceSensitivity === "ignore" ? [ce2(le2) ? d2 : n, J(le2), pe2("path"), L(le2)] : [J(le2), pe2("path"), L(le2)];
  }
  function ce2(H) {
    return $2(H, ["BlockStatement"]) && H.program.body.every((pe2) => C(pe2));
  }
  function W(H) {
    return K2(H) && H.inverse.body.length === 1 && $2(H.inverse.body[0], ["BlockStatement"]) && H.inverse.body[0].path.parts[0] === H.path.parts[0];
  }
  function K2(H) {
    return $2(H, ["BlockStatement"]) && H.inverse;
  }
  function de(H, pe2, X) {
    let le2 = H.getValue();
    if (ce2(le2))
      return "";
    let Ae2 = pe2("program");
    return X.htmlWhitespaceSensitivity === "ignore" ? i([n, Ae2]) : i(Ae2);
  }
  function ue2(H, pe2, X) {
    let le2 = H.getValue(), Ae2 = pe2("inverse"), Ee = X.htmlWhitespaceSensitivity === "ignore" ? [n, Ae2] : Ae2;
    return W(le2) ? Ee : K2(le2) ? [Y(le2, X), i(Ee)] : "";
  }
  function Fe2(H) {
    return y2(l(p, z(H)));
  }
  function z(H) {
    return H.split(/[\t\n\f\r ]+/);
  }
  function U2(H) {
    for (let pe2 = 0; pe2 < 2; pe2++) {
      let X = H.getParentNode(pe2);
      if (X && X.type === "AttrNode")
        return X.name.toLowerCase();
    }
  }
  function Z(H) {
    return H = typeof H == "string" ? H : "", H.split(`
`).length - 1;
  }
  function se2(H) {
    H = typeof H == "string" ? H : "";
    let pe2 = (H.match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "";
    return Z(pe2);
  }
  function fe2(H) {
    H = typeof H == "string" ? H : "";
    let pe2 = (H.match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "";
    return Z(pe2);
  }
  function ge2() {
    let H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return Array.from({ length: Math.min(H, o) }).fill(n);
  }
  function he2(H, pe2) {
    let { quote: X, regex: le2 } = c(H, pe2);
    return [X, H.replace(le2, `\\${X}`), X];
  }
  function we2(H) {
    let pe2 = 0, X = H.getParentNode(pe2);
    for (; X && $2(X, ["SubExpression"]); )
      pe2++, X = H.getParentNode(pe2);
    return !!(X && $2(H.getParentNode(pe2 + 1), ["ConcatStatement"]) && $2(H.getParentNode(pe2 + 2), ["AttrNode"]));
  }
  function ke2(H, pe2) {
    let X = Ne2(H, pe2), le2 = Pe2(H, pe2);
    return le2 ? i([X, p, a(le2)]) : X;
  }
  function Re2(H, pe2) {
    let X = Ne2(H, pe2), le2 = Pe2(H, pe2);
    return le2 ? [i([X, p, le2]), d2] : X;
  }
  function Ne2(H, pe2) {
    return pe2("path");
  }
  function Pe2(H, pe2) {
    let X = H.getValue(), le2 = [];
    if (X.params.length > 0) {
      let Ae2 = H.map(pe2, "params");
      le2.push(...Ae2);
    }
    if (X.hash && X.hash.pairs.length > 0) {
      let Ae2 = pe2("hash");
      le2.push(Ae2);
    }
    return le2.length === 0 ? "" : l(p, le2);
  }
  function oe(H) {
    return ["as |", H.blockParams.join(" "), "|"];
  }
  r.exports = { print: h, massageAstNode: w };
} }), Wd = te$1({ "src/language-handlebars/parsers.js"() {
  ne();
} }), Hd = te$1({ "node_modules/linguist-languages/data/Handlebars.json"(e, r) {
  r.exports = { name: "Handlebars", type: "markup", color: "#f7931e", aliases: ["hbs", "htmlbars"], extensions: [".handlebars", ".hbs"], tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155 };
} }), Gd = te$1({ "src/language-handlebars/index.js"(e, r) {
  ne();
  var t = wt$1(), s = Vd(), a = Wd(), n = [t(Hd(), () => ({ since: "2.3.0", parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"] }))], u = { glimmer: s };
  r.exports = { languages: n, printers: u, parsers: a };
} }), Ud = te$1({ "src/language-graphql/pragma.js"(e, r) {
  ne();
  function t(a) {
    return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(a);
  }
  function s(a) {
    return `# @format

` + a;
  }
  r.exports = { hasPragma: t, insertPragma: s };
} }), Jd = te$1({ "src/language-graphql/loc.js"(e, r) {
  ne();
  function t(a) {
    return typeof a.start == "number" ? a.start : a.loc && a.loc.start;
  }
  function s(a) {
    return typeof a.end == "number" ? a.end : a.loc && a.loc.end;
  }
  r.exports = { locStart: t, locEnd: s };
} }), zd = te$1({ "src/language-graphql/printer-graphql.js"(e, r) {
  ne();
  var { builders: { join: t, hardline: s, line: a, softline: n, group: u, indent: i, ifBreak: l } } = qe(), { isNextLineEmpty: p, isNonEmptyArray: d2 } = Ue$2(), { insertPragma: y2 } = Ud(), { locStart: g2, locEnd: c } = Jd();
  function f(P, $2, D) {
    let T = P.getValue();
    if (!T)
      return "";
    if (typeof T == "string")
      return T;
    switch (T.kind) {
      case "Document": {
        let m = [];
        return P.each((C, o, h) => {
          m.push(D()), o !== h.length - 1 && (m.push(s), p($2.originalText, C.getValue(), c) && m.push(s));
        }, "definitions"), [...m, s];
      }
      case "OperationDefinition": {
        let m = $2.originalText[g2(T)] !== "{", C = Boolean(T.name);
        return [m ? T.operation : "", m && C ? [" ", D("name")] : "", m && !C && d2(T.variableDefinitions) ? " " : "", d2(T.variableDefinitions) ? u(["(", i([n, t([l("", ", "), n], P.map(D, "variableDefinitions"))]), n, ")"]) : "", E(P, D, T), T.selectionSet ? !m && !C ? "" : " " : "", D("selectionSet")];
      }
      case "FragmentDefinition":
        return ["fragment ", D("name"), d2(T.variableDefinitions) ? u(["(", i([n, t([l("", ", "), n], P.map(D, "variableDefinitions"))]), n, ")"]) : "", " on ", D("typeCondition"), E(P, D, T), " ", D("selectionSet")];
      case "SelectionSet":
        return ["{", i([s, t(s, _(P, $2, D, "selections"))]), s, "}"];
      case "Field":
        return u([T.alias ? [D("alias"), ": "] : "", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $2, D, "arguments"))]), n, ")"]) : "", E(P, D, T), T.selectionSet ? " " : "", D("selectionSet")]);
      case "Name":
        return T.value;
      case "StringValue": {
        if (T.block) {
          let m = T.value.replace(/"""/g, "\\$&").split(`
`);
          return m.length === 1 && (m[0] = m[0].trim()), m.every((C) => C === "") && (m.length = 0), t(s, ['"""', ...m, '"""']);
        }
        return ['"', T.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
      }
      case "IntValue":
      case "FloatValue":
      case "EnumValue":
        return T.value;
      case "BooleanValue":
        return T.value ? "true" : "false";
      case "NullValue":
        return "null";
      case "Variable":
        return ["$", D("name")];
      case "ListValue":
        return u(["[", i([n, t([l("", ", "), n], P.map(D, "values"))]), n, "]"]);
      case "ObjectValue":
        return u(["{", $2.bracketSpacing && T.fields.length > 0 ? " " : "", i([n, t([l("", ", "), n], P.map(D, "fields"))]), n, l("", $2.bracketSpacing && T.fields.length > 0 ? " " : ""), "}"]);
      case "ObjectField":
      case "Argument":
        return [D("name"), ": ", D("value")];
      case "Directive":
        return ["@", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $2, D, "arguments"))]), n, ")"]) : ""];
      case "NamedType":
        return D("name");
      case "VariableDefinition":
        return [D("variable"), ": ", D("type"), T.defaultValue ? [" = ", D("defaultValue")] : "", E(P, D, T)];
      case "ObjectTypeExtension":
      case "ObjectTypeDefinition":
        return [D("description"), T.description ? s : "", T.kind === "ObjectTypeExtension" ? "extend " : "", "type ", D("name"), T.interfaces.length > 0 ? [" implements ", ...N2(P, $2, D)] : "", E(P, D, T), T.fields.length > 0 ? [" {", i([s, t(s, _(P, $2, D, "fields"))]), s, "}"] : ""];
      case "FieldDefinition":
        return [D("description"), T.description ? s : "", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $2, D, "arguments"))]), n, ")"]) : "", ": ", D("type"), E(P, D, T)];
      case "DirectiveDefinition":
        return [D("description"), T.description ? s : "", "directive ", "@", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $2, D, "arguments"))]), n, ")"]) : "", T.repeatable ? " repeatable" : "", " on ", t(" | ", P.map(D, "locations"))];
      case "EnumTypeExtension":
      case "EnumTypeDefinition":
        return [D("description"), T.description ? s : "", T.kind === "EnumTypeExtension" ? "extend " : "", "enum ", D("name"), E(P, D, T), T.values.length > 0 ? [" {", i([s, t(s, _(P, $2, D, "values"))]), s, "}"] : ""];
      case "EnumValueDefinition":
        return [D("description"), T.description ? s : "", D("name"), E(P, D, T)];
      case "InputValueDefinition":
        return [D("description"), T.description ? T.description.block ? s : a : "", D("name"), ": ", D("type"), T.defaultValue ? [" = ", D("defaultValue")] : "", E(P, D, T)];
      case "InputObjectTypeExtension":
      case "InputObjectTypeDefinition":
        return [D("description"), T.description ? s : "", T.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", D("name"), E(P, D, T), T.fields.length > 0 ? [" {", i([s, t(s, _(P, $2, D, "fields"))]), s, "}"] : ""];
      case "SchemaExtension":
        return ["extend schema", E(P, D, T), ...T.operationTypes.length > 0 ? [" {", i([s, t(s, _(P, $2, D, "operationTypes"))]), s, "}"] : []];
      case "SchemaDefinition":
        return [D("description"), T.description ? s : "", "schema", E(P, D, T), " {", T.operationTypes.length > 0 ? i([s, t(s, _(P, $2, D, "operationTypes"))]) : "", s, "}"];
      case "OperationTypeDefinition":
        return [D("operation"), ": ", D("type")];
      case "InterfaceTypeExtension":
      case "InterfaceTypeDefinition":
        return [D("description"), T.description ? s : "", T.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", D("name"), T.interfaces.length > 0 ? [" implements ", ...N2(P, $2, D)] : "", E(P, D, T), T.fields.length > 0 ? [" {", i([s, t(s, _(P, $2, D, "fields"))]), s, "}"] : ""];
      case "FragmentSpread":
        return ["...", D("name"), E(P, D, T)];
      case "InlineFragment":
        return ["...", T.typeCondition ? [" on ", D("typeCondition")] : "", E(P, D, T), " ", D("selectionSet")];
      case "UnionTypeExtension":
      case "UnionTypeDefinition":
        return u([D("description"), T.description ? s : "", u([T.kind === "UnionTypeExtension" ? "extend " : "", "union ", D("name"), E(P, D, T), T.types.length > 0 ? [" =", l("", " "), i([l([a, "  "]), t([a, "| "], P.map(D, "types"))])] : ""])]);
      case "ScalarTypeExtension":
      case "ScalarTypeDefinition":
        return [D("description"), T.description ? s : "", T.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", D("name"), E(P, D, T)];
      case "NonNullType":
        return [D("type"), "!"];
      case "ListType":
        return ["[", D("type"), "]"];
      default:
        throw new Error("unknown graphql type: " + JSON.stringify(T.kind));
    }
  }
  function E(P, $2, D) {
    if (D.directives.length === 0)
      return "";
    let T = t(a, P.map($2, "directives"));
    return D.kind === "FragmentDefinition" || D.kind === "OperationDefinition" ? u([a, T]) : [" ", u(i([n, T]))];
  }
  function _(P, $2, D, T) {
    return P.map((m, C, o) => {
      let h = D();
      return C < o.length - 1 && p($2.originalText, m.getValue(), c) ? [h, s] : h;
    }, T);
  }
  function w(P) {
    return P.kind && P.kind !== "Comment";
  }
  function F(P) {
    let $2 = P.getValue();
    if ($2.kind === "Comment")
      return "#" + $2.value.trimEnd();
    throw new Error("Not a comment: " + JSON.stringify($2));
  }
  function N2(P, $2, D) {
    let T = P.getNode(), m = [], { interfaces: C } = T, o = P.map((h) => D(h), "interfaces");
    for (let h = 0; h < C.length; h++) {
      let v2 = C[h];
      m.push(o[h]);
      let S = C[h + 1];
      if (S) {
        let b = $2.originalText.slice(v2.loc.end, S.loc.start), B = b.includes("#"), k = b.replace(/#.*/g, "").trim();
        m.push(k === "," ? "," : " &", B ? a : " ");
      }
    }
    return m;
  }
  function x(P, $2) {
    P.kind === "StringValue" && P.block && !P.value.includes(`
`) && ($2.value = $2.value.trim());
  }
  x.ignoredProperties = /* @__PURE__ */ new Set(["loc", "comments"]);
  function I2(P) {
    var $2;
    let D = P.getValue();
    return D == null || ($2 = D.comments) === null || $2 === void 0 ? void 0 : $2.some((T) => T.value.trim() === "prettier-ignore");
  }
  r.exports = { print: f, massageAstNode: x, hasPrettierIgnore: I2, insertPragma: y2, printComment: F, canAttachComment: w };
} }), Xd = te$1({ "src/language-graphql/options.js"(e, r) {
  ne();
  var t = jt();
  r.exports = { bracketSpacing: t.bracketSpacing };
} }), Kd = te$1({ "src/language-graphql/parsers.js"() {
  ne();
} }), Yd = te$1({ "node_modules/linguist-languages/data/GraphQL.json"(e, r) {
  r.exports = { name: "GraphQL", type: "data", color: "#e10098", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", aceMode: "text", languageId: 139 };
} }), Qd = te$1({ "src/language-graphql/index.js"(e, r) {
  ne();
  var t = wt$1(), s = zd(), a = Xd(), n = Kd(), u = [t(Yd(), () => ({ since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"] }))], i = { graphql: s };
  r.exports = { languages: u, options: a, printers: i, parsers: n };
} }), So$2 = te$1({ "node_modules/collapse-white-space/index.js"(e, r) {
  ne(), r.exports = t;
  function t(s) {
    return String(s).replace(/\s+/g, " ");
  }
} }), xo$2 = te$1({ "src/language-markdown/loc.js"(e, r) {
  ne();
  function t(a) {
    return a.position.start.offset;
  }
  function s(a) {
    return a.position.end.offset;
  }
  r.exports = { locStart: t, locEnd: s };
} }), Zd = te$1({ "src/language-markdown/constants.evaluate.js"(e, r) {
  r.exports = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" };
} }), nu = te$1({ "src/language-markdown/utils.js"(e, r) {
  ne();
  var { getLast: t } = Ue$2(), { locStart: s, locEnd: a } = xo$2(), { cjkPattern: n, kPattern: u, punctuationPattern: i } = Zd(), l = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], p = [...l, "tableCell", "paragraph", "heading"], d2 = new RegExp(u), y2 = new RegExp(i);
  function g2(F, N2) {
    let x = "non-cjk", I2 = "cj-letter", P = "k-letter", $2 = "cjk-punctuation", D = [], T = (N2.proseWrap === "preserve" ? F : F.replace(new RegExp(`(${n})
(${n})`, "g"), "$1$2")).split(/([\t\n ]+)/);
    for (let [C, o] of T.entries()) {
      if (C % 2 === 1) {
        D.push({ type: "whitespace", value: /\n/.test(o) ? `
` : " " });
        continue;
      }
      if ((C === 0 || C === T.length - 1) && o === "")
        continue;
      let h = o.split(new RegExp(`(${n})`));
      for (let [v2, S] of h.entries())
        if (!((v2 === 0 || v2 === h.length - 1) && S === "")) {
          if (v2 % 2 === 0) {
            S !== "" && m({ type: "word", value: S, kind: x, hasLeadingPunctuation: y2.test(S[0]), hasTrailingPunctuation: y2.test(t(S)) });
            continue;
          }
          m(y2.test(S) ? { type: "word", value: S, kind: $2, hasLeadingPunctuation: true, hasTrailingPunctuation: true } : { type: "word", value: S, kind: d2.test(S) ? P : I2, hasLeadingPunctuation: false, hasTrailingPunctuation: false });
        }
    }
    return D;
    function m(C) {
      let o = t(D);
      o && o.type === "word" && (o.kind === x && C.kind === I2 && !o.hasTrailingPunctuation || o.kind === I2 && C.kind === x && !C.hasLeadingPunctuation ? D.push({ type: "whitespace", value: " " }) : !h(x, $2) && ![o.value, C.value].some((v2) => /\u3000/.test(v2)) && D.push({ type: "whitespace", value: "" })), D.push(C);
      function h(v2, S) {
        return o.kind === v2 && C.kind === S || o.kind === S && C.kind === v2;
      }
    }
  }
  function c(F, N2) {
    let [, x, I2, P] = N2.slice(F.position.start.offset, F.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
    return { numberText: x, marker: I2, leadingSpaces: P };
  }
  function f(F, N2) {
    if (!F.ordered || F.children.length < 2)
      return false;
    let x = Number(c(F.children[0], N2.originalText).numberText), I2 = Number(c(F.children[1], N2.originalText).numberText);
    if (x === 0 && F.children.length > 2) {
      let P = Number(c(F.children[2], N2.originalText).numberText);
      return I2 === 1 && P === 1;
    }
    return I2 === 1;
  }
  function E(F, N2) {
    let { value: x } = F;
    return F.position.end.offset === N2.length && x.endsWith(`
`) && N2.endsWith(`
`) ? x.slice(0, -1) : x;
  }
  function _(F, N2) {
    return function x(I2, P, $2) {
      let D = Object.assign({}, N2(I2, P, $2));
      return D.children && (D.children = D.children.map((T, m) => x(T, m, [D, ...$2]))), D;
    }(F, null, []);
  }
  function w(F) {
    if ((F == null ? void 0 : F.type) !== "link" || F.children.length !== 1)
      return false;
    let [N2] = F.children;
    return s(F) === s(N2) && a(F) === a(N2);
  }
  r.exports = { mapAst: _, splitText: g2, punctuationPattern: i, getFencedCodeBlockValue: E, getOrderedListItemInfo: c, hasGitDiffFriendlyOrderedList: f, INLINE_NODE_TYPES: l, INLINE_NODE_WRAPPER_TYPES: p, isAutolink: w };
} }), eg = te$1({ "src/language-markdown/embed.js"(e, r) {
  ne();
  var { inferParserByLanguage: t, getMaxContinuousCount: s } = Ue$2(), { builders: { hardline: a, markAsRoot: n }, utils: { replaceEndOfLine: u } } = qe(), i = ru(), { getFencedCodeBlockValue: l } = nu();
  function p(d2, y2, g2, c) {
    let f = d2.getValue();
    if (f.type === "code" && f.lang !== null) {
      let E = t(f.lang, c);
      if (E) {
        let _ = c.__inJsTemplate ? "~" : "`", w = _.repeat(Math.max(3, s(f.value, _) + 1)), F = { parser: E };
        f.lang === "tsx" && (F.filepath = "dummy.tsx");
        let N2 = g2(l(f, c.originalText), F, { stripTrailingHardline: true });
        return n([w, f.lang, f.meta ? " " + f.meta : "", a, u(N2), a, w]);
      }
    }
    switch (f.type) {
      case "front-matter":
        return i(f, g2);
      case "importExport":
        return [g2(f.value, { parser: "babel" }, { stripTrailingHardline: true }), a];
      case "jsx":
        return g2(`<$>${f.value}</$>`, { parser: "__js_expression", rootMarker: "mdx" }, { stripTrailingHardline: true });
    }
    return null;
  }
  r.exports = p;
} }), bo$2 = te$1({ "src/language-markdown/pragma.js"(e, r) {
  ne();
  var t = Ao$2(), s = ["format", "prettier"];
  function a(n) {
    let u = `@(${s.join("|")})`, i = new RegExp([`<!--\\s*${u}\\s*-->`, `{\\s*\\/\\*\\s*${u}\\s*\\*\\/\\s*}`, `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*${u}[^\\S
]*($|
)[\\s\\S]*
.*-->`].join("|"), "m"), l = n.match(i);
    return (l == null ? void 0 : l.index) === 0;
  }
  r.exports = { startWithPragma: a, hasPragma: (n) => a(t(n).content.trimStart()), insertPragma: (n) => {
    let u = t(n), i = `<!-- @${s[0]} -->`;
    return u.frontMatter ? `${u.frontMatter.raw}

${i}

${u.content}` : `${i}

${u.content}`;
  } };
} }), tg = te$1({ "src/language-markdown/print-preprocess.js"(e, r) {
  ne();
  var t = lt$1(), { getOrderedListItemInfo: s, mapAst: a, splitText: n } = nu(), u = /^.$/su;
  function i(w, F) {
    return w = d2(w, F), w = c(w), w = p(w, F), w = E(w, F), w = _(w, F), w = f(w, F), w = l(w), w = y2(w), w;
  }
  function l(w) {
    return a(w, (F) => F.type !== "import" && F.type !== "export" ? F : Object.assign(Object.assign({}, F), {}, { type: "importExport" }));
  }
  function p(w, F) {
    return a(w, (N2) => N2.type !== "inlineCode" || F.proseWrap === "preserve" ? N2 : Object.assign(Object.assign({}, N2), {}, { value: N2.value.replace(/\s+/g, " ") }));
  }
  function d2(w, F) {
    return a(w, (N2) => N2.type !== "text" || N2.value === "*" || N2.value === "_" || !u.test(N2.value) || N2.position.end.offset - N2.position.start.offset === N2.value.length ? N2 : Object.assign(Object.assign({}, N2), {}, { value: F.originalText.slice(N2.position.start.offset, N2.position.end.offset) }));
  }
  function y2(w) {
    return g2(w, (F, N2) => F.type === "importExport" && N2.type === "importExport", (F, N2) => ({ type: "importExport", value: F.value + `

` + N2.value, position: { start: F.position.start, end: N2.position.end } }));
  }
  function g2(w, F, N2) {
    return a(w, (x) => {
      if (!x.children)
        return x;
      let I2 = x.children.reduce((P, $2) => {
        let D = t(P);
        return D && F(D, $2) ? P.splice(-1, 1, N2(D, $2)) : P.push($2), P;
      }, []);
      return Object.assign(Object.assign({}, x), {}, { children: I2 });
    });
  }
  function c(w) {
    return g2(w, (F, N2) => F.type === "text" && N2.type === "text", (F, N2) => ({ type: "text", value: F.value + N2.value, position: { start: F.position.start, end: N2.position.end } }));
  }
  function f(w, F) {
    return a(w, (N2, x, I2) => {
      let [P] = I2;
      if (N2.type !== "text")
        return N2;
      let { value: $2 } = N2;
      return P.type === "paragraph" && (x === 0 && ($2 = $2.trimStart()), x === P.children.length - 1 && ($2 = $2.trimEnd())), { type: "sentence", position: N2.position, children: n($2, F) };
    });
  }
  function E(w, F) {
    return a(w, (N2, x, I2) => {
      if (N2.type === "code") {
        let P = /^\n?(?: {4,}|\t)/.test(F.originalText.slice(N2.position.start.offset, N2.position.end.offset));
        if (N2.isIndented = P, P)
          for (let $2 = 0; $2 < I2.length; $2++) {
            let D = I2[$2];
            if (D.hasIndentedCodeblock)
              break;
            D.type === "list" && (D.hasIndentedCodeblock = true);
          }
      }
      return N2;
    });
  }
  function _(w, F) {
    return a(w, (I2, P, $2) => {
      if (I2.type === "list" && I2.children.length > 0) {
        for (let D = 0; D < $2.length; D++) {
          let T = $2[D];
          if (T.type === "list" && !T.isAligned)
            return I2.isAligned = false, I2;
        }
        I2.isAligned = x(I2);
      }
      return I2;
    });
    function N2(I2) {
      return I2.children.length === 0 ? -1 : I2.children[0].position.start.column - 1;
    }
    function x(I2) {
      if (!I2.ordered)
        return true;
      let [P, $2] = I2.children;
      if (s(P, F.originalText).leadingSpaces.length > 1)
        return true;
      let T = N2(P);
      if (T === -1)
        return false;
      if (I2.children.length === 1)
        return T % F.tabWidth === 0;
      let m = N2($2);
      return T !== m ? false : T % F.tabWidth === 0 ? true : s($2, F.originalText).leadingSpaces.length > 1;
    }
  }
  r.exports = i;
} }), rg = te$1({ "src/language-markdown/clean.js"(e, r) {
  ne();
  var t = So$2(), { isFrontMatterNode: s } = Ue$2(), { startWithPragma: a } = bo$2(), n = /* @__PURE__ */ new Set(["position", "raw"]);
  function u(i, l, p) {
    if ((i.type === "front-matter" || i.type === "code" || i.type === "yaml" || i.type === "import" || i.type === "export" || i.type === "jsx") && delete l.value, i.type === "list" && delete l.isAligned, (i.type === "list" || i.type === "listItem") && (delete l.spread, delete l.loose), i.type === "text" || (i.type === "inlineCode" && (l.value = i.value.replace(/[\t\n ]+/g, " ")), i.type === "wikiLink" && (l.value = i.value.trim().replace(/[\t\n]+/g, " ")), (i.type === "definition" || i.type === "linkReference" || i.type === "imageReference") && (l.label = t(i.label)), (i.type === "definition" || i.type === "link" || i.type === "image") && i.title && (l.title = i.title.replace(/\\(["')])/g, "$1")), p && p.type === "root" && p.children.length > 0 && (p.children[0] === i || s(p.children[0]) && p.children[1] === i) && i.type === "html" && a(i.value)))
      return null;
  }
  u.ignoredProperties = n, r.exports = u;
} }), ng = te$1({ "src/language-markdown/printer-markdown.js"(e, r) {
  ne();
  var t = So$2(), { getLast: s, getMinNotPresentContinuousCount: a, getMaxContinuousCount: n, getStringWidth: u, isNonEmptyArray: i } = Ue$2(), { builders: { breakParent: l, join: p, line: d2, literalline: y2, markAsRoot: g2, hardline: c, softline: f, ifBreak: E, fill: _, align: w, indent: F, group: N2, hardlineWithoutBreakParent: x }, utils: { normalizeDoc: I2, replaceTextEndOfLine: P }, printer: { printDocToString: $2 } } = qe(), D = eg(), { insertPragma: T } = bo$2(), { locStart: m, locEnd: C } = xo$2(), o = tg(), h = rg(), { getFencedCodeBlockValue: v2, hasGitDiffFriendlyOrderedList: S, splitText: b, punctuationPattern: B, INLINE_NODE_TYPES: k, INLINE_NODE_WRAPPER_TYPES: M2, isAutolink: R2 } = nu(), q = /* @__PURE__ */ new Set(["importExport"]), J = ["heading", "tableCell", "link", "wikiLink"], L = /* @__PURE__ */ new Set(["listItem", "definition", "footnoteDefinition"]);
  function Q(oe, H, pe2) {
    let X = oe.getValue();
    if (ge2(oe))
      return b(H.originalText.slice(X.position.start.offset, X.position.end.offset), H).map((le2) => le2.type === "word" ? le2.value : le2.value === "" ? "" : W(oe, le2.value, H));
    switch (X.type) {
      case "front-matter":
        return H.originalText.slice(X.position.start.offset, X.position.end.offset);
      case "root":
        return X.children.length === 0 ? "" : [I2(de(oe, H, pe2)), q.has(z(X).type) ? "" : c];
      case "paragraph":
        return ue2(oe, H, pe2, { postprocessor: _ });
      case "sentence":
        return ue2(oe, H, pe2);
      case "word": {
        let le2 = X.value.replace(/\*/g, "\\$&").replace(new RegExp([`(^|${B})(_+)`, `(_+)(${B}|$)`].join("|"), "g"), (De2, A, G, re, ye2) => (G ? `${A}${G}` : `${re}${ye2}`).replace(/_/g, "\\_")), Ae2 = (De2, A, G) => De2.type === "sentence" && G === 0, Ee = (De2, A, G) => R2(De2.children[G - 1]);
        return le2 !== X.value && (oe.match(void 0, Ae2, Ee) || oe.match(void 0, Ae2, (De2, A, G) => De2.type === "emphasis" && G === 0, Ee)) && (le2 = le2.replace(/^(\\?[*_])+/, (De2) => De2.replace(/\\/g, ""))), le2;
      }
      case "whitespace": {
        let le2 = oe.getParentNode(), Ae2 = le2.children.indexOf(X), Ee = le2.children[Ae2 + 1], De2 = Ee && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(Ee.value) ? "never" : H.proseWrap;
        return W(oe, X.value, { proseWrap: De2 });
      }
      case "emphasis": {
        let le2;
        if (R2(X.children[0]))
          le2 = H.originalText[X.position.start.offset];
        else {
          let Ae2 = oe.getParentNode(), Ee = Ae2.children.indexOf(X), De2 = Ae2.children[Ee - 1], A = Ae2.children[Ee + 1];
          le2 = De2 && De2.type === "sentence" && De2.children.length > 0 && s(De2.children).type === "word" && !s(De2.children).hasTrailingPunctuation || A && A.type === "sentence" && A.children.length > 0 && A.children[0].type === "word" && !A.children[0].hasLeadingPunctuation || ce2(oe, "emphasis") ? "*" : "_";
        }
        return [le2, ue2(oe, H, pe2), le2];
      }
      case "strong":
        return ["**", ue2(oe, H, pe2), "**"];
      case "delete":
        return ["~~", ue2(oe, H, pe2), "~~"];
      case "inlineCode": {
        let le2 = a(X.value, "`"), Ae2 = "`".repeat(le2 || 1), Ee = le2 && !/^\s/.test(X.value) ? " " : "";
        return [Ae2, Ee, X.value, Ee, Ae2];
      }
      case "wikiLink": {
        let le2 = "";
        return H.proseWrap === "preserve" ? le2 = X.value : le2 = X.value.replace(/[\t\n]+/g, " "), ["[[", le2, "]]"];
      }
      case "link":
        switch (H.originalText[X.position.start.offset]) {
          case "<": {
            let le2 = "mailto:";
            return ["<", X.url.startsWith(le2) && H.originalText.slice(X.position.start.offset + 1, X.position.start.offset + 1 + le2.length) !== le2 ? X.url.slice(le2.length) : X.url, ">"];
          }
          case "[":
            return ["[", ue2(oe, H, pe2), "](", he2(X.url, ")"), we2(X.title, H), ")"];
          default:
            return H.originalText.slice(X.position.start.offset, X.position.end.offset);
        }
      case "image":
        return ["![", X.alt || "", "](", he2(X.url, ")"), we2(X.title, H), ")"];
      case "blockquote":
        return ["> ", w("> ", ue2(oe, H, pe2))];
      case "heading":
        return ["#".repeat(X.depth) + " ", ue2(oe, H, pe2)];
      case "code": {
        if (X.isIndented) {
          let Ee = " ".repeat(4);
          return w(Ee, [Ee, ...P(X.value, c)]);
        }
        let le2 = H.__inJsTemplate ? "~" : "`", Ae2 = le2.repeat(Math.max(3, n(X.value, le2) + 1));
        return [Ae2, X.lang || "", X.meta ? " " + X.meta : "", c, ...P(v2(X, H.originalText), c), c, Ae2];
      }
      case "html": {
        let le2 = oe.getParentNode(), Ae2 = le2.type === "root" && s(le2.children) === X ? X.value.trimEnd() : X.value, Ee = /^<!--.*-->$/s.test(Ae2);
        return P(Ae2, Ee ? c : g2(y2));
      }
      case "list": {
        let le2 = Y(X, oe.getParentNode()), Ae2 = S(X, H);
        return ue2(oe, H, pe2, { processor: (Ee, De2) => {
          let A = re(), G = Ee.getValue();
          if (G.children.length === 2 && G.children[1].type === "html" && G.children[0].position.start.column !== G.children[1].position.start.column)
            return [A, V(Ee, H, pe2, A)];
          return [A, w(" ".repeat(A.length), V(Ee, H, pe2, A))];
          function re() {
            let ye2 = X.ordered ? (De2 === 0 ? X.start : Ae2 ? 1 : X.start + De2) + (le2 % 2 === 0 ? ". " : ") ") : le2 % 2 === 0 ? "- " : "* ";
            return X.isAligned || X.hasIndentedCodeblock ? j(ye2, H) : ye2;
          }
        } });
      }
      case "thematicBreak": {
        let le2 = ee2(oe, "list");
        return le2 === -1 ? "---" : Y(oe.getParentNode(le2), oe.getParentNode(le2 + 1)) % 2 === 0 ? "***" : "---";
      }
      case "linkReference":
        return ["[", ue2(oe, H, pe2), "]", X.referenceType === "full" ? Ne2(X) : X.referenceType === "collapsed" ? "[]" : ""];
      case "imageReference":
        switch (X.referenceType) {
          case "full":
            return ["![", X.alt || "", "]", Ne2(X)];
          default:
            return ["![", X.alt, "]", X.referenceType === "collapsed" ? "[]" : ""];
        }
      case "definition": {
        let le2 = H.proseWrap === "always" ? d2 : " ";
        return N2([Ne2(X), ":", F([le2, he2(X.url), X.title === null ? "" : [le2, we2(X.title, H, false)]])]);
      }
      case "footnote":
        return ["[^", ue2(oe, H, pe2), "]"];
      case "footnoteReference":
        return Pe2(X);
      case "footnoteDefinition": {
        let le2 = oe.getParentNode().children[oe.getName() + 1], Ae2 = X.children.length === 1 && X.children[0].type === "paragraph" && (H.proseWrap === "never" || H.proseWrap === "preserve" && X.children[0].position.start.line === X.children[0].position.end.line);
        return [Pe2(X), ": ", Ae2 ? ue2(oe, H, pe2) : N2([w(" ".repeat(4), ue2(oe, H, pe2, { processor: (Ee, De2) => De2 === 0 ? N2([f, pe2()]) : pe2() })), le2 && le2.type === "footnoteDefinition" ? f : ""])];
      }
      case "table":
        return K2(oe, H, pe2);
      case "tableCell":
        return ue2(oe, H, pe2);
      case "break":
        return /\s/.test(H.originalText[X.position.start.offset]) ? ["  ", g2(y2)] : ["\\", c];
      case "liquidNode":
        return P(X.value, c);
      case "importExport":
        return [X.value, c];
      case "esComment":
        return ["{/* ", X.value, " */}"];
      case "jsx":
        return X.value;
      case "math":
        return ["$$", c, X.value ? [...P(X.value, c), c] : "", "$$"];
      case "inlineMath":
        return H.originalText.slice(m(X), C(X));
      case "tableRow":
      case "listItem":
      default:
        throw new Error(`Unknown markdown type ${JSON.stringify(X.type)}`);
    }
  }
  function V(oe, H, pe2, X) {
    let le2 = oe.getValue(), Ae2 = le2.checked === null ? "" : le2.checked ? "[x] " : "[ ] ";
    return [Ae2, ue2(oe, H, pe2, { processor: (Ee, De2) => {
      if (De2 === 0 && Ee.getValue().type !== "list")
        return w(" ".repeat(Ae2.length), pe2());
      let A = " ".repeat(ke2(H.tabWidth - X.length, 0, 3));
      return [A, w(A, pe2())];
    } })];
  }
  function j(oe, H) {
    let pe2 = X();
    return oe + " ".repeat(pe2 >= 4 ? 0 : pe2);
    function X() {
      let le2 = oe.length % H.tabWidth;
      return le2 === 0 ? 0 : H.tabWidth - le2;
    }
  }
  function Y(oe, H) {
    return ie2(oe, H, (pe2) => pe2.ordered === oe.ordered);
  }
  function ie2(oe, H, pe2) {
    let X = -1;
    for (let le2 of H.children)
      if (le2.type === oe.type && pe2(le2) ? X++ : X = -1, le2 === oe)
        return X;
  }
  function ee2(oe, H) {
    let pe2 = Array.isArray(H) ? H : [H], X = -1, le2;
    for (; le2 = oe.getParentNode(++X); )
      if (pe2.includes(le2.type))
        return X;
    return -1;
  }
  function ce2(oe, H) {
    let pe2 = ee2(oe, H);
    return pe2 === -1 ? null : oe.getParentNode(pe2);
  }
  function W(oe, H, pe2) {
    if (pe2.proseWrap === "preserve" && H === `
`)
      return c;
    let X = pe2.proseWrap === "always" && !ce2(oe, J);
    return H !== "" ? X ? d2 : " " : X ? f : "";
  }
  function K2(oe, H, pe2) {
    let X = oe.getValue(), le2 = [], Ae2 = oe.map((ye2) => ye2.map((Ce2, Be) => {
      let ve2 = $2(pe2(), H).formatted, ze = u(ve2);
      return le2[Be] = Math.max(le2[Be] || 3, ze), { text: ve2, width: ze };
    }, "children"), "children"), Ee = A(false);
    if (H.proseWrap !== "never")
      return [l, Ee];
    let De2 = A(true);
    return [l, N2(E(De2, Ee))];
    function A(ye2) {
      let Ce2 = [re(Ae2[0], ye2), G(ye2)];
      return Ae2.length > 1 && Ce2.push(p(x, Ae2.slice(1).map((Be) => re(Be, ye2)))), p(x, Ce2);
    }
    function G(ye2) {
      return `| ${le2.map((Be, ve2) => {
        let ze = X.align[ve2], xe2 = ze === "center" || ze === "left" ? ":" : "-", Ye2 = ze === "center" || ze === "right" ? ":" : "-", Se2 = ye2 ? "-" : "-".repeat(Be - 2);
        return `${xe2}${Se2}${Ye2}`;
      }).join(" | ")} |`;
    }
    function re(ye2, Ce2) {
      return `| ${ye2.map((ve2, ze) => {
        let { text: xe2, width: Ye2 } = ve2;
        if (Ce2)
          return xe2;
        let Se2 = le2[ze] - Ye2, Ie2 = X.align[ze], Oe2 = 0;
        Ie2 === "right" ? Oe2 = Se2 : Ie2 === "center" && (Oe2 = Math.floor(Se2 / 2));
        let Je2 = Se2 - Oe2;
        return `${" ".repeat(Oe2)}${xe2}${" ".repeat(Je2)}`;
      }).join(" | ")} |`;
    }
  }
  function de(oe, H, pe2) {
    let X = [], le2 = null, { children: Ae2 } = oe.getValue();
    for (let [Ee, De2] of Ae2.entries())
      switch (U2(De2)) {
        case "start":
          le2 === null && (le2 = { index: Ee, offset: De2.position.end.offset });
          break;
        case "end":
          le2 !== null && (X.push({ start: le2, end: { index: Ee, offset: De2.position.start.offset } }), le2 = null);
          break;
      }
    return ue2(oe, H, pe2, { processor: (Ee, De2) => {
      if (X.length > 0) {
        let A = X[0];
        if (De2 === A.start.index)
          return [Fe2(Ae2[A.start.index]), H.originalText.slice(A.start.offset, A.end.offset), Fe2(Ae2[A.end.index])];
        if (A.start.index < De2 && De2 < A.end.index)
          return false;
        if (De2 === A.end.index)
          return X.shift(), false;
      }
      return pe2();
    } });
  }
  function ue2(oe, H, pe2) {
    let X = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, { postprocessor: le2 } = X, Ae2 = X.processor || (() => pe2()), Ee = oe.getValue(), De2 = [], A;
    return oe.each((G, re) => {
      let ye2 = G.getValue(), Ce2 = Ae2(G, re);
      if (Ce2 !== false) {
        let Be = { parts: De2, prevNode: A, parentNode: Ee, options: H };
        Z(ye2, Be) && (De2.push(c), A && q.has(A.type) || (se2(ye2, Be) || fe2(ye2, Be)) && De2.push(c), fe2(ye2, Be) && De2.push(c)), De2.push(Ce2), A = ye2;
      }
    }, "children"), le2 ? le2(De2) : De2;
  }
  function Fe2(oe) {
    if (oe.type === "html")
      return oe.value;
    if (oe.type === "paragraph" && Array.isArray(oe.children) && oe.children.length === 1 && oe.children[0].type === "esComment")
      return ["{/* ", oe.children[0].value, " */}"];
  }
  function z(oe) {
    let H = oe;
    for (; i(H.children); )
      H = s(H.children);
    return H;
  }
  function U2(oe) {
    let H;
    if (oe.type === "html")
      H = oe.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
    else {
      let pe2;
      oe.type === "esComment" ? pe2 = oe : oe.type === "paragraph" && oe.children.length === 1 && oe.children[0].type === "esComment" && (pe2 = oe.children[0]), pe2 && (H = pe2.value.match(/^prettier-ignore(?:-(start|end))?$/));
    }
    return H ? H[1] || "next" : false;
  }
  function Z(oe, H) {
    let pe2 = H.parts.length === 0, X = k.includes(oe.type), le2 = oe.type === "html" && M2.includes(H.parentNode.type);
    return !pe2 && !X && !le2;
  }
  function se2(oe, H) {
    var pe2, X, le2;
    let Ee = (H.prevNode && H.prevNode.type) === oe.type && L.has(oe.type), De2 = H.parentNode.type === "listItem" && !H.parentNode.loose, A = ((pe2 = H.prevNode) === null || pe2 === void 0 ? void 0 : pe2.type) === "listItem" && H.prevNode.loose, G = U2(H.prevNode) === "next", re = oe.type === "html" && ((X = H.prevNode) === null || X === void 0 ? void 0 : X.type) === "html" && H.prevNode.position.end.line + 1 === oe.position.start.line, ye2 = oe.type === "html" && H.parentNode.type === "listItem" && ((le2 = H.prevNode) === null || le2 === void 0 ? void 0 : le2.type) === "paragraph" && H.prevNode.position.end.line + 1 === oe.position.start.line;
    return A || !(Ee || De2 || G || re || ye2);
  }
  function fe2(oe, H) {
    let pe2 = H.prevNode && H.prevNode.type === "list", X = oe.type === "code" && oe.isIndented;
    return pe2 && X;
  }
  function ge2(oe) {
    let H = ce2(oe, ["linkReference", "imageReference"]);
    return H && (H.type !== "linkReference" || H.referenceType !== "full");
  }
  function he2(oe) {
    let H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], pe2 = [" ", ...Array.isArray(H) ? H : [H]];
    return new RegExp(pe2.map((X) => `\\${X}`).join("|")).test(oe) ? `<${oe}>` : oe;
  }
  function we2(oe, H) {
    let pe2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    if (!oe)
      return "";
    if (pe2)
      return " " + we2(oe, H, false);
    if (oe = oe.replace(/\\(["')])/g, "$1"), oe.includes('"') && oe.includes("'") && !oe.includes(")"))
      return `(${oe})`;
    let X = oe.split("'").length - 1, le2 = oe.split('"').length - 1, Ae2 = X > le2 ? '"' : le2 > X || H.singleQuote ? "'" : '"';
    return oe = oe.replace(/\\/, "\\\\"), oe = oe.replace(new RegExp(`(${Ae2})`, "g"), "\\$1"), `${Ae2}${oe}${Ae2}`;
  }
  function ke2(oe, H, pe2) {
    return oe < H ? H : oe > pe2 ? pe2 : oe;
  }
  function Re2(oe) {
    let H = Number(oe.getName());
    if (H === 0)
      return false;
    let pe2 = oe.getParentNode().children[H - 1];
    return U2(pe2) === "next";
  }
  function Ne2(oe) {
    return `[${t(oe.label)}]`;
  }
  function Pe2(oe) {
    return `[^${oe.label}]`;
  }
  r.exports = { preprocess: o, print: Q, embed: D, massageAstNode: h, hasPrettierIgnore: Re2, insertPragma: T };
} }), ug = te$1({ "src/language-markdown/options.js"(e, r) {
  ne();
  var t = jt();
  r.exports = { proseWrap: t.proseWrap, singleQuote: t.singleQuote };
} }), sg = te$1({ "src/language-markdown/parsers.js"() {
  ne();
} }), Aa = te$1({ "node_modules/linguist-languages/data/Markdown.json"(e, r) {
  r.exports = { name: "Markdown", type: "prose", color: "#083fa1", aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: [".md", ".livemd", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"], filenames: ["contents.lr"], tmScope: "source.gfm", languageId: 222 };
} }), ig = te$1({ "src/language-markdown/index.js"(e, r) {
  ne();
  var t = wt$1(), s = ng(), a = ug(), n = sg(), u = [t(Aa(), (l) => ({ since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: [...l.filenames, "README"], extensions: l.extensions.filter((p) => p !== ".mdx") })), t(Aa(), () => ({ name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"] }))], i = { mdast: s };
  r.exports = { languages: u, options: a, printers: i, parsers: n };
} }), ag = te$1({ "src/language-html/clean.js"(e, r) {
  ne();
  var { isFrontMatterNode: t } = Ue$2(), s = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]);
  function a(n, u) {
    if (n.type === "text" || n.type === "comment" || t(n) || n.type === "yaml" || n.type === "toml")
      return null;
    n.type === "attribute" && delete u.value, n.type === "docType" && delete u.value;
  }
  a.ignoredProperties = s, r.exports = a;
} }), og = te$1({ "src/language-html/constants.evaluate.js"(e, r) {
  r.exports = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" };
} }), lg = te$1({ "src/language-html/utils/is-unknown-namespace.js"(e, r) {
  ne();
  function t(s) {
    return s.type === "element" && !s.hasExplicitNamespace && !["html", "svg"].includes(s.namespace);
  }
  r.exports = t;
} }), qt$1 = te$1({ "src/language-html/utils/index.js"(e, r) {
  ne();
  var { inferParserByLanguage: t, isFrontMatterNode: s } = Ue$2(), { builders: { line: a, hardline: n, join: u }, utils: { getDocParts: i, replaceTextEndOfLine: l } } = qe(), { CSS_DISPLAY_TAGS: p, CSS_DISPLAY_DEFAULT: d2, CSS_WHITE_SPACE_TAGS: y2, CSS_WHITE_SPACE_DEFAULT: g2 } = og(), c = lg(), f = /* @__PURE__ */ new Set(["	", `
`, "\f", "\r", " "]), E = (A) => A.replace(/^[\t\n\f\r ]+/, ""), _ = (A) => A.replace(/[\t\n\f\r ]+$/, ""), w = (A) => E(_(A)), F = (A) => A.replace(/^[\t\f\r ]*\n/g, ""), N2 = (A) => F(_(A)), x = (A) => A.split(/[\t\n\f\r ]+/), I2 = (A) => A.match(/^[\t\n\f\r ]*/)[0], P = (A) => {
    let [, G, re, ye2] = A.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
    return { leadingWhitespace: G, trailingWhitespace: ye2, text: re };
  }, $2 = (A) => /[\t\n\f\r ]/.test(A);
  function D(A, G) {
    return !!(A.type === "ieConditionalComment" && A.lastChild && !A.lastChild.isSelfClosing && !A.lastChild.endSourceSpan || A.type === "ieConditionalComment" && !A.complete || se2(A) && A.children.some((re) => re.type !== "text" && re.type !== "interpolation") || X(A, G) && !o(A) && A.type !== "interpolation");
  }
  function T(A) {
    return A.type === "attribute" || !A.parent || !A.prev ? false : m(A.prev);
  }
  function m(A) {
    return A.type === "comment" && A.value.trim() === "prettier-ignore";
  }
  function C(A) {
    return A.type === "text" || A.type === "comment";
  }
  function o(A) {
    return A.type === "element" && (A.fullName === "script" || A.fullName === "style" || A.fullName === "svg:style" || c(A) && (A.name === "script" || A.name === "style"));
  }
  function h(A) {
    return A.children && !o(A);
  }
  function v2(A) {
    return o(A) || A.type === "interpolation" || S(A);
  }
  function S(A) {
    return we2(A).startsWith("pre");
  }
  function b(A, G) {
    let re = ye2();
    if (re && !A.prev && A.parent && A.parent.tagDefinition && A.parent.tagDefinition.ignoreFirstLf)
      return A.type === "interpolation";
    return re;
    function ye2() {
      return s(A) ? false : (A.type === "text" || A.type === "interpolation") && A.prev && (A.prev.type === "text" || A.prev.type === "interpolation") ? true : !A.parent || A.parent.cssDisplay === "none" ? false : se2(A.parent) ? true : !(!A.prev && (A.parent.type === "root" || se2(A) && A.parent || o(A.parent) || H(A.parent, G) || !ue2(A.parent.cssDisplay)) || A.prev && !U2(A.prev.cssDisplay));
    }
  }
  function B(A, G) {
    return s(A) ? false : (A.type === "text" || A.type === "interpolation") && A.next && (A.next.type === "text" || A.next.type === "interpolation") ? true : !A.parent || A.parent.cssDisplay === "none" ? false : se2(A.parent) ? true : !(!A.next && (A.parent.type === "root" || se2(A) && A.parent || o(A.parent) || H(A.parent, G) || !Fe2(A.parent.cssDisplay)) || A.next && !z(A.next.cssDisplay));
  }
  function k(A) {
    return Z(A.cssDisplay) && !o(A);
  }
  function M2(A) {
    return s(A) || A.next && A.sourceSpan.end && A.sourceSpan.end.line + 1 < A.next.sourceSpan.start.line;
  }
  function R2(A) {
    return q(A) || A.type === "element" && A.children.length > 0 && (["body", "script", "style"].includes(A.name) || A.children.some((G) => ee2(G))) || A.firstChild && A.firstChild === A.lastChild && A.firstChild.type !== "text" && V(A.firstChild) && (!A.lastChild.isTrailingSpaceSensitive || j(A.lastChild));
  }
  function q(A) {
    return A.type === "element" && A.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(A.name) || A.cssDisplay.startsWith("table") && A.cssDisplay !== "table-cell");
  }
  function J(A) {
    return Y(A) || A.prev && L(A.prev) || Q(A);
  }
  function L(A) {
    return Y(A) || A.type === "element" && A.fullName === "br" || Q(A);
  }
  function Q(A) {
    return V(A) && j(A);
  }
  function V(A) {
    return A.hasLeadingSpaces && (A.prev ? A.prev.sourceSpan.end.line < A.sourceSpan.start.line : A.parent.type === "root" || A.parent.startSourceSpan.end.line < A.sourceSpan.start.line);
  }
  function j(A) {
    return A.hasTrailingSpaces && (A.next ? A.next.sourceSpan.start.line > A.sourceSpan.end.line : A.parent.type === "root" || A.parent.endSourceSpan && A.parent.endSourceSpan.start.line > A.sourceSpan.end.line);
  }
  function Y(A) {
    switch (A.type) {
      case "ieConditionalComment":
      case "comment":
      case "directive":
        return true;
      case "element":
        return ["script", "select"].includes(A.name);
    }
    return false;
  }
  function ie2(A) {
    return A.lastChild ? ie2(A.lastChild) : A;
  }
  function ee2(A) {
    return A.children && A.children.some((G) => G.type !== "text");
  }
  function ce2(A) {
    let { type: G, lang: re } = A.attrMap;
    if (G === "module" || G === "text/javascript" || G === "text/babel" || G === "application/javascript" || re === "jsx")
      return "babel";
    if (G === "application/x-typescript" || re === "ts" || re === "tsx")
      return "typescript";
    if (G === "text/markdown")
      return "markdown";
    if (G === "text/html")
      return "html";
    if (G && (G.endsWith("json") || G.endsWith("importmap")) || G === "speculationrules")
      return "json";
    if (G === "text/x-handlebars-template")
      return "glimmer";
  }
  function W(A, G) {
    let { lang: re } = A.attrMap;
    if (!re || re === "postcss" || re === "css")
      return "css";
    if (re === "scss")
      return "scss";
    if (re === "less")
      return "less";
    if (re === "stylus")
      return t("stylus", G);
  }
  function K2(A, G) {
    if (A.name === "script" && !A.attrMap.src)
      return !A.attrMap.lang && !A.attrMap.type ? "babel" : ce2(A);
    if (A.name === "style")
      return W(A, G);
    if (G && X(A, G))
      return ce2(A) || !("src" in A.attrMap) && t(A.attrMap.lang, G);
  }
  function de(A) {
    return A === "block" || A === "list-item" || A.startsWith("table");
  }
  function ue2(A) {
    return !de(A) && A !== "inline-block";
  }
  function Fe2(A) {
    return !de(A) && A !== "inline-block";
  }
  function z(A) {
    return !de(A);
  }
  function U2(A) {
    return !de(A);
  }
  function Z(A) {
    return !de(A) && A !== "inline-block";
  }
  function se2(A) {
    return we2(A).startsWith("pre");
  }
  function fe2(A, G) {
    let re = 0;
    for (let ye2 = A.stack.length - 1; ye2 >= 0; ye2--) {
      let Ce2 = A.stack[ye2];
      Ce2 && typeof Ce2 == "object" && !Array.isArray(Ce2) && G(Ce2) && re++;
    }
    return re;
  }
  function ge2(A, G) {
    let re = A;
    for (; re; ) {
      if (G(re))
        return true;
      re = re.parent;
    }
    return false;
  }
  function he2(A, G) {
    if (A.prev && A.prev.type === "comment") {
      let ye2 = A.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
      if (ye2)
        return ye2[1];
    }
    let re = false;
    if (A.type === "element" && A.namespace === "svg")
      if (ge2(A, (ye2) => ye2.fullName === "svg:foreignObject"))
        re = true;
      else
        return A.name === "svg" ? "inline-block" : "block";
    switch (G.htmlWhitespaceSensitivity) {
      case "strict":
        return "inline";
      case "ignore":
        return "block";
      default:
        return G.parser === "vue" && A.parent && A.parent.type === "root" ? "block" : A.type === "element" && (!A.namespace || re || c(A)) && p[A.name] || d2;
    }
  }
  function we2(A) {
    return A.type === "element" && (!A.namespace || c(A)) && y2[A.name] || g2;
  }
  function ke2(A) {
    let G = Number.POSITIVE_INFINITY;
    for (let re of A.split(`
`)) {
      if (re.length === 0)
        continue;
      if (!f.has(re[0]))
        return 0;
      let ye2 = I2(re).length;
      re.length !== ye2 && ye2 < G && (G = ye2);
    }
    return G === Number.POSITIVE_INFINITY ? 0 : G;
  }
  function Re2(A) {
    let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ke2(A);
    return G === 0 ? A : A.split(`
`).map((re) => re.slice(G)).join(`
`);
  }
  function Ne2(A, G) {
    let re = 0;
    for (let ye2 = 0; ye2 < A.length; ye2++)
      A[ye2] === G && re++;
    return re;
  }
  function Pe2(A) {
    return A.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
  }
  var oe = /* @__PURE__ */ new Set(["template", "style", "script"]);
  function H(A, G) {
    return pe2(A, G) && !oe.has(A.fullName);
  }
  function pe2(A, G) {
    return G.parser === "vue" && A.type === "element" && A.parent.type === "root" && A.fullName.toLowerCase() !== "html";
  }
  function X(A, G) {
    return pe2(A, G) && (H(A, G) || A.attrMap.lang && A.attrMap.lang !== "html");
  }
  function le2(A) {
    let G = A.fullName;
    return G.charAt(0) === "#" || G === "slot-scope" || G === "v-slot" || G.startsWith("v-slot:");
  }
  function Ae2(A, G) {
    let re = A.parent;
    if (!pe2(re, G))
      return false;
    let ye2 = re.fullName, Ce2 = A.fullName;
    return ye2 === "script" && Ce2 === "setup" || ye2 === "style" && Ce2 === "vars";
  }
  function Ee(A) {
    let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : A.value;
    return A.parent.isWhitespaceSensitive ? A.parent.isIndentationSensitive ? l(G) : l(Re2(N2(G)), n) : i(u(a, x(G)));
  }
  function De2(A, G) {
    return pe2(A, G) && A.name === "script";
  }
  r.exports = { htmlTrim: w, htmlTrimPreserveIndentation: N2, hasHtmlWhitespace: $2, getLeadingAndTrailingHtmlWhitespace: P, canHaveInterpolation: h, countChars: Ne2, countParents: fe2, dedentString: Re2, forceBreakChildren: q, forceBreakContent: R2, forceNextEmptyLine: M2, getLastDescendant: ie2, getNodeCssStyleDisplay: he2, getNodeCssStyleWhiteSpace: we2, hasPrettierIgnore: T, inferScriptParser: K2, isVueCustomBlock: H, isVueNonHtmlBlock: X, isVueScriptTag: De2, isVueSlotAttribute: le2, isVueSfcBindingsAttribute: Ae2, isVueSfcBlock: pe2, isDanglingSpaceSensitiveNode: k, isIndentationSensitiveNode: S, isLeadingSpaceSensitiveNode: b, isPreLikeNode: se2, isScriptLikeTag: o, isTextLikeNode: C, isTrailingSpaceSensitiveNode: B, isWhitespaceSensitiveNode: v2, isUnknownNamespace: c, preferHardlineAsLeadingSpaces: J, preferHardlineAsTrailingSpaces: L, shouldPreserveContent: D, unescapeQuoteEntities: Pe2, getTextValueParts: Ee };
} }), cg = te$1({ "node_modules/angular-html-parser/lib/compiler/src/chars.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true }), e.$EOF = 0, e.$BSPACE = 8, e.$TAB = 9, e.$LF = 10, e.$VTAB = 11, e.$FF = 12, e.$CR = 13, e.$SPACE = 32, e.$BANG = 33, e.$DQ = 34, e.$HASH = 35, e.$$ = 36, e.$PERCENT = 37, e.$AMPERSAND = 38, e.$SQ = 39, e.$LPAREN = 40, e.$RPAREN = 41, e.$STAR = 42, e.$PLUS = 43, e.$COMMA = 44, e.$MINUS = 45, e.$PERIOD = 46, e.$SLASH = 47, e.$COLON = 58, e.$SEMICOLON = 59, e.$LT = 60, e.$EQ = 61, e.$GT = 62, e.$QUESTION = 63, e.$0 = 48, e.$7 = 55, e.$9 = 57, e.$A = 65, e.$E = 69, e.$F = 70, e.$X = 88, e.$Z = 90, e.$LBRACKET = 91, e.$BACKSLASH = 92, e.$RBRACKET = 93, e.$CARET = 94, e.$_ = 95, e.$a = 97, e.$b = 98, e.$e = 101, e.$f = 102, e.$n = 110, e.$r = 114, e.$t = 116, e.$u = 117, e.$v = 118, e.$x = 120, e.$z = 122, e.$LBRACE = 123, e.$BAR = 124, e.$RBRACE = 125, e.$NBSP = 160, e.$PIPE = 124, e.$TILDA = 126, e.$AT = 64, e.$BT = 96;
  function r(i) {
    return i >= e.$TAB && i <= e.$SPACE || i == e.$NBSP;
  }
  e.isWhitespace = r;
  function t(i) {
    return e.$0 <= i && i <= e.$9;
  }
  e.isDigit = t;
  function s(i) {
    return i >= e.$a && i <= e.$z || i >= e.$A && i <= e.$Z;
  }
  e.isAsciiLetter = s;
  function a(i) {
    return i >= e.$a && i <= e.$f || i >= e.$A && i <= e.$F || t(i);
  }
  e.isAsciiHexDigit = a;
  function n(i) {
    return i === e.$LF || i === e.$CR;
  }
  e.isNewLine = n;
  function u(i) {
    return e.$0 <= i && i <= e.$7;
  }
  e.isOctalDigit = u;
} }), pg = te$1({ "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = class {
    constructor(s, a, n) {
      this.filePath = s, this.name = a, this.members = n;
    }
    assertNoMembers() {
      if (this.members.length)
        throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
    }
  };
  e.StaticSymbol = r;
  var t = class {
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
    }
    get(s, a, n) {
      n = n || [];
      let u = n.length ? `.${n.join(".")}` : "", i = `"${s}".${a}${u}`, l = this.cache.get(i);
      return l || (l = new r(s, a, n), this.cache.set(i, l)), l;
    }
  };
  e.StaticSymbolCache = t;
} }), fg = te$1({ "node_modules/angular-html-parser/lib/compiler/src/util.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = /-+([a-z0-9])/g;
  function t(o) {
    return o.replace(r, function() {
      for (var h = arguments.length, v2 = new Array(h), S = 0; S < h; S++)
        v2[S] = arguments[S];
      return v2[1].toUpperCase();
    });
  }
  e.dashCaseToCamelCase = t;
  function s(o, h) {
    return n(o, ":", h);
  }
  e.splitAtColon = s;
  function a(o, h) {
    return n(o, ".", h);
  }
  e.splitAtPeriod = a;
  function n(o, h, v2) {
    let S = o.indexOf(h);
    return S == -1 ? v2 : [o.slice(0, S).trim(), o.slice(S + 1).trim()];
  }
  function u(o, h, v2) {
    return Array.isArray(o) ? h.visitArray(o, v2) : F(o) ? h.visitStringMap(o, v2) : o == null || typeof o == "string" || typeof o == "number" || typeof o == "boolean" ? h.visitPrimitive(o, v2) : h.visitOther(o, v2);
  }
  e.visitValue = u;
  function i(o) {
    return o != null;
  }
  e.isDefined = i;
  function l(o) {
    return o === void 0 ? null : o;
  }
  e.noUndefined = l;
  var p = class {
    visitArray(o, h) {
      return o.map((v2) => u(v2, this, h));
    }
    visitStringMap(o, h) {
      let v2 = {};
      return Object.keys(o).forEach((S) => {
        v2[S] = u(o[S], this, h);
      }), v2;
    }
    visitPrimitive(o, h) {
      return o;
    }
    visitOther(o, h) {
      return o;
    }
  };
  e.ValueTransformer = p, e.SyncAsync = { assertSync: (o) => {
    if (P(o))
      throw new Error("Illegal state: value cannot be a promise");
    return o;
  }, then: (o, h) => P(o) ? o.then(h) : h(o), all: (o) => o.some(P) ? Promise.all(o) : o };
  function d2(o) {
    throw new Error(`Internal Error: ${o}`);
  }
  e.error = d2;
  function y2(o, h) {
    let v2 = Error(o);
    return v2[g2] = true, h && (v2[c] = h), v2;
  }
  e.syntaxError = y2;
  var g2 = "ngSyntaxError", c = "ngParseErrors";
  function f(o) {
    return o[g2];
  }
  e.isSyntaxError = f;
  function E(o) {
    return o[c] || [];
  }
  e.getParseErrors = E;
  function _(o) {
    return o.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
  }
  e.escapeRegExp = _;
  var w = Object.getPrototypeOf({});
  function F(o) {
    return typeof o == "object" && o !== null && Object.getPrototypeOf(o) === w;
  }
  function N2(o) {
    let h = "";
    for (let v2 = 0; v2 < o.length; v2++) {
      let S = o.charCodeAt(v2);
      if (S >= 55296 && S <= 56319 && o.length > v2 + 1) {
        let b = o.charCodeAt(v2 + 1);
        b >= 56320 && b <= 57343 && (v2++, S = (S - 55296 << 10) + b - 56320 + 65536);
      }
      S <= 127 ? h += String.fromCharCode(S) : S <= 2047 ? h += String.fromCharCode(S >> 6 & 31 | 192, S & 63 | 128) : S <= 65535 ? h += String.fromCharCode(S >> 12 | 224, S >> 6 & 63 | 128, S & 63 | 128) : S <= 2097151 && (h += String.fromCharCode(S >> 18 & 7 | 240, S >> 12 & 63 | 128, S >> 6 & 63 | 128, S & 63 | 128));
    }
    return h;
  }
  e.utf8Encode = N2;
  function x(o) {
    if (typeof o == "string")
      return o;
    if (o instanceof Array)
      return "[" + o.map(x).join(", ") + "]";
    if (o == null)
      return "" + o;
    if (o.overriddenName)
      return `${o.overriddenName}`;
    if (o.name)
      return `${o.name}`;
    if (!o.toString)
      return "object";
    let h = o.toString();
    if (h == null)
      return "" + h;
    let v2 = h.indexOf(`
`);
    return v2 === -1 ? h : h.substring(0, v2);
  }
  e.stringify = x;
  function I2(o) {
    return typeof o == "function" && o.hasOwnProperty("__forward_ref__") ? o() : o;
  }
  e.resolveForwardRef = I2;
  function P(o) {
    return !!o && typeof o.then == "function";
  }
  e.isPromise = P;
  var $2 = class {
    constructor(o) {
      this.full = o;
      let h = o.split(".");
      this.major = h[0], this.minor = h[1], this.patch = h.slice(2).join(".");
    }
  };
  e.Version = $2;
  var D = typeof window < "u" && window, T = typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self, m = typeof globalThis < "u" && globalThis, C = m || D || T;
  e.global = C;
} }), Dg = te$1({ "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = pg(), t = fg(), s = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
  function a(v2) {
    return v2.replace(/\W/g, "_");
  }
  e.sanitizeIdentifier = a;
  var n = 0;
  function u(v2) {
    if (!v2 || !v2.reference)
      return null;
    let S = v2.reference;
    if (S instanceof r.StaticSymbol)
      return S.name;
    if (S.__anonymousType)
      return S.__anonymousType;
    let b = t.stringify(S);
    return b.indexOf("(") >= 0 ? (b = `anonymous_${n++}`, S.__anonymousType = b) : b = a(b), b;
  }
  e.identifierName = u;
  function i(v2) {
    let S = v2.reference;
    return S instanceof r.StaticSymbol ? S.filePath : `./${t.stringify(S)}`;
  }
  e.identifierModuleUrl = i;
  function l(v2, S) {
    return `View_${u({ reference: v2 })}_${S}`;
  }
  e.viewClassName = l;
  function p(v2) {
    return `RenderType_${u({ reference: v2 })}`;
  }
  e.rendererTypeName = p;
  function d2(v2) {
    return `HostView_${u({ reference: v2 })}`;
  }
  e.hostViewClassName = d2;
  function y2(v2) {
    return `${u({ reference: v2 })}NgFactory`;
  }
  e.componentFactoryName = y2;
  var g2;
  (function(v2) {
    v2[v2.Pipe = 0] = "Pipe", v2[v2.Directive = 1] = "Directive", v2[v2.NgModule = 2] = "NgModule", v2[v2.Injectable = 3] = "Injectable";
  })(g2 = e.CompileSummaryKind || (e.CompileSummaryKind = {}));
  function c(v2) {
    return v2.value != null ? a(v2.value) : u(v2.identifier);
  }
  e.tokenName = c;
  function f(v2) {
    return v2.identifier != null ? v2.identifier.reference : v2.value;
  }
  e.tokenReference = f;
  var E = class {
    constructor() {
      let { moduleUrl: v2, styles: S, styleUrls: b } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.moduleUrl = v2 || null, this.styles = P(S), this.styleUrls = P(b);
    }
  };
  e.CompileStylesheetMetadata = E;
  var _ = class {
    constructor(v2) {
      let { encapsulation: S, template: b, templateUrl: B, htmlAst: k, styles: M2, styleUrls: R2, externalStylesheets: q, animations: J, ngContentSelectors: L, interpolation: Q, isInline: V, preserveWhitespaces: j } = v2;
      if (this.encapsulation = S, this.template = b, this.templateUrl = B, this.htmlAst = k, this.styles = P(M2), this.styleUrls = P(R2), this.externalStylesheets = P(q), this.animations = J ? D(J) : [], this.ngContentSelectors = L || [], Q && Q.length != 2)
        throw new Error("'interpolation' should have a start and an end symbol.");
      this.interpolation = Q, this.isInline = V, this.preserveWhitespaces = j;
    }
    toSummary() {
      return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
    }
  };
  e.CompileTemplateMetadata = _;
  var w = class {
    static create(v2) {
      let { isHost: S, type: b, isComponent: B, selector: k, exportAs: M2, changeDetection: R2, inputs: q, outputs: J, host: L, providers: Q, viewProviders: V, queries: j, guards: Y, viewQueries: ie2, entryComponents: ee2, template: ce2, componentViewType: W, rendererType: K2, componentFactory: de } = v2, ue2 = {}, Fe2 = {}, z = {};
      L != null && Object.keys(L).forEach((se2) => {
        let fe2 = L[se2], ge2 = se2.match(s);
        ge2 === null ? z[se2] = fe2 : ge2[1] != null ? Fe2[ge2[1]] = fe2 : ge2[2] != null && (ue2[ge2[2]] = fe2);
      });
      let U2 = {};
      q != null && q.forEach((se2) => {
        let fe2 = t.splitAtColon(se2, [se2, se2]);
        U2[fe2[0]] = fe2[1];
      });
      let Z = {};
      return J != null && J.forEach((se2) => {
        let fe2 = t.splitAtColon(se2, [se2, se2]);
        Z[fe2[0]] = fe2[1];
      }), new w({ isHost: S, type: b, isComponent: !!B, selector: k, exportAs: M2, changeDetection: R2, inputs: U2, outputs: Z, hostListeners: ue2, hostProperties: Fe2, hostAttributes: z, providers: Q, viewProviders: V, queries: j, guards: Y, viewQueries: ie2, entryComponents: ee2, template: ce2, componentViewType: W, rendererType: K2, componentFactory: de });
    }
    constructor(v2) {
      let { isHost: S, type: b, isComponent: B, selector: k, exportAs: M2, changeDetection: R2, inputs: q, outputs: J, hostListeners: L, hostProperties: Q, hostAttributes: V, providers: j, viewProviders: Y, queries: ie2, guards: ee2, viewQueries: ce2, entryComponents: W, template: K2, componentViewType: de, rendererType: ue2, componentFactory: Fe2 } = v2;
      this.isHost = !!S, this.type = b, this.isComponent = B, this.selector = k, this.exportAs = M2, this.changeDetection = R2, this.inputs = q, this.outputs = J, this.hostListeners = L, this.hostProperties = Q, this.hostAttributes = V, this.providers = P(j), this.viewProviders = P(Y), this.queries = P(ie2), this.guards = ee2, this.viewQueries = P(ce2), this.entryComponents = P(W), this.template = K2, this.componentViewType = de, this.rendererType = ue2, this.componentFactory = Fe2;
    }
    toSummary() {
      return { summaryKind: g2.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
    }
  };
  e.CompileDirectiveMetadata = w;
  var F = class {
    constructor(v2) {
      let { type: S, name: b, pure: B } = v2;
      this.type = S, this.name = b, this.pure = !!B;
    }
    toSummary() {
      return { summaryKind: g2.Pipe, type: this.type, name: this.name, pure: this.pure };
    }
  };
  e.CompilePipeMetadata = F;
  var N2 = class {
  };
  e.CompileShallowModuleMetadata = N2;
  var x = class {
    constructor(v2) {
      let { type: S, providers: b, declaredDirectives: B, exportedDirectives: k, declaredPipes: M2, exportedPipes: R2, entryComponents: q, bootstrapComponents: J, importedModules: L, exportedModules: Q, schemas: V, transitiveModule: j, id: Y } = v2;
      this.type = S || null, this.declaredDirectives = P(B), this.exportedDirectives = P(k), this.declaredPipes = P(M2), this.exportedPipes = P(R2), this.providers = P(b), this.entryComponents = P(q), this.bootstrapComponents = P(J), this.importedModules = P(L), this.exportedModules = P(Q), this.schemas = P(V), this.id = Y || null, this.transitiveModule = j || null;
    }
    toSummary() {
      let v2 = this.transitiveModule;
      return { summaryKind: g2.NgModule, type: this.type, entryComponents: v2.entryComponents, providers: v2.providers, modules: v2.modules, exportedDirectives: v2.exportedDirectives, exportedPipes: v2.exportedPipes };
    }
  };
  e.CompileNgModuleMetadata = x;
  var I2 = class {
    constructor() {
      this.directivesSet = /* @__PURE__ */ new Set(), this.directives = [], this.exportedDirectivesSet = /* @__PURE__ */ new Set(), this.exportedDirectives = [], this.pipesSet = /* @__PURE__ */ new Set(), this.pipes = [], this.exportedPipesSet = /* @__PURE__ */ new Set(), this.exportedPipes = [], this.modulesSet = /* @__PURE__ */ new Set(), this.modules = [], this.entryComponentsSet = /* @__PURE__ */ new Set(), this.entryComponents = [], this.providers = [];
    }
    addProvider(v2, S) {
      this.providers.push({ provider: v2, module: S });
    }
    addDirective(v2) {
      this.directivesSet.has(v2.reference) || (this.directivesSet.add(v2.reference), this.directives.push(v2));
    }
    addExportedDirective(v2) {
      this.exportedDirectivesSet.has(v2.reference) || (this.exportedDirectivesSet.add(v2.reference), this.exportedDirectives.push(v2));
    }
    addPipe(v2) {
      this.pipesSet.has(v2.reference) || (this.pipesSet.add(v2.reference), this.pipes.push(v2));
    }
    addExportedPipe(v2) {
      this.exportedPipesSet.has(v2.reference) || (this.exportedPipesSet.add(v2.reference), this.exportedPipes.push(v2));
    }
    addModule(v2) {
      this.modulesSet.has(v2.reference) || (this.modulesSet.add(v2.reference), this.modules.push(v2));
    }
    addEntryComponent(v2) {
      this.entryComponentsSet.has(v2.componentType) || (this.entryComponentsSet.add(v2.componentType), this.entryComponents.push(v2));
    }
  };
  e.TransitiveCompileNgModuleMetadata = I2;
  function P(v2) {
    return v2 || [];
  }
  var $2 = class {
    constructor(v2, S) {
      let { useClass: b, useValue: B, useExisting: k, useFactory: M2, deps: R2, multi: q } = S;
      this.token = v2, this.useClass = b || null, this.useValue = B, this.useExisting = k, this.useFactory = M2 || null, this.dependencies = R2 || null, this.multi = !!q;
    }
  };
  e.ProviderMeta = $2;
  function D(v2) {
    return v2.reduce((S, b) => {
      let B = Array.isArray(b) ? D(b) : b;
      return S.concat(B);
    }, []);
  }
  e.flatten = D;
  function T(v2) {
    return v2.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
  }
  function m(v2, S, b) {
    let B;
    return b.isInline ? S.type.reference instanceof r.StaticSymbol ? B = `${S.type.reference.filePath}.${S.type.reference.name}.html` : B = `${u(v2)}/${u(S.type)}.html` : B = b.templateUrl, S.type.reference instanceof r.StaticSymbol ? B : T(B);
  }
  e.templateSourceUrl = m;
  function C(v2, S) {
    let b = v2.moduleUrl.split(/\/\\/g), B = b[b.length - 1];
    return T(`css/${S}${B}.ngstyle.js`);
  }
  e.sharedStylesheetJitUrl = C;
  function o(v2) {
    return T(`${u(v2.type)}/module.ngfactory.js`);
  }
  e.ngModuleJitUrl = o;
  function h(v2, S) {
    return T(`${u(v2)}/${u(S.type)}.ngfactory.js`);
  }
  e.templateJitUrl = h;
} }), mg = te$1({ "node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(e) {
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = cg(), t = Dg(), s = class {
    constructor(d2, y2, g2, c) {
      this.file = d2, this.offset = y2, this.line = g2, this.col = c;
    }
    toString() {
      return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
    }
    moveBy(d2) {
      let y2 = this.file.content, g2 = y2.length, c = this.offset, f = this.line, E = this.col;
      for (; c > 0 && d2 < 0; )
        if (c--, d2++, y2.charCodeAt(c) == r.$LF) {
          f--;
          let w = y2.substr(0, c - 1).lastIndexOf(String.fromCharCode(r.$LF));
          E = w > 0 ? c - w : c;
        } else
          E--;
      for (; c < g2 && d2 > 0; ) {
        let _ = y2.charCodeAt(c);
        c++, d2--, _ == r.$LF ? (f++, E = 0) : E++;
      }
      return new s(this.file, c, f, E);
    }
    getContext(d2, y2) {
      let g2 = this.file.content, c = this.offset;
      if (c != null) {
        c > g2.length - 1 && (c = g2.length - 1);
        let f = c, E = 0, _ = 0;
        for (; E < d2 && c > 0 && (c--, E++, !(g2[c] == `
` && ++_ == y2)); )
          ;
        for (E = 0, _ = 0; E < d2 && f < g2.length - 1 && (f++, E++, !(g2[f] == `
` && ++_ == y2)); )
          ;
        return { before: g2.substring(c, this.offset), after: g2.substring(this.offset, f + 1) };
      }
      return null;
    }
  };
  e.ParseLocation = s;
  var a = class {
    constructor(d2, y2) {
      this.content = d2, this.url = y2;
    }
  };
  e.ParseSourceFile = a;
  var n = class {
    constructor(d2, y2) {
      let g2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      this.start = d2, this.end = y2, this.details = g2;
    }
    toString() {
      return this.start.file.content.substring(this.start.offset, this.end.offset);
    }
  };
  e.ParseSourceSpan = n, e.EMPTY_PARSE_LOCATION = new s(new a("", ""), 0, 0, 0), e.EMPTY_SOURCE_SPAN = new n(e.EMPTY_PARSE_LOCATION, e.EMPTY_PARSE_LOCATION);
  var u;
  (function(d2) {
    d2[d2.WARNING = 0] = "WARNING", d2[d2.ERROR = 1] = "ERROR";
  })(u = e.ParseErrorLevel || (e.ParseErrorLevel = {}));
  var i = class {
    constructor(d2, y2) {
      let g2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : u.ERROR;
      this.span = d2, this.msg = y2, this.level = g2;
    }
    contextualMessage() {
      let d2 = this.span.start.getContext(100, 3);
      return d2 ? `${this.msg} ("${d2.before}[${u[this.level]} ->]${d2.after}")` : this.msg;
    }
    toString() {
      let d2 = this.span.details ? `, ${this.span.details}` : "";
      return `${this.contextualMessage()}: ${this.span.start}${d2}`;
    }
  };
  e.ParseError = i;
  function l(d2, y2) {
    let g2 = t.identifierModuleUrl(y2), c = g2 != null ? `in ${d2} ${t.identifierName(y2)} in ${g2}` : `in ${d2} ${t.identifierName(y2)}`, f = new a("", c);
    return new n(new s(f, -1, -1, -1), new s(f, -1, -1, -1));
  }
  e.typeSourceSpan = l;
  function p(d2, y2, g2) {
    let c = `in ${d2} ${y2} in ${g2}`, f = new a("", c);
    return new n(new s(f, -1, -1, -1), new s(f, -1, -1, -1));
  }
  e.r3JitTypeSourceSpan = p;
} }), dg = te$1({ "src/language-html/print-preprocess.js"(e, r) {
  ne();
  var { ParseSourceSpan: t } = mg(), { htmlTrim: s, getLeadingAndTrailingHtmlWhitespace: a, hasHtmlWhitespace: n, canHaveInterpolation: u, getNodeCssStyleDisplay: i, isDanglingSpaceSensitiveNode: l, isIndentationSensitiveNode: p, isLeadingSpaceSensitiveNode: d2, isTrailingSpaceSensitiveNode: y2, isWhitespaceSensitiveNode: g2, isVueScriptTag: c } = qt$1(), f = [_, w, N2, I2, P, T, $2, D, m, x, C];
  function E(o, h) {
    for (let v2 of f)
      v2(o, h);
    return o;
  }
  function _(o) {
    o.walk((h) => {
      if (h.type === "element" && h.tagDefinition.ignoreFirstLf && h.children.length > 0 && h.children[0].type === "text" && h.children[0].value[0] === `
`) {
        let v2 = h.children[0];
        v2.value.length === 1 ? h.removeChild(v2) : v2.value = v2.value.slice(1);
      }
    });
  }
  function w(o) {
    let h = (v2) => v2.type === "element" && v2.prev && v2.prev.type === "ieConditionalStartComment" && v2.prev.sourceSpan.end.offset === v2.startSourceSpan.start.offset && v2.firstChild && v2.firstChild.type === "ieConditionalEndComment" && v2.firstChild.sourceSpan.start.offset === v2.startSourceSpan.end.offset;
    o.walk((v2) => {
      if (v2.children)
        for (let S = 0; S < v2.children.length; S++) {
          let b = v2.children[S];
          if (!h(b))
            continue;
          let B = b.prev, k = b.firstChild;
          v2.removeChild(B), S--;
          let M2 = new t(B.sourceSpan.start, k.sourceSpan.end), R2 = new t(M2.start, b.sourceSpan.end);
          b.condition = B.condition, b.sourceSpan = R2, b.startSourceSpan = M2, b.removeChild(k);
        }
    });
  }
  function F(o, h, v2) {
    o.walk((S) => {
      if (S.children)
        for (let b = 0; b < S.children.length; b++) {
          let B = S.children[b];
          if (B.type !== "text" && !h(B))
            continue;
          B.type !== "text" && (B.type = "text", B.value = v2(B));
          let k = B.prev;
          !k || k.type !== "text" || (k.value += B.value, k.sourceSpan = new t(k.sourceSpan.start, B.sourceSpan.end), S.removeChild(B), b--);
        }
    });
  }
  function N2(o) {
    return F(o, (h) => h.type === "cdata", (h) => `<![CDATA[${h.value}]]>`);
  }
  function x(o) {
    let h = (v2) => v2.type === "element" && v2.attrs.length === 0 && v2.children.length === 1 && v2.firstChild.type === "text" && !n(v2.children[0].value) && !v2.firstChild.hasLeadingSpaces && !v2.firstChild.hasTrailingSpaces && v2.isLeadingSpaceSensitive && !v2.hasLeadingSpaces && v2.isTrailingSpaceSensitive && !v2.hasTrailingSpaces && v2.prev && v2.prev.type === "text" && v2.next && v2.next.type === "text";
    o.walk((v2) => {
      if (v2.children)
        for (let S = 0; S < v2.children.length; S++) {
          let b = v2.children[S];
          if (!h(b))
            continue;
          let B = b.prev, k = b.next;
          B.value += `<${b.rawName}>` + b.firstChild.value + `</${b.rawName}>` + k.value, B.sourceSpan = new t(B.sourceSpan.start, k.sourceSpan.end), B.isTrailingSpaceSensitive = k.isTrailingSpaceSensitive, B.hasTrailingSpaces = k.hasTrailingSpaces, v2.removeChild(b), S--, v2.removeChild(k);
        }
    });
  }
  function I2(o, h) {
    if (h.parser === "html")
      return;
    let v2 = /{{(.+?)}}/s;
    o.walk((S) => {
      if (u(S))
        for (let b of S.children) {
          if (b.type !== "text")
            continue;
          let B = b.sourceSpan.start, k = null, M2 = b.value.split(v2);
          for (let R2 = 0; R2 < M2.length; R2++, B = k) {
            let q = M2[R2];
            if (R2 % 2 === 0) {
              k = B.moveBy(q.length), q.length > 0 && S.insertChildBefore(b, { type: "text", value: q, sourceSpan: new t(B, k) });
              continue;
            }
            k = B.moveBy(q.length + 4), S.insertChildBefore(b, { type: "interpolation", sourceSpan: new t(B, k), children: q.length === 0 ? [] : [{ type: "text", value: q, sourceSpan: new t(B.moveBy(2), k.moveBy(-2)) }] });
          }
          S.removeChild(b);
        }
    });
  }
  function P(o) {
    o.walk((h) => {
      if (!h.children)
        return;
      if (h.children.length === 0 || h.children.length === 1 && h.children[0].type === "text" && s(h.children[0].value).length === 0) {
        h.hasDanglingSpaces = h.children.length > 0, h.children = [];
        return;
      }
      let v2 = g2(h), S = p(h);
      if (!v2)
        for (let b = 0; b < h.children.length; b++) {
          let B = h.children[b];
          if (B.type !== "text")
            continue;
          let { leadingWhitespace: k, text: M2, trailingWhitespace: R2 } = a(B.value), q = B.prev, J = B.next;
          M2 ? (B.value = M2, B.sourceSpan = new t(B.sourceSpan.start.moveBy(k.length), B.sourceSpan.end.moveBy(-R2.length)), k && (q && (q.hasTrailingSpaces = true), B.hasLeadingSpaces = true), R2 && (B.hasTrailingSpaces = true, J && (J.hasLeadingSpaces = true))) : (h.removeChild(B), b--, (k || R2) && (q && (q.hasTrailingSpaces = true), J && (J.hasLeadingSpaces = true)));
        }
      h.isWhitespaceSensitive = v2, h.isIndentationSensitive = S;
    });
  }
  function $2(o) {
    o.walk((h) => {
      h.isSelfClosing = !h.children || h.type === "element" && (h.tagDefinition.isVoid || h.startSourceSpan === h.endSourceSpan);
    });
  }
  function D(o, h) {
    o.walk((v2) => {
      v2.type === "element" && (v2.hasHtmComponentClosingTag = v2.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(h.originalText.slice(v2.endSourceSpan.start.offset, v2.endSourceSpan.end.offset)));
    });
  }
  function T(o, h) {
    o.walk((v2) => {
      v2.cssDisplay = i(v2, h);
    });
  }
  function m(o, h) {
    o.walk((v2) => {
      let { children: S } = v2;
      if (S) {
        if (S.length === 0) {
          v2.isDanglingSpaceSensitive = l(v2);
          return;
        }
        for (let b of S)
          b.isLeadingSpaceSensitive = d2(b, h), b.isTrailingSpaceSensitive = y2(b, h);
        for (let b = 0; b < S.length; b++) {
          let B = S[b];
          B.isLeadingSpaceSensitive = (b === 0 || B.prev.isTrailingSpaceSensitive) && B.isLeadingSpaceSensitive, B.isTrailingSpaceSensitive = (b === S.length - 1 || B.next.isLeadingSpaceSensitive) && B.isTrailingSpaceSensitive;
        }
      }
    });
  }
  function C(o, h) {
    if (h.parser === "vue") {
      let v2 = o.children.find((b) => c(b, h));
      if (!v2)
        return;
      let { lang: S } = v2.attrMap;
      (S === "ts" || S === "typescript") && (h.__should_parse_vue_template_with_ts = true);
    }
  }
  r.exports = E;
} }), gg = te$1({ "src/language-html/pragma.js"(e, r) {
  ne();
  function t(a) {
    return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(a);
  }
  function s(a) {
    return `<!-- @format -->

` + a.replace(/^\s*\n/, "");
  }
  r.exports = { hasPragma: t, insertPragma: s };
} }), uu$1 = te$1({ "src/language-html/loc.js"(e, r) {
  ne();
  function t(a) {
    return a.sourceSpan.start.offset;
  }
  function s(a) {
    return a.sourceSpan.end.offset;
  }
  r.exports = { locStart: t, locEnd: s };
} }), rr$1 = te$1({ "src/language-html/print/tag.js"(e, r) {
  ne();
  var t = Yt$1(), { isNonEmptyArray: s } = Ue$2(), { builders: { indent: a, join: n, line: u, softline: i, hardline: l }, utils: { replaceTextEndOfLine: p } } = qe(), { locStart: d2, locEnd: y2 } = uu$1(), { isTextLikeNode: g2, getLastDescendant: c, isPreLikeNode: f, hasPrettierIgnore: E, shouldPreserveContent: _, isVueSfcBlock: w } = qt$1();
  function F(L, Q) {
    return [L.isSelfClosing ? "" : N2(L, Q), x(L, Q)];
  }
  function N2(L, Q) {
    return L.lastChild && o(L.lastChild) ? "" : [I2(L, Q), $2(L, Q)];
  }
  function x(L, Q) {
    return (L.next ? m(L.next) : C(L.parent)) ? "" : [D(L, Q), P(L, Q)];
  }
  function I2(L, Q) {
    return C(L) ? D(L.lastChild, Q) : "";
  }
  function P(L, Q) {
    return o(L) ? $2(L.parent, Q) : h(L) ? q(L.next) : "";
  }
  function $2(L, Q) {
    if (t(!L.isSelfClosing), T(L, Q))
      return "";
    switch (L.type) {
      case "ieConditionalComment":
        return "<!";
      case "element":
        if (L.hasHtmComponentClosingTag)
          return "<//";
      default:
        return `</${L.rawName}`;
    }
  }
  function D(L, Q) {
    if (T(L, Q))
      return "";
    switch (L.type) {
      case "ieConditionalComment":
      case "ieConditionalEndComment":
        return "[endif]-->";
      case "ieConditionalStartComment":
        return "]><!-->";
      case "interpolation":
        return "}}";
      case "element":
        if (L.isSelfClosing)
          return "/>";
      default:
        return ">";
    }
  }
  function T(L, Q) {
    return !L.isSelfClosing && !L.endSourceSpan && (E(L) || _(L.parent, Q));
  }
  function m(L) {
    return L.prev && L.prev.type !== "docType" && !g2(L.prev) && L.isLeadingSpaceSensitive && !L.hasLeadingSpaces;
  }
  function C(L) {
    return L.lastChild && L.lastChild.isTrailingSpaceSensitive && !L.lastChild.hasTrailingSpaces && !g2(c(L.lastChild)) && !f(L);
  }
  function o(L) {
    return !L.next && !L.hasTrailingSpaces && L.isTrailingSpaceSensitive && g2(c(L));
  }
  function h(L) {
    return L.next && !g2(L.next) && g2(L) && L.isTrailingSpaceSensitive && !L.hasTrailingSpaces;
  }
  function v2(L) {
    let Q = L.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
    return Q ? Q[1] ? Q[1].split(/\s+/) : true : false;
  }
  function S(L) {
    return !L.prev && L.isLeadingSpaceSensitive && !L.hasLeadingSpaces;
  }
  function b(L, Q, V) {
    let j = L.getValue();
    if (!s(j.attrs))
      return j.isSelfClosing ? " " : "";
    let Y = j.prev && j.prev.type === "comment" && v2(j.prev.value), ie2 = typeof Y == "boolean" ? () => Y : Array.isArray(Y) ? (ue2) => Y.includes(ue2.rawName) : () => false, ee2 = L.map((ue2) => {
      let Fe2 = ue2.getValue();
      return ie2(Fe2) ? p(Q.originalText.slice(d2(Fe2), y2(Fe2))) : V();
    }, "attrs"), ce2 = j.type === "element" && j.fullName === "script" && j.attrs.length === 1 && j.attrs[0].fullName === "src" && j.children.length === 0, K2 = Q.singleAttributePerLine && j.attrs.length > 1 && !w(j, Q) ? l : u, de = [a([ce2 ? " " : u, n(K2, ee2)])];
    return j.firstChild && S(j.firstChild) || j.isSelfClosing && C(j.parent) || ce2 ? de.push(j.isSelfClosing ? " " : "") : de.push(Q.bracketSameLine ? j.isSelfClosing ? " " : "" : j.isSelfClosing ? u : i), de;
  }
  function B(L) {
    return L.firstChild && S(L.firstChild) ? "" : J(L);
  }
  function k(L, Q, V) {
    let j = L.getValue();
    return [M2(j, Q), b(L, Q, V), j.isSelfClosing ? "" : B(j)];
  }
  function M2(L, Q) {
    return L.prev && h(L.prev) ? "" : [R2(L, Q), q(L)];
  }
  function R2(L, Q) {
    return S(L) ? J(L.parent) : m(L) ? D(L.prev, Q) : "";
  }
  function q(L) {
    switch (L.type) {
      case "ieConditionalComment":
      case "ieConditionalStartComment":
        return `<!--[if ${L.condition}`;
      case "ieConditionalEndComment":
        return "<!--<!";
      case "interpolation":
        return "{{";
      case "docType":
        return "<!DOCTYPE";
      case "element":
        if (L.condition)
          return `<!--[if ${L.condition}]><!--><${L.rawName}`;
      default:
        return `<${L.rawName}`;
    }
  }
  function J(L) {
    switch (t(!L.isSelfClosing), L.type) {
      case "ieConditionalComment":
        return "]>";
      case "element":
        if (L.condition)
          return "><!--<![endif]-->";
      default:
        return ">";
    }
  }
  r.exports = { printClosingTag: F, printClosingTagStart: N2, printClosingTagStartMarker: $2, printClosingTagEndMarker: D, printClosingTagSuffix: P, printClosingTagEnd: x, needsToBorrowLastChildClosingTagEndMarker: C, needsToBorrowParentClosingTagStartMarker: o, needsToBorrowPrevClosingTagEndMarker: m, printOpeningTag: k, printOpeningTagStart: M2, printOpeningTagPrefix: R2, printOpeningTagStartMarker: q, printOpeningTagEndMarker: J, needsToBorrowNextOpeningTagStartMarker: h, needsToBorrowParentOpeningTagEndMarker: S };
} }), yg = te$1({ "node_modules/parse-srcset/src/parse-srcset.js"(e, r) {
  ne(), function(t, s) {
    typeof define == "function" && define.amd ? define([], s) : typeof r == "object" && r.exports ? r.exports = s() : t.parseSrcset = s();
  }(e, function() {
    return function(t, s) {
      var a = s && s.logger || console;
      function n($2) {
        return $2 === " " || $2 === "	" || $2 === `
` || $2 === "\f" || $2 === "\r";
      }
      function u($2) {
        var D, T = $2.exec(t.substring(N2));
        if (T)
          return D = T[0], N2 += D.length, D;
      }
      for (var i = t.length, l = /^[ \t\n\r\u000c]+/, p = /^[, \t\n\r\u000c]+/, d2 = /^[^ \t\n\r\u000c]+/, y2 = /[,]+$/, g2 = /^\d+$/, c = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, f, E, _, w, F, N2 = 0, x = []; ; ) {
        if (u(p), N2 >= i)
          return x;
        f = u(d2), E = [], f.slice(-1) === "," ? (f = f.replace(y2, ""), P()) : I2();
      }
      function I2() {
        for (u(l), _ = "", w = "in descriptor"; ; ) {
          if (F = t.charAt(N2), w === "in descriptor")
            if (n(F))
              _ && (E.push(_), _ = "", w = "after descriptor");
            else if (F === ",") {
              N2 += 1, _ && E.push(_), P();
              return;
            } else if (F === "(")
              _ = _ + F, w = "in parens";
            else if (F === "") {
              _ && E.push(_), P();
              return;
            } else
              _ = _ + F;
          else if (w === "in parens")
            if (F === ")")
              _ = _ + F, w = "in descriptor";
            else if (F === "") {
              E.push(_), P();
              return;
            } else
              _ = _ + F;
          else if (w === "after descriptor" && !n(F))
            if (F === "") {
              P();
              return;
            } else
              w = "in descriptor", N2 -= 1;
          N2 += 1;
        }
      }
      function P() {
        var $2 = false, D, T, m, C, o = {}, h, v2, S, b, B;
        for (C = 0; C < E.length; C++)
          h = E[C], v2 = h[h.length - 1], S = h.substring(0, h.length - 1), b = parseInt(S, 10), B = parseFloat(S), g2.test(S) && v2 === "w" ? ((D || T) && ($2 = true), b === 0 ? $2 = true : D = b) : c.test(S) && v2 === "x" ? ((D || T || m) && ($2 = true), B < 0 ? $2 = true : T = B) : g2.test(S) && v2 === "h" ? ((m || T) && ($2 = true), b === 0 ? $2 = true : m = b) : $2 = true;
        $2 ? a && a.error && a.error("Invalid srcset descriptor found in '" + t + "' at '" + h + "'.") : (o.url = f, D && (o.w = D), T && (o.d = T), m && (o.h = m), x.push(o));
      }
    };
  });
} }), hg = te$1({ "src/language-html/syntax-attribute.js"(e, r) {
  ne();
  var t = yg(), { builders: { ifBreak: s, join: a, line: n } } = qe();
  function u(l) {
    let p = t(l, { logger: { error(I2) {
      throw new Error(I2);
    } } }), d2 = p.some((I2) => {
      let { w: P } = I2;
      return P;
    }), y2 = p.some((I2) => {
      let { h: P } = I2;
      return P;
    }), g2 = p.some((I2) => {
      let { d: P } = I2;
      return P;
    });
    if (d2 + y2 + g2 > 1)
      throw new Error("Mixed descriptor in srcset is not supported");
    let c = d2 ? "w" : y2 ? "h" : "d", f = d2 ? "w" : y2 ? "h" : "x", E = (I2) => Math.max(...I2), _ = p.map((I2) => I2.url), w = E(_.map((I2) => I2.length)), F = p.map((I2) => I2[c]).map((I2) => I2 ? I2.toString() : ""), N2 = F.map((I2) => {
      let P = I2.indexOf(".");
      return P === -1 ? I2.length : P;
    }), x = E(N2);
    return a([",", n], _.map((I2, P) => {
      let $2 = [I2], D = F[P];
      if (D) {
        let T = w - I2.length + 1, m = x - N2[P], C = " ".repeat(T + m);
        $2.push(s(C, " "), D + f);
      }
      return $2;
    }));
  }
  function i(l) {
    return l.trim().split(/\s+/).join(" ");
  }
  r.exports = { printImgSrcset: u, printClassNames: i };
} }), vg = te$1({ "src/language-html/syntax-vue.js"(e, r) {
  ne();
  var { builders: { group: t } } = qe();
  function s(i, l) {
    let { left: p, operator: d2, right: y2 } = a(i);
    return [t(l(`function _(${p}) {}`, { parser: "babel", __isVueForBindingLeft: true })), " ", d2, " ", l(y2, { parser: "__js_expression" }, { stripTrailingHardline: true })];
  }
  function a(i) {
    let l = /(.*?)\s+(in|of)\s+(.*)/s, p = /,([^,\]}]*)(?:,([^,\]}]*))?$/, d2 = /^\(|\)$/g, y2 = i.match(l);
    if (!y2)
      return;
    let g2 = {};
    if (g2.for = y2[3].trim(), !g2.for)
      return;
    let c = y2[1].trim().replace(d2, ""), f = c.match(p);
    f ? (g2.alias = c.replace(p, ""), g2.iterator1 = f[1].trim(), f[2] && (g2.iterator2 = f[2].trim())) : g2.alias = c;
    let E = [g2.alias, g2.iterator1, g2.iterator2];
    if (!E.some((_, w) => !_ && (w === 0 || E.slice(w + 1).some(Boolean))))
      return { left: E.filter(Boolean).join(","), operator: y2[2], right: g2.for };
  }
  function n(i, l) {
    return l(`function _(${i}) {}`, { parser: "babel", __isVueBindings: true });
  }
  function u(i) {
    let l = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/, p = /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/, d2 = i.trim();
    return l.test(d2) || p.test(d2);
  }
  r.exports = { isVueEventBindingExpression: u, printVueFor: s, printVueBindings: n };
} }), To$2 = te$1({ "src/language-html/get-node-content.js"(e, r) {
  ne();
  var { needsToBorrowParentClosingTagStartMarker: t, printClosingTagStartMarker: s, needsToBorrowLastChildClosingTagEndMarker: a, printClosingTagEndMarker: n, needsToBorrowParentOpeningTagEndMarker: u, printOpeningTagEndMarker: i } = rr$1();
  function l(p, d2) {
    let y2 = p.startSourceSpan.end.offset;
    p.firstChild && u(p.firstChild) && (y2 -= i(p).length);
    let g2 = p.endSourceSpan.start.offset;
    return p.lastChild && t(p.lastChild) ? g2 += s(p, d2).length : a(p) && (g2 -= n(p.lastChild, d2).length), d2.originalText.slice(y2, g2);
  }
  r.exports = l;
} }), Cg = te$1({ "src/language-html/embed.js"(e, r) {
  ne();
  var { builders: { breakParent: t, group: s, hardline: a, indent: n, line: u, fill: i, softline: l }, utils: { mapDoc: p, replaceTextEndOfLine: d2 } } = qe(), y2 = ru(), { printClosingTag: g2, printClosingTagSuffix: c, needsToBorrowPrevClosingTagEndMarker: f, printOpeningTagPrefix: E, printOpeningTag: _ } = rr$1(), { printImgSrcset: w, printClassNames: F } = hg(), { printVueFor: N2, printVueBindings: x, isVueEventBindingExpression: I2 } = vg(), { isScriptLikeTag: P, isVueNonHtmlBlock: $2, inferScriptParser: D, htmlTrimPreserveIndentation: T, dedentString: m, unescapeQuoteEntities: C, isVueSlotAttribute: o, isVueSfcBindingsAttribute: h, getTextValueParts: v2 } = qt$1(), S = To$2();
  function b(k, M2, R2) {
    let q = (ee2) => new RegExp(ee2.join("|")).test(k.fullName), J = () => C(k.value), L = false, Q = (ee2, ce2) => {
      let W = ee2.type === "NGRoot" ? ee2.node.type === "NGMicrosyntax" && ee2.node.body.length === 1 && ee2.node.body[0].type === "NGMicrosyntaxExpression" ? ee2.node.body[0].expression : ee2.node : ee2.type === "JsExpressionRoot" ? ee2.node : ee2;
      W && (W.type === "ObjectExpression" || W.type === "ArrayExpression" || ce2.parser === "__vue_expression" && (W.type === "TemplateLiteral" || W.type === "StringLiteral")) && (L = true);
    }, V = (ee2) => s(ee2), j = function(ee2) {
      let ce2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      return s([n([l, ee2]), ce2 ? l : ""]);
    }, Y = (ee2) => L ? V(ee2) : j(ee2), ie2 = (ee2, ce2) => M2(ee2, Object.assign({ __onHtmlBindingRoot: Q, __embeddedInHtml: true }, ce2));
    if (k.fullName === "srcset" && (k.parent.fullName === "img" || k.parent.fullName === "source"))
      return j(w(J()));
    if (k.fullName === "class" && !R2.parentParser) {
      let ee2 = J();
      if (!ee2.includes("{{"))
        return F(ee2);
    }
    if (k.fullName === "style" && !R2.parentParser) {
      let ee2 = J();
      if (!ee2.includes("{{"))
        return j(ie2(ee2, { parser: "css", __isHTMLStyleAttribute: true }));
    }
    if (R2.parser === "vue") {
      if (k.fullName === "v-for")
        return N2(J(), ie2);
      if (o(k) || h(k, R2))
        return x(J(), ie2);
      let ee2 = ["^@", "^v-on:"], ce2 = ["^:", "^v-bind:"], W = ["^v-"];
      if (q(ee2)) {
        let K2 = J(), de = I2(K2) ? "__js_expression" : R2.__should_parse_vue_template_with_ts ? "__vue_ts_event_binding" : "__vue_event_binding";
        return Y(ie2(K2, { parser: de }));
      }
      if (q(ce2))
        return Y(ie2(J(), { parser: "__vue_expression" }));
      if (q(W))
        return Y(ie2(J(), { parser: "__js_expression" }));
    }
    if (R2.parser === "angular") {
      let ee2 = (z, U2) => ie2(z, Object.assign(Object.assign({}, U2), {}, { trailingComma: "none" })), ce2 = ["^\\*"], W = ["^\\(.+\\)$", "^on-"], K2 = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], de = ["^i18n(-.+)?$"];
      if (q(W))
        return Y(ee2(J(), { parser: "__ng_action" }));
      if (q(K2))
        return Y(ee2(J(), { parser: "__ng_binding" }));
      if (q(de)) {
        let z = J().trim();
        return j(i(v2(k, z)), !z.includes("@@"));
      }
      if (q(ce2))
        return Y(ee2(J(), { parser: "__ng_directive" }));
      let ue2 = /{{(.+?)}}/s, Fe2 = J();
      if (ue2.test(Fe2)) {
        let z = [];
        for (let [U2, Z] of Fe2.split(ue2).entries())
          if (U2 % 2 === 0)
            z.push(d2(Z));
          else
            try {
              z.push(s(["{{", n([u, ee2(Z, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), u, "}}"]));
            } catch {
              z.push("{{", d2(Z), "}}");
            }
        return s(z);
      }
    }
    return null;
  }
  function B(k, M2, R2, q) {
    let J = k.getValue();
    switch (J.type) {
      case "element": {
        if (P(J) || J.type === "interpolation")
          return;
        if (!J.isSelfClosing && $2(J, q)) {
          let L = D(J, q);
          if (!L)
            return;
          let Q = S(J, q), V = /^\s*$/.test(Q), j = "";
          return V || (j = R2(T(Q), { parser: L, __embeddedInHtml: true }, { stripTrailingHardline: true }), V = j === ""), [E(J, q), s(_(k, q, M2)), V ? "" : a, j, V ? "" : a, g2(J, q), c(J, q)];
        }
        break;
      }
      case "text": {
        if (P(J.parent)) {
          let L = D(J.parent, q);
          if (L) {
            let Q = L === "markdown" ? m(J.value.replace(/^[^\S\n]*\n/, "")) : J.value, V = { parser: L, __embeddedInHtml: true };
            if (q.parser === "html" && L === "babel") {
              let j = "script", { attrMap: Y } = J.parent;
              Y && (Y.type === "module" || Y.type === "text/babel" && Y["data-type"] === "module") && (j = "module"), V.__babelSourceType = j;
            }
            return [t, E(J, q), R2(Q, V, { stripTrailingHardline: true }), c(J, q)];
          }
        } else if (J.parent.type === "interpolation") {
          let L = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
          return q.parser === "angular" ? (L.parser = "__ng_interpolation", L.trailingComma = "none") : q.parser === "vue" ? L.parser = q.__should_parse_vue_template_with_ts ? "__vue_ts_expression" : "__vue_expression" : L.parser = "__js_expression", [n([u, R2(J.value, L, { stripTrailingHardline: true })]), J.parent.next && f(J.parent.next) ? " " : u];
        }
        break;
      }
      case "attribute": {
        if (!J.value)
          break;
        if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(q.originalText.slice(J.valueSpan.start.offset, J.valueSpan.end.offset)))
          return [J.rawName, "=", J.value];
        if (q.parser === "lwc" && /^{.*}$/s.test(q.originalText.slice(J.valueSpan.start.offset, J.valueSpan.end.offset)))
          return [J.rawName, "=", J.value];
        let L = b(J, (Q, V) => R2(Q, Object.assign({ __isInHtmlAttribute: true, __embeddedInHtml: true }, V), { stripTrailingHardline: true }), q);
        if (L)
          return [J.rawName, '="', s(p(L, (Q) => typeof Q == "string" ? Q.replace(/"/g, "&quot;") : Q)), '"'];
        break;
      }
      case "front-matter":
        return y2(J, R2);
    }
  }
  r.exports = B;
} }), Bo$1 = te$1({ "src/language-html/print/children.js"(e, r) {
  ne();
  var { builders: { breakParent: t, group: s, ifBreak: a, line: n, softline: u, hardline: i }, utils: { replaceTextEndOfLine: l } } = qe(), { locStart: p, locEnd: d2 } = uu$1(), { forceBreakChildren: y2, forceNextEmptyLine: g2, isTextLikeNode: c, hasPrettierIgnore: f, preferHardlineAsLeadingSpaces: E } = qt$1(), { printOpeningTagPrefix: _, needsToBorrowNextOpeningTagStartMarker: w, printOpeningTagStartMarker: F, needsToBorrowPrevClosingTagEndMarker: N2, printClosingTagEndMarker: x, printClosingTagSuffix: I2, needsToBorrowParentClosingTagStartMarker: P } = rr$1();
  function $2(m, C, o) {
    let h = m.getValue();
    return f(h) ? [_(h, C), ...l(C.originalText.slice(p(h) + (h.prev && w(h.prev) ? F(h).length : 0), d2(h) - (h.next && N2(h.next) ? x(h, C).length : 0))), I2(h, C)] : o();
  }
  function D(m, C) {
    return c(m) && c(C) ? m.isTrailingSpaceSensitive ? m.hasTrailingSpaces ? E(C) ? i : n : "" : E(C) ? i : u : w(m) && (f(C) || C.firstChild || C.isSelfClosing || C.type === "element" && C.attrs.length > 0) || m.type === "element" && m.isSelfClosing && N2(C) ? "" : !C.isLeadingSpaceSensitive || E(C) || N2(C) && m.lastChild && P(m.lastChild) && m.lastChild.lastChild && P(m.lastChild.lastChild) ? i : C.hasLeadingSpaces ? n : u;
  }
  function T(m, C, o) {
    let h = m.getValue();
    if (y2(h))
      return [t, ...m.map((S) => {
        let b = S.getValue(), B = b.prev ? D(b.prev, b) : "";
        return [B ? [B, g2(b.prev) ? i : ""] : "", $2(S, C, o)];
      }, "children")];
    let v2 = h.children.map(() => Symbol(""));
    return m.map((S, b) => {
      let B = S.getValue();
      if (c(B)) {
        if (B.prev && c(B.prev)) {
          let Q = D(B.prev, B);
          if (Q)
            return g2(B.prev) ? [i, i, $2(S, C, o)] : [Q, $2(S, C, o)];
        }
        return $2(S, C, o);
      }
      let k = [], M2 = [], R2 = [], q = [], J = B.prev ? D(B.prev, B) : "", L = B.next ? D(B, B.next) : "";
      return J && (g2(B.prev) ? k.push(i, i) : J === i ? k.push(i) : c(B.prev) ? M2.push(J) : M2.push(a("", u, { groupId: v2[b - 1] }))), L && (g2(B) ? c(B.next) && q.push(i, i) : L === i ? c(B.next) && q.push(i) : R2.push(L)), [...k, s([...M2, s([$2(S, C, o), ...R2], { id: v2[b] })]), ...q];
    }, "children");
  }
  r.exports = { printChildren: T };
} }), Eg = te$1({ "src/language-html/print/element.js"(e, r) {
  ne();
  var { builders: { breakParent: t, dedentToRoot: s, group: a, ifBreak: n, indentIfBreak: u, indent: i, line: l, softline: p }, utils: { replaceTextEndOfLine: d2 } } = qe(), y2 = To$2(), { shouldPreserveContent: g2, isScriptLikeTag: c, isVueCustomBlock: f, countParents: E, forceBreakContent: _ } = qt$1(), { printOpeningTagPrefix: w, printOpeningTag: F, printClosingTagSuffix: N2, printClosingTag: x, needsToBorrowPrevClosingTagEndMarker: I2, needsToBorrowLastChildClosingTagEndMarker: P } = rr$1(), { printChildren: $2 } = Bo$1();
  function D(T, m, C) {
    let o = T.getValue();
    if (g2(o, m))
      return [w(o, m), a(F(T, m, C)), ...d2(y2(o, m)), ...x(o, m), N2(o, m)];
    let h = o.children.length === 1 && o.firstChild.type === "interpolation" && o.firstChild.isLeadingSpaceSensitive && !o.firstChild.hasLeadingSpaces && o.lastChild.isTrailingSpaceSensitive && !o.lastChild.hasTrailingSpaces, v2 = Symbol("element-attr-group-id"), S = (M2) => a([a(F(T, m, C), { id: v2 }), M2, x(o, m)]), b = (M2) => h ? u(M2, { groupId: v2 }) : (c(o) || f(o, m)) && o.parent.type === "root" && m.parser === "vue" && !m.vueIndentScriptAndStyle ? M2 : i(M2), B = () => h ? n(p, "", { groupId: v2 }) : o.firstChild.hasLeadingSpaces && o.firstChild.isLeadingSpaceSensitive ? l : o.firstChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive ? s(p) : p, k = () => (o.next ? I2(o.next) : P(o.parent)) ? o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? " " : "" : h ? n(p, "", { groupId: v2 }) : o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? l : (o.lastChild.type === "comment" || o.lastChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${m.tabWidth * E(T, (R2) => R2.parent && R2.parent.type !== "root")}}$`).test(o.lastChild.value) ? "" : p;
    return o.children.length === 0 ? S(o.hasDanglingSpaces && o.isDanglingSpaceSensitive ? l : "") : S([_(o) ? t : "", b([B(), $2(T, m, C)]), k()]);
  }
  r.exports = { printElement: D };
} }), Fg = te$1({ "src/language-html/printer-html.js"(e, r) {
  ne();
  var { builders: { fill: t, group: s, hardline: a, literalline: n }, utils: { cleanDoc: u, getDocParts: i, isConcat: l, replaceTextEndOfLine: p } } = qe(), d2 = ag(), { countChars: y2, unescapeQuoteEntities: g2, getTextValueParts: c } = qt$1(), f = dg(), { insertPragma: E } = gg(), { locStart: _, locEnd: w } = uu$1(), F = Cg(), { printClosingTagSuffix: N2, printClosingTagEnd: x, printOpeningTagPrefix: I2, printOpeningTagStart: P } = rr$1(), { printElement: $2 } = Eg(), { printChildren: D } = Bo$1();
  function T(m, C, o) {
    let h = m.getValue();
    switch (h.type) {
      case "front-matter":
        return p(h.raw);
      case "root":
        return C.__onHtmlRoot && C.__onHtmlRoot(h), [s(D(m, C, o)), a];
      case "element":
      case "ieConditionalComment":
        return $2(m, C, o);
      case "ieConditionalStartComment":
      case "ieConditionalEndComment":
        return [P(h), x(h)];
      case "interpolation":
        return [P(h, C), ...m.map(o, "children"), x(h, C)];
      case "text": {
        if (h.parent.type === "interpolation") {
          let S = /\n[^\S\n]*$/, b = S.test(h.value), B = b ? h.value.replace(S, "") : h.value;
          return [...p(B), b ? a : ""];
        }
        let v2 = u([I2(h, C), ...c(h), N2(h, C)]);
        return l(v2) || v2.type === "fill" ? t(i(v2)) : v2;
      }
      case "docType":
        return [s([P(h, C), " ", h.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), x(h, C)];
      case "comment":
        return [I2(h, C), ...p(C.originalText.slice(_(h), w(h)), n), N2(h, C)];
      case "attribute": {
        if (h.value === null)
          return h.rawName;
        let v2 = g2(h.value), S = y2(v2, "'"), b = y2(v2, '"'), B = S < b ? "'" : '"';
        return [h.rawName, "=", B, ...p(B === '"' ? v2.replace(/"/g, "&quot;") : v2.replace(/'/g, "&apos;")), B];
      }
      default:
        throw new Error(`Unexpected node type ${h.type}`);
    }
  }
  r.exports = { preprocess: f, print: T, insertPragma: E, massageAstNode: d2, embed: F };
} }), Ag = te$1({ "src/language-html/options.js"(e, r) {
  ne();
  var t = jt(), s = "HTML";
  r.exports = { bracketSameLine: t.bracketSameLine, htmlWhitespaceSensitivity: { since: "1.15.0", category: s, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: t.singleAttributePerLine, vueIndentScriptAndStyle: { since: "1.19.0", category: s, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } };
} }), Sg = te$1({ "src/language-html/parsers.js"() {
  ne();
} }), kn = te$1({ "node_modules/linguist-languages/data/HTML.json"(e, r) {
  r.exports = { name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], languageId: 146 };
} }), xg = te$1({ "node_modules/linguist-languages/data/Vue.json"(e, r) {
  r.exports = { name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", languageId: 391 };
} }), bg = te$1({ "src/language-html/index.js"(e, r) {
  ne();
  var t = wt$1(), s = Fg(), a = Ag(), n = Sg(), u = [t(kn(), () => ({ name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: [] })), t(kn(), (l) => ({ since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: [...l.extensions, ".mjml"] })), t(kn(), () => ({ name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: [] })), t(xg(), () => ({ since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"] }))], i = { html: s };
  r.exports = { languages: u, printers: i, options: a, parsers: n };
} }), Tg = te$1({ "src/language-yaml/pragma.js"(e, r) {
  ne();
  function t(n) {
    return /^\s*@(?:prettier|format)\s*$/.test(n);
  }
  function s(n) {
    return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(n);
  }
  function a(n) {
    return `# @format

${n}`;
  }
  r.exports = { isPragma: t, hasPragma: s, insertPragma: a };
} }), Bg = te$1({ "src/language-yaml/loc.js"(e, r) {
  ne();
  function t(a) {
    return a.position.start.offset;
  }
  function s(a) {
    return a.position.end.offset;
  }
  r.exports = { locStart: t, locEnd: s };
} }), Ng = te$1({ "src/language-yaml/embed.js"(e, r) {
  ne();
  function t(s, a, n, u) {
    if (s.getValue().type === "root" && u.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint|lintstaged)rc$/.test(u.filepath))
      return n(u.originalText, Object.assign(Object.assign({}, u), {}, { parser: "json" }));
  }
  r.exports = t;
} }), Mt$2 = te$1({ "src/language-yaml/utils.js"(e, r) {
  ne();
  var { getLast: t, isNonEmptyArray: s } = Ue$2();
  function a(D, T) {
    let m = 0, C = D.stack.length - 1;
    for (let o = 0; o < C; o++) {
      let h = D.stack[o];
      n(h) && T(h) && m++;
    }
    return m;
  }
  function n(D, T) {
    return D && typeof D.type == "string" && (!T || T.includes(D.type));
  }
  function u(D, T, m) {
    return T("children" in D ? Object.assign(Object.assign({}, D), {}, { children: D.children.map((C) => u(C, T, D)) }) : D, m);
  }
  function i(D, T, m) {
    Object.defineProperty(D, T, { get: m, enumerable: false });
  }
  function l(D, T) {
    let m = 0, C = T.length;
    for (let o = D.position.end.offset - 1; o < C; o++) {
      let h = T[o];
      if (h === `
` && m++, m === 1 && /\S/.test(h))
        return false;
      if (m === 2)
        return true;
    }
    return false;
  }
  function p(D) {
    switch (D.getValue().type) {
      case "tag":
      case "anchor":
      case "comment":
        return false;
    }
    let m = D.stack.length;
    for (let C = 1; C < m; C++) {
      let o = D.stack[C], h = D.stack[C - 1];
      if (Array.isArray(h) && typeof o == "number" && o !== h.length - 1)
        return false;
    }
    return true;
  }
  function d2(D) {
    return s(D.children) ? d2(t(D.children)) : D;
  }
  function y2(D) {
    return D.value.trim() === "prettier-ignore";
  }
  function g2(D) {
    let T = D.getValue();
    if (T.type === "documentBody") {
      let m = D.getParentNode();
      return N2(m.head) && y2(t(m.head.endComments));
    }
    return E(T) && y2(t(T.leadingComments));
  }
  function c(D) {
    return !s(D.children) && !f(D);
  }
  function f(D) {
    return E(D) || _(D) || w(D) || F(D) || N2(D);
  }
  function E(D) {
    return s(D == null ? void 0 : D.leadingComments);
  }
  function _(D) {
    return s(D == null ? void 0 : D.middleComments);
  }
  function w(D) {
    return D == null ? void 0 : D.indicatorComment;
  }
  function F(D) {
    return D == null ? void 0 : D.trailingComment;
  }
  function N2(D) {
    return s(D == null ? void 0 : D.endComments);
  }
  function x(D) {
    let T = [], m;
    for (let C of D.split(/( +)/))
      C !== " " ? m === " " ? T.push(C) : T.push((T.pop() || "") + C) : m === void 0 && T.unshift(""), m = C;
    return m === " " && T.push((T.pop() || "") + " "), T[0] === "" && (T.shift(), T.unshift(" " + (T.shift() || ""))), T;
  }
  function I2(D, T, m) {
    let C = T.split(`
`).map((o, h, v2) => h === 0 && h === v2.length - 1 ? o : h !== 0 && h !== v2.length - 1 ? o.trim() : h === 0 ? o.trimEnd() : o.trimStart());
    return m.proseWrap === "preserve" ? C.map((o) => o.length === 0 ? [] : [o]) : C.map((o) => o.length === 0 ? [] : x(o)).reduce((o, h, v2) => v2 !== 0 && C[v2 - 1].length > 0 && h.length > 0 && !(D === "quoteDouble" && t(t(o)).endsWith("\\")) ? [...o.slice(0, -1), [...t(o), ...h]] : [...o, h], []).map((o) => m.proseWrap === "never" ? [o.join(" ")] : o);
  }
  function P(D, T) {
    let { parentIndent: m, isLastDescendant: C, options: o } = T, h = D.position.start.line === D.position.end.line ? "" : o.originalText.slice(D.position.start.offset, D.position.end.offset).match(/^[^\n]*\n(.*)$/s)[1], v2;
    if (D.indent === null) {
      let B = h.match(/^(?<leadingSpace> *)[^\n\r ]/m);
      v2 = B ? B.groups.leadingSpace.length : Number.POSITIVE_INFINITY;
    } else
      v2 = D.indent - 1 + m;
    let S = h.split(`
`).map((B) => B.slice(v2));
    if (o.proseWrap === "preserve" || D.type === "blockLiteral")
      return b(S.map((B) => B.length === 0 ? [] : [B]));
    return b(S.map((B) => B.length === 0 ? [] : x(B)).reduce((B, k, M2) => M2 !== 0 && S[M2 - 1].length > 0 && k.length > 0 && !/^\s/.test(k[0]) && !/^\s|\s$/.test(t(B)) ? [...B.slice(0, -1), [...t(B), ...k]] : [...B, k], []).map((B) => B.reduce((k, M2) => k.length > 0 && /\s$/.test(t(k)) ? [...k.slice(0, -1), t(k) + " " + M2] : [...k, M2], [])).map((B) => o.proseWrap === "never" ? [B.join(" ")] : B));
    function b(B) {
      if (D.chomping === "keep")
        return t(B).length === 0 ? B.slice(0, -1) : B;
      let k = 0;
      for (let M2 = B.length - 1; M2 >= 0 && B[M2].length === 0; M2--)
        k++;
      return k === 0 ? B : k >= 2 && !C ? B.slice(0, -(k - 1)) : B.slice(0, -k);
    }
  }
  function $2(D) {
    if (!D)
      return true;
    switch (D.type) {
      case "plain":
      case "quoteDouble":
      case "quoteSingle":
      case "alias":
      case "flowMapping":
      case "flowSequence":
        return true;
      default:
        return false;
    }
  }
  r.exports = { getLast: t, getAncestorCount: a, isNode: n, isEmptyNode: c, isInlineNode: $2, mapNode: u, defineShortcut: i, isNextLineEmpty: l, isLastDescendantNode: p, getBlockValueLineContents: P, getFlowScalarLineContents: I2, getLastDescendantNode: d2, hasPrettierIgnore: g2, hasLeadingComments: E, hasMiddleComments: _, hasIndicatorComment: w, hasTrailingComment: F, hasEndComments: N2 };
} }), wg = te$1({ "src/language-yaml/print-preprocess.js"(e, r) {
  ne();
  var { defineShortcut: t, mapNode: s } = Mt$2();
  function a(u) {
    return s(u, n);
  }
  function n(u) {
    switch (u.type) {
      case "document":
        t(u, "head", () => u.children[0]), t(u, "body", () => u.children[1]);
        break;
      case "documentBody":
      case "sequenceItem":
      case "flowSequenceItem":
      case "mappingKey":
      case "mappingValue":
        t(u, "content", () => u.children[0]);
        break;
      case "mappingItem":
      case "flowMappingItem":
        t(u, "key", () => u.children[0]), t(u, "value", () => u.children[1]);
        break;
    }
    return u;
  }
  r.exports = a;
} }), jr$1 = te$1({ "src/language-yaml/print/misc.js"(e, r) {
  ne();
  var { builders: { softline: t, align: s } } = qe(), { hasEndComments: a, isNextLineEmpty: n, isNode: u } = Mt$2(), i = /* @__PURE__ */ new WeakMap();
  function l(y2, g2) {
    let c = y2.getValue(), f = y2.stack[0], E;
    return i.has(f) ? E = i.get(f) : (E = /* @__PURE__ */ new Set(), i.set(f, E)), !E.has(c.position.end.line) && (E.add(c.position.end.line), n(c, g2) && !p(y2.getParentNode())) ? t : "";
  }
  function p(y2) {
    return a(y2) && !u(y2, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
  }
  function d2(y2, g2) {
    return s(" ".repeat(y2), g2);
  }
  r.exports = { alignWithSpaces: d2, shouldPrintEndComments: p, printNextEmptyLine: l };
} }), _g = te$1({ "src/language-yaml/print/flow-mapping-sequence.js"(e, r) {
  ne();
  var { builders: { ifBreak: t, line: s, softline: a, hardline: n, join: u } } = qe(), { isEmptyNode: i, getLast: l, hasEndComments: p } = Mt$2(), { printNextEmptyLine: d2, alignWithSpaces: y2 } = jr$1();
  function g2(f, E, _) {
    let w = f.getValue(), F = w.type === "flowMapping", N2 = F ? "{" : "[", x = F ? "}" : "]", I2 = a;
    F && w.children.length > 0 && _.bracketSpacing && (I2 = s);
    let P = l(w.children), $2 = P && P.type === "flowMappingItem" && i(P.key) && i(P.value);
    return [N2, y2(_.tabWidth, [I2, c(f, E, _), _.trailingComma === "none" ? "" : t(","), p(w) ? [n, u(n, f.map(E, "endComments"))] : ""]), $2 ? "" : I2, x];
  }
  function c(f, E, _) {
    let w = f.getValue();
    return f.map((N2, x) => [E(), x === w.children.length - 1 ? "" : [",", s, w.children[x].position.start.line !== w.children[x + 1].position.start.line ? d2(N2, _.originalText) : ""]], "children");
  }
  r.exports = { printFlowMapping: g2, printFlowSequence: g2 };
} }), Pg = te$1({ "src/language-yaml/print/mapping-item.js"(e, r) {
  ne();
  var { builders: { conditionalGroup: t, group: s, hardline: a, ifBreak: n, join: u, line: i } } = qe(), { hasLeadingComments: l, hasMiddleComments: p, hasTrailingComment: d2, hasEndComments: y2, isNode: g2, isEmptyNode: c, isInlineNode: f } = Mt$2(), { alignWithSpaces: E } = jr$1();
  function _(x, I2, P, $2, D) {
    let { key: T, value: m } = x, C = c(T), o = c(m);
    if (C && o)
      return ": ";
    let h = $2("key"), v2 = F(x) ? " " : "";
    if (o)
      return x.type === "flowMappingItem" && I2.type === "flowMapping" ? h : x.type === "mappingItem" && w(T.content, D) && !d2(T.content) && (!I2.tag || I2.tag.value !== "tag:yaml.org,2002:set") ? [h, v2, ":"] : ["? ", E(2, h)];
    let S = $2("value");
    if (C)
      return [": ", E(2, S)];
    if (l(m) || !f(T.content))
      return ["? ", E(2, h), a, u("", P.map($2, "value", "leadingComments").map((q) => [q, a])), ": ", E(2, S)];
    if (N2(T.content) && !l(T.content) && !p(T.content) && !d2(T.content) && !y2(T) && !l(m.content) && !p(m.content) && !y2(m) && w(m.content, D))
      return [h, v2, ": ", S];
    let b = Symbol("mappingKey"), B = s([n("? "), s(E(2, h), { id: b })]), k = [a, ": ", E(2, S)], M2 = [v2, ":"];
    l(m.content) || y2(m) && m.content && !g2(m.content, ["mapping", "sequence"]) || I2.type === "mapping" && d2(T.content) && f(m.content) || g2(m.content, ["mapping", "sequence"]) && m.content.tag === null && m.content.anchor === null ? M2.push(a) : m.content && M2.push(i), M2.push(S);
    let R2 = E(D.tabWidth, M2);
    return w(T.content, D) && !l(T.content) && !p(T.content) && !y2(T) ? t([[h, R2]]) : t([[B, n(k, R2, { groupId: b })]]);
  }
  function w(x, I2) {
    if (!x)
      return true;
    switch (x.type) {
      case "plain":
      case "quoteSingle":
      case "quoteDouble":
        break;
      case "alias":
        return true;
      default:
        return false;
    }
    if (I2.proseWrap === "preserve")
      return x.position.start.line === x.position.end.line;
    if (/\\$/m.test(I2.originalText.slice(x.position.start.offset, x.position.end.offset)))
      return false;
    switch (I2.proseWrap) {
      case "never":
        return !x.value.includes(`
`);
      case "always":
        return !/[\n ]/.test(x.value);
      default:
        return false;
    }
  }
  function F(x) {
    return x.key.content && x.key.content.type === "alias";
  }
  function N2(x) {
    if (!x)
      return true;
    switch (x.type) {
      case "plain":
      case "quoteDouble":
      case "quoteSingle":
        return x.position.start.line === x.position.end.line;
      case "alias":
        return true;
      default:
        return false;
    }
  }
  r.exports = _;
} }), Ig = te$1({ "src/language-yaml/print/block.js"(e, r) {
  ne();
  var { builders: { dedent: t, dedentToRoot: s, fill: a, hardline: n, join: u, line: i, literalline: l, markAsRoot: p }, utils: { getDocParts: d2 } } = qe(), { getAncestorCount: y2, getBlockValueLineContents: g2, hasIndicatorComment: c, isLastDescendantNode: f, isNode: E } = Mt$2(), { alignWithSpaces: _ } = jr$1();
  function w(F, N2, x) {
    let I2 = F.getValue(), P = y2(F, (C) => E(C, ["sequence", "mapping"])), $2 = f(F), D = [I2.type === "blockFolded" ? ">" : "|"];
    I2.indent !== null && D.push(I2.indent.toString()), I2.chomping !== "clip" && D.push(I2.chomping === "keep" ? "+" : "-"), c(I2) && D.push(" ", N2("indicatorComment"));
    let T = g2(I2, { parentIndent: P, isLastDescendant: $2, options: x }), m = [];
    for (let [C, o] of T.entries())
      C === 0 && m.push(n), m.push(a(d2(u(i, o)))), C !== T.length - 1 ? m.push(o.length === 0 ? n : p(l)) : I2.chomping === "keep" && $2 && m.push(s(o.length === 0 ? n : l));
    return I2.indent === null ? D.push(t(_(x.tabWidth, m))) : D.push(s(_(I2.indent - 1 + P, m))), D;
  }
  r.exports = w;
} }), kg = te$1({ "src/language-yaml/printer-yaml.js"(e, r) {
  ne();
  var { builders: { breakParent: t, fill: s, group: a, hardline: n, join: u, line: i, lineSuffix: l, literalline: p }, utils: { getDocParts: d2, replaceTextEndOfLine: y2 } } = qe(), { isPreviousLineEmpty: g2 } = Ue$2(), { insertPragma: c, isPragma: f } = Tg(), { locStart: E } = Bg(), _ = Ng(), { getFlowScalarLineContents: w, getLastDescendantNode: F, hasLeadingComments: N2, hasMiddleComments: x, hasTrailingComment: I2, hasEndComments: P, hasPrettierIgnore: $2, isLastDescendantNode: D, isNode: T, isInlineNode: m } = Mt$2(), C = wg(), { alignWithSpaces: o, printNextEmptyLine: h, shouldPrintEndComments: v2 } = jr$1(), { printFlowMapping: S, printFlowSequence: b } = _g(), B = Pg(), k = Ig();
  function M2(j, Y, ie2) {
    let ee2 = j.getValue(), ce2 = [];
    ee2.type !== "mappingValue" && N2(ee2) && ce2.push([u(n, j.map(ie2, "leadingComments")), n]);
    let { tag: W, anchor: K2 } = ee2;
    W && ce2.push(ie2("tag")), W && K2 && ce2.push(" "), K2 && ce2.push(ie2("anchor"));
    let de = "";
    T(ee2, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !D(j) && (de = h(j, Y.originalText)), (W || K2) && (T(ee2, ["sequence", "mapping"]) && !x(ee2) ? ce2.push(n) : ce2.push(" ")), x(ee2) && ce2.push([ee2.middleComments.length === 1 ? "" : n, u(n, j.map(ie2, "middleComments")), n]);
    let ue2 = j.getParentNode();
    return $2(j) ? ce2.push(y2(Y.originalText.slice(ee2.position.start.offset, ee2.position.end.offset).trimEnd(), p)) : ce2.push(a(R2(ee2, ue2, j, Y, ie2))), I2(ee2) && !T(ee2, ["document", "documentHead"]) && ce2.push(l([ee2.type === "mappingValue" && !ee2.content ? "" : " ", ue2.type === "mappingKey" && j.getParentNode(2).type === "mapping" && m(ee2) ? "" : t, ie2("trailingComment")])), v2(ee2) && ce2.push(o(ee2.type === "sequenceItem" ? 2 : 0, [n, u(n, j.map((Fe2) => [g2(Y.originalText, Fe2.getValue(), E) ? n : "", ie2()], "endComments"))])), ce2.push(de), ce2;
  }
  function R2(j, Y, ie2, ee2, ce2) {
    switch (j.type) {
      case "root": {
        let { children: W } = j, K2 = [];
        ie2.each((ue2, Fe2) => {
          let z = W[Fe2], U2 = W[Fe2 + 1];
          Fe2 !== 0 && K2.push(n), K2.push(ce2()), J(z, U2) ? (K2.push(n, "..."), I2(z) && K2.push(" ", ce2("trailingComment"))) : U2 && !I2(U2.head) && K2.push(n, "---");
        }, "children");
        let de = F(j);
        return (!T(de, ["blockLiteral", "blockFolded"]) || de.chomping !== "keep") && K2.push(n), K2;
      }
      case "document": {
        let W = Y.children[ie2.getName() + 1], K2 = [];
        return L(j, W, Y, ee2) === "head" && ((j.head.children.length > 0 || j.head.endComments.length > 0) && K2.push(ce2("head")), I2(j.head) ? K2.push(["---", " ", ce2(["head", "trailingComment"])]) : K2.push("---")), q(j) && K2.push(ce2("body")), u(n, K2);
      }
      case "documentHead":
        return u(n, [...ie2.map(ce2, "children"), ...ie2.map(ce2, "endComments")]);
      case "documentBody": {
        let { children: W, endComments: K2 } = j, de = "";
        if (W.length > 0 && K2.length > 0) {
          let ue2 = F(j);
          T(ue2, ["blockFolded", "blockLiteral"]) ? ue2.chomping !== "keep" && (de = [n, n]) : de = n;
        }
        return [u(n, ie2.map(ce2, "children")), de, u(n, ie2.map(ce2, "endComments"))];
      }
      case "directive":
        return ["%", u(" ", [j.name, ...j.parameters])];
      case "comment":
        return ["#", j.value];
      case "alias":
        return ["*", j.value];
      case "tag":
        return ee2.originalText.slice(j.position.start.offset, j.position.end.offset);
      case "anchor":
        return ["&", j.value];
      case "plain":
        return Q(j.type, ee2.originalText.slice(j.position.start.offset, j.position.end.offset), ee2);
      case "quoteDouble":
      case "quoteSingle": {
        let W = "'", K2 = '"', de = ee2.originalText.slice(j.position.start.offset + 1, j.position.end.offset - 1);
        if (j.type === "quoteSingle" && de.includes("\\") || j.type === "quoteDouble" && /\\[^"]/.test(de)) {
          let Fe2 = j.type === "quoteDouble" ? K2 : W;
          return [Fe2, Q(j.type, de, ee2), Fe2];
        }
        if (de.includes(K2))
          return [W, Q(j.type, j.type === "quoteDouble" ? de.replace(/\\"/g, K2).replace(/'/g, W.repeat(2)) : de, ee2), W];
        if (de.includes(W))
          return [K2, Q(j.type, j.type === "quoteSingle" ? de.replace(/''/g, W) : de, ee2), K2];
        let ue2 = ee2.singleQuote ? W : K2;
        return [ue2, Q(j.type, de, ee2), ue2];
      }
      case "blockFolded":
      case "blockLiteral":
        return k(ie2, ce2, ee2);
      case "mapping":
      case "sequence":
        return u(n, ie2.map(ce2, "children"));
      case "sequenceItem":
        return ["- ", o(2, j.content ? ce2("content") : "")];
      case "mappingKey":
      case "mappingValue":
        return j.content ? ce2("content") : "";
      case "mappingItem":
      case "flowMappingItem":
        return B(j, Y, ie2, ce2, ee2);
      case "flowMapping":
        return S(ie2, ce2, ee2);
      case "flowSequence":
        return b(ie2, ce2, ee2);
      case "flowSequenceItem":
        return ce2("content");
      default:
        throw new Error(`Unexpected node type ${j.type}`);
    }
  }
  function q(j) {
    return j.body.children.length > 0 || P(j.body);
  }
  function J(j, Y) {
    return I2(j) || Y && (Y.head.children.length > 0 || P(Y.head));
  }
  function L(j, Y, ie2, ee2) {
    return ie2.children[0] === j && /---(?:\s|$)/.test(ee2.originalText.slice(E(j), E(j) + 4)) || j.head.children.length > 0 || P(j.head) || I2(j.head) ? "head" : J(j, Y) ? false : Y ? "root" : false;
  }
  function Q(j, Y, ie2) {
    let ee2 = w(j, Y, ie2);
    return u(n, ee2.map((ce2) => s(d2(u(i, ce2)))));
  }
  function V(j, Y) {
    if (T(Y))
      switch (delete Y.position, Y.type) {
        case "comment":
          if (f(Y.value))
            return null;
          break;
        case "quoteDouble":
        case "quoteSingle":
          Y.type = "quote";
          break;
      }
  }
  r.exports = { preprocess: C, embed: _, print: M2, massageAstNode: V, insertPragma: c };
} }), Lg = te$1({ "src/language-yaml/options.js"(e, r) {
  ne();
  var t = jt();
  r.exports = { bracketSpacing: t.bracketSpacing, singleQuote: t.singleQuote, proseWrap: t.proseWrap };
} }), Og = te$1({ "src/language-yaml/parsers.js"() {
  ne();
} }), jg = te$1({ "node_modules/linguist-languages/data/YAML.json"(e, r) {
  r.exports = { name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "CITATION.cff", "glide.lock", "yarn.lock"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407 };
} }), qg = te$1({ "src/language-yaml/index.js"(e, r) {
  ne();
  var t = wt$1(), s = kg(), a = Lg(), n = Og(), u = [t(jg(), (i) => ({ since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: [...i.filenames.filter((l) => l !== "yarn.lock"), ".prettierrc", ".stylelintrc", ".lintstagedrc"] }))];
  r.exports = { languages: u, printers: { yaml: s }, options: a, parsers: n };
} }), Mg = te$1({ "src/languages.js"(e, r) {
  ne(), r.exports = [vd(), jd(), Gd(), Qd(), ig(), bg(), qg()];
} }), Rg = te$1({ "src/standalone.js"(e, r) {
  ne();
  var { version: t } = xa(), s = Om(), { getSupportInfo: a } = Un$1(), n = jm(), u = Mg(), i = qe();
  function l(d2) {
    let y2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    return function() {
      for (var g2 = arguments.length, c = new Array(g2), f = 0; f < g2; f++)
        c[f] = arguments[f];
      let E = c[y2] || {}, _ = E.plugins || [];
      return c[y2] = Object.assign(Object.assign({}, E), {}, { plugins: [...u, ...Array.isArray(_) ? _ : Object.values(_)] }), d2(...c);
    };
  }
  var p = l(s.formatWithCursor);
  r.exports = { formatWithCursor: p, format(d2, y2) {
    return p(d2, y2).formatted;
  }, check(d2, y2) {
    let { formatted: g2 } = p(d2, y2);
    return g2 === d2;
  }, doc: i, getSupportInfo: l(a, 0), version: t, util: n, __debug: { parse: l(s.parse), formatAST: l(s.formatAST), formatDoc: l(s.formatDoc), printToDoc: l(s.printToDoc), printDocToString: l(s.printDocToString) } };
} }), Ty = Rg();
var v = (l, h) => () => (h || l((h = { exports: {} }).exports, h), h.exports);
var he$2 = v((qf2, ii) => {
  var Nt2 = function(l) {
    return l && l.Math == Math && l;
  };
  ii.exports = Nt2(typeof globalThis == "object" && globalThis) || Nt2(typeof window == "object" && window) || Nt2(typeof self == "object" && self) || Nt2(typeof global == "object" && global) || function() {
    return this;
  }() || Function("return this")();
});
var ce$1 = v((Uf2, ai) => {
  ai.exports = function(l) {
    try {
      return !!l();
    } catch {
      return true;
    }
  };
});
var ve$1 = v(($f, ni) => {
  var xh = ce$1();
  ni.exports = !xh(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] != 7;
  });
});
var kt$1 = v((Hf, oi2) => {
  var gh = ce$1();
  oi2.exports = !gh(function() {
    var l = (function() {
    }).bind();
    return typeof l != "function" || l.hasOwnProperty("prototype");
  });
});
var Ft = v((zf, li) => {
  var Ph = kt$1(), Dt2 = Function.prototype.call;
  li.exports = Ph ? Dt2.bind(Dt2) : function() {
    return Dt2.apply(Dt2, arguments);
  };
});
var pi = v((ci) => {
  var hi = {}.propertyIsEnumerable, ui2 = Object.getOwnPropertyDescriptor, Ah = ui2 && !hi.call({ 1: 2 }, 1);
  ci.f = Ah ? function(h) {
    var f = ui2(this, h);
    return !!f && f.enumerable;
  } : hi;
});
var Ps$1 = v((Kf2, fi2) => {
  fi2.exports = function(l, h) {
    return { enumerable: !(l & 1), configurable: !(l & 2), writable: !(l & 4), value: h };
  };
});
var pe$1 = v((Wf, yi2) => {
  var di2 = kt$1(), mi = Function.prototype, As2 = mi.call, Th = di2 && mi.bind.bind(As2, As2);
  yi2.exports = di2 ? Th : function(l) {
    return function() {
      return As2.apply(l, arguments);
    };
  };
});
var st$1 = v((Gf2, gi) => {
  var xi = pe$1(), vh = xi({}.toString), Eh = xi("".slice);
  gi.exports = function(l) {
    return Eh(vh(l), 8, -1);
  };
});
var Ai = v((Jf2, Pi) => {
  var Ch = pe$1(), bh = ce$1(), Sh = st$1(), Ts2 = Object, wh = Ch("".split);
  Pi.exports = bh(function() {
    return !Ts2("z").propertyIsEnumerable(0);
  }) ? function(l) {
    return Sh(l) == "String" ? wh(l, "") : Ts2(l);
  } : Ts2;
});
var vs$1 = v((Xf, Ti2) => {
  Ti2.exports = function(l) {
    return l == null;
  };
});
var Es$2 = v((Yf2, vi2) => {
  var Ih = vs$1(), Nh = TypeError;
  vi2.exports = function(l) {
    if (Ih(l))
      throw Nh("Can't call method on " + l);
    return l;
  };
});
var Lt$1 = v((Qf2, Ei) => {
  var kh = Ai(), Dh = Es$2();
  Ei.exports = function(l) {
    return kh(Dh(l));
  };
});
var bs$1 = v((Zf2, Ci) => {
  var Cs2 = typeof document == "object" && document.all, Fh = typeof Cs2 > "u" && Cs2 !== void 0;
  Ci.exports = { all: Cs2, IS_HTMLDDA: Fh };
});
var ie = v((ed2, Si2) => {
  var bi = bs$1(), Lh = bi.all;
  Si2.exports = bi.IS_HTMLDDA ? function(l) {
    return typeof l == "function" || l === Lh;
  } : function(l) {
    return typeof l == "function";
  };
});
var Oe$1 = v((td2, Ni2) => {
  var wi2 = ie(), Ii2 = bs$1(), Oh = Ii2.all;
  Ni2.exports = Ii2.IS_HTMLDDA ? function(l) {
    return typeof l == "object" ? l !== null : wi2(l) || l === Oh;
  } : function(l) {
    return typeof l == "object" ? l !== null : wi2(l);
  };
});
var rt = v((sd2, ki) => {
  var Ss2 = he$2(), Bh = ie(), Mh = function(l) {
    return Bh(l) ? l : void 0;
  };
  ki.exports = function(l, h) {
    return arguments.length < 2 ? Mh(Ss2[l]) : Ss2[l] && Ss2[l][h];
  };
});
var Fi$1 = v((rd2, Di2) => {
  var _h = pe$1();
  Di2.exports = _h({}.isPrototypeOf);
});
var Oi = v((id2, Li2) => {
  var Rh = rt();
  Li2.exports = Rh("navigator", "userAgent") || "";
});
var Ui = v((ad2, qi) => {
  var ji2 = he$2(), ws2 = Oi(), Bi2 = ji2.process, Mi2 = ji2.Deno, _i2 = Bi2 && Bi2.versions || Mi2 && Mi2.version, Ri = _i2 && _i2.v8, fe2, Ot2;
  Ri && (fe2 = Ri.split("."), Ot2 = fe2[0] > 0 && fe2[0] < 4 ? 1 : +(fe2[0] + fe2[1]));
  !Ot2 && ws2 && (fe2 = ws2.match(/Edge\/(\d+)/), (!fe2 || fe2[1] >= 74) && (fe2 = ws2.match(/Chrome\/(\d+)/), fe2 && (Ot2 = +fe2[1])));
  qi.exports = Ot2;
});
var Is$1 = v((nd2, Hi2) => {
  var $i2 = Ui(), jh = ce$1();
  Hi2.exports = !!Object.getOwnPropertySymbols && !jh(function() {
    var l = Symbol();
    return !String(l) || !(Object(l) instanceof Symbol) || !Symbol.sham && $i2 && $i2 < 41;
  });
});
var Ns$1 = v((od2, zi2) => {
  var qh = Is$1();
  zi2.exports = qh && !Symbol.sham && typeof Symbol.iterator == "symbol";
});
var ks$1 = v((ld2, Vi2) => {
  var Uh = rt(), $h = ie(), Hh = Fi$1(), zh = Ns$1(), Vh = Object;
  Vi2.exports = zh ? function(l) {
    return typeof l == "symbol";
  } : function(l) {
    var h = Uh("Symbol");
    return $h(h) && Hh(h.prototype, Vh(l));
  };
});
var Wi = v((hd2, Ki) => {
  var Kh = String;
  Ki.exports = function(l) {
    try {
      return Kh(l);
    } catch {
      return "Object";
    }
  };
});
var Bt = v((ud2, Gi) => {
  var Wh = ie(), Gh = Wi(), Jh = TypeError;
  Gi.exports = function(l) {
    if (Wh(l))
      return l;
    throw Jh(Gh(l) + " is not a function");
  };
});
var Xi = v((cd2, Ji2) => {
  var Xh = Bt(), Yh = vs$1();
  Ji2.exports = function(l, h) {
    var f = l[h];
    return Yh(f) ? void 0 : Xh(f);
  };
});
var Qi = v((pd2, Yi2) => {
  var Ds2 = Ft(), Fs2 = ie(), Ls2 = Oe$1(), Qh = TypeError;
  Yi2.exports = function(l, h) {
    var f, d2;
    if (h === "string" && Fs2(f = l.toString) && !Ls2(d2 = Ds2(f, l)) || Fs2(f = l.valueOf) && !Ls2(d2 = Ds2(f, l)) || h !== "string" && Fs2(f = l.toString) && !Ls2(d2 = Ds2(f, l)))
      return d2;
    throw Qh("Can't convert object to primitive value");
  };
});
var ea$1 = v((fd2, Zi2) => {
  Zi2.exports = false;
});
var Mt$1 = v((dd2, sa2) => {
  var ta2 = he$2(), Zh = Object.defineProperty;
  sa2.exports = function(l, h) {
    try {
      Zh(ta2, l, { value: h, configurable: true, writable: true });
    } catch {
      ta2[l] = h;
    }
    return h;
  };
});
var _t$1 = v((md2, ia) => {
  var eu2 = he$2(), tu2 = Mt$1(), ra2 = "__core-js_shared__", su = eu2[ra2] || tu2(ra2, {});
  ia.exports = su;
});
var Os$1 = v((yd2, na2) => {
  var ru2 = ea$1(), aa = _t$1();
  (na2.exports = function(l, h) {
    return aa[l] || (aa[l] = h !== void 0 ? h : {});
  })("versions", []).push({ version: "3.26.1", mode: ru2 ? "pure" : "global", copyright: "© 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE", source: "https://github.com/zloirock/core-js" });
});
var Bs$1 = v((xd2, oa) => {
  var iu = Es$2(), au = Object;
  oa.exports = function(l) {
    return au(iu(l));
  };
});
var Ie$2 = v((gd2, la) => {
  var nu2 = pe$1(), ou = Bs$1(), lu2 = nu2({}.hasOwnProperty);
  la.exports = Object.hasOwn || function(h, f) {
    return lu2(ou(h), f);
  };
});
var Ms$1 = v((Pd2, ha2) => {
  var hu = pe$1(), uu2 = 0, cu = Math.random(), pu = hu(1 .toString);
  ha2.exports = function(l) {
    return "Symbol(" + (l === void 0 ? "" : l) + ")_" + pu(++uu2 + cu, 36);
  };
});
var it$1 = v((Ad2, da2) => {
  var fu = he$2(), du = Os$1(), ua = Ie$2(), mu = Ms$1(), ca2 = Is$1(), fa2 = Ns$1(), Ge2 = du("wks"), Be = fu.Symbol, pa = Be && Be.for, yu = fa2 ? Be : Be && Be.withoutSetter || mu;
  da2.exports = function(l) {
    if (!ua(Ge2, l) || !(ca2 || typeof Ge2[l] == "string")) {
      var h = "Symbol." + l;
      ca2 && ua(Be, l) ? Ge2[l] = Be[l] : fa2 && pa ? Ge2[l] = pa(h) : Ge2[l] = yu(h);
    }
    return Ge2[l];
  };
});
var ga = v((Td2, xa2) => {
  var xu = Ft(), ma = Oe$1(), ya2 = ks$1(), gu2 = Xi(), Pu = Qi(), Au = it$1(), Tu = TypeError, vu = Au("toPrimitive");
  xa2.exports = function(l, h) {
    if (!ma(l) || ya2(l))
      return l;
    var f = gu2(l, vu), d2;
    if (f) {
      if (h === void 0 && (h = "default"), d2 = xu(f, l, h), !ma(d2) || ya2(d2))
        return d2;
      throw Tu("Can't convert object to primitive value");
    }
    return h === void 0 && (h = "number"), Pu(l, h);
  };
});
var _s$1 = v((vd2, Pa2) => {
  var Eu = ga(), Cu = ks$1();
  Pa2.exports = function(l) {
    var h = Eu(l, "string");
    return Cu(h) ? h : h + "";
  };
});
var va = v((Ed2, Ta2) => {
  var bu = he$2(), Aa2 = Oe$1(), Rs2 = bu.document, Su2 = Aa2(Rs2) && Aa2(Rs2.createElement);
  Ta2.exports = function(l) {
    return Su2 ? Rs2.createElement(l) : {};
  };
});
var js$1 = v((Cd2, Ea2) => {
  var wu = ve$1(), Iu = ce$1(), Nu2 = va();
  Ea2.exports = !wu && !Iu(function() {
    return Object.defineProperty(Nu2("div"), "a", { get: function() {
      return 7;
    } }).a != 7;
  });
});
var qs$2 = v((ba2) => {
  var ku = ve$1(), Du = Ft(), Fu = pi(), Lu = Ps$1(), Ou = Lt$1(), Bu = _s$1(), Mu = Ie$2(), _u2 = js$1(), Ca2 = Object.getOwnPropertyDescriptor;
  ba2.f = ku ? Ca2 : function(h, f) {
    if (h = Ou(h), f = Bu(f), _u2)
      try {
        return Ca2(h, f);
      } catch {
      }
    if (Mu(h, f))
      return Lu(!Du(Fu.f, h, f), h[f]);
  };
});
var wa = v((Sd2, Sa2) => {
  var Ru = ve$1(), ju2 = ce$1();
  Sa2.exports = Ru && ju2(function() {
    return Object.defineProperty(function() {
    }, "prototype", { value: 42, writable: false }).prototype != 42;
  });
});
var Rt$1 = v((wd2, Ia2) => {
  var qu = Oe$1(), Uu = String, $u2 = TypeError;
  Ia2.exports = function(l) {
    if (qu(l))
      return l;
    throw $u2(Uu(l) + " is not an object");
  };
});
var at = v((ka2) => {
  var Hu2 = ve$1(), zu = js$1(), Vu = wa(), jt2 = Rt$1(), Na2 = _s$1(), Ku = TypeError, Us2 = Object.defineProperty, Wu = Object.getOwnPropertyDescriptor, $s2 = "enumerable", Hs2 = "configurable", zs2 = "writable";
  ka2.f = Hu2 ? Vu ? function(h, f, d2) {
    if (jt2(h), f = Na2(f), jt2(d2), typeof h == "function" && f === "prototype" && "value" in d2 && zs2 in d2 && !d2[zs2]) {
      var x = Wu(h, f);
      x && x[zs2] && (h[f] = d2.value, d2 = { configurable: Hs2 in d2 ? d2[Hs2] : x[Hs2], enumerable: $s2 in d2 ? d2[$s2] : x[$s2], writable: false });
    }
    return Us2(h, f, d2);
  } : Us2 : function(h, f, d2) {
    if (jt2(h), f = Na2(f), jt2(d2), zu)
      try {
        return Us2(h, f, d2);
      } catch {
      }
    if ("get" in d2 || "set" in d2)
      throw Ku("Accessors not supported");
    return "value" in d2 && (h[f] = d2.value), h;
  };
});
var Vs$1 = v((Nd2, Da) => {
  var Gu = ve$1(), Ju = at(), Xu = Ps$1();
  Da.exports = Gu ? function(l, h, f) {
    return Ju.f(l, h, Xu(1, f));
  } : function(l, h, f) {
    return l[h] = f, l;
  };
});
var Oa = v((kd2, La2) => {
  var Ks2 = ve$1(), Yu = Ie$2(), Fa2 = Function.prototype, Qu = Ks2 && Object.getOwnPropertyDescriptor, Ws2 = Yu(Fa2, "name"), Zu2 = Ws2 && (function() {
  }).name === "something", ec = Ws2 && (!Ks2 || Ks2 && Qu(Fa2, "name").configurable);
  La2.exports = { EXISTS: Ws2, PROPER: Zu2, CONFIGURABLE: ec };
});
var Js$1 = v((Dd2, Ba2) => {
  var tc = pe$1(), sc = ie(), Gs2 = _t$1(), rc = tc(Function.toString);
  sc(Gs2.inspectSource) || (Gs2.inspectSource = function(l) {
    return rc(l);
  });
  Ba2.exports = Gs2.inspectSource;
});
var Ra = v((Fd2, _a2) => {
  var ic = he$2(), ac = ie(), Ma2 = ic.WeakMap;
  _a2.exports = ac(Ma2) && /native code/.test(String(Ma2));
});
var Ua = v((Ld2, qa2) => {
  var nc = Os$1(), oc = Ms$1(), ja2 = nc("keys");
  qa2.exports = function(l) {
    return ja2[l] || (ja2[l] = oc(l));
  };
});
var Xs$1 = v((Od2, $a2) => {
  $a2.exports = {};
});
var Ka = v((Bd2, Va2) => {
  var lc = Ra(), za2 = he$2(), hc = Oe$1(), uc = Vs$1(), Ys2 = Ie$2(), Qs2 = _t$1(), cc = Ua(), pc = Xs$1(), Ha2 = "Object already initialized", Zs2 = za2.TypeError, fc = za2.WeakMap, qt2, nt, Ut, dc = function(l) {
    return Ut(l) ? nt(l) : qt2(l, {});
  }, mc = function(l) {
    return function(h) {
      var f;
      if (!hc(h) || (f = nt(h)).type !== l)
        throw Zs2("Incompatible receiver, " + l + " required");
      return f;
    };
  };
  lc || Qs2.state ? (de = Qs2.state || (Qs2.state = new fc()), de.get = de.get, de.has = de.has, de.set = de.set, qt2 = function(l, h) {
    if (de.has(l))
      throw Zs2(Ha2);
    return h.facade = l, de.set(l, h), h;
  }, nt = function(l) {
    return de.get(l) || {};
  }, Ut = function(l) {
    return de.has(l);
  }) : (Me2 = cc("state"), pc[Me2] = true, qt2 = function(l, h) {
    if (Ys2(l, Me2))
      throw Zs2(Ha2);
    return h.facade = l, uc(l, Me2, h), h;
  }, nt = function(l) {
    return Ys2(l, Me2) ? l[Me2] : {};
  }, Ut = function(l) {
    return Ys2(l, Me2);
  });
  var de, Me2;
  Va2.exports = { set: qt2, get: nt, has: Ut, enforce: dc, getterFor: mc };
});
var tr$1 = v((Md2, Ga2) => {
  var yc = ce$1(), xc = ie(), $t2 = Ie$2(), er2 = ve$1(), gc = Oa().CONFIGURABLE, Pc = Js$1(), Wa2 = Ka(), Ac = Wa2.enforce, Tc = Wa2.get, Ht = Object.defineProperty, vc = er2 && !yc(function() {
    return Ht(function() {
    }, "length", { value: 8 }).length !== 8;
  }), Ec = String(String).split("String"), Cc = Ga2.exports = function(l, h, f) {
    String(h).slice(0, 7) === "Symbol(" && (h = "[" + String(h).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), f && f.getter && (h = "get " + h), f && f.setter && (h = "set " + h), (!$t2(l, "name") || gc && l.name !== h) && (er2 ? Ht(l, "name", { value: h, configurable: true }) : l.name = h), vc && f && $t2(f, "arity") && l.length !== f.arity && Ht(l, "length", { value: f.arity });
    try {
      f && $t2(f, "constructor") && f.constructor ? er2 && Ht(l, "prototype", { writable: false }) : l.prototype && (l.prototype = void 0);
    } catch {
    }
    var d2 = Ac(l);
    return $t2(d2, "source") || (d2.source = Ec.join(typeof h == "string" ? h : "")), l;
  };
  Function.prototype.toString = Cc(function() {
    return xc(this) && Tc(this).source || Pc(this);
  }, "toString");
});
var Xa = v((_d2, Ja2) => {
  var bc = ie(), Sc = at(), wc = tr$1(), Ic = Mt$1();
  Ja2.exports = function(l, h, f, d2) {
    d2 || (d2 = {});
    var x = d2.enumerable, P = d2.name !== void 0 ? d2.name : h;
    if (bc(f) && wc(f, P, d2), d2.global)
      x ? l[h] = f : Ic(h, f);
    else {
      try {
        d2.unsafe ? l[h] && (x = true) : delete l[h];
      } catch {
      }
      x ? l[h] = f : Sc.f(l, h, { value: f, enumerable: false, configurable: !d2.nonConfigurable, writable: !d2.nonWritable });
    }
    return l;
  };
});
var Qa = v((Rd2, Ya2) => {
  var Nc = Math.ceil, kc = Math.floor;
  Ya2.exports = Math.trunc || function(h) {
    var f = +h;
    return (f > 0 ? kc : Nc)(f);
  };
});
var sr$1 = v((jd2, Za2) => {
  var Dc = Qa();
  Za2.exports = function(l) {
    var h = +l;
    return h !== h || h === 0 ? 0 : Dc(h);
  };
});
var tn = v((qd2, en2) => {
  var Fc = sr$1(), Lc = Math.max, Oc = Math.min;
  en2.exports = function(l, h) {
    var f = Fc(l);
    return f < 0 ? Lc(f + h, 0) : Oc(f, h);
  };
});
var rn = v((Ud2, sn2) => {
  var Bc = sr$1(), Mc = Math.min;
  sn2.exports = function(l) {
    return l > 0 ? Mc(Bc(l), 9007199254740991) : 0;
  };
});
var zt = v(($d2, an2) => {
  var _c2 = rn();
  an2.exports = function(l) {
    return _c2(l.length);
  };
});
var ln$1 = v((Hd2, on) => {
  var Rc = Lt$1(), jc = tn(), qc = zt(), nn2 = function(l) {
    return function(h, f, d2) {
      var x = Rc(h), P = qc(x), m = jc(d2, P), E;
      if (l && f != f) {
        for (; P > m; )
          if (E = x[m++], E != E)
            return true;
      } else
        for (; P > m; m++)
          if ((l || m in x) && x[m] === f)
            return l || m || 0;
      return !l && -1;
    };
  };
  on.exports = { includes: nn2(true), indexOf: nn2(false) };
});
var cn = v((zd2, un2) => {
  var Uc = pe$1(), rr2 = Ie$2(), $c = Lt$1(), Hc = ln$1().indexOf, zc = Xs$1(), hn2 = Uc([].push);
  un2.exports = function(l, h) {
    var f = $c(l), d2 = 0, x = [], P;
    for (P in f)
      !rr2(zc, P) && rr2(f, P) && hn2(x, P);
    for (; h.length > d2; )
      rr2(f, P = h[d2++]) && (~Hc(x, P) || hn2(x, P));
    return x;
  };
});
var fn$1 = v((Vd2, pn2) => {
  pn2.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
});
var mn = v((dn2) => {
  var Vc = cn(), Kc = fn$1(), Wc = Kc.concat("length", "prototype");
  dn2.f = Object.getOwnPropertyNames || function(h) {
    return Vc(h, Wc);
  };
});
var xn$1 = v((yn) => {
  yn.f = Object.getOwnPropertySymbols;
});
var Pn$1 = v((Gd2, gn2) => {
  var Gc = rt(), Jc = pe$1(), Xc = mn(), Yc = xn$1(), Qc = Rt$1(), Zc = Jc([].concat);
  gn2.exports = Gc("Reflect", "ownKeys") || function(h) {
    var f = Xc.f(Qc(h)), d2 = Yc.f;
    return d2 ? Zc(f, d2(h)) : f;
  };
});
var vn$1 = v((Jd2, Tn2) => {
  var An = Ie$2(), ep = Pn$1(), tp = qs$2(), sp = at();
  Tn2.exports = function(l, h, f) {
    for (var d2 = ep(h), x = sp.f, P = tp.f, m = 0; m < d2.length; m++) {
      var E = d2[m];
      !An(l, E) && !(f && An(f, E)) && x(l, E, P(h, E));
    }
  };
});
var Cn$1 = v((Xd2, En2) => {
  var rp = ce$1(), ip = ie(), ap = /#|\.prototype\./, ot2 = function(l, h) {
    var f = op[np(l)];
    return f == hp ? true : f == lp ? false : ip(h) ? rp(h) : !!h;
  }, np = ot2.normalize = function(l) {
    return String(l).replace(ap, ".").toLowerCase();
  }, op = ot2.data = {}, lp = ot2.NATIVE = "N", hp = ot2.POLYFILL = "P";
  En2.exports = ot2;
});
var ar$1 = v((Yd2, bn2) => {
  var ir2 = he$2(), up = qs$2().f, cp = Vs$1(), pp = Xa(), fp = Mt$1(), dp = vn$1(), mp = Cn$1();
  bn2.exports = function(l, h) {
    var f = l.target, d2 = l.global, x = l.stat, P, m, E, S, k, L;
    if (d2 ? m = ir2 : x ? m = ir2[f] || fp(f, {}) : m = (ir2[f] || {}).prototype, m)
      for (E in h) {
        if (k = h[E], l.dontCallGetSet ? (L = up(m, E), S = L && L.value) : S = m[E], P = mp(d2 ? E : f + (x ? "." : "#") + E, l.forced), !P && S !== void 0) {
          if (typeof k == typeof S)
            continue;
          dp(k, S);
        }
        (l.sham || S && S.sham) && cp(k, "sham", true), pp(m, E, k, l);
      }
  };
});
var Sn$1 = v(() => {
  var yp = ar$1(), nr2 = he$2();
  yp({ global: true, forced: nr2.globalThis !== nr2 }, { globalThis: nr2 });
});
var Nn$1 = v((em2, In2) => {
  var wn2 = tr$1(), xp = at();
  In2.exports = function(l, h, f) {
    return f.get && wn2(f.get, h, { getter: true }), f.set && wn2(f.set, h, { setter: true }), xp.f(l, h, f);
  };
});
var Dn = v((tm2, kn2) => {
  var gp = Rt$1();
  kn2.exports = function() {
    var l = gp(this), h = "";
    return l.hasIndices && (h += "d"), l.global && (h += "g"), l.ignoreCase && (h += "i"), l.multiline && (h += "m"), l.dotAll && (h += "s"), l.unicode && (h += "u"), l.unicodeSets && (h += "v"), l.sticky && (h += "y"), h;
  };
});
var or$1 = v((sm2, On2) => {
  var bp = st$1();
  On2.exports = Array.isArray || function(h) {
    return bp(h) == "Array";
  };
});
var Mn$2 = v((rm2, Bn2) => {
  var Sp = TypeError, wp = 9007199254740991;
  Bn2.exports = function(l) {
    if (l > wp)
      throw Sp("Maximum allowed index exceeded");
    return l;
  };
});
var Rn$2 = v((im2, _n2) => {
  var Ip = st$1(), Np = pe$1();
  _n2.exports = function(l) {
    if (Ip(l) === "Function")
      return Np(l);
  };
});
var Un = v((am2, qn2) => {
  var jn2 = Rn$2(), kp = Bt(), Dp = kt$1(), Fp = jn2(jn2.bind);
  qn2.exports = function(l, h) {
    return kp(l), h === void 0 ? l : Dp ? Fp(l, h) : function() {
      return l.apply(h, arguments);
    };
  };
});
var zn$1 = v((nm2, Hn2) => {
  var Lp = or$1(), Op = zt(), Bp = Mn$2(), Mp = Un(), $n2 = function(l, h, f, d2, x, P, m, E) {
    for (var S = x, k = 0, L = m ? Mp(m, E) : false, N2, O; k < d2; )
      k in f && (N2 = L ? L(f[k], k, h) : f[k], P > 0 && Lp(N2) ? (O = Op(N2), S = $n2(l, h, N2, O, S, P - 1) - 1) : (Bp(S + 1), l[S] = N2), S++), k++;
    return S;
  };
  Hn2.exports = $n2;
});
var Wn$1 = v((om2, Kn2) => {
  var _p = it$1(), Rp = _p("toStringTag"), Vn2 = {};
  Vn2[Rp] = "z";
  Kn2.exports = String(Vn2) === "[object z]";
});
var Jn = v((lm2, Gn2) => {
  var jp = Wn$1(), qp = ie(), Vt2 = st$1(), Up = it$1(), $p = Up("toStringTag"), Hp = Object, zp = Vt2(function() {
    return arguments;
  }()) == "Arguments", Vp = function(l, h) {
    try {
      return l[h];
    } catch {
    }
  };
  Gn2.exports = jp ? Vt2 : function(l) {
    var h, f, d2;
    return l === void 0 ? "Undefined" : l === null ? "Null" : typeof (f = Vp(h = Hp(l), $p)) == "string" ? f : zp ? Vt2(h) : (d2 = Vt2(h)) == "Object" && qp(h.callee) ? "Arguments" : d2;
  };
});
var to$1 = v((hm2, eo2) => {
  var Kp = pe$1(), Wp = ce$1(), Xn2 = ie(), Gp = Jn(), Jp = rt(), Xp = Js$1(), Yn2 = function() {
  }, Yp = [], Qn2 = Jp("Reflect", "construct"), lr2 = /^\s*(?:class|function)\b/, Qp = Kp(lr2.exec), Zp = !lr2.exec(Yn2), lt2 = function(h) {
    if (!Xn2(h))
      return false;
    try {
      return Qn2(Yn2, Yp, h), true;
    } catch {
      return false;
    }
  }, Zn2 = function(h) {
    if (!Xn2(h))
      return false;
    switch (Gp(h)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return false;
    }
    try {
      return Zp || !!Qp(lr2, Xp(h));
    } catch {
      return true;
    }
  };
  Zn2.sham = true;
  eo2.exports = !Qn2 || Wp(function() {
    var l;
    return lt2(lt2.call) || !lt2(Object) || !lt2(function() {
      l = true;
    }) || l;
  }) ? Zn2 : lt2;
});
var ao$1 = v((um2, io2) => {
  var so2 = or$1(), ef2 = to$1(), tf2 = Oe$1(), sf2 = it$1(), rf2 = sf2("species"), ro2 = Array;
  io2.exports = function(l) {
    var h;
    return so2(l) && (h = l.constructor, ef2(h) && (h === ro2 || so2(h.prototype)) ? h = void 0 : tf2(h) && (h = h[rf2], h === null && (h = void 0))), h === void 0 ? ro2 : h;
  };
});
var oo$1 = v((cm2, no2) => {
  var af2 = ao$1();
  no2.exports = function(l, h) {
    return new (af2(l))(h === 0 ? 0 : h);
  };
});
Sn$1();
var Pp = he$2(), Ap = ve$1(), Tp = Nn$1(), vp = Dn(), Ep = ce$1(), Fn = Pp.RegExp, Ln$1 = Fn.prototype, Cp = Ap && Ep(function() {
  var l = true;
  try {
    Fn(".", "d");
  } catch {
    l = false;
  }
  var h = {}, f = "", d2 = l ? "dgimsy" : "gimsy", x = function(S, k) {
    Object.defineProperty(h, S, { get: function() {
      return f += k, true;
    } });
  }, P = { dotAll: "s", global: "g", ignoreCase: "i", multiline: "m", sticky: "y" };
  l && (P.hasIndices = "d");
  for (var m in P)
    x(m, P[m]);
  var E = Object.getOwnPropertyDescriptor(Ln$1, "flags").get.call(h);
  return E !== d2 || f !== d2;
});
Cp && Tp(Ln$1, "flags", { configurable: true, get: vp });
var nf$1 = ar$1(), of$1 = zn$1(), lf$1 = Bt(), hf$1 = Bs$1(), uf$1 = zt(), cf$1 = oo$1();
nf$1({ target: "Array", proto: true }, { flatMap: function(h) {
  var f = hf$1(this), d2 = uf$1(f), x;
  return lf$1(h), x = cf$1(f, 0), x.length = of$1(x, f, f, d2, 0, 1, h, arguments.length > 1 ? arguments[1] : void 0), x;
} });
var pr$1 = Object.defineProperty, pf$1 = Object.getOwnPropertyDescriptor, fr$1 = Object.getOwnPropertyNames, ff$1 = Object.prototype.hasOwnProperty, lo$1 = (l, h) => function() {
  return l && (h = (0, l[fr$1(l)[0]])(l = 0)), h;
}, $ = (l, h) => function() {
  return h || (0, l[fr$1(l)[0]])((h = { exports: {} }).exports, h), h.exports;
}, df$1 = (l, h) => {
  for (var f in h)
    pr$1(l, f, { get: h[f], enumerable: true });
}, mf$1 = (l, h, f, d2) => {
  if (h && typeof h == "object" || typeof h == "function")
    for (let x of fr$1(h))
      !ff$1.call(l, x) && x !== f && pr$1(l, x, { get: () => h[x], enumerable: !(d2 = pf$1(h, x)) || d2.enumerable });
  return l;
}, yf$1 = (l) => mf$1(pr$1({}, "__esModule", { value: true }), l), U = lo$1({ "<define:process>"() {
} }), xf$1 = $({ "src/utils/try-combinations.js"(l, h) {
  U();
  function f() {
    let d2;
    for (var x = arguments.length, P = new Array(x), m = 0; m < x; m++)
      P[m] = arguments[m];
    for (let [E, S] of P.entries())
      try {
        return { result: S() };
      } catch (k) {
        E === 0 && (d2 = k);
      }
    return { error: d2 };
  }
  h.exports = f;
} }), ho$1 = $({ "src/language-js/utils/get-shebang.js"(l, h) {
  U();
  function f(d2) {
    if (!d2.startsWith("#!"))
      return "";
    let x = d2.indexOf(`
`);
    return x === -1 ? d2 : d2.slice(0, x);
  }
  h.exports = f;
} }), gf$1 = $({ "src/utils/text/skip-inline-comment.js"(l, h) {
  U();
  function f(d2, x) {
    if (x === false)
      return false;
    if (d2.charAt(x) === "/" && d2.charAt(x + 1) === "*") {
      for (let P = x + 2; P < d2.length; ++P)
        if (d2.charAt(P) === "*" && d2.charAt(P + 1) === "/")
          return P + 2;
    }
    return x;
  }
  h.exports = f;
} }), Pf$1 = $({ "src/utils/text/skip-newline.js"(l, h) {
  U();
  function f(d2, x, P) {
    let m = P && P.backwards;
    if (x === false)
      return false;
    let E = d2.charAt(x);
    if (m) {
      if (d2.charAt(x - 1) === "\r" && E === `
`)
        return x - 2;
      if (E === `
` || E === "\r" || E === "\u2028" || E === "\u2029")
        return x - 1;
    } else {
      if (E === "\r" && d2.charAt(x + 1) === `
`)
        return x + 2;
      if (E === `
` || E === "\r" || E === "\u2028" || E === "\u2029")
        return x + 1;
    }
    return x;
  }
  h.exports = f;
} }), uo$1 = $({ "src/utils/text/skip.js"(l, h) {
  U();
  function f(E) {
    return (S, k, L) => {
      let N2 = L && L.backwards;
      if (k === false)
        return false;
      let { length: O } = S, A = k;
      for (; A >= 0 && A < O; ) {
        let _ = S.charAt(A);
        if (E instanceof RegExp) {
          if (!E.test(_))
            return A;
        } else if (!E.includes(_))
          return A;
        N2 ? A-- : A++;
      }
      return A === -1 || A === O ? A : false;
    };
  }
  var d2 = f(/\s/), x = f(" 	"), P = f(",; 	"), m = f(/[^\n\r]/);
  h.exports = { skipWhitespace: d2, skipSpaces: x, skipToLineEnd: P, skipEverythingButNewLine: m };
} }), Af$1 = $({ "src/utils/text/skip-trailing-comment.js"(l, h) {
  U();
  var { skipEverythingButNewLine: f } = uo$1();
  function d2(x, P) {
    return P === false ? false : x.charAt(P) === "/" && x.charAt(P + 1) === "/" ? f(x, P) : P;
  }
  h.exports = d2;
} }), Tf$1 = $({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(l, h) {
  U();
  var f = gf$1(), d2 = Pf$1(), x = Af$1(), { skipSpaces: P } = uo$1();
  function m(E, S) {
    let k = null, L = S;
    for (; L !== k; )
      k = L, L = P(E, L), L = f(E, L), L = x(E, L), L = d2(E, L);
    return L;
  }
  h.exports = m;
} }), co$1 = {};
df$1(co$1, { EOL: () => cr$1, arch: () => vf$1, cpus: () => Po$1, default: () => Co$1, endianness: () => po$1, freemem: () => xo$1, getNetworkInterfaces: () => Eo$1, hostname: () => fo$1, loadavg: () => mo$1, networkInterfaces: () => vo$1, platform: () => Ef$1, release: () => To$1, tmpDir: () => hr$1, tmpdir: () => ur, totalmem: () => go$1, type: () => Ao$1, uptime: () => yo$1 });
function po$1() {
  if (typeof Kt > "u") {
    var l = new ArrayBuffer(2), h = new Uint8Array(l), f = new Uint16Array(l);
    if (h[0] = 1, h[1] = 2, f[0] === 258)
      Kt = "BE";
    else if (f[0] === 513)
      Kt = "LE";
    else
      throw new Error("unable to figure out endianess");
  }
  return Kt;
}
function fo$1() {
  return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
}
function mo$1() {
  return [];
}
function yo$1() {
  return 0;
}
function xo$1() {
  return Number.MAX_VALUE;
}
function go$1() {
  return Number.MAX_VALUE;
}
function Po$1() {
  return [];
}
function Ao$1() {
  return "Browser";
}
function To$1() {
  return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
}
function vo$1() {
}
function Eo$1() {
}
function vf$1() {
  return "javascript";
}
function Ef$1() {
  return "browser";
}
function hr$1() {
  return "/tmp";
}
var Kt, ur, cr$1, Co$1, Cf$1 = lo$1({ "node-modules-polyfills:os"() {
  U(), ur = hr$1, cr$1 = `
`, Co$1 = { EOL: cr$1, tmpdir: ur, tmpDir: hr$1, networkInterfaces: vo$1, getNetworkInterfaces: Eo$1, release: To$1, type: Ao$1, cpus: Po$1, totalmem: go$1, freemem: xo$1, uptime: yo$1, loadavg: mo$1, hostname: fo$1, endianness: po$1 };
} }), bf$1 = $({ "node-modules-polyfills-commonjs:os"(l, h) {
  U();
  var f = (Cf$1(), yf$1(co$1));
  if (f && f.default) {
    h.exports = f.default;
    for (let d2 in f)
      h.exports[d2] = f[d2];
  } else
    f && (h.exports = f);
} }), Sf$1 = $({ "node_modules/detect-newline/index.js"(l, h) {
  U();
  var f = (d2) => {
    if (typeof d2 != "string")
      throw new TypeError("Expected a string");
    let x = d2.match(/(?:\r?\n)/g) || [];
    if (x.length === 0)
      return;
    let P = x.filter((E) => E === `\r
`).length, m = x.length - P;
    return P > m ? `\r
` : `
`;
  };
  h.exports = f, h.exports.graceful = (d2) => typeof d2 == "string" && f(d2) || `
`;
} }), wf$1 = $({ "node_modules/jest-docblock/build/index.js"(l) {
  U(), Object.defineProperty(l, "__esModule", { value: true }), l.extract = A, l.parse = W, l.parseWithComments = I2, l.print = F, l.strip = _;
  function h() {
    let M2 = bf$1();
    return h = function() {
      return M2;
    }, M2;
  }
  function f() {
    let M2 = d2(Sf$1());
    return f = function() {
      return M2;
    }, M2;
  }
  function d2(M2) {
    return M2 && M2.__esModule ? M2 : { default: M2 };
  }
  var x = /\*\/$/, P = /^\/\*\*?/, m = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, E = /(^|\s+)\/\/([^\r\n]*)/g, S = /^(\r?\n)+/, k = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, L = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, N2 = /(\r?\n|^) *\* ?/g, O = [];
  function A(M2) {
    let V = M2.match(m);
    return V ? V[0].trimLeft() : "";
  }
  function _(M2) {
    let V = M2.match(m);
    return V && V[0] ? M2.substring(V[0].length) : M2;
  }
  function W(M2) {
    return I2(M2).pragmas;
  }
  function I2(M2) {
    let V = (0, f().default)(M2) || h().EOL;
    M2 = M2.replace(P, "").replace(x, "").replace(N2, "$1");
    let ee2 = "";
    for (; ee2 !== M2; )
      ee2 = M2, M2 = M2.replace(k, `${V}$1 $2${V}`);
    M2 = M2.replace(S, "").trimRight();
    let b = /* @__PURE__ */ Object.create(null), B = M2.replace(L, "").replace(S, "").trimRight(), te2;
    for (; te2 = L.exec(M2); ) {
      let R2 = te2[2].replace(E, "");
      typeof b[te2[1]] == "string" || Array.isArray(b[te2[1]]) ? b[te2[1]] = O.concat(b[te2[1]], R2) : b[te2[1]] = R2;
    }
    return { comments: B, pragmas: b };
  }
  function F(M2) {
    let { comments: V = "", pragmas: ee2 = {} } = M2, b = (0, f().default)(V) || h().EOL, B = "/**", te2 = " *", R2 = " */", ae2 = Object.keys(ee2), se2 = ae2.map((H) => z(H, ee2[H])).reduce((H, X) => H.concat(X), []).map((H) => `${te2} ${H}${b}`).join("");
    if (!V) {
      if (ae2.length === 0)
        return "";
      if (ae2.length === 1 && !Array.isArray(ee2[ae2[0]])) {
        let H = ee2[ae2[0]];
        return `${B} ${z(ae2[0], H)[0]}${R2}`;
      }
    }
    let _e2 = V.split(b).map((H) => `${te2} ${H}`).join(b) + b;
    return B + b + (V ? _e2 : "") + (V && ae2.length ? te2 + b : "") + se2 + R2;
  }
  function z(M2, V) {
    return O.concat(V).map((ee2) => `@${M2} ${ee2}`.trim());
  }
} }), If$1 = $({ "src/common/end-of-line.js"(l, h) {
  U();
  function f(m) {
    let E = m.indexOf("\r");
    return E >= 0 ? m.charAt(E + 1) === `
` ? "crlf" : "cr" : "lf";
  }
  function d2(m) {
    switch (m) {
      case "cr":
        return "\r";
      case "crlf":
        return `\r
`;
      default:
        return `
`;
    }
  }
  function x(m, E) {
    let S;
    switch (E) {
      case `
`:
        S = /\n/g;
        break;
      case "\r":
        S = /\r/g;
        break;
      case `\r
`:
        S = /\r\n/g;
        break;
      default:
        throw new Error(`Unexpected "eol" ${JSON.stringify(E)}.`);
    }
    let k = m.match(S);
    return k ? k.length : 0;
  }
  function P(m) {
    return m.replace(/\r\n?/g, `
`);
  }
  h.exports = { guessEndOfLine: f, convertEndOfLineToChars: d2, countEndOfLineChars: x, normalizeEndOfLine: P };
} }), Nf$1 = $({ "src/language-js/pragma.js"(l, h) {
  U();
  var { parseWithComments: f, strip: d2, extract: x, print: P } = wf$1(), { normalizeEndOfLine: m } = If$1(), E = ho$1();
  function S(N2) {
    let O = E(N2);
    O && (N2 = N2.slice(O.length + 1));
    let A = x(N2), { pragmas: _, comments: W } = f(A);
    return { shebang: O, text: N2, pragmas: _, comments: W };
  }
  function k(N2) {
    let O = Object.keys(S(N2).pragmas);
    return O.includes("prettier") || O.includes("format");
  }
  function L(N2) {
    let { shebang: O, text: A, pragmas: _, comments: W } = S(N2), I2 = d2(A), F = P({ pragmas: Object.assign({ format: "" }, _), comments: W.trimStart() });
    return (O ? `${O}
` : "") + m(F) + (I2.startsWith(`
`) ? `
` : `

`) + I2;
  }
  h.exports = { hasPragma: k, insertPragma: L };
} }), bo$1 = $({ "src/utils/is-non-empty-array.js"(l, h) {
  U();
  function f(d2) {
    return Array.isArray(d2) && d2.length > 0;
  }
  h.exports = f;
} }), So$1 = $({ "src/language-js/loc.js"(l, h) {
  U();
  var f = bo$1();
  function d2(S) {
    var k, L;
    let N2 = S.range ? S.range[0] : S.start, O = (k = (L = S.declaration) === null || L === void 0 ? void 0 : L.decorators) !== null && k !== void 0 ? k : S.decorators;
    return f(O) ? Math.min(d2(O[0]), N2) : N2;
  }
  function x(S) {
    return S.range ? S.range[1] : S.end;
  }
  function P(S, k) {
    let L = d2(S);
    return Number.isInteger(L) && L === d2(k);
  }
  function m(S, k) {
    let L = x(S);
    return Number.isInteger(L) && L === x(k);
  }
  function E(S, k) {
    return P(S, k) && m(S, k);
  }
  h.exports = { locStart: d2, locEnd: x, hasSameLocStart: P, hasSameLoc: E };
} }), wo$1 = $({ "src/language-js/parse/utils/create-parser.js"(l, h) {
  U();
  var { hasPragma: f } = Nf$1(), { locStart: d2, locEnd: x } = So$1();
  function P(m) {
    return m = typeof m == "function" ? { parse: m } : m, Object.assign({ astFormat: "estree", hasPragma: f, locStart: d2, locEnd: x }, m);
  }
  h.exports = P;
} }), dr$2 = $({ "src/common/parser-create-error.js"(l, h) {
  U();
  function f(d2, x) {
    let P = new SyntaxError(d2 + " (" + x.start.line + ":" + x.start.column + ")");
    return P.loc = x, P;
  }
  h.exports = f;
} }), Io$1 = $({ "src/language-js/parse/utils/create-babel-parse-error.js"(l, h) {
  U();
  var f = dr$2();
  function d2(x) {
    let { message: P, loc: m } = x;
    return f(P.replace(/ \(.*\)/, ""), { start: { line: m ? m.line : 0, column: m ? m.column + 1 : 0 } });
  }
  h.exports = d2;
} }), kf$1 = $({ "src/language-js/utils/is-ts-keyword-type.js"(l, h) {
  U();
  function f(d2) {
    let { type: x } = d2;
    return x.startsWith("TS") && x.endsWith("Keyword");
  }
  h.exports = f;
} }), Df = $({ "src/language-js/utils/is-block-comment.js"(l, h) {
  U();
  var f = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]), d2 = (x) => f.has(x == null ? void 0 : x.type);
  h.exports = d2;
} }), Ff = $({ "src/language-js/utils/is-type-cast-comment.js"(l, h) {
  U();
  var f = Df();
  function d2(x) {
    return f(x) && x.value[0] === "*" && /@(?:type|satisfies)\b/.test(x.value);
  }
  h.exports = d2;
} }), Lf = $({ "src/utils/get-last.js"(l, h) {
  U();
  var f = (d2) => d2[d2.length - 1];
  h.exports = f;
} }), Of$1 = $({ "src/language-js/parse/postprocess/visit-node.js"(l, h) {
  U();
  function f(d2, x) {
    if (Array.isArray(d2)) {
      for (let P = 0; P < d2.length; P++)
        d2[P] = f(d2[P], x);
      return d2;
    }
    if (d2 && typeof d2 == "object" && typeof d2.type == "string") {
      let P = Object.keys(d2);
      for (let m = 0; m < P.length; m++)
        d2[P[m]] = f(d2[P[m]], x);
      return x(d2) || d2;
    }
    return d2;
  }
  h.exports = f;
} }), Bf = $({ "src/language-js/parse/postprocess/throw-syntax-error.js"(l, h) {
  U();
  var f = dr$2();
  function d2(x, P) {
    let { start: m, end: E } = x.loc;
    throw f(P, { start: { line: m.line, column: m.column + 1 }, end: { line: E.line, column: E.column + 1 } });
  }
  h.exports = d2;
} }), Mf$1 = $({ "src/language-js/parse/postprocess/index.js"(l, h) {
  U();
  var { locStart: f, locEnd: d2 } = So$1(), x = kf$1(), P = Ff(), m = Lf(), E = Of$1(), S = Bf();
  function k(A, _) {
    if (_.parser !== "typescript" && _.parser !== "flow" && _.parser !== "acorn" && _.parser !== "espree" && _.parser !== "meriyah") {
      let I2 = /* @__PURE__ */ new Set();
      A = E(A, (F) => {
        F.leadingComments && F.leadingComments.some(P) && I2.add(f(F));
      }), A = E(A, (F) => {
        if (F.type === "ParenthesizedExpression") {
          let { expression: z } = F;
          if (z.type === "TypeCastExpression")
            return z.range = F.range, z;
          let M2 = f(F);
          if (!I2.has(M2))
            return z.extra = Object.assign(Object.assign({}, z.extra), {}, { parenthesized: true }), z;
        }
      });
    }
    return A = E(A, (I2) => {
      switch (I2.type) {
        case "ChainExpression":
          return L(I2.expression);
        case "LogicalExpression": {
          if (N2(I2))
            return O(I2);
          break;
        }
        case "VariableDeclaration": {
          let F = m(I2.declarations);
          F && F.init && W(I2, F);
          break;
        }
        case "TSParenthesizedType":
          return x(I2.typeAnnotation) || I2.typeAnnotation.type === "TSThisType" || (I2.typeAnnotation.range = [f(I2), d2(I2)]), I2.typeAnnotation;
        case "TSTypeParameter":
          if (typeof I2.name == "string") {
            let F = f(I2);
            I2.name = { type: "Identifier", name: I2.name, range: [F, F + I2.name.length] };
          }
          break;
        case "ObjectExpression":
          if (_.parser === "typescript") {
            let F = I2.properties.find((z) => z.type === "Property" && z.value.type === "TSEmptyBodyFunctionExpression");
            F && S(F.value, "Unexpected token.");
          }
          break;
        case "SequenceExpression": {
          let F = m(I2.expressions);
          I2.range = [f(I2), Math.min(d2(F), d2(I2))];
          break;
        }
        case "TopicReference":
          _.__isUsingHackPipeline = true;
          break;
        case "ExportAllDeclaration": {
          let { exported: F } = I2;
          if (_.parser === "meriyah" && F && F.type === "Identifier") {
            let z = _.originalText.slice(f(F), d2(F));
            (z.startsWith('"') || z.startsWith("'")) && (I2.exported = Object.assign(Object.assign({}, I2.exported), {}, { type: "Literal", value: I2.exported.name, raw: z }));
          }
          break;
        }
        case "PropertyDefinition":
          if (_.parser === "meriyah" && I2.static && !I2.computed && !I2.key) {
            let F = "static", z = f(I2);
            Object.assign(I2, { static: false, key: { type: "Identifier", name: F, range: [z, z + F.length] } });
          }
          break;
      }
    }), A;
    function W(I2, F) {
      _.originalText[d2(F)] !== ";" && (I2.range = [f(I2), d2(F)]);
    }
  }
  function L(A) {
    switch (A.type) {
      case "CallExpression":
        A.type = "OptionalCallExpression", A.callee = L(A.callee);
        break;
      case "MemberExpression":
        A.type = "OptionalMemberExpression", A.object = L(A.object);
        break;
      case "TSNonNullExpression":
        A.expression = L(A.expression);
        break;
    }
    return A;
  }
  function N2(A) {
    return A.type === "LogicalExpression" && A.right.type === "LogicalExpression" && A.operator === A.right.operator;
  }
  function O(A) {
    return N2(A) ? O({ type: "LogicalExpression", operator: A.operator, left: O({ type: "LogicalExpression", operator: A.operator, left: A.left, right: A.right.left, range: [f(A.left), d2(A.right.left)] }), right: A.right.right, range: [f(A), d2(A)] }) : A;
  }
  h.exports = k;
} }), No$1 = $({ "node_modules/@babel/parser/lib/index.js"(l) {
  U(), Object.defineProperty(l, "__esModule", { value: true });
  var h = { sourceType: "script", sourceFilename: void 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowNewTargetOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, plugins: [], strictMode: null, ranges: false, tokens: false, createParenthesizedExpressions: false, errorRecovery: false, attachComment: true, annexB: true };
  function f(t) {
    if (t && t.annexB != null && t.annexB !== false)
      throw new Error("The `annexB` option can only be set to `false`.");
    let r = {};
    for (let e of Object.keys(h))
      r[e] = t && t[e] != null ? t[e] : h[e];
    return r;
  }
  var d2 = class {
    constructor(t, r) {
      this.token = void 0, this.preserveSpace = void 0, this.token = t, this.preserveSpace = !!r;
    }
  }, x = { brace: new d2("{"), j_oTag: new d2("<tag"), j_cTag: new d2("</tag"), j_expr: new d2("<tag>...</tag>", true) };
  x.template = new d2("`", true);
  var P = true, m = true, E = true, S = true, k = true, L = true, N2 = class {
    constructor(t) {
      let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = t, this.keyword = r.keyword, this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.rightAssociative = !!r.rightAssociative, this.isLoop = !!r.isLoop, this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop != null ? r.binop : null, this.updateContext = null;
    }
  }, O = /* @__PURE__ */ new Map();
  function A(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    r.keyword = t;
    let e = b(t, r);
    return O.set(t, e), e;
  }
  function _(t, r) {
    return b(t, { beforeExpr: P, binop: r });
  }
  var W = -1, I2 = [], F = [], z = [], M2 = [], V = [], ee2 = [];
  function b(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var e, s, i, a;
    return ++W, F.push(t), z.push((e = r.binop) != null ? e : -1), M2.push((s = r.beforeExpr) != null ? s : false), V.push((i = r.startsExpr) != null ? i : false), ee2.push((a = r.prefix) != null ? a : false), I2.push(new N2(t, r)), W;
  }
  function B(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var e, s, i, a;
    return ++W, O.set(t, W), F.push(t), z.push((e = r.binop) != null ? e : -1), M2.push((s = r.beforeExpr) != null ? s : false), V.push((i = r.startsExpr) != null ? i : false), ee2.push((a = r.prefix) != null ? a : false), I2.push(new N2("name", r)), W;
  }
  var te2 = { bracketL: b("[", { beforeExpr: P, startsExpr: m }), bracketHashL: b("#[", { beforeExpr: P, startsExpr: m }), bracketBarL: b("[|", { beforeExpr: P, startsExpr: m }), bracketR: b("]"), bracketBarR: b("|]"), braceL: b("{", { beforeExpr: P, startsExpr: m }), braceBarL: b("{|", { beforeExpr: P, startsExpr: m }), braceHashL: b("#{", { beforeExpr: P, startsExpr: m }), braceR: b("}"), braceBarR: b("|}"), parenL: b("(", { beforeExpr: P, startsExpr: m }), parenR: b(")"), comma: b(",", { beforeExpr: P }), semi: b(";", { beforeExpr: P }), colon: b(":", { beforeExpr: P }), doubleColon: b("::", { beforeExpr: P }), dot: b("."), question: b("?", { beforeExpr: P }), questionDot: b("?."), arrow: b("=>", { beforeExpr: P }), template: b("template"), ellipsis: b("...", { beforeExpr: P }), backQuote: b("`", { startsExpr: m }), dollarBraceL: b("${", { beforeExpr: P, startsExpr: m }), templateTail: b("...`", { startsExpr: m }), templateNonTail: b("...${", { beforeExpr: P, startsExpr: m }), at: b("@"), hash: b("#", { startsExpr: m }), interpreterDirective: b("#!..."), eq: b("=", { beforeExpr: P, isAssign: S }), assign: b("_=", { beforeExpr: P, isAssign: S }), slashAssign: b("_=", { beforeExpr: P, isAssign: S }), xorAssign: b("_=", { beforeExpr: P, isAssign: S }), moduloAssign: b("_=", { beforeExpr: P, isAssign: S }), incDec: b("++/--", { prefix: k, postfix: L, startsExpr: m }), bang: b("!", { beforeExpr: P, prefix: k, startsExpr: m }), tilde: b("~", { beforeExpr: P, prefix: k, startsExpr: m }), doubleCaret: b("^^", { startsExpr: m }), doubleAt: b("@@", { startsExpr: m }), pipeline: _("|>", 0), nullishCoalescing: _("??", 1), logicalOR: _("||", 1), logicalAND: _("&&", 2), bitwiseOR: _("|", 3), bitwiseXOR: _("^", 4), bitwiseAND: _("&", 5), equality: _("==/!=/===/!==", 6), lt: _("</>/<=/>=", 7), gt: _("</>/<=/>=", 7), relational: _("</>/<=/>=", 7), bitShift: _("<</>>/>>>", 8), bitShiftL: _("<</>>/>>>", 8), bitShiftR: _("<</>>/>>>", 8), plusMin: b("+/-", { beforeExpr: P, binop: 9, prefix: k, startsExpr: m }), modulo: b("%", { binop: 10, startsExpr: m }), star: b("*", { binop: 10 }), slash: _("/", 10), exponent: b("**", { beforeExpr: P, binop: 11, rightAssociative: true }), _in: A("in", { beforeExpr: P, binop: 7 }), _instanceof: A("instanceof", { beforeExpr: P, binop: 7 }), _break: A("break"), _case: A("case", { beforeExpr: P }), _catch: A("catch"), _continue: A("continue"), _debugger: A("debugger"), _default: A("default", { beforeExpr: P }), _else: A("else", { beforeExpr: P }), _finally: A("finally"), _function: A("function", { startsExpr: m }), _if: A("if"), _return: A("return", { beforeExpr: P }), _switch: A("switch"), _throw: A("throw", { beforeExpr: P, prefix: k, startsExpr: m }), _try: A("try"), _var: A("var"), _const: A("const"), _with: A("with"), _new: A("new", { beforeExpr: P, startsExpr: m }), _this: A("this", { startsExpr: m }), _super: A("super", { startsExpr: m }), _class: A("class", { startsExpr: m }), _extends: A("extends", { beforeExpr: P }), _export: A("export"), _import: A("import", { startsExpr: m }), _null: A("null", { startsExpr: m }), _true: A("true", { startsExpr: m }), _false: A("false", { startsExpr: m }), _typeof: A("typeof", { beforeExpr: P, prefix: k, startsExpr: m }), _void: A("void", { beforeExpr: P, prefix: k, startsExpr: m }), _delete: A("delete", { beforeExpr: P, prefix: k, startsExpr: m }), _do: A("do", { isLoop: E, beforeExpr: P }), _for: A("for", { isLoop: E }), _while: A("while", { isLoop: E }), _as: B("as", { startsExpr: m }), _assert: B("assert", { startsExpr: m }), _async: B("async", { startsExpr: m }), _await: B("await", { startsExpr: m }), _from: B("from", { startsExpr: m }), _get: B("get", { startsExpr: m }), _let: B("let", { startsExpr: m }), _meta: B("meta", { startsExpr: m }), _of: B("of", { startsExpr: m }), _sent: B("sent", { startsExpr: m }), _set: B("set", { startsExpr: m }), _static: B("static", { startsExpr: m }), _using: B("using", { startsExpr: m }), _yield: B("yield", { startsExpr: m }), _asserts: B("asserts", { startsExpr: m }), _checks: B("checks", { startsExpr: m }), _exports: B("exports", { startsExpr: m }), _global: B("global", { startsExpr: m }), _implements: B("implements", { startsExpr: m }), _intrinsic: B("intrinsic", { startsExpr: m }), _infer: B("infer", { startsExpr: m }), _is: B("is", { startsExpr: m }), _mixins: B("mixins", { startsExpr: m }), _proto: B("proto", { startsExpr: m }), _require: B("require", { startsExpr: m }), _satisfies: B("satisfies", { startsExpr: m }), _keyof: B("keyof", { startsExpr: m }), _readonly: B("readonly", { startsExpr: m }), _unique: B("unique", { startsExpr: m }), _abstract: B("abstract", { startsExpr: m }), _declare: B("declare", { startsExpr: m }), _enum: B("enum", { startsExpr: m }), _module: B("module", { startsExpr: m }), _namespace: B("namespace", { startsExpr: m }), _interface: B("interface", { startsExpr: m }), _type: B("type", { startsExpr: m }), _opaque: B("opaque", { startsExpr: m }), name: b("name", { startsExpr: m }), string: b("string", { startsExpr: m }), num: b("num", { startsExpr: m }), bigint: b("bigint", { startsExpr: m }), decimal: b("decimal", { startsExpr: m }), regexp: b("regexp", { startsExpr: m }), privateName: b("#name", { startsExpr: m }), eof: b("eof"), jsxName: b("jsxName"), jsxText: b("jsxText", { beforeExpr: true }), jsxTagStart: b("jsxTagStart", { startsExpr: true }), jsxTagEnd: b("jsxTagEnd"), placeholder: b("%%", { startsExpr: true }) };
  function R2(t) {
    return t >= 93 && t <= 130;
  }
  function ae2(t) {
    return t <= 92;
  }
  function se2(t) {
    return t >= 58 && t <= 130;
  }
  function _e2(t) {
    return t >= 58 && t <= 134;
  }
  function H(t) {
    return M2[t];
  }
  function X(t) {
    return V[t];
  }
  function ye2(t) {
    return t >= 29 && t <= 33;
  }
  function ne2(t) {
    return t >= 127 && t <= 129;
  }
  function oe(t) {
    return t >= 90 && t <= 92;
  }
  function Ee(t) {
    return t >= 58 && t <= 92;
  }
  function le2(t) {
    return t >= 39 && t <= 59;
  }
  function ue2(t) {
    return t === 34;
  }
  function ht2(t) {
    return ee2[t];
  }
  function ut2(t) {
    return t >= 119 && t <= 121;
  }
  function Wt(t) {
    return t >= 122 && t <= 128;
  }
  function Y(t) {
    return F[t];
  }
  function Re2(t) {
    return z[t];
  }
  function Gt2(t) {
    return t === 57;
  }
  function ct2(t) {
    return t >= 24 && t <= 25;
  }
  function xe2(t) {
    return I2[t];
  }
  I2[8].updateContext = (t) => {
    t.pop();
  }, I2[5].updateContext = I2[7].updateContext = I2[23].updateContext = (t) => {
    t.push(x.brace);
  }, I2[22].updateContext = (t) => {
    t[t.length - 1] === x.template ? t.pop() : t.push(x.template);
  }, I2[140].updateContext = (t) => {
    t.push(x.j_expr, x.j_oTag);
  };
  function pt2(t, r) {
    if (t == null)
      return {};
    var e = {}, s = Object.keys(t), i, a;
    for (a = 0; a < s.length; a++)
      i = s[a], !(r.indexOf(i) >= 0) && (e[i] = t[i]);
    return e;
  }
  var Ce2 = class {
    constructor(t, r, e) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = t, this.column = r, this.index = e;
    }
  }, ft2 = class {
    constructor(t, r) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t, this.end = r;
    }
  };
  function re(t, r) {
    let { line: e, column: s, index: i } = t;
    return new Ce2(e, s + r, i + r);
  }
  var Jt2 = { SyntaxError: "BABEL_PARSER_SYNTAX_ERROR", SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" }, ko2 = function(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : t.length - 1;
    return { get() {
      return t.reduce((e, s) => e[s], this);
    }, set(e) {
      t.reduce((s, i, a) => a === r ? s[i] = e : s[i], this);
    } };
  }, Do2 = (t, r, e) => Object.keys(e).map((s) => [s, e[s]]).filter((s) => {
    let [, i] = s;
    return !!i;
  }).map((s) => {
    let [i, a] = s;
    return [i, typeof a == "function" ? { value: a, enumerable: false } : typeof a.reflect == "string" ? Object.assign({}, a, ko2(a.reflect.split("."))) : a];
  }).reduce((s, i) => {
    let [a, n] = i;
    return Object.defineProperty(s, a, Object.assign({ configurable: true }, n));
  }, Object.assign(new t(), r)), Fo2 = { ImportMetaOutsideModule: { message: `import.meta may appear only with 'sourceType: "module"'`, code: Jt2.SourceTypeModuleError }, ImportOutsideModule: { message: `'import' and 'export' may appear only with 'sourceType: "module"'`, code: Jt2.SourceTypeModuleError } }, mr2 = { ArrayPattern: "array destructuring pattern", AssignmentExpression: "assignment expression", AssignmentPattern: "assignment expression", ArrowFunctionExpression: "arrow function expression", ConditionalExpression: "conditional expression", CatchClause: "catch clause", ForOfStatement: "for-of statement", ForInStatement: "for-in statement", ForStatement: "for-loop", FormalParameters: "function parameter list", Identifier: "identifier", ImportSpecifier: "import specifier", ImportDefaultSpecifier: "import default specifier", ImportNamespaceSpecifier: "import namespace specifier", ObjectPattern: "object destructuring pattern", ParenthesizedExpression: "parenthesized expression", RestElement: "rest element", UpdateExpression: { true: "prefix operation", false: "postfix operation" }, VariableDeclarator: "variable declaration", YieldExpression: "yield expression" }, Xt2 = (t) => {
    let { type: r, prefix: e } = t;
    return r === "UpdateExpression" ? mr2.UpdateExpression[String(e)] : mr2[r];
  }, Lo2 = { AccessorIsGenerator: (t) => {
    let { kind: r } = t;
    return `A ${r}ter cannot be a generator.`;
  }, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitInUsingBinding: "'await' is not allowed to be used as a name in 'using' declarations.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: (t) => {
    let { kind: r } = t;
    return `Missing initializer in ${r} declaration.`;
  }, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.", DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: (t) => {
    let { exportName: r } = t;
    return `\`${r}\` has already been exported. Exported identifiers must be unique.`;
  }, DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: (t) => {
    let { localName: r, exportName: e } = t;
    return `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${r}' as '${e}' } from 'some-module'\`?`;
  }, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: (t) => {
    let { type: r } = t;
    return `'${r === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`;
  }, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: (t) => {
    let { type: r } = t;
    return `Unsyntactic ${r === "BreakStatement" ? "break" : "continue"}.`;
  }, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportBindingIsString: (t) => {
    let { importName: r } = t;
    return `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${r}" as foo }\`?`;
  }, ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: (t) => {
    let { maxArgumentCount: r } = t;
    return `\`import()\` requires exactly ${r === 1 ? "one argument" : "one or two arguments"}.`;
  }, ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.", ImportReflectionHasAssertion: "`import module x` cannot have assertions.", ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidCoverInitializedName: "Invalid shorthand property initializer.", InvalidDecimal: "Invalid decimal.", InvalidDigit: (t) => {
    let { radix: r } = t;
    return `Expected number in radix ${r}.`;
  }, InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: (t) => {
    let { reservedWord: r } = t;
    return `Escape sequence in keyword ${r}.`;
  }, InvalidIdentifier: (t) => {
    let { identifierName: r } = t;
    return `Invalid identifier ${r}.`;
  }, InvalidLhs: (t) => {
    let { ancestor: r } = t;
    return `Invalid left-hand side in ${Xt2(r)}.`;
  }, InvalidLhsBinding: (t) => {
    let { ancestor: r } = t;
    return `Binding invalid left-hand side in ${Xt2(r)}.`;
  }, InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: (t) => {
    let { unexpected: r } = t;
    return `Unexpected character '${r}'.`;
  }, InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: (t) => {
    let { identifierName: r } = t;
    return `Private name #${r} is not defined.`;
  }, InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: (t) => {
    let { labelName: r } = t;
    return `Label '${r}' is already declared.`;
  }, LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingPlugin: (t) => {
    let { missingPlugin: r } = t;
    return `This experimental syntax requires enabling the parser plugin: ${r.map((e) => JSON.stringify(e)).join(", ")}.`;
  }, MissingOneOfPlugins: (t) => {
    let { missingPlugin: r } = t;
    return `This experimental syntax requires enabling one of the following parser plugin(s): ${r.map((e) => JSON.stringify(e)).join(", ")}.`;
  }, MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: (t) => {
    let { key: r } = t;
    return `Duplicate key "${r}" is not allowed in module attributes.`;
  }, ModuleExportNameHasLoneSurrogate: (t) => {
    let { surrogateCharCode: r } = t;
    return `An export name cannot include a lone surrogate, found '\\u${r.toString(16)}'.`;
  }, ModuleExportUndefined: (t) => {
    let { localName: r } = t;
    return `Export '${r}' is not defined.`;
  }, MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: (t) => {
    let { identifierName: r } = t;
    return `Private names are only allowed in property accesses (\`obj.#${r}\`) or in \`in\` expressions (\`#${r} in obj\`).`;
  }, PrivateNameRedeclaration: (t) => {
    let { identifierName: r } = t;
    return `Duplicate private name #${r}.`;
  }, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.", SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", StaticPrototype: "Classes may not have static property named prototype.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: (t) => {
    let { keyword: r } = t;
    return `Unexpected keyword '${r}'.`;
  }, UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Unexpected private name.", UnexpectedReservedWord: (t) => {
    let { reservedWord: r } = t;
    return `Unexpected reserved word '${r}'.`;
  }, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: (t) => {
    let { expected: r, unexpected: e } = t;
    return `Unexpected token${e ? ` '${e}'.` : ""}${r ? `, expected "${r}"` : ""}`;
  }, UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: (t) => {
    let { target: r, onlyValidPropertyName: e } = t;
    return `The only valid meta property for ${r} is ${r}.${e}.`;
  }, UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.", VarRedeclaration: (t) => {
    let { identifierName: r } = t;
    return `Identifier '${r}' has already been declared.`;
  }, YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." }, Oo2 = { StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: (t) => {
    let { referenceName: r } = t;
    return `Assigning to '${r}' in strict mode.`;
  }, StrictEvalArgumentsBinding: (t) => {
    let { bindingName: r } = t;
    return `Binding '${r}' in strict mode.`;
  }, StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode." }, Bo2 = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), Mo2 = { PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: (t) => {
    let { token: r } = t;
    return `Invalid topic token ${r}. In order to use ${r} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${r}" }.`;
  }, PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipeUnparenthesizedBody: (t) => {
    let { type: r } = t;
    return `Hack-style pipe body cannot be an unparenthesized ${Xt2({ type: r })}; please wrap it in parentheses.`;
  }, PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.' }, _o2 = ["toMessage"], Ro2 = ["message"];
  function jo2(t) {
    let { toMessage: r } = t, e = pt2(t, _o2);
    return function s(i) {
      let { loc: a, details: n } = i;
      return Do2(SyntaxError, Object.assign({}, e, { loc: a }), { clone() {
        let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, u = o.loc || {};
        return s({ loc: new Ce2("line" in u ? u.line : this.loc.line, "column" in u ? u.column : this.loc.column, "index" in u ? u.index : this.loc.index), details: Object.assign({}, this.details, o.details) });
      }, details: { value: n, enumerable: false }, message: { get() {
        return `${r(this.details)} (${this.loc.line}:${this.loc.column})`;
      }, set(o) {
        Object.defineProperty(this, "message", { value: o });
      } }, pos: { reflect: "loc.index", enumerable: true }, missingPlugin: "missingPlugin" in n && { reflect: "details.missingPlugin", enumerable: true } });
    };
  }
  function ge2(t, r) {
    if (Array.isArray(t))
      return (s) => ge2(s, t[0]);
    let e = {};
    for (let s of Object.keys(t)) {
      let i = t[s], a = typeof i == "string" ? { message: () => i } : typeof i == "function" ? { message: i } : i, { message: n } = a, o = pt2(a, Ro2), u = typeof n == "string" ? () => n : n;
      e[s] = jo2(Object.assign({ code: Jt2.SyntaxError, reasonCode: s, toMessage: u }, r ? { syntaxPlugin: r } : {}, o));
    }
    return e;
  }
  var p = Object.assign({}, ge2(Fo2), ge2(Lo2), ge2(Oo2), ge2`pipelineOperator`(Mo2)), { defineProperty: qo2 } = Object, yr2 = (t, r) => qo2(t, r, { enumerable: false, value: t[r] });
  function Je2(t) {
    return t.loc.start && yr2(t.loc.start, "index"), t.loc.end && yr2(t.loc.end, "index"), t;
  }
  var Uo2 = (t) => class extends t {
    parse() {
      let e = Je2(super.parse());
      return this.options.tokens && (e.tokens = e.tokens.map(Je2)), e;
    }
    parseRegExpLiteral(e) {
      let { pattern: s, flags: i } = e, a = null;
      try {
        a = new RegExp(s, i);
      } catch {
      }
      let n = this.estreeParseLiteral(a);
      return n.regex = { pattern: s, flags: i }, n;
    }
    parseBigIntLiteral(e) {
      let s;
      try {
        s = BigInt(e);
      } catch {
        s = null;
      }
      let i = this.estreeParseLiteral(s);
      return i.bigint = String(i.value || e), i;
    }
    parseDecimalLiteral(e) {
      let i = this.estreeParseLiteral(null);
      return i.decimal = String(i.value || e), i;
    }
    estreeParseLiteral(e) {
      return this.parseLiteral(e, "Literal");
    }
    parseStringLiteral(e) {
      return this.estreeParseLiteral(e);
    }
    parseNumericLiteral(e) {
      return this.estreeParseLiteral(e);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(e) {
      return this.estreeParseLiteral(e);
    }
    directiveToStmt(e) {
      let s = e.value;
      delete e.value, s.type = "Literal", s.raw = s.extra.raw, s.value = s.extra.expressionValue;
      let i = e;
      return i.type = "ExpressionStatement", i.expression = s, i.directive = s.extra.rawValue, delete s.extra, i;
    }
    initFunction(e, s) {
      super.initFunction(e, s), e.expression = false;
    }
    checkDeclaration(e) {
      e != null && this.isObjectProperty(e) ? this.checkDeclaration(e.value) : super.checkDeclaration(e);
    }
    getObjectOrClassMethodParams(e) {
      return e.value.params;
    }
    isValidDirective(e) {
      var s;
      return e.type === "ExpressionStatement" && e.expression.type === "Literal" && typeof e.expression.value == "string" && !((s = e.expression.extra) != null && s.parenthesized);
    }
    parseBlockBody(e, s, i, a, n) {
      super.parseBlockBody(e, s, i, a, n);
      let o = e.directives.map((u) => this.directiveToStmt(u));
      e.body = o.concat(e.body), delete e.directives;
    }
    pushClassMethod(e, s, i, a, n, o) {
      this.parseMethod(s, i, a, n, o, "ClassMethod", true), s.typeParameters && (s.value.typeParameters = s.typeParameters, delete s.typeParameters), e.body.push(s);
    }
    parsePrivateName() {
      let e = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(e) : e;
    }
    convertPrivateNameToPrivateIdentifier(e) {
      let s = super.getPrivateNameSV(e);
      return e = e, delete e.id, e.name = s, e.type = "PrivateIdentifier", e;
    }
    isPrivateName(e) {
      return this.getPluginOption("estree", "classFeatures") ? e.type === "PrivateIdentifier" : super.isPrivateName(e);
    }
    getPrivateNameSV(e) {
      return this.getPluginOption("estree", "classFeatures") ? e.name : super.getPrivateNameSV(e);
    }
    parseLiteral(e, s) {
      let i = super.parseLiteral(e, s);
      return i.raw = i.extra.raw, delete i.extra, i;
    }
    parseFunctionBody(e, s) {
      let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      super.parseFunctionBody(e, s, i), e.expression = e.body.type !== "BlockStatement";
    }
    parseMethod(e, s, i, a, n, o) {
      let u = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false, c = this.startNode();
      return c.kind = e.kind, c = super.parseMethod(c, s, i, a, n, o, u), c.type = "FunctionExpression", delete c.kind, e.value = c, o === "ClassPrivateMethod" && (e.computed = false), this.finishNode(e, "MethodDefinition");
    }
    parseClassProperty() {
      let e = super.parseClassProperty(...arguments);
      return this.getPluginOption("estree", "classFeatures") && (e.type = "PropertyDefinition"), e;
    }
    parseClassPrivateProperty() {
      let e = super.parseClassPrivateProperty(...arguments);
      return this.getPluginOption("estree", "classFeatures") && (e.type = "PropertyDefinition", e.computed = false), e;
    }
    parseObjectMethod(e, s, i, a, n) {
      let o = super.parseObjectMethod(e, s, i, a, n);
      return o && (o.type = "Property", o.kind === "method" && (o.kind = "init"), o.shorthand = false), o;
    }
    parseObjectProperty(e, s, i, a) {
      let n = super.parseObjectProperty(e, s, i, a);
      return n && (n.kind = "init", n.type = "Property"), n;
    }
    isValidLVal(e, s, i) {
      return e === "Property" ? "value" : super.isValidLVal(e, s, i);
    }
    isAssignable(e, s) {
      return e != null && this.isObjectProperty(e) ? this.isAssignable(e.value, s) : super.isAssignable(e, s);
    }
    toAssignable(e) {
      let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (e != null && this.isObjectProperty(e)) {
        let { key: i, value: a } = e;
        this.isPrivateName(i) && this.classScope.usePrivateName(this.getPrivateNameSV(i), i.loc.start), this.toAssignable(a, s);
      } else
        super.toAssignable(e, s);
    }
    toAssignableObjectExpressionProp(e, s, i) {
      e.kind === "get" || e.kind === "set" ? this.raise(p.PatternHasAccessor, { at: e.key }) : e.method ? this.raise(p.PatternHasMethod, { at: e.key }) : super.toAssignableObjectExpressionProp(e, s, i);
    }
    finishCallExpression(e, s) {
      let i = super.finishCallExpression(e, s);
      if (i.callee.type === "Import") {
        if (i.type = "ImportExpression", i.source = i.arguments[0], this.hasPlugin("importAssertions")) {
          var a;
          i.attributes = (a = i.arguments[1]) != null ? a : null;
        }
        delete i.arguments, delete i.callee;
      }
      return i;
    }
    toReferencedArguments(e) {
      e.type !== "ImportExpression" && super.toReferencedArguments(e);
    }
    parseExport(e, s) {
      let i = this.state.lastTokStartLoc, a = super.parseExport(e, s);
      switch (a.type) {
        case "ExportAllDeclaration":
          a.exported = null;
          break;
        case "ExportNamedDeclaration":
          a.specifiers.length === 1 && a.specifiers[0].type === "ExportNamespaceSpecifier" && (a.type = "ExportAllDeclaration", a.exported = a.specifiers[0].exported, delete a.specifiers);
        case "ExportDefaultDeclaration":
          {
            var n;
            let { declaration: o } = a;
            (o == null ? void 0 : o.type) === "ClassDeclaration" && ((n = o.decorators) == null ? void 0 : n.length) > 0 && o.start === a.start && this.resetStartLocation(a, i);
          }
          break;
      }
      return a;
    }
    parseSubscript(e, s, i, a) {
      let n = super.parseSubscript(e, s, i, a);
      if (a.optionalChainMember) {
        if ((n.type === "OptionalMemberExpression" || n.type === "OptionalCallExpression") && (n.type = n.type.substring(8)), a.stop) {
          let o = this.startNodeAtNode(n);
          return o.expression = n, this.finishNode(o, "ChainExpression");
        }
      } else
        (n.type === "MemberExpression" || n.type === "CallExpression") && (n.optional = false);
      return n;
    }
    hasPropertyAsPrivateName(e) {
      return e.type === "ChainExpression" && (e = e.expression), super.hasPropertyAsPrivateName(e);
    }
    isObjectProperty(e) {
      return e.type === "Property" && e.kind === "init" && !e.method;
    }
    isObjectMethod(e) {
      return e.method || e.kind === "get" || e.kind === "set";
    }
    finishNodeAt(e, s, i) {
      return Je2(super.finishNodeAt(e, s, i));
    }
    resetStartLocation(e, s) {
      super.resetStartLocation(e, s), Je2(e);
    }
    resetEndLocation(e) {
      let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.lastTokEndLoc;
      super.resetEndLocation(e, s), Je2(e);
    }
  }, Yt2 = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", xr2 = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿", $o2 = new RegExp("[" + Yt2 + "]"), Ho2 = new RegExp("[" + Yt2 + xr2 + "]");
  Yt2 = xr2 = null;
  var gr2 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191], zo2 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function Qt2(t, r) {
    let e = 65536;
    for (let s = 0, i = r.length; s < i; s += 2) {
      if (e += r[s], e > t)
        return false;
      if (e += r[s + 1], e >= t)
        return true;
    }
    return false;
  }
  function Pe2(t) {
    return t < 65 ? t === 36 : t <= 90 ? true : t < 97 ? t === 95 : t <= 122 ? true : t <= 65535 ? t >= 170 && $o2.test(String.fromCharCode(t)) : Qt2(t, gr2);
  }
  function je2(t) {
    return t < 48 ? t === 36 : t < 58 ? true : t < 65 ? false : t <= 90 ? true : t < 97 ? t === 95 : t <= 122 ? true : t <= 65535 ? t >= 170 && Ho2.test(String.fromCharCode(t)) : Qt2(t, gr2) || Qt2(t, zo2);
  }
  var Zt2 = { keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"], strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], strictBind: ["eval", "arguments"] }, Vo2 = new Set(Zt2.keyword), Ko2 = new Set(Zt2.strict), Wo2 = new Set(Zt2.strictBind);
  function Pr2(t, r) {
    return r && t === "await" || t === "enum";
  }
  function Ar2(t, r) {
    return Pr2(t, r) || Ko2.has(t);
  }
  function Tr2(t) {
    return Wo2.has(t);
  }
  function vr2(t, r) {
    return Ar2(t, r) || Tr2(t);
  }
  function Go2(t) {
    return Vo2.has(t);
  }
  function Jo2(t, r, e) {
    return t === 64 && r === 64 && Pe2(e);
  }
  var Xo2 = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function Yo2(t) {
    return Xo2.has(t);
  }
  var qe2 = 0, Ue2 = 1, Ae2 = 2, es = 4, Er2 = 8, dt2 = 16, Cr2 = 32, Ne2 = 64, mt2 = 128, $e2 = 256, yt2 = Ue2 | Ae2 | mt2 | $e2, me2 = 1, ke2 = 2, br2 = 4, De2 = 8, xt2 = 16, Sr2 = 64, gt2 = 128, ts2 = 256, ss2 = 512, rs2 = 1024, is2 = 2048, Xe = 4096, Pt2 = 8192, wr2 = me2 | ke2 | De2 | gt2 | Pt2, He2 = me2 | 0 | De2 | Pt2, Qo2 = me2 | 0 | De2 | 0, At2 = me2 | 0 | br2 | 0, Ir2 = me2 | 0 | xt2 | 0, Zo2 = 0 | ke2 | 0 | gt2, el2 = 0 | ke2 | 0 | 0, Nr2 = me2 | ke2 | De2 | ts2 | Pt2, kr2 = 0 | rs2, be2 = 0 | Sr2, tl2 = me2 | 0 | 0 | Sr2, sl2 = Nr2 | ss2, rl2 = 0 | rs2, Dr2 = 0 | ke2 | 0 | Xe, il2 = is2, Tt2 = 4, as2 = 2, ns2 = 1, os2 = as2 | ns2, al2 = as2 | Tt2, nl2 = ns2 | Tt2, ol2 = as2, ll2 = ns2, ls2 = 0, hs2 = class {
    constructor(t) {
      this.var = /* @__PURE__ */ new Set(), this.lexical = /* @__PURE__ */ new Set(), this.functions = /* @__PURE__ */ new Set(), this.flags = t;
    }
  }, us2 = class {
    constructor(t, r) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = t, this.inModule = r;
    }
    get inTopLevel() {
      return (this.currentScope().flags & Ue2) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & Ae2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & dt2) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & Cr2) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & Ne2) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      let t = this.currentThisScopeFlags();
      return (t & Ne2) > 0 && (t & Ae2) === 0;
    }
    get inStaticBlock() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        let { flags: r } = this.scopeStack[t];
        if (r & mt2)
          return true;
        if (r & (yt2 | Ne2))
          return false;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & Ae2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(t) {
      return new hs2(t);
    }
    enter(t) {
      this.scopeStack.push(this.createScope(t));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(t) {
      return !!(t.flags & (Ae2 | mt2) || !this.parser.inModule && t.flags & Ue2);
    }
    declareName(t, r, e) {
      let s = this.currentScope();
      if (r & De2 || r & xt2)
        this.checkRedeclarationInScope(s, t, r, e), r & xt2 ? s.functions.add(t) : s.lexical.add(t), r & De2 && this.maybeExportDefined(s, t);
      else if (r & br2)
        for (let i = this.scopeStack.length - 1; i >= 0 && (s = this.scopeStack[i], this.checkRedeclarationInScope(s, t, r, e), s.var.add(t), this.maybeExportDefined(s, t), !(s.flags & yt2)); --i)
          ;
      this.parser.inModule && s.flags & Ue2 && this.undefinedExports.delete(t);
    }
    maybeExportDefined(t, r) {
      this.parser.inModule && t.flags & Ue2 && this.undefinedExports.delete(r);
    }
    checkRedeclarationInScope(t, r, e, s) {
      this.isRedeclaredInScope(t, r, e) && this.parser.raise(p.VarRedeclaration, { at: s, identifierName: r });
    }
    isRedeclaredInScope(t, r, e) {
      return e & me2 ? e & De2 ? t.lexical.has(r) || t.functions.has(r) || t.var.has(r) : e & xt2 ? t.lexical.has(r) || !this.treatFunctionsAsVarInScope(t) && t.var.has(r) : t.lexical.has(r) && !(t.flags & Er2 && t.lexical.values().next().value === r) || !this.treatFunctionsAsVarInScope(t) && t.functions.has(r) : false;
    }
    checkLocalExport(t) {
      let { name: r } = t, e = this.scopeStack[0];
      !e.lexical.has(r) && !e.var.has(r) && !e.functions.has(r) && this.undefinedExports.set(r, t.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        let { flags: r } = this.scopeStack[t];
        if (r & yt2)
          return r;
      }
    }
    currentThisScopeFlags() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        let { flags: r } = this.scopeStack[t];
        if (r & (yt2 | Ne2) && !(r & es))
          return r;
      }
    }
  }, hl2 = class extends hs2 {
    constructor() {
      super(...arguments), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }, ul2 = class extends us2 {
    createScope(t) {
      return new hl2(t);
    }
    declareName(t, r, e) {
      let s = this.currentScope();
      if (r & is2) {
        this.checkRedeclarationInScope(s, t, r, e), this.maybeExportDefined(s, t), s.declareFunctions.add(t);
        return;
      }
      super.declareName(t, r, e);
    }
    isRedeclaredInScope(t, r, e) {
      return super.isRedeclaredInScope(t, r, e) ? true : e & is2 ? !t.declareFunctions.has(r) && (t.lexical.has(r) || t.functions.has(r)) : false;
    }
    checkLocalExport(t) {
      this.scopeStack[0].declareFunctions.has(t.name) || super.checkLocalExport(t);
    }
  }, cl2 = class {
    constructor() {
      this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
    }
    hasPlugin(t) {
      if (typeof t == "string")
        return this.plugins.has(t);
      {
        let [r, e] = t;
        if (!this.hasPlugin(r))
          return false;
        let s = this.plugins.get(r);
        for (let i of Object.keys(e))
          if ((s == null ? void 0 : s[i]) !== e[i])
            return false;
        return true;
      }
    }
    getPluginOption(t, r) {
      var e;
      return (e = this.plugins.get(t)) == null ? void 0 : e[r];
    }
  };
  function Fr2(t, r) {
    t.trailingComments === void 0 ? t.trailingComments = r : t.trailingComments.unshift(...r);
  }
  function pl2(t, r) {
    t.leadingComments === void 0 ? t.leadingComments = r : t.leadingComments.unshift(...r);
  }
  function Ye2(t, r) {
    t.innerComments === void 0 ? t.innerComments = r : t.innerComments.unshift(...r);
  }
  function Qe(t, r, e) {
    let s = null, i = r.length;
    for (; s === null && i > 0; )
      s = r[--i];
    s === null || s.start > e.start ? Ye2(t, e.comments) : Fr2(s, e.comments);
  }
  var fl2 = class extends cl2 {
    addComment(t) {
      this.filename && (t.loc.filename = this.filename), this.state.comments.push(t);
    }
    processComment(t) {
      let { commentStack: r } = this.state, e = r.length;
      if (e === 0)
        return;
      let s = e - 1, i = r[s];
      i.start === t.end && (i.leadingNode = t, s--);
      let { start: a } = t;
      for (; s >= 0; s--) {
        let n = r[s], o = n.end;
        if (o > a)
          n.containingNode = t, this.finalizeComment(n), r.splice(s, 1);
        else {
          o === a && (n.trailingNode = t);
          break;
        }
      }
    }
    finalizeComment(t) {
      let { comments: r } = t;
      if (t.leadingNode !== null || t.trailingNode !== null)
        t.leadingNode !== null && Fr2(t.leadingNode, r), t.trailingNode !== null && pl2(t.trailingNode, r);
      else {
        let { containingNode: e, start: s } = t;
        if (this.input.charCodeAt(s - 1) === 44)
          switch (e.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              Qe(e, e.properties, t);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              Qe(e, e.arguments, t);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              Qe(e, e.params, t);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              Qe(e, e.elements, t);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              Qe(e, e.specifiers, t);
              break;
            default:
              Ye2(e, r);
          }
        else
          Ye2(e, r);
      }
    }
    finalizeRemainingComments() {
      let { commentStack: t } = this.state;
      for (let r = t.length - 1; r >= 0; r--)
        this.finalizeComment(t[r]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(t) {
      let { commentStack: r } = this.state, { length: e } = r;
      if (e === 0)
        return;
      let s = r[e - 1];
      s.leadingNode === t && (s.leadingNode = null);
    }
    takeSurroundingComments(t, r, e) {
      let { commentStack: s } = this.state, i = s.length;
      if (i === 0)
        return;
      let a = i - 1;
      for (; a >= 0; a--) {
        let n = s[a], o = n.end;
        if (n.start === e)
          n.leadingNode = t;
        else if (o === r)
          n.trailingNode = t;
        else if (o < r)
          break;
      }
    }
  }, cs2 = /\r\n?|[\n\u2028\u2029]/, vt2 = new RegExp(cs2.source, "g");
  function Ze2(t) {
    switch (t) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return true;
      default:
        return false;
    }
  }
  var ps2 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, dl2 = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y, Lr2 = new RegExp("(?=(" + dl2.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
  function ml2(t) {
    switch (t) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return true;
      default:
        return false;
    }
  }
  var Or2 = class {
    constructor() {
      this.strict = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = false, this.inType = false, this.noAnonFunctionType = false, this.hasFlowComment = false, this.isAmbientContext = false, this.inAbstractClass = false, this.inDisallowConditionalTypesContext = false, this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.soloAwait = false, this.inFSharpPipelineDirectBody = false, this.labels = [], this.comments = [], this.commentStack = [], this.pos = 0, this.type = 137, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.context = [x.brace], this.canStartJSXElement = true, this.containsEsc = false, this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    init(t) {
      let { strictMode: r, sourceType: e, startLine: s, startColumn: i } = t;
      this.strict = r === false ? false : r === true ? true : e === "module", this.curLine = s, this.lineStart = -i, this.startLoc = this.endLoc = new Ce2(s, i, 0);
    }
    curPosition() {
      return new Ce2(this.curLine, this.pos - this.lineStart, this.pos);
    }
    clone(t) {
      let r = new Or2(), e = Object.keys(this);
      for (let s = 0, i = e.length; s < i; s++) {
        let a = e[s], n = this[a];
        !t && Array.isArray(n) && (n = n.slice()), r[a] = n;
      }
      return r;
    }
  }, yl2 = function(r) {
    return r >= 48 && r <= 57;
  }, Br2 = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, Et2 = { bin: (t) => t === 48 || t === 49, oct: (t) => t >= 48 && t <= 55, dec: (t) => t >= 48 && t <= 57, hex: (t) => t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102 };
  function Mr2(t, r, e, s, i, a) {
    let n = e, o = s, u = i, c = "", y2 = null, g2 = e, { length: T } = r;
    for (; ; ) {
      if (e >= T) {
        a.unterminated(n, o, u), c += r.slice(g2, e);
        break;
      }
      let C = r.charCodeAt(e);
      if (xl2(t, C, r, e)) {
        c += r.slice(g2, e);
        break;
      }
      if (C === 92) {
        c += r.slice(g2, e);
        let j = gl2(r, e, s, i, t === "template", a);
        j.ch === null && !y2 ? y2 = { pos: e, lineStart: s, curLine: i } : c += j.ch, { pos: e, lineStart: s, curLine: i } = j, g2 = e;
      } else
        C === 8232 || C === 8233 ? (++e, ++i, s = e) : C === 10 || C === 13 ? t === "template" ? (c += r.slice(g2, e) + `
`, ++e, C === 13 && r.charCodeAt(e) === 10 && ++e, ++i, g2 = s = e) : a.unterminated(n, o, u) : ++e;
    }
    return { pos: e, str: c, firstInvalidLoc: y2, lineStart: s, curLine: i, containsInvalid: !!y2 };
  }
  function xl2(t, r, e, s) {
    return t === "template" ? r === 96 || r === 36 && e.charCodeAt(s + 1) === 123 : r === (t === "double" ? 34 : 39);
  }
  function gl2(t, r, e, s, i, a) {
    let n = !i;
    r++;
    let o = (c) => ({ pos: r, ch: c, lineStart: e, curLine: s }), u = t.charCodeAt(r++);
    switch (u) {
      case 110:
        return o(`
`);
      case 114:
        return o("\r");
      case 120: {
        let c;
        return { code: c, pos: r } = fs2(t, r, e, s, 2, false, n, a), o(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return { code: c, pos: r } = Rr2(t, r, e, s, n, a), o(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return o("	");
      case 98:
        return o("\b");
      case 118:
        return o("\v");
      case 102:
        return o("\f");
      case 13:
        t.charCodeAt(r) === 10 && ++r;
      case 10:
        e = r, ++s;
      case 8232:
      case 8233:
        return o("");
      case 56:
      case 57:
        if (i)
          return o(null);
        a.strictNumericEscape(r - 1, e, s);
      default:
        if (u >= 48 && u <= 55) {
          let c = r - 1, g2 = t.slice(c, r + 2).match(/^[0-7]+/)[0], T = parseInt(g2, 8);
          T > 255 && (g2 = g2.slice(0, -1), T = parseInt(g2, 8)), r += g2.length - 1;
          let C = t.charCodeAt(r);
          if (g2 !== "0" || C === 56 || C === 57) {
            if (i)
              return o(null);
            a.strictNumericEscape(c, e, s);
          }
          return o(String.fromCharCode(T));
        }
        return o(String.fromCharCode(u));
    }
  }
  function fs2(t, r, e, s, i, a, n, o) {
    let u = r, c;
    return { n: c, pos: r } = _r2(t, r, e, s, 16, i, a, false, o, !n), c === null && (n ? o.invalidEscapeSequence(u, e, s) : r = u - 1), { code: c, pos: r };
  }
  function _r2(t, r, e, s, i, a, n, o, u, c) {
    let y2 = r, g2 = i === 16 ? Br2.hex : Br2.decBinOct, T = i === 16 ? Et2.hex : i === 10 ? Et2.dec : i === 8 ? Et2.oct : Et2.bin, C = false, j = 0;
    for (let q = 0, G = a == null ? 1 / 0 : a; q < G; ++q) {
      let J = t.charCodeAt(r), K2;
      if (J === 95 && o !== "bail") {
        let Z = t.charCodeAt(r - 1), We2 = t.charCodeAt(r + 1);
        if (o) {
          if (Number.isNaN(We2) || !T(We2) || g2.has(Z) || g2.has(We2)) {
            if (c)
              return { n: null, pos: r };
            u.unexpectedNumericSeparator(r, e, s);
          }
        } else {
          if (c)
            return { n: null, pos: r };
          u.numericSeparatorInEscapeSequence(r, e, s);
        }
        ++r;
        continue;
      }
      if (J >= 97 ? K2 = J - 97 + 10 : J >= 65 ? K2 = J - 65 + 10 : yl2(J) ? K2 = J - 48 : K2 = 1 / 0, K2 >= i) {
        if (K2 <= 9 && c)
          return { n: null, pos: r };
        if (K2 <= 9 && u.invalidDigit(r, e, s, i))
          K2 = 0;
        else if (n)
          K2 = 0, C = true;
        else
          break;
      }
      ++r, j = j * i + K2;
    }
    return r === y2 || a != null && r - y2 !== a || C ? { n: null, pos: r } : { n: j, pos: r };
  }
  function Rr2(t, r, e, s, i, a) {
    let n = t.charCodeAt(r), o;
    if (n === 123) {
      if (++r, { code: o, pos: r } = fs2(t, r, e, s, t.indexOf("}", r) - r, true, i, a), ++r, o !== null && o > 1114111)
        if (i)
          a.invalidCodePoint(r, e, s);
        else
          return { code: null, pos: r };
    } else
      ({ code: o, pos: r } = fs2(t, r, e, s, 4, false, i, a));
    return { code: o, pos: r };
  }
  var Pl2 = ["at"], Al2 = ["at"];
  function et2(t, r, e) {
    return new Ce2(e, t - r, t);
  }
  var Tl2 = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), Se2 = class {
    constructor(t) {
      this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, this.loc = new ft2(t.startLoc, t.endLoc);
    }
  }, vl2 = class extends fl2 {
    constructor(t, r) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = { invalidDigit: (e, s, i, a) => this.options.errorRecovery ? (this.raise(p.InvalidDigit, { at: et2(e, s, i), radix: a }), true) : false, numericSeparatorInEscapeSequence: this.errorBuilder(p.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(p.UnexpectedNumericSeparator) }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(p.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(p.InvalidCodePoint) }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: (e, s, i) => {
        this.recordStrictModeErrors(p.StrictNumericEscape, { at: et2(e, s, i) });
      }, unterminated: (e, s, i) => {
        throw this.raise(p.UnterminatedString, { at: et2(e - 1, s, i) });
      } }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: this.errorBuilder(p.StrictNumericEscape), unterminated: (e, s, i) => {
        throw this.raise(p.UnterminatedTemplate, { at: et2(e, s, i) });
      } }), this.state = new Or2(), this.state.init(t), this.input = r, this.length = r.length, this.isLookahead = false;
    }
    pushToken(t) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(t), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Se2(this.state)), this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(t) {
      return this.match(t) ? (this.next(), true) : false;
    }
    match(t) {
      return this.state.type === t;
    }
    createLookaheadState(t) {
      return { pos: t.pos, value: null, type: t.type, start: t.start, end: t.end, context: [this.curContext()], inType: t.inType, startLoc: t.startLoc, lastTokEndLoc: t.lastTokEndLoc, curLine: t.curLine, lineStart: t.lineStart, curPosition: t.curPosition };
    }
    lookahead() {
      let t = this.state;
      this.state = this.createLookaheadState(t), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
      let r = this.state;
      return this.state = t, r;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(t) {
      return ps2.lastIndex = t, ps2.test(this.input) ? ps2.lastIndex : t;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    codePointAtPos(t) {
      let r = this.input.charCodeAt(t);
      if ((r & 64512) === 55296 && ++t < this.input.length) {
        let e = this.input.charCodeAt(t);
        (e & 64512) === 56320 && (r = 65536 + ((r & 1023) << 10) + (e & 1023));
      }
      return r;
    }
    setStrict(t) {
      this.state.strict = t, t && (this.state.strictErrors.forEach((r) => {
        let [e, s] = r;
        return this.raise(e, { at: s });
      }), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
        this.finishToken(137);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(t) {
      let r;
      this.isLookahead || (r = this.state.curPosition());
      let e = this.state.pos, s = this.input.indexOf(t, e + 2);
      if (s === -1)
        throw this.raise(p.UnterminatedComment, { at: this.state.curPosition() });
      for (this.state.pos = s + t.length, vt2.lastIndex = e + 2; vt2.test(this.input) && vt2.lastIndex <= s; )
        ++this.state.curLine, this.state.lineStart = vt2.lastIndex;
      if (this.isLookahead)
        return;
      let i = { type: "CommentBlock", value: this.input.slice(e + 2, s), start: e, end: s + t.length, loc: new ft2(r, this.state.curPosition()) };
      return this.options.tokens && this.pushToken(i), i;
    }
    skipLineComment(t) {
      let r = this.state.pos, e;
      this.isLookahead || (e = this.state.curPosition());
      let s = this.input.charCodeAt(this.state.pos += t);
      if (this.state.pos < this.length)
        for (; !Ze2(s) && ++this.state.pos < this.length; )
          s = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead)
        return;
      let i = this.state.pos, n = { type: "CommentLine", value: this.input.slice(r + t, i), start: r, end: i, loc: new ft2(e, this.state.curPosition()) };
      return this.options.tokens && this.pushToken(n), n;
    }
    skipSpace() {
      let t = this.state.pos, r = [];
      e:
        for (; this.state.pos < this.length; ) {
          let e = this.input.charCodeAt(this.state.pos);
          switch (e) {
            case 32:
            case 160:
            case 9:
              ++this.state.pos;
              break;
            case 13:
              this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
            case 10:
            case 8232:
            case 8233:
              ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
              break;
            case 47:
              switch (this.input.charCodeAt(this.state.pos + 1)) {
                case 42: {
                  let s = this.skipBlockComment("*/");
                  s !== void 0 && (this.addComment(s), this.options.attachComment && r.push(s));
                  break;
                }
                case 47: {
                  let s = this.skipLineComment(2);
                  s !== void 0 && (this.addComment(s), this.options.attachComment && r.push(s));
                  break;
                }
                default:
                  break e;
              }
              break;
            default:
              if (ml2(e))
                ++this.state.pos;
              else if (e === 45 && !this.inModule && this.options.annexB) {
                let s = this.state.pos;
                if (this.input.charCodeAt(s + 1) === 45 && this.input.charCodeAt(s + 2) === 62 && (t === 0 || this.state.lineStart > t)) {
                  let i = this.skipLineComment(3);
                  i !== void 0 && (this.addComment(i), this.options.attachComment && r.push(i));
                } else
                  break e;
              } else if (e === 60 && !this.inModule && this.options.annexB) {
                let s = this.state.pos;
                if (this.input.charCodeAt(s + 1) === 33 && this.input.charCodeAt(s + 2) === 45 && this.input.charCodeAt(s + 3) === 45) {
                  let i = this.skipLineComment(4);
                  i !== void 0 && (this.addComment(i), this.options.attachComment && r.push(i));
                } else
                  break e;
              } else
                break e;
          }
        }
      if (r.length > 0) {
        let e = this.state.pos, s = { start: t, end: e, comments: r, leadingNode: null, trailingNode: null, containingNode: null };
        this.state.commentStack.push(s);
      }
    }
    finishToken(t, r) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      let e = this.state.type;
      this.state.type = t, this.state.value = r, this.isLookahead || this.updateContext(e);
    }
    replaceToken(t) {
      this.state.type = t, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      let t = this.state.pos + 1, r = this.codePointAtPos(t);
      if (r >= 48 && r <= 57)
        throw this.raise(p.UnexpectedDigitAfterHash, { at: this.state.curPosition() });
      if (r === 123 || r === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(r === 123 ? p.RecordExpressionHashIncorrectStartSyntaxType : p.TupleExpressionHashIncorrectStartSyntaxType, { at: this.state.curPosition() });
        this.state.pos += 2, r === 123 ? this.finishToken(7) : this.finishToken(1);
      } else
        Pe2(r) ? (++this.state.pos, this.finishToken(136, this.readWord1(r))) : r === 92 ? (++this.state.pos, this.finishToken(136, this.readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      let t = this.input.charCodeAt(this.state.pos + 1);
      if (t >= 48 && t <= 57) {
        this.readNumber(true);
        return;
      }
      t === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2)
        return false;
      let t = this.input.charCodeAt(this.state.pos + 1);
      if (t !== 33)
        return false;
      let r = this.state.pos;
      for (this.state.pos += 1; !Ze2(t) && ++this.state.pos < this.length; )
        t = this.input.charCodeAt(this.state.pos);
      let e = this.input.slice(r + 2, this.state.pos);
      return this.finishToken(28, e), true;
    }
    readToken_mult_modulo(t) {
      let r = t === 42 ? 55 : 54, e = 1, s = this.input.charCodeAt(this.state.pos + 1);
      t === 42 && s === 42 && (e++, s = this.input.charCodeAt(this.state.pos + 2), r = 57), s === 61 && !this.state.inType && (e++, r = t === 37 ? 33 : 30), this.finishOp(r, e);
    }
    readToken_pipe_amp(t) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === t) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(t === 124 ? 41 : 42, 2);
        return;
      }
      if (t === 124) {
        if (r === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(p.RecordExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(p.TupleExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (r === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(t === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      let t = this.input.charCodeAt(this.state.pos + 1);
      t === 61 && !this.state.inType ? this.finishOp(32, 2) : t === 94 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "^^" }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "@@" }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(t) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === t) {
        this.finishOp(34, 2);
        return;
      }
      r === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      let { pos: t } = this.state, r = this.input.charCodeAt(t + 1);
      if (r === 60) {
        if (this.input.charCodeAt(t + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      let { pos: t } = this.state, r = this.input.charCodeAt(t + 1);
      if (r === 62) {
        let e = this.input.charCodeAt(t + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(t + e) === 61) {
          this.finishOp(30, e + 1);
          return;
        }
        this.finishOp(52, e);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(t) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (t === 61 && r === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(t === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      let t = this.input.charCodeAt(this.state.pos + 1), r = this.input.charCodeAt(this.state.pos + 2);
      t === 63 ? r === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : t === 46 && !(r >= 48 && r <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(t) {
      switch (t) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(p.TupleExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(p.RecordExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          let r = this.input.charCodeAt(this.state.pos + 1);
          if (r === 120 || r === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (r === 111 || r === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (r === 98 || r === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(false);
          return;
        case 34:
        case 39:
          this.readString(t);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(t);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(t);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(t);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(t);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (Pe2(t)) {
            this.readWord(t);
            return;
          }
      }
      throw this.raise(p.InvalidOrUnexpectedToken, { at: this.state.curPosition(), unexpected: String.fromCodePoint(t) });
    }
    finishOp(t, r) {
      let e = this.input.slice(this.state.pos, this.state.pos + r);
      this.state.pos += r, this.finishToken(t, e);
    }
    readRegexp() {
      let t = this.state.startLoc, r = this.state.start + 1, e, s, { pos: i } = this.state;
      for (; ; ++i) {
        if (i >= this.length)
          throw this.raise(p.UnterminatedRegExp, { at: re(t, 1) });
        let u = this.input.charCodeAt(i);
        if (Ze2(u))
          throw this.raise(p.UnterminatedRegExp, { at: re(t, 1) });
        if (e)
          e = false;
        else {
          if (u === 91)
            s = true;
          else if (u === 93 && s)
            s = false;
          else if (u === 47 && !s)
            break;
          e = u === 92;
        }
      }
      let a = this.input.slice(r, i);
      ++i;
      let n = "", o = () => re(t, i + 2 - r);
      for (; i < this.length; ) {
        let u = this.codePointAtPos(i), c = String.fromCharCode(u);
        if (Tl2.has(u))
          u === 118 ? (this.expectPlugin("regexpUnicodeSets", o()), n.includes("u") && this.raise(p.IncompatibleRegExpUVFlags, { at: o() })) : u === 117 && n.includes("v") && this.raise(p.IncompatibleRegExpUVFlags, { at: o() }), n.includes(c) && this.raise(p.DuplicateRegExpFlags, { at: o() });
        else if (je2(u) || u === 92)
          this.raise(p.MalformedRegExpFlags, { at: o() });
        else
          break;
        ++i, n += c;
      }
      this.state.pos = i, this.finishToken(135, { pattern: a, flags: n });
    }
    readInt(t, r) {
      let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true, { n: i, pos: a } = _r2(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, r, e, s, this.errorHandlers_readInt, false);
      return this.state.pos = a, i;
    }
    readRadixNumber(t) {
      let r = this.state.curPosition(), e = false;
      this.state.pos += 2;
      let s = this.readInt(t);
      s == null && this.raise(p.InvalidDigit, { at: re(r, 2), radix: t });
      let i = this.input.charCodeAt(this.state.pos);
      if (i === 110)
        ++this.state.pos, e = true;
      else if (i === 109)
        throw this.raise(p.InvalidDecimal, { at: r });
      if (Pe2(this.codePointAtPos(this.state.pos)))
        throw this.raise(p.NumberIdentifier, { at: this.state.curPosition() });
      if (e) {
        let a = this.input.slice(r.index, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(133, a);
        return;
      }
      this.finishToken(132, s);
    }
    readNumber(t) {
      let r = this.state.pos, e = this.state.curPosition(), s = false, i = false, a = false, n = false, o = false;
      !t && this.readInt(10) === null && this.raise(p.InvalidNumber, { at: this.state.curPosition() });
      let u = this.state.pos - r >= 2 && this.input.charCodeAt(r) === 48;
      if (u) {
        let T = this.input.slice(r, this.state.pos);
        if (this.recordStrictModeErrors(p.StrictOctalLiteral, { at: e }), !this.state.strict) {
          let C = T.indexOf("_");
          C > 0 && this.raise(p.ZeroDigitNumericSeparator, { at: re(e, C) });
        }
        o = u && !/[89]/.test(T);
      }
      let c = this.input.charCodeAt(this.state.pos);
      if (c === 46 && !o && (++this.state.pos, this.readInt(10), s = true, c = this.input.charCodeAt(this.state.pos)), (c === 69 || c === 101) && !o && (c = this.input.charCodeAt(++this.state.pos), (c === 43 || c === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(p.InvalidOrMissingExponent, { at: e }), s = true, n = true, c = this.input.charCodeAt(this.state.pos)), c === 110 && ((s || u) && this.raise(p.InvalidBigIntLiteral, { at: e }), ++this.state.pos, i = true), c === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (n || u) && this.raise(p.InvalidDecimal, { at: e }), ++this.state.pos, a = true), Pe2(this.codePointAtPos(this.state.pos)))
        throw this.raise(p.NumberIdentifier, { at: this.state.curPosition() });
      let y2 = this.input.slice(r, this.state.pos).replace(/[_mn]/g, "");
      if (i) {
        this.finishToken(133, y2);
        return;
      }
      if (a) {
        this.finishToken(134, y2);
        return;
      }
      let g2 = o ? parseInt(y2, 8) : parseFloat(y2);
      this.finishToken(132, g2);
    }
    readCodePoint(t) {
      let { code: r, pos: e } = Rr2(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, this.errorHandlers_readCodePoint);
      return this.state.pos = e, r;
    }
    readString(t) {
      let { str: r, pos: e, curLine: s, lineStart: i } = Mr2(t === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = e + 1, this.state.lineStart = i, this.state.curLine = s, this.finishToken(131, r);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let t = this.input[this.state.pos], { str: r, firstInvalidLoc: e, pos: s, curLine: i, lineStart: a } = Mr2("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = s + 1, this.state.lineStart = a, this.state.curLine = i, e && (this.state.firstInvalidTemplateEscapePos = new Ce2(e.curLine, e.pos - e.lineStart, e.pos)), this.input.codePointAt(s) === 96 ? this.finishToken(24, e ? null : t + r + "`") : (this.state.pos++, this.finishToken(25, e ? null : t + r + "${"));
    }
    recordStrictModeErrors(t, r) {
      let { at: e } = r, s = e.index;
      this.state.strict && !this.state.strictErrors.has(s) ? this.raise(t, { at: e }) : this.state.strictErrors.set(s, [t, e]);
    }
    readWord1(t) {
      this.state.containsEsc = false;
      let r = "", e = this.state.pos, s = this.state.pos;
      for (t !== void 0 && (this.state.pos += t <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        let i = this.codePointAtPos(this.state.pos);
        if (je2(i))
          this.state.pos += i <= 65535 ? 1 : 2;
        else if (i === 92) {
          this.state.containsEsc = true, r += this.input.slice(s, this.state.pos);
          let a = this.state.curPosition(), n = this.state.pos === e ? Pe2 : je2;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(p.MissingUnicodeEscape, { at: this.state.curPosition() }), s = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          let o = this.readCodePoint(true);
          o !== null && (n(o) || this.raise(p.EscapedCharNotAnIdentifier, { at: a }), r += String.fromCodePoint(o)), s = this.state.pos;
        } else
          break;
      }
      return r + this.input.slice(s, this.state.pos);
    }
    readWord(t) {
      let r = this.readWord1(t), e = O.get(r);
      e !== void 0 ? this.finishToken(e, Y(e)) : this.finishToken(130, r);
    }
    checkKeywordEscapes() {
      let { type: t } = this.state;
      Ee(t) && this.state.containsEsc && this.raise(p.InvalidEscapedReservedWord, { at: this.state.startLoc, reservedWord: Y(t) });
    }
    raise(t, r) {
      let { at: e } = r, s = pt2(r, Pl2), i = e instanceof Ce2 ? e : e.loc.start, a = t({ loc: i, details: s });
      if (!this.options.errorRecovery)
        throw a;
      return this.isLookahead || this.state.errors.push(a), a;
    }
    raiseOverwrite(t, r) {
      let { at: e } = r, s = pt2(r, Al2), i = e instanceof Ce2 ? e : e.loc.start, a = i.index, n = this.state.errors;
      for (let o = n.length - 1; o >= 0; o--) {
        let u = n[o];
        if (u.loc.index === a)
          return n[o] = t({ loc: i, details: s });
        if (u.loc.index < a)
          break;
      }
      return this.raise(t, r);
    }
    updateContext(t) {
    }
    unexpected(t, r) {
      throw this.raise(p.UnexpectedToken, { expected: r ? Y(r) : null, at: t != null ? t : this.state.startLoc });
    }
    expectPlugin(t, r) {
      if (this.hasPlugin(t))
        return true;
      throw this.raise(p.MissingPlugin, { at: r != null ? r : this.state.startLoc, missingPlugin: [t] });
    }
    expectOnePlugin(t) {
      if (!t.some((r) => this.hasPlugin(r)))
        throw this.raise(p.MissingOneOfPlugins, { at: this.state.startLoc, missingPlugin: t });
    }
    errorBuilder(t) {
      return (r, e, s) => {
        this.raise(t, { at: et2(r, e, s) });
      };
    }
  }, El2 = class {
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }, Cl2 = class {
    constructor(t) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = t;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new El2());
    }
    exit() {
      let t = this.stack.pop(), r = this.current();
      for (let [e, s] of Array.from(t.undefinedPrivateNames))
        r ? r.undefinedPrivateNames.has(e) || r.undefinedPrivateNames.set(e, s) : this.parser.raise(p.InvalidPrivateFieldResolution, { at: s, identifierName: e });
    }
    declarePrivateName(t, r, e) {
      let { privateNames: s, loneAccessors: i, undefinedPrivateNames: a } = this.current(), n = s.has(t);
      if (r & os2) {
        let o = n && i.get(t);
        if (o) {
          let u = o & Tt2, c = r & Tt2, y2 = o & os2, g2 = r & os2;
          n = y2 === g2 || u !== c, n || i.delete(t);
        } else
          n || i.set(t, r);
      }
      n && this.parser.raise(p.PrivateNameRedeclaration, { at: e, identifierName: t }), s.add(t), a.delete(t);
    }
    usePrivateName(t, r) {
      let e;
      for (e of this.stack)
        if (e.privateNames.has(t))
          return;
      e ? e.undefinedPrivateNames.set(t, r) : this.parser.raise(p.InvalidPrivateFieldResolution, { at: r, identifierName: t });
    }
  }, bl2 = 0, jr2 = 1, ds2 = 2, qr = 3, Ct2 = class {
    constructor() {
      let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : bl2;
      this.type = void 0, this.type = t;
    }
    canBeArrowParameterDeclaration() {
      return this.type === ds2 || this.type === jr2;
    }
    isCertainlyParameterDeclaration() {
      return this.type === qr;
    }
  }, Ur2 = class extends Ct2 {
    constructor(t) {
      super(t), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(t, r) {
      let { at: e } = r, s = e.index;
      this.declarationErrors.set(s, [t, e]);
    }
    clearDeclarationError(t) {
      this.declarationErrors.delete(t);
    }
    iterateErrors(t) {
      this.declarationErrors.forEach(t);
    }
  }, Sl2 = class {
    constructor(t) {
      this.parser = void 0, this.stack = [new Ct2()], this.parser = t;
    }
    enter(t) {
      this.stack.push(t);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(t, r) {
      let { at: e } = r, s = { at: e.loc.start }, { stack: i } = this, a = i.length - 1, n = i[a];
      for (; !n.isCertainlyParameterDeclaration(); ) {
        if (n.canBeArrowParameterDeclaration())
          n.recordDeclarationError(t, s);
        else
          return;
        n = i[--a];
      }
      this.parser.raise(t, s);
    }
    recordArrowParameterBindingError(t, r) {
      let { at: e } = r, { stack: s } = this, i = s[s.length - 1], a = { at: e.loc.start };
      if (i.isCertainlyParameterDeclaration())
        this.parser.raise(t, a);
      else if (i.canBeArrowParameterDeclaration())
        i.recordDeclarationError(t, a);
      else
        return;
    }
    recordAsyncArrowParametersError(t) {
      let { at: r } = t, { stack: e } = this, s = e.length - 1, i = e[s];
      for (; i.canBeArrowParameterDeclaration(); )
        i.type === ds2 && i.recordDeclarationError(p.AwaitBindingIdentifier, { at: r }), i = e[--s];
    }
    validateAsPattern() {
      let { stack: t } = this, r = t[t.length - 1];
      r.canBeArrowParameterDeclaration() && r.iterateErrors((e) => {
        let [s, i] = e;
        this.parser.raise(s, { at: i });
        let a = t.length - 2, n = t[a];
        for (; n.canBeArrowParameterDeclaration(); )
          n.clearDeclarationError(i.index), n = t[--a];
      });
    }
  };
  function wl2() {
    return new Ct2(qr);
  }
  function Il2() {
    return new Ur2(jr2);
  }
  function Nl2() {
    return new Ur2(ds2);
  }
  function $r2() {
    return new Ct2();
  }
  var ze = 0, Hr2 = 1, bt2 = 2, zr2 = 4, Ve2 = 8, kl2 = class {
    constructor() {
      this.stacks = [];
    }
    enter(t) {
      this.stacks.push(t);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & bt2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & Hr2) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & zr2) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & Ve2) > 0;
    }
  };
  function St2(t, r) {
    return (t ? bt2 : 0) | (r ? Hr2 : 0);
  }
  var Dl2 = class extends vl2 {
    addExtra(t, r, e) {
      let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      if (!t)
        return;
      let i = t.extra = t.extra || {};
      s ? i[r] = e : Object.defineProperty(i, r, { enumerable: s, value: e });
    }
    isContextual(t) {
      return this.state.type === t && !this.state.containsEsc;
    }
    isUnparsedContextual(t, r) {
      let e = t + r.length;
      if (this.input.slice(t, e) === r) {
        let s = this.input.charCodeAt(e);
        return !(je2(s) || (s & 64512) === 55296);
      }
      return false;
    }
    isLookaheadContextual(t) {
      let r = this.nextTokenStart();
      return this.isUnparsedContextual(r, t);
    }
    eatContextual(t) {
      return this.isContextual(t) ? (this.next(), true) : false;
    }
    expectContextual(t, r) {
      if (!this.eatContextual(t)) {
        if (r != null)
          throw this.raise(r, { at: this.state.startLoc });
        this.unexpected(null, t);
      }
    }
    canInsertSemicolon() {
      return this.match(137) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return cs2.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
    }
    hasFollowingLineBreak() {
      return Lr2.lastIndex = this.state.end, Lr2.test(this.input);
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon() {
      ((arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true) ? this.isLineTerminator() : this.eat(13)) || this.raise(p.MissingSemicolon, { at: this.state.lastTokEndLoc });
    }
    expect(t, r) {
      this.eat(t) || this.unexpected(r, t);
    }
    tryParse(t) {
      let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.clone(), e = { node: null };
      try {
        let s = t(function() {
          let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          throw e.node = i, e;
        });
        if (this.state.errors.length > r.errors.length) {
          let i = this.state;
          return this.state = r, this.state.tokensLength = i.tokensLength, { node: s, error: i.errors[r.errors.length], thrown: false, aborted: false, failState: i };
        }
        return { node: s, error: null, thrown: false, aborted: false, failState: null };
      } catch (s) {
        let i = this.state;
        if (this.state = r, s instanceof SyntaxError)
          return { node: null, error: s, thrown: true, aborted: false, failState: i };
        if (s === e)
          return { node: e.node, error: null, thrown: false, aborted: true, failState: i };
        throw s;
      }
    }
    checkExpressionErrors(t, r) {
      if (!t)
        return false;
      let { shorthandAssignLoc: e, doubleProtoLoc: s, privateKeyLoc: i, optionalParametersLoc: a } = t, n = !!e || !!s || !!a || !!i;
      if (!r)
        return n;
      e != null && this.raise(p.InvalidCoverInitializedName, { at: e }), s != null && this.raise(p.DuplicateProto, { at: s }), i != null && this.raise(p.UnexpectedPrivateField, { at: i }), a != null && this.unexpected(a);
    }
    isLiteralPropertyName() {
      return _e2(this.state.type);
    }
    isPrivateName(t) {
      return t.type === "PrivateName";
    }
    getPrivateNameSV(t) {
      return t.id.name;
    }
    hasPropertyAsPrivateName(t) {
      return (t.type === "MemberExpression" || t.type === "OptionalMemberExpression") && this.isPrivateName(t.property);
    }
    isObjectProperty(t) {
      return t.type === "ObjectProperty";
    }
    isObjectMethod(t) {
      return t.type === "ObjectMethod";
    }
    initializeScopes() {
      let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.sourceType === "module", r = this.state.labels;
      this.state.labels = [];
      let e = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      let s = this.inModule;
      this.inModule = t;
      let i = this.scope, a = this.getScopeHandler();
      this.scope = new a(this, t);
      let n = this.prodParam;
      this.prodParam = new kl2();
      let o = this.classScope;
      this.classScope = new Cl2(this);
      let u = this.expressionScope;
      return this.expressionScope = new Sl2(this), () => {
        this.state.labels = r, this.exportedIdentifiers = e, this.inModule = s, this.scope = i, this.prodParam = n, this.classScope = o, this.expressionScope = u;
      };
    }
    enterInitialScopes() {
      let t = ze;
      this.inModule && (t |= bt2), this.scope.enter(Ue2), this.prodParam.enter(t);
    }
    checkDestructuringPrivate(t) {
      let { privateKeyLoc: r } = t;
      r !== null && this.expectPlugin("destructuringPrivate", r);
    }
  }, wt2 = class {
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }, It2 = class {
    constructor(t, r, e) {
      this.type = "", this.start = r, this.end = 0, this.loc = new ft2(e), t != null && t.options.ranges && (this.range = [r, 0]), t != null && t.filename && (this.loc.filename = t.filename);
    }
  }, ms2 = It2.prototype;
  ms2.__clone = function() {
    let t = new It2(void 0, this.start, this.loc.start), r = Object.keys(this);
    for (let e = 0, s = r.length; e < s; e++) {
      let i = r[e];
      i !== "leadingComments" && i !== "trailingComments" && i !== "innerComments" && (t[i] = this[i]);
    }
    return t;
  };
  function Fl2(t) {
    return Te2(t);
  }
  function Te2(t) {
    let { type: r, start: e, end: s, loc: i, range: a, extra: n, name: o } = t, u = Object.create(ms2);
    return u.type = r, u.start = e, u.end = s, u.loc = i, u.range = a, u.extra = n, u.name = o, r === "Placeholder" && (u.expectedNode = t.expectedNode), u;
  }
  function Ll2(t) {
    let { type: r, start: e, end: s, loc: i, range: a, extra: n } = t;
    if (r === "Placeholder")
      return Fl2(t);
    let o = Object.create(ms2);
    return o.type = r, o.start = e, o.end = s, o.loc = i, o.range = a, t.raw !== void 0 ? o.raw = t.raw : o.extra = n, o.value = t.value, o;
  }
  var Ol2 = class extends Dl2 {
    startNode() {
      return new It2(this, this.state.start, this.state.startLoc);
    }
    startNodeAt(t) {
      return new It2(this, t.index, t);
    }
    startNodeAtNode(t) {
      return this.startNodeAt(t.loc.start);
    }
    finishNode(t, r) {
      return this.finishNodeAt(t, r, this.state.lastTokEndLoc);
    }
    finishNodeAt(t, r, e) {
      return t.type = r, t.end = e.index, t.loc.end = e, this.options.ranges && (t.range[1] = e.index), this.options.attachComment && this.processComment(t), t;
    }
    resetStartLocation(t, r) {
      t.start = r.index, t.loc.start = r, this.options.ranges && (t.range[0] = r.index);
    }
    resetEndLocation(t) {
      let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.lastTokEndLoc;
      t.end = r.index, t.loc.end = r, this.options.ranges && (t.range[1] = r.index);
    }
    resetStartLocationFromNode(t, r) {
      this.resetStartLocation(t, r.loc.start);
    }
  }, Bl2 = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), D = ge2`flow`({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: (t) => {
    let { reservedType: r } = t;
    return `Cannot overwrite reserved type ${r}.`;
  }, DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: (t) => {
    let { memberName: r, enumName: e } = t;
    return `Boolean enum members need to be initialized. Use either \`${r} = true,\` or \`${r} = false,\` in enum \`${e}\`.`;
  }, EnumDuplicateMemberName: (t) => {
    let { memberName: r, enumName: e } = t;
    return `Enum member names need to be unique, but the name \`${r}\` has already been used before in enum \`${e}\`.`;
  }, EnumInconsistentMemberValues: (t) => {
    let { enumName: r } = t;
    return `Enum \`${r}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`;
  }, EnumInvalidExplicitType: (t) => {
    let { invalidEnumType: r, enumName: e } = t;
    return `Enum type \`${r}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`;
  }, EnumInvalidExplicitTypeUnknownSupplied: (t) => {
    let { enumName: r } = t;
    return `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${r}\`.`;
  }, EnumInvalidMemberInitializerPrimaryType: (t) => {
    let { enumName: r, memberName: e, explicitType: s } = t;
    return `Enum \`${r}\` has type \`${s}\`, so the initializer of \`${e}\` needs to be a ${s} literal.`;
  }, EnumInvalidMemberInitializerSymbolType: (t) => {
    let { enumName: r, memberName: e } = t;
    return `Symbol enum members cannot be initialized. Use \`${e},\` in enum \`${r}\`.`;
  }, EnumInvalidMemberInitializerUnknownType: (t) => {
    let { enumName: r, memberName: e } = t;
    return `The enum member initializer for \`${e}\` needs to be a literal (either a boolean, number, or string) in enum \`${r}\`.`;
  }, EnumInvalidMemberName: (t) => {
    let { enumName: r, memberName: e, suggestion: s } = t;
    return `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${e}\`, consider using \`${s}\`, in enum \`${r}\`.`;
  }, EnumNumberMemberNotInitialized: (t) => {
    let { enumName: r, memberName: e } = t;
    return `Number enum members need to be initialized, e.g. \`${e} = 1\` in enum \`${r}\`.`;
  }, EnumStringMemberInconsistentlyInitailized: (t) => {
    let { enumName: r } = t;
    return `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${r}\`.`;
  }, GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: Object.assign({ message: "A binding pattern parameter cannot be optional in an implementation signature." }, { reasonCode: "OptionalBindingPattern" }), SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: (t) => {
    let { reservedType: r } = t;
    return `Unexpected reserved type ${r}.`;
  }, UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: (t) => {
    let { unsupportedExportKind: r, suggestion: e } = t;
    return `\`declare export ${r}\` is not supported. Use \`${e}\` instead.`;
  }, UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." });
  function Ml2(t) {
    return t.type === "DeclareExportAllDeclaration" || t.type === "DeclareExportDeclaration" && (!t.declaration || t.declaration.type !== "TypeAlias" && t.declaration.type !== "InterfaceDeclaration");
  }
  function ys2(t) {
    return t.importKind === "type" || t.importKind === "typeof";
  }
  function Vr2(t) {
    return se2(t) && t !== 97;
  }
  var _l2 = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" };
  function Rl2(t, r) {
    let e = [], s = [];
    for (let i = 0; i < t.length; i++)
      (r(t[i], i, t) ? e : s).push(t[i]);
    return [e, s];
  }
  var jl2 = /\*?\s*@((?:no)?flow)\b/, ql2 = (t) => class extends t {
    constructor() {
      super(...arguments), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return ul2;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(e, s) {
      e !== 131 && e !== 13 && e !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(e, s);
    }
    addComment(e) {
      if (this.flowPragma === void 0) {
        let s = jl2.exec(e.value);
        if (s)
          if (s[1] === "flow")
            this.flowPragma = "flow";
          else if (s[1] === "noflow")
            this.flowPragma = "noflow";
          else
            throw new Error("Unexpected flow pragma");
      }
      super.addComment(e);
    }
    flowParseTypeInitialiser(e) {
      let s = this.state.inType;
      this.state.inType = true, this.expect(e || 14);
      let i = this.flowParseType();
      return this.state.inType = s, i;
    }
    flowParsePredicate() {
      let e = this.startNode(), s = this.state.startLoc;
      return this.next(), this.expectContextual(108), this.state.lastTokStart > s.index + 1 && this.raise(D.UnexpectedSpaceBetweenModuloChecks, { at: s }), this.eat(10) ? (e.value = super.parseExpression(), this.expect(11), this.finishNode(e, "DeclaredPredicate")) : this.finishNode(e, "InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      let e = this.state.inType;
      this.state.inType = true, this.expect(14);
      let s = null, i = null;
      return this.match(54) ? (this.state.inType = e, i = this.flowParsePredicate()) : (s = this.flowParseType(), this.state.inType = e, this.match(54) && (i = this.flowParsePredicate())), [s, i];
    }
    flowParseDeclareClass(e) {
      return this.next(), this.flowParseInterfaceish(e, true), this.finishNode(e, "DeclareClass");
    }
    flowParseDeclareFunction(e) {
      this.next();
      let s = e.id = this.parseIdentifier(), i = this.startNode(), a = this.startNode();
      this.match(47) ? i.typeParameters = this.flowParseTypeParameterDeclaration() : i.typeParameters = null, this.expect(10);
      let n = this.flowParseFunctionTypeParams();
      return i.params = n.params, i.rest = n.rest, i.this = n._this, this.expect(11), [i.returnType, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), a.typeAnnotation = this.finishNode(i, "FunctionTypeAnnotation"), s.typeAnnotation = this.finishNode(a, "TypeAnnotation"), this.resetEndLocation(s), this.semicolon(), this.scope.declareName(e.id.name, il2, e.id.loc.start), this.finishNode(e, "DeclareFunction");
    }
    flowParseDeclare(e, s) {
      if (this.match(80))
        return this.flowParseDeclareClass(e);
      if (this.match(68))
        return this.flowParseDeclareFunction(e);
      if (this.match(74))
        return this.flowParseDeclareVariable(e);
      if (this.eatContextual(125))
        return this.match(16) ? this.flowParseDeclareModuleExports(e) : (s && this.raise(D.NestedDeclareModule, { at: this.state.lastTokStartLoc }), this.flowParseDeclareModule(e));
      if (this.isContextual(128))
        return this.flowParseDeclareTypeAlias(e);
      if (this.isContextual(129))
        return this.flowParseDeclareOpaqueType(e);
      if (this.isContextual(127))
        return this.flowParseDeclareInterface(e);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(e, s);
      this.unexpected();
    }
    flowParseDeclareVariable(e) {
      return this.next(), e.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(e.id.name, At2, e.id.loc.start), this.semicolon(), this.finishNode(e, "DeclareVariable");
    }
    flowParseDeclareModule(e) {
      this.scope.enter(qe2), this.match(131) ? e.id = super.parseExprAtom() : e.id = this.parseIdentifier();
      let s = e.body = this.startNode(), i = s.body = [];
      for (this.expect(5); !this.match(8); ) {
        let o = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(128) && !this.match(87) && this.raise(D.InvalidNonTypeImportInDeclareModule, { at: this.state.lastTokStartLoc }), super.parseImport(o)) : (this.expectContextual(123, D.UnsupportedStatementInDeclareModule), o = this.flowParseDeclare(o, true)), i.push(o);
      }
      this.scope.exit(), this.expect(8), this.finishNode(s, "BlockStatement");
      let a = null, n = false;
      return i.forEach((o) => {
        Ml2(o) ? (a === "CommonJS" && this.raise(D.AmbiguousDeclareModuleKind, { at: o }), a = "ES") : o.type === "DeclareModuleExports" && (n && this.raise(D.DuplicateDeclareModuleExports, { at: o }), a === "ES" && this.raise(D.AmbiguousDeclareModuleKind, { at: o }), a = "CommonJS", n = true);
      }), e.kind = a || "CommonJS", this.finishNode(e, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(e, s) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? e.declaration = this.flowParseDeclare(this.startNode()) : (e.declaration = this.flowParseType(), this.semicolon()), e.default = true, this.finishNode(e, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(128) || this.isContextual(127)) && !s) {
        let i = this.state.value;
        throw this.raise(D.UnsupportedDeclareExportKind, { at: this.state.startLoc, unsupportedExportKind: i, suggestion: _l2[i] });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(129))
        return e.declaration = this.flowParseDeclare(this.startNode()), e.default = false, this.finishNode(e, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(127) || this.isContextual(128) || this.isContextual(129))
        return e = this.parseExport(e, null), e.type === "ExportNamedDeclaration" && (e.type = "ExportDeclaration", e.default = false, delete e.exportKind), e.type = "Declare" + e.type, e;
      this.unexpected();
    }
    flowParseDeclareModuleExports(e) {
      return this.next(), this.expectContextual(109), e.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(e, "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(e) {
      this.next();
      let s = this.flowParseTypeAlias(e);
      return s.type = "DeclareTypeAlias", s;
    }
    flowParseDeclareOpaqueType(e) {
      this.next();
      let s = this.flowParseOpaqueType(e, true);
      return s.type = "DeclareOpaqueType", s;
    }
    flowParseDeclareInterface(e) {
      return this.next(), this.flowParseInterfaceish(e, false), this.finishNode(e, "DeclareInterface");
    }
    flowParseInterfaceish(e, s) {
      if (e.id = this.flowParseRestrictedIdentifier(!s, true), this.scope.declareName(e.id.name, s ? Ir2 : He2, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.extends = [], e.implements = [], e.mixins = [], this.eat(81))
        do
          e.extends.push(this.flowParseInterfaceExtends());
        while (!s && this.eat(12));
      if (s) {
        if (this.eatContextual(115))
          do
            e.mixins.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        if (this.eatContextual(111))
          do
            e.implements.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
      }
      e.body = this.flowParseObjectType({ allowStatic: s, allowExact: false, allowSpread: false, allowProto: s, allowInexact: false });
    }
    flowParseInterfaceExtends() {
      let e = this.startNode();
      return e.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? e.typeParameters = this.flowParseTypeParameterInstantiation() : e.typeParameters = null, this.finishNode(e, "InterfaceExtends");
    }
    flowParseInterface(e) {
      return this.flowParseInterfaceish(e, false), this.finishNode(e, "InterfaceDeclaration");
    }
    checkNotUnderscore(e) {
      e === "_" && this.raise(D.UnexpectedReservedUnderscore, { at: this.state.startLoc });
    }
    checkReservedType(e, s, i) {
      Bl2.has(e) && this.raise(i ? D.AssignReservedType : D.UnexpectedReservedType, { at: s, reservedType: e });
    }
    flowParseRestrictedIdentifier(e, s) {
      return this.checkReservedType(this.state.value, this.state.startLoc, s), this.parseIdentifier(e);
    }
    flowParseTypeAlias(e) {
      return e.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(e.id.name, He2, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(e, "TypeAlias");
    }
    flowParseOpaqueType(e, s) {
      return this.expectContextual(128), e.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(e.id.name, He2, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.supertype = null, this.match(14) && (e.supertype = this.flowParseTypeInitialiser(14)), e.impltype = null, s || (e.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e, "OpaqueType");
    }
    flowParseTypeParameter() {
      let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, s = this.state.startLoc, i = this.startNode(), a = this.flowParseVariance(), n = this.flowParseTypeAnnotatableIdentifier();
      return i.name = n.name, i.variance = a, i.bound = n.typeAnnotation, this.match(29) ? (this.eat(29), i.default = this.flowParseType()) : e && this.raise(D.MissingTypeParamDefault, { at: s }), this.finishNode(i, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      let e = this.state.inType, s = this.startNode();
      s.params = [], this.state.inType = true, this.match(47) || this.match(140) ? this.next() : this.unexpected();
      let i = false;
      do {
        let a = this.flowParseTypeParameter(i);
        s.params.push(a), a.default && (i = true), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = e, this.finishNode(s, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      let e = this.startNode(), s = this.state.inType;
      e.params = [], this.state.inType = true, this.expect(47);
      let i = this.state.noAnonFunctionType;
      for (this.state.noAnonFunctionType = false; !this.match(48); )
        e.params.push(this.flowParseType()), this.match(48) || this.expect(12);
      return this.state.noAnonFunctionType = i, this.expect(48), this.state.inType = s, this.finishNode(e, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      let e = this.startNode(), s = this.state.inType;
      for (e.params = [], this.state.inType = true, this.expect(47); !this.match(48); )
        e.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = s, this.finishNode(e, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      let e = this.startNode();
      if (this.expectContextual(127), e.extends = [], this.eat(81))
        do
          e.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return e.body = this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false }), this.finishNode(e, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(132) || this.match(131) ? super.parseExprAtom() : this.parseIdentifier(true);
    }
    flowParseObjectTypeIndexer(e, s, i) {
      return e.static = s, this.lookahead().type === 14 ? (e.id = this.flowParseObjectPropertyKey(), e.key = this.flowParseTypeInitialiser()) : (e.id = null, e.key = this.flowParseType()), this.expect(3), e.value = this.flowParseTypeInitialiser(), e.variance = i, this.finishNode(e, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(e, s) {
      return e.static = s, e.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (e.method = true, e.optional = false, e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.loc.start))) : (e.method = false, this.eat(17) && (e.optional = true), e.value = this.flowParseTypeInitialiser()), this.finishNode(e, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(e) {
      for (e.params = [], e.rest = null, e.typeParameters = null, e.this = null, this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (e.this = this.flowParseFunctionTypeParam(true), e.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
        e.params.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
      return this.eat(21) && (e.rest = this.flowParseFunctionTypeParam(false)), this.expect(11), e.returnType = this.flowParseTypeInitialiser(), this.finishNode(e, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(e, s) {
      let i = this.startNode();
      return e.static = s, e.value = this.flowParseObjectTypeMethodish(i), this.finishNode(e, "ObjectTypeCallProperty");
    }
    flowParseObjectType(e) {
      let { allowStatic: s, allowExact: i, allowSpread: a, allowProto: n, allowInexact: o } = e, u = this.state.inType;
      this.state.inType = true;
      let c = this.startNode();
      c.callProperties = [], c.properties = [], c.indexers = [], c.internalSlots = [];
      let y2, g2, T = false;
      for (i && this.match(6) ? (this.expect(6), y2 = 9, g2 = true) : (this.expect(5), y2 = 8, g2 = false), c.exact = g2; !this.match(y2); ) {
        let j = false, q = null, G = null, J = this.startNode();
        if (n && this.isContextual(116)) {
          let Z = this.lookahead();
          Z.type !== 14 && Z.type !== 17 && (this.next(), q = this.state.startLoc, s = false);
        }
        if (s && this.isContextual(104)) {
          let Z = this.lookahead();
          Z.type !== 14 && Z.type !== 17 && (this.next(), j = true);
        }
        let K2 = this.flowParseVariance();
        if (this.eat(0))
          q != null && this.unexpected(q), this.eat(0) ? (K2 && this.unexpected(K2.loc.start), c.internalSlots.push(this.flowParseObjectTypeInternalSlot(J, j))) : c.indexers.push(this.flowParseObjectTypeIndexer(J, j, K2));
        else if (this.match(10) || this.match(47))
          q != null && this.unexpected(q), K2 && this.unexpected(K2.loc.start), c.callProperties.push(this.flowParseObjectTypeCallProperty(J, j));
        else {
          let Z = "init";
          if (this.isContextual(98) || this.isContextual(103)) {
            let yh = this.lookahead();
            _e2(yh.type) && (Z = this.state.value, this.next());
          }
          let We2 = this.flowParseObjectTypeProperty(J, j, q, K2, Z, a, o != null ? o : !g2);
          We2 === null ? (T = true, G = this.state.lastTokStartLoc) : c.properties.push(We2);
        }
        this.flowObjectTypeSemicolon(), G && !this.match(8) && !this.match(9) && this.raise(D.UnexpectedExplicitInexactInObject, { at: G });
      }
      this.expect(y2), a && (c.inexact = T);
      let C = this.finishNode(c, "ObjectTypeAnnotation");
      return this.state.inType = u, C;
    }
    flowParseObjectTypeProperty(e, s, i, a, n, o, u) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (o ? u || this.raise(D.InexactInsideExact, { at: this.state.lastTokStartLoc }) : this.raise(D.InexactInsideNonObject, { at: this.state.lastTokStartLoc }), a && this.raise(D.InexactVariance, { at: a }), null) : (o || this.raise(D.UnexpectedSpreadType, { at: this.state.lastTokStartLoc }), i != null && this.unexpected(i), a && this.raise(D.SpreadVariance, { at: a }), e.argument = this.flowParseType(), this.finishNode(e, "ObjectTypeSpreadProperty"));
      {
        e.key = this.flowParseObjectPropertyKey(), e.static = s, e.proto = i != null, e.kind = n;
        let c = false;
        return this.match(47) || this.match(10) ? (e.method = true, i != null && this.unexpected(i), a && this.unexpected(a.loc.start), e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.loc.start)), (n === "get" || n === "set") && this.flowCheckGetterSetterParams(e), !o && e.key.name === "constructor" && e.value.this && this.raise(D.ThisParamBannedInConstructor, { at: e.value.this })) : (n !== "init" && this.unexpected(), e.method = false, this.eat(17) && (c = true), e.value = this.flowParseTypeInitialiser(), e.variance = a), e.optional = c, this.finishNode(e, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(e) {
      let s = e.kind === "get" ? 0 : 1, i = e.value.params.length + (e.value.rest ? 1 : 0);
      e.value.this && this.raise(e.kind === "get" ? D.GetterMayNotHaveThisParam : D.SetterMayNotHaveThisParam, { at: e.value.this }), i !== s && this.raise(e.kind === "get" ? p.BadGetterArity : p.BadSetterArity, { at: e }), e.kind === "set" && e.value.rest && this.raise(p.BadSetterRestParameter, { at: e });
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(e, s) {
      e != null || (e = this.state.startLoc);
      let a = s || this.flowParseRestrictedIdentifier(true);
      for (; this.eat(16); ) {
        let n = this.startNodeAt(e);
        n.qualification = a, n.id = this.flowParseRestrictedIdentifier(true), a = this.finishNode(n, "QualifiedTypeIdentifier");
      }
      return a;
    }
    flowParseGenericType(e, s) {
      let i = this.startNodeAt(e);
      return i.typeParameters = null, i.id = this.flowParseQualifiedTypeIdentifier(e, s), this.match(47) && (i.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(i, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      let e = this.startNode();
      return this.expect(87), e.argument = this.flowParsePrimaryType(), this.finishNode(e, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      let e = this.startNode();
      for (e.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (e.types.push(this.flowParseType()), !this.match(3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(e, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(e) {
      let s = null, i = false, a = null, n = this.startNode(), o = this.lookahead(), u = this.state.type === 78;
      return o.type === 14 || o.type === 17 ? (u && !e && this.raise(D.ThisParamMustBeFirst, { at: n }), s = this.parseIdentifier(u), this.eat(17) && (i = true, u && this.raise(D.ThisParamMayNotBeOptional, { at: n })), a = this.flowParseTypeInitialiser()) : a = this.flowParseType(), n.name = s, n.optional = i, n.typeAnnotation = a, this.finishNode(n, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(e) {
      let s = this.startNodeAt(e.loc.start);
      return s.name = null, s.optional = false, s.typeAnnotation = e, this.finishNode(s, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams() {
      let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], s = null, i = null;
      for (this.match(78) && (i = this.flowParseFunctionTypeParam(true), i.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
        e.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
      return this.eat(21) && (s = this.flowParseFunctionTypeParam(false)), { params: e, rest: s, _this: i };
    }
    flowIdentToTypeAnnotation(e, s, i) {
      switch (i.name) {
        case "any":
          return this.finishNode(s, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(s, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(s, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(s, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(s, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(s, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(s, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(i.name), this.flowParseGenericType(e, i);
      }
    }
    flowParsePrimaryType() {
      let e = this.state.startLoc, s = this.startNode(), i, a, n = false, o = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true });
        case 6:
          return this.flowParseObjectType({ allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false });
        case 0:
          return this.state.noAnonFunctionType = false, a = this.flowParseTupleType(), this.state.noAnonFunctionType = o, a;
        case 47:
          return s.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), i = this.flowParseFunctionTypeParams(), s.params = i.params, s.rest = i.rest, s.this = i._this, this.expect(11), this.expect(19), s.returnType = this.flowParseType(), this.finishNode(s, "FunctionTypeAnnotation");
        case 10:
          if (this.next(), !this.match(11) && !this.match(21))
            if (R2(this.state.type) || this.match(78)) {
              let u = this.lookahead().type;
              n = u !== 17 && u !== 14;
            } else
              n = true;
          if (n) {
            if (this.state.noAnonFunctionType = false, a = this.flowParseType(), this.state.noAnonFunctionType = o, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), a;
            this.eat(12);
          }
          return a ? i = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(a)]) : i = this.flowParseFunctionTypeParams(), s.params = i.params, s.rest = i.rest, s.this = i._this, this.expect(11), this.expect(19), s.returnType = this.flowParseType(), s.typeParameters = null, this.finishNode(s, "FunctionTypeAnnotation");
        case 131:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return s.value = this.match(85), this.next(), this.finishNode(s, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(132))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", s);
            if (this.match(133))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", s);
            throw this.raise(D.UnexpectedSubtractionOperand, { at: this.state.startLoc });
          }
          this.unexpected();
          return;
        case 132:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 133:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(s, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(s, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(s, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(s, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (Ee(this.state.type)) {
            let u = Y(this.state.type);
            return this.next(), super.createIdentifier(s, u);
          } else if (R2(this.state.type))
            return this.isContextual(127) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(e, s, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      let e = this.state.startLoc, s = this.flowParsePrimaryType(), i = false;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        let a = this.startNodeAt(e), n = this.eat(18);
        i = i || n, this.expect(0), !n && this.match(3) ? (a.elementType = s, this.next(), s = this.finishNode(a, "ArrayTypeAnnotation")) : (a.objectType = s, a.indexType = this.flowParseType(), this.expect(3), i ? (a.optional = n, s = this.finishNode(a, "OptionalIndexedAccessType")) : s = this.finishNode(a, "IndexedAccessType"));
      }
      return s;
    }
    flowParsePrefixType() {
      let e = this.startNode();
      return this.eat(17) ? (e.typeAnnotation = this.flowParsePrefixType(), this.finishNode(e, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      let e = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        let s = this.startNodeAt(e.loc.start);
        return s.params = [this.reinterpretTypeAsFunctionTypeParam(e)], s.rest = null, s.this = null, s.returnType = this.flowParseType(), s.typeParameters = null, this.finishNode(s, "FunctionTypeAnnotation");
      }
      return e;
    }
    flowParseIntersectionType() {
      let e = this.startNode();
      this.eat(45);
      let s = this.flowParseAnonFunctionWithoutParens();
      for (e.types = [s]; this.eat(45); )
        e.types.push(this.flowParseAnonFunctionWithoutParens());
      return e.types.length === 1 ? s : this.finishNode(e, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      let e = this.startNode();
      this.eat(43);
      let s = this.flowParseIntersectionType();
      for (e.types = [s]; this.eat(43); )
        e.types.push(this.flowParseIntersectionType());
      return e.types.length === 1 ? s : this.finishNode(e, "UnionTypeAnnotation");
    }
    flowParseType() {
      let e = this.state.inType;
      this.state.inType = true;
      let s = this.flowParseUnionType();
      return this.state.inType = e, s;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 130 && this.state.value === "_") {
        let e = this.state.startLoc, s = this.parseIdentifier();
        return this.flowParseGenericType(e, s);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      let e = this.startNode();
      return e.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(e, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(e) {
      let s = e ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (s.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(s)), s;
    }
    typeCastToParameter(e) {
      return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
    }
    flowParseVariance() {
      let e = null;
      return this.match(53) ? (e = this.startNode(), this.state.value === "+" ? e.kind = "plus" : e.kind = "minus", this.next(), this.finishNode(e, "Variance")) : e;
    }
    parseFunctionBody(e, s) {
      let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      if (s) {
        this.forwardNoArrowParamsConversionAt(e, () => super.parseFunctionBody(e, true, i));
        return;
      }
      super.parseFunctionBody(e, false, i);
    }
    parseFunctionBodyAndFinish(e, s) {
      let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      if (this.match(14)) {
        let a = this.startNode();
        [a.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), e.returnType = a.typeAnnotation ? this.finishNode(a, "TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(e, s, i);
    }
    parseStatementLike(e) {
      if (this.state.strict && this.isContextual(127)) {
        let i = this.lookahead();
        if (se2(i.type)) {
          let a = this.startNode();
          return this.next(), this.flowParseInterface(a);
        }
      } else if (this.shouldParseEnums() && this.isContextual(124)) {
        let i = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(i);
      }
      let s = super.parseStatementLike(e);
      return this.flowPragma === void 0 && !this.isValidDirective(s) && (this.flowPragma = null), s;
    }
    parseExpressionStatement(e, s, i) {
      if (s.type === "Identifier") {
        if (s.name === "declare") {
          if (this.match(80) || R2(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(e);
        } else if (R2(this.state.type)) {
          if (s.name === "interface")
            return this.flowParseInterface(e);
          if (s.name === "type")
            return this.flowParseTypeAlias(e);
          if (s.name === "opaque")
            return this.flowParseOpaqueType(e, false);
        }
      }
      return super.parseExpressionStatement(e, s, i);
    }
    shouldParseExportDeclaration() {
      let { type: e } = this.state;
      return ne2(e) || this.shouldParseEnums() && e === 124 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      let { type: e } = this.state;
      return ne2(e) || this.shouldParseEnums() && e === 124 ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual(124)) {
        let e = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(e);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(e, s, i) {
      if (!this.match(17))
        return e;
      if (this.state.maybeInArrowParameters) {
        let T = this.lookaheadCharCode();
        if (T === 44 || T === 61 || T === 58 || T === 41)
          return this.setOptionalParametersError(i), e;
      }
      this.expect(17);
      let a = this.state.clone(), n = this.state.noArrowAt, o = this.startNodeAt(s), { consequent: u, failed: c } = this.tryParseConditionalConsequent(), [y2, g2] = this.getArrowLikeExpressions(u);
      if (c || g2.length > 0) {
        let T = [...n];
        if (g2.length > 0) {
          this.state = a, this.state.noArrowAt = T;
          for (let C = 0; C < g2.length; C++)
            T.push(g2[C].start);
          ({ consequent: u, failed: c } = this.tryParseConditionalConsequent()), [y2, g2] = this.getArrowLikeExpressions(u);
        }
        c && y2.length > 1 && this.raise(D.AmbiguousConditionalArrow, { at: a.startLoc }), c && y2.length === 1 && (this.state = a, T.push(y2[0].start), this.state.noArrowAt = T, { consequent: u, failed: c } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(u, true), this.state.noArrowAt = n, this.expect(14), o.test = e, o.consequent = u, o.alternate = this.forwardNoArrowParamsConversionAt(o, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(o, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      let e = this.parseMaybeAssignAllowIn(), s = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), { consequent: e, failed: s };
    }
    getArrowLikeExpressions(e, s) {
      let i = [e], a = [];
      for (; i.length !== 0; ) {
        let n = i.pop();
        n.type === "ArrowFunctionExpression" ? (n.typeParameters || !n.returnType ? this.finishArrowValidation(n) : a.push(n), i.push(n.body)) : n.type === "ConditionalExpression" && (i.push(n.consequent), i.push(n.alternate));
      }
      return s ? (a.forEach((n) => this.finishArrowValidation(n)), [a, []]) : Rl2(a, (n) => n.params.every((o) => this.isAssignable(o, true)));
    }
    finishArrowValidation(e) {
      var s;
      this.toAssignableList(e.params, (s = e.extra) == null ? void 0 : s.trailingCommaLoc, false), this.scope.enter(Ae2 | es), super.checkParams(e, false, true), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(e, s) {
      let i;
      return this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), i = s(), this.state.noArrowParamsConversionAt.pop()) : i = s(), i;
    }
    parseParenItem(e, s) {
      if (e = super.parseParenItem(e, s), this.eat(17) && (e.optional = true, this.resetEndLocation(e)), this.match(14)) {
        let i = this.startNodeAt(s);
        return i.expression = e, i.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(i, "TypeCastExpression");
      }
      return e;
    }
    assertModuleNodeAllowed(e) {
      e.type === "ImportDeclaration" && (e.importKind === "type" || e.importKind === "typeof") || e.type === "ExportNamedDeclaration" && e.exportKind === "type" || e.type === "ExportAllDeclaration" && e.exportKind === "type" || super.assertModuleNodeAllowed(e);
    }
    parseExport(e, s) {
      let i = super.parseExport(e, s);
      return (i.type === "ExportNamedDeclaration" || i.type === "ExportAllDeclaration") && (i.exportKind = i.exportKind || "value"), i;
    }
    parseExportDeclaration(e) {
      if (this.isContextual(128)) {
        e.exportKind = "type";
        let s = this.startNode();
        return this.next(), this.match(5) ? (e.specifiers = this.parseExportSpecifiers(true), super.parseExportFrom(e), null) : this.flowParseTypeAlias(s);
      } else if (this.isContextual(129)) {
        e.exportKind = "type";
        let s = this.startNode();
        return this.next(), this.flowParseOpaqueType(s, false);
      } else if (this.isContextual(127)) {
        e.exportKind = "type";
        let s = this.startNode();
        return this.next(), this.flowParseInterface(s);
      } else if (this.shouldParseEnums() && this.isContextual(124)) {
        e.exportKind = "value";
        let s = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(s);
      } else
        return super.parseExportDeclaration(e);
    }
    eatExportStar(e) {
      return super.eatExportStar(e) ? true : this.isContextual(128) && this.lookahead().type === 55 ? (e.exportKind = "type", this.next(), this.next(), true) : false;
    }
    maybeParseExportNamespaceSpecifier(e) {
      let { startLoc: s } = this.state, i = super.maybeParseExportNamespaceSpecifier(e);
      return i && e.exportKind === "type" && this.unexpected(s), i;
    }
    parseClassId(e, s, i) {
      super.parseClassId(e, s, i), this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(e, s, i) {
      let { startLoc: a } = this.state;
      if (this.isContextual(123)) {
        if (super.parseClassMemberFromModifier(e, s))
          return;
        s.declare = true;
      }
      super.parseClassMember(e, s, i), s.declare && (s.type !== "ClassProperty" && s.type !== "ClassPrivateProperty" && s.type !== "PropertyDefinition" ? this.raise(D.DeclareClassElement, { at: a }) : s.value && this.raise(D.DeclareClassFieldInitializer, { at: s.value }));
    }
    isIterator(e) {
      return e === "iterator" || e === "asyncIterator";
    }
    readIterator() {
      let e = super.readWord1(), s = "@@" + e;
      (!this.isIterator(e) || !this.state.inType) && this.raise(p.InvalidIdentifier, { at: this.state.curPosition(), identifierName: s }), this.finishToken(130, s);
    }
    getTokenFromCode(e) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      e === 123 && s === 124 ? this.finishOp(6, 2) : this.state.inType && (e === 62 || e === 60) ? this.finishOp(e === 62 ? 48 : 47, 1) : this.state.inType && e === 63 ? s === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : Jo2(e, s, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(e);
    }
    isAssignable(e, s) {
      return e.type === "TypeCastExpression" ? this.isAssignable(e.expression, s) : super.isAssignable(e, s);
    }
    toAssignable(e) {
      let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      !s && e.type === "AssignmentExpression" && e.left.type === "TypeCastExpression" && (e.left = this.typeCastToParameter(e.left)), super.toAssignable(e, s);
    }
    toAssignableList(e, s, i) {
      for (let a = 0; a < e.length; a++) {
        let n = e[a];
        (n == null ? void 0 : n.type) === "TypeCastExpression" && (e[a] = this.typeCastToParameter(n));
      }
      super.toAssignableList(e, s, i);
    }
    toReferencedList(e, s) {
      for (let a = 0; a < e.length; a++) {
        var i;
        let n = e[a];
        n && n.type === "TypeCastExpression" && !((i = n.extra) != null && i.parenthesized) && (e.length > 1 || !s) && this.raise(D.TypeCastInPattern, { at: n.typeAnnotation });
      }
      return e;
    }
    parseArrayLike(e, s, i, a) {
      let n = super.parseArrayLike(e, s, i, a);
      return s && !this.state.maybeInArrowParameters && this.toReferencedList(n.elements), n;
    }
    isValidLVal(e, s, i) {
      return e === "TypeCastExpression" || super.isValidLVal(e, s, i);
    }
    parseClassProperty(e) {
      return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e);
    }
    parseClassPrivateProperty(e) {
      return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(e) {
      return !this.match(14) && super.isNonstaticConstructor(e);
    }
    pushClassMethod(e, s, i, a, n, o) {
      if (s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e, s, i, a, n, o), s.params && n) {
        let u = s.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(D.ThisParamBannedInConstructor, { at: s });
      } else if (s.type === "MethodDefinition" && n && s.value.params) {
        let u = s.value.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(D.ThisParamBannedInConstructor, { at: s });
      }
    }
    pushClassPrivateMethod(e, s, i, a) {
      s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e, s, i, a);
    }
    parseClassSuper(e) {
      if (super.parseClassSuper(e), e.superClass && this.match(47) && (e.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(111)) {
        this.next();
        let s = e.implements = [];
        do {
          let i = this.startNode();
          i.id = this.flowParseRestrictedIdentifier(true), this.match(47) ? i.typeParameters = this.flowParseTypeParameterInstantiation() : i.typeParameters = null, s.push(this.finishNode(i, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(e) {
      super.checkGetterSetterParams(e);
      let s = this.getObjectOrClassMethodParams(e);
      if (s.length > 0) {
        let i = s[0];
        this.isThisParam(i) && e.kind === "get" ? this.raise(D.GetterMayNotHaveThisParam, { at: i }) : this.isThisParam(i) && this.raise(D.SetterMayNotHaveThisParam, { at: i });
      }
    }
    parsePropertyNamePrefixOperator(e) {
      e.variance = this.flowParseVariance();
    }
    parseObjPropValue(e, s, i, a, n, o, u) {
      e.variance && this.unexpected(e.variance.loc.start), delete e.variance;
      let c;
      this.match(47) && !o && (c = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      let y2 = super.parseObjPropValue(e, s, i, a, n, o, u);
      return c && ((y2.value || y2).typeParameters = c), y2;
    }
    parseAssignableListItemTypes(e) {
      return this.eat(17) && (e.type !== "Identifier" && this.raise(D.PatternIsOptional, { at: e }), this.isThisParam(e) && this.raise(D.ThisParamMayNotBeOptional, { at: e }), e.optional = true), this.match(14) ? e.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(e) && this.raise(D.ThisParamAnnotationRequired, { at: e }), this.match(29) && this.isThisParam(e) && this.raise(D.ThisParamNoDefault, { at: e }), this.resetEndLocation(e), e;
    }
    parseMaybeDefault(e, s) {
      let i = super.parseMaybeDefault(e, s);
      return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(D.TypeBeforeInitializer, { at: i.typeAnnotation }), i;
    }
    shouldParseDefaultImport(e) {
      return ys2(e) ? Vr2(this.state.type) : super.shouldParseDefaultImport(e);
    }
    checkImportReflection(e) {
      super.checkImportReflection(e), e.module && e.importKind !== "value" && this.raise(D.ImportReflectionHasImportType, { at: e.specifiers[0].loc.start });
    }
    parseImportSpecifierLocal(e, s, i) {
      s.local = ys2(e) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(s, i));
    }
    maybeParseDefaultImportSpecifier(e) {
      e.importKind = "value";
      let s = null;
      if (this.match(87) ? s = "typeof" : this.isContextual(128) && (s = "type"), s) {
        let i = this.lookahead(), { type: a } = i;
        s === "type" && a === 55 && this.unexpected(null, i.type), (Vr2(a) || a === 5 || a === 55) && (this.next(), e.importKind = s);
      }
      return super.maybeParseDefaultImportSpecifier(e);
    }
    parseImportSpecifier(e, s, i, a, n) {
      let o = e.imported, u = null;
      o.type === "Identifier" && (o.name === "type" ? u = "type" : o.name === "typeof" && (u = "typeof"));
      let c = false;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        let g2 = this.parseIdentifier(true);
        u !== null && !se2(this.state.type) ? (e.imported = g2, e.importKind = u, e.local = Te2(g2)) : (e.imported = o, e.importKind = null, e.local = this.parseIdentifier());
      } else {
        if (u !== null && se2(this.state.type))
          e.imported = this.parseIdentifier(true), e.importKind = u;
        else {
          if (s)
            throw this.raise(p.ImportBindingIsString, { at: e, importName: o.value });
          e.imported = o, e.importKind = null;
        }
        this.eatContextual(93) ? e.local = this.parseIdentifier() : (c = true, e.local = Te2(e.imported));
      }
      let y2 = ys2(e);
      return i && y2 && this.raise(D.ImportTypeShorthandOnlyInPureImport, { at: e }), (i || y2) && this.checkReservedType(e.local.name, e.local.loc.start, true), c && !i && !y2 && this.checkReservedWord(e.local.name, e.loc.start, true, true), this.finishImportSpecifier(e, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(true);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(e, s) {
      let i = e.kind;
      i !== "get" && i !== "set" && this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e, s);
    }
    parseVarId(e, s) {
      super.parseVarId(e, s), this.match(14) && (e.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e.id));
    }
    parseAsyncArrowFromCallExpression(e, s) {
      if (this.match(14)) {
        let i = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = true, e.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = i;
      }
      return super.parseAsyncArrowFromCallExpression(e, s);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(e, s) {
      var i;
      let a = null, n;
      if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
        if (a = this.state.clone(), n = this.tryParse(() => super.parseMaybeAssign(e, s), a), !n.error)
          return n.node;
        let { context: c } = this.state, y2 = c[c.length - 1];
        (y2 === x.j_oTag || y2 === x.j_expr) && c.pop();
      }
      if ((i = n) != null && i.error || this.match(47)) {
        var o, u;
        a = a || this.state.clone();
        let c, y2 = this.tryParse((T) => {
          var C;
          c = this.flowParseTypeParameterDeclaration();
          let j = this.forwardNoArrowParamsConversionAt(c, () => {
            let G = super.parseMaybeAssign(e, s);
            return this.resetStartLocationFromNode(G, c), G;
          });
          (C = j.extra) != null && C.parenthesized && T();
          let q = this.maybeUnwrapTypeCastExpression(j);
          return q.type !== "ArrowFunctionExpression" && T(), q.typeParameters = c, this.resetStartLocationFromNode(q, c), j;
        }, a), g2 = null;
        if (y2.node && this.maybeUnwrapTypeCastExpression(y2.node).type === "ArrowFunctionExpression") {
          if (!y2.error && !y2.aborted)
            return y2.node.async && this.raise(D.UnexpectedTypeParameterBeforeAsyncArrowFunction, { at: c }), y2.node;
          g2 = y2.node;
        }
        if ((o = n) != null && o.node)
          return this.state = n.failState, n.node;
        if (g2)
          return this.state = y2.failState, g2;
        throw (u = n) != null && u.thrown ? n.error : y2.thrown ? y2.error : this.raise(D.UnexpectedTokenAfterTypeParameter, { at: c });
      }
      return super.parseMaybeAssign(e, s);
    }
    parseArrow(e) {
      if (this.match(14)) {
        let s = this.tryParse(() => {
          let i = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          let a = this.startNode();
          return [a.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = i, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), a;
        });
        if (s.thrown)
          return null;
        s.error && (this.state = s.failState), e.returnType = s.node.typeAnnotation ? this.finishNode(s.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(e);
    }
    shouldParseArrow(e) {
      return this.match(14) || super.shouldParseArrow(e);
    }
    setArrowFunctionParameters(e, s) {
      this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1 ? e.params = s : super.setArrowFunctionParameters(e, s);
    }
    checkParams(e, s, i) {
      let a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      if (!(i && this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1)) {
        for (let n = 0; n < e.params.length; n++)
          this.isThisParam(e.params[n]) && n > 0 && this.raise(D.ThisParamMustBeFirst, { at: e.params[n] });
        super.checkParams(e, s, i, a);
      }
    }
    parseParenAndDistinguishExpression(e) {
      return super.parseParenAndDistinguishExpression(e && this.state.noArrowAt.indexOf(this.state.start) === -1);
    }
    parseSubscripts(e, s, i) {
      if (e.type === "Identifier" && e.name === "async" && this.state.noArrowAt.indexOf(s.index) !== -1) {
        this.next();
        let a = this.startNodeAt(s);
        a.callee = e, a.arguments = super.parseCallExpressionArguments(11, false), e = this.finishNode(a, "CallExpression");
      } else if (e.type === "Identifier" && e.name === "async" && this.match(47)) {
        let a = this.state.clone(), n = this.tryParse((u) => this.parseAsyncArrowWithTypeParameters(s) || u(), a);
        if (!n.error && !n.aborted)
          return n.node;
        let o = this.tryParse(() => super.parseSubscripts(e, s, i), a);
        if (o.node && !o.error)
          return o.node;
        if (n.node)
          return this.state = n.failState, n.node;
        if (o.node)
          return this.state = o.failState, o.node;
        throw n.error || o.error;
      }
      return super.parseSubscripts(e, s, i);
    }
    parseSubscript(e, s, i, a) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (a.optionalChainMember = true, i)
          return a.stop = true, e;
        this.next();
        let n = this.startNodeAt(s);
        return n.callee = e, n.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), n.arguments = this.parseCallExpressionArguments(11, false), n.optional = true, this.finishCallExpression(n, true);
      } else if (!i && this.shouldParseTypes() && this.match(47)) {
        let n = this.startNodeAt(s);
        n.callee = e;
        let o = this.tryParse(() => (n.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), n.arguments = super.parseCallExpressionArguments(11, false), a.optionalChainMember && (n.optional = false), this.finishCallExpression(n, a.optionalChainMember)));
        if (o.node)
          return o.error && (this.state = o.failState), o.node;
      }
      return super.parseSubscript(e, s, i, a);
    }
    parseNewCallee(e) {
      super.parseNewCallee(e);
      let s = null;
      this.shouldParseTypes() && this.match(47) && (s = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), e.typeArguments = s;
    }
    parseAsyncArrowWithTypeParameters(e) {
      let s = this.startNodeAt(e);
      if (this.parseFunctionParams(s, false), !!this.parseArrow(s))
        return super.parseArrowExpression(s, void 0, true);
    }
    readToken_mult_modulo(e) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (e === 42 && s === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = false, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(e);
    }
    readToken_pipe_amp(e) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (e === 124 && s === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(e);
    }
    parseTopLevel(e, s) {
      let i = super.parseTopLevel(e, s);
      return this.state.hasFlowComment && this.raise(D.UnterminatedFlowComment, { at: this.state.curPosition() }), i;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(D.NestedFlowComment, { at: this.state.startLoc });
        this.hasFlowCommentCompletion();
        let e = this.skipFlowComment();
        e && (this.state.pos += e, this.state.hasFlowComment = true);
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      let { pos: e } = this.state, s = 2;
      for (; [32, 9].includes(this.input.charCodeAt(e + s)); )
        s++;
      let i = this.input.charCodeAt(s + e), a = this.input.charCodeAt(s + e + 1);
      return i === 58 && a === 58 ? s + 2 : this.input.slice(s + e, s + e + 12) === "flow-include" ? s + 12 : i === 58 && a !== 58 ? s : false;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(p.UnterminatedComment, { at: this.state.curPosition() });
    }
    flowEnumErrorBooleanMemberNotInitialized(e, s) {
      let { enumName: i, memberName: a } = s;
      this.raise(D.EnumBooleanMemberNotInitialized, { at: e, memberName: a, enumName: i });
    }
    flowEnumErrorInvalidMemberInitializer(e, s) {
      return this.raise(s.explicitType ? s.explicitType === "symbol" ? D.EnumInvalidMemberInitializerSymbolType : D.EnumInvalidMemberInitializerPrimaryType : D.EnumInvalidMemberInitializerUnknownType, Object.assign({ at: e }, s));
    }
    flowEnumErrorNumberMemberNotInitialized(e, s) {
      let { enumName: i, memberName: a } = s;
      this.raise(D.EnumNumberMemberNotInitialized, { at: e, enumName: i, memberName: a });
    }
    flowEnumErrorStringMemberInconsistentlyInitailized(e, s) {
      let { enumName: i } = s;
      this.raise(D.EnumStringMemberInconsistentlyInitailized, { at: e, enumName: i });
    }
    flowEnumMemberInit() {
      let e = this.state.startLoc, s = () => this.match(12) || this.match(8);
      switch (this.state.type) {
        case 132: {
          let i = this.parseNumericLiteral(this.state.value);
          return s() ? { type: "number", loc: i.loc.start, value: i } : { type: "invalid", loc: e };
        }
        case 131: {
          let i = this.parseStringLiteral(this.state.value);
          return s() ? { type: "string", loc: i.loc.start, value: i } : { type: "invalid", loc: e };
        }
        case 85:
        case 86: {
          let i = this.parseBooleanLiteral(this.match(85));
          return s() ? { type: "boolean", loc: i.loc.start, value: i } : { type: "invalid", loc: e };
        }
        default:
          return { type: "invalid", loc: e };
      }
    }
    flowEnumMemberRaw() {
      let e = this.state.startLoc, s = this.parseIdentifier(true), i = this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc: e };
      return { id: s, init: i };
    }
    flowEnumCheckExplicitTypeMismatch(e, s, i) {
      let { explicitType: a } = s;
      a !== null && a !== i && this.flowEnumErrorInvalidMemberInitializer(e, s);
    }
    flowEnumMembers(e) {
      let { enumName: s, explicitType: i } = e, a = /* @__PURE__ */ new Set(), n = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] }, o = false;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          o = true;
          break;
        }
        let u = this.startNode(), { id: c, init: y2 } = this.flowEnumMemberRaw(), g2 = c.name;
        if (g2 === "")
          continue;
        /^[a-z]/.test(g2) && this.raise(D.EnumInvalidMemberName, { at: c, memberName: g2, suggestion: g2[0].toUpperCase() + g2.slice(1), enumName: s }), a.has(g2) && this.raise(D.EnumDuplicateMemberName, { at: c, memberName: g2, enumName: s }), a.add(g2);
        let T = { enumName: s, explicitType: i, memberName: g2 };
        switch (u.id = c, y2.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(y2.loc, T, "boolean"), u.init = y2.value, n.booleanMembers.push(this.finishNode(u, "EnumBooleanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(y2.loc, T, "number"), u.init = y2.value, n.numberMembers.push(this.finishNode(u, "EnumNumberMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(y2.loc, T, "string"), u.init = y2.value, n.stringMembers.push(this.finishNode(u, "EnumStringMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(y2.loc, T);
          case "none":
            switch (i) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(y2.loc, T);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(y2.loc, T);
                break;
              default:
                n.defaultedMembers.push(this.finishNode(u, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return { members: n, hasUnknownMembers: o };
    }
    flowEnumStringMembers(e, s, i) {
      let { enumName: a } = i;
      if (e.length === 0)
        return s;
      if (s.length === 0)
        return e;
      if (s.length > e.length) {
        for (let n of e)
          this.flowEnumErrorStringMemberInconsistentlyInitailized(n, { enumName: a });
        return s;
      } else {
        for (let n of s)
          this.flowEnumErrorStringMemberInconsistentlyInitailized(n, { enumName: a });
        return e;
      }
    }
    flowEnumParseExplicitType(e) {
      let { enumName: s } = e;
      if (!this.eatContextual(101))
        return null;
      if (!R2(this.state.type))
        throw this.raise(D.EnumInvalidExplicitTypeUnknownSupplied, { at: this.state.startLoc, enumName: s });
      let { value: i } = this.state;
      return this.next(), i !== "boolean" && i !== "number" && i !== "string" && i !== "symbol" && this.raise(D.EnumInvalidExplicitType, { at: this.state.startLoc, enumName: s, invalidEnumType: i }), i;
    }
    flowEnumBody(e, s) {
      let i = s.name, a = s.loc.start, n = this.flowEnumParseExplicitType({ enumName: i });
      this.expect(5);
      let { members: o, hasUnknownMembers: u } = this.flowEnumMembers({ enumName: i, explicitType: n });
      switch (e.hasUnknownMembers = u, n) {
        case "boolean":
          return e.explicitType = true, e.members = o.booleanMembers, this.expect(8), this.finishNode(e, "EnumBooleanBody");
        case "number":
          return e.explicitType = true, e.members = o.numberMembers, this.expect(8), this.finishNode(e, "EnumNumberBody");
        case "string":
          return e.explicitType = true, e.members = this.flowEnumStringMembers(o.stringMembers, o.defaultedMembers, { enumName: i }), this.expect(8), this.finishNode(e, "EnumStringBody");
        case "symbol":
          return e.members = o.defaultedMembers, this.expect(8), this.finishNode(e, "EnumSymbolBody");
        default: {
          let c = () => (e.members = [], this.expect(8), this.finishNode(e, "EnumStringBody"));
          e.explicitType = false;
          let y2 = o.booleanMembers.length, g2 = o.numberMembers.length, T = o.stringMembers.length, C = o.defaultedMembers.length;
          if (!y2 && !g2 && !T && !C)
            return c();
          if (!y2 && !g2)
            return e.members = this.flowEnumStringMembers(o.stringMembers, o.defaultedMembers, { enumName: i }), this.expect(8), this.finishNode(e, "EnumStringBody");
          if (!g2 && !T && y2 >= C) {
            for (let j of o.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(j.loc.start, { enumName: i, memberName: j.id.name });
            return e.members = o.booleanMembers, this.expect(8), this.finishNode(e, "EnumBooleanBody");
          } else if (!y2 && !T && g2 >= C) {
            for (let j of o.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(j.loc.start, { enumName: i, memberName: j.id.name });
            return e.members = o.numberMembers, this.expect(8), this.finishNode(e, "EnumNumberBody");
          } else
            return this.raise(D.EnumInconsistentMemberValues, { at: a, enumName: i }), c();
        }
      }
    }
    flowParseEnumDeclaration(e) {
      let s = this.parseIdentifier();
      return e.id = s, e.body = this.flowEnumBody(this.startNode(), s), this.finishNode(e, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      let e = this.nextTokenStart();
      if (this.input.charCodeAt(e) === 60) {
        let s = this.input.charCodeAt(e + 1);
        return s !== 60 && s !== 61;
      }
      return false;
    }
    maybeUnwrapTypeCastExpression(e) {
      return e.type === "TypeCastExpression" ? e.expression : e;
    }
  }, Ul2 = { __proto__: null, quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: " ", iexcl: "¡", cent: "¢", pound: "£", curren: "¤", yen: "¥", brvbar: "¦", sect: "§", uml: "¨", copy: "©", ordf: "ª", laquo: "«", not: "¬", shy: "­", reg: "®", macr: "¯", deg: "°", plusmn: "±", sup2: "²", sup3: "³", acute: "´", micro: "µ", para: "¶", middot: "·", cedil: "¸", sup1: "¹", ordm: "º", raquo: "»", frac14: "¼", frac12: "½", frac34: "¾", iquest: "¿", Agrave: "À", Aacute: "Á", Acirc: "Â", Atilde: "Ã", Auml: "Ä", Aring: "Å", AElig: "Æ", Ccedil: "Ç", Egrave: "È", Eacute: "É", Ecirc: "Ê", Euml: "Ë", Igrave: "Ì", Iacute: "Í", Icirc: "Î", Iuml: "Ï", ETH: "Ð", Ntilde: "Ñ", Ograve: "Ò", Oacute: "Ó", Ocirc: "Ô", Otilde: "Õ", Ouml: "Ö", times: "×", Oslash: "Ø", Ugrave: "Ù", Uacute: "Ú", Ucirc: "Û", Uuml: "Ü", Yacute: "Ý", THORN: "Þ", szlig: "ß", agrave: "à", aacute: "á", acirc: "â", atilde: "ã", auml: "ä", aring: "å", aelig: "æ", ccedil: "ç", egrave: "è", eacute: "é", ecirc: "ê", euml: "ë", igrave: "ì", iacute: "í", icirc: "î", iuml: "ï", eth: "ð", ntilde: "ñ", ograve: "ò", oacute: "ó", ocirc: "ô", otilde: "õ", ouml: "ö", divide: "÷", oslash: "ø", ugrave: "ù", uacute: "ú", ucirc: "û", uuml: "ü", yacute: "ý", thorn: "þ", yuml: "ÿ", OElig: "Œ", oelig: "œ", Scaron: "Š", scaron: "š", Yuml: "Ÿ", fnof: "ƒ", circ: "ˆ", tilde: "˜", Alpha: "Α", Beta: "Β", Gamma: "Γ", Delta: "Δ", Epsilon: "Ε", Zeta: "Ζ", Eta: "Η", Theta: "Θ", Iota: "Ι", Kappa: "Κ", Lambda: "Λ", Mu: "Μ", Nu: "Ν", Xi: "Ξ", Omicron: "Ο", Pi: "Π", Rho: "Ρ", Sigma: "Σ", Tau: "Τ", Upsilon: "Υ", Phi: "Φ", Chi: "Χ", Psi: "Ψ", Omega: "Ω", alpha: "α", beta: "β", gamma: "γ", delta: "δ", epsilon: "ε", zeta: "ζ", eta: "η", theta: "θ", iota: "ι", kappa: "κ", lambda: "λ", mu: "μ", nu: "ν", xi: "ξ", omicron: "ο", pi: "π", rho: "ρ", sigmaf: "ς", sigma: "σ", tau: "τ", upsilon: "υ", phi: "φ", chi: "χ", psi: "ψ", omega: "ω", thetasym: "ϑ", upsih: "ϒ", piv: "ϖ", ensp: " ", emsp: " ", thinsp: " ", zwnj: "‌", zwj: "‍", lrm: "‎", rlm: "‏", ndash: "–", mdash: "—", lsquo: "‘", rsquo: "’", sbquo: "‚", ldquo: "“", rdquo: "”", bdquo: "„", dagger: "†", Dagger: "‡", bull: "•", hellip: "…", permil: "‰", prime: "′", Prime: "″", lsaquo: "‹", rsaquo: "›", oline: "‾", frasl: "⁄", euro: "€", image: "ℑ", weierp: "℘", real: "ℜ", trade: "™", alefsym: "ℵ", larr: "←", uarr: "↑", rarr: "→", darr: "↓", harr: "↔", crarr: "↵", lArr: "⇐", uArr: "⇑", rArr: "⇒", dArr: "⇓", hArr: "⇔", forall: "∀", part: "∂", exist: "∃", empty: "∅", nabla: "∇", isin: "∈", notin: "∉", ni: "∋", prod: "∏", sum: "∑", minus: "−", lowast: "∗", radic: "√", prop: "∝", infin: "∞", ang: "∠", and: "∧", or: "∨", cap: "∩", cup: "∪", int: "∫", there4: "∴", sim: "∼", cong: "≅", asymp: "≈", ne: "≠", equiv: "≡", le: "≤", ge: "≥", sub: "⊂", sup: "⊃", nsub: "⊄", sube: "⊆", supe: "⊇", oplus: "⊕", otimes: "⊗", perp: "⊥", sdot: "⋅", lceil: "⌈", rceil: "⌉", lfloor: "⌊", rfloor: "⌋", lang: "〈", rang: "〉", loz: "◊", spades: "♠", clubs: "♣", hearts: "♥", diams: "♦" }, Fe2 = ge2`jsx`({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: (t) => {
    let { openingTagName: r } = t;
    return `Expected corresponding JSX closing tag for <${r}>.`;
  }, MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnexpectedToken: (t) => {
    let { unexpected: r, HTMLEntity: e } = t;
    return `Unexpected token \`${r}\`. Did you mean \`${e}\` or \`{'${r}'}\`?`;
  }, UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" });
  function we2(t) {
    return t ? t.type === "JSXOpeningFragment" || t.type === "JSXClosingFragment" : false;
  }
  function Ke2(t) {
    if (t.type === "JSXIdentifier")
      return t.name;
    if (t.type === "JSXNamespacedName")
      return t.namespace.name + ":" + t.name.name;
    if (t.type === "JSXMemberExpression")
      return Ke2(t.object) + "." + Ke2(t.property);
    throw new Error("Node had unexpected type: " + t.type);
  }
  var $l2 = (t) => class extends t {
    jsxReadToken() {
      let e = "", s = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(Fe2.UnterminatedJsxContent, { at: this.state.startLoc });
        let i = this.input.charCodeAt(this.state.pos);
        switch (i) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              i === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(140)) : super.getTokenFromCode(i);
              return;
            }
            e += this.input.slice(s, this.state.pos), this.finishToken(139, e);
            return;
          case 38:
            e += this.input.slice(s, this.state.pos), e += this.jsxReadEntity(), s = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            Ze2(i) ? (e += this.input.slice(s, this.state.pos), e += this.jsxReadNewLine(true), s = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(e) {
      let s = this.input.charCodeAt(this.state.pos), i;
      return ++this.state.pos, s === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, i = e ? `
` : `\r
`) : i = String.fromCharCode(s), ++this.state.curLine, this.state.lineStart = this.state.pos, i;
    }
    jsxReadString(e) {
      let s = "", i = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(p.UnterminatedString, { at: this.state.startLoc });
        let a = this.input.charCodeAt(this.state.pos);
        if (a === e)
          break;
        a === 38 ? (s += this.input.slice(i, this.state.pos), s += this.jsxReadEntity(), i = this.state.pos) : Ze2(a) ? (s += this.input.slice(i, this.state.pos), s += this.jsxReadNewLine(false), i = this.state.pos) : ++this.state.pos;
      }
      s += this.input.slice(i, this.state.pos++), this.finishToken(131, s);
    }
    jsxReadEntity() {
      let e = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let s = 10;
        this.codePointAtPos(this.state.pos) === 120 && (s = 16, ++this.state.pos);
        let i = this.readInt(s, void 0, false, "bail");
        if (i !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(i);
      } else {
        let s = 0, i = false;
        for (; s++ < 10 && this.state.pos < this.length && !(i = this.codePointAtPos(this.state.pos) == 59); )
          ++this.state.pos;
        if (i) {
          let a = this.input.slice(e, this.state.pos), n = Ul2[a];
          if (++this.state.pos, n)
            return n;
        }
      }
      return this.state.pos = e, "&";
    }
    jsxReadWord() {
      let e, s = this.state.pos;
      do
        e = this.input.charCodeAt(++this.state.pos);
      while (je2(e) || e === 45);
      this.finishToken(138, this.input.slice(s, this.state.pos));
    }
    jsxParseIdentifier() {
      let e = this.startNode();
      return this.match(138) ? e.name = this.state.value : Ee(this.state.type) ? e.name = Y(this.state.type) : this.unexpected(), this.next(), this.finishNode(e, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      let e = this.state.startLoc, s = this.jsxParseIdentifier();
      if (!this.eat(14))
        return s;
      let i = this.startNodeAt(e);
      return i.namespace = s, i.name = this.jsxParseIdentifier(), this.finishNode(i, "JSXNamespacedName");
    }
    jsxParseElementName() {
      let e = this.state.startLoc, s = this.jsxParseNamespacedName();
      if (s.type === "JSXNamespacedName")
        return s;
      for (; this.eat(16); ) {
        let i = this.startNodeAt(e);
        i.object = s, i.property = this.jsxParseIdentifier(), s = this.finishNode(i, "JSXMemberExpression");
      }
      return s;
    }
    jsxParseAttributeValue() {
      let e;
      switch (this.state.type) {
        case 5:
          return e = this.startNode(), this.setContext(x.brace), this.next(), e = this.jsxParseExpressionContainer(e, x.j_oTag), e.expression.type === "JSXEmptyExpression" && this.raise(Fe2.AttributeIsEmpty, { at: e }), e;
        case 140:
        case 131:
          return this.parseExprAtom();
        default:
          throw this.raise(Fe2.UnsupportedJsxValue, { at: this.state.startLoc });
      }
    }
    jsxParseEmptyExpression() {
      let e = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(e, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(e) {
      return this.next(), e.expression = this.parseExpression(), this.setContext(x.j_expr), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(e, s) {
      if (this.match(8))
        e.expression = this.jsxParseEmptyExpression();
      else {
        let i = this.parseExpression();
        e.expression = i;
      }
      return this.setContext(s), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      let e = this.startNode();
      return this.match(5) ? (this.setContext(x.brace), this.next(), this.expect(21), e.argument = this.parseMaybeAssignAllowIn(), this.setContext(x.j_oTag), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXSpreadAttribute")) : (e.name = this.jsxParseNamespacedName(), e.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(e, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(e) {
      let s = this.startNodeAt(e);
      return this.eat(141) ? this.finishNode(s, "JSXOpeningFragment") : (s.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(s));
    }
    jsxParseOpeningElementAfterName(e) {
      let s = [];
      for (; !this.match(56) && !this.match(141); )
        s.push(this.jsxParseAttribute());
      return e.attributes = s, e.selfClosing = this.eat(56), this.expect(141), this.finishNode(e, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(e) {
      let s = this.startNodeAt(e);
      return this.eat(141) ? this.finishNode(s, "JSXClosingFragment") : (s.name = this.jsxParseElementName(), this.expect(141), this.finishNode(s, "JSXClosingElement"));
    }
    jsxParseElementAt(e) {
      let s = this.startNodeAt(e), i = [], a = this.jsxParseOpeningElementAt(e), n = null;
      if (!a.selfClosing) {
        e:
          for (; ; )
            switch (this.state.type) {
              case 140:
                if (e = this.state.startLoc, this.next(), this.eat(56)) {
                  n = this.jsxParseClosingElementAt(e);
                  break e;
                }
                i.push(this.jsxParseElementAt(e));
                break;
              case 139:
                i.push(this.parseExprAtom());
                break;
              case 5: {
                let o = this.startNode();
                this.setContext(x.brace), this.next(), this.match(21) ? i.push(this.jsxParseSpreadChild(o)) : i.push(this.jsxParseExpressionContainer(o, x.j_expr));
                break;
              }
              default:
                this.unexpected();
            }
        we2(a) && !we2(n) && n !== null ? this.raise(Fe2.MissingClosingTagFragment, { at: n }) : !we2(a) && we2(n) ? this.raise(Fe2.MissingClosingTagElement, { at: n, openingTagName: Ke2(a.name) }) : !we2(a) && !we2(n) && Ke2(n.name) !== Ke2(a.name) && this.raise(Fe2.MissingClosingTagElement, { at: n, openingTagName: Ke2(a.name) });
      }
      if (we2(a) ? (s.openingFragment = a, s.closingFragment = n) : (s.openingElement = a, s.closingElement = n), s.children = i, this.match(47))
        throw this.raise(Fe2.UnwrappedAdjacentJSXElements, { at: this.state.startLoc });
      return we2(a) ? this.finishNode(s, "JSXFragment") : this.finishNode(s, "JSXElement");
    }
    jsxParseElement() {
      let e = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(e);
    }
    setContext(e) {
      let { context: s } = this.state;
      s[s.length - 1] = e;
    }
    parseExprAtom(e) {
      return this.match(139) ? this.parseLiteral(this.state.value, "JSXText") : this.match(140) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(140), this.jsxParseElement()) : super.parseExprAtom(e);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(e) {
      let s = this.curContext();
      if (s === x.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (s === x.j_oTag || s === x.j_cTag) {
        if (Pe2(e)) {
          this.jsxReadWord();
          return;
        }
        if (e === 62) {
          ++this.state.pos, this.finishToken(141);
          return;
        }
        if ((e === 34 || e === 39) && s === x.j_oTag) {
          this.jsxReadString(e);
          return;
        }
      }
      if (e === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(140);
        return;
      }
      super.getTokenFromCode(e);
    }
    updateContext(e) {
      let { context: s, type: i } = this.state;
      if (i === 56 && e === 140)
        s.splice(-2, 2, x.j_cTag), this.state.canStartJSXElement = false;
      else if (i === 140)
        s.push(x.j_oTag);
      else if (i === 141) {
        let a = s[s.length - 1];
        a === x.j_oTag && e === 56 || a === x.j_cTag ? (s.pop(), this.state.canStartJSXElement = s[s.length - 1] === x.j_expr) : (this.setContext(x.j_expr), this.state.canStartJSXElement = true);
      } else
        this.state.canStartJSXElement = H(i);
    }
  }, Hl2 = class extends hs2 {
    constructor() {
      super(...arguments), this.types = /* @__PURE__ */ new Set(), this.enums = /* @__PURE__ */ new Set(), this.constEnums = /* @__PURE__ */ new Set(), this.classes = /* @__PURE__ */ new Set(), this.exportOnlyBindings = /* @__PURE__ */ new Set();
    }
  }, zl2 = class extends us2 {
    constructor() {
      super(...arguments), this.importsStack = [];
    }
    createScope(t) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new Hl2(t);
    }
    enter(t) {
      t == $e2 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(t);
    }
    exit() {
      let t = super.exit();
      return t == $e2 && this.importsStack.pop(), t;
    }
    hasImport(t, r) {
      let e = this.importsStack.length;
      if (this.importsStack[e - 1].has(t))
        return true;
      if (!r && e > 1) {
        for (let s = 0; s < e - 1; s++)
          if (this.importsStack[s].has(t))
            return true;
      }
      return false;
    }
    declareName(t, r, e) {
      if (r & Xe) {
        this.hasImport(t, true) && this.parser.raise(p.VarRedeclaration, { at: e, identifierName: t }), this.importsStack[this.importsStack.length - 1].add(t);
        return;
      }
      let s = this.currentScope();
      if (r & rs2) {
        this.maybeExportDefined(s, t), s.exportOnlyBindings.add(t);
        return;
      }
      super.declareName(t, r, e), r & ke2 && (r & me2 || (this.checkRedeclarationInScope(s, t, r, e), this.maybeExportDefined(s, t)), s.types.add(t)), r & ts2 && s.enums.add(t), r & ss2 && s.constEnums.add(t), r & gt2 && s.classes.add(t);
    }
    isRedeclaredInScope(t, r, e) {
      if (t.enums.has(r)) {
        if (e & ts2) {
          let s = !!(e & ss2), i = t.constEnums.has(r);
          return s !== i;
        }
        return true;
      }
      return e & gt2 && t.classes.has(r) ? t.lexical.has(r) ? !!(e & me2) : false : e & ke2 && t.types.has(r) ? true : super.isRedeclaredInScope(t, r, e);
    }
    checkLocalExport(t) {
      let { name: r } = t;
      if (this.hasImport(r))
        return;
      let e = this.scopeStack.length;
      for (let s = e - 1; s >= 0; s--) {
        let i = this.scopeStack[s];
        if (i.types.has(r) || i.exportOnlyBindings.has(r))
          return;
      }
      super.checkLocalExport(t);
    }
  }, Vl2 = (t, r) => Object.hasOwnProperty.call(t, r) && t[r], Kr2 = (t) => t.type === "ParenthesizedExpression" ? Kr2(t.expression) : t, Kl2 = class extends Ol2 {
    toAssignable(t) {
      let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var e, s;
      let i;
      switch ((t.type === "ParenthesizedExpression" || (e = t.extra) != null && e.parenthesized) && (i = Kr2(t), r ? i.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(p.InvalidParenthesizedAssignment, { at: t }) : i.type !== "MemberExpression" && this.raise(p.InvalidParenthesizedAssignment, { at: t }) : this.raise(p.InvalidParenthesizedAssignment, { at: t })), t.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          t.type = "ObjectPattern";
          for (let n = 0, o = t.properties.length, u = o - 1; n < o; n++) {
            var a;
            let c = t.properties[n], y2 = n === u;
            this.toAssignableObjectExpressionProp(c, y2, r), y2 && c.type === "RestElement" && (a = t.extra) != null && a.trailingCommaLoc && this.raise(p.RestTrailingComma, { at: t.extra.trailingCommaLoc });
          }
          break;
        case "ObjectProperty": {
          let { key: n, value: o } = t;
          this.isPrivateName(n) && this.classScope.usePrivateName(this.getPrivateNameSV(n), n.loc.start), this.toAssignable(o, r);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
        case "ArrayExpression":
          t.type = "ArrayPattern", this.toAssignableList(t.elements, (s = t.extra) == null ? void 0 : s.trailingCommaLoc, r);
          break;
        case "AssignmentExpression":
          t.operator !== "=" && this.raise(p.MissingEqInAssignment, { at: t.left.loc.end }), t.type = "AssignmentPattern", delete t.operator, this.toAssignable(t.left, r);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(i, r);
          break;
      }
    }
    toAssignableObjectExpressionProp(t, r, e) {
      if (t.type === "ObjectMethod")
        this.raise(t.kind === "get" || t.kind === "set" ? p.PatternHasAccessor : p.PatternHasMethod, { at: t.key });
      else if (t.type === "SpreadElement") {
        t.type = "RestElement";
        let s = t.argument;
        this.checkToRestConversion(s, false), this.toAssignable(s, e), r || this.raise(p.RestTrailingComma, { at: t });
      } else
        this.toAssignable(t, e);
    }
    toAssignableList(t, r, e) {
      let s = t.length - 1;
      for (let i = 0; i <= s; i++) {
        let a = t[i];
        if (a) {
          if (a.type === "SpreadElement") {
            a.type = "RestElement";
            let n = a.argument;
            this.checkToRestConversion(n, true), this.toAssignable(n, e);
          } else
            this.toAssignable(a, e);
          a.type === "RestElement" && (i < s ? this.raise(p.RestTrailingComma, { at: a }) : r && this.raise(p.RestTrailingComma, { at: r }));
        }
      }
    }
    isAssignable(t, r) {
      switch (t.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return true;
        case "ObjectExpression": {
          let e = t.properties.length - 1;
          return t.properties.every((s, i) => s.type !== "ObjectMethod" && (i === e || s.type !== "SpreadElement") && this.isAssignable(s));
        }
        case "ObjectProperty":
          return this.isAssignable(t.value);
        case "SpreadElement":
          return this.isAssignable(t.argument);
        case "ArrayExpression":
          return t.elements.every((e) => e === null || this.isAssignable(e));
        case "AssignmentExpression":
          return t.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(t.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !r;
        default:
          return false;
      }
    }
    toReferencedList(t, r) {
      return t;
    }
    toReferencedListDeep(t, r) {
      this.toReferencedList(t, r);
      for (let e of t)
        (e == null ? void 0 : e.type) === "ArrayExpression" && this.toReferencedListDeep(e.elements);
    }
    parseSpread(t) {
      let r = this.startNode();
      return this.next(), r.argument = this.parseMaybeAssignAllowIn(t, void 0), this.finishNode(r, "SpreadElement");
    }
    parseRestBinding() {
      let t = this.startNode();
      return this.next(), t.argument = this.parseBindingAtom(), this.finishNode(t, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          let t = this.startNode();
          return this.next(), t.elements = this.parseBindingList(3, 93, 1), this.finishNode(t, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, true);
      }
      return this.parseIdentifier();
    }
    parseBindingList(t, r, e) {
      let s = e & 1, i = [], a = true;
      for (; !this.eat(t); )
        if (a ? a = false : this.expect(12), s && this.match(12))
          i.push(null);
        else {
          if (this.eat(t))
            break;
          if (this.match(21)) {
            if (i.push(this.parseAssignableListItemTypes(this.parseRestBinding(), e)), !this.checkCommaAfterRest(r)) {
              this.expect(t);
              break;
            }
          } else {
            let n = [];
            for (this.match(26) && this.hasPlugin("decorators") && this.raise(p.UnsupportedParameterDecorator, { at: this.state.startLoc }); this.match(26); )
              n.push(this.parseDecorator());
            i.push(this.parseAssignableListItem(e, n));
          }
        }
      return i;
    }
    parseBindingRestProperty(t) {
      return this.next(), t.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(t, "RestElement");
    }
    parseBindingProperty() {
      let t = this.startNode(), { type: r, startLoc: e } = this.state;
      return r === 21 ? this.parseBindingRestProperty(t) : (r === 136 ? (this.expectPlugin("destructuringPrivate", e), this.classScope.usePrivateName(this.state.value, e), t.key = this.parsePrivateName()) : this.parsePropertyName(t), t.method = false, this.parseObjPropValue(t, e, false, false, true, false));
    }
    parseAssignableListItem(t, r) {
      let e = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(e, t);
      let s = this.parseMaybeDefault(e.loc.start, e);
      return r.length && (e.decorators = r), s;
    }
    parseAssignableListItemTypes(t, r) {
      return t;
    }
    parseMaybeDefault(t, r) {
      var s;
      if (t != null || (t = this.state.startLoc), r = (s = r) != null ? s : this.parseBindingAtom(), !this.eat(29))
        return r;
      let i = this.startNodeAt(t);
      return i.left = r, i.right = this.parseMaybeAssignAllowIn(), this.finishNode(i, "AssignmentPattern");
    }
    isValidLVal(t, r, e) {
      return Vl2({ AssignmentPattern: "left", RestElement: "argument", ObjectProperty: "value", ParenthesizedExpression: "expression", ArrayPattern: "elements", ObjectPattern: "properties" }, t);
    }
    checkLVal(t, r) {
      let { in: e, binding: s = be2, checkClashes: i = false, strictModeChanged: a = false, hasParenthesizedAncestor: n = false } = r;
      var o;
      let u = t.type;
      if (this.isObjectMethod(t))
        return;
      if (u === "MemberExpression") {
        s !== be2 && this.raise(p.InvalidPropertyBindingPattern, { at: t });
        return;
      }
      if (u === "Identifier") {
        this.checkIdentifier(t, s, a);
        let { name: C } = t;
        i && (i.has(C) ? this.raise(p.ParamDupe, { at: t }) : i.add(C));
        return;
      }
      let c = this.isValidLVal(u, !(n || (o = t.extra) != null && o.parenthesized) && e.type === "AssignmentExpression", s);
      if (c === true)
        return;
      if (c === false) {
        let C = s === be2 ? p.InvalidLhs : p.InvalidLhsBinding;
        this.raise(C, { at: t, ancestor: e });
        return;
      }
      let [y2, g2] = Array.isArray(c) ? c : [c, u === "ParenthesizedExpression"], T = u === "ArrayPattern" || u === "ObjectPattern" || u === "ParenthesizedExpression" ? { type: u } : e;
      for (let C of [].concat(t[y2]))
        C && this.checkLVal(C, { in: T, binding: s, checkClashes: i, strictModeChanged: a, hasParenthesizedAncestor: g2 });
    }
    checkIdentifier(t, r) {
      let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      this.state.strict && (e ? vr2(t.name, this.inModule) : Tr2(t.name)) && (r === be2 ? this.raise(p.StrictEvalArguments, { at: t, referenceName: t.name }) : this.raise(p.StrictEvalArgumentsBinding, { at: t, bindingName: t.name })), r & Pt2 && t.name === "let" && this.raise(p.LetInLexicalBinding, { at: t }), r & be2 || this.declareNameFromIdentifier(t, r);
    }
    declareNameFromIdentifier(t, r) {
      this.scope.declareName(t.name, r, t.loc.start);
    }
    checkToRestConversion(t, r) {
      switch (t.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(t.expression, r);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (r)
            break;
        default:
          this.raise(p.InvalidRestAssignmentPattern, { at: t });
      }
    }
    checkCommaAfterRest(t) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === t ? p.RestTrailingComma : p.ElementAfterRest, { at: this.state.startLoc }), true) : false;
    }
  }, Wl2 = (t, r) => Object.hasOwnProperty.call(t, r) && t[r];
  function Gl2(t) {
    if (t == null)
      throw new Error(`Unexpected ${t} value.`);
    return t;
  }
  function Wr2(t) {
    if (!t)
      throw new Error("Assert fail");
  }
  var w = ge2`typescript`({ AbstractMethodHasImplementation: (t) => {
    let { methodName: r } = t;
    return `Method '${r}' cannot have an implementation because it is marked abstract.`;
  }, AbstractPropertyHasInitializer: (t) => {
    let { propertyName: r } = t;
    return `Property '${r}' cannot have an initializer because it is marked abstract.`;
  }, AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: (t) => {
    let { kind: r } = t;
    return `'declare' is not allowed in ${r}ters.`;
  }, DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: (t) => {
    return "Accessibility modifier already seen.";
  }, DuplicateModifier: (t) => {
    let { modifier: r } = t;
    return `Duplicate modifier: '${r}'.`;
  }, EmptyHeritageClauseType: (t) => {
    let { token: r } = t;
    return `'${r}' list cannot be empty.`;
  }, EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier", IncompatibleModifiers: (t) => {
    let { modifiers: r } = t;
    return `'${r[0]}' modifier cannot be used with '${r[1]}' modifier.`;
  }, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: (t) => {
    let { modifier: r } = t;
    return `Index signatures cannot have an accessibility modifier ('${r}').`;
  }, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.", InvalidModifierOnTypeMember: (t) => {
    let { modifier: r } = t;
    return `'${r}' modifier cannot appear on a type member.`;
  }, InvalidModifierOnTypeParameter: (t) => {
    let { modifier: r } = t;
    return `'${r}' modifier cannot appear on a type parameter.`;
  }, InvalidModifierOnTypeParameterPositions: (t) => {
    let { modifier: r } = t;
    return `'${r}' modifier can only appear on a type parameter of a class, interface or type alias.`;
  }, InvalidModifiersOrder: (t) => {
    let { orderedModifiers: r } = t;
    return `'${r[0]}' modifier must precede '${r[1]}' modifier.`;
  }, InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: (t) => {
    let { modifier: r } = t;
    return `Private elements cannot have an accessibility modifier ('${r}').`;
  }, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: (t) => {
    let { typeParameterName: r } = t;
    return `Single type parameter ${r} should have a trailing comma. Example usage: <${r},>.`;
  }, StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: (t) => {
    let { type: r } = t;
    return `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${r}.`;
  } });
  function Jl2(t) {
    switch (t) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  function Gr2(t) {
    return t === "private" || t === "public" || t === "protected";
  }
  function Xl2(t) {
    return t === "in" || t === "out";
  }
  var Yl2 = (t) => class extends t {
    constructor() {
      super(...arguments), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out"], disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: w.InvalidModifierOnTypeParameter }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, { allowedModifiers: ["const"], disallowedModifiers: ["in", "out"], errorTemplate: w.InvalidModifierOnTypeParameterPositions }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out", "const"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: w.InvalidModifierOnTypeParameter });
    }
    getScopeHandler() {
      return zl2;
    }
    tsIsIdentifier() {
      return R2(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(136) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      return this.next(), this.tsTokenCanFollowModifier();
    }
    tsParseModifier(e, s) {
      if (!R2(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
        return;
      let i = this.state.value;
      if (e.indexOf(i) !== -1) {
        if (s && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return i;
      }
    }
    tsParseModifiers(e, s) {
      let { allowedModifiers: i, disallowedModifiers: a, stopOnStartOfClassStaticBlock: n, errorTemplate: o = w.InvalidModifierOnTypeMember } = e, u = (y2, g2, T, C) => {
        g2 === T && s[C] && this.raise(w.InvalidModifiersOrder, { at: y2, orderedModifiers: [T, C] });
      }, c = (y2, g2, T, C) => {
        (s[T] && g2 === C || s[C] && g2 === T) && this.raise(w.IncompatibleModifiers, { at: y2, modifiers: [T, C] });
      };
      for (; ; ) {
        let { startLoc: y2 } = this.state, g2 = this.tsParseModifier(i.concat(a != null ? a : []), n);
        if (!g2)
          break;
        Gr2(g2) ? s.accessibility ? this.raise(w.DuplicateAccessibilityModifier, { at: y2, modifier: g2 }) : (u(y2, g2, g2, "override"), u(y2, g2, g2, "static"), u(y2, g2, g2, "readonly"), s.accessibility = g2) : Xl2(g2) ? (s[g2] && this.raise(w.DuplicateModifier, { at: y2, modifier: g2 }), s[g2] = true, u(y2, g2, "in", "out")) : (Object.hasOwnProperty.call(s, g2) ? this.raise(w.DuplicateModifier, { at: y2, modifier: g2 }) : (u(y2, g2, "static", "readonly"), u(y2, g2, "static", "override"), u(y2, g2, "override", "readonly"), u(y2, g2, "abstract", "override"), c(y2, g2, "declare", "override"), c(y2, g2, "static", "abstract")), s[g2] = true), a != null && a.includes(g2) && this.raise(o, { at: y2, modifier: g2 });
      }
    }
    tsIsListTerminator(e) {
      switch (e) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(e, s) {
      let i = [];
      for (; !this.tsIsListTerminator(e); )
        i.push(s());
      return i;
    }
    tsParseDelimitedList(e, s, i) {
      return Gl2(this.tsParseDelimitedListWorker(e, s, true, i));
    }
    tsParseDelimitedListWorker(e, s, i, a) {
      let n = [], o = -1;
      for (; !this.tsIsListTerminator(e); ) {
        o = -1;
        let u = s();
        if (u == null)
          return;
        if (n.push(u), this.eat(12)) {
          o = this.state.lastTokStart;
          continue;
        }
        if (this.tsIsListTerminator(e))
          break;
        i && this.expect(12);
        return;
      }
      return a && (a.value = o), n;
    }
    tsParseBracketedList(e, s, i, a, n) {
      a || (i ? this.expect(0) : this.expect(47));
      let o = this.tsParseDelimitedList(e, s, n);
      return i ? this.expect(3) : this.expect(48), o;
    }
    tsParseImportType() {
      let e = this.startNode();
      return this.expect(83), this.expect(10), this.match(131) || this.raise(w.UnsupportedImportTypeArgument, { at: this.state.startLoc }), e.argument = super.parseExprAtom(), this.expect(11), this.eat(16) && (e.qualifier = this.tsParseEntityName()), this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSImportType");
    }
    tsParseEntityName() {
      let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true, s = this.parseIdentifier(e);
      for (; this.eat(16); ) {
        let i = this.startNodeAtNode(s);
        i.left = s, i.right = this.parseIdentifier(e), s = this.finishNode(i, "TSQualifiedName");
      }
      return s;
    }
    tsParseTypeReference() {
      let e = this.startNode();
      return e.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeReference");
    }
    tsParseThisTypePredicate(e) {
      this.next();
      let s = this.startNodeAtNode(e);
      return s.parameterName = e, s.typeAnnotation = this.tsParseTypeAnnotation(false), s.asserts = false, this.finishNode(s, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      let e = this.startNode();
      return this.next(), this.finishNode(e, "TSThisType");
    }
    tsParseTypeQuery() {
      let e = this.startNode();
      return this.expect(87), this.match(83) ? e.exprName = this.tsParseImportType() : e.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeQuery");
    }
    tsParseTypeParameter(e) {
      let s = this.startNode();
      return e(s), s.name = this.tsParseTypeParameterName(), s.constraint = this.tsEatThenParseType(81), s.default = this.tsEatThenParseType(29), this.finishNode(s, "TSTypeParameter");
    }
    tsTryParseTypeParameters(e) {
      if (this.match(47))
        return this.tsParseTypeParameters(e);
    }
    tsParseTypeParameters(e) {
      let s = this.startNode();
      this.match(47) || this.match(140) ? this.next() : this.unexpected();
      let i = { value: -1 };
      return s.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, e), false, true, i), s.params.length === 0 && this.raise(w.EmptyTypeParameters, { at: s }), i.value !== -1 && this.addExtra(s, "trailingComma", i.value), this.finishNode(s, "TSTypeParameterDeclaration");
    }
    tsFillSignature(e, s) {
      let i = e === 19, a = "parameters", n = "typeAnnotation";
      s.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), s[a] = this.tsParseBindingListForSignature(), i ? s[n] = this.tsParseTypeOrTypePredicateAnnotation(e) : this.match(e) && (s[n] = this.tsParseTypeOrTypePredicateAnnotation(e));
    }
    tsParseBindingListForSignature() {
      return super.parseBindingList(11, 41, 2).map((e) => (e.type !== "Identifier" && e.type !== "RestElement" && e.type !== "ObjectPattern" && e.type !== "ArrayPattern" && this.raise(w.UnsupportedSignatureParameterKind, { at: e, type: e.type }), e));
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(e, s) {
      return this.tsFillSignature(14, s), this.tsParseTypeMemberSemicolon(), this.finishNode(s, e);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), R2(this.state.type) ? (this.next(), this.match(14)) : false;
    }
    tsTryParseIndexSignature(e) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      let s = this.parseIdentifier();
      s.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(s), this.expect(3), e.parameters = [s];
      let i = this.tsTryParseTypeAnnotation();
      return i && (e.typeAnnotation = i), this.tsParseTypeMemberSemicolon(), this.finishNode(e, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(e, s) {
      this.eat(17) && (e.optional = true);
      let i = e;
      if (this.match(10) || this.match(47)) {
        s && this.raise(w.ReadonlyForMethodSignature, { at: e });
        let a = i;
        a.kind && this.match(47) && this.raise(w.AccesorCannotHaveTypeParameters, { at: this.state.curPosition() }), this.tsFillSignature(14, a), this.tsParseTypeMemberSemicolon();
        let n = "parameters", o = "typeAnnotation";
        if (a.kind === "get")
          a[n].length > 0 && (this.raise(p.BadGetterArity, { at: this.state.curPosition() }), this.isThisParam(a[n][0]) && this.raise(w.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }));
        else if (a.kind === "set") {
          if (a[n].length !== 1)
            this.raise(p.BadSetterArity, { at: this.state.curPosition() });
          else {
            let u = a[n][0];
            this.isThisParam(u) && this.raise(w.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }), u.type === "Identifier" && u.optional && this.raise(w.SetAccesorCannotHaveOptionalParameter, { at: this.state.curPosition() }), u.type === "RestElement" && this.raise(w.SetAccesorCannotHaveRestParameter, { at: this.state.curPosition() });
          }
          a[o] && this.raise(w.SetAccesorCannotHaveReturnType, { at: a[o] });
        } else
          a.kind = "method";
        return this.finishNode(a, "TSMethodSignature");
      } else {
        let a = i;
        s && (a.readonly = true);
        let n = this.tsTryParseTypeAnnotation();
        return n && (a.typeAnnotation = n), this.tsParseTypeMemberSemicolon(), this.finishNode(a, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      let e = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", e);
      if (this.match(77)) {
        let i = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e) : (e.key = this.createIdentifier(i, "new"), this.tsParsePropertyOrMethodSignature(e, false));
      }
      this.tsParseModifiers({ allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] }, e);
      let s = this.tsTryParseIndexSignature(e);
      return s || (super.parsePropertyName(e), !e.computed && e.key.type === "Identifier" && (e.key.name === "get" || e.key.name === "set") && this.tsTokenCanFollowModifier() && (e.kind = e.key.name, super.parsePropertyName(e)), this.tsParsePropertyOrMethodSignature(e, !!e.readonly));
    }
    tsParseTypeLiteral() {
      let e = this.startNode();
      return e.members = this.tsParseObjectTypeMembers(), this.finishNode(e, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      let e = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), e;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(120) : (this.isContextual(120) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? false : (this.next(), this.match(58)));
    }
    tsParseMappedTypeParameter() {
      let e = this.startNode();
      return e.name = this.tsParseTypeParameterName(), e.constraint = this.tsExpectThenParseType(58), this.finishNode(e, "TSTypeParameter");
    }
    tsParseMappedType() {
      let e = this.startNode();
      return this.expect(5), this.match(53) ? (e.readonly = this.state.value, this.next(), this.expectContextual(120)) : this.eatContextual(120) && (e.readonly = true), this.expect(0), e.typeParameter = this.tsParseMappedTypeParameter(), e.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (e.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (e.optional = true), e.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(e, "TSMappedType");
    }
    tsParseTupleType() {
      let e = this.startNode();
      e.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
      let s = false, i = null;
      return e.elementTypes.forEach((a) => {
        let { type: o } = a;
        s && o !== "TSRestType" && o !== "TSOptionalType" && !(o === "TSNamedTupleMember" && a.optional) && this.raise(w.OptionalTypeBeforeRequired, { at: a }), s || (s = o === "TSNamedTupleMember" && a.optional || o === "TSOptionalType");
        let u = o;
        o === "TSRestType" && (a = a.typeAnnotation, u = a.type);
        let c = u === "TSNamedTupleMember";
        i != null || (i = c), i !== c && this.raise(w.MixedLabeledAndUnlabeledElements, { at: a });
      }), this.finishNode(e, "TSTupleType");
    }
    tsParseTupleElementType() {
      let { startLoc: e } = this.state, s = this.eat(21), i, a, n, o, c = se2(this.state.type) ? this.lookaheadCharCode() : null;
      if (c === 58)
        i = true, n = false, a = this.parseIdentifier(true), this.expect(14), o = this.tsParseType();
      else if (c === 63) {
        n = true;
        let y2 = this.state.startLoc, g2 = this.state.value, T = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (i = true, a = this.createIdentifier(this.startNodeAt(y2), g2), this.expect(17), this.expect(14), o = this.tsParseType()) : (i = false, o = T, this.expect(17));
      } else
        o = this.tsParseType(), n = this.eat(17), i = this.eat(14);
      if (i) {
        let y2;
        a ? (y2 = this.startNodeAtNode(a), y2.optional = n, y2.label = a, y2.elementType = o, this.eat(17) && (y2.optional = true, this.raise(w.TupleOptionalAfterType, { at: this.state.lastTokStartLoc }))) : (y2 = this.startNodeAtNode(o), y2.optional = n, this.raise(w.InvalidTupleMemberLabel, { at: o }), y2.label = o, y2.elementType = this.tsParseType()), o = this.finishNode(y2, "TSNamedTupleMember");
      } else if (n) {
        let y2 = this.startNodeAtNode(o);
        y2.typeAnnotation = o, o = this.finishNode(y2, "TSOptionalType");
      }
      if (s) {
        let y2 = this.startNodeAt(e);
        y2.typeAnnotation = o, o = this.finishNode(y2, "TSRestType");
      }
      return o;
    }
    tsParseParenthesizedType() {
      let e = this.startNode();
      return this.expect(10), e.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(e, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(e, s) {
      let i = this.startNode();
      return e === "TSConstructorType" && (i.abstract = !!s, s && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, i)), this.finishNode(i, e);
    }
    tsParseLiteralTypeNode() {
      let e = this.startNode();
      return e.literal = (() => {
        switch (this.state.type) {
          case 132:
          case 133:
          case 131:
          case 85:
          case 86:
            return super.parseExprAtom();
          default:
            this.unexpected();
        }
      })(), this.finishNode(e, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      let e = this.startNode();
      return e.literal = super.parseTemplate(false), this.finishNode(e, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      let e = this.tsParseThisTypeNode();
      return this.isContextual(114) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e) : e;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 131:
        case 132:
        case 133:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            let e = this.startNode(), s = this.lookahead();
            return s.type !== 132 && s.type !== 133 && this.unexpected(), e.literal = this.parseMaybeUnary(), this.finishNode(e, "TSLiteralType");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          let { type: e } = this.state;
          if (R2(e) || e === 88 || e === 84) {
            let s = e === 88 ? "TSVoidKeyword" : e === 84 ? "TSNullKeyword" : Jl2(this.state.value);
            if (s !== void 0 && this.lookaheadCharCode() !== 46) {
              let i = this.startNode();
              return this.next(), this.finishNode(i, s);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let e = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          let s = this.startNodeAtNode(e);
          s.elementType = e, this.expect(3), e = this.finishNode(s, "TSArrayType");
        } else {
          let s = this.startNodeAtNode(e);
          s.objectType = e, s.indexType = this.tsParseType(), this.expect(3), e = this.finishNode(s, "TSIndexedAccessType");
        }
      return e;
    }
    tsParseTypeOperator() {
      let e = this.startNode(), s = this.state.value;
      return this.next(), e.operator = s, e.typeAnnotation = this.tsParseTypeOperatorOrHigher(), s === "readonly" && this.tsCheckTypeAnnotationForReadOnly(e), this.finishNode(e, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(e) {
      switch (e.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(w.UnexpectedReadonly, { at: e });
      }
    }
    tsParseInferType() {
      let e = this.startNode();
      this.expectContextual(113);
      let s = this.startNode();
      return s.name = this.tsParseTypeParameterName(), s.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), e.typeParameter = this.finishNode(s, "TSTypeParameter"), this.finishNode(e, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        let e = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return e;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return ut2(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(113) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(e, s, i) {
      let a = this.startNode(), n = this.eat(i), o = [];
      do
        o.push(s());
      while (this.eat(i));
      return o.length === 1 && !n ? o[0] : (a.types = o, this.finishNode(a, e));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? true : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (R2(this.state.type) || this.match(78))
        return this.next(), true;
      if (this.match(5)) {
        let { errors: e } = this.state, s = e.length;
        try {
          return this.parseObjectLike(8, true), e.length === s;
        } catch {
          return false;
        }
      }
      if (this.match(0)) {
        this.next();
        let { errors: e } = this.state, s = e.length;
        try {
          return super.parseBindingList(3, 93, 1), e.length === s;
        } catch {
          return false;
        }
      }
      return false;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(e) {
      return this.tsInType(() => {
        let s = this.startNode();
        this.expect(e);
        let i = this.startNode(), a = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (a && this.match(78)) {
          let u = this.tsParseThisTypeOrThisTypePredicate();
          return u.type === "TSThisType" ? (i.parameterName = u, i.asserts = true, i.typeAnnotation = null, u = this.finishNode(i, "TSTypePredicate")) : (this.resetStartLocationFromNode(u, i), u.asserts = true), s.typeAnnotation = u, this.finishNode(s, "TSTypeAnnotation");
        }
        let n = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!n)
          return a ? (i.parameterName = this.parseIdentifier(), i.asserts = a, i.typeAnnotation = null, s.typeAnnotation = this.finishNode(i, "TSTypePredicate"), this.finishNode(s, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, s);
        let o = this.tsParseTypeAnnotation(false);
        return i.parameterName = n, i.typeAnnotation = o, i.asserts = a, s.typeAnnotation = this.finishNode(i, "TSTypePredicate"), this.finishNode(s, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : void 0;
    }
    tsTryParseTypeAnnotation() {
      return this.match(14) ? this.tsParseTypeAnnotation() : void 0;
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      let e = this.parseIdentifier();
      if (this.isContextual(114) && !this.hasPrecedingLineBreak())
        return this.next(), e;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 107)
        return false;
      let e = this.state.containsEsc;
      return this.next(), !R2(this.state.type) && !this.match(78) ? false : (e && this.raise(p.InvalidEscapedReservedWord, { at: this.state.lastTokStartLoc, reservedWord: "asserts" }), true);
    }
    tsParseTypeAnnotation() {
      let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.startNode();
      return this.tsInType(() => {
        e && this.expect(14), s.typeAnnotation = this.tsParseType();
      }), this.finishNode(s, "TSTypeAnnotation");
    }
    tsParseType() {
      Wr2(this.state.inType);
      let e = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return e;
      let s = this.startNodeAtNode(e);
      return s.checkType = e, s.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), s.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), s.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(s, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(122) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(w.ReservedTypeAssertion, { at: this.state.startLoc });
      let e = this.startNode();
      return e.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), e.expression = this.parseMaybeUnary(), this.finishNode(e, "TSTypeAssertion");
    }
    tsParseHeritageClause(e) {
      let s = this.state.startLoc, i = this.tsParseDelimitedList("HeritageClauseElement", () => {
        let a = this.startNode();
        return a.expression = this.tsParseEntityName(), this.match(47) && (a.typeParameters = this.tsParseTypeArguments()), this.finishNode(a, "TSExpressionWithTypeArguments");
      });
      return i.length || this.raise(w.EmptyHeritageClauseType, { at: s, token: e }), i;
    }
    tsParseInterfaceDeclaration(e) {
      let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.hasFollowingLineBreak())
        return null;
      this.expectContextual(127), s.declare && (e.declare = true), R2(this.state.type) ? (e.id = this.parseIdentifier(), this.checkIdentifier(e.id, Zo2)) : (e.id = null, this.raise(w.MissingInterfaceName, { at: this.state.startLoc })), e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (e.extends = this.tsParseHeritageClause("extends"));
      let i = this.startNode();
      return i.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e.body = this.finishNode(i, "TSInterfaceBody"), this.finishNode(e, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(e) {
      return e.id = this.parseIdentifier(), this.checkIdentifier(e.id, el2), e.typeAnnotation = this.tsInType(() => {
        if (e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(112) && this.lookahead().type !== 16) {
          let s = this.startNode();
          return this.next(), this.finishNode(s, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(e, "TSTypeAliasDeclaration");
    }
    tsInNoContext(e) {
      let s = this.state.context;
      this.state.context = [s[0]];
      try {
        return e();
      } finally {
        this.state.context = s;
      }
    }
    tsInType(e) {
      let s = this.state.inType;
      this.state.inType = true;
      try {
        return e();
      } finally {
        this.state.inType = s;
      }
    }
    tsInDisallowConditionalTypesContext(e) {
      let s = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = true;
      try {
        return e();
      } finally {
        this.state.inDisallowConditionalTypesContext = s;
      }
    }
    tsInAllowConditionalTypesContext(e) {
      let s = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = false;
      try {
        return e();
      } finally {
        this.state.inDisallowConditionalTypesContext = s;
      }
    }
    tsEatThenParseType(e) {
      return this.match(e) ? this.tsNextThenParseType() : void 0;
    }
    tsExpectThenParseType(e) {
      return this.tsDoThenParseType(() => this.expect(e));
    }
    tsNextThenParseType() {
      return this.tsDoThenParseType(() => this.next());
    }
    tsDoThenParseType(e) {
      return this.tsInType(() => (e(), this.tsParseType()));
    }
    tsParseEnumMember() {
      let e = this.startNode();
      return e.id = this.match(131) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true), this.eat(29) && (e.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(e, "TSEnumMember");
    }
    tsParseEnumDeclaration(e) {
      let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return s.const && (e.const = true), s.declare && (e.declare = true), this.expectContextual(124), e.id = this.parseIdentifier(), this.checkIdentifier(e.id, e.const ? sl2 : Nr2), this.expect(5), e.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(e, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      let e = this.startNode();
      return this.scope.enter(qe2), this.expect(5), super.parseBlockOrModuleBlockBody(e.body = [], void 0, true, 8), this.scope.exit(), this.finishNode(e, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(e) {
      let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (e.id = this.parseIdentifier(), s || this.checkIdentifier(e.id, rl2), this.eat(16)) {
        let i = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(i, true), e.body = i;
      } else
        this.scope.enter($e2), this.prodParam.enter(ze), e.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(e, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(e) {
      return this.isContextual(110) ? (e.global = true, e.id = this.parseIdentifier()) : this.match(131) ? e.id = super.parseStringLiteral(this.state.value) : this.unexpected(), this.match(5) ? (this.scope.enter($e2), this.prodParam.enter(ze), e.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(e, s) {
      e.isExport = s || false, e.id = this.parseIdentifier(), this.checkIdentifier(e.id, Xe), this.expect(29);
      let i = this.tsParseModuleReference();
      return e.importKind === "type" && i.type !== "TSExternalModuleReference" && this.raise(w.ImportAliasHasImportType, { at: i }), e.moduleReference = i, this.semicolon(), this.finishNode(e, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(117) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
    }
    tsParseExternalModuleReference() {
      let e = this.startNode();
      return this.expectContextual(117), this.expect(10), this.match(131) || this.unexpected(), e.expression = super.parseExprAtom(), this.expect(11), this.finishNode(e, "TSExternalModuleReference");
    }
    tsLookAhead(e) {
      let s = this.state.clone(), i = e();
      return this.state = s, i;
    }
    tsTryParseAndCatch(e) {
      let s = this.tryParse((i) => e() || i());
      if (!(s.aborted || !s.node))
        return s.error && (this.state = s.failState), s.node;
    }
    tsTryParse(e) {
      let s = this.state.clone(), i = e();
      if (i !== void 0 && i !== false)
        return i;
      this.state = s;
    }
    tsTryParseDeclare(e) {
      if (this.isLineTerminator())
        return;
      let s = this.state.type, i;
      return this.isContextual(99) && (s = 74, i = "let"), this.tsInAmbientContext(() => {
        if (s === 68)
          return e.declare = true, super.parseFunctionStatement(e, false, false);
        if (s === 80)
          return e.declare = true, this.parseClass(e, true, false);
        if (s === 124)
          return this.tsParseEnumDeclaration(e, { declare: true });
        if (s === 110)
          return this.tsParseAmbientExternalModuleDeclaration(e);
        if (s === 75 || s === 74)
          return !this.match(75) || !this.isLookaheadContextual("enum") ? (e.declare = true, this.parseVarStatement(e, i || this.state.value, true)) : (this.expect(75), this.tsParseEnumDeclaration(e, { const: true, declare: true }));
        if (s === 127) {
          let a = this.tsParseInterfaceDeclaration(e, { declare: true });
          if (a)
            return a;
        }
        if (R2(s))
          return this.tsParseDeclaration(e, this.state.value, true, null);
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
    }
    tsParseExpressionStatement(e, s, i) {
      switch (s.name) {
        case "declare": {
          let a = this.tsTryParseDeclare(e);
          if (a)
            return a.declare = true, a;
          break;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter($e2), this.prodParam.enter(ze);
            let a = e;
            return a.global = true, a.id = s, a.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(a, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(e, s.name, false, i);
      }
    }
    tsParseDeclaration(e, s, i, a) {
      switch (s) {
        case "abstract":
          if (this.tsCheckLineTerminator(i) && (this.match(80) || R2(this.state.type)))
            return this.tsParseAbstractDeclaration(e, a);
          break;
        case "module":
          if (this.tsCheckLineTerminator(i)) {
            if (this.match(131))
              return this.tsParseAmbientExternalModuleDeclaration(e);
            if (R2(this.state.type))
              return this.tsParseModuleOrNamespaceDeclaration(e);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(i) && R2(this.state.type))
            return this.tsParseModuleOrNamespaceDeclaration(e);
          break;
        case "type":
          if (this.tsCheckLineTerminator(i) && R2(this.state.type))
            return this.tsParseTypeAliasDeclaration(e);
          break;
      }
    }
    tsCheckLineTerminator(e) {
      return e ? this.hasFollowingLineBreak() ? false : (this.next(), true) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(e) {
      if (!this.match(47))
        return;
      let s = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = true;
      let i = this.tsTryParseAndCatch(() => {
        let a = this.startNodeAt(e);
        return a.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(a), a.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), a;
      });
      if (this.state.maybeInArrowParameters = s, !!i)
        return super.parseArrowExpression(i, null, true);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      let e = this.startNode();
      return e.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), e.params.length === 0 && this.raise(w.EmptyTypeArguments, { at: e }), this.expect(48), this.finishNode(e, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return Wt(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? false : super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(e, s) {
      let i = this.state.startLoc, a = {};
      this.tsParseModifiers({ allowedModifiers: ["public", "private", "protected", "override", "readonly"] }, a);
      let n = a.accessibility, o = a.override, u = a.readonly;
      !(e & 4) && (n || u || o) && this.raise(w.UnexpectedParameterModifier, { at: i });
      let c = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(c, e);
      let y2 = this.parseMaybeDefault(c.loc.start, c);
      if (n || u || o) {
        let g2 = this.startNodeAt(i);
        return s.length && (g2.decorators = s), n && (g2.accessibility = n), u && (g2.readonly = u), o && (g2.override = o), y2.type !== "Identifier" && y2.type !== "AssignmentPattern" && this.raise(w.UnsupportedParameterPropertyKind, { at: g2 }), g2.parameter = y2, this.finishNode(g2, "TSParameterProperty");
      }
      return s.length && (c.decorators = s), y2;
    }
    isSimpleParameter(e) {
      return e.type === "TSParameterProperty" && super.isSimpleParameter(e.parameter) || super.isSimpleParameter(e);
    }
    tsDisallowOptionalPattern(e) {
      for (let s of e.params)
        s.type !== "Identifier" && s.optional && !this.state.isAmbientContext && this.raise(w.PatternIsOptional, { at: s });
    }
    setArrowFunctionParameters(e, s, i) {
      super.setArrowFunctionParameters(e, s, i), this.tsDisallowOptionalPattern(e);
    }
    parseFunctionBodyAndFinish(e, s) {
      let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      this.match(14) && (e.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      let a = s === "FunctionDeclaration" ? "TSDeclareFunction" : s === "ClassMethod" || s === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return a && !this.match(5) && this.isLineTerminator() ? this.finishNode(e, a) : a === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(w.DeclareFunctionHasImplementation, { at: e }), e.declare) ? super.parseFunctionBodyAndFinish(e, a, i) : (this.tsDisallowOptionalPattern(e), super.parseFunctionBodyAndFinish(e, s, i));
    }
    registerFunctionStatementId(e) {
      !e.body && e.id ? this.checkIdentifier(e.id, kr2) : super.registerFunctionStatementId(e);
    }
    tsCheckForInvalidTypeCasts(e) {
      e.forEach((s) => {
        (s == null ? void 0 : s.type) === "TSTypeCastExpression" && this.raise(w.UnexpectedTypeAnnotation, { at: s.typeAnnotation });
      });
    }
    toReferencedList(e, s) {
      return this.tsCheckForInvalidTypeCasts(e), e;
    }
    parseArrayLike(e, s, i, a) {
      let n = super.parseArrayLike(e, s, i, a);
      return n.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(n.elements), n;
    }
    parseSubscript(e, s, i, a) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = false, this.next();
        let o = this.startNodeAt(s);
        return o.expression = e, this.finishNode(o, "TSNonNullExpression");
      }
      let n = false;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (i)
          return a.stop = true, e;
        a.optionalChainMember = n = true, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let o, u = this.tsTryParseAndCatch(() => {
          if (!i && this.atPossibleAsyncArrow(e)) {
            let T = this.tsTryParseGenericAsyncArrowFunction(s);
            if (T)
              return T;
          }
          let c = this.tsParseTypeArgumentsInExpression();
          if (!c)
            return;
          if (n && !this.match(10)) {
            o = this.state.curPosition();
            return;
          }
          if (ct2(this.state.type)) {
            let T = super.parseTaggedTemplateExpression(e, s, a);
            return T.typeParameters = c, T;
          }
          if (!i && this.eat(10)) {
            let T = this.startNodeAt(s);
            return T.callee = e, T.arguments = this.parseCallExpressionArguments(11, false), this.tsCheckForInvalidTypeCasts(T.arguments), T.typeParameters = c, a.optionalChainMember && (T.optional = n), this.finishCallExpression(T, a.optionalChainMember);
          }
          let y2 = this.state.type;
          if (y2 === 48 || y2 === 52 || y2 !== 10 && X(y2) && !this.hasPrecedingLineBreak())
            return;
          let g2 = this.startNodeAt(s);
          return g2.expression = e, g2.typeParameters = c, this.finishNode(g2, "TSInstantiationExpression");
        });
        if (o && this.unexpected(o, 10), u)
          return u.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(w.InvalidPropertyAccessAfterInstantiationExpression, { at: this.state.startLoc }), u;
      }
      return super.parseSubscript(e, s, i, a);
    }
    parseNewCallee(e) {
      var s;
      super.parseNewCallee(e);
      let { callee: i } = e;
      i.type === "TSInstantiationExpression" && !((s = i.extra) != null && s.parenthesized) && (e.typeParameters = i.typeParameters, e.callee = i.expression);
    }
    parseExprOp(e, s, i) {
      let a;
      if (Re2(58) > i && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (a = this.isContextual(118)))) {
        let n = this.startNodeAt(s);
        return n.expression = e, n.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (a && this.raise(p.UnexpectedKeyword, { at: this.state.startLoc, keyword: "const" }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(n, a ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(n, s, i);
      }
      return super.parseExprOp(e, s, i);
    }
    checkReservedWord(e, s, i, a) {
      this.state.isAmbientContext || super.checkReservedWord(e, s, i, a);
    }
    checkImportReflection(e) {
      super.checkImportReflection(e), e.module && e.importKind !== "value" && this.raise(w.ImportReflectionHasImportType, { at: e.specifiers[0].loc.start });
    }
    checkDuplicateExports() {
    }
    parseImport(e) {
      if (e.importKind = "value", R2(this.state.type) || this.match(55) || this.match(5)) {
        let i = this.lookahead();
        if (this.isContextual(128) && i.type !== 12 && i.type !== 97 && i.type !== 29 && (e.importKind = "type", this.next(), i = this.lookahead()), R2(this.state.type) && i.type === 29)
          return this.tsParseImportEqualsDeclaration(e);
      }
      let s = super.parseImport(e);
      return s.importKind === "type" && s.specifiers.length > 1 && s.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(w.TypeImportCannotSpecifyDefaultAndNamed, { at: s }), s;
    }
    parseExport(e, s) {
      if (this.match(83))
        return this.next(), this.isContextual(128) && this.lookaheadCharCode() !== 61 ? (e.importKind = "type", this.next()) : e.importKind = "value", this.tsParseImportEqualsDeclaration(e, true);
      if (this.eat(29)) {
        let i = e;
        return i.expression = super.parseExpression(), this.semicolon(), this.finishNode(i, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        let i = e;
        return this.expectContextual(126), i.id = this.parseIdentifier(), this.semicolon(), this.finishNode(i, "TSNamespaceExportDeclaration");
      } else {
        if (e.exportKind = "value", this.isContextual(128)) {
          let i = this.lookaheadCharCode();
          (i === 123 || i === 42) && (this.next(), e.exportKind = "type");
        }
        return super.parseExport(e, s);
      }
    }
    isAbstractClass() {
      return this.isContextual(122) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        let e = this.startNode();
        return this.next(), e.abstract = true, this.parseClass(e, true, true);
      }
      if (this.match(127)) {
        let e = this.tsParseInterfaceDeclaration(this.startNode());
        if (e)
          return e;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(e, s) {
      let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, { isAmbientContext: a } = this.state, n = super.parseVarStatement(e, s, i || a);
      if (!a)
        return n;
      for (let { id: o, init: u } of n.declarations)
        u && (s !== "const" || o.typeAnnotation ? this.raise(w.InitializerNotAllowedInAmbientContext, { at: u }) : Zl2(u, this.hasPlugin("estree")) || this.raise(w.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, { at: u }));
      return n;
    }
    parseStatementContent(e, s) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        let i = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(i, { const: true });
      }
      if (this.isContextual(124))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(127)) {
        let i = this.tsParseInterfaceDeclaration(this.startNode());
        if (i)
          return i;
      }
      return super.parseStatementContent(e, s);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(e, s) {
      return s.some((i) => Gr2(i) ? e.accessibility === i : !!e[i]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(104) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(e, s, i) {
      let a = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({ allowedModifiers: a, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: true, errorTemplate: w.InvalidModifierOnTypeParameterPositions }, s);
      let n = () => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(s, a) && this.raise(w.StaticBlockCannotHaveModifier, { at: this.state.curPosition() }), super.parseClassStaticBlock(e, s)) : this.parseClassMemberWithIsStatic(e, s, i, !!s.static);
      };
      s.declare ? this.tsInAmbientContext(n) : n();
    }
    parseClassMemberWithIsStatic(e, s, i, a) {
      let n = this.tsTryParseIndexSignature(s);
      if (n) {
        e.body.push(n), s.abstract && this.raise(w.IndexSignatureHasAbstract, { at: s }), s.accessibility && this.raise(w.IndexSignatureHasAccessibility, { at: s, modifier: s.accessibility }), s.declare && this.raise(w.IndexSignatureHasDeclare, { at: s }), s.override && this.raise(w.IndexSignatureHasOverride, { at: s });
        return;
      }
      !this.state.inAbstractClass && s.abstract && this.raise(w.NonAbstractClassHasAbstractMethod, { at: s }), s.override && (i.hadSuperClass || this.raise(w.OverrideNotInSubClass, { at: s })), super.parseClassMemberWithIsStatic(e, s, i, a);
    }
    parsePostMemberNameModifiers(e) {
      this.eat(17) && (e.optional = true), e.readonly && this.match(10) && this.raise(w.ClassMethodHasReadonly, { at: e }), e.declare && this.match(10) && this.raise(w.ClassMethodHasDeclare, { at: e });
    }
    parseExpressionStatement(e, s, i) {
      return (s.type === "Identifier" ? this.tsParseExpressionStatement(e, s, i) : void 0) || super.parseExpressionStatement(e, s, i);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? true : super.shouldParseExportDeclaration();
    }
    parseConditional(e, s, i) {
      if (!this.state.maybeInArrowParameters || !this.match(17))
        return super.parseConditional(e, s, i);
      let a = this.tryParse(() => super.parseConditional(e, s));
      return a.node ? (a.error && (this.state = a.failState), a.node) : (a.error && super.setOptionalParametersError(i, a.error), e);
    }
    parseParenItem(e, s) {
      if (e = super.parseParenItem(e, s), this.eat(17) && (e.optional = true, this.resetEndLocation(e)), this.match(14)) {
        let i = this.startNodeAt(s);
        return i.expression = e, i.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(i, "TSTypeCastExpression");
      }
      return e;
    }
    parseExportDeclaration(e) {
      if (!this.state.isAmbientContext && this.isContextual(123))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(e));
      let s = this.state.startLoc, i = this.eatContextual(123);
      if (i && (this.isContextual(123) || !this.shouldParseExportDeclaration()))
        throw this.raise(w.ExpectedAmbientAfterExportDeclare, { at: this.state.startLoc });
      let n = R2(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(e);
      return n ? ((n.type === "TSInterfaceDeclaration" || n.type === "TSTypeAliasDeclaration" || i) && (e.exportKind = "type"), i && (this.resetStartLocation(n, s), n.declare = true), n) : null;
    }
    parseClassId(e, s, i, a) {
      if ((!s || i) && this.isContextual(111))
        return;
      super.parseClassId(e, s, i, e.declare ? kr2 : wr2);
      let n = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      n && (e.typeParameters = n);
    }
    parseClassPropertyAnnotation(e) {
      e.optional || (this.eat(35) ? e.definite = true : this.eat(17) && (e.optional = true));
      let s = this.tsTryParseTypeAnnotation();
      s && (e.typeAnnotation = s);
    }
    parseClassProperty(e) {
      if (this.parseClassPropertyAnnotation(e), this.state.isAmbientContext && !(e.readonly && !e.typeAnnotation) && this.match(29) && this.raise(w.DeclareClassFieldHasInitializer, { at: this.state.startLoc }), e.abstract && this.match(29)) {
        let { key: s } = e;
        this.raise(w.AbstractPropertyHasInitializer, { at: this.state.startLoc, propertyName: s.type === "Identifier" && !e.computed ? s.name : `[${this.input.slice(s.start, s.end)}]` });
      }
      return super.parseClassProperty(e);
    }
    parseClassPrivateProperty(e) {
      return e.abstract && this.raise(w.PrivateElementHasAbstract, { at: e }), e.accessibility && this.raise(w.PrivateElementHasAccessibility, { at: e, modifier: e.accessibility }), this.parseClassPropertyAnnotation(e), super.parseClassPrivateProperty(e);
    }
    parseClassAccessorProperty(e) {
      return this.parseClassPropertyAnnotation(e), e.optional && this.raise(w.AccessorCannotBeOptional, { at: e }), super.parseClassAccessorProperty(e);
    }
    pushClassMethod(e, s, i, a, n, o) {
      let u = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      u && n && this.raise(w.ConstructorHasTypeParameters, { at: u });
      let { declare: c = false, kind: y2 } = s;
      c && (y2 === "get" || y2 === "set") && this.raise(w.DeclareAccessor, { at: s, kind: y2 }), u && (s.typeParameters = u), super.pushClassMethod(e, s, i, a, n, o);
    }
    pushClassPrivateMethod(e, s, i, a) {
      let n = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      n && (s.typeParameters = n), super.pushClassPrivateMethod(e, s, i, a);
    }
    declareClassPrivateMethodInScope(e, s) {
      e.type !== "TSDeclareMethod" && (e.type === "MethodDefinition" && !e.value.body || super.declareClassPrivateMethodInScope(e, s));
    }
    parseClassSuper(e) {
      super.parseClassSuper(e), e.superClass && (this.match(47) || this.match(51)) && (e.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(111) && (e.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(e, s, i, a, n, o, u) {
      let c = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return c && (e.typeParameters = c), super.parseObjPropValue(e, s, i, a, n, o, u);
    }
    parseFunctionParams(e, s) {
      let i = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      i && (e.typeParameters = i), super.parseFunctionParams(e, s);
    }
    parseVarId(e, s) {
      super.parseVarId(e, s), e.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (e.definite = true);
      let i = this.tsTryParseTypeAnnotation();
      i && (e.id.typeAnnotation = i, this.resetEndLocation(e.id));
    }
    parseAsyncArrowFromCallExpression(e, s) {
      return this.match(14) && (e.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e, s);
    }
    parseMaybeAssign(e, s) {
      var i, a, n, o, u, c, y2;
      let g2, T, C;
      if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
        if (g2 = this.state.clone(), T = this.tryParse(() => super.parseMaybeAssign(e, s), g2), !T.error)
          return T.node;
        let { context: G } = this.state, J = G[G.length - 1];
        (J === x.j_oTag || J === x.j_expr) && G.pop();
      }
      if (!((i = T) != null && i.error) && !this.match(47))
        return super.parseMaybeAssign(e, s);
      (!g2 || g2 === this.state) && (g2 = this.state.clone());
      let j, q = this.tryParse((G) => {
        var J, K2;
        j = this.tsParseTypeParameters(this.tsParseConstModifier);
        let Z = super.parseMaybeAssign(e, s);
        return (Z.type !== "ArrowFunctionExpression" || (J = Z.extra) != null && J.parenthesized) && G(), ((K2 = j) == null ? void 0 : K2.params.length) !== 0 && this.resetStartLocationFromNode(Z, j), Z.typeParameters = j, Z;
      }, g2);
      if (!q.error && !q.aborted)
        return j && this.reportReservedArrowTypeParam(j), q.node;
      if (!T && (Wr2(!this.hasPlugin("jsx")), C = this.tryParse(() => super.parseMaybeAssign(e, s), g2), !C.error))
        return C.node;
      if ((a = T) != null && a.node)
        return this.state = T.failState, T.node;
      if (q.node)
        return this.state = q.failState, j && this.reportReservedArrowTypeParam(j), q.node;
      if ((n = C) != null && n.node)
        return this.state = C.failState, C.node;
      throw (o = T) != null && o.thrown ? T.error : q.thrown ? q.error : (u = C) != null && u.thrown ? C.error : ((c = T) == null ? void 0 : c.error) || q.error || ((y2 = C) == null ? void 0 : y2.error);
    }
    reportReservedArrowTypeParam(e) {
      var s;
      e.params.length === 1 && !e.params[0].constraint && !((s = e.extra) != null && s.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(w.ReservedArrowTypeParam, { at: e });
    }
    parseMaybeUnary(e, s) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e, s);
    }
    parseArrow(e) {
      if (this.match(14)) {
        let s = this.tryParse((i) => {
          let a = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && i(), a;
        });
        if (s.aborted)
          return;
        s.thrown || (s.error && (this.state = s.failState), e.returnType = s.node);
      }
      return super.parseArrow(e);
    }
    parseAssignableListItemTypes(e, s) {
      if (!(s & 2))
        return e;
      this.eat(17) && (e.optional = true);
      let i = this.tsTryParseTypeAnnotation();
      return i && (e.typeAnnotation = i), this.resetEndLocation(e), e;
    }
    isAssignable(e, s) {
      switch (e.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(e.expression, s);
        case "TSParameterProperty":
          return true;
        default:
          return super.isAssignable(e, s);
      }
    }
    toAssignable(e) {
      let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      switch (e.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(e, s);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          s ? this.expressionScope.recordArrowParameterBindingError(w.UnexpectedTypeCastInParameter, { at: e }) : this.raise(w.UnexpectedTypeCastInParameter, { at: e }), this.toAssignable(e.expression, s);
          break;
        case "AssignmentExpression":
          !s && e.left.type === "TSTypeCastExpression" && (e.left = this.typeCastToParameter(e.left));
        default:
          super.toAssignable(e, s);
      }
    }
    toAssignableParenthesizedExpression(e, s) {
      switch (e.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(e.expression, s);
          break;
        default:
          super.toAssignable(e, s);
      }
    }
    checkToRestConversion(e, s) {
      switch (e.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(e.expression, false);
          break;
        default:
          super.checkToRestConversion(e, s);
      }
    }
    isValidLVal(e, s, i) {
      return Wl2({ TSTypeCastExpression: true, TSParameterProperty: "parameter", TSNonNullExpression: "expression", TSAsExpression: (i !== be2 || !s) && ["expression", true], TSSatisfiesExpression: (i !== be2 || !s) && ["expression", true], TSTypeAssertion: (i !== be2 || !s) && ["expression", true] }, e) || super.isValidLVal(e, s, i);
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(true);
        default:
          return super.parseBindingAtom();
      }
    }
    parseMaybeDecoratorArguments(e) {
      if (this.match(47) || this.match(51)) {
        let s = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          let i = super.parseMaybeDecoratorArguments(e);
          return i.typeParameters = s, i;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(e);
    }
    checkCommaAfterRest(e) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e ? (this.next(), false) : super.checkCommaAfterRest(e);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(e, s) {
      let i = super.parseMaybeDefault(e, s);
      return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(w.TypeAnnotationAfterAssign, { at: i.typeAnnotation }), i;
    }
    getTokenFromCode(e) {
      if (this.state.inType) {
        if (e === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (e === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(e);
    }
    reScan_lt_gt() {
      let { type: e } = this.state;
      e === 47 ? (this.state.pos -= 1, this.readToken_lt()) : e === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let { type: e } = this.state;
      return e === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : e;
    }
    toAssignableList(e, s, i) {
      for (let a = 0; a < e.length; a++) {
        let n = e[a];
        (n == null ? void 0 : n.type) === "TSTypeCastExpression" && (e[a] = this.typeCastToParameter(n));
      }
      super.toAssignableList(e, s, i);
    }
    typeCastToParameter(e) {
      return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
    }
    shouldParseArrow(e) {
      return this.match(14) ? e.every((s) => this.isAssignable(s, true)) : super.shouldParseArrow(e);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(e) {
      if (this.match(47) || this.match(51)) {
        let s = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        s && (e.typeParameters = s);
      }
      return super.jsxParseOpeningElementAfterName(e);
    }
    getGetterSetterExpectedParamCount(e) {
      let s = super.getGetterSetterExpectedParamCount(e), a = this.getObjectOrClassMethodParams(e)[0];
      return a && this.isThisParam(a) ? s + 1 : s;
    }
    parseCatchClauseParam() {
      let e = super.parseCatchClauseParam(), s = this.tsTryParseTypeAnnotation();
      return s && (e.typeAnnotation = s, this.resetEndLocation(e)), e;
    }
    tsInAmbientContext(e) {
      let s = this.state.isAmbientContext;
      this.state.isAmbientContext = true;
      try {
        return e();
      } finally {
        this.state.isAmbientContext = s;
      }
    }
    parseClass(e, s, i) {
      let a = this.state.inAbstractClass;
      this.state.inAbstractClass = !!e.abstract;
      try {
        return super.parseClass(e, s, i);
      } finally {
        this.state.inAbstractClass = a;
      }
    }
    tsParseAbstractDeclaration(e, s) {
      if (this.match(80))
        return e.abstract = true, this.maybeTakeDecorators(s, this.parseClass(e, true, false));
      if (this.isContextual(127)) {
        if (!this.hasFollowingLineBreak())
          return e.abstract = true, this.raise(w.NonClassMethodPropertyHasAbstractModifer, { at: e }), this.tsParseInterfaceDeclaration(e);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(e, s, i, a, n, o, u) {
      let c = super.parseMethod(e, s, i, a, n, o, u);
      if (c.abstract && (this.hasPlugin("estree") ? !!c.value.body : !!c.body)) {
        let { key: g2 } = c;
        this.raise(w.AbstractMethodHasImplementation, { at: c, methodName: g2.type === "Identifier" && !c.computed ? g2.name : `[${this.input.slice(g2.start, g2.end)}]` });
      }
      return c;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
    }
    parseExportSpecifier(e, s, i, a) {
      return !s && a ? (this.parseTypeOnlyImportExportSpecifier(e, false, i), this.finishNode(e, "ExportSpecifier")) : (e.exportKind = "value", super.parseExportSpecifier(e, s, i, a));
    }
    parseImportSpecifier(e, s, i, a, n) {
      return !s && a ? (this.parseTypeOnlyImportExportSpecifier(e, true, i), this.finishNode(e, "ImportSpecifier")) : (e.importKind = "value", super.parseImportSpecifier(e, s, i, a, i ? Dr2 : Xe));
    }
    parseTypeOnlyImportExportSpecifier(e, s, i) {
      let a = s ? "imported" : "local", n = s ? "local" : "exported", o = e[a], u, c = false, y2 = true, g2 = o.loc.start;
      if (this.isContextual(93)) {
        let C = this.parseIdentifier();
        if (this.isContextual(93)) {
          let j = this.parseIdentifier();
          se2(this.state.type) ? (c = true, o = C, u = s ? this.parseIdentifier() : this.parseModuleExportName(), y2 = false) : (u = j, y2 = false);
        } else
          se2(this.state.type) ? (y2 = false, u = s ? this.parseIdentifier() : this.parseModuleExportName()) : (c = true, o = C);
      } else
        se2(this.state.type) && (c = true, s ? (o = this.parseIdentifier(true), this.isContextual(93) || this.checkReservedWord(o.name, o.loc.start, true, true)) : o = this.parseModuleExportName());
      c && i && this.raise(s ? w.TypeModifierIsUsedInTypeImports : w.TypeModifierIsUsedInTypeExports, { at: g2 }), e[a] = o, e[n] = u;
      let T = s ? "importKind" : "exportKind";
      e[T] = c ? "type" : "value", y2 && this.eatContextual(93) && (e[n] = s ? this.parseIdentifier() : this.parseModuleExportName()), e[n] || (e[n] = Te2(e[a])), s && this.checkIdentifier(e[n], c ? Dr2 : Xe);
    }
  };
  function Ql2(t) {
    if (t.type !== "MemberExpression")
      return false;
    let { computed: r, property: e } = t;
    return r && e.type !== "StringLiteral" && (e.type !== "TemplateLiteral" || e.expressions.length > 0) ? false : Xr2(t.object);
  }
  function Zl2(t, r) {
    var e;
    let { type: s } = t;
    if ((e = t.extra) != null && e.parenthesized)
      return false;
    if (r) {
      if (s === "Literal") {
        let { value: i } = t;
        if (typeof i == "string" || typeof i == "boolean")
          return true;
      }
    } else if (s === "StringLiteral" || s === "BooleanLiteral")
      return true;
    return !!(Jr2(t, r) || eh(t, r) || s === "TemplateLiteral" && t.expressions.length === 0 || Ql2(t));
  }
  function Jr2(t, r) {
    return r ? t.type === "Literal" && (typeof t.value == "number" || "bigint" in t) : t.type === "NumericLiteral" || t.type === "BigIntLiteral";
  }
  function eh(t, r) {
    if (t.type === "UnaryExpression") {
      let { operator: e, argument: s } = t;
      if (e === "-" && Jr2(s, r))
        return true;
    }
    return false;
  }
  function Xr2(t) {
    return t.type === "Identifier" ? true : t.type !== "MemberExpression" || t.computed ? false : Xr2(t.object);
  }
  var Yr2 = ge2`placeholders`({ ClassNameIsRequired: "A class name is required.", UnexpectedSpace: "Unexpected space in placeholder." }), th = (t) => class extends t {
    parsePlaceholder(e) {
      if (this.match(142)) {
        let s = this.startNode();
        return this.next(), this.assertNoSpace(), s.name = super.parseIdentifier(true), this.assertNoSpace(), this.expect(142), this.finishPlaceholder(s, e);
      }
    }
    finishPlaceholder(e, s) {
      let i = !!(e.expectedNode && e.type === "Placeholder");
      return e.expectedNode = s, i ? e : this.finishNode(e, "Placeholder");
    }
    getTokenFromCode(e) {
      e === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(142, 2) : super.getTokenFromCode(e);
    }
    parseExprAtom(e) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(e);
    }
    parseIdentifier(e) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(e);
    }
    checkReservedWord(e, s, i, a) {
      e !== void 0 && super.checkReservedWord(e, s, i, a);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(e, s, i) {
      return e === "Placeholder" || super.isValidLVal(e, s, i);
    }
    toAssignable(e, s) {
      e && e.type === "Placeholder" && e.expectedNode === "Expression" ? e.expectedNode = "Pattern" : super.toAssignable(e, s);
    }
    chStartsBindingIdentifier(e, s) {
      return !!(super.chStartsBindingIdentifier(e, s) || this.lookahead().type === 142);
    }
    verifyBreakContinue(e, s) {
      e.label && e.label.type === "Placeholder" || super.verifyBreakContinue(e, s);
    }
    parseExpressionStatement(e, s) {
      if (s.type !== "Placeholder" || s.extra && s.extra.parenthesized)
        return super.parseExpressionStatement(e, s);
      if (this.match(14)) {
        let i = e;
        return i.label = this.finishPlaceholder(s, "Identifier"), this.next(), i.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(i, "LabeledStatement");
      }
      return this.semicolon(), e.name = s.name, this.finishPlaceholder(e, "Statement");
    }
    parseBlock(e, s, i) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(e, s, i);
    }
    parseFunctionId(e) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(e);
    }
    parseClass(e, s, i) {
      let a = s ? "ClassDeclaration" : "ClassExpression";
      this.next();
      let n = this.state.strict, o = this.parsePlaceholder("Identifier");
      if (o)
        if (this.match(81) || this.match(142) || this.match(5))
          e.id = o;
        else {
          if (i || !s)
            return e.id = null, e.body = this.finishPlaceholder(o, "ClassBody"), this.finishNode(e, a);
          throw this.raise(Yr2.ClassNameIsRequired, { at: this.state.startLoc });
        }
      else
        this.parseClassId(e, s, i);
      return super.parseClassSuper(e), e.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!e.superClass, n), this.finishNode(e, a);
    }
    parseExport(e, s) {
      let i = this.parsePlaceholder("Identifier");
      if (!i)
        return super.parseExport(e, s);
      if (!this.isContextual(97) && !this.match(12))
        return e.specifiers = [], e.source = null, e.declaration = this.finishPlaceholder(i, "Declaration"), this.finishNode(e, "ExportNamedDeclaration");
      this.expectPlugin("exportDefaultFrom");
      let a = this.startNode();
      return a.exported = i, e.specifiers = [this.finishNode(a, "ExportDefaultSpecifier")], super.parseExport(e, s);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        let e = this.nextTokenStart();
        if (this.isUnparsedContextual(e, "from") && this.input.startsWith(Y(142), this.nextTokenStartSince(e + 4)))
          return true;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(e) {
      return e.specifiers && e.specifiers.length > 0 ? true : super.maybeParseExportDefaultSpecifier(e);
    }
    checkExport(e) {
      let { specifiers: s } = e;
      s != null && s.length && (e.specifiers = s.filter((i) => i.exported.type === "Placeholder")), super.checkExport(e), e.specifiers = s;
    }
    parseImport(e) {
      let s = this.parsePlaceholder("Identifier");
      if (!s)
        return super.parseImport(e);
      if (e.specifiers = [], !this.isContextual(97) && !this.match(12))
        return e.source = this.finishPlaceholder(s, "StringLiteral"), this.semicolon(), this.finishNode(e, "ImportDeclaration");
      let i = this.startNodeAtNode(s);
      return i.local = s, e.specifiers.push(this.finishNode(i, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(e) || this.parseNamedImportSpecifiers(e)), this.expectContextual(97), e.source = this.parseImportSource(), this.semicolon(), this.finishNode(e, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.state.lastTokEndLoc.index && this.raise(Yr2.UnexpectedSpace, { at: this.state.lastTokEndLoc });
    }
  }, sh2 = (t) => class extends t {
    parseV8Intrinsic() {
      if (this.match(54)) {
        let e = this.state.startLoc, s = this.startNode();
        if (this.next(), R2(this.state.type)) {
          let i = this.parseIdentifierName(), a = this.createIdentifier(s, i);
          if (a.type = "V8IntrinsicIdentifier", this.match(10))
            return a;
        }
        this.unexpected(e);
      }
    }
    parseExprAtom(e) {
      return this.parseV8Intrinsic() || super.parseExprAtom(e);
    }
  };
  function Q(t, r) {
    let [e, s] = typeof r == "string" ? [r, {}] : r, i = Object.keys(s), a = i.length === 0;
    return t.some((n) => {
      if (typeof n == "string")
        return a && n === e;
      {
        let [o, u] = n;
        if (o !== e)
          return false;
        for (let c of i)
          if (u[c] !== s[c])
            return false;
        return true;
      }
    });
  }
  function Le(t, r, e) {
    let s = t.find((i) => Array.isArray(i) ? i[0] === r : i === r);
    return s && Array.isArray(s) && s.length > 1 ? s[1][e] : null;
  }
  var Qr = ["minimal", "fsharp", "hack", "smart"], Zr2 = ["^^", "@@", "^", "%", "#"], ei = ["hash", "bar"];
  function rh(t) {
    if (Q(t, "decorators")) {
      if (Q(t, "decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      let r = Le(t, "decorators", "decoratorsBeforeExport");
      if (r != null && typeof r != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      let e = Le(t, "decorators", "allowCallParenthesized");
      if (e != null && typeof e != "boolean")
        throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (Q(t, "flow") && Q(t, "typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (Q(t, "placeholders") && Q(t, "v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (Q(t, "pipelineOperator")) {
      let r = Le(t, "pipelineOperator", "proposal");
      if (!Qr.includes(r)) {
        let s = Qr.map((i) => `"${i}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${s}.`);
      }
      let e = Q(t, ["recordAndTuple", { syntaxType: "hash" }]);
      if (r === "hack") {
        if (Q(t, "placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (Q(t, "v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        let s = Le(t, "pipelineOperator", "topicToken");
        if (!Zr2.includes(s)) {
          let i = Zr2.map((a) => `"${a}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${i}.`);
        }
        if (s === "#" && e)
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
      } else if (r === "smart" && e)
        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
    }
    if (Q(t, "moduleAttributes")) {
      if (Q(t, "importAssertions"))
        throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
      if (Le(t, "moduleAttributes", "version") !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
    }
    if (Q(t, "recordAndTuple") && Le(t, "recordAndTuple", "syntaxType") != null && !ei.includes(Le(t, "recordAndTuple", "syntaxType")))
      throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + ei.map((r) => `'${r}'`).join(", "));
    if (Q(t, "asyncDoExpressions") && !Q(t, "doExpressions")) {
      let r = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw r.missingPlugins = "doExpressions", r;
    }
  }
  var ti2 = { estree: Uo2, jsx: $l2, flow: ql2, typescript: Yl2, v8intrinsic: sh2, placeholders: th }, ih = Object.keys(ti2), ah = class extends Kl2 {
    checkProto(t, r, e, s) {
      if (t.type === "SpreadElement" || this.isObjectMethod(t) || t.computed || t.shorthand)
        return;
      let i = t.key;
      if ((i.type === "Identifier" ? i.name : i.value) === "__proto__") {
        if (r) {
          this.raise(p.RecordNoProto, { at: i });
          return;
        }
        e.used && (s ? s.doubleProtoLoc === null && (s.doubleProtoLoc = i.loc.start) : this.raise(p.DuplicateProto, { at: i })), e.used = true;
      }
    }
    shouldExitDescending(t, r) {
      return t.type === "ArrowFunctionExpression" && t.start === r;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      let t = this.parseExpression();
      return this.match(137) || this.unexpected(), this.finalizeRemainingComments(), t.comments = this.state.comments, t.errors = this.state.errors, this.options.tokens && (t.tokens = this.tokens), t;
    }
    parseExpression(t, r) {
      return t ? this.disallowInAnd(() => this.parseExpressionBase(r)) : this.allowInAnd(() => this.parseExpressionBase(r));
    }
    parseExpressionBase(t) {
      let r = this.state.startLoc, e = this.parseMaybeAssign(t);
      if (this.match(12)) {
        let s = this.startNodeAt(r);
        for (s.expressions = [e]; this.eat(12); )
          s.expressions.push(this.parseMaybeAssign(t));
        return this.toReferencedList(s.expressions), this.finishNode(s, "SequenceExpression");
      }
      return e;
    }
    parseMaybeAssignDisallowIn(t, r) {
      return this.disallowInAnd(() => this.parseMaybeAssign(t, r));
    }
    parseMaybeAssignAllowIn(t, r) {
      return this.allowInAnd(() => this.parseMaybeAssign(t, r));
    }
    setOptionalParametersError(t, r) {
      var e;
      t.optionalParametersLoc = (e = r == null ? void 0 : r.loc) != null ? e : this.state.startLoc;
    }
    parseMaybeAssign(t, r) {
      let e = this.state.startLoc;
      if (this.isContextual(106) && this.prodParam.hasYield) {
        let n = this.parseYield();
        return r && (n = r.call(this, n, e)), n;
      }
      let s;
      t ? s = false : (t = new wt2(), s = true);
      let { type: i } = this.state;
      (i === 10 || R2(i)) && (this.state.potentialArrowAt = this.state.start);
      let a = this.parseMaybeConditional(t);
      if (r && (a = r.call(this, a, e)), ye2(this.state.type)) {
        let n = this.startNodeAt(e), o = this.state.value;
        if (n.operator = o, this.match(29)) {
          this.toAssignable(a, true), n.left = a;
          let u = e.index;
          t.doubleProtoLoc != null && t.doubleProtoLoc.index >= u && (t.doubleProtoLoc = null), t.shorthandAssignLoc != null && t.shorthandAssignLoc.index >= u && (t.shorthandAssignLoc = null), t.privateKeyLoc != null && t.privateKeyLoc.index >= u && (this.checkDestructuringPrivate(t), t.privateKeyLoc = null);
        } else
          n.left = a;
        return this.next(), n.right = this.parseMaybeAssign(), this.checkLVal(a, { in: this.finishNode(n, "AssignmentExpression") }), n;
      } else
        s && this.checkExpressionErrors(t, true);
      return a;
    }
    parseMaybeConditional(t) {
      let r = this.state.startLoc, e = this.state.potentialArrowAt, s = this.parseExprOps(t);
      return this.shouldExitDescending(s, e) ? s : this.parseConditional(s, r, t);
    }
    parseConditional(t, r, e) {
      if (this.eat(17)) {
        let s = this.startNodeAt(r);
        return s.test = t, s.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), s.alternate = this.parseMaybeAssign(), this.finishNode(s, "ConditionalExpression");
      }
      return t;
    }
    parseMaybeUnaryOrPrivate(t) {
      return this.match(136) ? this.parsePrivateName() : this.parseMaybeUnary(t);
    }
    parseExprOps(t) {
      let r = this.state.startLoc, e = this.state.potentialArrowAt, s = this.parseMaybeUnaryOrPrivate(t);
      return this.shouldExitDescending(s, e) ? s : this.parseExprOp(s, r, -1);
    }
    parseExprOp(t, r, e) {
      if (this.isPrivateName(t)) {
        let i = this.getPrivateNameSV(t);
        (e >= Re2(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(p.PrivateInExpectedIn, { at: t, identifierName: i }), this.classScope.usePrivateName(i, t.loc.start);
      }
      let s = this.state.type;
      if (le2(s) && (this.prodParam.hasIn || !this.match(58))) {
        let i = Re2(s);
        if (i > e) {
          if (s === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return t;
            this.checkPipelineAtInfixOperator(t, r);
          }
          let a = this.startNodeAt(r);
          a.left = t, a.operator = this.state.value;
          let n = s === 41 || s === 42, o = s === 40;
          if (o && (i = Re2(42)), this.next(), s === 39 && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(p.UnexpectedAwaitAfterPipelineBody, { at: this.state.startLoc });
          a.right = this.parseExprOpRightExpr(s, i);
          let u = this.finishNode(a, n || o ? "LogicalExpression" : "BinaryExpression"), c = this.state.type;
          if (o && (c === 41 || c === 42) || n && c === 40)
            throw this.raise(p.MixingCoalesceWithLogical, { at: this.state.startLoc });
          return this.parseExprOp(u, r, e);
        }
      }
      return t;
    }
    parseExprOpRightExpr(t, r) {
      let e = this.state.startLoc;
      switch (t) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "smart":
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(106))
                  throw this.raise(p.PipeBodyIsTighter, { at: this.state.startLoc });
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(t, r), e);
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(r));
          }
        default:
          return this.parseExprOpBaseRightExpr(t, r);
      }
    }
    parseExprOpBaseRightExpr(t, r) {
      let e = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), e, Gt2(t) ? r - 1 : r);
    }
    parseHackPipeBody() {
      var t;
      let { startLoc: r } = this.state, e = this.parseMaybeAssign();
      return Bo2.has(e.type) && !((t = e.extra) != null && t.parenthesized) && this.raise(p.PipeUnparenthesizedBody, { at: r, type: e.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(p.PipeTopicUnused, { at: r }), e;
    }
    checkExponentialAfterUnary(t) {
      this.match(57) && this.raise(p.UnexpectedTokenUnaryExponentiation, { at: t.argument });
    }
    parseMaybeUnary(t, r) {
      let e = this.state.startLoc, s = this.isContextual(96);
      if (s && this.isAwaitAllowed()) {
        this.next();
        let o = this.parseAwait(e);
        return r || this.checkExponentialAfterUnary(o), o;
      }
      let i = this.match(34), a = this.startNode();
      if (ht2(this.state.type)) {
        a.operator = this.state.value, a.prefix = true, this.match(72) && this.expectPlugin("throwExpressions");
        let o = this.match(89);
        if (this.next(), a.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(t, true), this.state.strict && o) {
          let u = a.argument;
          u.type === "Identifier" ? this.raise(p.StrictDelete, { at: a }) : this.hasPropertyAsPrivateName(u) && this.raise(p.DeletePrivateField, { at: a });
        }
        if (!i)
          return r || this.checkExponentialAfterUnary(a), this.finishNode(a, "UnaryExpression");
      }
      let n = this.parseUpdate(a, i, t);
      if (s) {
        let { type: o } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? X(o) : X(o) && !this.match(54)) && !this.isAmbiguousAwait())
          return this.raiseOverwrite(p.AwaitNotInAsyncContext, { at: e }), this.parseAwait(e);
      }
      return n;
    }
    parseUpdate(t, r, e) {
      if (r) {
        let a = t;
        return this.checkLVal(a.argument, { in: this.finishNode(a, "UpdateExpression") }), t;
      }
      let s = this.state.startLoc, i = this.parseExprSubscripts(e);
      if (this.checkExpressionErrors(e, false))
        return i;
      for (; ue2(this.state.type) && !this.canInsertSemicolon(); ) {
        let a = this.startNodeAt(s);
        a.operator = this.state.value, a.prefix = false, a.argument = i, this.next(), this.checkLVal(i, { in: i = this.finishNode(a, "UpdateExpression") });
      }
      return i;
    }
    parseExprSubscripts(t) {
      let r = this.state.startLoc, e = this.state.potentialArrowAt, s = this.parseExprAtom(t);
      return this.shouldExitDescending(s, e) ? s : this.parseSubscripts(s, r);
    }
    parseSubscripts(t, r, e) {
      let s = { optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(t), stop: false };
      do
        t = this.parseSubscript(t, r, e, s), s.maybeAsyncArrow = false;
      while (!s.stop);
      return t;
    }
    parseSubscript(t, r, e, s) {
      let { type: i } = this.state;
      if (!e && i === 15)
        return this.parseBind(t, r, e, s);
      if (ct2(i))
        return this.parseTaggedTemplateExpression(t, r, s);
      let a = false;
      if (i === 18) {
        if (e && (this.raise(p.OptionalChainingNoNew, { at: this.state.startLoc }), this.lookaheadCharCode() === 40))
          return s.stop = true, t;
        s.optionalChainMember = a = true, this.next();
      }
      if (!e && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(t, r, s, a);
      {
        let n = this.eat(0);
        return n || a || this.eat(16) ? this.parseMember(t, r, s, n, a) : (s.stop = true, t);
      }
    }
    parseMember(t, r, e, s, i) {
      let a = this.startNodeAt(r);
      return a.object = t, a.computed = s, s ? (a.property = this.parseExpression(), this.expect(3)) : this.match(136) ? (t.type === "Super" && this.raise(p.SuperPrivateField, { at: r }), this.classScope.usePrivateName(this.state.value, this.state.startLoc), a.property = this.parsePrivateName()) : a.property = this.parseIdentifier(true), e.optionalChainMember ? (a.optional = i, this.finishNode(a, "OptionalMemberExpression")) : this.finishNode(a, "MemberExpression");
    }
    parseBind(t, r, e, s) {
      let i = this.startNodeAt(r);
      return i.object = t, this.next(), i.callee = this.parseNoCallExpr(), s.stop = true, this.parseSubscripts(this.finishNode(i, "BindExpression"), r, e);
    }
    parseCoverCallAndAsyncArrowHead(t, r, e, s) {
      let i = this.state.maybeInArrowParameters, a = null;
      this.state.maybeInArrowParameters = true, this.next();
      let n = this.startNodeAt(r);
      n.callee = t;
      let { maybeAsyncArrow: o, optionalChainMember: u } = e;
      o && (this.expressionScope.enter(Nl2()), a = new wt2()), u && (n.optional = s), s ? n.arguments = this.parseCallExpressionArguments(11) : n.arguments = this.parseCallExpressionArguments(11, t.type === "Import", t.type !== "Super", n, a);
      let c = this.finishCallExpression(n, u);
      return o && this.shouldParseAsyncArrow() && !s ? (e.stop = true, this.checkDestructuringPrivate(a), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), c = this.parseAsyncArrowFromCallExpression(this.startNodeAt(r), c)) : (o && (this.checkExpressionErrors(a, true), this.expressionScope.exit()), this.toReferencedArguments(c)), this.state.maybeInArrowParameters = i, c;
    }
    toReferencedArguments(t, r) {
      this.toReferencedListDeep(t.arguments, r);
    }
    parseTaggedTemplateExpression(t, r, e) {
      let s = this.startNodeAt(r);
      return s.tag = t, s.quasi = this.parseTemplate(true), e.optionalChainMember && this.raise(p.OptionalChainingNoTemplate, { at: r }), this.finishNode(s, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(t) {
      return t.type === "Identifier" && t.name === "async" && this.state.lastTokEndLoc.index === t.end && !this.canInsertSemicolon() && t.end - t.start === 5 && t.start === this.state.potentialArrowAt;
    }
    finishCallExpression(t, r) {
      if (t.callee.type === "Import")
        if (t.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectPlugin("importAssertions")), t.arguments.length === 0 || t.arguments.length > 2)
          this.raise(p.ImportCallArity, { at: t, maxArgumentCount: this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1 });
        else
          for (let e of t.arguments)
            e.type === "SpreadElement" && this.raise(p.ImportCallSpreadArgument, { at: e });
      return this.finishNode(t, r ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(t, r, e, s, i) {
      let a = [], n = true, o = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = false; !this.eat(t); ) {
        if (n)
          n = false;
        else if (this.expect(12), this.match(t)) {
          r && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(p.ImportCallArgumentTrailingComma, { at: this.state.lastTokStartLoc }), s && this.addTrailingCommaExtraToNode(s), this.next();
          break;
        }
        a.push(this.parseExprListItem(false, i, e));
      }
      return this.state.inFSharpPipelineDirectBody = o, a;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(t, r) {
      var e;
      return this.resetPreviousNodeTrailingComments(r), this.expect(19), this.parseArrowExpression(t, r.arguments, true, (e = r.extra) == null ? void 0 : e.trailingCommaLoc), r.innerComments && Ye2(t, r.innerComments), r.callee.trailingComments && Ye2(t, r.callee.trailingComments), t;
    }
    parseNoCallExpr() {
      let t = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), t, true);
    }
    parseExprAtom(t) {
      let r, e = null, { type: s } = this.state;
      switch (s) {
        case 79:
          return this.parseSuper();
        case 83:
          return r = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(r) : (this.match(10) || this.raise(p.UnsupportedImport, { at: this.state.lastTokStartLoc }), this.finishNode(r, "Import"));
        case 78:
          return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), false);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 132:
          return this.parseNumericLiteral(this.state.value);
        case 133:
          return this.parseBigIntLiteral(this.state.value);
        case 134:
          return this.parseDecimalLiteral(this.state.value);
        case 131:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(true);
        case 86:
          return this.parseBooleanLiteral(false);
        case 10: {
          let i = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(i);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
        case 0:
          return this.parseArrayLike(3, true, false, t);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
        case 5:
          return this.parseObjectLike(8, false, false, t);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          e = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(e, this.startNode()), false);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(false);
        case 15: {
          r = this.startNode(), this.next(), r.object = null;
          let i = r.callee = this.parseNoCallExpr();
          if (i.type === "MemberExpression")
            return this.finishNode(r, "BindExpression");
          throw this.raise(p.UnsupportedBind, { at: i });
        }
        case 136:
          return this.raise(p.PrivateInExpectedIn, { at: this.state.startLoc, identifierName: this.state.value }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          let i = this.getPluginOption("pipelineOperator", "proposal");
          if (i)
            return this.parseTopicReference(i);
          this.unexpected();
          break;
        }
        case 47: {
          let i = this.input.codePointAt(this.nextTokenStart());
          Pe2(i) || i === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          if (R2(s)) {
            if (this.isContextual(125) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak())
              return this.parseModuleExpression();
            let i = this.state.potentialArrowAt === this.state.start, a = this.state.containsEsc, n = this.parseIdentifier();
            if (!a && n.name === "async" && !this.canInsertSemicolon()) {
              let { type: o } = this.state;
              if (o === 68)
                return this.resetPreviousNodeTrailingComments(n), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(n));
              if (R2(o))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(n)) : n;
              if (o === 90)
                return this.resetPreviousNodeTrailingComments(n), this.parseDo(this.startNodeAtNode(n), true);
            }
            return i && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(n), [n], false)) : n;
          } else
            this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(t, r) {
      let e = this.getPluginOption("pipelineOperator", "proposal");
      if (e)
        return this.state.type = t, this.state.value = r, this.state.pos--, this.state.end--, this.state.endLoc = re(this.state.endLoc, -1), this.parseTopicReference(e);
      this.unexpected();
    }
    parseTopicReference(t) {
      let r = this.startNode(), e = this.state.startLoc, s = this.state.type;
      return this.next(), this.finishTopicReference(r, e, t, s);
    }
    finishTopicReference(t, r, e, s) {
      if (this.testTopicReferenceConfiguration(e, r, s)) {
        let i = e === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
        return this.topicReferenceIsAllowedInCurrentContext() || this.raise(e === "smart" ? p.PrimaryTopicNotAllowed : p.PipeTopicUnbound, { at: r }), this.registerTopicReference(), this.finishNode(t, i);
      } else
        throw this.raise(p.PipeTopicUnconfiguredToken, { at: r, token: Y(s) });
    }
    testTopicReferenceConfiguration(t, r, e) {
      switch (t) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", { topicToken: Y(e) }]);
        case "smart":
          return e === 27;
        default:
          throw this.raise(p.PipeTopicRequiresHackPipes, { at: r });
      }
    }
    parseAsyncArrowUnaryFunction(t) {
      this.prodParam.enter(St2(true, this.prodParam.hasYield));
      let r = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(p.LineTerminatorBeforeArrow, { at: this.state.curPosition() }), this.expect(19), this.parseArrowExpression(t, r, true);
    }
    parseDo(t, r) {
      this.expectPlugin("doExpressions"), r && this.expectPlugin("asyncDoExpressions"), t.async = r, this.next();
      let e = this.state.labels;
      return this.state.labels = [], r ? (this.prodParam.enter(bt2), t.body = this.parseBlock(), this.prodParam.exit()) : t.body = this.parseBlock(), this.state.labels = e, this.finishNode(t, "DoExpression");
    }
    parseSuper() {
      let t = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(p.SuperNotAllowed, { at: t }) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(p.UnexpectedSuper, { at: t }), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(p.UnsupportedSuper, { at: t }), this.finishNode(t, "Super");
    }
    parsePrivateName() {
      let t = this.startNode(), r = this.startNodeAt(re(this.state.startLoc, 1)), e = this.state.value;
      return this.next(), t.id = this.createIdentifier(r, e), this.finishNode(t, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      let t = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(t), "function");
        return this.next(), this.match(102) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(t, r, "sent");
      }
      return this.parseFunction(t);
    }
    parseMetaProperty(t, r, e) {
      t.meta = r;
      let s = this.state.containsEsc;
      return t.property = this.parseIdentifier(true), (t.property.name !== e || s) && this.raise(p.UnsupportedMetaProperty, { at: t.property, target: r.name, onlyValidPropertyName: e }), this.finishNode(t, "MetaProperty");
    }
    parseImportMetaProperty(t) {
      let r = this.createIdentifier(this.startNodeAtNode(t), "import");
      return this.next(), this.isContextual(100) && (this.inModule || this.raise(p.ImportMetaOutsideModule, { at: r }), this.sawUnambiguousESM = true), this.parseMetaProperty(t, r, "meta");
    }
    parseLiteralAtNode(t, r, e) {
      return this.addExtra(e, "rawValue", t), this.addExtra(e, "raw", this.input.slice(e.start, this.state.end)), e.value = t, this.next(), this.finishNode(e, r);
    }
    parseLiteral(t, r) {
      let e = this.startNode();
      return this.parseLiteralAtNode(t, r, e);
    }
    parseStringLiteral(t) {
      return this.parseLiteral(t, "StringLiteral");
    }
    parseNumericLiteral(t) {
      return this.parseLiteral(t, "NumericLiteral");
    }
    parseBigIntLiteral(t) {
      return this.parseLiteral(t, "BigIntLiteral");
    }
    parseDecimalLiteral(t) {
      return this.parseLiteral(t, "DecimalLiteral");
    }
    parseRegExpLiteral(t) {
      let r = this.parseLiteral(t.value, "RegExpLiteral");
      return r.pattern = t.pattern, r.flags = t.flags, r;
    }
    parseBooleanLiteral(t) {
      let r = this.startNode();
      return r.value = t, this.next(), this.finishNode(r, "BooleanLiteral");
    }
    parseNullLiteral() {
      let t = this.startNode();
      return this.next(), this.finishNode(t, "NullLiteral");
    }
    parseParenAndDistinguishExpression(t) {
      let r = this.state.startLoc, e;
      this.next(), this.expressionScope.enter(Il2());
      let s = this.state.maybeInArrowParameters, i = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
      let a = this.state.startLoc, n = [], o = new wt2(), u = true, c, y2;
      for (; !this.match(11); ) {
        if (u)
          u = false;
        else if (this.expect(12, o.optionalParametersLoc === null ? null : o.optionalParametersLoc), this.match(11)) {
          y2 = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          let C = this.state.startLoc;
          if (c = this.state.startLoc, n.push(this.parseParenItem(this.parseRestBinding(), C)), !this.checkCommaAfterRest(41))
            break;
        } else
          n.push(this.parseMaybeAssignAllowIn(o, this.parseParenItem));
      }
      let g2 = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = s, this.state.inFSharpPipelineDirectBody = i;
      let T = this.startNodeAt(r);
      return t && this.shouldParseArrow(n) && (T = this.parseArrow(T)) ? (this.checkDestructuringPrivate(o), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(T, n, false), T) : (this.expressionScope.exit(), n.length || this.unexpected(this.state.lastTokStartLoc), y2 && this.unexpected(y2), c && this.unexpected(c), this.checkExpressionErrors(o, true), this.toReferencedListDeep(n, true), n.length > 1 ? (e = this.startNodeAt(a), e.expressions = n, this.finishNode(e, "SequenceExpression"), this.resetEndLocation(e, g2)) : e = n[0], this.wrapParenthesis(r, e));
    }
    wrapParenthesis(t, r) {
      if (!this.options.createParenthesizedExpressions)
        return this.addExtra(r, "parenthesized", true), this.addExtra(r, "parenStart", t.index), this.takeSurroundingComments(r, t.index, this.state.lastTokEndLoc.index), r;
      let e = this.startNodeAt(t);
      return e.expression = r, this.finishNode(e, "ParenthesizedExpression");
    }
    shouldParseArrow(t) {
      return !this.canInsertSemicolon();
    }
    parseArrow(t) {
      if (this.eat(19))
        return t;
    }
    parseParenItem(t, r) {
      return t;
    }
    parseNewOrNewTarget() {
      let t = this.startNode();
      if (this.next(), this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(t), "new");
        this.next();
        let e = this.parseMetaProperty(t, r, "target");
        return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(p.UnexpectedNewTarget, { at: e }), e;
      }
      return this.parseNew(t);
    }
    parseNew(t) {
      if (this.parseNewCallee(t), this.eat(10)) {
        let r = this.parseExprList(11);
        this.toReferencedList(r), t.arguments = r;
      } else
        t.arguments = [];
      return this.finishNode(t, "NewExpression");
    }
    parseNewCallee(t) {
      t.callee = this.parseNoCallExpr(), t.callee.type === "Import" && this.raise(p.ImportCallNotNewExpression, { at: t.callee });
    }
    parseTemplateElement(t) {
      let { start: r, startLoc: e, end: s, value: i } = this.state, a = r + 1, n = this.startNodeAt(re(e, 1));
      i === null && (t || this.raise(p.InvalidEscapeSequenceTemplate, { at: re(this.state.firstInvalidTemplateEscapePos, 1) }));
      let o = this.match(24), u = o ? -1 : -2, c = s + u;
      n.value = { raw: this.input.slice(a, c).replace(/\r\n?/g, `
`), cooked: i === null ? null : i.slice(1, u) }, n.tail = o, this.next();
      let y2 = this.finishNode(n, "TemplateElement");
      return this.resetEndLocation(y2, re(this.state.lastTokEndLoc, u)), y2;
    }
    parseTemplate(t) {
      let r = this.startNode();
      r.expressions = [];
      let e = this.parseTemplateElement(t);
      for (r.quasis = [e]; !e.tail; )
        r.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), r.quasis.push(e = this.parseTemplateElement(t));
      return this.finishNode(r, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(t, r, e, s) {
      e && this.expectPlugin("recordAndTuple");
      let i = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      let a = /* @__PURE__ */ Object.create(null), n = true, o = this.startNode();
      for (o.properties = [], this.next(); !this.match(t); ) {
        if (n)
          n = false;
        else if (this.expect(12), this.match(t)) {
          this.addTrailingCommaExtraToNode(o);
          break;
        }
        let c;
        r ? c = this.parseBindingProperty() : (c = this.parsePropertyDefinition(s), this.checkProto(c, e, a, s)), e && !this.isObjectProperty(c) && c.type !== "SpreadElement" && this.raise(p.InvalidRecordProperty, { at: c }), c.shorthand && this.addExtra(c, "shorthand", true), o.properties.push(c);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = i;
      let u = "ObjectExpression";
      return r ? u = "ObjectPattern" : e && (u = "RecordExpression"), this.finishNode(o, u);
    }
    addTrailingCommaExtraToNode(t) {
      this.addExtra(t, "trailingComma", this.state.lastTokStart), this.addExtra(t, "trailingCommaLoc", this.state.lastTokStartLoc, false);
    }
    maybeAsyncOrAccessorProp(t) {
      return !t.computed && t.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(t) {
      let r = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(p.UnsupportedPropertyDecorator, { at: this.state.startLoc }); this.match(26); )
          r.push(this.parseDecorator());
      let e = this.startNode(), s = false, i = false, a;
      if (this.match(21))
        return r.length && this.unexpected(), this.parseSpread();
      r.length && (e.decorators = r, r = []), e.method = false, t && (a = this.state.startLoc);
      let n = this.eat(55);
      this.parsePropertyNamePrefixOperator(e);
      let o = this.state.containsEsc, u = this.parsePropertyName(e, t);
      if (!n && !o && this.maybeAsyncOrAccessorProp(e)) {
        let c = u.name;
        c === "async" && !this.hasPrecedingLineBreak() && (s = true, this.resetPreviousNodeTrailingComments(u), n = this.eat(55), this.parsePropertyName(e)), (c === "get" || c === "set") && (i = true, this.resetPreviousNodeTrailingComments(u), e.kind = c, this.match(55) && (n = true, this.raise(p.AccessorIsGenerator, { at: this.state.curPosition(), kind: c }), this.next()), this.parsePropertyName(e));
      }
      return this.parseObjPropValue(e, a, n, s, false, i, t);
    }
    getGetterSetterExpectedParamCount(t) {
      return t.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(t) {
      return t.params;
    }
    checkGetterSetterParams(t) {
      var r;
      let e = this.getGetterSetterExpectedParamCount(t), s = this.getObjectOrClassMethodParams(t);
      s.length !== e && this.raise(t.kind === "get" ? p.BadGetterArity : p.BadSetterArity, { at: t }), t.kind === "set" && ((r = s[s.length - 1]) == null ? void 0 : r.type) === "RestElement" && this.raise(p.BadSetterRestParameter, { at: t });
    }
    parseObjectMethod(t, r, e, s, i) {
      if (i) {
        let a = this.parseMethod(t, r, false, false, false, "ObjectMethod");
        return this.checkGetterSetterParams(a), a;
      }
      if (e || r || this.match(10))
        return s && this.unexpected(), t.kind = "method", t.method = true, this.parseMethod(t, r, e, false, false, "ObjectMethod");
    }
    parseObjectProperty(t, r, e, s) {
      if (t.shorthand = false, this.eat(14))
        return t.value = e ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(s), this.finishNode(t, "ObjectProperty");
      if (!t.computed && t.key.type === "Identifier") {
        if (this.checkReservedWord(t.key.name, t.key.loc.start, true, false), e)
          t.value = this.parseMaybeDefault(r, Te2(t.key));
        else if (this.match(29)) {
          let i = this.state.startLoc;
          s != null ? s.shorthandAssignLoc === null && (s.shorthandAssignLoc = i) : this.raise(p.InvalidCoverInitializedName, { at: i }), t.value = this.parseMaybeDefault(r, Te2(t.key));
        } else
          t.value = Te2(t.key);
        return t.shorthand = true, this.finishNode(t, "ObjectProperty");
      }
    }
    parseObjPropValue(t, r, e, s, i, a, n) {
      let o = this.parseObjectMethod(t, e, s, i, a) || this.parseObjectProperty(t, r, i, n);
      return o || this.unexpected(), o;
    }
    parsePropertyName(t, r) {
      if (this.eat(0))
        t.computed = true, t.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        let { type: e, value: s } = this.state, i;
        if (se2(e))
          i = this.parseIdentifier(true);
        else
          switch (e) {
            case 132:
              i = this.parseNumericLiteral(s);
              break;
            case 131:
              i = this.parseStringLiteral(s);
              break;
            case 133:
              i = this.parseBigIntLiteral(s);
              break;
            case 134:
              i = this.parseDecimalLiteral(s);
              break;
            case 136: {
              let a = this.state.startLoc;
              r != null ? r.privateKeyLoc === null && (r.privateKeyLoc = a) : this.raise(p.UnexpectedPrivateField, { at: a }), i = this.parsePrivateName();
              break;
            }
            default:
              this.unexpected();
          }
        t.key = i, e !== 136 && (t.computed = false);
      }
      return t.key;
    }
    initFunction(t, r) {
      t.id = null, t.generator = false, t.async = r;
    }
    parseMethod(t, r, e, s, i, a) {
      let n = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
      this.initFunction(t, e), t.generator = r, this.scope.enter(Ae2 | dt2 | (n ? Ne2 : 0) | (i ? Cr2 : 0)), this.prodParam.enter(St2(e, t.generator)), this.parseFunctionParams(t, s);
      let o = this.parseFunctionBodyAndFinish(t, a, true);
      return this.prodParam.exit(), this.scope.exit(), o;
    }
    parseArrayLike(t, r, e, s) {
      e && this.expectPlugin("recordAndTuple");
      let i = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      let a = this.startNode();
      return this.next(), a.elements = this.parseExprList(t, !e, s, a), this.state.inFSharpPipelineDirectBody = i, this.finishNode(a, e ? "TupleExpression" : "ArrayExpression");
    }
    parseArrowExpression(t, r, e, s) {
      this.scope.enter(Ae2 | es);
      let i = St2(e, false);
      !this.match(5) && this.prodParam.hasIn && (i |= Ve2), this.prodParam.enter(i), this.initFunction(t, e);
      let a = this.state.maybeInArrowParameters;
      return r && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(t, r, s)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(t, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = a, this.finishNode(t, "ArrowFunctionExpression");
    }
    setArrowFunctionParameters(t, r, e) {
      this.toAssignableList(r, e, false), t.params = r;
    }
    parseFunctionBodyAndFinish(t, r) {
      let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      return this.parseFunctionBody(t, false, e), this.finishNode(t, r);
    }
    parseFunctionBody(t, r) {
      let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, s = r && !this.match(5);
      if (this.expressionScope.enter($r2()), s)
        t.body = this.parseMaybeAssign(), this.checkParams(t, false, r, false);
      else {
        let i = this.state.strict, a = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | zr2), t.body = this.parseBlock(true, false, (n) => {
          let o = !this.isSimpleParamList(t.params);
          n && o && this.raise(p.IllegalLanguageModeDirective, { at: (t.kind === "method" || t.kind === "constructor") && t.key ? t.key.loc.end : t });
          let u = !i && this.state.strict;
          this.checkParams(t, !this.state.strict && !r && !e && !o, r, u), this.state.strict && t.id && this.checkIdentifier(t.id, tl2, u);
        }), this.prodParam.exit(), this.state.labels = a;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(t) {
      return t.type === "Identifier";
    }
    isSimpleParamList(t) {
      for (let r = 0, e = t.length; r < e; r++)
        if (!this.isSimpleParameter(t[r]))
          return false;
      return true;
    }
    checkParams(t, r, e) {
      let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true, i = !r && /* @__PURE__ */ new Set(), a = { type: "FormalParameters" };
      for (let n of t.params)
        this.checkLVal(n, { in: a, binding: At2, checkClashes: i, strictModeChanged: s });
    }
    parseExprList(t, r, e, s) {
      let i = [], a = true;
      for (; !this.eat(t); ) {
        if (a)
          a = false;
        else if (this.expect(12), this.match(t)) {
          s && this.addTrailingCommaExtraToNode(s), this.next();
          break;
        }
        i.push(this.parseExprListItem(r, e));
      }
      return i;
    }
    parseExprListItem(t, r, e) {
      let s;
      if (this.match(12))
        t || this.raise(p.UnexpectedToken, { at: this.state.curPosition(), unexpected: "," }), s = null;
      else if (this.match(21)) {
        let i = this.state.startLoc;
        s = this.parseParenItem(this.parseSpread(r), i);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), e || this.raise(p.UnexpectedArgumentPlaceholder, { at: this.state.startLoc });
        let i = this.startNode();
        this.next(), s = this.finishNode(i, "ArgumentPlaceholder");
      } else
        s = this.parseMaybeAssignAllowIn(r, this.parseParenItem);
      return s;
    }
    parseIdentifier(t) {
      let r = this.startNode(), e = this.parseIdentifierName(t);
      return this.createIdentifier(r, e);
    }
    createIdentifier(t, r) {
      return t.name = r, t.loc.identifierName = r, this.finishNode(t, "Identifier");
    }
    parseIdentifierName(t) {
      let r, { startLoc: e, type: s } = this.state;
      se2(s) ? r = this.state.value : this.unexpected();
      let i = ae2(s);
      return t ? i && this.replaceToken(130) : this.checkReservedWord(r, e, i, false), this.next(), r;
    }
    checkReservedWord(t, r, e, s) {
      if (t.length > 10 || !Yo2(t))
        return;
      if (e && Go2(t)) {
        this.raise(p.UnexpectedKeyword, { at: r, keyword: t });
        return;
      }
      if ((this.state.strict ? s ? vr2 : Ar2 : Pr2)(t, this.inModule)) {
        this.raise(p.UnexpectedReservedWord, { at: r, reservedWord: t });
        return;
      } else if (t === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(p.YieldBindingIdentifier, { at: r });
          return;
        }
      } else if (t === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(p.AwaitBindingIdentifier, { at: r });
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(p.AwaitBindingIdentifierInStaticBlock, { at: r });
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError({ at: r });
      } else if (t === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(p.ArgumentsInClass, { at: r });
        return;
      }
    }
    isAwaitAllowed() {
      return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
    }
    parseAwait(t) {
      let r = this.startNodeAt(t);
      return this.expressionScope.recordParameterInitializerError(p.AwaitExpressionFormalParameter, { at: r }), this.eat(55) && this.raise(p.ObsoleteAwaitStar, { at: r }), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (r.argument = this.parseMaybeUnary(null, true)), this.finishNode(r, "AwaitExpression");
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak())
        return true;
      let { type: t } = this.state;
      return t === 53 || t === 10 || t === 0 || ct2(t) || t === 101 && !this.state.containsEsc || t === 135 || t === 56 || this.hasPlugin("v8intrinsic") && t === 54;
    }
    parseYield() {
      let t = this.startNode();
      this.expressionScope.recordParameterInitializerError(p.YieldInParameter, { at: t }), this.next();
      let r = false, e = null;
      if (!this.hasPrecedingLineBreak())
        switch (r = this.eat(55), this.state.type) {
          case 13:
          case 137:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!r)
              break;
          default:
            e = this.parseMaybeAssign();
        }
      return t.delegate = r, t.argument = e, this.finishNode(t, "YieldExpression");
    }
    checkPipelineAtInfixOperator(t, r) {
      this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && t.type === "SequenceExpression" && this.raise(p.PipelineHeadSequenceExpression, { at: r });
    }
    parseSmartPipelineBodyInStyle(t, r) {
      if (this.isSimpleReference(t)) {
        let e = this.startNodeAt(r);
        return e.callee = t, this.finishNode(e, "PipelineBareFunction");
      } else {
        let e = this.startNodeAt(r);
        return this.checkSmartPipeTopicBodyEarlyErrors(r), e.expression = t, this.finishNode(e, "PipelineTopicExpression");
      }
    }
    isSimpleReference(t) {
      switch (t.type) {
        case "MemberExpression":
          return !t.computed && this.isSimpleReference(t.object);
        case "Identifier":
          return true;
        default:
          return false;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(t) {
      if (this.match(19))
        throw this.raise(p.PipelineBodyNoArrow, { at: this.state.startLoc });
      this.topicReferenceWasUsedInCurrentContext() || this.raise(p.PipelineTopicUnused, { at: t });
    }
    withTopicBindingContext(t) {
      let r = this.state.topicContext;
      this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
      try {
        return t();
      } finally {
        this.state.topicContext = r;
      }
    }
    withSmartMixTopicForbiddingContext(t) {
      if (this.hasPlugin(["pipelineOperator", { proposal: "smart" }])) {
        let r = this.state.topicContext;
        this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
        try {
          return t();
        } finally {
          this.state.topicContext = r;
        }
      } else
        return t();
    }
    withSoloAwaitPermittingContext(t) {
      let r = this.state.soloAwait;
      this.state.soloAwait = true;
      try {
        return t();
      } finally {
        this.state.soloAwait = r;
      }
    }
    allowInAnd(t) {
      let r = this.prodParam.currentFlags();
      if (Ve2 & ~r) {
        this.prodParam.enter(r | Ve2);
        try {
          return t();
        } finally {
          this.prodParam.exit();
        }
      }
      return t();
    }
    disallowInAnd(t) {
      let r = this.prodParam.currentFlags();
      if (Ve2 & r) {
        this.prodParam.enter(r & ~Ve2);
        try {
          return t();
        } finally {
          this.prodParam.exit();
        }
      }
      return t();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(t) {
      let r = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      let e = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = true;
      let s = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, t);
      return this.state.inFSharpPipelineDirectBody = e, s;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      let t = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      let r = this.startNodeAt(this.state.endLoc);
      this.next();
      let e = this.initializeScopes(true);
      this.enterInitialScopes();
      try {
        t.body = this.parseProgram(r, 8, "module");
      } finally {
        e();
      }
      return this.finishNode(t, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(t) {
    }
  }, xs2 = { kind: "loop" }, nh = { kind: "switch" }, oh = /[\uD800-\uDFFF]/u, gs2 = /in(?:stanceof)?/y;
  function lh(t, r) {
    for (let e = 0; e < t.length; e++) {
      let s = t[e], { type: i } = s;
      if (typeof i == "number") {
        {
          if (i === 136) {
            let { loc: a, start: n, value: o, end: u } = s, c = n + 1, y2 = re(a.start, 1);
            t.splice(e, 1, new Se2({ type: xe2(27), value: "#", start: n, end: c, startLoc: a.start, endLoc: y2 }), new Se2({ type: xe2(130), value: o, start: c, end: u, startLoc: y2, endLoc: a.end })), e++;
            continue;
          }
          if (ct2(i)) {
            let { loc: a, start: n, value: o, end: u } = s, c = n + 1, y2 = re(a.start, 1), g2;
            r.charCodeAt(n) === 96 ? g2 = new Se2({ type: xe2(22), value: "`", start: n, end: c, startLoc: a.start, endLoc: y2 }) : g2 = new Se2({ type: xe2(8), value: "}", start: n, end: c, startLoc: a.start, endLoc: y2 });
            let T, C, j, q;
            i === 24 ? (C = u - 1, j = re(a.end, -1), T = o === null ? null : o.slice(1, -1), q = new Se2({ type: xe2(22), value: "`", start: C, end: u, startLoc: j, endLoc: a.end })) : (C = u - 2, j = re(a.end, -2), T = o === null ? null : o.slice(1, -2), q = new Se2({ type: xe2(23), value: "${", start: C, end: u, startLoc: j, endLoc: a.end })), t.splice(e, 1, g2, new Se2({ type: xe2(20), value: T, start: c, end: C, startLoc: y2, endLoc: j }), q), e += 2;
            continue;
          }
        }
        s.type = xe2(i);
      }
    }
    return t;
  }
  var hh = class extends ah {
    parseTopLevel(t, r) {
      return t.program = this.parseProgram(r), t.comments = this.state.comments, this.options.tokens && (t.tokens = lh(this.tokens, this.input)), this.finishNode(t, "File");
    }
    parseProgram(t) {
      let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 137, e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.options.sourceType;
      if (t.sourceType = e, t.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t, true, true, r), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
        for (let [i, a] of Array.from(this.scope.undefinedExports))
          this.raise(p.ModuleExportUndefined, { at: a, localName: i });
      let s;
      return r === 137 ? s = this.finishNode(t, "Program") : s = this.finishNodeAt(t, "Program", re(this.state.startLoc, -1)), s;
    }
    stmtToDirective(t) {
      let r = t;
      r.type = "Directive", r.value = r.expression, delete r.expression;
      let e = r.value, s = e.value, i = this.input.slice(e.start, e.end), a = e.value = i.slice(1, -1);
      return this.addExtra(e, "raw", i), this.addExtra(e, "rawValue", a), this.addExtra(e, "expressionValue", s), e.type = "DirectiveLiteral", r;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      let t = this.startNode();
      return t.value = this.state.value, this.next(), this.finishNode(t, "InterpreterDirective");
    }
    isLet() {
      return this.isContextual(99) ? this.hasFollowingBindingAtom() : false;
    }
    chStartsBindingIdentifier(t, r) {
      if (Pe2(t)) {
        if (gs2.lastIndex = r, gs2.test(this.input)) {
          let e = this.codePointAtPos(gs2.lastIndex);
          if (!je2(e) && e !== 92)
            return false;
        }
        return true;
      } else
        return t === 92;
    }
    chStartsBindingPattern(t) {
      return t === 91 || t === 123;
    }
    hasFollowingBindingAtom() {
      let t = this.nextTokenStart(), r = this.codePointAtPos(t);
      return this.chStartsBindingPattern(r) || this.chStartsBindingIdentifier(r, t);
    }
    hasFollowingBindingIdentifier() {
      let t = this.nextTokenStart(), r = this.codePointAtPos(t);
      return this.chStartsBindingIdentifier(r, t);
    }
    startsUsingForOf() {
      let t = this.lookahead();
      return t.type === 101 && !t.containsEsc ? false : (this.expectPlugin("explicitResourceManagement"), true);
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration() {
      let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, r = 0;
      return this.options.annexB && !this.state.strict && (r |= 4, t && (r |= 8)), this.parseStatementLike(r);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(t) {
      let r = null;
      return this.match(26) && (r = this.parseDecorators(true)), this.parseStatementContent(t, r);
    }
    parseStatementContent(t, r) {
      let e = this.state.type, s = this.startNode(), i = !!(t & 2), a = !!(t & 4), n = t & 1;
      switch (e) {
        case 60:
          return this.parseBreakContinueStatement(s, true);
        case 63:
          return this.parseBreakContinueStatement(s, false);
        case 64:
          return this.parseDebuggerStatement(s);
        case 90:
          return this.parseDoWhileStatement(s);
        case 91:
          return this.parseForStatement(s);
        case 68:
          if (this.lookaheadCharCode() === 46)
            break;
          return a || this.raise(this.state.strict ? p.StrictFunction : this.options.annexB ? p.SloppyFunctionAnnexB : p.SloppyFunction, { at: this.state.startLoc }), this.parseFunctionStatement(s, false, !i && a);
        case 80:
          return i || this.unexpected(), this.parseClass(this.maybeTakeDecorators(r, s), true);
        case 69:
          return this.parseIfStatement(s);
        case 70:
          return this.parseReturnStatement(s);
        case 71:
          return this.parseSwitchStatement(s);
        case 72:
          return this.parseThrowStatement(s);
        case 73:
          return this.parseTryStatement(s);
        case 105:
          if (this.hasFollowingLineBreak() || this.state.containsEsc || !this.hasFollowingBindingIdentifier())
            break;
          return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(p.UnexpectedUsingDeclaration, { at: this.state.startLoc }) : i || this.raise(p.UnexpectedLexicalDeclaration, { at: this.state.startLoc }), this.parseVarStatement(s, "using");
        case 99: {
          if (this.state.containsEsc)
            break;
          let c = this.nextTokenStart(), y2 = this.codePointAtPos(c);
          if (y2 !== 91 && (!i && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(y2, c) && y2 !== 123))
            break;
        }
        case 75:
          i || this.raise(p.UnexpectedLexicalDeclaration, { at: this.state.startLoc });
        case 74: {
          let c = this.state.value;
          return this.parseVarStatement(s, c);
        }
        case 92:
          return this.parseWhileStatement(s);
        case 76:
          return this.parseWithStatement(s);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(s);
        case 83: {
          let c = this.lookaheadCharCode();
          if (c === 40 || c === 46)
            break;
        }
        case 82: {
          !this.options.allowImportExportEverywhere && !n && this.raise(p.UnexpectedImportExport, { at: this.state.startLoc }), this.next();
          let c;
          return e === 83 ? (c = this.parseImport(s), c.type === "ImportDeclaration" && (!c.importKind || c.importKind === "value") && (this.sawUnambiguousESM = true)) : (c = this.parseExport(s, r), (c.type === "ExportNamedDeclaration" && (!c.exportKind || c.exportKind === "value") || c.type === "ExportAllDeclaration" && (!c.exportKind || c.exportKind === "value") || c.type === "ExportDefaultDeclaration") && (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(c), c;
        }
        default:
          if (this.isAsyncFunction())
            return i || this.raise(p.AsyncFunctionInSingleStatementContext, { at: this.state.startLoc }), this.next(), this.parseFunctionStatement(s, true, !i && a);
      }
      let o = this.state.value, u = this.parseExpression();
      return R2(e) && u.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(s, o, u, t) : this.parseExpressionStatement(s, u, r);
    }
    assertModuleNodeAllowed(t) {
      !this.options.allowImportExportEverywhere && !this.inModule && this.raise(p.ImportOutsideModule, { at: t });
    }
    decoratorsEnabledBeforeExport() {
      return this.hasPlugin("decorators-legacy") ? true : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
    }
    maybeTakeDecorators(t, r, e) {
      return t && (r.decorators && r.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(p.DecoratorsBeforeAfterExport, { at: r.decorators[0] }), r.decorators.unshift(...t)) : r.decorators = t, this.resetStartLocationFromNode(r, t[0]), e && this.resetStartLocationFromNode(e, r)), r;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(t) {
      let r = [];
      do
        r.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82))
        t || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(p.DecoratorExportClass, { at: this.state.startLoc });
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(p.UnexpectedLeadingDecorator, { at: this.state.startLoc });
      return r;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      let t = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        let r = this.state.startLoc, e;
        if (this.match(10)) {
          let s = this.state.startLoc;
          this.next(), e = this.parseExpression(), this.expect(11), e = this.wrapParenthesis(s, e);
          let i = this.state.startLoc;
          t.expression = this.parseMaybeDecoratorArguments(e), this.getPluginOption("decorators", "allowCallParenthesized") === false && t.expression !== e && this.raise(p.DecoratorArgumentsOutsideParentheses, { at: i });
        } else {
          for (e = this.parseIdentifier(false); this.eat(16); ) {
            let s = this.startNodeAt(r);
            s.object = e, this.match(136) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), s.property = this.parsePrivateName()) : s.property = this.parseIdentifier(true), s.computed = false, e = this.finishNode(s, "MemberExpression");
          }
          t.expression = this.parseMaybeDecoratorArguments(e);
        }
      } else
        t.expression = this.parseExprSubscripts();
      return this.finishNode(t, "Decorator");
    }
    parseMaybeDecoratorArguments(t) {
      if (this.eat(10)) {
        let r = this.startNodeAtNode(t);
        return r.callee = t, r.arguments = this.parseCallExpressionArguments(11, false), this.toReferencedList(r.arguments), this.finishNode(r, "CallExpression");
      }
      return t;
    }
    parseBreakContinueStatement(t, r) {
      return this.next(), this.isLineTerminator() ? t.label = null : (t.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(t, r), this.finishNode(t, r ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(t, r) {
      let e;
      for (e = 0; e < this.state.labels.length; ++e) {
        let s = this.state.labels[e];
        if ((t.label == null || s.name === t.label.name) && (s.kind != null && (r || s.kind === "loop") || t.label && r))
          break;
      }
      if (e === this.state.labels.length) {
        let s = r ? "BreakStatement" : "ContinueStatement";
        this.raise(p.IllegalBreakContinue, { at: t, type: s });
      }
    }
    parseDebuggerStatement(t) {
      return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      let t = this.parseExpression();
      return this.expect(11), t;
    }
    parseDoWhileStatement(t) {
      return this.next(), this.state.labels.push(xs2), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), t.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(t, "DoWhileStatement");
    }
    parseForStatement(t) {
      this.next(), this.state.labels.push(xs2);
      let r = null;
      if (this.isAwaitAllowed() && this.eatContextual(96) && (r = this.state.lastTokStartLoc), this.scope.enter(qe2), this.expect(10), this.match(13))
        return r !== null && this.unexpected(r), this.parseFor(t, null);
      let e = this.isContextual(99), s = this.isContextual(105) && !this.hasFollowingLineBreak(), i = e && this.hasFollowingBindingAtom() || s && this.hasFollowingBindingIdentifier() && this.startsUsingForOf();
      if (this.match(74) || this.match(75) || i) {
        let c = this.startNode(), y2 = this.state.value;
        this.next(), this.parseVar(c, true, y2);
        let g2 = this.finishNode(c, "VariableDeclaration"), T = this.match(58);
        return T && s && this.raise(p.ForInUsing, { at: g2 }), (T || this.isContextual(101)) && g2.declarations.length === 1 ? this.parseForIn(t, g2, r) : (r !== null && this.unexpected(r), this.parseFor(t, g2));
      }
      let a = this.isContextual(95), n = new wt2(), o = this.parseExpression(true, n), u = this.isContextual(101);
      if (u && (e && this.raise(p.ForOfLet, { at: o }), r === null && a && o.type === "Identifier" && this.raise(p.ForOfAsync, { at: o })), u || this.match(58)) {
        this.checkDestructuringPrivate(n), this.toAssignable(o, true);
        let c = u ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(o, { in: { type: c } }), this.parseForIn(t, o, r);
      } else
        this.checkExpressionErrors(n, true);
      return r !== null && this.unexpected(r), this.parseFor(t, o);
    }
    parseFunctionStatement(t, r, e) {
      return this.next(), this.parseFunction(t, 1 | (e ? 2 : 0) | (r ? 8 : 0));
    }
    parseIfStatement(t) {
      return this.next(), t.test = this.parseHeaderExpression(), t.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), t.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(t, "IfStatement");
    }
    parseReturnStatement(t) {
      return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(p.IllegalReturn, { at: this.state.startLoc }), this.next(), this.isLineTerminator() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement");
    }
    parseSwitchStatement(t) {
      this.next(), t.discriminant = this.parseHeaderExpression();
      let r = t.cases = [];
      this.expect(5), this.state.labels.push(nh), this.scope.enter(qe2);
      let e;
      for (let s; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          let i = this.match(61);
          e && this.finishNode(e, "SwitchCase"), r.push(e = this.startNode()), e.consequent = [], this.next(), i ? e.test = this.parseExpression() : (s && this.raise(p.MultipleDefaultsInSwitch, { at: this.state.lastTokStartLoc }), s = true, e.test = null), this.expect(14);
        } else
          e ? e.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), e && this.finishNode(e, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t, "SwitchStatement");
    }
    parseThrowStatement(t) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(p.NewlineAfterThrow, { at: this.state.lastTokEndLoc }), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, "ThrowStatement");
    }
    parseCatchClauseParam() {
      let t = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && t.type === "Identifier" ? Er2 : 0), this.checkLVal(t, { in: { type: "CatchClause" }, binding: Qo2 }), t;
    }
    parseTryStatement(t) {
      if (this.next(), t.block = this.parseBlock(), t.handler = null, this.match(62)) {
        let r = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), r.param = this.parseCatchClauseParam(), this.expect(11)) : (r.param = null, this.scope.enter(qe2)), r.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), t.handler = this.finishNode(r, "CatchClause");
      }
      return t.finalizer = this.eat(67) ? this.parseBlock() : null, !t.handler && !t.finalizer && this.raise(p.NoCatchOrFinally, { at: t }), this.finishNode(t, "TryStatement");
    }
    parseVarStatement(t, r) {
      let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      return this.next(), this.parseVar(t, false, r, e), this.semicolon(), this.finishNode(t, "VariableDeclaration");
    }
    parseWhileStatement(t) {
      return this.next(), t.test = this.parseHeaderExpression(), this.state.labels.push(xs2), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(t, "WhileStatement");
    }
    parseWithStatement(t) {
      return this.state.strict && this.raise(p.StrictWith, { at: this.state.startLoc }), this.next(), t.object = this.parseHeaderExpression(), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(t, "WithStatement");
    }
    parseEmptyStatement(t) {
      return this.next(), this.finishNode(t, "EmptyStatement");
    }
    parseLabeledStatement(t, r, e, s) {
      for (let a of this.state.labels)
        a.name === r && this.raise(p.LabelRedeclaration, { at: e, labelName: r });
      let i = oe(this.state.type) ? "loop" : this.match(71) ? "switch" : null;
      for (let a = this.state.labels.length - 1; a >= 0; a--) {
        let n = this.state.labels[a];
        if (n.statementStart === t.start)
          n.statementStart = this.state.start, n.kind = i;
        else
          break;
      }
      return this.state.labels.push({ name: r, kind: i, statementStart: this.state.start }), t.body = s & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement(), this.state.labels.pop(), t.label = e, this.finishNode(t, "LabeledStatement");
    }
    parseExpressionStatement(t, r, e) {
      return t.expression = r, this.semicolon(), this.finishNode(t, "ExpressionStatement");
    }
    parseBlock() {
      let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, e = arguments.length > 2 ? arguments[2] : void 0, s = this.startNode();
      return t && this.state.strictErrors.clear(), this.expect(5), r && this.scope.enter(qe2), this.parseBlockBody(s, t, false, 8, e), r && this.scope.exit(), this.finishNode(s, "BlockStatement");
    }
    isValidDirective(t) {
      return t.type === "ExpressionStatement" && t.expression.type === "StringLiteral" && !t.expression.extra.parenthesized;
    }
    parseBlockBody(t, r, e, s, i) {
      let a = t.body = [], n = t.directives = [];
      this.parseBlockOrModuleBlockBody(a, r ? n : void 0, e, s, i);
    }
    parseBlockOrModuleBlockBody(t, r, e, s, i) {
      let a = this.state.strict, n = false, o = false;
      for (; !this.match(s); ) {
        let u = e ? this.parseModuleItem() : this.parseStatementListItem();
        if (r && !o) {
          if (this.isValidDirective(u)) {
            let c = this.stmtToDirective(u);
            r.push(c), !n && c.value.value === "use strict" && (n = true, this.setStrict(true));
            continue;
          }
          o = true, this.state.strictErrors.clear();
        }
        t.push(u);
      }
      i && i.call(this, n), a || this.setStrict(false), this.next();
    }
    parseFor(t, r) {
      return t.init = r, this.semicolon(false), t.test = this.match(13) ? null : this.parseExpression(), this.semicolon(false), t.update = this.match(11) ? null : this.parseExpression(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, "ForStatement");
    }
    parseForIn(t, r, e) {
      let s = this.match(58);
      return this.next(), s ? e !== null && this.unexpected(e) : t.await = e !== null, r.type === "VariableDeclaration" && r.declarations[0].init != null && (!s || !this.options.annexB || this.state.strict || r.kind !== "var" || r.declarations[0].id.type !== "Identifier") && this.raise(p.ForInOfLoopInitializer, { at: r, type: s ? "ForInStatement" : "ForOfStatement" }), r.type === "AssignmentPattern" && this.raise(p.InvalidLhs, { at: r, ancestor: { type: "ForStatement" } }), t.left = r, t.right = s ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, s ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(t, r, e) {
      let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, i = t.declarations = [];
      for (t.kind = e; ; ) {
        let a = this.startNode();
        if (this.parseVarId(a, e), a.init = this.eat(29) ? r ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, a.init === null && !s && (a.id.type !== "Identifier" && !(r && (this.match(58) || this.isContextual(101))) ? this.raise(p.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: "destructuring" }) : e === "const" && !(this.match(58) || this.isContextual(101)) && this.raise(p.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: "const" })), i.push(this.finishNode(a, "VariableDeclarator")), !this.eat(12))
          break;
      }
      return t;
    }
    parseVarId(t, r) {
      r === "using" && !this.inModule && this.match(96) && this.raise(p.AwaitInUsingBinding, { at: this.state.startLoc });
      let e = this.parseBindingAtom();
      this.checkLVal(e, { in: { type: "VariableDeclarator" }, binding: r === "var" ? At2 : He2 }), t.id = e;
    }
    parseAsyncFunctionExpression(t) {
      return this.parseFunction(t, 8);
    }
    parseFunction(t) {
      let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, e = r & 2, s = !!(r & 1), i = s && !(r & 4), a = !!(r & 8);
      this.initFunction(t, a), this.match(55) && (e && this.raise(p.GeneratorInSingleStatementContext, { at: this.state.startLoc }), this.next(), t.generator = true), s && (t.id = this.parseFunctionId(i));
      let n = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = false, this.scope.enter(Ae2), this.prodParam.enter(St2(a, t.generator)), s || (t.id = this.parseFunctionId()), this.parseFunctionParams(t, false), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(t, s ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), s && !e && this.registerFunctionStatementId(t), this.state.maybeInArrowParameters = n, t;
    }
    parseFunctionId(t) {
      return t || R2(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(t, r) {
      this.expect(10), this.expressionScope.enter(wl2()), t.params = this.parseBindingList(11, 41, 2 | (r ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(t) {
      t.id && this.scope.declareName(t.id.name, !this.options.annexB || this.state.strict || t.generator || t.async ? this.scope.treatFunctionsAsVar ? At2 : He2 : Ir2, t.id.loc.start);
    }
    parseClass(t, r, e) {
      this.next();
      let s = this.state.strict;
      return this.state.strict = true, this.parseClassId(t, r, e), this.parseClassSuper(t), t.body = this.parseClassBody(!!t.superClass, s), this.finishNode(t, r ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    isNonstaticConstructor(t) {
      return !t.computed && !t.static && (t.key.name === "constructor" || t.key.value === "constructor");
    }
    parseClassBody(t, r) {
      this.classScope.enter();
      let e = { hadConstructor: false, hadSuperClass: t }, s = [], i = this.startNode();
      if (i.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (s.length > 0)
              throw this.raise(p.DecoratorSemicolon, { at: this.state.lastTokEndLoc });
            continue;
          }
          if (this.match(26)) {
            s.push(this.parseDecorator());
            continue;
          }
          let a = this.startNode();
          s.length && (a.decorators = s, this.resetStartLocationFromNode(a, s[0]), s = []), this.parseClassMember(i, a, e), a.kind === "constructor" && a.decorators && a.decorators.length > 0 && this.raise(p.DecoratorConstructor, { at: a });
        }
      }), this.state.strict = r, this.next(), s.length)
        throw this.raise(p.TrailingDecorator, { at: this.state.startLoc });
      return this.classScope.exit(), this.finishNode(i, "ClassBody");
    }
    parseClassMemberFromModifier(t, r) {
      let e = this.parseIdentifier(true);
      if (this.isClassMethod()) {
        let s = r;
        return s.kind = "method", s.computed = false, s.key = e, s.static = false, this.pushClassMethod(t, s, false, false, false, false), true;
      } else if (this.isClassProperty()) {
        let s = r;
        return s.computed = false, s.key = e, s.static = false, t.body.push(this.parseClassProperty(s)), true;
      }
      return this.resetPreviousNodeTrailingComments(e), false;
    }
    parseClassMember(t, r, e) {
      let s = this.isContextual(104);
      if (s) {
        if (this.parseClassMemberFromModifier(t, r))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(t, r);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(t, r, e, s);
    }
    parseClassMemberWithIsStatic(t, r, e, s) {
      let i = r, a = r, n = r, o = r, u = r, c = i, y2 = i;
      if (r.static = s, this.parsePropertyNamePrefixOperator(r), this.eat(55)) {
        c.kind = "method";
        let q = this.match(136);
        if (this.parseClassElementName(c), q) {
          this.pushClassPrivateMethod(t, a, true, false);
          return;
        }
        this.isNonstaticConstructor(i) && this.raise(p.ConstructorIsGenerator, { at: i.key }), this.pushClassMethod(t, i, true, false, false, false);
        return;
      }
      let g2 = R2(this.state.type) && !this.state.containsEsc, T = this.match(136), C = this.parseClassElementName(r), j = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(y2), this.isClassMethod()) {
        if (c.kind = "method", T) {
          this.pushClassPrivateMethod(t, a, false, false);
          return;
        }
        let q = this.isNonstaticConstructor(i), G = false;
        q && (i.kind = "constructor", e.hadConstructor && !this.hasPlugin("typescript") && this.raise(p.DuplicateConstructor, { at: C }), q && this.hasPlugin("typescript") && r.override && this.raise(p.OverrideOnConstructor, { at: C }), e.hadConstructor = true, G = e.hadSuperClass), this.pushClassMethod(t, i, false, false, q, G);
      } else if (this.isClassProperty())
        T ? this.pushClassPrivateProperty(t, o) : this.pushClassProperty(t, n);
      else if (g2 && C.name === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(C);
        let q = this.eat(55);
        y2.optional && this.unexpected(j), c.kind = "method";
        let G = this.match(136);
        this.parseClassElementName(c), this.parsePostMemberNameModifiers(y2), G ? this.pushClassPrivateMethod(t, a, q, true) : (this.isNonstaticConstructor(i) && this.raise(p.ConstructorIsAsync, { at: i.key }), this.pushClassMethod(t, i, q, true, false, false));
      } else if (g2 && (C.name === "get" || C.name === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(C), c.kind = C.name;
        let q = this.match(136);
        this.parseClassElementName(i), q ? this.pushClassPrivateMethod(t, a, false, false) : (this.isNonstaticConstructor(i) && this.raise(p.ConstructorIsAccessor, { at: i.key }), this.pushClassMethod(t, i, false, false, false, false)), this.checkGetterSetterParams(i);
      } else if (g2 && C.name === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(C);
        let q = this.match(136);
        this.parseClassElementName(n), this.pushClassAccessorProperty(t, u, q);
      } else
        this.isLineTerminator() ? T ? this.pushClassPrivateProperty(t, o) : this.pushClassProperty(t, n) : this.unexpected();
    }
    parseClassElementName(t) {
      let { type: r, value: e } = this.state;
      if ((r === 130 || r === 131) && t.static && e === "prototype" && this.raise(p.StaticPrototype, { at: this.state.startLoc }), r === 136) {
        e === "constructor" && this.raise(p.ConstructorClassPrivateField, { at: this.state.startLoc });
        let s = this.parsePrivateName();
        return t.key = s, s;
      }
      return this.parsePropertyName(t);
    }
    parseClassStaticBlock(t, r) {
      var e;
      this.scope.enter(Ne2 | mt2 | dt2);
      let s = this.state.labels;
      this.state.labels = [], this.prodParam.enter(ze);
      let i = r.body = [];
      this.parseBlockOrModuleBlockBody(i, void 0, false, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = s, t.body.push(this.finishNode(r, "StaticBlock")), (e = r.decorators) != null && e.length && this.raise(p.DecoratorStaticBlock, { at: r });
    }
    pushClassProperty(t, r) {
      !r.computed && (r.key.name === "constructor" || r.key.value === "constructor") && this.raise(p.ConstructorClassField, { at: r.key }), t.body.push(this.parseClassProperty(r));
    }
    pushClassPrivateProperty(t, r) {
      let e = this.parseClassPrivateProperty(r);
      t.body.push(e), this.classScope.declarePrivateName(this.getPrivateNameSV(e.key), ls2, e.key.loc.start);
    }
    pushClassAccessorProperty(t, r, e) {
      if (!e && !r.computed) {
        let i = r.key;
        (i.name === "constructor" || i.value === "constructor") && this.raise(p.ConstructorClassField, { at: i });
      }
      let s = this.parseClassAccessorProperty(r);
      t.body.push(s), e && this.classScope.declarePrivateName(this.getPrivateNameSV(s.key), ls2, s.key.loc.start);
    }
    pushClassMethod(t, r, e, s, i, a) {
      t.body.push(this.parseMethod(r, e, s, i, a, "ClassMethod", true));
    }
    pushClassPrivateMethod(t, r, e, s) {
      let i = this.parseMethod(r, e, s, false, false, "ClassPrivateMethod", true);
      t.body.push(i);
      let a = i.kind === "get" ? i.static ? al2 : ol2 : i.kind === "set" ? i.static ? nl2 : ll2 : ls2;
      this.declareClassPrivateMethodInScope(i, a);
    }
    declareClassPrivateMethodInScope(t, r) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(t.key), r, t.key.loc.start);
    }
    parsePostMemberNameModifiers(t) {
    }
    parseClassPrivateProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassPrivateProperty");
    }
    parseClassProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassProperty");
    }
    parseClassAccessorProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassAccessorProperty");
    }
    parseInitializer(t) {
      this.scope.enter(Ne2 | dt2), this.expressionScope.enter($r2()), this.prodParam.enter(ze), t.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(t, r, e) {
      let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : wr2;
      if (R2(this.state.type))
        t.id = this.parseIdentifier(), r && this.declareNameFromIdentifier(t.id, s);
      else if (e || !r)
        t.id = null;
      else
        throw this.raise(p.MissingClassName, { at: this.state.startLoc });
    }
    parseClassSuper(t) {
      t.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(t, r) {
      let e = this.maybeParseExportDefaultSpecifier(t), s = !e || this.eat(12), i = s && this.eatExportStar(t), a = i && this.maybeParseExportNamespaceSpecifier(t), n = s && (!a || this.eat(12)), o = e || i;
      if (i && !a) {
        if (e && this.unexpected(), r)
          throw this.raise(p.UnsupportedDecoratorExport, { at: t });
        return this.parseExportFrom(t, true), this.finishNode(t, "ExportAllDeclaration");
      }
      let u = this.maybeParseExportNamedSpecifiers(t);
      e && s && !i && !u && this.unexpected(null, 5), a && n && this.unexpected(null, 97);
      let c;
      if (o || u) {
        if (c = false, r)
          throw this.raise(p.UnsupportedDecoratorExport, { at: t });
        this.parseExportFrom(t, o);
      } else
        c = this.maybeParseExportDeclaration(t);
      if (o || u || c) {
        var y2;
        let g2 = t;
        if (this.checkExport(g2, true, false, !!g2.source), ((y2 = g2.declaration) == null ? void 0 : y2.type) === "ClassDeclaration")
          this.maybeTakeDecorators(r, g2.declaration, g2);
        else if (r)
          throw this.raise(p.UnsupportedDecoratorExport, { at: t });
        return this.finishNode(g2, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        let g2 = t, T = this.parseExportDefaultExpression();
        if (g2.declaration = T, T.type === "ClassDeclaration")
          this.maybeTakeDecorators(r, T, g2);
        else if (r)
          throw this.raise(p.UnsupportedDecoratorExport, { at: t });
        return this.checkExport(g2, true, true), this.finishNode(g2, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(t) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(t) {
      if (this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom");
        let r = this.startNode();
        return r.exported = this.parseIdentifier(true), t.specifiers = [this.finishNode(r, "ExportDefaultSpecifier")], true;
      }
      return false;
    }
    maybeParseExportNamespaceSpecifier(t) {
      if (this.isContextual(93)) {
        t.specifiers || (t.specifiers = []);
        let r = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), r.exported = this.parseModuleExportName(), t.specifiers.push(this.finishNode(r, "ExportNamespaceSpecifier")), true;
      }
      return false;
    }
    maybeParseExportNamedSpecifiers(t) {
      if (this.match(5)) {
        t.specifiers || (t.specifiers = []);
        let r = t.exportKind === "type";
        return t.specifiers.push(...this.parseExportSpecifiers(r)), t.source = null, t.declaration = null, this.hasPlugin("importAssertions") && (t.assertions = []), true;
      }
      return false;
    }
    maybeParseExportDeclaration(t) {
      return this.shouldParseExportDeclaration() ? (t.specifiers = [], t.source = null, this.hasPlugin("importAssertions") && (t.assertions = []), t.declaration = this.parseExportDeclaration(t), true) : false;
    }
    isAsyncFunction() {
      if (!this.isContextual(95))
        return false;
      let t = this.nextTokenStart();
      return !cs2.test(this.input.slice(this.state.pos, t)) && this.isUnparsedContextual(t, "function");
    }
    parseExportDefaultExpression() {
      let t = this.startNode();
      if (this.match(68))
        return this.next(), this.parseFunction(t, 5);
      if (this.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(t, 13);
      if (this.match(80))
        return this.parseClass(t, true, true);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true && this.raise(p.DecoratorBeforeExport, { at: this.state.startLoc }), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(p.UnsupportedDefaultExport, { at: this.state.startLoc });
      let r = this.parseMaybeAssignAllowIn();
      return this.semicolon(), r;
    }
    parseExportDeclaration(t) {
      return this.match(80) ? this.parseClass(this.startNode(), true, false) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      let { type: t } = this.state;
      if (R2(t)) {
        if (t === 95 && !this.state.containsEsc || t === 99)
          return false;
        if ((t === 128 || t === 127) && !this.state.containsEsc) {
          let { type: s } = this.lookahead();
          if (R2(s) && s !== 97 || s === 5)
            return this.expectOnePlugin(["flow", "typescript"]), false;
        }
      } else if (!this.match(65))
        return false;
      let r = this.nextTokenStart(), e = this.isUnparsedContextual(r, "from");
      if (this.input.charCodeAt(r) === 44 || R2(this.state.type) && e)
        return true;
      if (this.match(65) && e) {
        let s = this.input.charCodeAt(this.nextTokenStartSince(r + 4));
        return s === 34 || s === 39;
      }
      return false;
    }
    parseExportFrom(t, r) {
      if (this.eatContextual(97)) {
        t.source = this.parseImportSource(), this.checkExport(t);
        let e = this.maybeParseImportAssertions();
        e && (t.assertions = e, this.checkJSONModuleImport(t));
      } else
        r && this.unexpected();
      this.semicolon();
    }
    shouldParseExportDeclaration() {
      let { type: t } = this.state;
      return t === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === true && this.raise(p.DecoratorBeforeExport, { at: this.state.startLoc }), true) : t === 74 || t === 75 || t === 68 || t === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(t, r, e, s) {
      if (r) {
        if (e) {
          if (this.checkDuplicateExports(t, "default"), this.hasPlugin("exportDefaultFrom")) {
            var i;
            let a = t.declaration;
            a.type === "Identifier" && a.name === "from" && a.end - a.start === 4 && !((i = a.extra) != null && i.parenthesized) && this.raise(p.ExportDefaultFromAsIdentifier, { at: a });
          }
        } else if (t.specifiers && t.specifiers.length)
          for (let a of t.specifiers) {
            let { exported: n } = a, o = n.type === "Identifier" ? n.name : n.value;
            if (this.checkDuplicateExports(a, o), !s && a.local) {
              let { local: u } = a;
              u.type !== "Identifier" ? this.raise(p.ExportBindingIsString, { at: a, localName: u.value, exportName: o }) : (this.checkReservedWord(u.name, u.loc.start, true, false), this.scope.checkLocalExport(u));
            }
          }
        else if (t.declaration) {
          if (t.declaration.type === "FunctionDeclaration" || t.declaration.type === "ClassDeclaration") {
            let a = t.declaration.id;
            if (!a)
              throw new Error("Assertion failure");
            this.checkDuplicateExports(t, a.name);
          } else if (t.declaration.type === "VariableDeclaration")
            for (let a of t.declaration.declarations)
              this.checkDeclaration(a.id);
        }
      }
    }
    checkDeclaration(t) {
      if (t.type === "Identifier")
        this.checkDuplicateExports(t, t.name);
      else if (t.type === "ObjectPattern")
        for (let r of t.properties)
          this.checkDeclaration(r);
      else if (t.type === "ArrayPattern")
        for (let r of t.elements)
          r && this.checkDeclaration(r);
      else
        t.type === "ObjectProperty" ? this.checkDeclaration(t.value) : t.type === "RestElement" ? this.checkDeclaration(t.argument) : t.type === "AssignmentPattern" && this.checkDeclaration(t.left);
    }
    checkDuplicateExports(t, r) {
      this.exportedIdentifiers.has(r) && (r === "default" ? this.raise(p.DuplicateDefaultExport, { at: t }) : this.raise(p.DuplicateExport, { at: t, exportName: r })), this.exportedIdentifiers.add(r);
    }
    parseExportSpecifiers(t) {
      let r = [], e = true;
      for (this.expect(5); !this.eat(8); ) {
        if (e)
          e = false;
        else if (this.expect(12), this.eat(8))
          break;
        let s = this.isContextual(128), i = this.match(131), a = this.startNode();
        a.local = this.parseModuleExportName(), r.push(this.parseExportSpecifier(a, i, t, s));
      }
      return r;
    }
    parseExportSpecifier(t, r, e, s) {
      return this.eatContextual(93) ? t.exported = this.parseModuleExportName() : r ? t.exported = Ll2(t.local) : t.exported || (t.exported = Te2(t.local)), this.finishNode(t, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(131)) {
        let t = this.parseStringLiteral(this.state.value), r = t.value.match(oh);
        return r && this.raise(p.ModuleExportNameHasLoneSurrogate, { at: t, surrogateCharCode: r[0].charCodeAt(0) }), t;
      }
      return this.parseIdentifier(true);
    }
    isJSONModuleImport(t) {
      return t.assertions != null ? t.assertions.some((r) => {
        let { key: e, value: s } = r;
        return s.value === "json" && (e.type === "Identifier" ? e.name === "type" : e.value === "type");
      }) : false;
    }
    checkImportReflection(t) {
      if (t.module) {
        var r;
        (t.specifiers.length !== 1 || t.specifiers[0].type !== "ImportDefaultSpecifier") && this.raise(p.ImportReflectionNotBinding, { at: t.specifiers[0].loc.start }), ((r = t.assertions) == null ? void 0 : r.length) > 0 && this.raise(p.ImportReflectionHasAssertion, { at: t.specifiers[0].loc.start });
      }
    }
    checkJSONModuleImport(t) {
      if (this.isJSONModuleImport(t) && t.type !== "ExportAllDeclaration") {
        let { specifiers: r } = t;
        if (r != null) {
          let e = r.find((s) => {
            let i;
            if (s.type === "ExportSpecifier" ? i = s.local : s.type === "ImportSpecifier" && (i = s.imported), i !== void 0)
              return i.type === "Identifier" ? i.name !== "default" : i.value !== "default";
          });
          e !== void 0 && this.raise(p.ImportJSONBindingNotDefault, { at: e.loc.start });
        }
      }
    }
    parseMaybeImportReflection(t) {
      let r = false;
      if (this.isContextual(125)) {
        let e = this.lookahead(), s = e.type;
        R2(s) ? (s !== 97 || this.input.charCodeAt(this.nextTokenStartSince(e.end)) === 102) && (r = true) : s !== 12 && (r = true);
      }
      r ? (this.expectPlugin("importReflection"), this.next(), t.module = true) : this.hasPlugin("importReflection") && (t.module = false);
    }
    parseImport(t) {
      if (t.specifiers = [], !this.match(131)) {
        this.parseMaybeImportReflection(t);
        let s = !this.maybeParseDefaultImportSpecifier(t) || this.eat(12), i = s && this.maybeParseStarImportSpecifier(t);
        s && !i && this.parseNamedImportSpecifiers(t), this.expectContextual(97);
      }
      t.source = this.parseImportSource();
      let r = this.maybeParseImportAssertions();
      if (r)
        t.assertions = r;
      else {
        let e = this.maybeParseModuleAttributes();
        e && (t.attributes = e);
      }
      return this.checkImportReflection(t), this.checkJSONModuleImport(t), this.semicolon(), this.finishNode(t, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(131) || this.unexpected(), this.parseExprAtom();
    }
    shouldParseDefaultImport(t) {
      return R2(this.state.type);
    }
    parseImportSpecifierLocal(t, r, e) {
      r.local = this.parseIdentifier(), t.specifiers.push(this.finishImportSpecifier(r, e));
    }
    finishImportSpecifier(t, r) {
      let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : He2;
      return this.checkLVal(t.local, { in: { type: r }, binding: e }), this.finishNode(t, r);
    }
    parseAssertEntries() {
      let t = [], r = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        let e = this.startNode(), s = this.state.value;
        if (r.has(s) && this.raise(p.ModuleAttributesWithDuplicateKeys, { at: this.state.startLoc, key: s }), r.add(s), this.match(131) ? e.key = this.parseStringLiteral(s) : e.key = this.parseIdentifier(true), this.expect(14), !this.match(131))
          throw this.raise(p.ModuleAttributeInvalidValue, { at: this.state.startLoc });
        e.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(e, "ImportAttribute"));
      } while (this.eat(12));
      return t;
    }
    maybeParseModuleAttributes() {
      if (this.match(76) && !this.hasPrecedingLineBreak())
        this.expectPlugin("moduleAttributes"), this.next();
      else
        return this.hasPlugin("moduleAttributes") ? [] : null;
      let t = [], r = /* @__PURE__ */ new Set();
      do {
        let e = this.startNode();
        if (e.key = this.parseIdentifier(true), e.key.name !== "type" && this.raise(p.ModuleAttributeDifferentFromType, { at: e.key }), r.has(e.key.name) && this.raise(p.ModuleAttributesWithDuplicateKeys, { at: e.key, key: e.key.name }), r.add(e.key.name), this.expect(14), !this.match(131))
          throw this.raise(p.ModuleAttributeInvalidValue, { at: this.state.startLoc });
        e.value = this.parseStringLiteral(this.state.value), this.finishNode(e, "ImportAttribute"), t.push(e);
      } while (this.eat(12));
      return t;
    }
    maybeParseImportAssertions() {
      if (this.isContextual(94) && !this.hasPrecedingLineBreak())
        this.expectPlugin("importAssertions"), this.next();
      else
        return this.hasPlugin("importAssertions") ? [] : null;
      this.eat(5);
      let t = this.parseAssertEntries();
      return this.eat(8), t;
    }
    maybeParseDefaultImportSpecifier(t) {
      return this.shouldParseDefaultImport(t) ? (this.parseImportSpecifierLocal(t, this.startNode(), "ImportDefaultSpecifier"), true) : false;
    }
    maybeParseStarImportSpecifier(t) {
      if (this.match(55)) {
        let r = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(t, r, "ImportNamespaceSpecifier"), true;
      }
      return false;
    }
    parseNamedImportSpecifiers(t) {
      let r = true;
      for (this.expect(5); !this.eat(8); ) {
        if (r)
          r = false;
        else {
          if (this.eat(14))
            throw this.raise(p.DestructureNamedImport, { at: this.state.startLoc });
          if (this.expect(12), this.eat(8))
            break;
        }
        let e = this.startNode(), s = this.match(131), i = this.isContextual(128);
        e.imported = this.parseModuleExportName();
        let a = this.parseImportSpecifier(e, s, t.importKind === "type" || t.importKind === "typeof", i, void 0);
        t.specifiers.push(a);
      }
    }
    parseImportSpecifier(t, r, e, s, i) {
      if (this.eatContextual(93))
        t.local = this.parseIdentifier();
      else {
        let { imported: a } = t;
        if (r)
          throw this.raise(p.ImportBindingIsString, { at: t, importName: a.value });
        this.checkReservedWord(a.name, t.loc.start, true, true), t.local || (t.local = Te2(a));
      }
      return this.finishImportSpecifier(t, "ImportSpecifier", i);
    }
    isThisParam(t) {
      return t.type === "Identifier" && t.name === "this";
    }
  }, si = class extends hh {
    constructor(t, r) {
      t = f(t), super(t, r), this.options = t, this.initializeScopes(), this.plugins = uh(this.options.plugins), this.filename = t.sourceFilename;
    }
    getScopeHandler() {
      return us2;
    }
    parse() {
      this.enterInitialScopes();
      let t = this.startNode(), r = this.startNode();
      return this.nextToken(), t.errors = null, this.parseTopLevel(t, r), t.errors = this.state.errors, t;
    }
  };
  function uh(t) {
    let r = /* @__PURE__ */ new Map();
    for (let e of t) {
      let [s, i] = Array.isArray(e) ? e : [e, {}];
      r.has(s) || r.set(s, i || {});
    }
    return r;
  }
  function ch(t, r) {
    var e;
    if (((e = r) == null ? void 0 : e.sourceType) === "unambiguous") {
      r = Object.assign({}, r);
      try {
        r.sourceType = "module";
        let s = tt(r, t), i = s.parse();
        if (s.sawUnambiguousESM)
          return i;
        if (s.ambiguousScriptDifferentAst)
          try {
            return r.sourceType = "script", tt(r, t).parse();
          } catch {
          }
        else
          i.program.sourceType = "script";
        return i;
      } catch (s) {
        try {
          return r.sourceType = "script", tt(r, t).parse();
        } catch {
        }
        throw s;
      }
    } else
      return tt(r, t).parse();
  }
  function ph(t, r) {
    let e = tt(r, t);
    return e.options.strictMode && (e.state.strict = true), e.getExpression();
  }
  function fh(t) {
    let r = {};
    for (let e of Object.keys(t))
      r[e] = xe2(t[e]);
    return r;
  }
  var dh = fh(te2);
  function tt(t, r) {
    let e = si;
    return t != null && t.plugins && (rh(t.plugins), e = mh(t.plugins)), new e(t, r);
  }
  var ri2 = {};
  function mh(t) {
    let r = ih.filter((i) => Q(t, i)), e = r.join("/"), s = ri2[e];
    if (!s) {
      s = si;
      for (let i of r)
        s = ti2[i](s);
      ri2[e] = s;
    }
    return s;
  }
  l.parse = ch, l.parseExpression = ph, l.tokTypes = dh;
} }), _f$1 = $({ "src/language-js/parse/json.js"(l, h) {
  U();
  var f = bo$1(), d2 = dr$2(), x = wo$1(), P = Io$1();
  function m() {
    let N2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, { allowComments: O = true } = N2;
    return function(_) {
      let { parseExpression: W } = No$1(), I2;
      try {
        I2 = W(_, { tokens: true, ranges: true });
      } catch (F) {
        throw P(F);
      }
      if (!O && f(I2.comments))
        throw E(I2.comments[0], "Comment");
      return S(I2), I2;
    };
  }
  function E(N2, O) {
    let [A, _] = [N2.loc.start, N2.loc.end].map((W) => {
      let { line: I2, column: F } = W;
      return { line: I2, column: F + 1 };
    });
    return d2(`${O} is not allowed in JSON.`, { start: A, end: _ });
  }
  function S(N2) {
    switch (N2.type) {
      case "ArrayExpression":
        for (let O of N2.elements)
          O !== null && S(O);
        return;
      case "ObjectExpression":
        for (let O of N2.properties)
          S(O);
        return;
      case "ObjectProperty":
        if (N2.computed)
          throw E(N2.key, "Computed key");
        if (N2.shorthand)
          throw E(N2.key, "Shorthand property");
        N2.key.type !== "Identifier" && S(N2.key), S(N2.value);
        return;
      case "UnaryExpression": {
        let { operator: O, argument: A } = N2;
        if (O !== "+" && O !== "-")
          throw E(N2, `Operator '${N2.operator}'`);
        if (A.type === "NumericLiteral" || A.type === "Identifier" && (A.name === "Infinity" || A.name === "NaN"))
          return;
        throw E(A, `Operator '${O}' before '${A.type}'`);
      }
      case "Identifier":
        if (N2.name !== "Infinity" && N2.name !== "NaN" && N2.name !== "undefined")
          throw E(N2, `Identifier '${N2.name}'`);
        return;
      case "TemplateLiteral":
        if (f(N2.expressions))
          throw E(N2.expressions[0], "'TemplateLiteral' with expression");
        for (let O of N2.quasis)
          S(O);
        return;
      case "NullLiteral":
      case "BooleanLiteral":
      case "NumericLiteral":
      case "StringLiteral":
      case "TemplateElement":
        return;
      default:
        throw E(N2, `'${N2.type}'`);
    }
  }
  var k = m(), L = { json: x({ parse: k, hasPragma() {
    return true;
  } }), json5: x(k), "json-stringify": x({ parse: m({ allowComments: false }), astFormat: "estree-json" }) };
  h.exports = L;
} }), Rf$1 = $({ "src/language-js/parse/babel.js"(l, h) {
  U();
  var f = xf$1(), d2 = ho$1(), x = Tf$1(), P = wo$1(), m = Io$1(), E = Mf$1(), S = _f$1(), k = { sourceType: "module", allowImportExportEverywhere: true, allowReturnOutsideFunction: true, allowSuperOutsideMethod: true, allowUndeclaredExports: true, errorRecovery: true, createParenthesizedExpressions: true, plugins: ["doExpressions", "exportDefaultFrom", "functionBind", "functionSent", "throwExpressions", "partialApplication", ["decorators", { decoratorsBeforeExport: false }], "importAssertions", "decimal", "moduleBlocks", "asyncDoExpressions", "regexpUnicodeSets", "destructuringPrivate", "decoratorAutoAccessors"], tokens: true, ranges: true }, L = ["recordAndTuple", { syntaxType: "hash" }], N2 = "v8intrinsic", O = [["pipelineOperator", { proposal: "hack", topicToken: "%" }], ["pipelineOperator", { proposal: "minimal" }], ["pipelineOperator", { proposal: "fsharp" }]], A = function(H) {
    let X = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : k;
    return Object.assign(Object.assign({}, X), {}, { plugins: [...X.plugins, ...H] });
  }, _ = /@(?:no)?flow\b/;
  function W(H, X) {
    if (X.filepath && X.filepath.endsWith(".js.flow"))
      return true;
    let ye2 = d2(H);
    ye2 && (H = H.slice(ye2.length));
    let ne2 = x(H, 0);
    return ne2 !== false && (H = H.slice(0, ne2)), _.test(H);
  }
  function I2(H, X, ye2) {
    let ne2 = No$1()[H], oe = ne2(X, ye2), Ee = oe.errors.find((le2) => !te2.has(le2.reasonCode));
    if (Ee)
      throw Ee;
    return oe;
  }
  function F(H) {
    for (var X = arguments.length, ye2 = new Array(X > 1 ? X - 1 : 0), ne2 = 1; ne2 < X; ne2++)
      ye2[ne2 - 1] = arguments[ne2];
    return function(oe, Ee) {
      let le2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if ((le2.parser === "babel" || le2.parser === "__babel_estree") && W(oe, le2))
        return le2.parser = "babel-flow", M2(oe, Ee, le2);
      let ue2 = ye2;
      le2.__babelSourceType === "script" && (ue2 = ue2.map((Y) => Object.assign(Object.assign({}, Y), {}, { sourceType: "script" }))), /#[[{]/.test(oe) && (ue2 = ue2.map((Y) => A([L], Y)));
      let ht2 = /%[A-Z]/.test(oe);
      oe.includes("|>") ? ue2 = (ht2 ? [...O, N2] : O).flatMap((Re2) => ue2.map((Gt2) => A([Re2], Gt2))) : ht2 && (ue2 = ue2.map((Y) => A([N2], Y)));
      let { result: ut2, error: Wt } = f(...ue2.map((Y) => () => I2(H, oe, Y)));
      if (!ut2)
        throw m(Wt);
      return le2.originalText = oe, E(ut2, le2);
    };
  }
  var z = F("parse", A(["jsx", "flow"])), M2 = F("parse", A(["jsx", ["flow", { all: true, enums: true }]])), V = F("parse", A(["jsx", "typescript"]), A(["typescript"])), ee2 = F("parse", A(["jsx", "flow", "estree"])), b = F("parseExpression", A(["jsx"])), B = F("parseExpression", A(["typescript"])), te2 = /* @__PURE__ */ new Set(["StrictNumericEscape", "StrictWith", "StrictOctalLiteral", "StrictDelete", "StrictEvalArguments", "StrictEvalArgumentsBinding", "StrictFunction", "EmptyTypeArguments", "EmptyTypeParameters", "ConstructorHasTypeParameters", "UnsupportedParameterPropertyKind", "UnexpectedParameterModifier", "MixedLabeledAndUnlabeledElements", "InvalidTupleMemberLabel", "NonClassMethodPropertyHasAbstractModifer", "ReadonlyForMethodSignature", "ClassMethodHasDeclare", "ClassMethodHasReadonly", "InvalidModifierOnTypeMember", "DuplicateAccessibilityModifier", "IndexSignatureHasDeclare", "DecoratorExportClass", "ParamDupe", "InvalidDecimal", "RestTrailingComma", "UnsupportedParameterDecorator", "UnterminatedJsxContent", "UnexpectedReservedWord", "ModuleAttributesWithDuplicateKeys", "LineTerminatorBeforeArrow", "InvalidEscapeSequenceTemplate", "NonAbstractClassHasAbstractMethod", "UnsupportedPropertyDecorator", "OptionalTypeBeforeRequired", "PatternIsOptional", "OptionalBindingPattern", "DeclareClassFieldHasInitializer", "TypeImportCannotSpecifyDefaultAndNamed", "DeclareFunctionHasImplementation", "ConstructorClassField", "VarRedeclaration", "InvalidPrivateFieldResolution", "DuplicateExport"]), R2 = P(z), ae2 = P(V), se2 = P(b), _e2 = P(B);
  h.exports = { parsers: Object.assign(Object.assign({ babel: R2, "babel-flow": P(M2), "babel-ts": ae2 }, S), {}, { __js_expression: se2, __vue_expression: se2, __vue_ts_expression: _e2, __vue_event_binding: R2, __vue_ts_event_binding: ae2, __babel_estree: P(ee2) }) };
} }), Tm = Rf$1();
var y = (e, r) => () => (r || e((r = { exports: {} }).exports, r), r.exports);
var ue = y((Gl2, Wr2) => {
  var qe2 = function(e) {
    return e && e.Math == Math && e;
  };
  Wr2.exports = qe2(typeof globalThis == "object" && globalThis) || qe2(typeof window == "object" && window) || qe2(typeof self == "object" && self) || qe2(typeof global == "object" && global) || function() {
    return this;
  }() || Function("return this")();
});
var ae$1 = y((Vl2, Yr2) => {
  Yr2.exports = function(e) {
    try {
      return !!e();
    } catch {
      return true;
    }
  };
});
var De$1 = y((Xl2, Qr) => {
  var vs2 = ae$1();
  Qr.exports = !vs2(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] != 7;
  });
});
var Ie$1 = y((Hl2, Kr2) => {
  var _s2 = ae$1();
  Kr2.exports = !_s2(function() {
    var e = (function() {
    }).bind();
    return typeof e != "function" || e.hasOwnProperty("prototype");
  });
});
var ce = y((zl2, Jr2) => {
  var Ss2 = Ie$1(), Re2 = Function.prototype.call;
  Jr2.exports = Ss2 ? Re2.bind(Re2) : function() {
    return Re2.apply(Re2, arguments);
  };
});
var uu = y((ru2) => {
  var Zr2 = {}.propertyIsEnumerable, eu2 = Object.getOwnPropertyDescriptor, ys2 = eu2 && !Zr2.call({ 1: 2 }, 1);
  ru2.f = ys2 ? function(r) {
    var u = eu2(this, r);
    return !!u && u.enumerable;
  } : Zr2;
});
var xe$1 = y((Yl2, tu2) => {
  tu2.exports = function(e, r) {
    return { enumerable: !(e & 1), configurable: !(e & 2), writable: !(e & 4), value: r };
  };
});
var te = y((Ql2, iu) => {
  var nu2 = Ie$1(), su = Function.prototype, rr2 = su.call, Ts2 = nu2 && su.bind.bind(rr2, rr2);
  iu.exports = nu2 ? Ts2 : function(e) {
    return function() {
      return rr2.apply(e, arguments);
    };
  };
});
var Ae$1 = y((Kl2, ou) => {
  var au = te(), Bs2 = au({}.toString), bs2 = au("".slice);
  ou.exports = function(e) {
    return bs2(Bs2(e), 8, -1);
  };
});
var lu = y((Jl2, Du) => {
  var ws2 = te(), Ns2 = ae$1(), Os2 = Ae$1(), ur2 = Object, qs2 = ws2("".split);
  Du.exports = Ns2(function() {
    return !ur2("z").propertyIsEnumerable(0);
  }) ? function(e) {
    return Os2(e) == "String" ? qs2(e, "") : ur2(e);
  } : ur2;
});
var Pe$1 = y((Zl2, cu) => {
  cu.exports = function(e) {
    return e == null;
  };
});
var tr = y((ec, hu) => {
  var Is2 = Pe$1(), Rs2 = TypeError;
  hu.exports = function(e) {
    if (Is2(e))
      throw Rs2("Can't call method on " + e);
    return e;
  };
});
var ke$1 = y((rc, pu) => {
  var xs2 = lu(), Ps2 = tr();
  pu.exports = function(e) {
    return xs2(Ps2(e));
  };
});
var sr = y((uc, fu) => {
  var nr2 = typeof document == "object" && document.all, ks2 = typeof nr2 > "u" && nr2 !== void 0;
  fu.exports = { all: nr2, IS_HTMLDDA: ks2 };
});
var ee = y((tc, Eu) => {
  var du = sr(), Ls2 = du.all;
  Eu.exports = du.IS_HTMLDDA ? function(e) {
    return typeof e == "function" || e === Ls2;
  } : function(e) {
    return typeof e == "function";
  };
});
var he$1 = y((nc, gu2) => {
  var Cu = ee(), mu = sr(), $s2 = mu.all;
  gu2.exports = mu.IS_HTMLDDA ? function(e) {
    return typeof e == "object" ? e !== null : Cu(e) || e === $s2;
  } : function(e) {
    return typeof e == "object" ? e !== null : Cu(e);
  };
});
var ve = y((sc, Fu) => {
  var ir2 = ue(), Ms2 = ee(), js2 = function(e) {
    return Ms2(e) ? e : void 0;
  };
  Fu.exports = function(e, r) {
    return arguments.length < 2 ? js2(ir2[e]) : ir2[e] && ir2[e][r];
  };
});
var ar = y((ic, Au) => {
  var Us2 = te();
  Au.exports = Us2({}.isPrototypeOf);
});
var _u = y((ac, vu) => {
  var Gs2 = ve();
  vu.exports = Gs2("navigator", "userAgent") || "";
});
var Nu = y((oc, wu) => {
  var bu = ue(), or2 = _u(), Su2 = bu.process, yu = bu.Deno, Tu = Su2 && Su2.versions || yu && yu.version, Bu = Tu && Tu.v8, ne2, Le;
  Bu && (ne2 = Bu.split("."), Le = ne2[0] > 0 && ne2[0] < 4 ? 1 : +(ne2[0] + ne2[1]));
  !Le && or2 && (ne2 = or2.match(/Edge\/(\d+)/), (!ne2 || ne2[1] >= 74) && (ne2 = or2.match(/Chrome\/(\d+)/), ne2 && (Le = +ne2[1])));
  wu.exports = Le;
});
var Dr = y((Dc, qu) => {
  var Ou = Nu(), Vs2 = ae$1();
  qu.exports = !!Object.getOwnPropertySymbols && !Vs2(function() {
    var e = Symbol();
    return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && Ou && Ou < 41;
  });
});
var lr = y((lc, Iu) => {
  var Xs2 = Dr();
  Iu.exports = Xs2 && !Symbol.sham && typeof Symbol.iterator == "symbol";
});
var cr = y((cc, Ru) => {
  var Hs2 = ve(), zs2 = ee(), Ws2 = ar(), Ys2 = lr(), Qs2 = Object;
  Ru.exports = Ys2 ? function(e) {
    return typeof e == "symbol";
  } : function(e) {
    var r = Hs2("Symbol");
    return zs2(r) && Ws2(r.prototype, Qs2(e));
  };
});
var $e$1 = y((hc, xu) => {
  var Ks2 = String;
  xu.exports = function(e) {
    try {
      return Ks2(e);
    } catch {
      return "Object";
    }
  };
});
var _e = y((pc, Pu) => {
  var Js2 = ee(), Zs2 = $e$1(), ei = TypeError;
  Pu.exports = function(e) {
    if (Js2(e))
      return e;
    throw ei(Zs2(e) + " is not a function");
  };
});
var Me$1 = y((fc, ku) => {
  var ri2 = _e(), ui2 = Pe$1();
  ku.exports = function(e, r) {
    var u = e[r];
    return ui2(u) ? void 0 : ri2(u);
  };
});
var $u = y((dc, Lu) => {
  var hr2 = ce(), pr2 = ee(), fr2 = he$1(), ti2 = TypeError;
  Lu.exports = function(e, r) {
    var u, n;
    if (r === "string" && pr2(u = e.toString) && !fr2(n = hr2(u, e)) || pr2(u = e.valueOf) && !fr2(n = hr2(u, e)) || r !== "string" && pr2(u = e.toString) && !fr2(n = hr2(u, e)))
      return n;
    throw ti2("Can't convert object to primitive value");
  };
});
var ju = y((Ec, Mu) => {
  Mu.exports = false;
});
var je = y((Cc, Gu) => {
  var Uu = ue(), ni = Object.defineProperty;
  Gu.exports = function(e, r) {
    try {
      ni(Uu, e, { value: r, configurable: true, writable: true });
    } catch {
      Uu[e] = r;
    }
    return r;
  };
});
var Ue$1 = y((mc, Xu) => {
  var si = ue(), ii = je(), Vu = "__core-js_shared__", ai = si[Vu] || ii(Vu, {});
  Xu.exports = ai;
});
var dr$1 = y((gc, zu) => {
  var oi2 = ju(), Hu2 = Ue$1();
  (zu.exports = function(e, r) {
    return Hu2[e] || (Hu2[e] = r !== void 0 ? r : {});
  })("versions", []).push({ version: "3.26.1", mode: oi2 ? "pure" : "global", copyright: "© 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE", source: "https://github.com/zloirock/core-js" });
});
var Er$1 = y((Fc, Wu) => {
  var Di2 = tr(), li = Object;
  Wu.exports = function(e) {
    return li(Di2(e));
  };
});
var le = y((Ac, Yu) => {
  var ci = te(), hi = Er$1(), pi2 = ci({}.hasOwnProperty);
  Yu.exports = Object.hasOwn || function(r, u) {
    return pi2(hi(r), u);
  };
});
var Cr$1 = y((vc, Qu) => {
  var fi2 = te(), di2 = 0, Ei = Math.random(), Ci = fi2(1 .toString);
  Qu.exports = function(e) {
    return "Symbol(" + (e === void 0 ? "" : e) + ")_" + Ci(++di2 + Ei, 36);
  };
});
var fe = y((_c2, rt2) => {
  var mi = ue(), gi = dr$1(), Ku = le(), Fi2 = Cr$1(), Ju = Dr(), et2 = lr(), Ce2 = gi("wks"), pe2 = mi.Symbol, Zu2 = pe2 && pe2.for, Ai2 = et2 ? pe2 : pe2 && pe2.withoutSetter || Fi2;
  rt2.exports = function(e) {
    if (!Ku(Ce2, e) || !(Ju || typeof Ce2[e] == "string")) {
      var r = "Symbol." + e;
      Ju && Ku(pe2, e) ? Ce2[e] = pe2[e] : et2 && Zu2 ? Ce2[e] = Zu2(r) : Ce2[e] = Ai2(r);
    }
    return Ce2[e];
  };
});
var st = y((Sc, nt) => {
  var vi2 = ce(), ut2 = he$1(), tt = cr(), _i2 = Me$1(), Si2 = $u(), yi2 = fe(), Ti2 = TypeError, Bi2 = yi2("toPrimitive");
  nt.exports = function(e, r) {
    if (!ut2(e) || tt(e))
      return e;
    var u = _i2(e, Bi2), n;
    if (u) {
      if (r === void 0 && (r = "default"), n = vi2(u, e, r), !ut2(n) || tt(n))
        return n;
      throw Ti2("Can't convert object to primitive value");
    }
    return r === void 0 && (r = "number"), Si2(e, r);
  };
});
var Ge$1 = y((yc, it2) => {
  var bi = st(), wi2 = cr();
  it2.exports = function(e) {
    var r = bi(e, "string");
    return wi2(r) ? r : r + "";
  };
});
var Dt = y((Tc, ot2) => {
  var Ni2 = ue(), at2 = he$1(), mr2 = Ni2.document, Oi2 = at2(mr2) && at2(mr2.createElement);
  ot2.exports = function(e) {
    return Oi2 ? mr2.createElement(e) : {};
  };
});
var gr$1 = y((Bc, lt2) => {
  var qi = De$1(), Ii2 = ae$1(), Ri = Dt();
  lt2.exports = !qi && !Ii2(function() {
    return Object.defineProperty(Ri("div"), "a", { get: function() {
      return 7;
    } }).a != 7;
  });
});
var Fr = y((ht2) => {
  var xi = De$1(), Pi = ce(), ki = uu(), Li2 = xe$1(), $i2 = ke$1(), Mi2 = Ge$1(), ji2 = le(), Ui2 = gr$1(), ct2 = Object.getOwnPropertyDescriptor;
  ht2.f = xi ? ct2 : function(r, u) {
    if (r = $i2(r), u = Mi2(u), Ui2)
      try {
        return ct2(r, u);
      } catch {
      }
    if (ji2(r, u))
      return Li2(!Pi(ki.f, r, u), r[u]);
  };
});
var ft$1 = y((wc, pt2) => {
  var Gi = De$1(), Vi2 = ae$1();
  pt2.exports = Gi && Vi2(function() {
    return Object.defineProperty(function() {
    }, "prototype", { value: 42, writable: false }).prototype != 42;
  });
});
var me$1 = y((Nc, dt2) => {
  var Xi2 = he$1(), Hi2 = String, zi2 = TypeError;
  dt2.exports = function(e) {
    if (Xi2(e))
      return e;
    throw zi2(Hi2(e) + " is not an object");
  };
});
var Se$1 = y((Ct2) => {
  var Wi2 = De$1(), Yi2 = gr$1(), Qi2 = ft$1(), Ve2 = me$1(), Et2 = Ge$1(), Ki = TypeError, Ar2 = Object.defineProperty, Ji2 = Object.getOwnPropertyDescriptor, vr2 = "enumerable", _r2 = "configurable", Sr2 = "writable";
  Ct2.f = Wi2 ? Qi2 ? function(r, u, n) {
    if (Ve2(r), u = Et2(u), Ve2(n), typeof r == "function" && u === "prototype" && "value" in n && Sr2 in n && !n[Sr2]) {
      var D = Ji2(r, u);
      D && D[Sr2] && (r[u] = n.value, n = { configurable: _r2 in n ? n[_r2] : D[_r2], enumerable: vr2 in n ? n[vr2] : D[vr2], writable: false });
    }
    return Ar2(r, u, n);
  } : Ar2 : function(r, u, n) {
    if (Ve2(r), u = Et2(u), Ve2(n), Yi2)
      try {
        return Ar2(r, u, n);
      } catch {
      }
    if ("get" in n || "set" in n)
      throw Ki("Accessors not supported");
    return "value" in n && (r[u] = n.value), r;
  };
});
var yr$1 = y((qc, mt2) => {
  var Zi2 = De$1(), ea2 = Se$1(), ra2 = xe$1();
  mt2.exports = Zi2 ? function(e, r, u) {
    return ea2.f(e, r, ra2(1, u));
  } : function(e, r, u) {
    return e[r] = u, e;
  };
});
var At$1 = y((Ic, Ft2) => {
  var Tr2 = De$1(), ua = le(), gt2 = Function.prototype, ta2 = Tr2 && Object.getOwnPropertyDescriptor, Br2 = ua(gt2, "name"), na2 = Br2 && (function() {
  }).name === "something", sa2 = Br2 && (!Tr2 || Tr2 && ta2(gt2, "name").configurable);
  Ft2.exports = { EXISTS: Br2, PROPER: na2, CONFIGURABLE: sa2 };
});
var wr$1 = y((Rc, vt2) => {
  var ia = te(), aa = ee(), br2 = Ue$1(), oa = ia(Function.toString);
  aa(br2.inspectSource) || (br2.inspectSource = function(e) {
    return oa(e);
  });
  vt2.exports = br2.inspectSource;
});
var yt$1 = y((xc, St2) => {
  var Da = ue(), la = ee(), _t2 = Da.WeakMap;
  St2.exports = la(_t2) && /native code/.test(String(_t2));
});
var bt$1 = y((Pc, Bt2) => {
  var ca2 = dr$1(), ha2 = Cr$1(), Tt2 = ca2("keys");
  Bt2.exports = function(e) {
    return Tt2[e] || (Tt2[e] = ha2(e));
  };
});
var Nr$1 = y((kc, wt2) => {
  wt2.exports = {};
});
var It$1 = y((Lc, qt2) => {
  var pa = yt$1(), Ot2 = ue(), fa2 = he$1(), da2 = yr$1(), Or2 = le(), qr = Ue$1(), Ea2 = bt$1(), Ca2 = Nr$1(), Nt2 = "Object already initialized", Ir2 = Ot2.TypeError, ma = Ot2.WeakMap, Xe, ye2, He2, ga2 = function(e) {
    return He2(e) ? ye2(e) : Xe(e, {});
  }, Fa2 = function(e) {
    return function(r) {
      var u;
      if (!fa2(r) || (u = ye2(r)).type !== e)
        throw Ir2("Incompatible receiver, " + e + " required");
      return u;
    };
  };
  pa || qr.state ? (se2 = qr.state || (qr.state = new ma()), se2.get = se2.get, se2.has = se2.has, se2.set = se2.set, Xe = function(e, r) {
    if (se2.has(e))
      throw Ir2(Nt2);
    return r.facade = e, se2.set(e, r), r;
  }, ye2 = function(e) {
    return se2.get(e) || {};
  }, He2 = function(e) {
    return se2.has(e);
  }) : (de = Ea2("state"), Ca2[de] = true, Xe = function(e, r) {
    if (Or2(e, de))
      throw Ir2(Nt2);
    return r.facade = e, da2(e, de, r), r;
  }, ye2 = function(e) {
    return Or2(e, de) ? e[de] : {};
  }, He2 = function(e) {
    return Or2(e, de);
  });
  var se2, de;
  qt2.exports = { set: Xe, get: ye2, has: He2, enforce: ga2, getterFor: Fa2 };
});
var Pt$1 = y(($c, xt2) => {
  var Aa2 = ae$1(), va2 = ee(), ze = le(), Rr2 = De$1(), _a2 = At$1().CONFIGURABLE, Sa2 = wr$1(), Rt2 = It$1(), ya2 = Rt2.enforce, Ta2 = Rt2.get, We2 = Object.defineProperty, Ba2 = Rr2 && !Aa2(function() {
    return We2(function() {
    }, "length", { value: 8 }).length !== 8;
  }), ba2 = String(String).split("String"), wa2 = xt2.exports = function(e, r, u) {
    String(r).slice(0, 7) === "Symbol(" && (r = "[" + String(r).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), u && u.getter && (r = "get " + r), u && u.setter && (r = "set " + r), (!ze(e, "name") || _a2 && e.name !== r) && (Rr2 ? We2(e, "name", { value: r, configurable: true }) : e.name = r), Ba2 && u && ze(u, "arity") && e.length !== u.arity && We2(e, "length", { value: u.arity });
    try {
      u && ze(u, "constructor") && u.constructor ? Rr2 && We2(e, "prototype", { writable: false }) : e.prototype && (e.prototype = void 0);
    } catch {
    }
    var n = ya2(e);
    return ze(n, "source") || (n.source = ba2.join(typeof r == "string" ? r : "")), e;
  };
  Function.prototype.toString = wa2(function() {
    return va2(this) && Ta2(this).source || Sa2(this);
  }, "toString");
});
var Lt = y((Mc, kt2) => {
  var Na2 = ee(), Oa2 = Se$1(), qa2 = Pt$1(), Ia2 = je();
  kt2.exports = function(e, r, u, n) {
    n || (n = {});
    var D = n.enumerable, s = n.name !== void 0 ? n.name : r;
    if (Na2(u) && qa2(u, s, n), n.global)
      D ? e[r] = u : Ia2(r, u);
    else {
      try {
        n.unsafe ? e[r] && (D = true) : delete e[r];
      } catch {
      }
      D ? e[r] = u : Oa2.f(e, r, { value: u, enumerable: false, configurable: !n.nonConfigurable, writable: !n.nonWritable });
    }
    return e;
  };
});
var Mt = y((jc, $t2) => {
  var Ra2 = Math.ceil, xa2 = Math.floor;
  $t2.exports = Math.trunc || function(r) {
    var u = +r;
    return (u > 0 ? xa2 : Ra2)(u);
  };
});
var xr$1 = y((Uc, jt2) => {
  var Pa2 = Mt();
  jt2.exports = function(e) {
    var r = +e;
    return r !== r || r === 0 ? 0 : Pa2(r);
  };
});
var Gt = y((Gc, Ut) => {
  var ka2 = xr$1(), La2 = Math.max, $a2 = Math.min;
  Ut.exports = function(e, r) {
    var u = ka2(e);
    return u < 0 ? La2(u + r, 0) : $a2(u, r);
  };
});
var Xt$1 = y((Vc, Vt2) => {
  var Ma2 = xr$1(), ja2 = Math.min;
  Vt2.exports = function(e) {
    return e > 0 ? ja2(Ma2(e), 9007199254740991) : 0;
  };
});
var Te$1 = y((Xc, Ht) => {
  var Ua2 = Xt$1();
  Ht.exports = function(e) {
    return Ua2(e.length);
  };
});
var Yt = y((Hc, Wt) => {
  var Ga2 = ke$1(), Va2 = Gt(), Xa2 = Te$1(), zt2 = function(e) {
    return function(r, u, n) {
      var D = Ga2(r), s = Xa2(D), a = Va2(n, s), f;
      if (e && u != u) {
        for (; s > a; )
          if (f = D[a++], f != f)
            return true;
      } else
        for (; s > a; a++)
          if ((e || a in D) && D[a] === u)
            return e || a || 0;
      return !e && -1;
    };
  };
  Wt.exports = { includes: zt2(true), indexOf: zt2(false) };
});
var Jt = y((zc, Kt2) => {
  var Ha2 = te(), Pr2 = le(), za2 = ke$1(), Wa2 = Yt().indexOf, Ya2 = Nr$1(), Qt2 = Ha2([].push);
  Kt2.exports = function(e, r) {
    var u = za2(e), n = 0, D = [], s;
    for (s in u)
      !Pr2(Ya2, s) && Pr2(u, s) && Qt2(D, s);
    for (; r.length > n; )
      Pr2(u, s = r[n++]) && (~Wa2(D, s) || Qt2(D, s));
    return D;
  };
});
var en$1 = y((Wc, Zt2) => {
  Zt2.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
});
var un = y((rn2) => {
  var Qa2 = Jt(), Ka2 = en$1(), Ja2 = Ka2.concat("length", "prototype");
  rn2.f = Object.getOwnPropertyNames || function(r) {
    return Qa2(r, Ja2);
  };
});
var nn = y((tn2) => {
  tn2.f = Object.getOwnPropertySymbols;
});
var an = y((Kc, sn2) => {
  var Za2 = ve(), eo2 = te(), ro2 = un(), uo2 = nn(), to2 = me$1(), no2 = eo2([].concat);
  sn2.exports = Za2("Reflect", "ownKeys") || function(r) {
    var u = ro2.f(to2(r)), n = uo2.f;
    return n ? no2(u, n(r)) : u;
  };
});
var ln = y((Jc, Dn2) => {
  var on = le(), so2 = an(), io2 = Fr(), ao2 = Se$1();
  Dn2.exports = function(e, r, u) {
    for (var n = so2(r), D = ao2.f, s = io2.f, a = 0; a < n.length; a++) {
      var f = n[a];
      !on(e, f) && !(u && on(u, f)) && D(e, f, s(r, f));
    }
  };
});
var hn$1 = y((Zc, cn2) => {
  var oo2 = ae$1(), Do2 = ee(), lo2 = /#|\.prototype\./, Be = function(e, r) {
    var u = ho2[co2(e)];
    return u == fo2 ? true : u == po2 ? false : Do2(r) ? oo2(r) : !!r;
  }, co2 = Be.normalize = function(e) {
    return String(e).replace(lo2, ".").toLowerCase();
  }, ho2 = Be.data = {}, po2 = Be.NATIVE = "N", fo2 = Be.POLYFILL = "P";
  cn2.exports = Be;
});
var Ye = y((e2, pn2) => {
  var kr2 = ue(), Eo2 = Fr().f, Co2 = yr$1(), mo2 = Lt(), go2 = je(), Fo2 = ln(), Ao2 = hn$1();
  pn2.exports = function(e, r) {
    var u = e.target, n = e.global, D = e.stat, s, a, f, c, v2, i;
    if (n ? a = kr2 : D ? a = kr2[u] || go2(u, {}) : a = (kr2[u] || {}).prototype, a)
      for (f in r) {
        if (v2 = r[f], e.dontCallGetSet ? (i = Eo2(a, f), c = i && i.value) : c = a[f], s = Ao2(n ? f : u + (D ? "." : "#") + f, e.forced), !s && c !== void 0) {
          if (typeof v2 == typeof c)
            continue;
          Fo2(v2, c);
        }
        (e.sham || c && c.sham) && Co2(v2, "sham", true), mo2(a, f, v2, e);
      }
  };
});
var fn = y(() => {
  var vo2 = Ye(), Lr2 = ue();
  vo2({ global: true, forced: Lr2.globalThis !== Lr2 }, { globalThis: Lr2 });
});
var $r$1 = y((t2, dn2) => {
  var _o2 = Ae$1();
  dn2.exports = Array.isArray || function(r) {
    return _o2(r) == "Array";
  };
});
var Cn = y((n2, En2) => {
  var So2 = TypeError, yo2 = 9007199254740991;
  En2.exports = function(e) {
    if (e > yo2)
      throw So2("Maximum allowed index exceeded");
    return e;
  };
});
var gn = y((s2, mn2) => {
  var To2 = Ae$1(), Bo2 = te();
  mn2.exports = function(e) {
    if (To2(e) === "Function")
      return Bo2(e);
  };
});
var Mr = y((i2, An) => {
  var Fn2 = gn(), bo2 = _e(), wo2 = Ie$1(), No2 = Fn2(Fn2.bind);
  An.exports = function(e, r) {
    return bo2(e), r === void 0 ? e : wo2 ? No2(e, r) : function() {
      return e.apply(r, arguments);
    };
  };
});
var Sn = y((a2, _n2) => {
  var Oo2 = $r$1(), qo2 = Te$1(), Io2 = Cn(), Ro2 = Mr(), vn2 = function(e, r, u, n, D, s, a, f) {
    for (var c = D, v2 = 0, i = a ? Ro2(a, f) : false, l, p; v2 < n; )
      v2 in u && (l = i ? i(u[v2], v2, r) : u[v2], s > 0 && Oo2(l) ? (p = qo2(l), c = vn2(e, r, l, p, c, s - 1) - 1) : (Io2(c + 1), e[c] = l), c++), v2++;
    return c;
  };
  _n2.exports = vn2;
});
var Bn = y((o2, Tn2) => {
  var xo2 = fe(), Po2 = xo2("toStringTag"), yn = {};
  yn[Po2] = "z";
  Tn2.exports = String(yn) === "[object z]";
});
var jr = y((D2, bn2) => {
  var ko2 = Bn(), Lo2 = ee(), Qe = Ae$1(), $o2 = fe(), Mo2 = $o2("toStringTag"), jo2 = Object, Uo2 = Qe(function() {
    return arguments;
  }()) == "Arguments", Go2 = function(e, r) {
    try {
      return e[r];
    } catch {
    }
  };
  bn2.exports = ko2 ? Qe : function(e) {
    var r, u, n;
    return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (u = Go2(r = jo2(e), Mo2)) == "string" ? u : Uo2 ? Qe(r) : (n = Qe(r)) == "Object" && Lo2(r.callee) ? "Arguments" : n;
  };
});
var Rn$1 = y((l2, In2) => {
  var Vo2 = te(), Xo2 = ae$1(), wn2 = ee(), Ho2 = jr(), zo2 = ve(), Wo2 = wr$1(), Nn2 = function() {
  }, Yo2 = [], On2 = zo2("Reflect", "construct"), Ur2 = /^\s*(?:class|function)\b/, Qo2 = Vo2(Ur2.exec), Ko2 = !Ur2.exec(Nn2), be2 = function(r) {
    if (!wn2(r))
      return false;
    try {
      return On2(Nn2, Yo2, r), true;
    } catch {
      return false;
    }
  }, qn2 = function(r) {
    if (!wn2(r))
      return false;
    switch (Ho2(r)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return false;
    }
    try {
      return Ko2 || !!Qo2(Ur2, Wo2(r));
    } catch {
      return true;
    }
  };
  qn2.sham = true;
  In2.exports = !On2 || Xo2(function() {
    var e;
    return be2(be2.call) || !be2(Object) || !be2(function() {
      e = true;
    }) || e;
  }) ? qn2 : be2;
});
var Ln = y((c2, kn2) => {
  var xn2 = $r$1(), Jo2 = Rn$1(), Zo2 = he$1(), eD2 = fe(), rD = eD2("species"), Pn2 = Array;
  kn2.exports = function(e) {
    var r;
    return xn2(e) && (r = e.constructor, Jo2(r) && (r === Pn2 || xn2(r.prototype)) ? r = void 0 : Zo2(r) && (r = r[rD], r === null && (r = void 0))), r === void 0 ? Pn2 : r;
  };
});
var Mn$1 = y((h2, $n2) => {
  var uD2 = Ln();
  $n2.exports = function(e, r) {
    return new (uD2(e))(r === 0 ? 0 : r);
  };
});
var Gr = y((p2, jn2) => {
  jn2.exports = {};
});
var Gn = y((f2, Un2) => {
  var DD2 = fe(), lD2 = Gr(), cD2 = DD2("iterator"), hD2 = Array.prototype;
  Un2.exports = function(e) {
    return e !== void 0 && (lD2.Array === e || hD2[cD2] === e);
  };
});
var Vr = y((d2, Xn2) => {
  var pD2 = jr(), Vn2 = Me$1(), fD2 = Pe$1(), dD2 = Gr(), ED2 = fe(), CD2 = ED2("iterator");
  Xn2.exports = function(e) {
    if (!fD2(e))
      return Vn2(e, CD2) || Vn2(e, "@@iterator") || dD2[pD2(e)];
  };
});
var zn = y((E2, Hn2) => {
  var mD2 = ce(), gD2 = _e(), FD2 = me$1(), AD2 = $e$1(), vD2 = Vr(), _D2 = TypeError;
  Hn2.exports = function(e, r) {
    var u = arguments.length < 2 ? vD2(e) : r;
    if (gD2(u))
      return FD2(mD2(u, e));
    throw _D2(AD2(e) + " is not iterable");
  };
});
var Qn = y((C2, Yn2) => {
  var SD2 = ce(), Wn2 = me$1(), yD2 = Me$1();
  Yn2.exports = function(e, r, u) {
    var n, D;
    Wn2(e);
    try {
      if (n = yD2(e, "return"), !n) {
        if (r === "throw")
          throw u;
        return u;
      }
      n = SD2(n, e);
    } catch (s) {
      D = true, n = s;
    }
    if (r === "throw")
      throw u;
    if (D)
      throw n;
    return Wn2(n), u;
  };
});
var rs$1 = y((m2, es) => {
  var TD2 = Mr(), BD2 = ce(), bD2 = me$1(), wD2 = $e$1(), ND2 = Gn(), OD2 = Te$1(), Kn2 = ar(), qD2 = zn(), ID2 = Vr(), Jn2 = Qn(), RD2 = TypeError, Ke2 = function(e, r) {
    this.stopped = e, this.result = r;
  }, Zn2 = Ke2.prototype;
  es.exports = function(e, r, u) {
    var n = u && u.that, D = !!(u && u.AS_ENTRIES), s = !!(u && u.IS_RECORD), a = !!(u && u.IS_ITERATOR), f = !!(u && u.INTERRUPTED), c = TD2(r, n), v2, i, l, p, m, C, g2, B = function(F) {
      return v2 && Jn2(v2, "normal", F), new Ke2(true, F);
    }, O = function(F) {
      return D ? (bD2(F), f ? c(F[0], F[1], B) : c(F[0], F[1])) : f ? c(F, B) : c(F);
    };
    if (s)
      v2 = e.iterator;
    else if (a)
      v2 = e;
    else {
      if (i = ID2(e), !i)
        throw RD2(wD2(e) + " is not iterable");
      if (ND2(i)) {
        for (l = 0, p = OD2(e); p > l; l++)
          if (m = O(e[l]), m && Kn2(Zn2, m))
            return m;
        return new Ke2(false);
      }
      v2 = qD2(e, i);
    }
    for (C = s ? e.next : v2.next; !(g2 = BD2(C, v2)).done; ) {
      try {
        m = O(g2.value);
      } catch (F) {
        Jn2(v2, "throw", F);
      }
      if (typeof m == "object" && m && Kn2(Zn2, m))
        return m;
    }
    return new Ke2(false);
  };
});
var ts = y((g2, us2) => {
  var xD2 = Ge$1(), PD2 = Se$1(), kD2 = xe$1();
  us2.exports = function(e, r, u) {
    var n = xD2(r);
    n in e ? PD2.f(e, n, kD2(0, u)) : e[n] = u;
  };
});
fn();
var tD = Ye(), nD = Sn(), sD = _e(), iD = Er$1(), aD = Te$1(), oD = Mn$1();
tD({ target: "Array", proto: true }, { flatMap: function(r) {
  var u = iD(this), n = aD(u), D;
  return sD(r), D = oD(u, 0), D.length = nD(D, u, u, n, 0, 1, r, arguments.length > 1 ? arguments[1] : void 0), D;
} });
var LD = Ye(), $D = rs$1(), MD = ts();
LD({ target: "Object", stat: true }, { fromEntries: function(r) {
  var u = {};
  return $D(r, function(n, D) {
    MD(u, n, D);
  }, { AS_ENTRIES: true }), u;
} });
var jD = ["cliName", "cliCategory", "cliDescription"];
function UD(e, r) {
  if (e == null)
    return {};
  var u = GD(e, r), n, D;
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e);
    for (D = 0; D < s.length; D++)
      n = s[D], !(r.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(e, n) && (u[n] = e[n]);
  }
  return u;
}
function GD(e, r) {
  if (e == null)
    return {};
  var u = {}, n = Object.keys(e), D, s;
  for (s = 0; s < n.length; s++)
    D = n[s], !(r.indexOf(D) >= 0) && (u[D] = e[D]);
  return u;
}
var VD = Object.create, Je$1 = Object.defineProperty, XD = Object.getOwnPropertyDescriptor, Xr = Object.getOwnPropertyNames, HD = Object.getPrototypeOf, zD = Object.prototype.hasOwnProperty, ge$1 = (e, r) => function() {
  return e && (r = (0, e[Xr(e)[0]])(e = 0)), r;
}, I$1 = (e, r) => function() {
  return r || (0, e[Xr(e)[0]])((r = { exports: {} }).exports, r), r.exports;
}, is = (e, r) => {
  for (var u in r)
    Je$1(e, u, { get: r[u], enumerable: true });
}, as = (e, r, u, n) => {
  if (r && typeof r == "object" || typeof r == "function")
    for (let D of Xr(r))
      !zD.call(e, D) && D !== u && Je$1(e, D, { get: () => r[D], enumerable: !(n = XD(r, D)) || n.enumerable });
  return e;
}, WD = (e, r, u) => (u = e != null ? VD(HD(e)) : {}, as(r || !e || !e.__esModule ? Je$1(u, "default", { value: e, enumerable: true }) : u, e)), os = (e) => as(Je$1({}, "__esModule", { value: true }), e), we$1, N = ge$1({ "<define:process>"() {
  we$1 = { env: {}, argv: [] };
} }), Ds$1 = I$1({ "node_modules/angular-html-parser/lib/compiler/src/chars.js"(e) {
  N(), Object.defineProperty(e, "__esModule", { value: true }), e.$EOF = 0, e.$BSPACE = 8, e.$TAB = 9, e.$LF = 10, e.$VTAB = 11, e.$FF = 12, e.$CR = 13, e.$SPACE = 32, e.$BANG = 33, e.$DQ = 34, e.$HASH = 35, e.$$ = 36, e.$PERCENT = 37, e.$AMPERSAND = 38, e.$SQ = 39, e.$LPAREN = 40, e.$RPAREN = 41, e.$STAR = 42, e.$PLUS = 43, e.$COMMA = 44, e.$MINUS = 45, e.$PERIOD = 46, e.$SLASH = 47, e.$COLON = 58, e.$SEMICOLON = 59, e.$LT = 60, e.$EQ = 61, e.$GT = 62, e.$QUESTION = 63, e.$0 = 48, e.$7 = 55, e.$9 = 57, e.$A = 65, e.$E = 69, e.$F = 70, e.$X = 88, e.$Z = 90, e.$LBRACKET = 91, e.$BACKSLASH = 92, e.$RBRACKET = 93, e.$CARET = 94, e.$_ = 95, e.$a = 97, e.$b = 98, e.$e = 101, e.$f = 102, e.$n = 110, e.$r = 114, e.$t = 116, e.$u = 117, e.$v = 118, e.$x = 120, e.$z = 122, e.$LBRACE = 123, e.$BAR = 124, e.$RBRACE = 125, e.$NBSP = 160, e.$PIPE = 124, e.$TILDA = 126, e.$AT = 64, e.$BT = 96;
  function r(f) {
    return f >= e.$TAB && f <= e.$SPACE || f == e.$NBSP;
  }
  e.isWhitespace = r;
  function u(f) {
    return e.$0 <= f && f <= e.$9;
  }
  e.isDigit = u;
  function n(f) {
    return f >= e.$a && f <= e.$z || f >= e.$A && f <= e.$Z;
  }
  e.isAsciiLetter = n;
  function D(f) {
    return f >= e.$a && f <= e.$f || f >= e.$A && f <= e.$F || u(f);
  }
  e.isAsciiHexDigit = D;
  function s(f) {
    return f === e.$LF || f === e.$CR;
  }
  e.isNewLine = s;
  function a(f) {
    return e.$0 <= f && f <= e.$7;
  }
  e.isOctalDigit = a;
} }), YD = I$1({ "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(e) {
  N(), Object.defineProperty(e, "__esModule", { value: true });
  var r = class {
    constructor(n, D, s) {
      this.filePath = n, this.name = D, this.members = s;
    }
    assertNoMembers() {
      if (this.members.length)
        throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
    }
  };
  e.StaticSymbol = r;
  var u = class {
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
    }
    get(n, D, s) {
      s = s || [];
      let a = s.length ? `.${s.join(".")}` : "", f = `"${n}".${D}${a}`, c = this.cache.get(f);
      return c || (c = new r(n, D, s), this.cache.set(f, c)), c;
    }
  };
  e.StaticSymbolCache = u;
} }), QD = I$1({ "node_modules/angular-html-parser/lib/compiler/src/util.js"(e) {
  N(), Object.defineProperty(e, "__esModule", { value: true });
  var r = /-+([a-z0-9])/g;
  function u(o) {
    return o.replace(r, function() {
      for (var d2 = arguments.length, h = new Array(d2), A = 0; A < d2; A++)
        h[A] = arguments[A];
      return h[1].toUpperCase();
    });
  }
  e.dashCaseToCamelCase = u;
  function n(o, d2) {
    return s(o, ":", d2);
  }
  e.splitAtColon = n;
  function D(o, d2) {
    return s(o, ".", d2);
  }
  e.splitAtPeriod = D;
  function s(o, d2, h) {
    let A = o.indexOf(d2);
    return A == -1 ? h : [o.slice(0, A).trim(), o.slice(A + 1).trim()];
  }
  function a(o, d2, h) {
    return Array.isArray(o) ? d2.visitArray(o, h) : F(o) ? d2.visitStringMap(o, h) : o == null || typeof o == "string" || typeof o == "number" || typeof o == "boolean" ? d2.visitPrimitive(o, h) : d2.visitOther(o, h);
  }
  e.visitValue = a;
  function f(o) {
    return o != null;
  }
  e.isDefined = f;
  function c(o) {
    return o === void 0 ? null : o;
  }
  e.noUndefined = c;
  var v2 = class {
    visitArray(o, d2) {
      return o.map((h) => a(h, this, d2));
    }
    visitStringMap(o, d2) {
      let h = {};
      return Object.keys(o).forEach((A) => {
        h[A] = a(o[A], this, d2);
      }), h;
    }
    visitPrimitive(o, d2) {
      return o;
    }
    visitOther(o, d2) {
      return o;
    }
  };
  e.ValueTransformer = v2, e.SyncAsync = { assertSync: (o) => {
    if (R2(o))
      throw new Error("Illegal state: value cannot be a promise");
    return o;
  }, then: (o, d2) => R2(o) ? o.then(d2) : d2(o), all: (o) => o.some(R2) ? Promise.all(o) : o };
  function i(o) {
    throw new Error(`Internal Error: ${o}`);
  }
  e.error = i;
  function l(o, d2) {
    let h = Error(o);
    return h[p] = true, d2 && (h[m] = d2), h;
  }
  e.syntaxError = l;
  var p = "ngSyntaxError", m = "ngParseErrors";
  function C(o) {
    return o[p];
  }
  e.isSyntaxError = C;
  function g2(o) {
    return o[m] || [];
  }
  e.getParseErrors = g2;
  function B(o) {
    return o.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
  }
  e.escapeRegExp = B;
  var O = Object.getPrototypeOf({});
  function F(o) {
    return typeof o == "object" && o !== null && Object.getPrototypeOf(o) === O;
  }
  function w(o) {
    let d2 = "";
    for (let h = 0; h < o.length; h++) {
      let A = o.charCodeAt(h);
      if (A >= 55296 && A <= 56319 && o.length > h + 1) {
        let q = o.charCodeAt(h + 1);
        q >= 56320 && q <= 57343 && (h++, A = (A - 55296 << 10) + q - 56320 + 65536);
      }
      A <= 127 ? d2 += String.fromCharCode(A) : A <= 2047 ? d2 += String.fromCharCode(A >> 6 & 31 | 192, A & 63 | 128) : A <= 65535 ? d2 += String.fromCharCode(A >> 12 | 224, A >> 6 & 63 | 128, A & 63 | 128) : A <= 2097151 && (d2 += String.fromCharCode(A >> 18 & 7 | 240, A >> 12 & 63 | 128, A >> 6 & 63 | 128, A & 63 | 128));
    }
    return d2;
  }
  e.utf8Encode = w;
  function b(o) {
    if (typeof o == "string")
      return o;
    if (o instanceof Array)
      return "[" + o.map(b).join(", ") + "]";
    if (o == null)
      return "" + o;
    if (o.overriddenName)
      return `${o.overriddenName}`;
    if (o.name)
      return `${o.name}`;
    if (!o.toString)
      return "object";
    let d2 = o.toString();
    if (d2 == null)
      return "" + d2;
    let h = d2.indexOf(`
`);
    return h === -1 ? d2 : d2.substring(0, h);
  }
  e.stringify = b;
  function M2(o) {
    return typeof o == "function" && o.hasOwnProperty("__forward_ref__") ? o() : o;
  }
  e.resolveForwardRef = M2;
  function R2(o) {
    return !!o && typeof o.then == "function";
  }
  e.isPromise = R2;
  var U2 = class {
    constructor(o) {
      this.full = o;
      let d2 = o.split(".");
      this.major = d2[0], this.minor = d2[1], this.patch = d2.slice(2).join(".");
    }
  };
  e.Version = U2;
  var k = typeof window < "u" && window, j = typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self, L = typeof globalThis < "u" && globalThis, t = L || k || j;
  e.global = t;
} }), KD = I$1({ "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(e) {
  N(), Object.defineProperty(e, "__esModule", { value: true });
  var r = YD(), u = QD(), n = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
  function D(h) {
    return h.replace(/\W/g, "_");
  }
  e.sanitizeIdentifier = D;
  var s = 0;
  function a(h) {
    if (!h || !h.reference)
      return null;
    let A = h.reference;
    if (A instanceof r.StaticSymbol)
      return A.name;
    if (A.__anonymousType)
      return A.__anonymousType;
    let q = u.stringify(A);
    return q.indexOf("(") >= 0 ? (q = `anonymous_${s++}`, A.__anonymousType = q) : q = D(q), q;
  }
  e.identifierName = a;
  function f(h) {
    let A = h.reference;
    return A instanceof r.StaticSymbol ? A.filePath : `./${u.stringify(A)}`;
  }
  e.identifierModuleUrl = f;
  function c(h, A) {
    return `View_${a({ reference: h })}_${A}`;
  }
  e.viewClassName = c;
  function v2(h) {
    return `RenderType_${a({ reference: h })}`;
  }
  e.rendererTypeName = v2;
  function i(h) {
    return `HostView_${a({ reference: h })}`;
  }
  e.hostViewClassName = i;
  function l(h) {
    return `${a({ reference: h })}NgFactory`;
  }
  e.componentFactoryName = l;
  var p;
  (function(h) {
    h[h.Pipe = 0] = "Pipe", h[h.Directive = 1] = "Directive", h[h.NgModule = 2] = "NgModule", h[h.Injectable = 3] = "Injectable";
  })(p = e.CompileSummaryKind || (e.CompileSummaryKind = {}));
  function m(h) {
    return h.value != null ? D(h.value) : a(h.identifier);
  }
  e.tokenName = m;
  function C(h) {
    return h.identifier != null ? h.identifier.reference : h.value;
  }
  e.tokenReference = C;
  var g2 = class {
    constructor() {
      let { moduleUrl: h, styles: A, styleUrls: q } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.moduleUrl = h || null, this.styles = R2(A), this.styleUrls = R2(q);
    }
  };
  e.CompileStylesheetMetadata = g2;
  var B = class {
    constructor(h) {
      let { encapsulation: A, template: q, templateUrl: P, htmlAst: G, styles: X, styleUrls: Q, externalStylesheets: H, animations: W, ngContentSelectors: K2, interpolation: J, isInline: S, preserveWhitespaces: E } = h;
      if (this.encapsulation = A, this.template = q, this.templateUrl = P, this.htmlAst = G, this.styles = R2(X), this.styleUrls = R2(Q), this.externalStylesheets = R2(H), this.animations = W ? k(W) : [], this.ngContentSelectors = K2 || [], J && J.length != 2)
        throw new Error("'interpolation' should have a start and an end symbol.");
      this.interpolation = J, this.isInline = S, this.preserveWhitespaces = E;
    }
    toSummary() {
      return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
    }
  };
  e.CompileTemplateMetadata = B;
  var O = class {
    static create(h) {
      let { isHost: A, type: q, isComponent: P, selector: G, exportAs: X, changeDetection: Q, inputs: H, outputs: W, host: K2, providers: J, viewProviders: S, queries: E, guards: _, viewQueries: T, entryComponents: x, template: $2, componentViewType: V, rendererType: z, componentFactory: Y } = h, ie2 = {}, Ee = {}, er2 = {};
      K2 != null && Object.keys(K2).forEach((Z) => {
        let re = K2[Z], oe = Z.match(n);
        oe === null ? er2[Z] = re : oe[1] != null ? Ee[oe[1]] = re : oe[2] != null && (ie2[oe[2]] = re);
      });
      let Fe2 = {};
      H != null && H.forEach((Z) => {
        let re = u.splitAtColon(Z, [Z, Z]);
        Fe2[re[0]] = re[1];
      });
      let Oe2 = {};
      return W != null && W.forEach((Z) => {
        let re = u.splitAtColon(Z, [Z, Z]);
        Oe2[re[0]] = re[1];
      }), new O({ isHost: A, type: q, isComponent: !!P, selector: G, exportAs: X, changeDetection: Q, inputs: Fe2, outputs: Oe2, hostListeners: ie2, hostProperties: Ee, hostAttributes: er2, providers: J, viewProviders: S, queries: E, guards: _, viewQueries: T, entryComponents: x, template: $2, componentViewType: V, rendererType: z, componentFactory: Y });
    }
    constructor(h) {
      let { isHost: A, type: q, isComponent: P, selector: G, exportAs: X, changeDetection: Q, inputs: H, outputs: W, hostListeners: K2, hostProperties: J, hostAttributes: S, providers: E, viewProviders: _, queries: T, guards: x, viewQueries: $2, entryComponents: V, template: z, componentViewType: Y, rendererType: ie2, componentFactory: Ee } = h;
      this.isHost = !!A, this.type = q, this.isComponent = P, this.selector = G, this.exportAs = X, this.changeDetection = Q, this.inputs = H, this.outputs = W, this.hostListeners = K2, this.hostProperties = J, this.hostAttributes = S, this.providers = R2(E), this.viewProviders = R2(_), this.queries = R2(T), this.guards = x, this.viewQueries = R2($2), this.entryComponents = R2(V), this.template = z, this.componentViewType = Y, this.rendererType = ie2, this.componentFactory = Ee;
    }
    toSummary() {
      return { summaryKind: p.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
    }
  };
  e.CompileDirectiveMetadata = O;
  var F = class {
    constructor(h) {
      let { type: A, name: q, pure: P } = h;
      this.type = A, this.name = q, this.pure = !!P;
    }
    toSummary() {
      return { summaryKind: p.Pipe, type: this.type, name: this.name, pure: this.pure };
    }
  };
  e.CompilePipeMetadata = F;
  var w = class {
  };
  e.CompileShallowModuleMetadata = w;
  var b = class {
    constructor(h) {
      let { type: A, providers: q, declaredDirectives: P, exportedDirectives: G, declaredPipes: X, exportedPipes: Q, entryComponents: H, bootstrapComponents: W, importedModules: K2, exportedModules: J, schemas: S, transitiveModule: E, id: _ } = h;
      this.type = A || null, this.declaredDirectives = R2(P), this.exportedDirectives = R2(G), this.declaredPipes = R2(X), this.exportedPipes = R2(Q), this.providers = R2(q), this.entryComponents = R2(H), this.bootstrapComponents = R2(W), this.importedModules = R2(K2), this.exportedModules = R2(J), this.schemas = R2(S), this.id = _ || null, this.transitiveModule = E || null;
    }
    toSummary() {
      let h = this.transitiveModule;
      return { summaryKind: p.NgModule, type: this.type, entryComponents: h.entryComponents, providers: h.providers, modules: h.modules, exportedDirectives: h.exportedDirectives, exportedPipes: h.exportedPipes };
    }
  };
  e.CompileNgModuleMetadata = b;
  var M2 = class {
    constructor() {
      this.directivesSet = /* @__PURE__ */ new Set(), this.directives = [], this.exportedDirectivesSet = /* @__PURE__ */ new Set(), this.exportedDirectives = [], this.pipesSet = /* @__PURE__ */ new Set(), this.pipes = [], this.exportedPipesSet = /* @__PURE__ */ new Set(), this.exportedPipes = [], this.modulesSet = /* @__PURE__ */ new Set(), this.modules = [], this.entryComponentsSet = /* @__PURE__ */ new Set(), this.entryComponents = [], this.providers = [];
    }
    addProvider(h, A) {
      this.providers.push({ provider: h, module: A });
    }
    addDirective(h) {
      this.directivesSet.has(h.reference) || (this.directivesSet.add(h.reference), this.directives.push(h));
    }
    addExportedDirective(h) {
      this.exportedDirectivesSet.has(h.reference) || (this.exportedDirectivesSet.add(h.reference), this.exportedDirectives.push(h));
    }
    addPipe(h) {
      this.pipesSet.has(h.reference) || (this.pipesSet.add(h.reference), this.pipes.push(h));
    }
    addExportedPipe(h) {
      this.exportedPipesSet.has(h.reference) || (this.exportedPipesSet.add(h.reference), this.exportedPipes.push(h));
    }
    addModule(h) {
      this.modulesSet.has(h.reference) || (this.modulesSet.add(h.reference), this.modules.push(h));
    }
    addEntryComponent(h) {
      this.entryComponentsSet.has(h.componentType) || (this.entryComponentsSet.add(h.componentType), this.entryComponents.push(h));
    }
  };
  e.TransitiveCompileNgModuleMetadata = M2;
  function R2(h) {
    return h || [];
  }
  var U2 = class {
    constructor(h, A) {
      let { useClass: q, useValue: P, useExisting: G, useFactory: X, deps: Q, multi: H } = A;
      this.token = h, this.useClass = q || null, this.useValue = P, this.useExisting = G, this.useFactory = X || null, this.dependencies = Q || null, this.multi = !!H;
    }
  };
  e.ProviderMeta = U2;
  function k(h) {
    return h.reduce((A, q) => {
      let P = Array.isArray(q) ? k(q) : q;
      return A.concat(P);
    }, []);
  }
  e.flatten = k;
  function j(h) {
    return h.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
  }
  function L(h, A, q) {
    let P;
    return q.isInline ? A.type.reference instanceof r.StaticSymbol ? P = `${A.type.reference.filePath}.${A.type.reference.name}.html` : P = `${a(h)}/${a(A.type)}.html` : P = q.templateUrl, A.type.reference instanceof r.StaticSymbol ? P : j(P);
  }
  e.templateSourceUrl = L;
  function t(h, A) {
    let q = h.moduleUrl.split(/\/\\/g), P = q[q.length - 1];
    return j(`css/${A}${P}.ngstyle.js`);
  }
  e.sharedStylesheetJitUrl = t;
  function o(h) {
    return j(`${a(h.type)}/module.ngfactory.js`);
  }
  e.ngModuleJitUrl = o;
  function d2(h, A) {
    return j(`${a(h)}/${a(A.type)}.ngfactory.js`);
  }
  e.templateJitUrl = d2;
} }), Ne$1 = I$1({ "node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(e) {
  N(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Ds$1(), u = KD(), n = class {
    constructor(i, l, p, m) {
      this.file = i, this.offset = l, this.line = p, this.col = m;
    }
    toString() {
      return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
    }
    moveBy(i) {
      let l = this.file.content, p = l.length, m = this.offset, C = this.line, g2 = this.col;
      for (; m > 0 && i < 0; )
        if (m--, i++, l.charCodeAt(m) == r.$LF) {
          C--;
          let O = l.substr(0, m - 1).lastIndexOf(String.fromCharCode(r.$LF));
          g2 = O > 0 ? m - O : m;
        } else
          g2--;
      for (; m < p && i > 0; ) {
        let B = l.charCodeAt(m);
        m++, i--, B == r.$LF ? (C++, g2 = 0) : g2++;
      }
      return new n(this.file, m, C, g2);
    }
    getContext(i, l) {
      let p = this.file.content, m = this.offset;
      if (m != null) {
        m > p.length - 1 && (m = p.length - 1);
        let C = m, g2 = 0, B = 0;
        for (; g2 < i && m > 0 && (m--, g2++, !(p[m] == `
` && ++B == l)); )
          ;
        for (g2 = 0, B = 0; g2 < i && C < p.length - 1 && (C++, g2++, !(p[C] == `
` && ++B == l)); )
          ;
        return { before: p.substring(m, this.offset), after: p.substring(this.offset, C + 1) };
      }
      return null;
    }
  };
  e.ParseLocation = n;
  var D = class {
    constructor(i, l) {
      this.content = i, this.url = l;
    }
  };
  e.ParseSourceFile = D;
  var s = class {
    constructor(i, l) {
      let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      this.start = i, this.end = l, this.details = p;
    }
    toString() {
      return this.start.file.content.substring(this.start.offset, this.end.offset);
    }
  };
  e.ParseSourceSpan = s, e.EMPTY_PARSE_LOCATION = new n(new D("", ""), 0, 0, 0), e.EMPTY_SOURCE_SPAN = new s(e.EMPTY_PARSE_LOCATION, e.EMPTY_PARSE_LOCATION);
  var a;
  (function(i) {
    i[i.WARNING = 0] = "WARNING", i[i.ERROR = 1] = "ERROR";
  })(a = e.ParseErrorLevel || (e.ParseErrorLevel = {}));
  var f = class {
    constructor(i, l) {
      let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : a.ERROR;
      this.span = i, this.msg = l, this.level = p;
    }
    contextualMessage() {
      let i = this.span.start.getContext(100, 3);
      return i ? `${this.msg} ("${i.before}[${a[this.level]} ->]${i.after}")` : this.msg;
    }
    toString() {
      let i = this.span.details ? `, ${this.span.details}` : "";
      return `${this.contextualMessage()}: ${this.span.start}${i}`;
    }
  };
  e.ParseError = f;
  function c(i, l) {
    let p = u.identifierModuleUrl(l), m = p != null ? `in ${i} ${u.identifierName(l)} in ${p}` : `in ${i} ${u.identifierName(l)}`, C = new D("", m);
    return new s(new n(C, -1, -1, -1), new n(C, -1, -1, -1));
  }
  e.typeSourceSpan = c;
  function v2(i, l, p) {
    let m = `in ${i} ${l} in ${p}`, C = new D("", m);
    return new s(new n(C, -1, -1, -1), new n(C, -1, -1, -1));
  }
  e.r3JitTypeSourceSpan = v2;
} }), JD = I$1({ "src/utils/front-matter/parse.js"(e, r) {
  N();
  var u = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
  function n(D) {
    let s = D.match(u);
    if (!s)
      return { content: D };
    let { startDelimiter: a, language: f, value: c = "", endDelimiter: v2 } = s.groups, i = f.trim() || "yaml";
    if (a === "+++" && (i = "toml"), i !== "yaml" && a !== v2)
      return { content: D };
    let [l] = s;
    return { frontMatter: { type: "front-matter", lang: i, value: c, startDelimiter: a, endDelimiter: v2, raw: l.replace(/\n$/, "") }, content: l.replace(/[^\n]/g, " ") + D.slice(l.length) };
  }
  r.exports = n;
} }), ls$1 = I$1({ "src/utils/get-last.js"(e, r) {
  N();
  var u = (n) => n[n.length - 1];
  r.exports = u;
} }), ZD = I$1({ "src/common/parser-create-error.js"(e, r) {
  N();
  function u(n, D) {
    let s = new SyntaxError(n + " (" + D.start.line + ":" + D.start.column + ")");
    return s.loc = D, s;
  }
  r.exports = u;
} }), cs = {};
is(cs, { default: () => el });
function el(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
var rl = ge$1({ "node_modules/escape-string-regexp/index.js"() {
  N();
} }), hs$1 = I$1({ "node_modules/semver/internal/debug.js"(e, r) {
  N();
  var u = typeof we$1 == "object" && we$1.env && we$1.env.NODE_DEBUG && /\bsemver\b/i.test(we$1.env.NODE_DEBUG) ? function() {
    for (var n = arguments.length, D = new Array(n), s = 0; s < n; s++)
      D[s] = arguments[s];
    return console.error("SEMVER", ...D);
  } : () => {
  };
  r.exports = u;
} }), ps$1 = I$1({ "node_modules/semver/internal/constants.js"(e, r) {
  N();
  var u = "2.0.0", n = 256, D = Number.MAX_SAFE_INTEGER || 9007199254740991, s = 16;
  r.exports = { SEMVER_SPEC_VERSION: u, MAX_LENGTH: n, MAX_SAFE_INTEGER: D, MAX_SAFE_COMPONENT_LENGTH: s };
} }), ul$1 = I$1({ "node_modules/semver/internal/re.js"(e, r) {
  N();
  var { MAX_SAFE_COMPONENT_LENGTH: u } = ps$1(), n = hs$1();
  e = r.exports = {};
  var D = e.re = [], s = e.src = [], a = e.t = {}, f = 0, c = (v2, i, l) => {
    let p = f++;
    n(v2, p, i), a[v2] = p, s[p] = i, D[p] = new RegExp(i, l ? "g" : void 0);
  };
  c("NUMERICIDENTIFIER", "0|[1-9]\\d*"), c("NUMERICIDENTIFIERLOOSE", "[0-9]+"), c("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), c("MAINVERSION", `(${s[a.NUMERICIDENTIFIER]})\\.(${s[a.NUMERICIDENTIFIER]})\\.(${s[a.NUMERICIDENTIFIER]})`), c("MAINVERSIONLOOSE", `(${s[a.NUMERICIDENTIFIERLOOSE]})\\.(${s[a.NUMERICIDENTIFIERLOOSE]})\\.(${s[a.NUMERICIDENTIFIERLOOSE]})`), c("PRERELEASEIDENTIFIER", `(?:${s[a.NUMERICIDENTIFIER]}|${s[a.NONNUMERICIDENTIFIER]})`), c("PRERELEASEIDENTIFIERLOOSE", `(?:${s[a.NUMERICIDENTIFIERLOOSE]}|${s[a.NONNUMERICIDENTIFIER]})`), c("PRERELEASE", `(?:-(${s[a.PRERELEASEIDENTIFIER]}(?:\\.${s[a.PRERELEASEIDENTIFIER]})*))`), c("PRERELEASELOOSE", `(?:-?(${s[a.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${s[a.PRERELEASEIDENTIFIERLOOSE]})*))`), c("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), c("BUILD", `(?:\\+(${s[a.BUILDIDENTIFIER]}(?:\\.${s[a.BUILDIDENTIFIER]})*))`), c("FULLPLAIN", `v?${s[a.MAINVERSION]}${s[a.PRERELEASE]}?${s[a.BUILD]}?`), c("FULL", `^${s[a.FULLPLAIN]}$`), c("LOOSEPLAIN", `[v=\\s]*${s[a.MAINVERSIONLOOSE]}${s[a.PRERELEASELOOSE]}?${s[a.BUILD]}?`), c("LOOSE", `^${s[a.LOOSEPLAIN]}$`), c("GTLT", "((?:<|>)?=?)"), c("XRANGEIDENTIFIERLOOSE", `${s[a.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), c("XRANGEIDENTIFIER", `${s[a.NUMERICIDENTIFIER]}|x|X|\\*`), c("XRANGEPLAIN", `[v=\\s]*(${s[a.XRANGEIDENTIFIER]})(?:\\.(${s[a.XRANGEIDENTIFIER]})(?:\\.(${s[a.XRANGEIDENTIFIER]})(?:${s[a.PRERELEASE]})?${s[a.BUILD]}?)?)?`), c("XRANGEPLAINLOOSE", `[v=\\s]*(${s[a.XRANGEIDENTIFIERLOOSE]})(?:\\.(${s[a.XRANGEIDENTIFIERLOOSE]})(?:\\.(${s[a.XRANGEIDENTIFIERLOOSE]})(?:${s[a.PRERELEASELOOSE]})?${s[a.BUILD]}?)?)?`), c("XRANGE", `^${s[a.GTLT]}\\s*${s[a.XRANGEPLAIN]}$`), c("XRANGELOOSE", `^${s[a.GTLT]}\\s*${s[a.XRANGEPLAINLOOSE]}$`), c("COERCE", `(^|[^\\d])(\\d{1,${u}})(?:\\.(\\d{1,${u}}))?(?:\\.(\\d{1,${u}}))?(?:$|[^\\d])`), c("COERCERTL", s[a.COERCE], true), c("LONETILDE", "(?:~>?)"), c("TILDETRIM", `(\\s*)${s[a.LONETILDE]}\\s+`, true), e.tildeTrimReplace = "$1~", c("TILDE", `^${s[a.LONETILDE]}${s[a.XRANGEPLAIN]}$`), c("TILDELOOSE", `^${s[a.LONETILDE]}${s[a.XRANGEPLAINLOOSE]}$`), c("LONECARET", "(?:\\^)"), c("CARETTRIM", `(\\s*)${s[a.LONECARET]}\\s+`, true), e.caretTrimReplace = "$1^", c("CARET", `^${s[a.LONECARET]}${s[a.XRANGEPLAIN]}$`), c("CARETLOOSE", `^${s[a.LONECARET]}${s[a.XRANGEPLAINLOOSE]}$`), c("COMPARATORLOOSE", `^${s[a.GTLT]}\\s*(${s[a.LOOSEPLAIN]})$|^$`), c("COMPARATOR", `^${s[a.GTLT]}\\s*(${s[a.FULLPLAIN]})$|^$`), c("COMPARATORTRIM", `(\\s*)${s[a.GTLT]}\\s*(${s[a.LOOSEPLAIN]}|${s[a.XRANGEPLAIN]})`, true), e.comparatorTrimReplace = "$1$2$3", c("HYPHENRANGE", `^\\s*(${s[a.XRANGEPLAIN]})\\s+-\\s+(${s[a.XRANGEPLAIN]})\\s*$`), c("HYPHENRANGELOOSE", `^\\s*(${s[a.XRANGEPLAINLOOSE]})\\s+-\\s+(${s[a.XRANGEPLAINLOOSE]})\\s*$`), c("STAR", "(<|>)?=?\\s*\\*"), c("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), c("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
} }), tl = I$1({ "node_modules/semver/internal/parse-options.js"(e, r) {
  N();
  var u = ["includePrerelease", "loose", "rtl"], n = (D) => D ? typeof D != "object" ? { loose: true } : u.filter((s) => D[s]).reduce((s, a) => (s[a] = true, s), {}) : {};
  r.exports = n;
} }), nl = I$1({ "node_modules/semver/internal/identifiers.js"(e, r) {
  N();
  var u = /^[0-9]+$/, n = (s, a) => {
    let f = u.test(s), c = u.test(a);
    return f && c && (s = +s, a = +a), s === a ? 0 : f && !c ? -1 : c && !f ? 1 : s < a ? -1 : 1;
  }, D = (s, a) => n(a, s);
  r.exports = { compareIdentifiers: n, rcompareIdentifiers: D };
} }), sl$1 = I$1({ "node_modules/semver/classes/semver.js"(e, r) {
  N();
  var u = hs$1(), { MAX_LENGTH: n, MAX_SAFE_INTEGER: D } = ps$1(), { re: s, t: a } = ul$1(), f = tl(), { compareIdentifiers: c } = nl(), v2 = class {
    constructor(i, l) {
      if (l = f(l), i instanceof v2) {
        if (i.loose === !!l.loose && i.includePrerelease === !!l.includePrerelease)
          return i;
        i = i.version;
      } else if (typeof i != "string")
        throw new TypeError(`Invalid Version: ${i}`);
      if (i.length > n)
        throw new TypeError(`version is longer than ${n} characters`);
      u("SemVer", i, l), this.options = l, this.loose = !!l.loose, this.includePrerelease = !!l.includePrerelease;
      let p = i.trim().match(l.loose ? s[a.LOOSE] : s[a.FULL]);
      if (!p)
        throw new TypeError(`Invalid Version: ${i}`);
      if (this.raw = i, this.major = +p[1], this.minor = +p[2], this.patch = +p[3], this.major > D || this.major < 0)
        throw new TypeError("Invalid major version");
      if (this.minor > D || this.minor < 0)
        throw new TypeError("Invalid minor version");
      if (this.patch > D || this.patch < 0)
        throw new TypeError("Invalid patch version");
      p[4] ? this.prerelease = p[4].split(".").map((m) => {
        if (/^[0-9]+$/.test(m)) {
          let C = +m;
          if (C >= 0 && C < D)
            return C;
        }
        return m;
      }) : this.prerelease = [], this.build = p[5] ? p[5].split(".") : [], this.format();
    }
    format() {
      return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
    }
    toString() {
      return this.version;
    }
    compare(i) {
      if (u("SemVer.compare", this.version, this.options, i), !(i instanceof v2)) {
        if (typeof i == "string" && i === this.version)
          return 0;
        i = new v2(i, this.options);
      }
      return i.version === this.version ? 0 : this.compareMain(i) || this.comparePre(i);
    }
    compareMain(i) {
      return i instanceof v2 || (i = new v2(i, this.options)), c(this.major, i.major) || c(this.minor, i.minor) || c(this.patch, i.patch);
    }
    comparePre(i) {
      if (i instanceof v2 || (i = new v2(i, this.options)), this.prerelease.length && !i.prerelease.length)
        return -1;
      if (!this.prerelease.length && i.prerelease.length)
        return 1;
      if (!this.prerelease.length && !i.prerelease.length)
        return 0;
      let l = 0;
      do {
        let p = this.prerelease[l], m = i.prerelease[l];
        if (u("prerelease compare", l, p, m), p === void 0 && m === void 0)
          return 0;
        if (m === void 0)
          return 1;
        if (p === void 0)
          return -1;
        if (p === m)
          continue;
        return c(p, m);
      } while (++l);
    }
    compareBuild(i) {
      i instanceof v2 || (i = new v2(i, this.options));
      let l = 0;
      do {
        let p = this.build[l], m = i.build[l];
        if (u("prerelease compare", l, p, m), p === void 0 && m === void 0)
          return 0;
        if (m === void 0)
          return 1;
        if (p === void 0)
          return -1;
        if (p === m)
          continue;
        return c(p, m);
      } while (++l);
    }
    inc(i, l) {
      switch (i) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", l);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", l);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", l), this.inc("pre", l);
          break;
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", l), this.inc("pre", l);
          break;
        case "major":
          (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0)
            this.prerelease = [0];
          else {
            let p = this.prerelease.length;
            for (; --p >= 0; )
              typeof this.prerelease[p] == "number" && (this.prerelease[p]++, p = -2);
            p === -1 && this.prerelease.push(0);
          }
          l && (c(this.prerelease[0], l) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [l, 0]) : this.prerelease = [l, 0]);
          break;
        default:
          throw new Error(`invalid increment argument: ${i}`);
      }
      return this.format(), this.raw = this.version, this;
    }
  };
  r.exports = v2;
} }), Hr = I$1({ "node_modules/semver/functions/compare.js"(e, r) {
  N();
  var u = sl$1(), n = (D, s, a) => new u(D, a).compare(new u(s, a));
  r.exports = n;
} }), il$1 = I$1({ "node_modules/semver/functions/lt.js"(e, r) {
  N();
  var u = Hr(), n = (D, s, a) => u(D, s, a) < 0;
  r.exports = n;
} }), al$1 = I$1({ "node_modules/semver/functions/gte.js"(e, r) {
  N();
  var u = Hr(), n = (D, s, a) => u(D, s, a) >= 0;
  r.exports = n;
} }), ol$1 = I$1({ "src/utils/arrayify.js"(e, r) {
  N(), r.exports = (u, n) => Object.entries(u).map((D) => {
    let [s, a] = D;
    return Object.assign({ [n]: s }, a);
  });
} }), Dl$1 = I$1({ "package.json"(e, r) {
  r.exports = { version: "2.8.8" };
} }), ll$1 = I$1({ "node_modules/outdent/lib/index.js"(e, r) {
  N(), Object.defineProperty(e, "__esModule", { value: true }), e.outdent = void 0;
  function u() {
    for (var F = [], w = 0; w < arguments.length; w++)
      F[w] = arguments[w];
  }
  function n() {
    return typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : D();
  }
  function D() {
    return { add: u, delete: u, get: u, set: u, has: function(F) {
      return false;
    } };
  }
  var s = Object.prototype.hasOwnProperty, a = function(F, w) {
    return s.call(F, w);
  };
  function f(F, w) {
    for (var b in w)
      a(w, b) && (F[b] = w[b]);
    return F;
  }
  var c = /^[ \t]*(?:\r\n|\r|\n)/, v2 = /(?:\r\n|\r|\n)[ \t]*$/, i = /^(?:[\r\n]|$)/, l = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p = /^[ \t]*[\r\n][ \t\r\n]*$/;
  function m(F, w, b) {
    var M2 = 0, R2 = F[0].match(l);
    R2 && (M2 = R2[1].length);
    var U2 = "(\\r\\n|\\r|\\n).{0," + M2 + "}", k = new RegExp(U2, "g");
    w && (F = F.slice(1));
    var j = b.newline, L = b.trimLeadingNewline, t = b.trimTrailingNewline, o = typeof j == "string", d2 = F.length, h = F.map(function(A, q) {
      return A = A.replace(k, "$1"), q === 0 && L && (A = A.replace(c, "")), q === d2 - 1 && t && (A = A.replace(v2, "")), o && (A = A.replace(/\r\n|\n|\r/g, function(P) {
        return j;
      })), A;
    });
    return h;
  }
  function C(F, w) {
    for (var b = "", M2 = 0, R2 = F.length; M2 < R2; M2++)
      b += F[M2], M2 < R2 - 1 && (b += w[M2]);
    return b;
  }
  function g2(F) {
    return a(F, "raw") && a(F, "length");
  }
  function B(F) {
    var w = n(), b = n();
    function M2(U2) {
      for (var k = [], j = 1; j < arguments.length; j++)
        k[j - 1] = arguments[j];
      if (g2(U2)) {
        var L = U2, t = (k[0] === M2 || k[0] === O) && p.test(L[0]) && i.test(L[1]), o = t ? b : w, d2 = o.get(L);
        if (d2 || (d2 = m(L, t, F), o.set(L, d2)), k.length === 0)
          return d2[0];
        var h = C(d2, t ? k.slice(1) : k);
        return h;
      } else
        return B(f(f({}, F), U2 || {}));
    }
    var R2 = f(M2, { string: function(U2) {
      return m([U2], false, F)[0];
    } });
    return R2;
  }
  var O = B({ trimLeadingNewline: true, trimTrailingNewline: true });
  if (e.outdent = O, e.default = O, typeof r < "u")
    try {
      r.exports = O, Object.defineProperty(O, "__esModule", { value: true }), O.default = O, O.outdent = O;
    } catch {
    }
} }), cl$1 = I$1({ "src/main/core-options.js"(e, r) {
  N();
  var { outdent: u } = ll$1(), n = "Config", D = "Editor", s = "Format", a = "Other", f = "Output", c = "Global", v2 = "Special", i = { cursorOffset: { since: "1.4.0", category: v2, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: u`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: D }, endOfLine: { since: "1.15.0", category: c, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: u`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        ` }] }, filepath: { since: "1.4.0", category: v2, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: a, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: v2, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: a }, parser: { since: "0.0.10", category: c, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (l) => typeof l == "string" || typeof l == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "acorn", since: "2.6.0", description: "JavaScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: c, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (l) => typeof l == "string" || typeof l == "object", cliName: "plugin", cliCategory: n }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: c, description: u`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (l) => typeof l == "string" || typeof l == "object", cliName: "plugin-search-dir", cliCategory: n }, printWidth: { since: "0.0.0", category: c, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: v2, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: u`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: D }, rangeStart: { since: "1.4.0", category: v2, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: u`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: D }, requirePragma: { since: "1.7.0", category: v2, type: "boolean", default: false, description: u`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: a }, tabWidth: { type: "int", category: c, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: c, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: c, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
  r.exports = { CATEGORY_CONFIG: n, CATEGORY_EDITOR: D, CATEGORY_FORMAT: s, CATEGORY_OTHER: a, CATEGORY_OUTPUT: f, CATEGORY_GLOBAL: c, CATEGORY_SPECIAL: v2, options: i };
} }), hl$1 = I$1({ "src/main/support.js"(e, r) {
  N();
  var u = { compare: Hr(), lt: il$1(), gte: al$1() }, n = ol$1(), D = Dl$1().version, s = cl$1().options;
  function a() {
    let { plugins: c = [], showUnreleased: v2 = false, showDeprecated: i = false, showInternal: l = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, p = D.split("-", 1)[0], m = c.flatMap((F) => F.languages || []).filter(g2), C = n(Object.assign({}, ...c.map((F) => {
      let { options: w } = F;
      return w;
    }), s), "name").filter((F) => g2(F) && B(F)).sort((F, w) => F.name === w.name ? 0 : F.name < w.name ? -1 : 1).map(O).map((F) => {
      F = Object.assign({}, F), Array.isArray(F.default) && (F.default = F.default.length === 1 ? F.default[0].value : F.default.filter(g2).sort((b, M2) => u.compare(M2.since, b.since))[0].value), Array.isArray(F.choices) && (F.choices = F.choices.filter((b) => g2(b) && B(b)), F.name === "parser" && f(F, m, c));
      let w = Object.fromEntries(c.filter((b) => b.defaultOptions && b.defaultOptions[F.name] !== void 0).map((b) => [b.name, b.defaultOptions[F.name]]));
      return Object.assign(Object.assign({}, F), {}, { pluginDefaults: w });
    });
    return { languages: m, options: C };
    function g2(F) {
      return v2 || !("since" in F) || F.since && u.gte(p, F.since);
    }
    function B(F) {
      return i || !("deprecated" in F) || F.deprecated && u.lt(p, F.deprecated);
    }
    function O(F) {
      if (l)
        return F;
      return UD(F, jD);
    }
  }
  function f(c, v2, i) {
    let l = new Set(c.choices.map((p) => p.value));
    for (let p of v2)
      if (p.parsers) {
        for (let m of p.parsers)
          if (!l.has(m)) {
            l.add(m);
            let C = i.find((B) => B.parsers && B.parsers[m]), g2 = p.name;
            C && C.name && (g2 += ` (plugin: ${C.name})`), c.choices.push({ value: m, description: g2 });
          }
      }
  }
  r.exports = { getSupportInfo: a };
} }), pl$1 = I$1({ "src/utils/is-non-empty-array.js"(e, r) {
  N();
  function u(n) {
    return Array.isArray(n) && n.length > 0;
  }
  r.exports = u;
} });
function fl$1() {
  let { onlyFirst: e = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
  return new RegExp(r, e ? void 0 : "g");
}
var dl$1 = ge$1({ "node_modules/strip-ansi/node_modules/ansi-regex/index.js"() {
  N();
} });
function El$1(e) {
  if (typeof e != "string")
    throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);
  return e.replace(fl$1(), "");
}
var Cl$1 = ge$1({ "node_modules/strip-ansi/index.js"() {
  N(), dl$1();
} });
function ml$1(e) {
  return Number.isInteger(e) ? e >= 4352 && (e <= 4447 || e === 9001 || e === 9002 || 11904 <= e && e <= 12871 && e !== 12351 || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141) : false;
}
var gl$1 = ge$1({ "node_modules/is-fullwidth-code-point/index.js"() {
  N();
} }), Fl$1 = I$1({ "node_modules/emoji-regex/index.js"(e, r) {
  N(), r.exports = function() {
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
  };
} }), fs = {};
is(fs, { default: () => Al$1 });
function Al$1(e) {
  if (typeof e != "string" || e.length === 0 || (e = El$1(e), e.length === 0))
    return 0;
  e = e.replace((0, ds$1.default)(), "  ");
  let r = 0;
  for (let u = 0; u < e.length; u++) {
    let n = e.codePointAt(u);
    n <= 31 || n >= 127 && n <= 159 || n >= 768 && n <= 879 || (n > 65535 && u++, r += ml$1(n) ? 2 : 1);
  }
  return r;
}
var ds$1, vl$1 = ge$1({ "node_modules/string-width/index.js"() {
  N(), Cl$1(), gl$1(), ds$1 = WD(Fl$1());
} }), _l$1 = I$1({ "src/utils/get-string-width.js"(e, r) {
  N();
  var u = (vl$1(), os(fs)).default, n = /[^\x20-\x7F]/;
  function D(s) {
    return s ? n.test(s) ? u(s) : s.length : 0;
  }
  r.exports = D;
} }), zr$1 = I$1({ "src/utils/text/skip.js"(e, r) {
  N();
  function u(f) {
    return (c, v2, i) => {
      let l = i && i.backwards;
      if (v2 === false)
        return false;
      let { length: p } = c, m = v2;
      for (; m >= 0 && m < p; ) {
        let C = c.charAt(m);
        if (f instanceof RegExp) {
          if (!f.test(C))
            return m;
        } else if (!f.includes(C))
          return m;
        l ? m-- : m++;
      }
      return m === -1 || m === p ? m : false;
    };
  }
  var n = u(/\s/), D = u(" 	"), s = u(",; 	"), a = u(/[^\n\r]/);
  r.exports = { skipWhitespace: n, skipSpaces: D, skipToLineEnd: s, skipEverythingButNewLine: a };
} }), Es$1 = I$1({ "src/utils/text/skip-inline-comment.js"(e, r) {
  N();
  function u(n, D) {
    if (D === false)
      return false;
    if (n.charAt(D) === "/" && n.charAt(D + 1) === "*") {
      for (let s = D + 2; s < n.length; ++s)
        if (n.charAt(s) === "*" && n.charAt(s + 1) === "/")
          return s + 2;
    }
    return D;
  }
  r.exports = u;
} }), Cs$1 = I$1({ "src/utils/text/skip-trailing-comment.js"(e, r) {
  N();
  var { skipEverythingButNewLine: u } = zr$1();
  function n(D, s) {
    return s === false ? false : D.charAt(s) === "/" && D.charAt(s + 1) === "/" ? u(D, s) : s;
  }
  r.exports = n;
} }), ms$1 = I$1({ "src/utils/text/skip-newline.js"(e, r) {
  N();
  function u(n, D, s) {
    let a = s && s.backwards;
    if (D === false)
      return false;
    let f = n.charAt(D);
    if (a) {
      if (n.charAt(D - 1) === "\r" && f === `
`)
        return D - 2;
      if (f === `
` || f === "\r" || f === "\u2028" || f === "\u2029")
        return D - 1;
    } else {
      if (f === "\r" && n.charAt(D + 1) === `
`)
        return D + 2;
      if (f === `
` || f === "\r" || f === "\u2028" || f === "\u2029")
        return D + 1;
    }
    return D;
  }
  r.exports = u;
} }), Sl$1 = I$1({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e, r) {
  N();
  var u = Es$1(), n = ms$1(), D = Cs$1(), { skipSpaces: s } = zr$1();
  function a(f, c) {
    let v2 = null, i = c;
    for (; i !== v2; )
      v2 = i, i = s(f, i), i = u(f, i), i = D(f, i), i = n(f, i);
    return i;
  }
  r.exports = a;
} }), yl$1 = I$1({ "src/common/util.js"(e, r) {
  N();
  var { default: u } = (rl(), os(cs)), n = ls$1(), { getSupportInfo: D } = hl$1(), s = pl$1(), a = _l$1(), { skipWhitespace: f, skipSpaces: c, skipToLineEnd: v2, skipEverythingButNewLine: i } = zr$1(), l = Es$1(), p = Cs$1(), m = ms$1(), C = Sl$1(), g2 = (S) => S[S.length - 2];
  function B(S) {
    return (E, _, T) => {
      let x = T && T.backwards;
      if (_ === false)
        return false;
      let { length: $2 } = E, V = _;
      for (; V >= 0 && V < $2; ) {
        let z = E.charAt(V);
        if (S instanceof RegExp) {
          if (!S.test(z))
            return V;
        } else if (!S.includes(z))
          return V;
        x ? V-- : V++;
      }
      return V === -1 || V === $2 ? V : false;
    };
  }
  function O(S, E) {
    let _ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, T = c(S, _.backwards ? E - 1 : E, _), x = m(S, T, _);
    return T !== x;
  }
  function F(S, E, _) {
    for (let T = E; T < _; ++T)
      if (S.charAt(T) === `
`)
        return true;
    return false;
  }
  function w(S, E, _) {
    let T = _(E) - 1;
    T = c(S, T, { backwards: true }), T = m(S, T, { backwards: true }), T = c(S, T, { backwards: true });
    let x = m(S, T, { backwards: true });
    return T !== x;
  }
  function b(S, E) {
    let _ = null, T = E;
    for (; T !== _; )
      _ = T, T = v2(S, T), T = l(S, T), T = c(S, T);
    return T = p(S, T), T = m(S, T), T !== false && O(S, T);
  }
  function M2(S, E, _) {
    return b(S, _(E));
  }
  function R2(S, E, _) {
    return C(S, _(E));
  }
  function U2(S, E, _) {
    return S.charAt(R2(S, E, _));
  }
  function k(S, E) {
    let _ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return c(S, _.backwards ? E - 1 : E, _) !== E;
  }
  function j(S, E) {
    let _ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, T = 0;
    for (let x = _; x < S.length; ++x)
      S[x] === "	" ? T = T + E - T % E : T++;
    return T;
  }
  function L(S, E) {
    let _ = S.lastIndexOf(`
`);
    return _ === -1 ? 0 : j(S.slice(_ + 1).match(/^[\t ]*/)[0], E);
  }
  function t(S, E) {
    let _ = { quote: '"', regex: /"/g, escaped: "&quot;" }, T = { quote: "'", regex: /'/g, escaped: "&apos;" }, x = E === "'" ? T : _, $2 = x === T ? _ : T, V = x;
    if (S.includes(x.quote) || S.includes($2.quote)) {
      let z = (S.match(x.regex) || []).length, Y = (S.match($2.regex) || []).length;
      V = z > Y ? $2 : x;
    }
    return V;
  }
  function o(S, E) {
    let _ = S.slice(1, -1), T = E.parser === "json" || E.parser === "json5" && E.quoteProps === "preserve" && !E.singleQuote ? '"' : E.__isInHtmlAttribute ? "'" : t(_, E.singleQuote ? "'" : '"').quote;
    return d2(_, T, !(E.parser === "css" || E.parser === "less" || E.parser === "scss" || E.__embeddedInHtml));
  }
  function d2(S, E, _) {
    let T = E === '"' ? "'" : '"', x = /\\(.)|(["'])/gs, $2 = S.replace(x, (V, z, Y) => z === T ? z : Y === E ? "\\" + Y : Y || (_ && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(z) ? z : "\\" + z));
    return E + $2 + E;
  }
  function h(S) {
    return S.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
  }
  function A(S, E) {
    let _ = S.match(new RegExp(`(${u(E)})+`, "g"));
    return _ === null ? 0 : _.reduce((T, x) => Math.max(T, x.length / E.length), 0);
  }
  function q(S, E) {
    let _ = S.match(new RegExp(`(${u(E)})+`, "g"));
    if (_ === null)
      return 0;
    let T = /* @__PURE__ */ new Map(), x = 0;
    for (let $2 of _) {
      let V = $2.length / E.length;
      T.set(V, true), V > x && (x = V);
    }
    for (let $2 = 1; $2 < x; $2++)
      if (!T.get($2))
        return $2;
    return x + 1;
  }
  function P(S, E) {
    (S.comments || (S.comments = [])).push(E), E.printed = false, E.nodeDescription = J(S);
  }
  function G(S, E) {
    E.leading = true, E.trailing = false, P(S, E);
  }
  function X(S, E, _) {
    E.leading = false, E.trailing = false, _ && (E.marker = _), P(S, E);
  }
  function Q(S, E) {
    E.leading = false, E.trailing = true, P(S, E);
  }
  function H(S, E) {
    let { languages: _ } = D({ plugins: E.plugins }), T = _.find((x) => {
      let { name: $2 } = x;
      return $2.toLowerCase() === S;
    }) || _.find((x) => {
      let { aliases: $2 } = x;
      return Array.isArray($2) && $2.includes(S);
    }) || _.find((x) => {
      let { extensions: $2 } = x;
      return Array.isArray($2) && $2.includes(`.${S}`);
    });
    return T && T.parsers[0];
  }
  function W(S) {
    return S && S.type === "front-matter";
  }
  function K2(S) {
    let E = /* @__PURE__ */ new WeakMap();
    return function(_) {
      return E.has(_) || E.set(_, Symbol(S)), E.get(_);
    };
  }
  function J(S) {
    let E = S.type || S.kind || "(unknown type)", _ = String(S.name || S.id && (typeof S.id == "object" ? S.id.name : S.id) || S.key && (typeof S.key == "object" ? S.key.name : S.key) || S.value && (typeof S.value == "object" ? "" : String(S.value)) || S.operator || "");
    return _.length > 20 && (_ = _.slice(0, 19) + "…"), E + (_ ? " " + _ : "");
  }
  r.exports = { inferParserByLanguage: H, getStringWidth: a, getMaxContinuousCount: A, getMinNotPresentContinuousCount: q, getPenultimate: g2, getLast: n, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: C, getNextNonSpaceNonCommentCharacterIndex: R2, getNextNonSpaceNonCommentCharacter: U2, skip: B, skipWhitespace: f, skipSpaces: c, skipToLineEnd: v2, skipEverythingButNewLine: i, skipInlineComment: l, skipTrailingComment: p, skipNewline: m, isNextLineEmptyAfterIndex: b, isNextLineEmpty: M2, isPreviousLineEmpty: w, hasNewline: O, hasNewlineInRange: F, hasSpaces: k, getAlignmentSize: j, getIndentSize: L, getPreferredQuote: t, printString: o, printNumber: h, makeString: d2, addLeadingComment: G, addDanglingComment: X, addTrailingComment: Q, isFrontMatterNode: W, isNonEmptyArray: s, createGroupIdMapper: K2 };
} }), Tl$1 = I$1({ "vendors/html-tag-names.json"(e, r) {
  r.exports = { htmlTagNames: ["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"] };
} }), gs$1 = I$1({ "src/language-html/utils/array-to-map.js"(e, r) {
  N();
  function u(n) {
    let D = /* @__PURE__ */ Object.create(null);
    for (let s of n)
      D[s] = true;
    return D;
  }
  r.exports = u;
} }), Bl$1 = I$1({ "src/language-html/utils/html-tag-names.js"(e, r) {
  N();
  var { htmlTagNames: u } = Tl$1(), n = gs$1(), D = n(u);
  r.exports = D;
} }), bl$1 = I$1({ "vendors/html-element-attributes.json"(e, r) {
  r.exports = { htmlElementAttributes: { "*": ["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "slot", "spellcheck", "style", "tabindex", "title", "translate"], a: ["charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "target", "type"], applet: ["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"], area: ["alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "target", "type"], audio: ["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"], base: ["href", "target"], basefont: ["color", "face", "size"], blockquote: ["cite"], body: ["alink", "background", "bgcolor", "link", "text", "vlink"], br: ["clear"], button: ["disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "type", "value"], canvas: ["height", "width"], caption: ["align"], col: ["align", "char", "charoff", "span", "valign", "width"], colgroup: ["align", "char", "charoff", "span", "valign", "width"], data: ["value"], del: ["cite", "datetime"], details: ["open"], dialog: ["open"], dir: ["compact"], div: ["align"], dl: ["compact"], embed: ["height", "src", "type", "width"], fieldset: ["disabled", "form", "name"], font: ["color", "face", "size"], form: ["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"], frame: ["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"], frameset: ["cols", "rows"], h1: ["align"], h2: ["align"], h3: ["align"], h4: ["align"], h5: ["align"], h6: ["align"], head: ["profile"], hr: ["align", "noshade", "size", "width"], html: ["manifest", "version"], iframe: ["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"], img: ["align", "alt", "border", "crossorigin", "decoding", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"], input: ["accept", "align", "alt", "autocomplete", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "readonly", "required", "size", "src", "step", "type", "usemap", "value", "width"], ins: ["cite", "datetime"], isindex: ["prompt"], label: ["for", "form"], legend: ["align"], li: ["type", "value"], link: ["as", "charset", "color", "crossorigin", "disabled", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "referrerpolicy", "rel", "rev", "sizes", "target", "type"], map: ["name"], menu: ["compact"], meta: ["charset", "content", "http-equiv", "media", "name", "scheme"], meter: ["high", "low", "max", "min", "optimum", "value"], object: ["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "type", "typemustmatch", "usemap", "vspace", "width"], ol: ["compact", "reversed", "start", "type"], optgroup: ["disabled", "label"], option: ["disabled", "label", "selected", "value"], output: ["for", "form", "name"], p: ["align"], param: ["name", "type", "value", "valuetype"], pre: ["width"], progress: ["max", "value"], q: ["cite"], script: ["async", "charset", "crossorigin", "defer", "integrity", "language", "nomodule", "referrerpolicy", "src", "type"], select: ["autocomplete", "disabled", "form", "multiple", "name", "required", "size"], slot: ["name"], source: ["height", "media", "sizes", "src", "srcset", "type", "width"], style: ["media", "type"], table: ["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"], tbody: ["align", "char", "charoff", "valign"], td: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], textarea: ["autocomplete", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "wrap"], tfoot: ["align", "char", "charoff", "valign"], th: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], thead: ["align", "char", "charoff", "valign"], time: ["datetime"], tr: ["align", "bgcolor", "char", "charoff", "valign"], track: ["default", "kind", "label", "src", "srclang"], ul: ["compact", "type"], video: ["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"] } };
} }), wl$1 = I$1({ "src/language-html/utils/map-object.js"(e, r) {
  N();
  function u(n, D) {
    let s = /* @__PURE__ */ Object.create(null);
    for (let [a, f] of Object.entries(n))
      s[a] = D(f, a);
    return s;
  }
  r.exports = u;
} }), Nl$1 = I$1({ "src/language-html/utils/html-elements-attributes.js"(e, r) {
  N();
  var { htmlElementAttributes: u } = bl$1(), n = wl$1(), D = gs$1(), s = n(u, D);
  r.exports = s;
} }), Ol$1 = I$1({ "src/language-html/utils/is-unknown-namespace.js"(e, r) {
  N();
  function u(n) {
    return n.type === "element" && !n.hasExplicitNamespace && !["html", "svg"].includes(n.namespace);
  }
  r.exports = u;
} }), ql$1 = I$1({ "src/language-html/pragma.js"(e, r) {
  N();
  function u(D) {
    return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(D);
  }
  function n(D) {
    return `<!-- @format -->

` + D.replace(/^\s*\n/, "");
  }
  r.exports = { hasPragma: u, insertPragma: n };
} }), Il$1 = I$1({ "src/language-html/ast.js"(e, r) {
  N();
  var u = { attrs: true, children: true }, n = /* @__PURE__ */ new Set(["parent"]), D = class {
    constructor() {
      let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      for (let f of /* @__PURE__ */ new Set([...n, ...Object.keys(a)]))
        this.setProperty(f, a[f]);
    }
    setProperty(a, f) {
      if (this[a] !== f) {
        if (a in u && (f = f.map((c) => this.createChild(c))), !n.has(a)) {
          this[a] = f;
          return;
        }
        Object.defineProperty(this, a, { value: f, enumerable: false, configurable: true });
      }
    }
    map(a) {
      let f;
      for (let c in u) {
        let v2 = this[c];
        if (v2) {
          let i = s(v2, (l) => l.map(a));
          f !== v2 && (f || (f = new D({ parent: this.parent })), f.setProperty(c, i));
        }
      }
      if (f)
        for (let c in this)
          c in u || (f[c] = this[c]);
      return a(f || this);
    }
    walk(a) {
      for (let f in u) {
        let c = this[f];
        if (c)
          for (let v2 = 0; v2 < c.length; v2++)
            c[v2].walk(a);
      }
      a(this);
    }
    createChild(a) {
      let f = a instanceof D ? a.clone() : new D(a);
      return f.setProperty("parent", this), f;
    }
    insertChildBefore(a, f) {
      this.children.splice(this.children.indexOf(a), 0, this.createChild(f));
    }
    removeChild(a) {
      this.children.splice(this.children.indexOf(a), 1);
    }
    replaceChild(a, f) {
      this.children[this.children.indexOf(a)] = this.createChild(f);
    }
    clone() {
      return new D(this);
    }
    get firstChild() {
      var a;
      return (a = this.children) === null || a === void 0 ? void 0 : a[0];
    }
    get lastChild() {
      var a;
      return (a = this.children) === null || a === void 0 ? void 0 : a[this.children.length - 1];
    }
    get prev() {
      var a;
      return (a = this.parent) === null || a === void 0 ? void 0 : a.children[this.parent.children.indexOf(this) - 1];
    }
    get next() {
      var a;
      return (a = this.parent) === null || a === void 0 ? void 0 : a.children[this.parent.children.indexOf(this) + 1];
    }
    get rawName() {
      return this.hasExplicitNamespace ? this.fullName : this.name;
    }
    get fullName() {
      return this.namespace ? this.namespace + ":" + this.name : this.name;
    }
    get attrMap() {
      return Object.fromEntries(this.attrs.map((a) => [a.fullName, a.value]));
    }
  };
  function s(a, f) {
    let c = a.map(f);
    return c.some((v2, i) => v2 !== a[i]) ? c : a;
  }
  r.exports = { Node: D };
} }), Rl$1 = I$1({ "src/language-html/conditional-comment.js"(e, r) {
  N();
  var { ParseSourceSpan: u } = Ne$1(), n = [{ regex: /^(\[if([^\]]*)]>)(.*?)<!\s*\[endif]$/s, parse: s }, { regex: /^\[if([^\]]*)]><!$/, parse: a }, { regex: /^<!\s*\[endif]$/, parse: f }];
  function D(c, v2) {
    if (c.value)
      for (let { regex: i, parse: l } of n) {
        let p = c.value.match(i);
        if (p)
          return l(c, v2, p);
      }
    return null;
  }
  function s(c, v2, i) {
    let [, l, p, m] = i, C = 4 + l.length, g2 = c.sourceSpan.start.moveBy(C), B = g2.moveBy(m.length), [O, F] = (() => {
      try {
        return [true, v2(m, g2).children];
      } catch {
        return [false, [{ type: "text", value: m, sourceSpan: new u(g2, B) }]];
      }
    })();
    return { type: "ieConditionalComment", complete: O, children: F, condition: p.trim().replace(/\s+/g, " "), sourceSpan: c.sourceSpan, startSourceSpan: new u(c.sourceSpan.start, g2), endSourceSpan: new u(B, c.sourceSpan.end) };
  }
  function a(c, v2, i) {
    let [, l] = i;
    return { type: "ieConditionalStartComment", condition: l.trim().replace(/\s+/g, " "), sourceSpan: c.sourceSpan };
  }
  function f(c) {
    return { type: "ieConditionalEndComment", sourceSpan: c.sourceSpan };
  }
  r.exports = { parseIeConditionalComment: D };
} }), xl$1 = I$1({ "src/language-html/loc.js"(e, r) {
  N();
  function u(D) {
    return D.sourceSpan.start.offset;
  }
  function n(D) {
    return D.sourceSpan.end.offset;
  }
  r.exports = { locStart: u, locEnd: n };
} }), Ze$1 = I$1({ "node_modules/angular-html-parser/lib/compiler/src/ml_parser/tags.js"(e) {
  N(), Object.defineProperty(e, "__esModule", { value: true });
  (function(c) {
    c[c.RAW_TEXT = 0] = "RAW_TEXT", c[c.ESCAPABLE_RAW_TEXT = 1] = "ESCAPABLE_RAW_TEXT", c[c.PARSABLE_DATA = 2] = "PARSABLE_DATA";
  })(e.TagContentType || (e.TagContentType = {}));
  function u(c) {
    if (c[0] != ":")
      return [null, c];
    let v2 = c.indexOf(":", 1);
    if (v2 == -1)
      throw new Error(`Unsupported format "${c}" expecting ":namespace:name"`);
    return [c.slice(1, v2), c.slice(v2 + 1)];
  }
  e.splitNsName = u;
  function n(c) {
    return u(c)[1] === "ng-container";
  }
  e.isNgContainer = n;
  function D(c) {
    return u(c)[1] === "ng-content";
  }
  e.isNgContent = D;
  function s(c) {
    return u(c)[1] === "ng-template";
  }
  e.isNgTemplate = s;
  function a(c) {
    return c === null ? null : u(c)[0];
  }
  e.getNsPrefix = a;
  function f(c, v2) {
    return c ? `:${c}:${v2}` : v2;
  }
  e.mergeNsAndName = f, e.NAMED_ENTITIES = { Aacute: "Á", aacute: "á", Abreve: "Ă", abreve: "ă", ac: "∾", acd: "∿", acE: "∾̳", Acirc: "Â", acirc: "â", acute: "´", Acy: "А", acy: "а", AElig: "Æ", aelig: "æ", af: "⁡", Afr: "𝔄", afr: "𝔞", Agrave: "À", agrave: "à", alefsym: "ℵ", aleph: "ℵ", Alpha: "Α", alpha: "α", Amacr: "Ā", amacr: "ā", amalg: "⨿", AMP: "&", amp: "&", And: "⩓", and: "∧", andand: "⩕", andd: "⩜", andslope: "⩘", andv: "⩚", ang: "∠", ange: "⦤", angle: "∠", angmsd: "∡", angmsdaa: "⦨", angmsdab: "⦩", angmsdac: "⦪", angmsdad: "⦫", angmsdae: "⦬", angmsdaf: "⦭", angmsdag: "⦮", angmsdah: "⦯", angrt: "∟", angrtvb: "⊾", angrtvbd: "⦝", angsph: "∢", angst: "Å", angzarr: "⍼", Aogon: "Ą", aogon: "ą", Aopf: "𝔸", aopf: "𝕒", ap: "≈", apacir: "⩯", apE: "⩰", ape: "≊", apid: "≋", apos: "'", ApplyFunction: "⁡", approx: "≈", approxeq: "≊", Aring: "Å", aring: "å", Ascr: "𝒜", ascr: "𝒶", Assign: "≔", ast: "*", asymp: "≈", asympeq: "≍", Atilde: "Ã", atilde: "ã", Auml: "Ä", auml: "ä", awconint: "∳", awint: "⨑", backcong: "≌", backepsilon: "϶", backprime: "‵", backsim: "∽", backsimeq: "⋍", Backslash: "∖", Barv: "⫧", barvee: "⊽", Barwed: "⌆", barwed: "⌅", barwedge: "⌅", bbrk: "⎵", bbrktbrk: "⎶", bcong: "≌", Bcy: "Б", bcy: "б", bdquo: "„", becaus: "∵", Because: "∵", because: "∵", bemptyv: "⦰", bepsi: "϶", bernou: "ℬ", Bernoullis: "ℬ", Beta: "Β", beta: "β", beth: "ℶ", between: "≬", Bfr: "𝔅", bfr: "𝔟", bigcap: "⋂", bigcirc: "◯", bigcup: "⋃", bigodot: "⨀", bigoplus: "⨁", bigotimes: "⨂", bigsqcup: "⨆", bigstar: "★", bigtriangledown: "▽", bigtriangleup: "△", biguplus: "⨄", bigvee: "⋁", bigwedge: "⋀", bkarow: "⤍", blacklozenge: "⧫", blacksquare: "▪", blacktriangle: "▴", blacktriangledown: "▾", blacktriangleleft: "◂", blacktriangleright: "▸", blank: "␣", blk12: "▒", blk14: "░", blk34: "▓", block: "█", bne: "=⃥", bnequiv: "≡⃥", bNot: "⫭", bnot: "⌐", Bopf: "𝔹", bopf: "𝕓", bot: "⊥", bottom: "⊥", bowtie: "⋈", boxbox: "⧉", boxDL: "╗", boxDl: "╖", boxdL: "╕", boxdl: "┐", boxDR: "╔", boxDr: "╓", boxdR: "╒", boxdr: "┌", boxH: "═", boxh: "─", boxHD: "╦", boxHd: "╤", boxhD: "╥", boxhd: "┬", boxHU: "╩", boxHu: "╧", boxhU: "╨", boxhu: "┴", boxminus: "⊟", boxplus: "⊞", boxtimes: "⊠", boxUL: "╝", boxUl: "╜", boxuL: "╛", boxul: "┘", boxUR: "╚", boxUr: "╙", boxuR: "╘", boxur: "└", boxV: "║", boxv: "│", boxVH: "╬", boxVh: "╫", boxvH: "╪", boxvh: "┼", boxVL: "╣", boxVl: "╢", boxvL: "╡", boxvl: "┤", boxVR: "╠", boxVr: "╟", boxvR: "╞", boxvr: "├", bprime: "‵", Breve: "˘", breve: "˘", brvbar: "¦", Bscr: "ℬ", bscr: "𝒷", bsemi: "⁏", bsim: "∽", bsime: "⋍", bsol: "\\", bsolb: "⧅", bsolhsub: "⟈", bull: "•", bullet: "•", bump: "≎", bumpE: "⪮", bumpe: "≏", Bumpeq: "≎", bumpeq: "≏", Cacute: "Ć", cacute: "ć", Cap: "⋒", cap: "∩", capand: "⩄", capbrcup: "⩉", capcap: "⩋", capcup: "⩇", capdot: "⩀", CapitalDifferentialD: "ⅅ", caps: "∩︀", caret: "⁁", caron: "ˇ", Cayleys: "ℭ", ccaps: "⩍", Ccaron: "Č", ccaron: "č", Ccedil: "Ç", ccedil: "ç", Ccirc: "Ĉ", ccirc: "ĉ", Cconint: "∰", ccups: "⩌", ccupssm: "⩐", Cdot: "Ċ", cdot: "ċ", cedil: "¸", Cedilla: "¸", cemptyv: "⦲", cent: "¢", CenterDot: "·", centerdot: "·", Cfr: "ℭ", cfr: "𝔠", CHcy: "Ч", chcy: "ч", check: "✓", checkmark: "✓", Chi: "Χ", chi: "χ", cir: "○", circ: "ˆ", circeq: "≗", circlearrowleft: "↺", circlearrowright: "↻", circledast: "⊛", circledcirc: "⊚", circleddash: "⊝", CircleDot: "⊙", circledR: "®", circledS: "Ⓢ", CircleMinus: "⊖", CirclePlus: "⊕", CircleTimes: "⊗", cirE: "⧃", cire: "≗", cirfnint: "⨐", cirmid: "⫯", cirscir: "⧂", ClockwiseContourIntegral: "∲", CloseCurlyDoubleQuote: "”", CloseCurlyQuote: "’", clubs: "♣", clubsuit: "♣", Colon: "∷", colon: ":", Colone: "⩴", colone: "≔", coloneq: "≔", comma: ",", commat: "@", comp: "∁", compfn: "∘", complement: "∁", complexes: "ℂ", cong: "≅", congdot: "⩭", Congruent: "≡", Conint: "∯", conint: "∮", ContourIntegral: "∮", Copf: "ℂ", copf: "𝕔", coprod: "∐", Coproduct: "∐", COPY: "©", copy: "©", copysr: "℗", CounterClockwiseContourIntegral: "∳", crarr: "↵", Cross: "⨯", cross: "✗", Cscr: "𝒞", cscr: "𝒸", csub: "⫏", csube: "⫑", csup: "⫐", csupe: "⫒", ctdot: "⋯", cudarrl: "⤸", cudarrr: "⤵", cuepr: "⋞", cuesc: "⋟", cularr: "↶", cularrp: "⤽", Cup: "⋓", cup: "∪", cupbrcap: "⩈", CupCap: "≍", cupcap: "⩆", cupcup: "⩊", cupdot: "⊍", cupor: "⩅", cups: "∪︀", curarr: "↷", curarrm: "⤼", curlyeqprec: "⋞", curlyeqsucc: "⋟", curlyvee: "⋎", curlywedge: "⋏", curren: "¤", curvearrowleft: "↶", curvearrowright: "↷", cuvee: "⋎", cuwed: "⋏", cwconint: "∲", cwint: "∱", cylcty: "⌭", Dagger: "‡", dagger: "†", daleth: "ℸ", Darr: "↡", dArr: "⇓", darr: "↓", dash: "‐", Dashv: "⫤", dashv: "⊣", dbkarow: "⤏", dblac: "˝", Dcaron: "Ď", dcaron: "ď", Dcy: "Д", dcy: "д", DD: "ⅅ", dd: "ⅆ", ddagger: "‡", ddarr: "⇊", DDotrahd: "⤑", ddotseq: "⩷", deg: "°", Del: "∇", Delta: "Δ", delta: "δ", demptyv: "⦱", dfisht: "⥿", Dfr: "𝔇", dfr: "𝔡", dHar: "⥥", dharl: "⇃", dharr: "⇂", DiacriticalAcute: "´", DiacriticalDot: "˙", DiacriticalDoubleAcute: "˝", DiacriticalGrave: "`", DiacriticalTilde: "˜", diam: "⋄", Diamond: "⋄", diamond: "⋄", diamondsuit: "♦", diams: "♦", die: "¨", DifferentialD: "ⅆ", digamma: "ϝ", disin: "⋲", div: "÷", divide: "÷", divideontimes: "⋇", divonx: "⋇", DJcy: "Ђ", djcy: "ђ", dlcorn: "⌞", dlcrop: "⌍", dollar: "$", Dopf: "𝔻", dopf: "𝕕", Dot: "¨", dot: "˙", DotDot: "⃜", doteq: "≐", doteqdot: "≑", DotEqual: "≐", dotminus: "∸", dotplus: "∔", dotsquare: "⊡", doublebarwedge: "⌆", DoubleContourIntegral: "∯", DoubleDot: "¨", DoubleDownArrow: "⇓", DoubleLeftArrow: "⇐", DoubleLeftRightArrow: "⇔", DoubleLeftTee: "⫤", DoubleLongLeftArrow: "⟸", DoubleLongLeftRightArrow: "⟺", DoubleLongRightArrow: "⟹", DoubleRightArrow: "⇒", DoubleRightTee: "⊨", DoubleUpArrow: "⇑", DoubleUpDownArrow: "⇕", DoubleVerticalBar: "∥", DownArrow: "↓", Downarrow: "⇓", downarrow: "↓", DownArrowBar: "⤓", DownArrowUpArrow: "⇵", DownBreve: "̑", downdownarrows: "⇊", downharpoonleft: "⇃", downharpoonright: "⇂", DownLeftRightVector: "⥐", DownLeftTeeVector: "⥞", DownLeftVector: "↽", DownLeftVectorBar: "⥖", DownRightTeeVector: "⥟", DownRightVector: "⇁", DownRightVectorBar: "⥗", DownTee: "⊤", DownTeeArrow: "↧", drbkarow: "⤐", drcorn: "⌟", drcrop: "⌌", Dscr: "𝒟", dscr: "𝒹", DScy: "Ѕ", dscy: "ѕ", dsol: "⧶", Dstrok: "Đ", dstrok: "đ", dtdot: "⋱", dtri: "▿", dtrif: "▾", duarr: "⇵", duhar: "⥯", dwangle: "⦦", DZcy: "Џ", dzcy: "џ", dzigrarr: "⟿", Eacute: "É", eacute: "é", easter: "⩮", Ecaron: "Ě", ecaron: "ě", ecir: "≖", Ecirc: "Ê", ecirc: "ê", ecolon: "≕", Ecy: "Э", ecy: "э", eDDot: "⩷", Edot: "Ė", eDot: "≑", edot: "ė", ee: "ⅇ", efDot: "≒", Efr: "𝔈", efr: "𝔢", eg: "⪚", Egrave: "È", egrave: "è", egs: "⪖", egsdot: "⪘", el: "⪙", Element: "∈", elinters: "⏧", ell: "ℓ", els: "⪕", elsdot: "⪗", Emacr: "Ē", emacr: "ē", empty: "∅", emptyset: "∅", EmptySmallSquare: "◻", emptyv: "∅", EmptyVerySmallSquare: "▫", emsp: " ", emsp13: " ", emsp14: " ", ENG: "Ŋ", eng: "ŋ", ensp: " ", Eogon: "Ę", eogon: "ę", Eopf: "𝔼", eopf: "𝕖", epar: "⋕", eparsl: "⧣", eplus: "⩱", epsi: "ε", Epsilon: "Ε", epsilon: "ε", epsiv: "ϵ", eqcirc: "≖", eqcolon: "≕", eqsim: "≂", eqslantgtr: "⪖", eqslantless: "⪕", Equal: "⩵", equals: "=", EqualTilde: "≂", equest: "≟", Equilibrium: "⇌", equiv: "≡", equivDD: "⩸", eqvparsl: "⧥", erarr: "⥱", erDot: "≓", Escr: "ℰ", escr: "ℯ", esdot: "≐", Esim: "⩳", esim: "≂", Eta: "Η", eta: "η", ETH: "Ð", eth: "ð", Euml: "Ë", euml: "ë", euro: "€", excl: "!", exist: "∃", Exists: "∃", expectation: "ℰ", ExponentialE: "ⅇ", exponentiale: "ⅇ", fallingdotseq: "≒", Fcy: "Ф", fcy: "ф", female: "♀", ffilig: "ﬃ", fflig: "ﬀ", ffllig: "ﬄ", Ffr: "𝔉", ffr: "𝔣", filig: "ﬁ", FilledSmallSquare: "◼", FilledVerySmallSquare: "▪", fjlig: "fj", flat: "♭", fllig: "ﬂ", fltns: "▱", fnof: "ƒ", Fopf: "𝔽", fopf: "𝕗", ForAll: "∀", forall: "∀", fork: "⋔", forkv: "⫙", Fouriertrf: "ℱ", fpartint: "⨍", frac12: "½", frac13: "⅓", frac14: "¼", frac15: "⅕", frac16: "⅙", frac18: "⅛", frac23: "⅔", frac25: "⅖", frac34: "¾", frac35: "⅗", frac38: "⅜", frac45: "⅘", frac56: "⅚", frac58: "⅝", frac78: "⅞", frasl: "⁄", frown: "⌢", Fscr: "ℱ", fscr: "𝒻", gacute: "ǵ", Gamma: "Γ", gamma: "γ", Gammad: "Ϝ", gammad: "ϝ", gap: "⪆", Gbreve: "Ğ", gbreve: "ğ", Gcedil: "Ģ", Gcirc: "Ĝ", gcirc: "ĝ", Gcy: "Г", gcy: "г", Gdot: "Ġ", gdot: "ġ", gE: "≧", ge: "≥", gEl: "⪌", gel: "⋛", geq: "≥", geqq: "≧", geqslant: "⩾", ges: "⩾", gescc: "⪩", gesdot: "⪀", gesdoto: "⪂", gesdotol: "⪄", gesl: "⋛︀", gesles: "⪔", Gfr: "𝔊", gfr: "𝔤", Gg: "⋙", gg: "≫", ggg: "⋙", gimel: "ℷ", GJcy: "Ѓ", gjcy: "ѓ", gl: "≷", gla: "⪥", glE: "⪒", glj: "⪤", gnap: "⪊", gnapprox: "⪊", gnE: "≩", gne: "⪈", gneq: "⪈", gneqq: "≩", gnsim: "⋧", Gopf: "𝔾", gopf: "𝕘", grave: "`", GreaterEqual: "≥", GreaterEqualLess: "⋛", GreaterFullEqual: "≧", GreaterGreater: "⪢", GreaterLess: "≷", GreaterSlantEqual: "⩾", GreaterTilde: "≳", Gscr: "𝒢", gscr: "ℊ", gsim: "≳", gsime: "⪎", gsiml: "⪐", GT: ">", Gt: "≫", gt: ">", gtcc: "⪧", gtcir: "⩺", gtdot: "⋗", gtlPar: "⦕", gtquest: "⩼", gtrapprox: "⪆", gtrarr: "⥸", gtrdot: "⋗", gtreqless: "⋛", gtreqqless: "⪌", gtrless: "≷", gtrsim: "≳", gvertneqq: "≩︀", gvnE: "≩︀", Hacek: "ˇ", hairsp: " ", half: "½", hamilt: "ℋ", HARDcy: "Ъ", hardcy: "ъ", hArr: "⇔", harr: "↔", harrcir: "⥈", harrw: "↭", Hat: "^", hbar: "ℏ", Hcirc: "Ĥ", hcirc: "ĥ", hearts: "♥", heartsuit: "♥", hellip: "…", hercon: "⊹", Hfr: "ℌ", hfr: "𝔥", HilbertSpace: "ℋ", hksearow: "⤥", hkswarow: "⤦", hoarr: "⇿", homtht: "∻", hookleftarrow: "↩", hookrightarrow: "↪", Hopf: "ℍ", hopf: "𝕙", horbar: "―", HorizontalLine: "─", Hscr: "ℋ", hscr: "𝒽", hslash: "ℏ", Hstrok: "Ħ", hstrok: "ħ", HumpDownHump: "≎", HumpEqual: "≏", hybull: "⁃", hyphen: "‐", Iacute: "Í", iacute: "í", ic: "⁣", Icirc: "Î", icirc: "î", Icy: "И", icy: "и", Idot: "İ", IEcy: "Е", iecy: "е", iexcl: "¡", iff: "⇔", Ifr: "ℑ", ifr: "𝔦", Igrave: "Ì", igrave: "ì", ii: "ⅈ", iiiint: "⨌", iiint: "∭", iinfin: "⧜", iiota: "℩", IJlig: "Ĳ", ijlig: "ĳ", Im: "ℑ", Imacr: "Ī", imacr: "ī", image: "ℑ", ImaginaryI: "ⅈ", imagline: "ℐ", imagpart: "ℑ", imath: "ı", imof: "⊷", imped: "Ƶ", Implies: "⇒", in: "∈", incare: "℅", infin: "∞", infintie: "⧝", inodot: "ı", Int: "∬", int: "∫", intcal: "⊺", integers: "ℤ", Integral: "∫", intercal: "⊺", Intersection: "⋂", intlarhk: "⨗", intprod: "⨼", InvisibleComma: "⁣", InvisibleTimes: "⁢", IOcy: "Ё", iocy: "ё", Iogon: "Į", iogon: "į", Iopf: "𝕀", iopf: "𝕚", Iota: "Ι", iota: "ι", iprod: "⨼", iquest: "¿", Iscr: "ℐ", iscr: "𝒾", isin: "∈", isindot: "⋵", isinE: "⋹", isins: "⋴", isinsv: "⋳", isinv: "∈", it: "⁢", Itilde: "Ĩ", itilde: "ĩ", Iukcy: "І", iukcy: "і", Iuml: "Ï", iuml: "ï", Jcirc: "Ĵ", jcirc: "ĵ", Jcy: "Й", jcy: "й", Jfr: "𝔍", jfr: "𝔧", jmath: "ȷ", Jopf: "𝕁", jopf: "𝕛", Jscr: "𝒥", jscr: "𝒿", Jsercy: "Ј", jsercy: "ј", Jukcy: "Є", jukcy: "є", Kappa: "Κ", kappa: "κ", kappav: "ϰ", Kcedil: "Ķ", kcedil: "ķ", Kcy: "К", kcy: "к", Kfr: "𝔎", kfr: "𝔨", kgreen: "ĸ", KHcy: "Х", khcy: "х", KJcy: "Ќ", kjcy: "ќ", Kopf: "𝕂", kopf: "𝕜", Kscr: "𝒦", kscr: "𝓀", lAarr: "⇚", Lacute: "Ĺ", lacute: "ĺ", laemptyv: "⦴", lagran: "ℒ", Lambda: "Λ", lambda: "λ", Lang: "⟪", lang: "⟨", langd: "⦑", langle: "⟨", lap: "⪅", Laplacetrf: "ℒ", laquo: "«", Larr: "↞", lArr: "⇐", larr: "←", larrb: "⇤", larrbfs: "⤟", larrfs: "⤝", larrhk: "↩", larrlp: "↫", larrpl: "⤹", larrsim: "⥳", larrtl: "↢", lat: "⪫", lAtail: "⤛", latail: "⤙", late: "⪭", lates: "⪭︀", lBarr: "⤎", lbarr: "⤌", lbbrk: "❲", lbrace: "{", lbrack: "[", lbrke: "⦋", lbrksld: "⦏", lbrkslu: "⦍", Lcaron: "Ľ", lcaron: "ľ", Lcedil: "Ļ", lcedil: "ļ", lceil: "⌈", lcub: "{", Lcy: "Л", lcy: "л", ldca: "⤶", ldquo: "“", ldquor: "„", ldrdhar: "⥧", ldrushar: "⥋", ldsh: "↲", lE: "≦", le: "≤", LeftAngleBracket: "⟨", LeftArrow: "←", Leftarrow: "⇐", leftarrow: "←", LeftArrowBar: "⇤", LeftArrowRightArrow: "⇆", leftarrowtail: "↢", LeftCeiling: "⌈", LeftDoubleBracket: "⟦", LeftDownTeeVector: "⥡", LeftDownVector: "⇃", LeftDownVectorBar: "⥙", LeftFloor: "⌊", leftharpoondown: "↽", leftharpoonup: "↼", leftleftarrows: "⇇", LeftRightArrow: "↔", Leftrightarrow: "⇔", leftrightarrow: "↔", leftrightarrows: "⇆", leftrightharpoons: "⇋", leftrightsquigarrow: "↭", LeftRightVector: "⥎", LeftTee: "⊣", LeftTeeArrow: "↤", LeftTeeVector: "⥚", leftthreetimes: "⋋", LeftTriangle: "⊲", LeftTriangleBar: "⧏", LeftTriangleEqual: "⊴", LeftUpDownVector: "⥑", LeftUpTeeVector: "⥠", LeftUpVector: "↿", LeftUpVectorBar: "⥘", LeftVector: "↼", LeftVectorBar: "⥒", lEg: "⪋", leg: "⋚", leq: "≤", leqq: "≦", leqslant: "⩽", les: "⩽", lescc: "⪨", lesdot: "⩿", lesdoto: "⪁", lesdotor: "⪃", lesg: "⋚︀", lesges: "⪓", lessapprox: "⪅", lessdot: "⋖", lesseqgtr: "⋚", lesseqqgtr: "⪋", LessEqualGreater: "⋚", LessFullEqual: "≦", LessGreater: "≶", lessgtr: "≶", LessLess: "⪡", lesssim: "≲", LessSlantEqual: "⩽", LessTilde: "≲", lfisht: "⥼", lfloor: "⌊", Lfr: "𝔏", lfr: "𝔩", lg: "≶", lgE: "⪑", lHar: "⥢", lhard: "↽", lharu: "↼", lharul: "⥪", lhblk: "▄", LJcy: "Љ", ljcy: "љ", Ll: "⋘", ll: "≪", llarr: "⇇", llcorner: "⌞", Lleftarrow: "⇚", llhard: "⥫", lltri: "◺", Lmidot: "Ŀ", lmidot: "ŀ", lmoust: "⎰", lmoustache: "⎰", lnap: "⪉", lnapprox: "⪉", lnE: "≨", lne: "⪇", lneq: "⪇", lneqq: "≨", lnsim: "⋦", loang: "⟬", loarr: "⇽", lobrk: "⟦", LongLeftArrow: "⟵", Longleftarrow: "⟸", longleftarrow: "⟵", LongLeftRightArrow: "⟷", Longleftrightarrow: "⟺", longleftrightarrow: "⟷", longmapsto: "⟼", LongRightArrow: "⟶", Longrightarrow: "⟹", longrightarrow: "⟶", looparrowleft: "↫", looparrowright: "↬", lopar: "⦅", Lopf: "𝕃", lopf: "𝕝", loplus: "⨭", lotimes: "⨴", lowast: "∗", lowbar: "_", LowerLeftArrow: "↙", LowerRightArrow: "↘", loz: "◊", lozenge: "◊", lozf: "⧫", lpar: "(", lparlt: "⦓", lrarr: "⇆", lrcorner: "⌟", lrhar: "⇋", lrhard: "⥭", lrm: "‎", lrtri: "⊿", lsaquo: "‹", Lscr: "ℒ", lscr: "𝓁", Lsh: "↰", lsh: "↰", lsim: "≲", lsime: "⪍", lsimg: "⪏", lsqb: "[", lsquo: "‘", lsquor: "‚", Lstrok: "Ł", lstrok: "ł", LT: "<", Lt: "≪", lt: "<", ltcc: "⪦", ltcir: "⩹", ltdot: "⋖", lthree: "⋋", ltimes: "⋉", ltlarr: "⥶", ltquest: "⩻", ltri: "◃", ltrie: "⊴", ltrif: "◂", ltrPar: "⦖", lurdshar: "⥊", luruhar: "⥦", lvertneqq: "≨︀", lvnE: "≨︀", macr: "¯", male: "♂", malt: "✠", maltese: "✠", Map: "⤅", map: "↦", mapsto: "↦", mapstodown: "↧", mapstoleft: "↤", mapstoup: "↥", marker: "▮", mcomma: "⨩", Mcy: "М", mcy: "м", mdash: "—", mDDot: "∺", measuredangle: "∡", MediumSpace: " ", Mellintrf: "ℳ", Mfr: "𝔐", mfr: "𝔪", mho: "℧", micro: "µ", mid: "∣", midast: "*", midcir: "⫰", middot: "·", minus: "−", minusb: "⊟", minusd: "∸", minusdu: "⨪", MinusPlus: "∓", mlcp: "⫛", mldr: "…", mnplus: "∓", models: "⊧", Mopf: "𝕄", mopf: "𝕞", mp: "∓", Mscr: "ℳ", mscr: "𝓂", mstpos: "∾", Mu: "Μ", mu: "μ", multimap: "⊸", mumap: "⊸", nabla: "∇", Nacute: "Ń", nacute: "ń", nang: "∠⃒", nap: "≉", napE: "⩰̸", napid: "≋̸", napos: "ŉ", napprox: "≉", natur: "♮", natural: "♮", naturals: "ℕ", nbsp: " ", nbump: "≎̸", nbumpe: "≏̸", ncap: "⩃", Ncaron: "Ň", ncaron: "ň", Ncedil: "Ņ", ncedil: "ņ", ncong: "≇", ncongdot: "⩭̸", ncup: "⩂", Ncy: "Н", ncy: "н", ndash: "–", ne: "≠", nearhk: "⤤", neArr: "⇗", nearr: "↗", nearrow: "↗", nedot: "≐̸", NegativeMediumSpace: "​", NegativeThickSpace: "​", NegativeThinSpace: "​", NegativeVeryThinSpace: "​", nequiv: "≢", nesear: "⤨", nesim: "≂̸", NestedGreaterGreater: "≫", NestedLessLess: "≪", NewLine: `
`, nexist: "∄", nexists: "∄", Nfr: "𝔑", nfr: "𝔫", ngE: "≧̸", nge: "≱", ngeq: "≱", ngeqq: "≧̸", ngeqslant: "⩾̸", nges: "⩾̸", nGg: "⋙̸", ngsim: "≵", nGt: "≫⃒", ngt: "≯", ngtr: "≯", nGtv: "≫̸", nhArr: "⇎", nharr: "↮", nhpar: "⫲", ni: "∋", nis: "⋼", nisd: "⋺", niv: "∋", NJcy: "Њ", njcy: "њ", nlArr: "⇍", nlarr: "↚", nldr: "‥", nlE: "≦̸", nle: "≰", nLeftarrow: "⇍", nleftarrow: "↚", nLeftrightarrow: "⇎", nleftrightarrow: "↮", nleq: "≰", nleqq: "≦̸", nleqslant: "⩽̸", nles: "⩽̸", nless: "≮", nLl: "⋘̸", nlsim: "≴", nLt: "≪⃒", nlt: "≮", nltri: "⋪", nltrie: "⋬", nLtv: "≪̸", nmid: "∤", NoBreak: "⁠", NonBreakingSpace: " ", Nopf: "ℕ", nopf: "𝕟", Not: "⫬", not: "¬", NotCongruent: "≢", NotCupCap: "≭", NotDoubleVerticalBar: "∦", NotElement: "∉", NotEqual: "≠", NotEqualTilde: "≂̸", NotExists: "∄", NotGreater: "≯", NotGreaterEqual: "≱", NotGreaterFullEqual: "≧̸", NotGreaterGreater: "≫̸", NotGreaterLess: "≹", NotGreaterSlantEqual: "⩾̸", NotGreaterTilde: "≵", NotHumpDownHump: "≎̸", NotHumpEqual: "≏̸", notin: "∉", notindot: "⋵̸", notinE: "⋹̸", notinva: "∉", notinvb: "⋷", notinvc: "⋶", NotLeftTriangle: "⋪", NotLeftTriangleBar: "⧏̸", NotLeftTriangleEqual: "⋬", NotLess: "≮", NotLessEqual: "≰", NotLessGreater: "≸", NotLessLess: "≪̸", NotLessSlantEqual: "⩽̸", NotLessTilde: "≴", NotNestedGreaterGreater: "⪢̸", NotNestedLessLess: "⪡̸", notni: "∌", notniva: "∌", notnivb: "⋾", notnivc: "⋽", NotPrecedes: "⊀", NotPrecedesEqual: "⪯̸", NotPrecedesSlantEqual: "⋠", NotReverseElement: "∌", NotRightTriangle: "⋫", NotRightTriangleBar: "⧐̸", NotRightTriangleEqual: "⋭", NotSquareSubset: "⊏̸", NotSquareSubsetEqual: "⋢", NotSquareSuperset: "⊐̸", NotSquareSupersetEqual: "⋣", NotSubset: "⊂⃒", NotSubsetEqual: "⊈", NotSucceeds: "⊁", NotSucceedsEqual: "⪰̸", NotSucceedsSlantEqual: "⋡", NotSucceedsTilde: "≿̸", NotSuperset: "⊃⃒", NotSupersetEqual: "⊉", NotTilde: "≁", NotTildeEqual: "≄", NotTildeFullEqual: "≇", NotTildeTilde: "≉", NotVerticalBar: "∤", npar: "∦", nparallel: "∦", nparsl: "⫽⃥", npart: "∂̸", npolint: "⨔", npr: "⊀", nprcue: "⋠", npre: "⪯̸", nprec: "⊀", npreceq: "⪯̸", nrArr: "⇏", nrarr: "↛", nrarrc: "⤳̸", nrarrw: "↝̸", nRightarrow: "⇏", nrightarrow: "↛", nrtri: "⋫", nrtrie: "⋭", nsc: "⊁", nsccue: "⋡", nsce: "⪰̸", Nscr: "𝒩", nscr: "𝓃", nshortmid: "∤", nshortparallel: "∦", nsim: "≁", nsime: "≄", nsimeq: "≄", nsmid: "∤", nspar: "∦", nsqsube: "⋢", nsqsupe: "⋣", nsub: "⊄", nsubE: "⫅̸", nsube: "⊈", nsubset: "⊂⃒", nsubseteq: "⊈", nsubseteqq: "⫅̸", nsucc: "⊁", nsucceq: "⪰̸", nsup: "⊅", nsupE: "⫆̸", nsupe: "⊉", nsupset: "⊃⃒", nsupseteq: "⊉", nsupseteqq: "⫆̸", ntgl: "≹", Ntilde: "Ñ", ntilde: "ñ", ntlg: "≸", ntriangleleft: "⋪", ntrianglelefteq: "⋬", ntriangleright: "⋫", ntrianglerighteq: "⋭", Nu: "Ν", nu: "ν", num: "#", numero: "№", numsp: " ", nvap: "≍⃒", nVDash: "⊯", nVdash: "⊮", nvDash: "⊭", nvdash: "⊬", nvge: "≥⃒", nvgt: ">⃒", nvHarr: "⤄", nvinfin: "⧞", nvlArr: "⤂", nvle: "≤⃒", nvlt: "<⃒", nvltrie: "⊴⃒", nvrArr: "⤃", nvrtrie: "⊵⃒", nvsim: "∼⃒", nwarhk: "⤣", nwArr: "⇖", nwarr: "↖", nwarrow: "↖", nwnear: "⤧", Oacute: "Ó", oacute: "ó", oast: "⊛", ocir: "⊚", Ocirc: "Ô", ocirc: "ô", Ocy: "О", ocy: "о", odash: "⊝", Odblac: "Ő", odblac: "ő", odiv: "⨸", odot: "⊙", odsold: "⦼", OElig: "Œ", oelig: "œ", ofcir: "⦿", Ofr: "𝔒", ofr: "𝔬", ogon: "˛", Ograve: "Ò", ograve: "ò", ogt: "⧁", ohbar: "⦵", ohm: "Ω", oint: "∮", olarr: "↺", olcir: "⦾", olcross: "⦻", oline: "‾", olt: "⧀", Omacr: "Ō", omacr: "ō", Omega: "Ω", omega: "ω", Omicron: "Ο", omicron: "ο", omid: "⦶", ominus: "⊖", Oopf: "𝕆", oopf: "𝕠", opar: "⦷", OpenCurlyDoubleQuote: "“", OpenCurlyQuote: "‘", operp: "⦹", oplus: "⊕", Or: "⩔", or: "∨", orarr: "↻", ord: "⩝", order: "ℴ", orderof: "ℴ", ordf: "ª", ordm: "º", origof: "⊶", oror: "⩖", orslope: "⩗", orv: "⩛", oS: "Ⓢ", Oscr: "𝒪", oscr: "ℴ", Oslash: "Ø", oslash: "ø", osol: "⊘", Otilde: "Õ", otilde: "õ", Otimes: "⨷", otimes: "⊗", otimesas: "⨶", Ouml: "Ö", ouml: "ö", ovbar: "⌽", OverBar: "‾", OverBrace: "⏞", OverBracket: "⎴", OverParenthesis: "⏜", par: "∥", para: "¶", parallel: "∥", parsim: "⫳", parsl: "⫽", part: "∂", PartialD: "∂", Pcy: "П", pcy: "п", percnt: "%", period: ".", permil: "‰", perp: "⊥", pertenk: "‱", Pfr: "𝔓", pfr: "𝔭", Phi: "Φ", phi: "φ", phiv: "ϕ", phmmat: "ℳ", phone: "☎", Pi: "Π", pi: "π", pitchfork: "⋔", piv: "ϖ", planck: "ℏ", planckh: "ℎ", plankv: "ℏ", plus: "+", plusacir: "⨣", plusb: "⊞", pluscir: "⨢", plusdo: "∔", plusdu: "⨥", pluse: "⩲", PlusMinus: "±", plusmn: "±", plussim: "⨦", plustwo: "⨧", pm: "±", Poincareplane: "ℌ", pointint: "⨕", Popf: "ℙ", popf: "𝕡", pound: "£", Pr: "⪻", pr: "≺", prap: "⪷", prcue: "≼", prE: "⪳", pre: "⪯", prec: "≺", precapprox: "⪷", preccurlyeq: "≼", Precedes: "≺", PrecedesEqual: "⪯", PrecedesSlantEqual: "≼", PrecedesTilde: "≾", preceq: "⪯", precnapprox: "⪹", precneqq: "⪵", precnsim: "⋨", precsim: "≾", Prime: "″", prime: "′", primes: "ℙ", prnap: "⪹", prnE: "⪵", prnsim: "⋨", prod: "∏", Product: "∏", profalar: "⌮", profline: "⌒", profsurf: "⌓", prop: "∝", Proportion: "∷", Proportional: "∝", propto: "∝", prsim: "≾", prurel: "⊰", Pscr: "𝒫", pscr: "𝓅", Psi: "Ψ", psi: "ψ", puncsp: " ", Qfr: "𝔔", qfr: "𝔮", qint: "⨌", Qopf: "ℚ", qopf: "𝕢", qprime: "⁗", Qscr: "𝒬", qscr: "𝓆", quaternions: "ℍ", quatint: "⨖", quest: "?", questeq: "≟", QUOT: '"', quot: '"', rAarr: "⇛", race: "∽̱", Racute: "Ŕ", racute: "ŕ", radic: "√", raemptyv: "⦳", Rang: "⟫", rang: "⟩", rangd: "⦒", range: "⦥", rangle: "⟩", raquo: "»", Rarr: "↠", rArr: "⇒", rarr: "→", rarrap: "⥵", rarrb: "⇥", rarrbfs: "⤠", rarrc: "⤳", rarrfs: "⤞", rarrhk: "↪", rarrlp: "↬", rarrpl: "⥅", rarrsim: "⥴", Rarrtl: "⤖", rarrtl: "↣", rarrw: "↝", rAtail: "⤜", ratail: "⤚", ratio: "∶", rationals: "ℚ", RBarr: "⤐", rBarr: "⤏", rbarr: "⤍", rbbrk: "❳", rbrace: "}", rbrack: "]", rbrke: "⦌", rbrksld: "⦎", rbrkslu: "⦐", Rcaron: "Ř", rcaron: "ř", Rcedil: "Ŗ", rcedil: "ŗ", rceil: "⌉", rcub: "}", Rcy: "Р", rcy: "р", rdca: "⤷", rdldhar: "⥩", rdquo: "”", rdquor: "”", rdsh: "↳", Re: "ℜ", real: "ℜ", realine: "ℛ", realpart: "ℜ", reals: "ℝ", rect: "▭", REG: "®", reg: "®", ReverseElement: "∋", ReverseEquilibrium: "⇋", ReverseUpEquilibrium: "⥯", rfisht: "⥽", rfloor: "⌋", Rfr: "ℜ", rfr: "𝔯", rHar: "⥤", rhard: "⇁", rharu: "⇀", rharul: "⥬", Rho: "Ρ", rho: "ρ", rhov: "ϱ", RightAngleBracket: "⟩", RightArrow: "→", Rightarrow: "⇒", rightarrow: "→", RightArrowBar: "⇥", RightArrowLeftArrow: "⇄", rightarrowtail: "↣", RightCeiling: "⌉", RightDoubleBracket: "⟧", RightDownTeeVector: "⥝", RightDownVector: "⇂", RightDownVectorBar: "⥕", RightFloor: "⌋", rightharpoondown: "⇁", rightharpoonup: "⇀", rightleftarrows: "⇄", rightleftharpoons: "⇌", rightrightarrows: "⇉", rightsquigarrow: "↝", RightTee: "⊢", RightTeeArrow: "↦", RightTeeVector: "⥛", rightthreetimes: "⋌", RightTriangle: "⊳", RightTriangleBar: "⧐", RightTriangleEqual: "⊵", RightUpDownVector: "⥏", RightUpTeeVector: "⥜", RightUpVector: "↾", RightUpVectorBar: "⥔", RightVector: "⇀", RightVectorBar: "⥓", ring: "˚", risingdotseq: "≓", rlarr: "⇄", rlhar: "⇌", rlm: "‏", rmoust: "⎱", rmoustache: "⎱", rnmid: "⫮", roang: "⟭", roarr: "⇾", robrk: "⟧", ropar: "⦆", Ropf: "ℝ", ropf: "𝕣", roplus: "⨮", rotimes: "⨵", RoundImplies: "⥰", rpar: ")", rpargt: "⦔", rppolint: "⨒", rrarr: "⇉", Rrightarrow: "⇛", rsaquo: "›", Rscr: "ℛ", rscr: "𝓇", Rsh: "↱", rsh: "↱", rsqb: "]", rsquo: "’", rsquor: "’", rthree: "⋌", rtimes: "⋊", rtri: "▹", rtrie: "⊵", rtrif: "▸", rtriltri: "⧎", RuleDelayed: "⧴", ruluhar: "⥨", rx: "℞", Sacute: "Ś", sacute: "ś", sbquo: "‚", Sc: "⪼", sc: "≻", scap: "⪸", Scaron: "Š", scaron: "š", sccue: "≽", scE: "⪴", sce: "⪰", Scedil: "Ş", scedil: "ş", Scirc: "Ŝ", scirc: "ŝ", scnap: "⪺", scnE: "⪶", scnsim: "⋩", scpolint: "⨓", scsim: "≿", Scy: "С", scy: "с", sdot: "⋅", sdotb: "⊡", sdote: "⩦", searhk: "⤥", seArr: "⇘", searr: "↘", searrow: "↘", sect: "§", semi: ";", seswar: "⤩", setminus: "∖", setmn: "∖", sext: "✶", Sfr: "𝔖", sfr: "𝔰", sfrown: "⌢", sharp: "♯", SHCHcy: "Щ", shchcy: "щ", SHcy: "Ш", shcy: "ш", ShortDownArrow: "↓", ShortLeftArrow: "←", shortmid: "∣", shortparallel: "∥", ShortRightArrow: "→", ShortUpArrow: "↑", shy: "­", Sigma: "Σ", sigma: "σ", sigmaf: "ς", sigmav: "ς", sim: "∼", simdot: "⩪", sime: "≃", simeq: "≃", simg: "⪞", simgE: "⪠", siml: "⪝", simlE: "⪟", simne: "≆", simplus: "⨤", simrarr: "⥲", slarr: "←", SmallCircle: "∘", smallsetminus: "∖", smashp: "⨳", smeparsl: "⧤", smid: "∣", smile: "⌣", smt: "⪪", smte: "⪬", smtes: "⪬︀", SOFTcy: "Ь", softcy: "ь", sol: "/", solb: "⧄", solbar: "⌿", Sopf: "𝕊", sopf: "𝕤", spades: "♠", spadesuit: "♠", spar: "∥", sqcap: "⊓", sqcaps: "⊓︀", sqcup: "⊔", sqcups: "⊔︀", Sqrt: "√", sqsub: "⊏", sqsube: "⊑", sqsubset: "⊏", sqsubseteq: "⊑", sqsup: "⊐", sqsupe: "⊒", sqsupset: "⊐", sqsupseteq: "⊒", squ: "□", Square: "□", square: "□", SquareIntersection: "⊓", SquareSubset: "⊏", SquareSubsetEqual: "⊑", SquareSuperset: "⊐", SquareSupersetEqual: "⊒", SquareUnion: "⊔", squarf: "▪", squf: "▪", srarr: "→", Sscr: "𝒮", sscr: "𝓈", ssetmn: "∖", ssmile: "⌣", sstarf: "⋆", Star: "⋆", star: "☆", starf: "★", straightepsilon: "ϵ", straightphi: "ϕ", strns: "¯", Sub: "⋐", sub: "⊂", subdot: "⪽", subE: "⫅", sube: "⊆", subedot: "⫃", submult: "⫁", subnE: "⫋", subne: "⊊", subplus: "⪿", subrarr: "⥹", Subset: "⋐", subset: "⊂", subseteq: "⊆", subseteqq: "⫅", SubsetEqual: "⊆", subsetneq: "⊊", subsetneqq: "⫋", subsim: "⫇", subsub: "⫕", subsup: "⫓", succ: "≻", succapprox: "⪸", succcurlyeq: "≽", Succeeds: "≻", SucceedsEqual: "⪰", SucceedsSlantEqual: "≽", SucceedsTilde: "≿", succeq: "⪰", succnapprox: "⪺", succneqq: "⪶", succnsim: "⋩", succsim: "≿", SuchThat: "∋", Sum: "∑", sum: "∑", sung: "♪", Sup: "⋑", sup: "⊃", sup1: "¹", sup2: "²", sup3: "³", supdot: "⪾", supdsub: "⫘", supE: "⫆", supe: "⊇", supedot: "⫄", Superset: "⊃", SupersetEqual: "⊇", suphsol: "⟉", suphsub: "⫗", suplarr: "⥻", supmult: "⫂", supnE: "⫌", supne: "⊋", supplus: "⫀", Supset: "⋑", supset: "⊃", supseteq: "⊇", supseteqq: "⫆", supsetneq: "⊋", supsetneqq: "⫌", supsim: "⫈", supsub: "⫔", supsup: "⫖", swarhk: "⤦", swArr: "⇙", swarr: "↙", swarrow: "↙", swnwar: "⤪", szlig: "ß", Tab: "	", target: "⌖", Tau: "Τ", tau: "τ", tbrk: "⎴", Tcaron: "Ť", tcaron: "ť", Tcedil: "Ţ", tcedil: "ţ", Tcy: "Т", tcy: "т", tdot: "⃛", telrec: "⌕", Tfr: "𝔗", tfr: "𝔱", there4: "∴", Therefore: "∴", therefore: "∴", Theta: "Θ", theta: "θ", thetasym: "ϑ", thetav: "ϑ", thickapprox: "≈", thicksim: "∼", ThickSpace: "  ", thinsp: " ", ThinSpace: " ", thkap: "≈", thksim: "∼", THORN: "Þ", thorn: "þ", Tilde: "∼", tilde: "˜", TildeEqual: "≃", TildeFullEqual: "≅", TildeTilde: "≈", times: "×", timesb: "⊠", timesbar: "⨱", timesd: "⨰", tint: "∭", toea: "⤨", top: "⊤", topbot: "⌶", topcir: "⫱", Topf: "𝕋", topf: "𝕥", topfork: "⫚", tosa: "⤩", tprime: "‴", TRADE: "™", trade: "™", triangle: "▵", triangledown: "▿", triangleleft: "◃", trianglelefteq: "⊴", triangleq: "≜", triangleright: "▹", trianglerighteq: "⊵", tridot: "◬", trie: "≜", triminus: "⨺", TripleDot: "⃛", triplus: "⨹", trisb: "⧍", tritime: "⨻", trpezium: "⏢", Tscr: "𝒯", tscr: "𝓉", TScy: "Ц", tscy: "ц", TSHcy: "Ћ", tshcy: "ћ", Tstrok: "Ŧ", tstrok: "ŧ", twixt: "≬", twoheadleftarrow: "↞", twoheadrightarrow: "↠", Uacute: "Ú", uacute: "ú", Uarr: "↟", uArr: "⇑", uarr: "↑", Uarrocir: "⥉", Ubrcy: "Ў", ubrcy: "ў", Ubreve: "Ŭ", ubreve: "ŭ", Ucirc: "Û", ucirc: "û", Ucy: "У", ucy: "у", udarr: "⇅", Udblac: "Ű", udblac: "ű", udhar: "⥮", ufisht: "⥾", Ufr: "𝔘", ufr: "𝔲", Ugrave: "Ù", ugrave: "ù", uHar: "⥣", uharl: "↿", uharr: "↾", uhblk: "▀", ulcorn: "⌜", ulcorner: "⌜", ulcrop: "⌏", ultri: "◸", Umacr: "Ū", umacr: "ū", uml: "¨", UnderBar: "_", UnderBrace: "⏟", UnderBracket: "⎵", UnderParenthesis: "⏝", Union: "⋃", UnionPlus: "⊎", Uogon: "Ų", uogon: "ų", Uopf: "𝕌", uopf: "𝕦", UpArrow: "↑", Uparrow: "⇑", uparrow: "↑", UpArrowBar: "⤒", UpArrowDownArrow: "⇅", UpDownArrow: "↕", Updownarrow: "⇕", updownarrow: "↕", UpEquilibrium: "⥮", upharpoonleft: "↿", upharpoonright: "↾", uplus: "⊎", UpperLeftArrow: "↖", UpperRightArrow: "↗", Upsi: "ϒ", upsi: "υ", upsih: "ϒ", Upsilon: "Υ", upsilon: "υ", UpTee: "⊥", UpTeeArrow: "↥", upuparrows: "⇈", urcorn: "⌝", urcorner: "⌝", urcrop: "⌎", Uring: "Ů", uring: "ů", urtri: "◹", Uscr: "𝒰", uscr: "𝓊", utdot: "⋰", Utilde: "Ũ", utilde: "ũ", utri: "▵", utrif: "▴", uuarr: "⇈", Uuml: "Ü", uuml: "ü", uwangle: "⦧", vangrt: "⦜", varepsilon: "ϵ", varkappa: "ϰ", varnothing: "∅", varphi: "ϕ", varpi: "ϖ", varpropto: "∝", vArr: "⇕", varr: "↕", varrho: "ϱ", varsigma: "ς", varsubsetneq: "⊊︀", varsubsetneqq: "⫋︀", varsupsetneq: "⊋︀", varsupsetneqq: "⫌︀", vartheta: "ϑ", vartriangleleft: "⊲", vartriangleright: "⊳", Vbar: "⫫", vBar: "⫨", vBarv: "⫩", Vcy: "В", vcy: "в", VDash: "⊫", Vdash: "⊩", vDash: "⊨", vdash: "⊢", Vdashl: "⫦", Vee: "⋁", vee: "∨", veebar: "⊻", veeeq: "≚", vellip: "⋮", Verbar: "‖", verbar: "|", Vert: "‖", vert: "|", VerticalBar: "∣", VerticalLine: "|", VerticalSeparator: "❘", VerticalTilde: "≀", VeryThinSpace: " ", Vfr: "𝔙", vfr: "𝔳", vltri: "⊲", vnsub: "⊂⃒", vnsup: "⊃⃒", Vopf: "𝕍", vopf: "𝕧", vprop: "∝", vrtri: "⊳", Vscr: "𝒱", vscr: "𝓋", vsubnE: "⫋︀", vsubne: "⊊︀", vsupnE: "⫌︀", vsupne: "⊋︀", Vvdash: "⊪", vzigzag: "⦚", Wcirc: "Ŵ", wcirc: "ŵ", wedbar: "⩟", Wedge: "⋀", wedge: "∧", wedgeq: "≙", weierp: "℘", Wfr: "𝔚", wfr: "𝔴", Wopf: "𝕎", wopf: "𝕨", wp: "℘", wr: "≀", wreath: "≀", Wscr: "𝒲", wscr: "𝓌", xcap: "⋂", xcirc: "◯", xcup: "⋃", xdtri: "▽", Xfr: "𝔛", xfr: "𝔵", xhArr: "⟺", xharr: "⟷", Xi: "Ξ", xi: "ξ", xlArr: "⟸", xlarr: "⟵", xmap: "⟼", xnis: "⋻", xodot: "⨀", Xopf: "𝕏", xopf: "𝕩", xoplus: "⨁", xotime: "⨂", xrArr: "⟹", xrarr: "⟶", Xscr: "𝒳", xscr: "𝓍", xsqcup: "⨆", xuplus: "⨄", xutri: "△", xvee: "⋁", xwedge: "⋀", Yacute: "Ý", yacute: "ý", YAcy: "Я", yacy: "я", Ycirc: "Ŷ", ycirc: "ŷ", Ycy: "Ы", ycy: "ы", yen: "¥", Yfr: "𝔜", yfr: "𝔶", YIcy: "Ї", yicy: "ї", Yopf: "𝕐", yopf: "𝕪", Yscr: "𝒴", yscr: "𝓎", YUcy: "Ю", yucy: "ю", Yuml: "Ÿ", yuml: "ÿ", Zacute: "Ź", zacute: "ź", Zcaron: "Ž", zcaron: "ž", Zcy: "З", zcy: "з", Zdot: "Ż", zdot: "ż", zeetrf: "ℨ", ZeroWidthSpace: "​", Zeta: "Ζ", zeta: "ζ", Zfr: "ℨ", zfr: "𝔷", ZHcy: "Ж", zhcy: "ж", zigrarr: "⇝", Zopf: "ℤ", zopf: "𝕫", Zscr: "𝒵", zscr: "𝓏", zwj: "‍", zwnj: "‌" }, e.NGSP_UNICODE = "", e.NAMED_ENTITIES.ngsp = e.NGSP_UNICODE;
} }), Fs$1 = I$1({ "node_modules/angular-html-parser/lib/compiler/src/ml_parser/html_tags.js"(e) {
  N(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Ze$1(), u = class {
    constructor() {
      let { closedByChildren: a, implicitNamespacePrefix: f, contentType: c = r.TagContentType.PARSABLE_DATA, closedByParent: v2 = false, isVoid: i = false, ignoreFirstLf: l = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.closedByChildren = {}, this.closedByParent = false, this.canSelfClose = false, a && a.length > 0 && a.forEach((p) => this.closedByChildren[p] = true), this.isVoid = i, this.closedByParent = v2 || i, this.implicitNamespacePrefix = f || null, this.contentType = c, this.ignoreFirstLf = l;
    }
    isClosedByChild(a) {
      return this.isVoid || a.toLowerCase() in this.closedByChildren;
    }
  };
  e.HtmlTagDefinition = u;
  var n, D;
  function s(a) {
    return D || (n = new u(), D = { base: new u({ isVoid: true }), meta: new u({ isVoid: true }), area: new u({ isVoid: true }), embed: new u({ isVoid: true }), link: new u({ isVoid: true }), img: new u({ isVoid: true }), input: new u({ isVoid: true }), param: new u({ isVoid: true }), hr: new u({ isVoid: true }), br: new u({ isVoid: true }), source: new u({ isVoid: true }), track: new u({ isVoid: true }), wbr: new u({ isVoid: true }), p: new u({ closedByChildren: ["address", "article", "aside", "blockquote", "div", "dl", "fieldset", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"], closedByParent: true }), thead: new u({ closedByChildren: ["tbody", "tfoot"] }), tbody: new u({ closedByChildren: ["tbody", "tfoot"], closedByParent: true }), tfoot: new u({ closedByChildren: ["tbody"], closedByParent: true }), tr: new u({ closedByChildren: ["tr"], closedByParent: true }), td: new u({ closedByChildren: ["td", "th"], closedByParent: true }), th: new u({ closedByChildren: ["td", "th"], closedByParent: true }), col: new u({ isVoid: true }), svg: new u({ implicitNamespacePrefix: "svg" }), math: new u({ implicitNamespacePrefix: "math" }), li: new u({ closedByChildren: ["li"], closedByParent: true }), dt: new u({ closedByChildren: ["dt", "dd"] }), dd: new u({ closedByChildren: ["dt", "dd"], closedByParent: true }), rb: new u({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), rt: new u({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), rtc: new u({ closedByChildren: ["rb", "rtc", "rp"], closedByParent: true }), rp: new u({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), optgroup: new u({ closedByChildren: ["optgroup"], closedByParent: true }), option: new u({ closedByChildren: ["option", "optgroup"], closedByParent: true }), pre: new u({ ignoreFirstLf: true }), listing: new u({ ignoreFirstLf: true }), style: new u({ contentType: r.TagContentType.RAW_TEXT }), script: new u({ contentType: r.TagContentType.RAW_TEXT }), title: new u({ contentType: r.TagContentType.ESCAPABLE_RAW_TEXT }), textarea: new u({ contentType: r.TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }) }), D[a] || n;
  }
  e.getHtmlTagDefinition = s;
} }), Pl$1 = I$1({ "node_modules/angular-html-parser/lib/compiler/src/ast_path.js"(e) {
  N(), Object.defineProperty(e, "__esModule", { value: true });
  var r = class {
    constructor(u) {
      let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
      this.path = u, this.position = n;
    }
    get empty() {
      return !this.path || !this.path.length;
    }
    get head() {
      return this.path[0];
    }
    get tail() {
      return this.path[this.path.length - 1];
    }
    parentOf(u) {
      return u && this.path[this.path.indexOf(u) - 1];
    }
    childOf(u) {
      return this.path[this.path.indexOf(u) + 1];
    }
    first(u) {
      for (let n = this.path.length - 1; n >= 0; n--) {
        let D = this.path[n];
        if (D instanceof u)
          return D;
      }
    }
    push(u) {
      this.path.push(u);
    }
    pop() {
      return this.path.pop();
    }
  };
  e.AstPath = r;
} }), As$1 = I$1({ "node_modules/angular-html-parser/lib/compiler/src/ml_parser/ast.js"(e) {
  N(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Pl$1(), u = class {
    constructor(C, g2, B) {
      this.value = C, this.sourceSpan = g2, this.i18n = B, this.type = "text";
    }
    visit(C, g2) {
      return C.visitText(this, g2);
    }
  };
  e.Text = u;
  var n = class {
    constructor(C, g2) {
      this.value = C, this.sourceSpan = g2, this.type = "cdata";
    }
    visit(C, g2) {
      return C.visitCdata(this, g2);
    }
  };
  e.CDATA = n;
  var D = class {
    constructor(C, g2, B, O, F, w) {
      this.switchValue = C, this.type = g2, this.cases = B, this.sourceSpan = O, this.switchValueSourceSpan = F, this.i18n = w;
    }
    visit(C, g2) {
      return C.visitExpansion(this, g2);
    }
  };
  e.Expansion = D;
  var s = class {
    constructor(C, g2, B, O, F) {
      this.value = C, this.expression = g2, this.sourceSpan = B, this.valueSourceSpan = O, this.expSourceSpan = F;
    }
    visit(C, g2) {
      return C.visitExpansionCase(this, g2);
    }
  };
  e.ExpansionCase = s;
  var a = class {
    constructor(C, g2, B) {
      let O = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, F = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null, w = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null;
      this.name = C, this.value = g2, this.sourceSpan = B, this.valueSpan = O, this.nameSpan = F, this.i18n = w, this.type = "attribute";
    }
    visit(C, g2) {
      return C.visitAttribute(this, g2);
    }
  };
  e.Attribute = a;
  var f = class {
    constructor(C, g2, B, O) {
      let F = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null, w = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null, b = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null, M2 = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null;
      this.name = C, this.attrs = g2, this.children = B, this.sourceSpan = O, this.startSourceSpan = F, this.endSourceSpan = w, this.nameSpan = b, this.i18n = M2, this.type = "element";
    }
    visit(C, g2) {
      return C.visitElement(this, g2);
    }
  };
  e.Element = f;
  var c = class {
    constructor(C, g2) {
      this.value = C, this.sourceSpan = g2, this.type = "comment";
    }
    visit(C, g2) {
      return C.visitComment(this, g2);
    }
  };
  e.Comment = c;
  var v2 = class {
    constructor(C, g2) {
      this.value = C, this.sourceSpan = g2, this.type = "docType";
    }
    visit(C, g2) {
      return C.visitDocType(this, g2);
    }
  };
  e.DocType = v2;
  function i(C, g2) {
    let B = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, O = [], F = C.visit ? (w) => C.visit(w, B) || w.visit(C, B) : (w) => w.visit(C, B);
    return g2.forEach((w) => {
      let b = F(w);
      b && O.push(b);
    }), O;
  }
  e.visitAll = i;
  var l = class {
    constructor() {
    }
    visitElement(C, g2) {
      this.visitChildren(g2, (B) => {
        B(C.attrs), B(C.children);
      });
    }
    visitAttribute(C, g2) {
    }
    visitText(C, g2) {
    }
    visitCdata(C, g2) {
    }
    visitComment(C, g2) {
    }
    visitDocType(C, g2) {
    }
    visitExpansion(C, g2) {
      return this.visitChildren(g2, (B) => {
        B(C.cases);
      });
    }
    visitExpansionCase(C, g2) {
    }
    visitChildren(C, g2) {
      let B = [], O = this;
      function F(w) {
        w && B.push(i(O, w, C));
      }
      return g2(F), Array.prototype.concat.apply([], B);
    }
  };
  e.RecursiveVisitor = l;
  function p(C) {
    let g2 = C.sourceSpan.start.offset, B = C.sourceSpan.end.offset;
    return C instanceof f && (C.endSourceSpan ? B = C.endSourceSpan.end.offset : C.children && C.children.length && (B = p(C.children[C.children.length - 1]).end)), { start: g2, end: B };
  }
  function m(C, g2) {
    let B = [], O = new class extends l {
      visit(F, w) {
        let b = p(F);
        if (b.start <= g2 && g2 < b.end)
          B.push(F);
        else
          return true;
      }
    }();
    return i(O, C), new r.AstPath(B, g2);
  }
  e.findNode = m;
} }), kl$1 = I$1({ "node_modules/angular-html-parser/lib/compiler/src/assertions.js"(e) {
  N(), Object.defineProperty(e, "__esModule", { value: true });
  function r(D, s) {
    if (s != null) {
      if (!Array.isArray(s))
        throw new Error(`Expected '${D}' to be an array of strings.`);
      for (let a = 0; a < s.length; a += 1)
        if (typeof s[a] != "string")
          throw new Error(`Expected '${D}' to be an array of strings.`);
    }
  }
  e.assertArrayOfStrings = r;
  var u = [/^\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\/\//];
  function n(D, s) {
    if (s != null && !(Array.isArray(s) && s.length == 2))
      throw new Error(`Expected '${D}' to be an array, [start, end].`);
    if (s != null) {
      let a = s[0], f = s[1];
      u.forEach((c) => {
        if (c.test(a) || c.test(f))
          throw new Error(`['${a}', '${f}'] contains unusable interpolation symbol.`);
      });
    }
  }
  e.assertInterpolationSymbols = n;
} }), Ll$1 = I$1({ "node_modules/angular-html-parser/lib/compiler/src/ml_parser/interpolation_config.js"(e) {
  N(), Object.defineProperty(e, "__esModule", { value: true });
  var r = kl$1(), u = class {
    constructor(n, D) {
      this.start = n, this.end = D;
    }
    static fromArray(n) {
      return n ? (r.assertInterpolationSymbols("interpolation", n), new u(n[0], n[1])) : e.DEFAULT_INTERPOLATION_CONFIG;
    }
  };
  e.InterpolationConfig = u, e.DEFAULT_INTERPOLATION_CONFIG = new u("{{", "}}");
} }), $l$1 = I$1({ "node_modules/angular-html-parser/lib/compiler/src/ml_parser/lexer.js"(e) {
  N(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Ds$1(), u = Ne$1(), n = Ll$1(), D = Ze$1(), s;
  (function(t) {
    t[t.TAG_OPEN_START = 0] = "TAG_OPEN_START", t[t.TAG_OPEN_END = 1] = "TAG_OPEN_END", t[t.TAG_OPEN_END_VOID = 2] = "TAG_OPEN_END_VOID", t[t.TAG_CLOSE = 3] = "TAG_CLOSE", t[t.TEXT = 4] = "TEXT", t[t.ESCAPABLE_RAW_TEXT = 5] = "ESCAPABLE_RAW_TEXT", t[t.RAW_TEXT = 6] = "RAW_TEXT", t[t.COMMENT_START = 7] = "COMMENT_START", t[t.COMMENT_END = 8] = "COMMENT_END", t[t.CDATA_START = 9] = "CDATA_START", t[t.CDATA_END = 10] = "CDATA_END", t[t.ATTR_NAME = 11] = "ATTR_NAME", t[t.ATTR_QUOTE = 12] = "ATTR_QUOTE", t[t.ATTR_VALUE = 13] = "ATTR_VALUE", t[t.DOC_TYPE_START = 14] = "DOC_TYPE_START", t[t.DOC_TYPE_END = 15] = "DOC_TYPE_END", t[t.EXPANSION_FORM_START = 16] = "EXPANSION_FORM_START", t[t.EXPANSION_CASE_VALUE = 17] = "EXPANSION_CASE_VALUE", t[t.EXPANSION_CASE_EXP_START = 18] = "EXPANSION_CASE_EXP_START", t[t.EXPANSION_CASE_EXP_END = 19] = "EXPANSION_CASE_EXP_END", t[t.EXPANSION_FORM_END = 20] = "EXPANSION_FORM_END", t[t.EOF = 21] = "EOF";
  })(s = e.TokenType || (e.TokenType = {}));
  var a = class {
    constructor(t, o, d2) {
      this.type = t, this.parts = o, this.sourceSpan = d2;
    }
  };
  e.Token = a;
  var f = class extends u.ParseError {
    constructor(t, o, d2) {
      super(d2, t), this.tokenType = o;
    }
  };
  e.TokenError = f;
  var c = class {
    constructor(t, o) {
      this.tokens = t, this.errors = o;
    }
  };
  e.TokenizeResult = c;
  function v2(t, o, d2) {
    let h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return new C(new u.ParseSourceFile(t, o), d2, h).tokenize();
  }
  e.tokenize = v2;
  var i = /\r\n?/g;
  function l(t) {
    return `Unexpected character "${t === r.$EOF ? "EOF" : String.fromCharCode(t)}"`;
  }
  function p(t) {
    return `Unknown entity "${t}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
  }
  var m = class {
    constructor(t) {
      this.error = t;
    }
  }, C = class {
    constructor(t, o, d2) {
      this._getTagContentType = o, this._currentTokenStart = null, this._currentTokenType = null, this._expansionCaseStack = [], this._inInterpolation = false, this._fullNameStack = [], this.tokens = [], this.errors = [], this._tokenizeIcu = d2.tokenizeExpansionForms || false, this._interpolationConfig = d2.interpolationConfig || n.DEFAULT_INTERPOLATION_CONFIG, this._leadingTriviaCodePoints = d2.leadingTriviaChars && d2.leadingTriviaChars.map((A) => A.codePointAt(0) || 0), this._canSelfClose = d2.canSelfClose || false, this._allowHtmComponentClosingTags = d2.allowHtmComponentClosingTags || false;
      let h = d2.range || { endPos: t.content.length, startPos: 0, startLine: 0, startCol: 0 };
      this._cursor = d2.escapedString ? new j(t, h) : new k(t, h);
      try {
        this._cursor.init();
      } catch (A) {
        this.handleError(A);
      }
    }
    _processCarriageReturns(t) {
      return t.replace(i, `
`);
    }
    tokenize() {
      for (; this._cursor.peek() !== r.$EOF; ) {
        let t = this._cursor.clone();
        try {
          if (this._attemptCharCode(r.$LT))
            if (this._attemptCharCode(r.$BANG))
              this._attemptStr("[CDATA[") ? this._consumeCdata(t) : this._attemptStr("--") ? this._consumeComment(t) : this._attemptStrCaseInsensitive("doctype") ? this._consumeDocType(t) : this._consumeBogusComment(t);
            else if (this._attemptCharCode(r.$SLASH))
              this._consumeTagClose(t);
            else {
              let o = this._cursor.clone();
              this._attemptCharCode(r.$QUESTION) ? (this._cursor = o, this._consumeBogusComment(t)) : this._consumeTagOpen(t);
            }
          else
            this._tokenizeIcu && this._tokenizeExpansionForm() || this._consumeText();
        } catch (o) {
          this.handleError(o);
        }
      }
      return this._beginToken(s.EOF), this._endToken([]), new c(U2(this.tokens), this.errors);
    }
    _tokenizeExpansionForm() {
      if (this.isExpansionFormStart())
        return this._consumeExpansionFormStart(), true;
      if (b(this._cursor.peek()) && this._isInExpansionForm())
        return this._consumeExpansionCaseStart(), true;
      if (this._cursor.peek() === r.$RBRACE) {
        if (this._isInExpansionCase())
          return this._consumeExpansionCaseEnd(), true;
        if (this._isInExpansionForm())
          return this._consumeExpansionFormEnd(), true;
      }
      return false;
    }
    _beginToken(t) {
      let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._cursor.clone();
      this._currentTokenStart = o, this._currentTokenType = t;
    }
    _endToken(t) {
      let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._cursor.clone();
      if (this._currentTokenStart === null)
        throw new f("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(o));
      if (this._currentTokenType === null)
        throw new f("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
      let d2 = new a(this._currentTokenType, t, this._cursor.getSpan(this._currentTokenStart, this._leadingTriviaCodePoints));
      return this.tokens.push(d2), this._currentTokenStart = null, this._currentTokenType = null, d2;
    }
    _createError(t, o) {
      this._isInExpansionForm() && (t += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`);
      let d2 = new f(t, this._currentTokenType, o);
      return this._currentTokenStart = null, this._currentTokenType = null, new m(d2);
    }
    handleError(t) {
      if (t instanceof L && (t = this._createError(t.msg, this._cursor.getSpan(t.cursor))), t instanceof m)
        this.errors.push(t.error);
      else
        throw t;
    }
    _attemptCharCode(t) {
      return this._cursor.peek() === t ? (this._cursor.advance(), true) : false;
    }
    _attemptCharCodeCaseInsensitive(t) {
      return M2(this._cursor.peek(), t) ? (this._cursor.advance(), true) : false;
    }
    _requireCharCode(t) {
      let o = this._cursor.clone();
      if (!this._attemptCharCode(t))
        throw this._createError(l(this._cursor.peek()), this._cursor.getSpan(o));
    }
    _attemptStr(t) {
      let o = t.length;
      if (this._cursor.charsLeft() < o)
        return false;
      let d2 = this._cursor.clone();
      for (let h = 0; h < o; h++)
        if (!this._attemptCharCode(t.charCodeAt(h)))
          return this._cursor = d2, false;
      return true;
    }
    _attemptStrCaseInsensitive(t) {
      for (let o = 0; o < t.length; o++)
        if (!this._attemptCharCodeCaseInsensitive(t.charCodeAt(o)))
          return false;
      return true;
    }
    _requireStr(t) {
      let o = this._cursor.clone();
      if (!this._attemptStr(t))
        throw this._createError(l(this._cursor.peek()), this._cursor.getSpan(o));
    }
    _requireStrCaseInsensitive(t) {
      let o = this._cursor.clone();
      if (!this._attemptStrCaseInsensitive(t))
        throw this._createError(l(this._cursor.peek()), this._cursor.getSpan(o));
    }
    _attemptCharCodeUntilFn(t) {
      for (; !t(this._cursor.peek()); )
        this._cursor.advance();
    }
    _requireCharCodeUntilFn(t, o) {
      let d2 = this._cursor.clone();
      if (this._attemptCharCodeUntilFn(t), this._cursor.clone().diff(d2) < o)
        throw this._createError(l(this._cursor.peek()), this._cursor.getSpan(d2));
    }
    _attemptUntilChar(t) {
      for (; this._cursor.peek() !== t; )
        this._cursor.advance();
    }
    _readChar(t) {
      if (t && this._cursor.peek() === r.$AMPERSAND)
        return this._decodeEntity();
      {
        let o = String.fromCodePoint(this._cursor.peek());
        return this._cursor.advance(), o;
      }
    }
    _decodeEntity() {
      let t = this._cursor.clone();
      if (this._cursor.advance(), this._attemptCharCode(r.$HASH)) {
        let o = this._attemptCharCode(r.$x) || this._attemptCharCode(r.$X), d2 = this._cursor.clone();
        if (this._attemptCharCodeUntilFn(F), this._cursor.peek() != r.$SEMICOLON)
          throw this._createError(l(this._cursor.peek()), this._cursor.getSpan());
        let h = this._cursor.getChars(d2);
        this._cursor.advance();
        try {
          let A = parseInt(h, o ? 16 : 10);
          return String.fromCharCode(A);
        } catch {
          throw this._createError(p(this._cursor.getChars(t)), this._cursor.getSpan());
        }
      } else {
        let o = this._cursor.clone();
        if (this._attemptCharCodeUntilFn(w), this._cursor.peek() != r.$SEMICOLON)
          return this._cursor = o, "&";
        let d2 = this._cursor.getChars(o);
        this._cursor.advance();
        let h = D.NAMED_ENTITIES[d2];
        if (!h)
          throw this._createError(p(d2), this._cursor.getSpan(t));
        return h;
      }
    }
    _consumeRawText(t, o) {
      this._beginToken(t ? s.ESCAPABLE_RAW_TEXT : s.RAW_TEXT);
      let d2 = [];
      for (; ; ) {
        let h = this._cursor.clone(), A = o();
        if (this._cursor = h, A)
          break;
        d2.push(this._readChar(t));
      }
      return this._endToken([this._processCarriageReturns(d2.join(""))]);
    }
    _consumeComment(t) {
      this._beginToken(s.COMMENT_START, t), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("-->")), this._beginToken(s.COMMENT_END), this._requireStr("-->"), this._endToken([]);
    }
    _consumeBogusComment(t) {
      this._beginToken(s.COMMENT_START, t), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === r.$GT), this._beginToken(s.COMMENT_END), this._cursor.advance(), this._endToken([]);
    }
    _consumeCdata(t) {
      this._beginToken(s.CDATA_START, t), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("]]>")), this._beginToken(s.CDATA_END), this._requireStr("]]>"), this._endToken([]);
    }
    _consumeDocType(t) {
      this._beginToken(s.DOC_TYPE_START, t), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === r.$GT), this._beginToken(s.DOC_TYPE_END), this._cursor.advance(), this._endToken([]);
    }
    _consumePrefixAndName() {
      let t = this._cursor.clone(), o = "";
      for (; this._cursor.peek() !== r.$COLON && !O(this._cursor.peek()); )
        this._cursor.advance();
      let d2;
      this._cursor.peek() === r.$COLON ? (o = this._cursor.getChars(t), this._cursor.advance(), d2 = this._cursor.clone()) : d2 = t, this._requireCharCodeUntilFn(B, o === "" ? 0 : 1);
      let h = this._cursor.getChars(d2);
      return [o, h];
    }
    _consumeTagOpen(t) {
      let o, d2, h, A = this.tokens.length, q = this._cursor.clone(), P = [];
      try {
        if (!r.isAsciiLetter(this._cursor.peek()))
          throw this._createError(l(this._cursor.peek()), this._cursor.getSpan(t));
        for (h = this._consumeTagOpenStart(t), d2 = h.parts[0], o = h.parts[1], this._attemptCharCodeUntilFn(g2); this._cursor.peek() !== r.$SLASH && this._cursor.peek() !== r.$GT; ) {
          let [X, Q] = this._consumeAttributeName();
          if (this._attemptCharCodeUntilFn(g2), this._attemptCharCode(r.$EQ)) {
            this._attemptCharCodeUntilFn(g2);
            let H = this._consumeAttributeValue();
            P.push({ prefix: X, name: Q, value: H });
          } else
            P.push({ prefix: X, name: Q });
          this._attemptCharCodeUntilFn(g2);
        }
        this._consumeTagOpenEnd();
      } catch (X) {
        if (X instanceof m) {
          this._cursor = q, h && (this.tokens.length = A), this._beginToken(s.TEXT, t), this._endToken(["<"]);
          return;
        }
        throw X;
      }
      if (this._canSelfClose && this.tokens[this.tokens.length - 1].type === s.TAG_OPEN_END_VOID)
        return;
      let G = this._getTagContentType(o, d2, this._fullNameStack.length > 0, P);
      this._handleFullNameStackForTagOpen(d2, o), G === D.TagContentType.RAW_TEXT ? this._consumeRawTextWithTagClose(d2, o, false) : G === D.TagContentType.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(d2, o, true);
    }
    _consumeRawTextWithTagClose(t, o, d2) {
      this._consumeRawText(d2, () => !this._attemptCharCode(r.$LT) || !this._attemptCharCode(r.$SLASH) || (this._attemptCharCodeUntilFn(g2), !this._attemptStrCaseInsensitive(t ? `${t}:${o}` : o)) ? false : (this._attemptCharCodeUntilFn(g2), this._attemptCharCode(r.$GT)));
      this._beginToken(s.TAG_CLOSE), this._requireCharCodeUntilFn((A) => A === r.$GT, 3), this._cursor.advance(), this._endToken([t, o]), this._handleFullNameStackForTagClose(t, o);
    }
    _consumeTagOpenStart(t) {
      this._beginToken(s.TAG_OPEN_START, t);
      let o = this._consumePrefixAndName();
      return this._endToken(o);
    }
    _consumeAttributeName() {
      let t = this._cursor.peek();
      if (t === r.$SQ || t === r.$DQ)
        throw this._createError(l(t), this._cursor.getSpan());
      this._beginToken(s.ATTR_NAME);
      let o = this._consumePrefixAndName();
      return this._endToken(o), o;
    }
    _consumeAttributeValue() {
      let t;
      if (this._cursor.peek() === r.$SQ || this._cursor.peek() === r.$DQ) {
        this._beginToken(s.ATTR_QUOTE);
        let o = this._cursor.peek();
        this._cursor.advance(), this._endToken([String.fromCodePoint(o)]), this._beginToken(s.ATTR_VALUE);
        let d2 = [];
        for (; this._cursor.peek() !== o; )
          d2.push(this._readChar(true));
        t = this._processCarriageReturns(d2.join("")), this._endToken([t]), this._beginToken(s.ATTR_QUOTE), this._cursor.advance(), this._endToken([String.fromCodePoint(o)]);
      } else {
        this._beginToken(s.ATTR_VALUE);
        let o = this._cursor.clone();
        this._requireCharCodeUntilFn(B, 1), t = this._processCarriageReturns(this._cursor.getChars(o)), this._endToken([t]);
      }
      return t;
    }
    _consumeTagOpenEnd() {
      let t = this._attemptCharCode(r.$SLASH) ? s.TAG_OPEN_END_VOID : s.TAG_OPEN_END;
      this._beginToken(t), this._requireCharCode(r.$GT), this._endToken([]);
    }
    _consumeTagClose(t) {
      if (this._beginToken(s.TAG_CLOSE, t), this._attemptCharCodeUntilFn(g2), this._allowHtmComponentClosingTags && this._attemptCharCode(r.$SLASH))
        this._attemptCharCodeUntilFn(g2), this._requireCharCode(r.$GT), this._endToken([]);
      else {
        let [o, d2] = this._consumePrefixAndName();
        this._attemptCharCodeUntilFn(g2), this._requireCharCode(r.$GT), this._endToken([o, d2]), this._handleFullNameStackForTagClose(o, d2);
      }
    }
    _consumeExpansionFormStart() {
      this._beginToken(s.EXPANSION_FORM_START), this._requireCharCode(r.$LBRACE), this._endToken([]), this._expansionCaseStack.push(s.EXPANSION_FORM_START), this._beginToken(s.RAW_TEXT);
      let t = this._readUntil(r.$COMMA);
      this._endToken([t]), this._requireCharCode(r.$COMMA), this._attemptCharCodeUntilFn(g2), this._beginToken(s.RAW_TEXT);
      let o = this._readUntil(r.$COMMA);
      this._endToken([o]), this._requireCharCode(r.$COMMA), this._attemptCharCodeUntilFn(g2);
    }
    _consumeExpansionCaseStart() {
      this._beginToken(s.EXPANSION_CASE_VALUE);
      let t = this._readUntil(r.$LBRACE).trim();
      this._endToken([t]), this._attemptCharCodeUntilFn(g2), this._beginToken(s.EXPANSION_CASE_EXP_START), this._requireCharCode(r.$LBRACE), this._endToken([]), this._attemptCharCodeUntilFn(g2), this._expansionCaseStack.push(s.EXPANSION_CASE_EXP_START);
    }
    _consumeExpansionCaseEnd() {
      this._beginToken(s.EXPANSION_CASE_EXP_END), this._requireCharCode(r.$RBRACE), this._endToken([]), this._attemptCharCodeUntilFn(g2), this._expansionCaseStack.pop();
    }
    _consumeExpansionFormEnd() {
      this._beginToken(s.EXPANSION_FORM_END), this._requireCharCode(r.$RBRACE), this._endToken([]), this._expansionCaseStack.pop();
    }
    _consumeText() {
      let t = this._cursor.clone();
      this._beginToken(s.TEXT, t);
      let o = [];
      do
        this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (o.push(this._interpolationConfig.start), this._inInterpolation = true) : this._interpolationConfig && this._inInterpolation && this._attemptStr(this._interpolationConfig.end) ? (o.push(this._interpolationConfig.end), this._inInterpolation = false) : o.push(this._readChar(true));
      while (!this._isTextEnd());
      this._endToken([this._processCarriageReturns(o.join(""))]);
    }
    _isTextEnd() {
      return !!(this._cursor.peek() === r.$LT || this._cursor.peek() === r.$EOF || this._tokenizeIcu && !this._inInterpolation && (this.isExpansionFormStart() || this._cursor.peek() === r.$RBRACE && this._isInExpansionCase()));
    }
    _readUntil(t) {
      let o = this._cursor.clone();
      return this._attemptUntilChar(t), this._cursor.getChars(o);
    }
    _isInExpansionCase() {
      return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === s.EXPANSION_CASE_EXP_START;
    }
    _isInExpansionForm() {
      return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === s.EXPANSION_FORM_START;
    }
    isExpansionFormStart() {
      if (this._cursor.peek() !== r.$LBRACE)
        return false;
      if (this._interpolationConfig) {
        let t = this._cursor.clone(), o = this._attemptStr(this._interpolationConfig.start);
        return this._cursor = t, !o;
      }
      return true;
    }
    _handleFullNameStackForTagOpen(t, o) {
      let d2 = D.mergeNsAndName(t, o);
      (this._fullNameStack.length === 0 || this._fullNameStack[this._fullNameStack.length - 1] === d2) && this._fullNameStack.push(d2);
    }
    _handleFullNameStackForTagClose(t, o) {
      let d2 = D.mergeNsAndName(t, o);
      this._fullNameStack.length !== 0 && this._fullNameStack[this._fullNameStack.length - 1] === d2 && this._fullNameStack.pop();
    }
  };
  function g2(t) {
    return !r.isWhitespace(t) || t === r.$EOF;
  }
  function B(t) {
    return r.isWhitespace(t) || t === r.$GT || t === r.$SLASH || t === r.$SQ || t === r.$DQ || t === r.$EQ;
  }
  function O(t) {
    return (t < r.$a || r.$z < t) && (t < r.$A || r.$Z < t) && (t < r.$0 || t > r.$9);
  }
  function F(t) {
    return t == r.$SEMICOLON || t == r.$EOF || !r.isAsciiHexDigit(t);
  }
  function w(t) {
    return t == r.$SEMICOLON || t == r.$EOF || !r.isAsciiLetter(t);
  }
  function b(t) {
    return t === r.$EQ || r.isAsciiLetter(t) || r.isDigit(t);
  }
  function M2(t, o) {
    return R2(t) == R2(o);
  }
  function R2(t) {
    return t >= r.$a && t <= r.$z ? t - r.$a + r.$A : t;
  }
  function U2(t) {
    let o = [], d2;
    for (let h = 0; h < t.length; h++) {
      let A = t[h];
      d2 && d2.type == s.TEXT && A.type == s.TEXT ? (d2.parts[0] += A.parts[0], d2.sourceSpan.end = A.sourceSpan.end) : (d2 = A, o.push(d2));
    }
    return o;
  }
  var k = class {
    constructor(t, o) {
      if (t instanceof k)
        this.file = t.file, this.input = t.input, this.end = t.end, this.state = Object.assign({}, t.state);
      else {
        if (!o)
          throw new Error("Programming error: the range argument must be provided with a file argument.");
        this.file = t, this.input = t.content, this.end = o.endPos, this.state = { peek: -1, offset: o.startPos, line: o.startLine, column: o.startCol };
      }
    }
    clone() {
      return new k(this);
    }
    peek() {
      return this.state.peek;
    }
    charsLeft() {
      return this.end - this.state.offset;
    }
    diff(t) {
      return this.state.offset - t.state.offset;
    }
    advance() {
      this.advanceState(this.state);
    }
    init() {
      this.updatePeek(this.state);
    }
    getSpan(t, o) {
      if (t = t || this, o)
        for (t = t.clone(); this.diff(t) > 0 && o.indexOf(t.peek()) !== -1; )
          t.advance();
      return new u.ParseSourceSpan(new u.ParseLocation(t.file, t.state.offset, t.state.line, t.state.column), new u.ParseLocation(this.file, this.state.offset, this.state.line, this.state.column));
    }
    getChars(t) {
      return this.input.substring(t.state.offset, this.state.offset);
    }
    charAt(t) {
      return this.input.charCodeAt(t);
    }
    advanceState(t) {
      if (t.offset >= this.end)
        throw this.state = t, new L('Unexpected character "EOF"', this);
      let o = this.charAt(t.offset);
      o === r.$LF ? (t.line++, t.column = 0) : r.isNewLine(o) || t.column++, t.offset++, this.updatePeek(t);
    }
    updatePeek(t) {
      t.peek = t.offset >= this.end ? r.$EOF : this.charAt(t.offset);
    }
  }, j = class extends k {
    constructor(t, o) {
      t instanceof j ? (super(t), this.internalState = Object.assign({}, t.internalState)) : (super(t, o), this.internalState = this.state);
    }
    advance() {
      this.state = this.internalState, super.advance(), this.processEscapeSequence();
    }
    init() {
      super.init(), this.processEscapeSequence();
    }
    clone() {
      return new j(this);
    }
    getChars(t) {
      let o = t.clone(), d2 = "";
      for (; o.internalState.offset < this.internalState.offset; )
        d2 += String.fromCodePoint(o.peek()), o.advance();
      return d2;
    }
    processEscapeSequence() {
      let t = () => this.internalState.peek;
      if (t() === r.$BACKSLASH)
        if (this.internalState = Object.assign({}, this.state), this.advanceState(this.internalState), t() === r.$n)
          this.state.peek = r.$LF;
        else if (t() === r.$r)
          this.state.peek = r.$CR;
        else if (t() === r.$v)
          this.state.peek = r.$VTAB;
        else if (t() === r.$t)
          this.state.peek = r.$TAB;
        else if (t() === r.$b)
          this.state.peek = r.$BSPACE;
        else if (t() === r.$f)
          this.state.peek = r.$FF;
        else if (t() === r.$u)
          if (this.advanceState(this.internalState), t() === r.$LBRACE) {
            this.advanceState(this.internalState);
            let o = this.clone(), d2 = 0;
            for (; t() !== r.$RBRACE; )
              this.advanceState(this.internalState), d2++;
            this.state.peek = this.decodeHexDigits(o, d2);
          } else {
            let o = this.clone();
            this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(o, 4);
          }
        else if (t() === r.$x) {
          this.advanceState(this.internalState);
          let o = this.clone();
          this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(o, 2);
        } else if (r.isOctalDigit(t())) {
          let o = "", d2 = 0, h = this.clone();
          for (; r.isOctalDigit(t()) && d2 < 3; )
            h = this.clone(), o += String.fromCodePoint(t()), this.advanceState(this.internalState), d2++;
          this.state.peek = parseInt(o, 8), this.internalState = h.internalState;
        } else
          r.isNewLine(this.internalState.peek) ? (this.advanceState(this.internalState), this.state = this.internalState) : this.state.peek = this.internalState.peek;
    }
    decodeHexDigits(t, o) {
      let d2 = this.input.substr(t.internalState.offset, o), h = parseInt(d2, 16);
      if (isNaN(h))
        throw t.state = t.internalState, new L("Invalid hexadecimal escape sequence", t);
      return h;
    }
  }, L = class {
    constructor(t, o) {
      this.msg = t, this.cursor = o;
    }
  };
  e.CursorError = L;
} }), ns$1 = I$1({ "node_modules/angular-html-parser/lib/compiler/src/ml_parser/parser.js"(e) {
  N(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Ne$1(), u = As$1(), n = $l$1(), D = Ze$1(), s = class extends r.ParseError {
    constructor(i, l, p) {
      super(l, p), this.elementName = i;
    }
    static create(i, l, p) {
      return new s(i, l, p);
    }
  };
  e.TreeError = s;
  var a = class {
    constructor(i, l) {
      this.rootNodes = i, this.errors = l;
    }
  };
  e.ParseTreeResult = a;
  var f = class {
    constructor(i) {
      this.getTagDefinition = i;
    }
    parse(i, l, p) {
      let m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, C = arguments.length > 4 ? arguments[4] : void 0, g2 = (k) => function(j) {
        for (var L = arguments.length, t = new Array(L > 1 ? L - 1 : 0), o = 1; o < L; o++)
          t[o - 1] = arguments[o];
        return k(j.toLowerCase(), ...t);
      }, B = m ? this.getTagDefinition : g2(this.getTagDefinition), O = (k) => B(k).contentType, F = m ? C : g2(C), w = C ? (k, j, L, t) => {
        let o = F(k, j, L, t);
        return o !== void 0 ? o : O(k);
      } : O, b = n.tokenize(i, l, w, p), M2 = p && p.canSelfClose || false, R2 = p && p.allowHtmComponentClosingTags || false, U2 = new c(b.tokens, B, M2, R2, m).build();
      return new a(U2.rootNodes, b.errors.concat(U2.errors));
    }
  };
  e.Parser = f;
  var c = class {
    constructor(i, l, p, m, C) {
      this.tokens = i, this.getTagDefinition = l, this.canSelfClose = p, this.allowHtmComponentClosingTags = m, this.isTagNameCaseSensitive = C, this._index = -1, this._rootNodes = [], this._errors = [], this._elementStack = [], this._advance();
    }
    build() {
      for (; this._peek.type !== n.TokenType.EOF; )
        this._peek.type === n.TokenType.TAG_OPEN_START ? this._consumeStartTag(this._advance()) : this._peek.type === n.TokenType.TAG_CLOSE ? (this._closeVoidElement(), this._consumeEndTag(this._advance())) : this._peek.type === n.TokenType.CDATA_START ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : this._peek.type === n.TokenType.COMMENT_START ? (this._closeVoidElement(), this._consumeComment(this._advance())) : this._peek.type === n.TokenType.TEXT || this._peek.type === n.TokenType.RAW_TEXT || this._peek.type === n.TokenType.ESCAPABLE_RAW_TEXT ? (this._closeVoidElement(), this._consumeText(this._advance())) : this._peek.type === n.TokenType.EXPANSION_FORM_START ? this._consumeExpansion(this._advance()) : this._peek.type === n.TokenType.DOC_TYPE_START ? this._consumeDocType(this._advance()) : this._advance();
      return new a(this._rootNodes, this._errors);
    }
    _advance() {
      let i = this._peek;
      return this._index < this.tokens.length - 1 && this._index++, this._peek = this.tokens[this._index], i;
    }
    _advanceIf(i) {
      return this._peek.type === i ? this._advance() : null;
    }
    _consumeCdata(i) {
      let l = this._advance(), p = this._getText(l), m = this._advanceIf(n.TokenType.CDATA_END);
      this._addToParent(new u.CDATA(p, new r.ParseSourceSpan(i.sourceSpan.start, (m || l).sourceSpan.end)));
    }
    _consumeComment(i) {
      let l = this._advanceIf(n.TokenType.RAW_TEXT), p = this._advanceIf(n.TokenType.COMMENT_END), m = l != null ? l.parts[0].trim() : null, C = new r.ParseSourceSpan(i.sourceSpan.start, (p || l || i).sourceSpan.end);
      this._addToParent(new u.Comment(m, C));
    }
    _consumeDocType(i) {
      let l = this._advanceIf(n.TokenType.RAW_TEXT), p = this._advanceIf(n.TokenType.DOC_TYPE_END), m = l != null ? l.parts[0].trim() : null, C = new r.ParseSourceSpan(i.sourceSpan.start, (p || l || i).sourceSpan.end);
      this._addToParent(new u.DocType(m, C));
    }
    _consumeExpansion(i) {
      let l = this._advance(), p = this._advance(), m = [];
      for (; this._peek.type === n.TokenType.EXPANSION_CASE_VALUE; ) {
        let g2 = this._parseExpansionCase();
        if (!g2)
          return;
        m.push(g2);
      }
      if (this._peek.type !== n.TokenType.EXPANSION_FORM_END) {
        this._errors.push(s.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
        return;
      }
      let C = new r.ParseSourceSpan(i.sourceSpan.start, this._peek.sourceSpan.end);
      this._addToParent(new u.Expansion(l.parts[0], p.parts[0], m, C, l.sourceSpan)), this._advance();
    }
    _parseExpansionCase() {
      let i = this._advance();
      if (this._peek.type !== n.TokenType.EXPANSION_CASE_EXP_START)
        return this._errors.push(s.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
      let l = this._advance(), p = this._collectExpansionExpTokens(l);
      if (!p)
        return null;
      let m = this._advance();
      p.push(new n.Token(n.TokenType.EOF, [], m.sourceSpan));
      let C = new c(p, this.getTagDefinition, this.canSelfClose, this.allowHtmComponentClosingTags, this.isTagNameCaseSensitive).build();
      if (C.errors.length > 0)
        return this._errors = this._errors.concat(C.errors), null;
      let g2 = new r.ParseSourceSpan(i.sourceSpan.start, m.sourceSpan.end), B = new r.ParseSourceSpan(l.sourceSpan.start, m.sourceSpan.end);
      return new u.ExpansionCase(i.parts[0], C.rootNodes, g2, i.sourceSpan, B);
    }
    _collectExpansionExpTokens(i) {
      let l = [], p = [n.TokenType.EXPANSION_CASE_EXP_START];
      for (; ; ) {
        if ((this._peek.type === n.TokenType.EXPANSION_FORM_START || this._peek.type === n.TokenType.EXPANSION_CASE_EXP_START) && p.push(this._peek.type), this._peek.type === n.TokenType.EXPANSION_CASE_EXP_END)
          if (v2(p, n.TokenType.EXPANSION_CASE_EXP_START)) {
            if (p.pop(), p.length == 0)
              return l;
          } else
            return this._errors.push(s.create(null, i.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
        if (this._peek.type === n.TokenType.EXPANSION_FORM_END)
          if (v2(p, n.TokenType.EXPANSION_FORM_START))
            p.pop();
          else
            return this._errors.push(s.create(null, i.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
        if (this._peek.type === n.TokenType.EOF)
          return this._errors.push(s.create(null, i.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
        l.push(this._advance());
      }
    }
    _getText(i) {
      let l = i.parts[0];
      if (l.length > 0 && l[0] == `
`) {
        let p = this._getParentElement();
        p != null && p.children.length == 0 && this.getTagDefinition(p.name).ignoreFirstLf && (l = l.substring(1));
      }
      return l;
    }
    _consumeText(i) {
      let l = this._getText(i);
      l.length > 0 && this._addToParent(new u.Text(l, i.sourceSpan));
    }
    _closeVoidElement() {
      let i = this._getParentElement();
      i && this.getTagDefinition(i.name).isVoid && this._elementStack.pop();
    }
    _consumeStartTag(i) {
      let l = i.parts[0], p = i.parts[1], m = [];
      for (; this._peek.type === n.TokenType.ATTR_NAME; )
        m.push(this._consumeAttr(this._advance()));
      let C = this._getElementFullName(l, p, this._getParentElement()), g2 = false;
      if (this._peek.type === n.TokenType.TAG_OPEN_END_VOID) {
        this._advance(), g2 = true;
        let b = this.getTagDefinition(C);
        this.canSelfClose || b.canSelfClose || D.getNsPrefix(C) !== null || b.isVoid || this._errors.push(s.create(C, i.sourceSpan, `Only void and foreign elements can be self closed "${i.parts[1]}"`));
      } else
        this._peek.type === n.TokenType.TAG_OPEN_END && (this._advance(), g2 = false);
      let B = this._peek.sourceSpan.start, O = new r.ParseSourceSpan(i.sourceSpan.start, B), F = new r.ParseSourceSpan(i.sourceSpan.start.moveBy(1), i.sourceSpan.end), w = new u.Element(C, m, [], O, O, void 0, F);
      this._pushElement(w), g2 && (this._popElement(C), w.endSourceSpan = O);
    }
    _pushElement(i) {
      let l = this._getParentElement();
      l && this.getTagDefinition(l.name).isClosedByChild(i.name) && this._elementStack.pop(), this._addToParent(i), this._elementStack.push(i);
    }
    _consumeEndTag(i) {
      let l = this.allowHtmComponentClosingTags && i.parts.length === 0 ? null : this._getElementFullName(i.parts[0], i.parts[1], this._getParentElement());
      if (this._getParentElement() && (this._getParentElement().endSourceSpan = i.sourceSpan), l && this.getTagDefinition(l).isVoid)
        this._errors.push(s.create(l, i.sourceSpan, `Void elements do not have end tags "${i.parts[1]}"`));
      else if (!this._popElement(l)) {
        let p = `Unexpected closing tag "${l}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
        this._errors.push(s.create(l, i.sourceSpan, p));
      }
    }
    _popElement(i) {
      for (let l = this._elementStack.length - 1; l >= 0; l--) {
        let p = this._elementStack[l];
        if (!i || (D.getNsPrefix(p.name) ? p.name == i : p.name.toLowerCase() == i.toLowerCase()))
          return this._elementStack.splice(l, this._elementStack.length - l), true;
        if (!this.getTagDefinition(p.name).closedByParent)
          return false;
      }
      return false;
    }
    _consumeAttr(i) {
      let l = D.mergeNsAndName(i.parts[0], i.parts[1]), p = i.sourceSpan.end, m = "", C, g2;
      if (this._peek.type === n.TokenType.ATTR_QUOTE && (g2 = this._advance().sourceSpan.start), this._peek.type === n.TokenType.ATTR_VALUE) {
        let B = this._advance();
        m = B.parts[0], p = B.sourceSpan.end, C = B.sourceSpan;
      }
      return this._peek.type === n.TokenType.ATTR_QUOTE && (p = this._advance().sourceSpan.end, C = new r.ParseSourceSpan(g2, p)), new u.Attribute(l, m, new r.ParseSourceSpan(i.sourceSpan.start, p), C, i.sourceSpan);
    }
    _getParentElement() {
      return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;
    }
    _getParentElementSkippingContainers() {
      let i = null;
      for (let l = this._elementStack.length - 1; l >= 0; l--) {
        if (!D.isNgContainer(this._elementStack[l].name))
          return { parent: this._elementStack[l], container: i };
        i = this._elementStack[l];
      }
      return { parent: null, container: i };
    }
    _addToParent(i) {
      let l = this._getParentElement();
      l != null ? l.children.push(i) : this._rootNodes.push(i);
    }
    _insertBeforeContainer(i, l, p) {
      if (!l)
        this._addToParent(p), this._elementStack.push(p);
      else {
        if (i) {
          let m = i.children.indexOf(l);
          i.children[m] = p;
        } else
          this._rootNodes.push(p);
        p.children.push(l), this._elementStack.splice(this._elementStack.indexOf(l), 0, p);
      }
    }
    _getElementFullName(i, l, p) {
      return i === "" && (i = this.getTagDefinition(l).implicitNamespacePrefix || "", i === "" && p != null && (i = D.getNsPrefix(p.name))), D.mergeNsAndName(i, l);
    }
  };
  function v2(i, l) {
    return i.length > 0 && i[i.length - 1] === l;
  }
} }), Ml$1 = I$1({ "node_modules/angular-html-parser/lib/compiler/src/ml_parser/html_parser.js"(e) {
  N(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Fs$1(), u = ns$1(), n = ns$1();
  e.ParseTreeResult = n.ParseTreeResult, e.TreeError = n.TreeError;
  var D = class extends u.Parser {
    constructor() {
      super(r.getHtmlTagDefinition);
    }
    parse(s, a, f) {
      let c = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, v2 = arguments.length > 4 ? arguments[4] : void 0;
      return super.parse(s, a, f, c, v2);
    }
  };
  e.HtmlParser = D;
} }), ss$1 = I$1({ "node_modules/angular-html-parser/lib/angular-html-parser/src/index.js"(e) {
  N(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Ml$1(), u = Ze$1();
  e.TagContentType = u.TagContentType;
  var n = null, D = () => (n || (n = new r.HtmlParser()), n);
  function s(a) {
    let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, { canSelfClose: c = false, allowHtmComponentClosingTags: v2 = false, isTagNameCaseSensitive: i = false, getTagContentType: l } = f;
    return D().parse(a, "angular-html-parser", { tokenizeExpansionForms: false, interpolationConfig: void 0, canSelfClose: c, allowHtmComponentClosingTags: v2 }, i, l);
  }
  e.parse = s;
} }), jl$1 = I$1({ "src/language-html/parser-html.js"(e, r) {
  N();
  var { ParseSourceSpan: u, ParseLocation: n, ParseSourceFile: D } = Ne$1(), s = JD(), a = ls$1(), f = ZD(), { inferParserByLanguage: c } = yl$1(), v2 = Bl$1(), i = Nl$1(), l = Ol$1(), { hasPragma: p } = ql$1(), { Node: m } = Il$1(), { parseIeConditionalComment: C } = Rl$1(), { locStart: g2, locEnd: B } = xl$1();
  function O(b, M2, R2) {
    let { canSelfClose: U2, normalizeTagName: k, normalizeAttributeName: j, allowHtmComponentClosingTags: L, isTagNameCaseSensitive: t, getTagContentType: o } = M2, d2 = ss$1(), { RecursiveVisitor: h, visitAll: A } = As$1(), { ParseSourceSpan: q } = Ne$1(), { getHtmlTagDefinition: P } = Fs$1(), { rootNodes: G, errors: X } = d2.parse(b, { canSelfClose: U2, allowHtmComponentClosingTags: L, isTagNameCaseSensitive: t, getTagContentType: o });
    if (R2.parser === "vue")
      if (G.some((_) => _.type === "docType" && _.value === "html" || _.type === "element" && _.name.toLowerCase() === "html")) {
        U2 = true, k = true, j = true, L = true, t = false;
        let _ = d2.parse(b, { canSelfClose: U2, allowHtmComponentClosingTags: L, isTagNameCaseSensitive: t });
        G = _.rootNodes, X = _.errors;
      } else {
        let _ = (T) => {
          if (!T || T.type !== "element" || T.name !== "template")
            return false;
          let x = T.attrs.find((V) => V.name === "lang"), $2 = x && x.value;
          return !$2 || c($2, R2) === "html";
        };
        if (G.some(_)) {
          let T, x = () => d2.parse(b, { canSelfClose: U2, allowHtmComponentClosingTags: L, isTagNameCaseSensitive: t }), $2 = () => T || (T = x()), V = (z) => $2().rootNodes.find((Y) => {
            let { startSourceSpan: ie2 } = Y;
            return ie2 && ie2.start.offset === z.startSourceSpan.start.offset;
          });
          for (let z = 0; z < G.length; z++) {
            let Y = G[z], { endSourceSpan: ie2, startSourceSpan: Ee } = Y;
            if (ie2 === null)
              X = $2().errors, G[z] = V(Y) || Y;
            else if (_(Y)) {
              let Fe2 = $2(), Oe2 = Ee.end.offset, Z = ie2.start.offset;
              for (let re of Fe2.errors) {
                let { offset: oe } = re.span.start;
                if (Oe2 < oe && oe < Z) {
                  X = [re];
                  break;
                }
              }
              G[z] = V(Y) || Y;
            }
          }
        }
      }
    if (X.length > 0) {
      let { msg: E, span: { start: _, end: T } } = X[0];
      throw f(E, { start: { line: _.line + 1, column: _.col + 1 }, end: { line: T.line + 1, column: T.col + 1 } });
    }
    let Q = (E) => {
      let _ = E.name.startsWith(":") ? E.name.slice(1).split(":")[0] : null, T = E.nameSpan.toString(), x = _ !== null && T.startsWith(`${_}:`), $2 = x ? T.slice(_.length + 1) : T;
      E.name = $2, E.namespace = _, E.hasExplicitNamespace = x;
    }, H = (E) => {
      switch (E.type) {
        case "element":
          Q(E);
          for (let _ of E.attrs)
            Q(_), _.valueSpan ? (_.value = _.valueSpan.toString(), /["']/.test(_.value[0]) && (_.value = _.value.slice(1, -1))) : _.value = null;
          break;
        case "comment":
          E.value = E.sourceSpan.toString().slice(4, -3);
          break;
        case "text":
          E.value = E.sourceSpan.toString();
          break;
      }
    }, W = (E, _) => {
      let T = E.toLowerCase();
      return _(T) ? T : E;
    }, K2 = (E) => {
      if (E.type === "element" && (k && (!E.namespace || E.namespace === E.tagDefinition.implicitNamespacePrefix || l(E)) && (E.name = W(E.name, (_) => _ in v2)), j)) {
        let _ = i[E.name] || /* @__PURE__ */ Object.create(null);
        for (let T of E.attrs)
          T.namespace || (T.name = W(T.name, (x) => E.name in i && (x in i["*"] || x in _)));
      }
    }, J = (E) => {
      E.sourceSpan && E.endSourceSpan && (E.sourceSpan = new q(E.sourceSpan.start, E.endSourceSpan.end));
    }, S = (E) => {
      if (E.type === "element") {
        let _ = P(t ? E.name : E.name.toLowerCase());
        !E.namespace || E.namespace === _.implicitNamespacePrefix || l(E) ? E.tagDefinition = _ : E.tagDefinition = P("");
      }
    };
    return A(new class extends h {
      visit(E) {
        H(E), S(E), K2(E), J(E);
      }
    }(), G), G;
  }
  function F(b, M2, R2) {
    let U2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true, { frontMatter: k, content: j } = U2 ? s(b) : { frontMatter: null, content: b }, L = new D(b, M2.filepath), t = new n(L, 0, 0, 0), o = t.moveBy(b.length), d2 = { type: "root", sourceSpan: new u(t, o), children: O(j, R2, M2) };
    if (k) {
      let q = new n(L, 0, 0, 0), P = q.moveBy(k.raw.length);
      k.sourceSpan = new u(q, P), d2.children.unshift(k);
    }
    let h = new m(d2), A = (q, P) => {
      let { offset: G } = P, X = b.slice(0, G).replace(/[^\n\r]/g, " "), H = F(X + q, M2, R2, false);
      H.sourceSpan = new u(P, a(H.children).sourceSpan.end);
      let W = H.children[0];
      return W.length === G ? H.children.shift() : (W.sourceSpan = new u(W.sourceSpan.start.moveBy(G), W.sourceSpan.end), W.value = W.value.slice(G)), H;
    };
    return h.walk((q) => {
      if (q.type === "comment") {
        let P = C(q, A);
        P && q.parent.replaceChild(q, P);
      }
    }), h;
  }
  function w() {
    let { name: b, canSelfClose: M2 = false, normalizeTagName: R2 = false, normalizeAttributeName: U2 = false, allowHtmComponentClosingTags: k = false, isTagNameCaseSensitive: j = false, getTagContentType: L } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return { parse: (t, o, d2) => F(t, Object.assign({ parser: b }, d2), { canSelfClose: M2, normalizeTagName: R2, normalizeAttributeName: U2, allowHtmComponentClosingTags: k, isTagNameCaseSensitive: j, getTagContentType: L }), hasPragma: p, astFormat: "html", locStart: g2, locEnd: B };
  }
  r.exports = { parsers: { html: w({ name: "html", canSelfClose: true, normalizeTagName: true, normalizeAttributeName: true, allowHtmComponentClosingTags: true }), angular: w({ name: "angular", canSelfClose: true }), vue: w({ name: "vue", canSelfClose: true, isTagNameCaseSensitive: true, getTagContentType: (b, M2, R2, U2) => {
    if (b.toLowerCase() !== "html" && !R2 && (b !== "template" || U2.some((k) => {
      let { name: j, value: L } = k;
      return j === "lang" && L !== "html" && L !== "" && L !== void 0;
    })))
      return ss$1().TagContentType.RAW_TEXT;
  } }), lwc: w({ name: "lwc" }) } };
} }), _2 = jl$1();
var standalone$1 = { exports: {} };
var standalone = { exports: {} };
var hasRequiredStandalone;
function requireStandalone() {
  if (hasRequiredStandalone)
    return standalone.exports;
  hasRequiredStandalone = 1;
  (function(module, exports) {
    (function(e) {
      module.exports = e();
    })(function() {
      var xe2 = (e, r) => () => (r || e((r = { exports: {} }).exports, r), r.exports);
      var pt2 = xe2((r0, pu) => {
        var ir2 = function(e) {
          return e && e.Math == Math && e;
        };
        pu.exports = ir2(typeof globalThis == "object" && globalThis) || ir2(typeof window == "object" && window) || ir2(typeof self == "object" && self) || ir2(typeof commonjsGlobal == "object" && commonjsGlobal) || function() {
          return this;
        }() || Function("return this")();
      });
      var Dt2 = xe2((n0, fu) => {
        fu.exports = function(e) {
          try {
            return !!e();
          } catch {
            return true;
          }
        };
      });
      var yt2 = xe2((u0, Du) => {
        var Mo2 = Dt2();
        Du.exports = !Mo2(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        });
      });
      var ar2 = xe2((s0, mu) => {
        var Ro2 = Dt2();
        mu.exports = !Ro2(function() {
          var e = (function() {
          }).bind();
          return typeof e != "function" || e.hasOwnProperty("prototype");
        });
      });
      var At2 = xe2((i0, du) => {
        var $o2 = ar2(), or2 = Function.prototype.call;
        du.exports = $o2 ? or2.bind(or2) : function() {
          return or2.apply(or2, arguments);
        };
      });
      var vu = xe2((hu) => {
        var gu2 = {}.propertyIsEnumerable, yu = Object.getOwnPropertyDescriptor, Vo2 = yu && !gu2.call({ 1: 2 }, 1);
        hu.f = Vo2 ? function(r) {
          var t = yu(this, r);
          return !!t && t.enumerable;
        } : gu2;
      });
      var lr2 = xe2((o0, Cu) => {
        Cu.exports = function(e, r) {
          return { enumerable: !(e & 1), configurable: !(e & 2), writable: !(e & 4), value: r };
        };
      });
      var mt2 = xe2((l0, Au) => {
        var Eu = ar2(), Fu = Function.prototype, Wr2 = Fu.call, Wo2 = Eu && Fu.bind.bind(Wr2, Wr2);
        Au.exports = Eu ? Wo2 : function(e) {
          return function() {
            return Wr2.apply(e, arguments);
          };
        };
      });
      var Vt2 = xe2((c0, xu) => {
        var Su2 = mt2(), Ho2 = Su2({}.toString), Go2 = Su2("".slice);
        xu.exports = function(e) {
          return Go2(Ho2(e), 8, -1);
        };
      });
      var Tu = xe2((p0, bu) => {
        var Uo2 = mt2(), Jo2 = Dt2(), zo2 = Vt2(), Hr2 = Object, Xo2 = Uo2("".split);
        bu.exports = Jo2(function() {
          return !Hr2("z").propertyIsEnumerable(0);
        }) ? function(e) {
          return zo2(e) == "String" ? Xo2(e, "") : Hr2(e);
        } : Hr2;
      });
      var cr2 = xe2((f0, Bu) => {
        Bu.exports = function(e) {
          return e == null;
        };
      });
      var Gr2 = xe2((D0, Nu2) => {
        var Ko2 = cr2(), Yo2 = TypeError;
        Nu2.exports = function(e) {
          if (Ko2(e))
            throw Yo2("Can't call method on " + e);
          return e;
        };
      });
      var pr2 = xe2((m0, wu) => {
        var Qo2 = Tu(), Zo2 = Gr2();
        wu.exports = function(e) {
          return Qo2(Zo2(e));
        };
      });
      var Jr2 = xe2((d0, _u2) => {
        var Ur2 = typeof document == "object" && document.all, el2 = typeof Ur2 > "u" && Ur2 !== void 0;
        _u2.exports = { all: Ur2, IS_HTMLDDA: el2 };
      });
      var ot2 = xe2((g0, Iu) => {
        var Pu = Jr2(), tl2 = Pu.all;
        Iu.exports = Pu.IS_HTMLDDA ? function(e) {
          return typeof e == "function" || e === tl2;
        } : function(e) {
          return typeof e == "function";
        };
      });
      var St2 = xe2((y0, Ou) => {
        var ku = ot2(), Lu = Jr2(), rl2 = Lu.all;
        Ou.exports = Lu.IS_HTMLDDA ? function(e) {
          return typeof e == "object" ? e !== null : ku(e) || e === rl2;
        } : function(e) {
          return typeof e == "object" ? e !== null : ku(e);
        };
      });
      var Wt = xe2((h0, ju2) => {
        var zr2 = pt2(), nl2 = ot2(), ul2 = function(e) {
          return nl2(e) ? e : void 0;
        };
        ju2.exports = function(e, r) {
          return arguments.length < 2 ? ul2(zr2[e]) : zr2[e] && zr2[e][r];
        };
      });
      var Xr2 = xe2((v0, qu) => {
        var sl2 = mt2();
        qu.exports = sl2({}.isPrototypeOf);
      });
      var Ru = xe2((C0, Mu) => {
        var il2 = Wt();
        Mu.exports = il2("navigator", "userAgent") || "";
      });
      var Ju = xe2((E0, Uu) => {
        var Gu = pt2(), Kr2 = Ru(), $u2 = Gu.process, Vu = Gu.Deno, Wu = $u2 && $u2.versions || Vu && Vu.version, Hu2 = Wu && Wu.v8, dt2, fr2;
        Hu2 && (dt2 = Hu2.split("."), fr2 = dt2[0] > 0 && dt2[0] < 4 ? 1 : +(dt2[0] + dt2[1]));
        !fr2 && Kr2 && (dt2 = Kr2.match(/Edge\/(\d+)/), (!dt2 || dt2[1] >= 74) && (dt2 = Kr2.match(/Chrome\/(\d+)/), dt2 && (fr2 = +dt2[1])));
        Uu.exports = fr2;
      });
      var Yr2 = xe2((F0, Xu) => {
        var zu = Ju(), al2 = Dt2();
        Xu.exports = !!Object.getOwnPropertySymbols && !al2(function() {
          var e = Symbol();
          return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && zu && zu < 41;
        });
      });
      var Qr = xe2((A0, Ku) => {
        var ol2 = Yr2();
        Ku.exports = ol2 && !Symbol.sham && typeof Symbol.iterator == "symbol";
      });
      var Zr2 = xe2((S0, Yu) => {
        var ll2 = Wt(), cl2 = ot2(), pl2 = Xr2(), fl2 = Qr(), Dl2 = Object;
        Yu.exports = fl2 ? function(e) {
          return typeof e == "symbol";
        } : function(e) {
          var r = ll2("Symbol");
          return cl2(r) && pl2(r.prototype, Dl2(e));
        };
      });
      var Dr2 = xe2((x0, Qu) => {
        var ml2 = String;
        Qu.exports = function(e) {
          try {
            return ml2(e);
          } catch {
            return "Object";
          }
        };
      });
      var Ht = xe2((b0, Zu2) => {
        var dl2 = ot2(), gl2 = Dr2(), yl2 = TypeError;
        Zu2.exports = function(e) {
          if (dl2(e))
            return e;
          throw yl2(gl2(e) + " is not a function");
        };
      });
      var mr2 = xe2((T0, es) => {
        var hl2 = Ht(), vl2 = cr2();
        es.exports = function(e, r) {
          var t = e[r];
          return vl2(t) ? void 0 : hl2(t);
        };
      });
      var rs2 = xe2((B0, ts2) => {
        var en2 = At2(), tn2 = ot2(), rn2 = St2(), Cl2 = TypeError;
        ts2.exports = function(e, r) {
          var t, s;
          if (r === "string" && tn2(t = e.toString) && !rn2(s = en2(t, e)) || tn2(t = e.valueOf) && !rn2(s = en2(t, e)) || r !== "string" && tn2(t = e.toString) && !rn2(s = en2(t, e)))
            return s;
          throw Cl2("Can't convert object to primitive value");
        };
      });
      var us2 = xe2((N0, ns2) => {
        ns2.exports = false;
      });
      var dr2 = xe2((w0, is2) => {
        var ss2 = pt2(), El2 = Object.defineProperty;
        is2.exports = function(e, r) {
          try {
            El2(ss2, e, { value: r, configurable: true, writable: true });
          } catch {
            ss2[e] = r;
          }
          return r;
        };
      });
      var gr2 = xe2((_0, os2) => {
        var Fl2 = pt2(), Al2 = dr2(), as2 = "__core-js_shared__", Sl2 = Fl2[as2] || Al2(as2, {});
        os2.exports = Sl2;
      });
      var nn2 = xe2((P0, cs2) => {
        var xl2 = us2(), ls2 = gr2();
        (cs2.exports = function(e, r) {
          return ls2[e] || (ls2[e] = r !== void 0 ? r : {});
        })("versions", []).push({ version: "3.26.1", mode: xl2 ? "pure" : "global", copyright: "© 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE", source: "https://github.com/zloirock/core-js" });
      });
      var yr2 = xe2((I0, ps2) => {
        var bl2 = Gr2(), Tl2 = Object;
        ps2.exports = function(e) {
          return Tl2(bl2(e));
        };
      });
      var Ct2 = xe2((k0, fs2) => {
        var Bl2 = mt2(), Nl2 = yr2(), wl2 = Bl2({}.hasOwnProperty);
        fs2.exports = Object.hasOwn || function(r, t) {
          return wl2(Nl2(r), t);
        };
      });
      var un2 = xe2((L0, Ds2) => {
        var _l2 = mt2(), Pl2 = 0, Il2 = Math.random(), kl2 = _l2(1 .toString);
        Ds2.exports = function(e) {
          return "Symbol(" + (e === void 0 ? "" : e) + ")_" + kl2(++Pl2 + Il2, 36);
        };
      });
      var bt2 = xe2((O0, hs2) => {
        var Ll2 = pt2(), Ol2 = nn2(), ms2 = Ct2(), jl2 = un2(), ds2 = Yr2(), ys2 = Qr(), It2 = Ol2("wks"), xt2 = Ll2.Symbol, gs2 = xt2 && xt2.for, ql2 = ys2 ? xt2 : xt2 && xt2.withoutSetter || jl2;
        hs2.exports = function(e) {
          if (!ms2(It2, e) || !(ds2 || typeof It2[e] == "string")) {
            var r = "Symbol." + e;
            ds2 && ms2(xt2, e) ? It2[e] = xt2[e] : ys2 && gs2 ? It2[e] = gs2(r) : It2[e] = ql2(r);
          }
          return It2[e];
        };
      });
      var Fs2 = xe2((j0, Es2) => {
        var Ml2 = At2(), vs2 = St2(), Cs2 = Zr2(), Rl2 = mr2(), $l2 = rs2(), Vl2 = bt2(), Wl2 = TypeError, Hl2 = Vl2("toPrimitive");
        Es2.exports = function(e, r) {
          if (!vs2(e) || Cs2(e))
            return e;
          var t = Rl2(e, Hl2), s;
          if (t) {
            if (r === void 0 && (r = "default"), s = Ml2(t, e, r), !vs2(s) || Cs2(s))
              return s;
            throw Wl2("Can't convert object to primitive value");
          }
          return r === void 0 && (r = "number"), $l2(e, r);
        };
      });
      var hr2 = xe2((q0, As2) => {
        var Gl2 = Fs2(), Ul2 = Zr2();
        As2.exports = function(e) {
          var r = Gl2(e, "string");
          return Ul2(r) ? r : r + "";
        };
      });
      var bs2 = xe2((M0, xs2) => {
        var Jl2 = pt2(), Ss2 = St2(), sn2 = Jl2.document, zl2 = Ss2(sn2) && Ss2(sn2.createElement);
        xs2.exports = function(e) {
          return zl2 ? sn2.createElement(e) : {};
        };
      });
      var an2 = xe2((R0, Ts2) => {
        var Xl2 = yt2(), Kl2 = Dt2(), Yl2 = bs2();
        Ts2.exports = !Xl2 && !Kl2(function() {
          return Object.defineProperty(Yl2("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      });
      var on = xe2((Ns2) => {
        var Ql2 = yt2(), Zl2 = At2(), ec = vu(), tc = lr2(), rc = pr2(), nc = hr2(), uc = Ct2(), sc = an2(), Bs2 = Object.getOwnPropertyDescriptor;
        Ns2.f = Ql2 ? Bs2 : function(r, t) {
          if (r = rc(r), t = nc(t), sc)
            try {
              return Bs2(r, t);
            } catch {
            }
          if (uc(r, t))
            return tc(!Zl2(ec.f, r, t), r[t]);
        };
      });
      var _s2 = xe2((V0, ws2) => {
        var ic = yt2(), ac = Dt2();
        ws2.exports = ic && ac(function() {
          return Object.defineProperty(function() {
          }, "prototype", { value: 42, writable: false }).prototype != 42;
        });
      });
      var Tt2 = xe2((W0, Ps2) => {
        var oc = St2(), lc = String, cc = TypeError;
        Ps2.exports = function(e) {
          if (oc(e))
            return e;
          throw cc(lc(e) + " is not an object");
        };
      });
      var kt2 = xe2((ks2) => {
        var pc = yt2(), fc = an2(), Dc = _s2(), vr2 = Tt2(), Is2 = hr2(), mc = TypeError, ln2 = Object.defineProperty, dc = Object.getOwnPropertyDescriptor, cn2 = "enumerable", pn2 = "configurable", fn2 = "writable";
        ks2.f = pc ? Dc ? function(r, t, s) {
          if (vr2(r), t = Is2(t), vr2(s), typeof r == "function" && t === "prototype" && "value" in s && fn2 in s && !s[fn2]) {
            var a = dc(r, t);
            a && a[fn2] && (r[t] = s.value, s = { configurable: pn2 in s ? s[pn2] : a[pn2], enumerable: cn2 in s ? s[cn2] : a[cn2], writable: false });
          }
          return ln2(r, t, s);
        } : ln2 : function(r, t, s) {
          if (vr2(r), t = Is2(t), vr2(s), fc)
            try {
              return ln2(r, t, s);
            } catch {
            }
          if ("get" in s || "set" in s)
            throw mc("Accessors not supported");
          return "value" in s && (r[t] = s.value), r;
        };
      });
      var Dn2 = xe2((G0, Ls2) => {
        var gc = yt2(), yc = kt2(), hc = lr2();
        Ls2.exports = gc ? function(e, r, t) {
          return yc.f(e, r, hc(1, t));
        } : function(e, r, t) {
          return e[r] = t, e;
        };
      });
      var qs2 = xe2((U0, js2) => {
        var mn2 = yt2(), vc = Ct2(), Os2 = Function.prototype, Cc = mn2 && Object.getOwnPropertyDescriptor, dn2 = vc(Os2, "name"), Ec = dn2 && (function() {
        }).name === "something", Fc = dn2 && (!mn2 || mn2 && Cc(Os2, "name").configurable);
        js2.exports = { EXISTS: dn2, PROPER: Ec, CONFIGURABLE: Fc };
      });
      var yn = xe2((J0, Ms2) => {
        var Ac = mt2(), Sc = ot2(), gn2 = gr2(), xc = Ac(Function.toString);
        Sc(gn2.inspectSource) || (gn2.inspectSource = function(e) {
          return xc(e);
        });
        Ms2.exports = gn2.inspectSource;
      });
      var Vs2 = xe2((z0, $s2) => {
        var bc = pt2(), Tc = ot2(), Rs2 = bc.WeakMap;
        $s2.exports = Tc(Rs2) && /native code/.test(String(Rs2));
      });
      var Gs2 = xe2((X0, Hs2) => {
        var Bc = nn2(), Nc = un2(), Ws2 = Bc("keys");
        Hs2.exports = function(e) {
          return Ws2[e] || (Ws2[e] = Nc(e));
        };
      });
      var hn2 = xe2((K0, Us2) => {
        Us2.exports = {};
      });
      var Ks2 = xe2((Y0, Xs2) => {
        var wc = Vs2(), zs2 = pt2(), _c2 = St2(), Pc = Dn2(), vn2 = Ct2(), Cn2 = gr2(), Ic = Gs2(), kc = hn2(), Js2 = "Object already initialized", En2 = zs2.TypeError, Lc = zs2.WeakMap, Cr2, Gt2, Er2, Oc = function(e) {
          return Er2(e) ? Gt2(e) : Cr2(e, {});
        }, jc = function(e) {
          return function(r) {
            var t;
            if (!_c2(r) || (t = Gt2(r)).type !== e)
              throw En2("Incompatible receiver, " + e + " required");
            return t;
          };
        };
        wc || Cn2.state ? (gt2 = Cn2.state || (Cn2.state = new Lc()), gt2.get = gt2.get, gt2.has = gt2.has, gt2.set = gt2.set, Cr2 = function(e, r) {
          if (gt2.has(e))
            throw En2(Js2);
          return r.facade = e, gt2.set(e, r), r;
        }, Gt2 = function(e) {
          return gt2.get(e) || {};
        }, Er2 = function(e) {
          return gt2.has(e);
        }) : (Bt2 = Ic("state"), kc[Bt2] = true, Cr2 = function(e, r) {
          if (vn2(e, Bt2))
            throw En2(Js2);
          return r.facade = e, Pc(e, Bt2, r), r;
        }, Gt2 = function(e) {
          return vn2(e, Bt2) ? e[Bt2] : {};
        }, Er2 = function(e) {
          return vn2(e, Bt2);
        });
        var gt2, Bt2;
        Xs2.exports = { set: Cr2, get: Gt2, has: Er2, enforce: Oc, getterFor: jc };
      });
      var An = xe2((Q0, Qs2) => {
        var qc = Dt2(), Mc = ot2(), Fr2 = Ct2(), Fn2 = yt2(), Rc = qs2().CONFIGURABLE, $c = yn(), Ys2 = Ks2(), Vc = Ys2.enforce, Wc = Ys2.get, Ar2 = Object.defineProperty, Hc = Fn2 && !qc(function() {
          return Ar2(function() {
          }, "length", { value: 8 }).length !== 8;
        }), Gc = String(String).split("String"), Uc = Qs2.exports = function(e, r, t) {
          String(r).slice(0, 7) === "Symbol(" && (r = "[" + String(r).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), t && t.getter && (r = "get " + r), t && t.setter && (r = "set " + r), (!Fr2(e, "name") || Rc && e.name !== r) && (Fn2 ? Ar2(e, "name", { value: r, configurable: true }) : e.name = r), Hc && t && Fr2(t, "arity") && e.length !== t.arity && Ar2(e, "length", { value: t.arity });
          try {
            t && Fr2(t, "constructor") && t.constructor ? Fn2 && Ar2(e, "prototype", { writable: false }) : e.prototype && (e.prototype = void 0);
          } catch {
          }
          var s = Vc(e);
          return Fr2(s, "source") || (s.source = Gc.join(typeof r == "string" ? r : "")), e;
        };
        Function.prototype.toString = Uc(function() {
          return Mc(this) && Wc(this).source || $c(this);
        }, "toString");
      });
      var ei = xe2((Z0, Zs2) => {
        var Jc = ot2(), zc = kt2(), Xc = An(), Kc = dr2();
        Zs2.exports = function(e, r, t, s) {
          s || (s = {});
          var a = s.enumerable, n = s.name !== void 0 ? s.name : r;
          if (Jc(t) && Xc(t, n, s), s.global)
            a ? e[r] = t : Kc(r, t);
          else {
            try {
              s.unsafe ? e[r] && (a = true) : delete e[r];
            } catch {
            }
            a ? e[r] = t : zc.f(e, r, { value: t, enumerable: false, configurable: !s.nonConfigurable, writable: !s.nonWritable });
          }
          return e;
        };
      });
      var ri2 = xe2((ey, ti2) => {
        var Yc = Math.ceil, Qc = Math.floor;
        ti2.exports = Math.trunc || function(r) {
          var t = +r;
          return (t > 0 ? Qc : Yc)(t);
        };
      });
      var Sr2 = xe2((ty, ni) => {
        var Zc = ri2();
        ni.exports = function(e) {
          var r = +e;
          return r !== r || r === 0 ? 0 : Zc(r);
        };
      });
      var si = xe2((ry, ui2) => {
        var ep = Sr2(), tp = Math.max, rp = Math.min;
        ui2.exports = function(e, r) {
          var t = ep(e);
          return t < 0 ? tp(t + r, 0) : rp(t, r);
        };
      });
      var ai = xe2((ny, ii) => {
        var np = Sr2(), up = Math.min;
        ii.exports = function(e) {
          return e > 0 ? up(np(e), 9007199254740991) : 0;
        };
      });
      var Lt2 = xe2((uy, oi2) => {
        var sp = ai();
        oi2.exports = function(e) {
          return sp(e.length);
        };
      });
      var pi2 = xe2((sy, ci) => {
        var ip = pr2(), ap = si(), op = Lt2(), li = function(e) {
          return function(r, t, s) {
            var a = ip(r), n = op(a), u = ap(s, n), i;
            if (e && t != t) {
              for (; n > u; )
                if (i = a[u++], i != i)
                  return true;
            } else
              for (; n > u; u++)
                if ((e || u in a) && a[u] === t)
                  return e || u || 0;
            return !e && -1;
          };
        };
        ci.exports = { includes: li(true), indexOf: li(false) };
      });
      var mi = xe2((iy, Di2) => {
        var lp = mt2(), Sn2 = Ct2(), cp = pr2(), pp = pi2().indexOf, fp = hn2(), fi2 = lp([].push);
        Di2.exports = function(e, r) {
          var t = cp(e), s = 0, a = [], n;
          for (n in t)
            !Sn2(fp, n) && Sn2(t, n) && fi2(a, n);
          for (; r.length > s; )
            Sn2(t, n = r[s++]) && (~pp(a, n) || fi2(a, n));
          return a;
        };
      });
      var gi = xe2((ay, di2) => {
        di2.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      });
      var hi = xe2((yi2) => {
        var Dp = mi(), mp = gi(), dp = mp.concat("length", "prototype");
        yi2.f = Object.getOwnPropertyNames || function(r) {
          return Dp(r, dp);
        };
      });
      var Ci = xe2((vi2) => {
        vi2.f = Object.getOwnPropertySymbols;
      });
      var Fi2 = xe2((cy, Ei) => {
        var gp = Wt(), yp = mt2(), hp = hi(), vp2 = Ci(), Cp2 = Tt2(), Ep2 = yp([].concat);
        Ei.exports = gp("Reflect", "ownKeys") || function(r) {
          var t = hp.f(Cp2(r)), s = vp2.f;
          return s ? Ep2(t, s(r)) : t;
        };
      });
      var xi = xe2((py, Si2) => {
        var Ai2 = Ct2(), Fp = Fi2(), Ap2 = on(), Sp = kt2();
        Si2.exports = function(e, r, t) {
          for (var s = Fp(r), a = Sp.f, n = Ap2.f, u = 0; u < s.length; u++) {
            var i = s[u];
            !Ai2(e, i) && !(t && Ai2(t, i)) && a(e, i, n(r, i));
          }
        };
      });
      var Ti2 = xe2((fy, bi) => {
        var xp = Dt2(), bp = ot2(), Tp2 = /#|\.prototype\./, Ut = function(e, r) {
          var t = Np[Bp(e)];
          return t == _p ? true : t == wp ? false : bp(r) ? xp(r) : !!r;
        }, Bp = Ut.normalize = function(e) {
          return String(e).replace(Tp2, ".").toLowerCase();
        }, Np = Ut.data = {}, wp = Ut.NATIVE = "N", _p = Ut.POLYFILL = "P";
        bi.exports = Ut;
      });
      var Jt2 = xe2((Dy, Bi2) => {
        var xn2 = pt2(), Pp2 = on().f, Ip = Dn2(), kp = ei(), Lp = dr2(), Op = xi(), jp = Ti2();
        Bi2.exports = function(e, r) {
          var t = e.target, s = e.global, a = e.stat, n, u, i, l, p, y2;
          if (s ? u = xn2 : a ? u = xn2[t] || Lp(t, {}) : u = (xn2[t] || {}).prototype, u)
            for (i in r) {
              if (p = r[i], e.dontCallGetSet ? (y2 = Pp2(u, i), l = y2 && y2.value) : l = u[i], n = jp(s ? i : t + (a ? "." : "#") + i, e.forced), !n && l !== void 0) {
                if (typeof p == typeof l)
                  continue;
                Op(p, l);
              }
              (e.sham || l && l.sham) && Ip(p, "sham", true), kp(u, i, p, e);
            }
        };
      });
      var bn2 = xe2((my, Ni2) => {
        var qp = Vt2();
        Ni2.exports = Array.isArray || function(r) {
          return qp(r) == "Array";
        };
      });
      var _i2 = xe2((dy, wi2) => {
        var Mp = TypeError, Rp = 9007199254740991;
        wi2.exports = function(e) {
          if (e > Rp)
            throw Mp("Maximum allowed index exceeded");
          return e;
        };
      });
      var Ii2 = xe2((gy, Pi) => {
        var $p = Vt2(), Vp = mt2();
        Pi.exports = function(e) {
          if ($p(e) === "Function")
            return Vp(e);
        };
      });
      var Tn2 = xe2((yy, Li2) => {
        var ki = Ii2(), Wp = Ht(), Hp = ar2(), Gp = ki(ki.bind);
        Li2.exports = function(e, r) {
          return Wp(e), r === void 0 ? e : Hp ? Gp(e, r) : function() {
            return e.apply(r, arguments);
          };
        };
      });
      var Bn2 = xe2((hy, ji2) => {
        var Up = bn2(), Jp = Lt2(), zp = _i2(), Xp = Tn2(), Oi2 = function(e, r, t, s, a, n, u, i) {
          for (var l = a, p = 0, y2 = u ? Xp(u, i) : false, h, g2; p < s; )
            p in t && (h = y2 ? y2(t[p], p, r) : t[p], n > 0 && Up(h) ? (g2 = Jp(h), l = Oi2(e, r, h, g2, l, n - 1) - 1) : (zp(l + 1), e[l] = h), l++), p++;
          return l;
        };
        ji2.exports = Oi2;
      });
      var Ri = xe2((vy, Mi2) => {
        var Kp = bt2(), Yp = Kp("toStringTag"), qi = {};
        qi[Yp] = "z";
        Mi2.exports = String(qi) === "[object z]";
      });
      var Nn2 = xe2((Cy, $i2) => {
        var Qp = Ri(), Zp = ot2(), xr2 = Vt2(), ef2 = bt2(), tf2 = ef2("toStringTag"), rf2 = Object, nf2 = xr2(function() {
          return arguments;
        }()) == "Arguments", uf2 = function(e, r) {
          try {
            return e[r];
          } catch {
          }
        };
        $i2.exports = Qp ? xr2 : function(e) {
          var r, t, s;
          return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (t = uf2(r = rf2(e), tf2)) == "string" ? t : nf2 ? xr2(r) : (s = xr2(r)) == "Object" && Zp(r.callee) ? "Arguments" : s;
        };
      });
      var Ji2 = xe2((Ey, Ui2) => {
        var sf2 = mt2(), af2 = Dt2(), Vi2 = ot2(), of2 = Nn2(), lf2 = Wt(), cf2 = yn(), Wi2 = function() {
        }, pf2 = [], Hi2 = lf2("Reflect", "construct"), wn2 = /^\s*(?:class|function)\b/, ff2 = sf2(wn2.exec), Df2 = !wn2.exec(Wi2), zt2 = function(r) {
          if (!Vi2(r))
            return false;
          try {
            return Hi2(Wi2, pf2, r), true;
          } catch {
            return false;
          }
        }, Gi = function(r) {
          if (!Vi2(r))
            return false;
          switch (of2(r)) {
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
              return false;
          }
          try {
            return Df2 || !!ff2(wn2, cf2(r));
          } catch {
            return true;
          }
        };
        Gi.sham = true;
        Ui2.exports = !Hi2 || af2(function() {
          var e;
          return zt2(zt2.call) || !zt2(Object) || !zt2(function() {
            e = true;
          }) || e;
        }) ? Gi : zt2;
      });
      var Yi2 = xe2((Fy, Ki) => {
        var zi2 = bn2(), mf2 = Ji2(), df2 = St2(), gf2 = bt2(), yf2 = gf2("species"), Xi2 = Array;
        Ki.exports = function(e) {
          var r;
          return zi2(e) && (r = e.constructor, mf2(r) && (r === Xi2 || zi2(r.prototype)) ? r = void 0 : df2(r) && (r = r[yf2], r === null && (r = void 0))), r === void 0 ? Xi2 : r;
        };
      });
      var _n2 = xe2((Ay, Qi2) => {
        var hf2 = Yi2();
        Qi2.exports = function(e, r) {
          return new (hf2(e))(r === 0 ? 0 : r);
        };
      });
      var Zi2 = xe2(() => {
        var vf2 = Jt2(), Cf2 = Bn2(), Ef2 = Ht(), Ff2 = yr2(), Af2 = Lt2(), Sf2 = _n2();
        vf2({ target: "Array", proto: true }, { flatMap: function(r) {
          var t = Ff2(this), s = Af2(t), a;
          return Ef2(r), a = Sf2(t, 0), a.length = Cf2(a, t, t, s, 0, 1, r, arguments.length > 1 ? arguments[1] : void 0), a;
        } });
      });
      var Pn2 = xe2((by, ea2) => {
        ea2.exports = {};
      });
      var ra2 = xe2((Ty2, ta2) => {
        var xf2 = bt2(), bf2 = Pn2(), Tf2 = xf2("iterator"), Bf2 = Array.prototype;
        ta2.exports = function(e) {
          return e !== void 0 && (bf2.Array === e || Bf2[Tf2] === e);
        };
      });
      var In2 = xe2((By, ua) => {
        var Nf2 = Nn2(), na2 = mr2(), wf2 = cr2(), _f2 = Pn2(), Pf2 = bt2(), If2 = Pf2("iterator");
        ua.exports = function(e) {
          if (!wf2(e))
            return na2(e, If2) || na2(e, "@@iterator") || _f2[Nf2(e)];
        };
      });
      var ia = xe2((Ny, sa2) => {
        var kf2 = At2(), Lf2 = Ht(), Of2 = Tt2(), jf2 = Dr2(), qf2 = In2(), Mf2 = TypeError;
        sa2.exports = function(e, r) {
          var t = arguments.length < 2 ? qf2(e) : r;
          if (Lf2(t))
            return Of2(kf2(t, e));
          throw Mf2(jf2(e) + " is not iterable");
        };
      });
      var la = xe2((wy, oa) => {
        var Rf2 = At2(), aa = Tt2(), $f = mr2();
        oa.exports = function(e, r, t) {
          var s, a;
          aa(e);
          try {
            if (s = $f(e, "return"), !s) {
              if (r === "throw")
                throw t;
              return t;
            }
            s = Rf2(s, e);
          } catch (n) {
            a = true, s = n;
          }
          if (r === "throw")
            throw t;
          if (a)
            throw s;
          return aa(s), t;
        };
      });
      var ma = xe2((_y, Da) => {
        var Vf = Tn2(), Wf = At2(), Hf = Tt2(), Gf2 = Dr2(), Uf2 = ra2(), Jf2 = Lt2(), ca2 = Xr2(), zf = ia(), Xf = In2(), pa = la(), Kf2 = TypeError, br2 = function(e, r) {
          this.stopped = e, this.result = r;
        }, fa2 = br2.prototype;
        Da.exports = function(e, r, t) {
          var s = t && t.that, a = !!(t && t.AS_ENTRIES), n = !!(t && t.IS_RECORD), u = !!(t && t.IS_ITERATOR), i = !!(t && t.INTERRUPTED), l = Vf(r, s), p, y2, h, g2, c, f, F, _ = function(E) {
            return p && pa(p, "normal", E), new br2(true, E);
          }, w = function(E) {
            return a ? (Hf(E), i ? l(E[0], E[1], _) : l(E[0], E[1])) : i ? l(E, _) : l(E);
          };
          if (n)
            p = e.iterator;
          else if (u)
            p = e;
          else {
            if (y2 = Xf(e), !y2)
              throw Kf2(Gf2(e) + " is not iterable");
            if (Uf2(y2)) {
              for (h = 0, g2 = Jf2(e); g2 > h; h++)
                if (c = w(e[h]), c && ca2(fa2, c))
                  return c;
              return new br2(false);
            }
            p = zf(e, y2);
          }
          for (f = n ? e.next : p.next; !(F = Wf(f, p)).done; ) {
            try {
              c = w(F.value);
            } catch (E) {
              pa(p, "throw", E);
            }
            if (typeof c == "object" && c && ca2(fa2, c))
              return c;
          }
          return new br2(false);
        };
      });
      var ga2 = xe2((Py, da2) => {
        var Yf2 = hr2(), Qf2 = kt2(), Zf2 = lr2();
        da2.exports = function(e, r, t) {
          var s = Yf2(r);
          s in e ? Qf2.f(e, s, Zf2(0, t)) : e[s] = t;
        };
      });
      var ya2 = xe2(() => {
        var eD2 = Jt2(), tD2 = ma(), rD = ga2();
        eD2({ target: "Object", stat: true }, { fromEntries: function(r) {
          var t = {};
          return tD2(r, function(s, a) {
            rD(t, s, a);
          }, { AS_ENTRIES: true }), t;
        } });
      });
      var Ca2 = xe2((Ly, va2) => {
        var ha2 = An(), nD2 = kt2();
        va2.exports = function(e, r, t) {
          return t.get && ha2(t.get, r, { getter: true }), t.set && ha2(t.set, r, { setter: true }), nD2.f(e, r, t);
        };
      });
      var Fa2 = xe2((Oy, Ea2) => {
        var uD2 = Tt2();
        Ea2.exports = function() {
          var e = uD2(this), r = "";
          return e.hasIndices && (r += "d"), e.global && (r += "g"), e.ignoreCase && (r += "i"), e.multiline && (r += "m"), e.dotAll && (r += "s"), e.unicode && (r += "u"), e.unicodeSets && (r += "v"), e.sticky && (r += "y"), r;
        };
      });
      var xa2 = xe2(() => {
        var sD2 = pt2(), iD2 = yt2(), aD2 = Ca2(), oD2 = Fa2(), lD2 = Dt2(), Aa2 = sD2.RegExp, Sa2 = Aa2.prototype, cD2 = iD2 && lD2(function() {
          var e = true;
          try {
            Aa2(".", "d");
          } catch {
            e = false;
          }
          var r = {}, t = "", s = e ? "dgimsy" : "gimsy", a = function(l, p) {
            Object.defineProperty(r, l, { get: function() {
              return t += p, true;
            } });
          }, n = { dotAll: "s", global: "g", ignoreCase: "i", multiline: "m", sticky: "y" };
          e && (n.hasIndices = "d");
          for (var u in n)
            a(u, n[u]);
          var i = Object.getOwnPropertyDescriptor(Sa2, "flags").get.call(r);
          return i !== s || t !== s;
        });
        cD2 && aD2(Sa2, "flags", { configurable: true, get: oD2 });
      });
      var ba2 = xe2(() => {
        var pD2 = Jt2(), kn2 = pt2();
        pD2({ global: true, forced: kn2.globalThis !== kn2 }, { globalThis: kn2 });
      });
      var Ta2 = xe2(() => {
        ba2();
      });
      var Ba2 = xe2(() => {
        var fD2 = Jt2(), DD2 = Bn2(), mD2 = yr2(), dD2 = Lt2(), gD2 = Sr2(), yD2 = _n2();
        fD2({ target: "Array", proto: true }, { flat: function() {
          var r = arguments.length ? arguments[0] : void 0, t = mD2(this), s = dD2(t), a = yD2(t, 0);
          return a.length = DD2(a, t, t, s, 0, r === void 0 ? 1 : gD2(r)), a;
        } });
      });
      var e0 = xe2((Uy, jo2) => {
        var hD2 = ["cliName", "cliCategory", "cliDescription"], vD2 = ["_"], CD2 = ["languageId"];
        function Hn2(e, r) {
          if (e == null)
            return {};
          var t = ED2(e, r), s, a;
          if (Object.getOwnPropertySymbols) {
            var n = Object.getOwnPropertySymbols(e);
            for (a = 0; a < n.length; a++)
              s = n[a], !(r.indexOf(s) >= 0) && Object.prototype.propertyIsEnumerable.call(e, s) && (t[s] = e[s]);
          }
          return t;
        }
        function ED2(e, r) {
          if (e == null)
            return {};
          var t = {}, s = Object.keys(e), a, n;
          for (n = 0; n < s.length; n++)
            a = s[n], !(r.indexOf(a) >= 0) && (t[a] = e[a]);
          return t;
        }
        Zi2();
        ya2();
        xa2();
        Ta2();
        Ba2();
        var FD2 = Object.create, _r2 = Object.defineProperty, AD2 = Object.getOwnPropertyDescriptor, Gn2 = Object.getOwnPropertyNames, SD2 = Object.getPrototypeOf, xD2 = Object.prototype.hasOwnProperty, ht2 = (e, r) => function() {
          return e && (r = (0, e[Gn2(e)[0]])(e = 0)), r;
        }, te2 = (e, r) => function() {
          return r || (0, e[Gn2(e)[0]])((r = { exports: {} }).exports, r), r.exports;
        }, Kt2 = (e, r) => {
          for (var t in r)
            _r2(e, t, { get: r[t], enumerable: true });
        }, Pa2 = (e, r, t, s) => {
          if (r && typeof r == "object" || typeof r == "function")
            for (let a of Gn2(r))
              !xD2.call(e, a) && a !== t && _r2(e, a, { get: () => r[a], enumerable: !(s = AD2(r, a)) || s.enumerable });
          return e;
        }, bD2 = (e, r, t) => (t = e != null ? FD2(SD2(e)) : {}, Pa2(r || !e || !e.__esModule ? _r2(t, "default", { value: e, enumerable: true }) : t, e)), ft2 = (e) => Pa2(_r2({}, "__esModule", { value: true }), e), wt2, ne2 = ht2({ "<define:process>"() {
          wt2 = { env: {}, argv: [] };
        } }), Ia2 = te2({ "package.json"(e, r) {
          r.exports = { version: "2.8.8" };
        } }), TD2 = te2({ "node_modules/diff/lib/diff/base.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true }), e.default = r;
          function r() {
          }
          r.prototype = { diff: function(n, u) {
            var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, l = i.callback;
            typeof i == "function" && (l = i, i = {}), this.options = i;
            var p = this;
            function y2(N2) {
              return l ? (setTimeout(function() {
                l(void 0, N2);
              }, 0), true) : N2;
            }
            n = this.castInput(n), u = this.castInput(u), n = this.removeEmpty(this.tokenize(n)), u = this.removeEmpty(this.tokenize(u));
            var h = u.length, g2 = n.length, c = 1, f = h + g2, F = [{ newPos: -1, components: [] }], _ = this.extractCommon(F[0], u, n, 0);
            if (F[0].newPos + 1 >= h && _ + 1 >= g2)
              return y2([{ value: this.join(u), count: u.length }]);
            function w() {
              for (var N2 = -1 * c; N2 <= c; N2 += 2) {
                var x = void 0, I2 = F[N2 - 1], P = F[N2 + 1], $2 = (P ? P.newPos : 0) - N2;
                I2 && (F[N2 - 1] = void 0);
                var D = I2 && I2.newPos + 1 < h, T = P && 0 <= $2 && $2 < g2;
                if (!D && !T) {
                  F[N2] = void 0;
                  continue;
                }
                if (!D || T && I2.newPos < P.newPos ? (x = s(P), p.pushComponent(x.components, void 0, true)) : (x = I2, x.newPos++, p.pushComponent(x.components, true, void 0)), $2 = p.extractCommon(x, u, n, N2), x.newPos + 1 >= h && $2 + 1 >= g2)
                  return y2(t(p, x.components, u, n, p.useLongestToken));
                F[N2] = x;
              }
              c++;
            }
            if (l)
              (function N2() {
                setTimeout(function() {
                  if (c > f)
                    return l();
                  w() || N2();
                }, 0);
              })();
            else
              for (; c <= f; ) {
                var E = w();
                if (E)
                  return E;
              }
          }, pushComponent: function(n, u, i) {
            var l = n[n.length - 1];
            l && l.added === u && l.removed === i ? n[n.length - 1] = { count: l.count + 1, added: u, removed: i } : n.push({ count: 1, added: u, removed: i });
          }, extractCommon: function(n, u, i, l) {
            for (var p = u.length, y2 = i.length, h = n.newPos, g2 = h - l, c = 0; h + 1 < p && g2 + 1 < y2 && this.equals(u[h + 1], i[g2 + 1]); )
              h++, g2++, c++;
            return c && n.components.push({ count: c }), n.newPos = h, g2;
          }, equals: function(n, u) {
            return this.options.comparator ? this.options.comparator(n, u) : n === u || this.options.ignoreCase && n.toLowerCase() === u.toLowerCase();
          }, removeEmpty: function(n) {
            for (var u = [], i = 0; i < n.length; i++)
              n[i] && u.push(n[i]);
            return u;
          }, castInput: function(n) {
            return n;
          }, tokenize: function(n) {
            return n.split("");
          }, join: function(n) {
            return n.join("");
          } };
          function t(a, n, u, i, l) {
            for (var p = 0, y2 = n.length, h = 0, g2 = 0; p < y2; p++) {
              var c = n[p];
              if (c.removed) {
                if (c.value = a.join(i.slice(g2, g2 + c.count)), g2 += c.count, p && n[p - 1].added) {
                  var F = n[p - 1];
                  n[p - 1] = n[p], n[p] = F;
                }
              } else {
                if (!c.added && l) {
                  var f = u.slice(h, h + c.count);
                  f = f.map(function(w, E) {
                    var N2 = i[g2 + E];
                    return N2.length > w.length ? N2 : w;
                  }), c.value = a.join(f);
                } else
                  c.value = a.join(u.slice(h, h + c.count));
                h += c.count, c.added || (g2 += c.count);
              }
            }
            var _ = n[y2 - 1];
            return y2 > 1 && typeof _.value == "string" && (_.added || _.removed) && a.equals("", _.value) && (n[y2 - 2].value += _.value, n.pop()), n;
          }
          function s(a) {
            return { newPos: a.newPos, components: a.components.slice(0) };
          }
        } }), BD2 = te2({ "node_modules/diff/lib/diff/array.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true }), e.diffArrays = a, e.arrayDiff = void 0;
          var r = t(TD2());
          function t(n) {
            return n && n.__esModule ? n : { default: n };
          }
          var s = new r.default();
          e.arrayDiff = s, s.tokenize = function(n) {
            return n.slice();
          }, s.join = s.removeEmpty = function(n) {
            return n;
          };
          function a(n, u, i) {
            return s.diff(n, u, i);
          }
        } }), Un2 = te2({ "src/document/doc-builders.js"(e, r) {
          ne2();
          function t(C) {
            return { type: "concat", parts: C };
          }
          function s(C) {
            return { type: "indent", contents: C };
          }
          function a(C, o) {
            return { type: "align", contents: o, n: C };
          }
          function n(C) {
            let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return { type: "group", id: o.id, contents: C, break: Boolean(o.shouldBreak), expandedStates: o.expandedStates };
          }
          function u(C) {
            return a(Number.NEGATIVE_INFINITY, C);
          }
          function i(C) {
            return a({ type: "root" }, C);
          }
          function l(C) {
            return a(-1, C);
          }
          function p(C, o) {
            return n(C[0], Object.assign(Object.assign({}, o), {}, { expandedStates: C }));
          }
          function y2(C) {
            return { type: "fill", parts: C };
          }
          function h(C, o) {
            let d2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return { type: "if-break", breakContents: C, flatContents: o, groupId: d2.groupId };
          }
          function g2(C, o) {
            return { type: "indent-if-break", contents: C, groupId: o.groupId, negate: o.negate };
          }
          function c(C) {
            return { type: "line-suffix", contents: C };
          }
          var f = { type: "line-suffix-boundary" }, F = { type: "break-parent" }, _ = { type: "trim" }, w = { type: "line", hard: true }, E = { type: "line", hard: true, literal: true }, N2 = { type: "line" }, x = { type: "line", soft: true }, I2 = t([w, F]), P = t([E, F]), $2 = { type: "cursor", placeholder: Symbol("cursor") };
          function D(C, o) {
            let d2 = [];
            for (let v2 = 0; v2 < o.length; v2++)
              v2 !== 0 && d2.push(C), d2.push(o[v2]);
            return t(d2);
          }
          function T(C, o, d2) {
            let v2 = C;
            if (o > 0) {
              for (let S = 0; S < Math.floor(o / d2); ++S)
                v2 = s(v2);
              v2 = a(o % d2, v2), v2 = a(Number.NEGATIVE_INFINITY, v2);
            }
            return v2;
          }
          function m(C, o) {
            return { type: "label", label: C, contents: o };
          }
          r.exports = { concat: t, join: D, line: N2, softline: x, hardline: I2, literalline: P, group: n, conditionalGroup: p, fill: y2, lineSuffix: c, lineSuffixBoundary: f, cursor: $2, breakParent: F, ifBreak: h, trim: _, indent: s, indentIfBreak: g2, align: a, addAlignmentToDoc: T, markAsRoot: i, dedentToRoot: u, dedent: l, hardlineWithoutBreakParent: w, literallineWithoutBreakParent: E, label: m };
        } }), Jn2 = te2({ "src/common/end-of-line.js"(e, r) {
          ne2();
          function t(u) {
            let i = u.indexOf("\r");
            return i >= 0 ? u.charAt(i + 1) === `
` ? "crlf" : "cr" : "lf";
          }
          function s(u) {
            switch (u) {
              case "cr":
                return "\r";
              case "crlf":
                return `\r
`;
              default:
                return `
`;
            }
          }
          function a(u, i) {
            let l;
            switch (i) {
              case `
`:
                l = /\n/g;
                break;
              case "\r":
                l = /\r/g;
                break;
              case `\r
`:
                l = /\r\n/g;
                break;
              default:
                throw new Error(`Unexpected "eol" ${JSON.stringify(i)}.`);
            }
            let p = u.match(l);
            return p ? p.length : 0;
          }
          function n(u) {
            return u.replace(/\r\n?/g, `
`);
          }
          r.exports = { guessEndOfLine: t, convertEndOfLineToChars: s, countEndOfLineChars: a, normalizeEndOfLine: n };
        } }), lt2 = te2({ "src/utils/get-last.js"(e, r) {
          ne2();
          var t = (s) => s[s.length - 1];
          r.exports = t;
        } });
        function ND2() {
          let { onlyFirst: e = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
          return new RegExp(r, e ? void 0 : "g");
        }
        var wD2 = ht2({ "node_modules/strip-ansi/node_modules/ansi-regex/index.js"() {
          ne2();
        } });
        function _D2(e) {
          if (typeof e != "string")
            throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);
          return e.replace(ND2(), "");
        }
        var PD2 = ht2({ "node_modules/strip-ansi/index.js"() {
          ne2(), wD2();
        } });
        function ID2(e) {
          return Number.isInteger(e) ? e >= 4352 && (e <= 4447 || e === 9001 || e === 9002 || 11904 <= e && e <= 12871 && e !== 12351 || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141) : false;
        }
        var kD2 = ht2({ "node_modules/is-fullwidth-code-point/index.js"() {
          ne2();
        } }), LD2 = te2({ "node_modules/emoji-regex/index.js"(e, r) {
          ne2(), r.exports = function() {
            return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
          };
        } }), ka2 = {};
        Kt2(ka2, { default: () => OD2 });
        function OD2(e) {
          if (typeof e != "string" || e.length === 0 || (e = _D2(e), e.length === 0))
            return 0;
          e = e.replace((0, La2.default)(), "  ");
          let r = 0;
          for (let t = 0; t < e.length; t++) {
            let s = e.codePointAt(t);
            s <= 31 || s >= 127 && s <= 159 || s >= 768 && s <= 879 || (s > 65535 && t++, r += ID2(s) ? 2 : 1);
          }
          return r;
        }
        var La2, jD2 = ht2({ "node_modules/string-width/index.js"() {
          ne2(), PD2(), kD2(), La2 = bD2(LD2());
        } }), Oa2 = te2({ "src/utils/get-string-width.js"(e, r) {
          ne2();
          var t = (jD2(), ft2(ka2)).default, s = /[^\x20-\x7F]/;
          function a(n) {
            return n ? s.test(n) ? t(n) : n.length : 0;
          }
          r.exports = a;
        } }), Yt2 = te2({ "src/document/doc-utils.js"(e, r) {
          ne2();
          var t = lt2(), { literalline: s, join: a } = Un2(), n = (o) => Array.isArray(o) || o && o.type === "concat", u = (o) => {
            if (Array.isArray(o))
              return o;
            if (o.type !== "concat" && o.type !== "fill")
              throw new Error("Expect doc type to be `concat` or `fill`.");
            return o.parts;
          }, i = {};
          function l(o, d2, v2, S) {
            let b = [o];
            for (; b.length > 0; ) {
              let B = b.pop();
              if (B === i) {
                v2(b.pop());
                continue;
              }
              if (v2 && b.push(B, i), !d2 || d2(B) !== false)
                if (n(B) || B.type === "fill") {
                  let k = u(B);
                  for (let M2 = k.length, R2 = M2 - 1; R2 >= 0; --R2)
                    b.push(k[R2]);
                } else if (B.type === "if-break")
                  B.flatContents && b.push(B.flatContents), B.breakContents && b.push(B.breakContents);
                else if (B.type === "group" && B.expandedStates)
                  if (S)
                    for (let k = B.expandedStates.length, M2 = k - 1; M2 >= 0; --M2)
                      b.push(B.expandedStates[M2]);
                  else
                    b.push(B.contents);
                else
                  B.contents && b.push(B.contents);
            }
          }
          function p(o, d2) {
            let v2 = /* @__PURE__ */ new Map();
            return S(o);
            function S(B) {
              if (v2.has(B))
                return v2.get(B);
              let k = b(B);
              return v2.set(B, k), k;
            }
            function b(B) {
              if (Array.isArray(B))
                return d2(B.map(S));
              if (B.type === "concat" || B.type === "fill") {
                let k = B.parts.map(S);
                return d2(Object.assign(Object.assign({}, B), {}, { parts: k }));
              }
              if (B.type === "if-break") {
                let k = B.breakContents && S(B.breakContents), M2 = B.flatContents && S(B.flatContents);
                return d2(Object.assign(Object.assign({}, B), {}, { breakContents: k, flatContents: M2 }));
              }
              if (B.type === "group" && B.expandedStates) {
                let k = B.expandedStates.map(S), M2 = k[0];
                return d2(Object.assign(Object.assign({}, B), {}, { contents: M2, expandedStates: k }));
              }
              if (B.contents) {
                let k = S(B.contents);
                return d2(Object.assign(Object.assign({}, B), {}, { contents: k }));
              }
              return d2(B);
            }
          }
          function y2(o, d2, v2) {
            let S = v2, b = false;
            function B(k) {
              let M2 = d2(k);
              if (M2 !== void 0 && (b = true, S = M2), b)
                return false;
            }
            return l(o, B), S;
          }
          function h(o) {
            if (o.type === "group" && o.break || o.type === "line" && o.hard || o.type === "break-parent")
              return true;
          }
          function g2(o) {
            return y2(o, h, false);
          }
          function c(o) {
            if (o.length > 0) {
              let d2 = t(o);
              !d2.expandedStates && !d2.break && (d2.break = "propagated");
            }
            return null;
          }
          function f(o) {
            let d2 = /* @__PURE__ */ new Set(), v2 = [];
            function S(B) {
              if (B.type === "break-parent" && c(v2), B.type === "group") {
                if (v2.push(B), d2.has(B))
                  return false;
                d2.add(B);
              }
            }
            function b(B) {
              B.type === "group" && v2.pop().break && c(v2);
            }
            l(o, S, b, true);
          }
          function F(o) {
            return o.type === "line" && !o.hard ? o.soft ? "" : " " : o.type === "if-break" ? o.flatContents || "" : o;
          }
          function _(o) {
            return p(o, F);
          }
          var w = (o, d2) => o && o.type === "line" && o.hard && d2 && d2.type === "break-parent";
          function E(o) {
            if (!o)
              return o;
            if (n(o) || o.type === "fill") {
              let d2 = u(o);
              for (; d2.length > 1 && w(...d2.slice(-2)); )
                d2.length -= 2;
              if (d2.length > 0) {
                let v2 = E(t(d2));
                d2[d2.length - 1] = v2;
              }
              return Array.isArray(o) ? d2 : Object.assign(Object.assign({}, o), {}, { parts: d2 });
            }
            switch (o.type) {
              case "align":
              case "indent":
              case "indent-if-break":
              case "group":
              case "line-suffix":
              case "label": {
                let d2 = E(o.contents);
                return Object.assign(Object.assign({}, o), {}, { contents: d2 });
              }
              case "if-break": {
                let d2 = E(o.breakContents), v2 = E(o.flatContents);
                return Object.assign(Object.assign({}, o), {}, { breakContents: d2, flatContents: v2 });
              }
            }
            return o;
          }
          function N2(o) {
            return E(I2(o));
          }
          function x(o) {
            switch (o.type) {
              case "fill":
                if (o.parts.every((v2) => v2 === ""))
                  return "";
                break;
              case "group":
                if (!o.contents && !o.id && !o.break && !o.expandedStates)
                  return "";
                if (o.contents.type === "group" && o.contents.id === o.id && o.contents.break === o.break && o.contents.expandedStates === o.expandedStates)
                  return o.contents;
                break;
              case "align":
              case "indent":
              case "indent-if-break":
              case "line-suffix":
                if (!o.contents)
                  return "";
                break;
              case "if-break":
                if (!o.flatContents && !o.breakContents)
                  return "";
                break;
            }
            if (!n(o))
              return o;
            let d2 = [];
            for (let v2 of u(o)) {
              if (!v2)
                continue;
              let [S, ...b] = n(v2) ? u(v2) : [v2];
              typeof S == "string" && typeof t(d2) == "string" ? d2[d2.length - 1] += S : d2.push(S), d2.push(...b);
            }
            return d2.length === 0 ? "" : d2.length === 1 ? d2[0] : Array.isArray(o) ? d2 : Object.assign(Object.assign({}, o), {}, { parts: d2 });
          }
          function I2(o) {
            return p(o, (d2) => x(d2));
          }
          function P(o) {
            let d2 = [], v2 = o.filter(Boolean);
            for (; v2.length > 0; ) {
              let S = v2.shift();
              if (S) {
                if (n(S)) {
                  v2.unshift(...u(S));
                  continue;
                }
                if (d2.length > 0 && typeof t(d2) == "string" && typeof S == "string") {
                  d2[d2.length - 1] += S;
                  continue;
                }
                d2.push(S);
              }
            }
            return d2;
          }
          function $2(o) {
            return p(o, (d2) => Array.isArray(d2) ? P(d2) : d2.parts ? Object.assign(Object.assign({}, d2), {}, { parts: P(d2.parts) }) : d2);
          }
          function D(o) {
            return p(o, (d2) => typeof d2 == "string" && d2.includes(`
`) ? T(d2) : d2);
          }
          function T(o) {
            let d2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s;
            return a(d2, o.split(`
`)).parts;
          }
          function m(o) {
            if (o.type === "line")
              return true;
          }
          function C(o) {
            return y2(o, m, false);
          }
          r.exports = { isConcat: n, getDocParts: u, willBreak: g2, traverseDoc: l, findInDoc: y2, mapDoc: p, propagateBreaks: f, removeLines: _, stripTrailingHardline: N2, normalizeParts: P, normalizeDoc: $2, cleanDoc: I2, replaceTextEndOfLine: T, replaceEndOfLine: D, canBreak: C };
        } }), qD2 = te2({ "src/document/doc-printer.js"(e, r) {
          ne2();
          var { convertEndOfLineToChars: t } = Jn2(), s = lt2(), a = Oa2(), { fill: n, cursor: u, indent: i } = Un2(), { isConcat: l, getDocParts: p } = Yt2(), y2, h = 1, g2 = 2;
          function c() {
            return { value: "", length: 0, queue: [] };
          }
          function f(x, I2) {
            return _(x, { type: "indent" }, I2);
          }
          function F(x, I2, P) {
            return I2 === Number.NEGATIVE_INFINITY ? x.root || c() : I2 < 0 ? _(x, { type: "dedent" }, P) : I2 ? I2.type === "root" ? Object.assign(Object.assign({}, x), {}, { root: x }) : _(x, { type: typeof I2 == "string" ? "stringAlign" : "numberAlign", n: I2 }, P) : x;
          }
          function _(x, I2, P) {
            let $2 = I2.type === "dedent" ? x.queue.slice(0, -1) : [...x.queue, I2], D = "", T = 0, m = 0, C = 0;
            for (let k of $2)
              switch (k.type) {
                case "indent":
                  v2(), P.useTabs ? o(1) : d2(P.tabWidth);
                  break;
                case "stringAlign":
                  v2(), D += k.n, T += k.n.length;
                  break;
                case "numberAlign":
                  m += 1, C += k.n;
                  break;
                default:
                  throw new Error(`Unexpected type '${k.type}'`);
              }
            return b(), Object.assign(Object.assign({}, x), {}, { value: D, length: T, queue: $2 });
            function o(k) {
              D += "	".repeat(k), T += P.tabWidth * k;
            }
            function d2(k) {
              D += " ".repeat(k), T += k;
            }
            function v2() {
              P.useTabs ? S() : b();
            }
            function S() {
              m > 0 && o(m), B();
            }
            function b() {
              C > 0 && d2(C), B();
            }
            function B() {
              m = 0, C = 0;
            }
          }
          function w(x) {
            if (x.length === 0)
              return 0;
            let I2 = 0;
            for (; x.length > 0 && typeof s(x) == "string" && /^[\t ]*$/.test(s(x)); )
              I2 += x.pop().length;
            if (x.length > 0 && typeof s(x) == "string") {
              let P = s(x).replace(/[\t ]*$/, "");
              I2 += s(x).length - P.length, x[x.length - 1] = P;
            }
            return I2;
          }
          function E(x, I2, P, $2, D) {
            let T = I2.length, m = [x], C = [];
            for (; P >= 0; ) {
              if (m.length === 0) {
                if (T === 0)
                  return true;
                m.push(I2[--T]);
                continue;
              }
              let { mode: o, doc: d2 } = m.pop();
              if (typeof d2 == "string")
                C.push(d2), P -= a(d2);
              else if (l(d2) || d2.type === "fill") {
                let v2 = p(d2);
                for (let S = v2.length - 1; S >= 0; S--)
                  m.push({ mode: o, doc: v2[S] });
              } else
                switch (d2.type) {
                  case "indent":
                  case "align":
                  case "indent-if-break":
                  case "label":
                    m.push({ mode: o, doc: d2.contents });
                    break;
                  case "trim":
                    P += w(C);
                    break;
                  case "group": {
                    if (D && d2.break)
                      return false;
                    let v2 = d2.break ? h : o, S = d2.expandedStates && v2 === h ? s(d2.expandedStates) : d2.contents;
                    m.push({ mode: v2, doc: S });
                    break;
                  }
                  case "if-break": {
                    let S = (d2.groupId ? y2[d2.groupId] || g2 : o) === h ? d2.breakContents : d2.flatContents;
                    S && m.push({ mode: o, doc: S });
                    break;
                  }
                  case "line":
                    if (o === h || d2.hard)
                      return true;
                    d2.soft || (C.push(" "), P--);
                    break;
                  case "line-suffix":
                    $2 = true;
                    break;
                  case "line-suffix-boundary":
                    if ($2)
                      return false;
                    break;
                }
            }
            return false;
          }
          function N2(x, I2) {
            y2 = {};
            let P = I2.printWidth, $2 = t(I2.endOfLine), D = 0, T = [{ ind: c(), mode: h, doc: x }], m = [], C = false, o = [];
            for (; T.length > 0; ) {
              let { ind: v2, mode: S, doc: b } = T.pop();
              if (typeof b == "string") {
                let B = $2 !== `
` ? b.replace(/\n/g, $2) : b;
                m.push(B), D += a(B);
              } else if (l(b)) {
                let B = p(b);
                for (let k = B.length - 1; k >= 0; k--)
                  T.push({ ind: v2, mode: S, doc: B[k] });
              } else
                switch (b.type) {
                  case "cursor":
                    m.push(u.placeholder);
                    break;
                  case "indent":
                    T.push({ ind: f(v2, I2), mode: S, doc: b.contents });
                    break;
                  case "align":
                    T.push({ ind: F(v2, b.n, I2), mode: S, doc: b.contents });
                    break;
                  case "trim":
                    D -= w(m);
                    break;
                  case "group":
                    switch (S) {
                      case g2:
                        if (!C) {
                          T.push({ ind: v2, mode: b.break ? h : g2, doc: b.contents });
                          break;
                        }
                      case h: {
                        C = false;
                        let B = { ind: v2, mode: g2, doc: b.contents }, k = P - D, M2 = o.length > 0;
                        if (!b.break && E(B, T, k, M2))
                          T.push(B);
                        else if (b.expandedStates) {
                          let R2 = s(b.expandedStates);
                          if (b.break) {
                            T.push({ ind: v2, mode: h, doc: R2 });
                            break;
                          } else
                            for (let q = 1; q < b.expandedStates.length + 1; q++)
                              if (q >= b.expandedStates.length) {
                                T.push({ ind: v2, mode: h, doc: R2 });
                                break;
                              } else {
                                let J = b.expandedStates[q], L = { ind: v2, mode: g2, doc: J };
                                if (E(L, T, k, M2)) {
                                  T.push(L);
                                  break;
                                }
                              }
                        } else
                          T.push({ ind: v2, mode: h, doc: b.contents });
                        break;
                      }
                    }
                    b.id && (y2[b.id] = s(T).mode);
                    break;
                  case "fill": {
                    let B = P - D, { parts: k } = b;
                    if (k.length === 0)
                      break;
                    let [M2, R2] = k, q = { ind: v2, mode: g2, doc: M2 }, J = { ind: v2, mode: h, doc: M2 }, L = E(q, [], B, o.length > 0, true);
                    if (k.length === 1) {
                      L ? T.push(q) : T.push(J);
                      break;
                    }
                    let Q = { ind: v2, mode: g2, doc: R2 }, V = { ind: v2, mode: h, doc: R2 };
                    if (k.length === 2) {
                      L ? T.push(Q, q) : T.push(V, J);
                      break;
                    }
                    k.splice(0, 2);
                    let j = { ind: v2, mode: S, doc: n(k) }, Y = k[0];
                    E({ ind: v2, mode: g2, doc: [M2, R2, Y] }, [], B, o.length > 0, true) ? T.push(j, Q, q) : L ? T.push(j, V, q) : T.push(j, V, J);
                    break;
                  }
                  case "if-break":
                  case "indent-if-break": {
                    let B = b.groupId ? y2[b.groupId] : S;
                    if (B === h) {
                      let k = b.type === "if-break" ? b.breakContents : b.negate ? b.contents : i(b.contents);
                      k && T.push({ ind: v2, mode: S, doc: k });
                    }
                    if (B === g2) {
                      let k = b.type === "if-break" ? b.flatContents : b.negate ? i(b.contents) : b.contents;
                      k && T.push({ ind: v2, mode: S, doc: k });
                    }
                    break;
                  }
                  case "line-suffix":
                    o.push({ ind: v2, mode: S, doc: b.contents });
                    break;
                  case "line-suffix-boundary":
                    o.length > 0 && T.push({ ind: v2, mode: S, doc: { type: "line", hard: true } });
                    break;
                  case "line":
                    switch (S) {
                      case g2:
                        if (b.hard)
                          C = true;
                        else {
                          b.soft || (m.push(" "), D += 1);
                          break;
                        }
                      case h:
                        if (o.length > 0) {
                          T.push({ ind: v2, mode: S, doc: b }, ...o.reverse()), o.length = 0;
                          break;
                        }
                        b.literal ? v2.root ? (m.push($2, v2.root.value), D = v2.root.length) : (m.push($2), D = 0) : (D -= w(m), m.push($2 + v2.value), D = v2.length);
                        break;
                    }
                    break;
                  case "label":
                    T.push({ ind: v2, mode: S, doc: b.contents });
                    break;
                }
              T.length === 0 && o.length > 0 && (T.push(...o.reverse()), o.length = 0);
            }
            let d2 = m.indexOf(u.placeholder);
            if (d2 !== -1) {
              let v2 = m.indexOf(u.placeholder, d2 + 1), S = m.slice(0, d2).join(""), b = m.slice(d2 + 1, v2).join(""), B = m.slice(v2 + 1).join("");
              return { formatted: S + b + B, cursorNodeStart: S.length, cursorNodeText: b };
            }
            return { formatted: m.join("") };
          }
          r.exports = { printDocToString: N2 };
        } }), MD2 = te2({ "src/document/doc-debug.js"(e, r) {
          ne2();
          var { isConcat: t, getDocParts: s } = Yt2();
          function a(u) {
            if (!u)
              return "";
            if (t(u)) {
              let i = [];
              for (let l of s(u))
                if (t(l))
                  i.push(...a(l).parts);
                else {
                  let p = a(l);
                  p !== "" && i.push(p);
                }
              return { type: "concat", parts: i };
            }
            return u.type === "if-break" ? Object.assign(Object.assign({}, u), {}, { breakContents: a(u.breakContents), flatContents: a(u.flatContents) }) : u.type === "group" ? Object.assign(Object.assign({}, u), {}, { contents: a(u.contents), expandedStates: u.expandedStates && u.expandedStates.map(a) }) : u.type === "fill" ? { type: "fill", parts: u.parts.map(a) } : u.contents ? Object.assign(Object.assign({}, u), {}, { contents: a(u.contents) }) : u;
          }
          function n(u) {
            let i = /* @__PURE__ */ Object.create(null), l = /* @__PURE__ */ new Set();
            return p(a(u));
            function p(h, g2, c) {
              if (typeof h == "string")
                return JSON.stringify(h);
              if (t(h)) {
                let f = s(h).map(p).filter(Boolean);
                return f.length === 1 ? f[0] : `[${f.join(", ")}]`;
              }
              if (h.type === "line") {
                let f = Array.isArray(c) && c[g2 + 1] && c[g2 + 1].type === "break-parent";
                return h.literal ? f ? "literalline" : "literallineWithoutBreakParent" : h.hard ? f ? "hardline" : "hardlineWithoutBreakParent" : h.soft ? "softline" : "line";
              }
              if (h.type === "break-parent")
                return Array.isArray(c) && c[g2 - 1] && c[g2 - 1].type === "line" && c[g2 - 1].hard ? void 0 : "breakParent";
              if (h.type === "trim")
                return "trim";
              if (h.type === "indent")
                return "indent(" + p(h.contents) + ")";
              if (h.type === "align")
                return h.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + p(h.contents) + ")" : h.n < 0 ? "dedent(" + p(h.contents) + ")" : h.n.type === "root" ? "markAsRoot(" + p(h.contents) + ")" : "align(" + JSON.stringify(h.n) + ", " + p(h.contents) + ")";
              if (h.type === "if-break")
                return "ifBreak(" + p(h.breakContents) + (h.flatContents ? ", " + p(h.flatContents) : "") + (h.groupId ? (h.flatContents ? "" : ', ""') + `, { groupId: ${y2(h.groupId)} }` : "") + ")";
              if (h.type === "indent-if-break") {
                let f = [];
                h.negate && f.push("negate: true"), h.groupId && f.push(`groupId: ${y2(h.groupId)}`);
                let F = f.length > 0 ? `, { ${f.join(", ")} }` : "";
                return `indentIfBreak(${p(h.contents)}${F})`;
              }
              if (h.type === "group") {
                let f = [];
                h.break && h.break !== "propagated" && f.push("shouldBreak: true"), h.id && f.push(`id: ${y2(h.id)}`);
                let F = f.length > 0 ? `, { ${f.join(", ")} }` : "";
                return h.expandedStates ? `conditionalGroup([${h.expandedStates.map((_) => p(_)).join(",")}]${F})` : `group(${p(h.contents)}${F})`;
              }
              if (h.type === "fill")
                return `fill([${h.parts.map((f) => p(f)).join(", ")}])`;
              if (h.type === "line-suffix")
                return "lineSuffix(" + p(h.contents) + ")";
              if (h.type === "line-suffix-boundary")
                return "lineSuffixBoundary";
              if (h.type === "label")
                return `label(${JSON.stringify(h.label)}, ${p(h.contents)})`;
              throw new Error("Unknown doc type " + h.type);
            }
            function y2(h) {
              if (typeof h != "symbol")
                return JSON.stringify(String(h));
              if (h in i)
                return i[h];
              let g2 = String(h).slice(7, -1) || "symbol";
              for (let c = 0; ; c++) {
                let f = g2 + (c > 0 ? ` #${c}` : "");
                if (!l.has(f))
                  return l.add(f), i[h] = `Symbol.for(${JSON.stringify(f)})`;
              }
            }
          }
          r.exports = { printDocToDebug: n };
        } }), qe2 = te2({ "src/document/index.js"(e, r) {
          ne2(), r.exports = { builders: Un2(), printer: qD2(), utils: Yt2(), debug: MD2() };
        } }), ja2 = {};
        Kt2(ja2, { default: () => RD2 });
        function RD2(e) {
          if (typeof e != "string")
            throw new TypeError("Expected a string");
          return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
        }
        var $D2 = ht2({ "node_modules/escape-string-regexp/index.js"() {
          ne2();
        } }), qa2 = te2({ "node_modules/semver/internal/debug.js"(e, r) {
          ne2();
          var t = typeof wt2 == "object" && wt2.env && wt2.env.NODE_DEBUG && /\bsemver\b/i.test(wt2.env.NODE_DEBUG) ? function() {
            for (var s = arguments.length, a = new Array(s), n = 0; n < s; n++)
              a[n] = arguments[n];
            return console.error("SEMVER", ...a);
          } : () => {
          };
          r.exports = t;
        } }), Ma2 = te2({ "node_modules/semver/internal/constants.js"(e, r) {
          ne2();
          var t = "2.0.0", s = 256, a = Number.MAX_SAFE_INTEGER || 9007199254740991, n = 16;
          r.exports = { SEMVER_SPEC_VERSION: t, MAX_LENGTH: s, MAX_SAFE_INTEGER: a, MAX_SAFE_COMPONENT_LENGTH: n };
        } }), VD2 = te2({ "node_modules/semver/internal/re.js"(e, r) {
          ne2();
          var { MAX_SAFE_COMPONENT_LENGTH: t } = Ma2(), s = qa2();
          e = r.exports = {};
          var a = e.re = [], n = e.src = [], u = e.t = {}, i = 0, l = (p, y2, h) => {
            let g2 = i++;
            s(p, g2, y2), u[p] = g2, n[g2] = y2, a[g2] = new RegExp(y2, h ? "g" : void 0);
          };
          l("NUMERICIDENTIFIER", "0|[1-9]\\d*"), l("NUMERICIDENTIFIERLOOSE", "[0-9]+"), l("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), l("MAINVERSION", `(${n[u.NUMERICIDENTIFIER]})\\.(${n[u.NUMERICIDENTIFIER]})\\.(${n[u.NUMERICIDENTIFIER]})`), l("MAINVERSIONLOOSE", `(${n[u.NUMERICIDENTIFIERLOOSE]})\\.(${n[u.NUMERICIDENTIFIERLOOSE]})\\.(${n[u.NUMERICIDENTIFIERLOOSE]})`), l("PRERELEASEIDENTIFIER", `(?:${n[u.NUMERICIDENTIFIER]}|${n[u.NONNUMERICIDENTIFIER]})`), l("PRERELEASEIDENTIFIERLOOSE", `(?:${n[u.NUMERICIDENTIFIERLOOSE]}|${n[u.NONNUMERICIDENTIFIER]})`), l("PRERELEASE", `(?:-(${n[u.PRERELEASEIDENTIFIER]}(?:\\.${n[u.PRERELEASEIDENTIFIER]})*))`), l("PRERELEASELOOSE", `(?:-?(${n[u.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${n[u.PRERELEASEIDENTIFIERLOOSE]})*))`), l("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), l("BUILD", `(?:\\+(${n[u.BUILDIDENTIFIER]}(?:\\.${n[u.BUILDIDENTIFIER]})*))`), l("FULLPLAIN", `v?${n[u.MAINVERSION]}${n[u.PRERELEASE]}?${n[u.BUILD]}?`), l("FULL", `^${n[u.FULLPLAIN]}$`), l("LOOSEPLAIN", `[v=\\s]*${n[u.MAINVERSIONLOOSE]}${n[u.PRERELEASELOOSE]}?${n[u.BUILD]}?`), l("LOOSE", `^${n[u.LOOSEPLAIN]}$`), l("GTLT", "((?:<|>)?=?)"), l("XRANGEIDENTIFIERLOOSE", `${n[u.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), l("XRANGEIDENTIFIER", `${n[u.NUMERICIDENTIFIER]}|x|X|\\*`), l("XRANGEPLAIN", `[v=\\s]*(${n[u.XRANGEIDENTIFIER]})(?:\\.(${n[u.XRANGEIDENTIFIER]})(?:\\.(${n[u.XRANGEIDENTIFIER]})(?:${n[u.PRERELEASE]})?${n[u.BUILD]}?)?)?`), l("XRANGEPLAINLOOSE", `[v=\\s]*(${n[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[u.XRANGEIDENTIFIERLOOSE]})(?:${n[u.PRERELEASELOOSE]})?${n[u.BUILD]}?)?)?`), l("XRANGE", `^${n[u.GTLT]}\\s*${n[u.XRANGEPLAIN]}$`), l("XRANGELOOSE", `^${n[u.GTLT]}\\s*${n[u.XRANGEPLAINLOOSE]}$`), l("COERCE", `(^|[^\\d])(\\d{1,${t}})(?:\\.(\\d{1,${t}}))?(?:\\.(\\d{1,${t}}))?(?:$|[^\\d])`), l("COERCERTL", n[u.COERCE], true), l("LONETILDE", "(?:~>?)"), l("TILDETRIM", `(\\s*)${n[u.LONETILDE]}\\s+`, true), e.tildeTrimReplace = "$1~", l("TILDE", `^${n[u.LONETILDE]}${n[u.XRANGEPLAIN]}$`), l("TILDELOOSE", `^${n[u.LONETILDE]}${n[u.XRANGEPLAINLOOSE]}$`), l("LONECARET", "(?:\\^)"), l("CARETTRIM", `(\\s*)${n[u.LONECARET]}\\s+`, true), e.caretTrimReplace = "$1^", l("CARET", `^${n[u.LONECARET]}${n[u.XRANGEPLAIN]}$`), l("CARETLOOSE", `^${n[u.LONECARET]}${n[u.XRANGEPLAINLOOSE]}$`), l("COMPARATORLOOSE", `^${n[u.GTLT]}\\s*(${n[u.LOOSEPLAIN]})$|^$`), l("COMPARATOR", `^${n[u.GTLT]}\\s*(${n[u.FULLPLAIN]})$|^$`), l("COMPARATORTRIM", `(\\s*)${n[u.GTLT]}\\s*(${n[u.LOOSEPLAIN]}|${n[u.XRANGEPLAIN]})`, true), e.comparatorTrimReplace = "$1$2$3", l("HYPHENRANGE", `^\\s*(${n[u.XRANGEPLAIN]})\\s+-\\s+(${n[u.XRANGEPLAIN]})\\s*$`), l("HYPHENRANGELOOSE", `^\\s*(${n[u.XRANGEPLAINLOOSE]})\\s+-\\s+(${n[u.XRANGEPLAINLOOSE]})\\s*$`), l("STAR", "(<|>)?=?\\s*\\*"), l("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), l("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
        } }), WD2 = te2({ "node_modules/semver/internal/parse-options.js"(e, r) {
          ne2();
          var t = ["includePrerelease", "loose", "rtl"], s = (a) => a ? typeof a != "object" ? { loose: true } : t.filter((n) => a[n]).reduce((n, u) => (n[u] = true, n), {}) : {};
          r.exports = s;
        } }), HD2 = te2({ "node_modules/semver/internal/identifiers.js"(e, r) {
          ne2();
          var t = /^[0-9]+$/, s = (n, u) => {
            let i = t.test(n), l = t.test(u);
            return i && l && (n = +n, u = +u), n === u ? 0 : i && !l ? -1 : l && !i ? 1 : n < u ? -1 : 1;
          }, a = (n, u) => s(u, n);
          r.exports = { compareIdentifiers: s, rcompareIdentifiers: a };
        } }), GD2 = te2({ "node_modules/semver/classes/semver.js"(e, r) {
          ne2();
          var t = qa2(), { MAX_LENGTH: s, MAX_SAFE_INTEGER: a } = Ma2(), { re: n, t: u } = VD2(), i = WD2(), { compareIdentifiers: l } = HD2(), p = class {
            constructor(y2, h) {
              if (h = i(h), y2 instanceof p) {
                if (y2.loose === !!h.loose && y2.includePrerelease === !!h.includePrerelease)
                  return y2;
                y2 = y2.version;
              } else if (typeof y2 != "string")
                throw new TypeError(`Invalid Version: ${y2}`);
              if (y2.length > s)
                throw new TypeError(`version is longer than ${s} characters`);
              t("SemVer", y2, h), this.options = h, this.loose = !!h.loose, this.includePrerelease = !!h.includePrerelease;
              let g2 = y2.trim().match(h.loose ? n[u.LOOSE] : n[u.FULL]);
              if (!g2)
                throw new TypeError(`Invalid Version: ${y2}`);
              if (this.raw = y2, this.major = +g2[1], this.minor = +g2[2], this.patch = +g2[3], this.major > a || this.major < 0)
                throw new TypeError("Invalid major version");
              if (this.minor > a || this.minor < 0)
                throw new TypeError("Invalid minor version");
              if (this.patch > a || this.patch < 0)
                throw new TypeError("Invalid patch version");
              g2[4] ? this.prerelease = g2[4].split(".").map((c) => {
                if (/^[0-9]+$/.test(c)) {
                  let f = +c;
                  if (f >= 0 && f < a)
                    return f;
                }
                return c;
              }) : this.prerelease = [], this.build = g2[5] ? g2[5].split(".") : [], this.format();
            }
            format() {
              return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
            }
            toString() {
              return this.version;
            }
            compare(y2) {
              if (t("SemVer.compare", this.version, this.options, y2), !(y2 instanceof p)) {
                if (typeof y2 == "string" && y2 === this.version)
                  return 0;
                y2 = new p(y2, this.options);
              }
              return y2.version === this.version ? 0 : this.compareMain(y2) || this.comparePre(y2);
            }
            compareMain(y2) {
              return y2 instanceof p || (y2 = new p(y2, this.options)), l(this.major, y2.major) || l(this.minor, y2.minor) || l(this.patch, y2.patch);
            }
            comparePre(y2) {
              if (y2 instanceof p || (y2 = new p(y2, this.options)), this.prerelease.length && !y2.prerelease.length)
                return -1;
              if (!this.prerelease.length && y2.prerelease.length)
                return 1;
              if (!this.prerelease.length && !y2.prerelease.length)
                return 0;
              let h = 0;
              do {
                let g2 = this.prerelease[h], c = y2.prerelease[h];
                if (t("prerelease compare", h, g2, c), g2 === void 0 && c === void 0)
                  return 0;
                if (c === void 0)
                  return 1;
                if (g2 === void 0)
                  return -1;
                if (g2 === c)
                  continue;
                return l(g2, c);
              } while (++h);
            }
            compareBuild(y2) {
              y2 instanceof p || (y2 = new p(y2, this.options));
              let h = 0;
              do {
                let g2 = this.build[h], c = y2.build[h];
                if (t("prerelease compare", h, g2, c), g2 === void 0 && c === void 0)
                  return 0;
                if (c === void 0)
                  return 1;
                if (g2 === void 0)
                  return -1;
                if (g2 === c)
                  continue;
                return l(g2, c);
              } while (++h);
            }
            inc(y2, h) {
              switch (y2) {
                case "premajor":
                  this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", h);
                  break;
                case "preminor":
                  this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", h);
                  break;
                case "prepatch":
                  this.prerelease.length = 0, this.inc("patch", h), this.inc("pre", h);
                  break;
                case "prerelease":
                  this.prerelease.length === 0 && this.inc("patch", h), this.inc("pre", h);
                  break;
                case "major":
                  (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                  break;
                case "minor":
                  (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                  break;
                case "patch":
                  this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                  break;
                case "pre":
                  if (this.prerelease.length === 0)
                    this.prerelease = [0];
                  else {
                    let g2 = this.prerelease.length;
                    for (; --g2 >= 0; )
                      typeof this.prerelease[g2] == "number" && (this.prerelease[g2]++, g2 = -2);
                    g2 === -1 && this.prerelease.push(0);
                  }
                  h && (l(this.prerelease[0], h) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [h, 0]) : this.prerelease = [h, 0]);
                  break;
                default:
                  throw new Error(`invalid increment argument: ${y2}`);
              }
              return this.format(), this.raw = this.version, this;
            }
          };
          r.exports = p;
        } }), zn2 = te2({ "node_modules/semver/functions/compare.js"(e, r) {
          ne2();
          var t = GD2(), s = (a, n, u) => new t(a, u).compare(new t(n, u));
          r.exports = s;
        } }), UD2 = te2({ "node_modules/semver/functions/lt.js"(e, r) {
          ne2();
          var t = zn2(), s = (a, n, u) => t(a, n, u) < 0;
          r.exports = s;
        } }), JD2 = te2({ "node_modules/semver/functions/gte.js"(e, r) {
          ne2();
          var t = zn2(), s = (a, n, u) => t(a, n, u) >= 0;
          r.exports = s;
        } }), zD2 = te2({ "src/utils/arrayify.js"(e, r) {
          ne2(), r.exports = (t, s) => Object.entries(t).map((a) => {
            let [n, u] = a;
            return Object.assign({ [s]: n }, u);
          });
        } }), XD2 = te2({ "node_modules/outdent/lib/index.js"(e, r) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true }), e.outdent = void 0;
          function t() {
            for (var E = [], N2 = 0; N2 < arguments.length; N2++)
              E[N2] = arguments[N2];
          }
          function s() {
            return typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : a();
          }
          function a() {
            return { add: t, delete: t, get: t, set: t, has: function(E) {
              return false;
            } };
          }
          var n = Object.prototype.hasOwnProperty, u = function(E, N2) {
            return n.call(E, N2);
          };
          function i(E, N2) {
            for (var x in N2)
              u(N2, x) && (E[x] = N2[x]);
            return E;
          }
          var l = /^[ \t]*(?:\r\n|\r|\n)/, p = /(?:\r\n|\r|\n)[ \t]*$/, y2 = /^(?:[\r\n]|$)/, h = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, g2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
          function c(E, N2, x) {
            var I2 = 0, P = E[0].match(h);
            P && (I2 = P[1].length);
            var $2 = "(\\r\\n|\\r|\\n).{0," + I2 + "}", D = new RegExp($2, "g");
            N2 && (E = E.slice(1));
            var T = x.newline, m = x.trimLeadingNewline, C = x.trimTrailingNewline, o = typeof T == "string", d2 = E.length, v2 = E.map(function(S, b) {
              return S = S.replace(D, "$1"), b === 0 && m && (S = S.replace(l, "")), b === d2 - 1 && C && (S = S.replace(p, "")), o && (S = S.replace(/\r\n|\n|\r/g, function(B) {
                return T;
              })), S;
            });
            return v2;
          }
          function f(E, N2) {
            for (var x = "", I2 = 0, P = E.length; I2 < P; I2++)
              x += E[I2], I2 < P - 1 && (x += N2[I2]);
            return x;
          }
          function F(E) {
            return u(E, "raw") && u(E, "length");
          }
          function _(E) {
            var N2 = s(), x = s();
            function I2($2) {
              for (var D = [], T = 1; T < arguments.length; T++)
                D[T - 1] = arguments[T];
              if (F($2)) {
                var m = $2, C = (D[0] === I2 || D[0] === w) && g2.test(m[0]) && y2.test(m[1]), o = C ? x : N2, d2 = o.get(m);
                if (d2 || (d2 = c(m, C, E), o.set(m, d2)), D.length === 0)
                  return d2[0];
                var v2 = f(d2, C ? D.slice(1) : D);
                return v2;
              } else
                return _(i(i({}, E), $2 || {}));
            }
            var P = i(I2, { string: function($2) {
              return c([$2], false, E)[0];
            } });
            return P;
          }
          var w = _({ trimLeadingNewline: true, trimTrailingNewline: true });
          if (e.outdent = w, e.default = w, typeof r < "u")
            try {
              r.exports = w, Object.defineProperty(w, "__esModule", { value: true }), w.default = w, w.outdent = w;
            } catch {
            }
        } }), KD2 = te2({ "src/main/core-options.js"(e, r) {
          ne2();
          var { outdent: t } = XD2(), s = "Config", a = "Editor", n = "Format", u = "Other", i = "Output", l = "Global", p = "Special", y2 = { cursorOffset: { since: "1.4.0", category: p, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: a }, endOfLine: { since: "1.15.0", category: l, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: t`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        ` }] }, filepath: { since: "1.4.0", category: p, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: u, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: p, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: u }, parser: { since: "0.0.10", category: l, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (h) => typeof h == "string" || typeof h == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "acorn", since: "2.6.0", description: "JavaScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: l, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (h) => typeof h == "string" || typeof h == "object", cliName: "plugin", cliCategory: s }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: l, description: t`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (h) => typeof h == "string" || typeof h == "object", cliName: "plugin-search-dir", cliCategory: s }, printWidth: { since: "0.0.0", category: l, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: p, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a }, rangeStart: { since: "1.4.0", category: p, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a }, requirePragma: { since: "1.7.0", category: p, type: "boolean", default: false, description: t`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: u }, tabWidth: { type: "int", category: l, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: l, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: l, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
          r.exports = { CATEGORY_CONFIG: s, CATEGORY_EDITOR: a, CATEGORY_FORMAT: n, CATEGORY_OTHER: u, CATEGORY_OUTPUT: i, CATEGORY_GLOBAL: l, CATEGORY_SPECIAL: p, options: y2 };
        } }), Xn2 = te2({ "src/main/support.js"(e, r) {
          ne2();
          var t = { compare: zn2(), lt: UD2(), gte: JD2() }, s = zD2(), a = Ia2().version, n = KD2().options;
          function u() {
            let { plugins: l = [], showUnreleased: p = false, showDeprecated: y2 = false, showInternal: h = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, g2 = a.split("-", 1)[0], c = l.flatMap((E) => E.languages || []).filter(F), f = s(Object.assign({}, ...l.map((E) => {
              let { options: N2 } = E;
              return N2;
            }), n), "name").filter((E) => F(E) && _(E)).sort((E, N2) => E.name === N2.name ? 0 : E.name < N2.name ? -1 : 1).map(w).map((E) => {
              E = Object.assign({}, E), Array.isArray(E.default) && (E.default = E.default.length === 1 ? E.default[0].value : E.default.filter(F).sort((x, I2) => t.compare(I2.since, x.since))[0].value), Array.isArray(E.choices) && (E.choices = E.choices.filter((x) => F(x) && _(x)), E.name === "parser" && i(E, c, l));
              let N2 = Object.fromEntries(l.filter((x) => x.defaultOptions && x.defaultOptions[E.name] !== void 0).map((x) => [x.name, x.defaultOptions[E.name]]));
              return Object.assign(Object.assign({}, E), {}, { pluginDefaults: N2 });
            });
            return { languages: c, options: f };
            function F(E) {
              return p || !("since" in E) || E.since && t.gte(g2, E.since);
            }
            function _(E) {
              return y2 || !("deprecated" in E) || E.deprecated && t.lt(g2, E.deprecated);
            }
            function w(E) {
              if (h)
                return E;
              return Hn2(E, hD2);
            }
          }
          function i(l, p, y2) {
            let h = new Set(l.choices.map((g2) => g2.value));
            for (let g2 of p)
              if (g2.parsers) {
                for (let c of g2.parsers)
                  if (!h.has(c)) {
                    h.add(c);
                    let f = y2.find((_) => _.parsers && _.parsers[c]), F = g2.name;
                    f && f.name && (F += ` (plugin: ${f.name})`), l.choices.push({ value: c, description: F });
                  }
              }
          }
          r.exports = { getSupportInfo: u };
        } }), Kn2 = te2({ "src/utils/is-non-empty-array.js"(e, r) {
          ne2();
          function t(s) {
            return Array.isArray(s) && s.length > 0;
          }
          r.exports = t;
        } }), Pr2 = te2({ "src/utils/text/skip.js"(e, r) {
          ne2();
          function t(i) {
            return (l, p, y2) => {
              let h = y2 && y2.backwards;
              if (p === false)
                return false;
              let { length: g2 } = l, c = p;
              for (; c >= 0 && c < g2; ) {
                let f = l.charAt(c);
                if (i instanceof RegExp) {
                  if (!i.test(f))
                    return c;
                } else if (!i.includes(f))
                  return c;
                h ? c-- : c++;
              }
              return c === -1 || c === g2 ? c : false;
            };
          }
          var s = t(/\s/), a = t(" 	"), n = t(",; 	"), u = t(/[^\n\r]/);
          r.exports = { skipWhitespace: s, skipSpaces: a, skipToLineEnd: n, skipEverythingButNewLine: u };
        } }), Ra2 = te2({ "src/utils/text/skip-inline-comment.js"(e, r) {
          ne2();
          function t(s, a) {
            if (a === false)
              return false;
            if (s.charAt(a) === "/" && s.charAt(a + 1) === "*") {
              for (let n = a + 2; n < s.length; ++n)
                if (s.charAt(n) === "*" && s.charAt(n + 1) === "/")
                  return n + 2;
            }
            return a;
          }
          r.exports = t;
        } }), $a2 = te2({ "src/utils/text/skip-trailing-comment.js"(e, r) {
          ne2();
          var { skipEverythingButNewLine: t } = Pr2();
          function s(a, n) {
            return n === false ? false : a.charAt(n) === "/" && a.charAt(n + 1) === "/" ? t(a, n) : n;
          }
          r.exports = s;
        } }), Va2 = te2({ "src/utils/text/skip-newline.js"(e, r) {
          ne2();
          function t(s, a, n) {
            let u = n && n.backwards;
            if (a === false)
              return false;
            let i = s.charAt(a);
            if (u) {
              if (s.charAt(a - 1) === "\r" && i === `
`)
                return a - 2;
              if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
                return a - 1;
            } else {
              if (i === "\r" && s.charAt(a + 1) === `
`)
                return a + 2;
              if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
                return a + 1;
            }
            return a;
          }
          r.exports = t;
        } }), YD2 = te2({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e, r) {
          ne2();
          var t = Ra2(), s = Va2(), a = $a2(), { skipSpaces: n } = Pr2();
          function u(i, l) {
            let p = null, y2 = l;
            for (; y2 !== p; )
              p = y2, y2 = n(i, y2), y2 = t(i, y2), y2 = a(i, y2), y2 = s(i, y2);
            return y2;
          }
          r.exports = u;
        } }), Ue2 = te2({ "src/common/util.js"(e, r) {
          ne2();
          var { default: t } = ($D2(), ft2(ja2)), s = lt2(), { getSupportInfo: a } = Xn2(), n = Kn2(), u = Oa2(), { skipWhitespace: i, skipSpaces: l, skipToLineEnd: p, skipEverythingButNewLine: y2 } = Pr2(), h = Ra2(), g2 = $a2(), c = Va2(), f = YD2(), F = (V) => V[V.length - 2];
          function _(V) {
            return (j, Y, ie2) => {
              let ee2 = ie2 && ie2.backwards;
              if (Y === false)
                return false;
              let { length: ce2 } = j, W = Y;
              for (; W >= 0 && W < ce2; ) {
                let K2 = j.charAt(W);
                if (V instanceof RegExp) {
                  if (!V.test(K2))
                    return W;
                } else if (!V.includes(K2))
                  return W;
                ee2 ? W-- : W++;
              }
              return W === -1 || W === ce2 ? W : false;
            };
          }
          function w(V, j) {
            let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, ie2 = l(V, Y.backwards ? j - 1 : j, Y), ee2 = c(V, ie2, Y);
            return ie2 !== ee2;
          }
          function E(V, j, Y) {
            for (let ie2 = j; ie2 < Y; ++ie2)
              if (V.charAt(ie2) === `
`)
                return true;
            return false;
          }
          function N2(V, j, Y) {
            let ie2 = Y(j) - 1;
            ie2 = l(V, ie2, { backwards: true }), ie2 = c(V, ie2, { backwards: true }), ie2 = l(V, ie2, { backwards: true });
            let ee2 = c(V, ie2, { backwards: true });
            return ie2 !== ee2;
          }
          function x(V, j) {
            let Y = null, ie2 = j;
            for (; ie2 !== Y; )
              Y = ie2, ie2 = p(V, ie2), ie2 = h(V, ie2), ie2 = l(V, ie2);
            return ie2 = g2(V, ie2), ie2 = c(V, ie2), ie2 !== false && w(V, ie2);
          }
          function I2(V, j, Y) {
            return x(V, Y(j));
          }
          function P(V, j, Y) {
            return f(V, Y(j));
          }
          function $2(V, j, Y) {
            return V.charAt(P(V, j, Y));
          }
          function D(V, j) {
            let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return l(V, Y.backwards ? j - 1 : j, Y) !== j;
          }
          function T(V, j) {
            let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, ie2 = 0;
            for (let ee2 = Y; ee2 < V.length; ++ee2)
              V[ee2] === "	" ? ie2 = ie2 + j - ie2 % j : ie2++;
            return ie2;
          }
          function m(V, j) {
            let Y = V.lastIndexOf(`
`);
            return Y === -1 ? 0 : T(V.slice(Y + 1).match(/^[\t ]*/)[0], j);
          }
          function C(V, j) {
            let Y = { quote: '"', regex: /"/g, escaped: "&quot;" }, ie2 = { quote: "'", regex: /'/g, escaped: "&apos;" }, ee2 = j === "'" ? ie2 : Y, ce2 = ee2 === ie2 ? Y : ie2, W = ee2;
            if (V.includes(ee2.quote) || V.includes(ce2.quote)) {
              let K2 = (V.match(ee2.regex) || []).length, de = (V.match(ce2.regex) || []).length;
              W = K2 > de ? ce2 : ee2;
            }
            return W;
          }
          function o(V, j) {
            let Y = V.slice(1, -1), ie2 = j.parser === "json" || j.parser === "json5" && j.quoteProps === "preserve" && !j.singleQuote ? '"' : j.__isInHtmlAttribute ? "'" : C(Y, j.singleQuote ? "'" : '"').quote;
            return d2(Y, ie2, !(j.parser === "css" || j.parser === "less" || j.parser === "scss" || j.__embeddedInHtml));
          }
          function d2(V, j, Y) {
            let ie2 = j === '"' ? "'" : '"', ee2 = /\\(.)|(["'])/gs, ce2 = V.replace(ee2, (W, K2, de) => K2 === ie2 ? K2 : de === j ? "\\" + de : de || (Y && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(K2) ? K2 : "\\" + K2));
            return j + ce2 + j;
          }
          function v2(V) {
            return V.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
          }
          function S(V, j) {
            let Y = V.match(new RegExp(`(${t(j)})+`, "g"));
            return Y === null ? 0 : Y.reduce((ie2, ee2) => Math.max(ie2, ee2.length / j.length), 0);
          }
          function b(V, j) {
            let Y = V.match(new RegExp(`(${t(j)})+`, "g"));
            if (Y === null)
              return 0;
            let ie2 = /* @__PURE__ */ new Map(), ee2 = 0;
            for (let ce2 of Y) {
              let W = ce2.length / j.length;
              ie2.set(W, true), W > ee2 && (ee2 = W);
            }
            for (let ce2 = 1; ce2 < ee2; ce2++)
              if (!ie2.get(ce2))
                return ce2;
            return ee2 + 1;
          }
          function B(V, j) {
            (V.comments || (V.comments = [])).push(j), j.printed = false, j.nodeDescription = Q(V);
          }
          function k(V, j) {
            j.leading = true, j.trailing = false, B(V, j);
          }
          function M2(V, j, Y) {
            j.leading = false, j.trailing = false, Y && (j.marker = Y), B(V, j);
          }
          function R2(V, j) {
            j.leading = false, j.trailing = true, B(V, j);
          }
          function q(V, j) {
            let { languages: Y } = a({ plugins: j.plugins }), ie2 = Y.find((ee2) => {
              let { name: ce2 } = ee2;
              return ce2.toLowerCase() === V;
            }) || Y.find((ee2) => {
              let { aliases: ce2 } = ee2;
              return Array.isArray(ce2) && ce2.includes(V);
            }) || Y.find((ee2) => {
              let { extensions: ce2 } = ee2;
              return Array.isArray(ce2) && ce2.includes(`.${V}`);
            });
            return ie2 && ie2.parsers[0];
          }
          function J(V) {
            return V && V.type === "front-matter";
          }
          function L(V) {
            let j = /* @__PURE__ */ new WeakMap();
            return function(Y) {
              return j.has(Y) || j.set(Y, Symbol(V)), j.get(Y);
            };
          }
          function Q(V) {
            let j = V.type || V.kind || "(unknown type)", Y = String(V.name || V.id && (typeof V.id == "object" ? V.id.name : V.id) || V.key && (typeof V.key == "object" ? V.key.name : V.key) || V.value && (typeof V.value == "object" ? "" : String(V.value)) || V.operator || "");
            return Y.length > 20 && (Y = Y.slice(0, 19) + "…"), j + (Y ? " " + Y : "");
          }
          r.exports = { inferParserByLanguage: q, getStringWidth: u, getMaxContinuousCount: S, getMinNotPresentContinuousCount: b, getPenultimate: F, getLast: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: f, getNextNonSpaceNonCommentCharacterIndex: P, getNextNonSpaceNonCommentCharacter: $2, skip: _, skipWhitespace: i, skipSpaces: l, skipToLineEnd: p, skipEverythingButNewLine: y2, skipInlineComment: h, skipTrailingComment: g2, skipNewline: c, isNextLineEmptyAfterIndex: x, isNextLineEmpty: I2, isPreviousLineEmpty: N2, hasNewline: w, hasNewlineInRange: E, hasSpaces: D, getAlignmentSize: T, getIndentSize: m, getPreferredQuote: C, printString: o, printNumber: v2, makeString: d2, addLeadingComment: k, addDanglingComment: M2, addTrailingComment: R2, isFrontMatterNode: J, isNonEmptyArray: n, createGroupIdMapper: L };
        } }), Wa2 = {};
        Kt2(Wa2, { basename: () => za2, default: () => Ka2, delimiter: () => Mn2, dirname: () => Ja2, extname: () => Xa2, isAbsolute: () => Qn2, join: () => Ga2, normalize: () => Yn2, relative: () => Ua2, resolve: () => wr2, sep: () => qn2 });
        function Ha2(e, r) {
          for (var t = 0, s = e.length - 1; s >= 0; s--) {
            var a = e[s];
            a === "." ? e.splice(s, 1) : a === ".." ? (e.splice(s, 1), t++) : t && (e.splice(s, 1), t--);
          }
          if (r)
            for (; t--; t)
              e.unshift("..");
          return e;
        }
        function wr2() {
          for (var e = "", r = false, t = arguments.length - 1; t >= -1 && !r; t--) {
            var s = t >= 0 ? arguments[t] : "/";
            if (typeof s != "string")
              throw new TypeError("Arguments to path.resolve must be strings");
            if (!s)
              continue;
            e = s + "/" + e, r = s.charAt(0) === "/";
          }
          return e = Ha2(Zn2(e.split("/"), function(a) {
            return !!a;
          }), !r).join("/"), (r ? "/" : "") + e || ".";
        }
        function Yn2(e) {
          var r = Qn2(e), t = Ya2(e, -1) === "/";
          return e = Ha2(Zn2(e.split("/"), function(s) {
            return !!s;
          }), !r).join("/"), !e && !r && (e = "."), e && t && (e += "/"), (r ? "/" : "") + e;
        }
        function Qn2(e) {
          return e.charAt(0) === "/";
        }
        function Ga2() {
          var e = Array.prototype.slice.call(arguments, 0);
          return Yn2(Zn2(e, function(r, t) {
            if (typeof r != "string")
              throw new TypeError("Arguments to path.join must be strings");
            return r;
          }).join("/"));
        }
        function Ua2(e, r) {
          e = wr2(e).substr(1), r = wr2(r).substr(1);
          function t(p) {
            for (var y2 = 0; y2 < p.length && p[y2] === ""; y2++)
              ;
            for (var h = p.length - 1; h >= 0 && p[h] === ""; h--)
              ;
            return y2 > h ? [] : p.slice(y2, h - y2 + 1);
          }
          for (var s = t(e.split("/")), a = t(r.split("/")), n = Math.min(s.length, a.length), u = n, i = 0; i < n; i++)
            if (s[i] !== a[i]) {
              u = i;
              break;
            }
          for (var l = [], i = u; i < s.length; i++)
            l.push("..");
          return l = l.concat(a.slice(u)), l.join("/");
        }
        function Ja2(e) {
          var r = Ir2(e), t = r[0], s = r[1];
          return !t && !s ? "." : (s && (s = s.substr(0, s.length - 1)), t + s);
        }
        function za2(e, r) {
          var t = Ir2(e)[2];
          return r && t.substr(-1 * r.length) === r && (t = t.substr(0, t.length - r.length)), t;
        }
        function Xa2(e) {
          return Ir2(e)[3];
        }
        function Zn2(e, r) {
          if (e.filter)
            return e.filter(r);
          for (var t = [], s = 0; s < e.length; s++)
            r(e[s], s, e) && t.push(e[s]);
          return t;
        }
        var Na2, Ir2, qn2, Mn2, Ka2, Ya2, QD2 = ht2({ "node-modules-polyfills:path"() {
          ne2(), Na2 = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, Ir2 = function(e) {
            return Na2.exec(e).slice(1);
          }, qn2 = "/", Mn2 = ":", Ka2 = { extname: Xa2, basename: za2, dirname: Ja2, sep: qn2, delimiter: Mn2, relative: Ua2, join: Ga2, isAbsolute: Qn2, normalize: Yn2, resolve: wr2 }, Ya2 = "ab".substr(-1) === "b" ? function(e, r, t) {
            return e.substr(r, t);
          } : function(e, r, t) {
            return r < 0 && (r = e.length + r), e.substr(r, t);
          };
        } }), ZD2 = te2({ "node-modules-polyfills-commonjs:path"(e, r) {
          ne2();
          var t = (QD2(), ft2(Wa2));
          if (t && t.default) {
            r.exports = t.default;
            for (let s in t)
              r.exports[s] = t[s];
          } else
            t && (r.exports = t);
        } }), Qt2 = te2({ "src/common/errors.js"(e, r) {
          ne2();
          var t = class extends Error {
          }, s = class extends Error {
          }, a = class extends Error {
          }, n = class extends Error {
          };
          r.exports = { ConfigError: t, DebugError: s, UndefinedParserError: a, ArgExpansionBailout: n };
        } }), vt2 = {};
        Kt2(vt2, { __assign: () => Nr2, __asyncDelegator: () => fm2, __asyncGenerator: () => pm2, __asyncValues: () => Dm2, __await: () => Xt2, __awaiter: () => sm2, __classPrivateFieldGet: () => ym2, __classPrivateFieldSet: () => hm2, __createBinding: () => am2, __decorate: () => rm2, __exportStar: () => om2, __extends: () => em2, __generator: () => im2, __importDefault: () => gm2, __importStar: () => dm2, __makeTemplateObject: () => mm2, __metadata: () => um2, __param: () => nm2, __read: () => Qa2, __rest: () => tm2, __spread: () => lm2, __spreadArrays: () => cm2, __values: () => Rn2 });
        function em2(e, r) {
          Br2(e, r);
          function t() {
            this.constructor = e;
          }
          e.prototype = r === null ? Object.create(r) : (t.prototype = r.prototype, new t());
        }
        function tm2(e, r) {
          var t = {};
          for (var s in e)
            Object.prototype.hasOwnProperty.call(e, s) && r.indexOf(s) < 0 && (t[s] = e[s]);
          if (e != null && typeof Object.getOwnPropertySymbols == "function")
            for (var a = 0, s = Object.getOwnPropertySymbols(e); a < s.length; a++)
              r.indexOf(s[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[a]) && (t[s[a]] = e[s[a]]);
          return t;
        }
        function rm2(e, r, t, s) {
          var a = arguments.length, n = a < 3 ? r : s === null ? s = Object.getOwnPropertyDescriptor(r, t) : s, u;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            n = Reflect.decorate(e, r, t, s);
          else
            for (var i = e.length - 1; i >= 0; i--)
              (u = e[i]) && (n = (a < 3 ? u(n) : a > 3 ? u(r, t, n) : u(r, t)) || n);
          return a > 3 && n && Object.defineProperty(r, t, n), n;
        }
        function nm2(e, r) {
          return function(t, s) {
            r(t, s, e);
          };
        }
        function um2(e, r) {
          if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
            return Reflect.metadata(e, r);
        }
        function sm2(e, r, t, s) {
          function a(n) {
            return n instanceof t ? n : new t(function(u) {
              u(n);
            });
          }
          return new (t || (t = Promise))(function(n, u) {
            function i(y2) {
              try {
                p(s.next(y2));
              } catch (h) {
                u(h);
              }
            }
            function l(y2) {
              try {
                p(s.throw(y2));
              } catch (h) {
                u(h);
              }
            }
            function p(y2) {
              y2.done ? n(y2.value) : a(y2.value).then(i, l);
            }
            p((s = s.apply(e, r || [])).next());
          });
        }
        function im2(e, r) {
          var t = { label: 0, sent: function() {
            if (n[0] & 1)
              throw n[1];
            return n[1];
          }, trys: [], ops: [] }, s, a, n, u;
          return u = { next: i(0), throw: i(1), return: i(2) }, typeof Symbol == "function" && (u[Symbol.iterator] = function() {
            return this;
          }), u;
          function i(p) {
            return function(y2) {
              return l([p, y2]);
            };
          }
          function l(p) {
            if (s)
              throw new TypeError("Generator is already executing.");
            for (; t; )
              try {
                if (s = 1, a && (n = p[0] & 2 ? a.return : p[0] ? a.throw || ((n = a.return) && n.call(a), 0) : a.next) && !(n = n.call(a, p[1])).done)
                  return n;
                switch (a = 0, n && (p = [p[0] & 2, n.value]), p[0]) {
                  case 0:
                  case 1:
                    n = p;
                    break;
                  case 4:
                    return t.label++, { value: p[1], done: false };
                  case 5:
                    t.label++, a = p[1], p = [0];
                    continue;
                  case 7:
                    p = t.ops.pop(), t.trys.pop();
                    continue;
                  default:
                    if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (p[0] === 6 || p[0] === 2)) {
                      t = 0;
                      continue;
                    }
                    if (p[0] === 3 && (!n || p[1] > n[0] && p[1] < n[3])) {
                      t.label = p[1];
                      break;
                    }
                    if (p[0] === 6 && t.label < n[1]) {
                      t.label = n[1], n = p;
                      break;
                    }
                    if (n && t.label < n[2]) {
                      t.label = n[2], t.ops.push(p);
                      break;
                    }
                    n[2] && t.ops.pop(), t.trys.pop();
                    continue;
                }
                p = r.call(e, t);
              } catch (y2) {
                p = [6, y2], a = 0;
              } finally {
                s = n = 0;
              }
            if (p[0] & 5)
              throw p[1];
            return { value: p[0] ? p[1] : void 0, done: true };
          }
        }
        function am2(e, r, t, s) {
          s === void 0 && (s = t), e[s] = r[t];
        }
        function om2(e, r) {
          for (var t in e)
            t !== "default" && !r.hasOwnProperty(t) && (r[t] = e[t]);
        }
        function Rn2(e) {
          var r = typeof Symbol == "function" && Symbol.iterator, t = r && e[r], s = 0;
          if (t)
            return t.call(e);
          if (e && typeof e.length == "number")
            return { next: function() {
              return e && s >= e.length && (e = void 0), { value: e && e[s++], done: !e };
            } };
          throw new TypeError(r ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }
        function Qa2(e, r) {
          var t = typeof Symbol == "function" && e[Symbol.iterator];
          if (!t)
            return e;
          var s = t.call(e), a, n = [], u;
          try {
            for (; (r === void 0 || r-- > 0) && !(a = s.next()).done; )
              n.push(a.value);
          } catch (i) {
            u = { error: i };
          } finally {
            try {
              a && !a.done && (t = s.return) && t.call(s);
            } finally {
              if (u)
                throw u.error;
            }
          }
          return n;
        }
        function lm2() {
          for (var e = [], r = 0; r < arguments.length; r++)
            e = e.concat(Qa2(arguments[r]));
          return e;
        }
        function cm2() {
          for (var e = 0, r = 0, t = arguments.length; r < t; r++)
            e += arguments[r].length;
          for (var s = Array(e), a = 0, r = 0; r < t; r++)
            for (var n = arguments[r], u = 0, i = n.length; u < i; u++, a++)
              s[a] = n[u];
          return s;
        }
        function Xt2(e) {
          return this instanceof Xt2 ? (this.v = e, this) : new Xt2(e);
        }
        function pm2(e, r, t) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var s = t.apply(e, r || []), a, n = [];
          return a = {}, u("next"), u("throw"), u("return"), a[Symbol.asyncIterator] = function() {
            return this;
          }, a;
          function u(g2) {
            s[g2] && (a[g2] = function(c) {
              return new Promise(function(f, F) {
                n.push([g2, c, f, F]) > 1 || i(g2, c);
              });
            });
          }
          function i(g2, c) {
            try {
              l(s[g2](c));
            } catch (f) {
              h(n[0][3], f);
            }
          }
          function l(g2) {
            g2.value instanceof Xt2 ? Promise.resolve(g2.value.v).then(p, y2) : h(n[0][2], g2);
          }
          function p(g2) {
            i("next", g2);
          }
          function y2(g2) {
            i("throw", g2);
          }
          function h(g2, c) {
            g2(c), n.shift(), n.length && i(n[0][0], n[0][1]);
          }
        }
        function fm2(e) {
          var r, t;
          return r = {}, s("next"), s("throw", function(a) {
            throw a;
          }), s("return"), r[Symbol.iterator] = function() {
            return this;
          }, r;
          function s(a, n) {
            r[a] = e[a] ? function(u) {
              return (t = !t) ? { value: Xt2(e[a](u)), done: a === "return" } : n ? n(u) : u;
            } : n;
          }
        }
        function Dm2(e) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var r = e[Symbol.asyncIterator], t;
          return r ? r.call(e) : (e = typeof Rn2 == "function" ? Rn2(e) : e[Symbol.iterator](), t = {}, s("next"), s("throw"), s("return"), t[Symbol.asyncIterator] = function() {
            return this;
          }, t);
          function s(n) {
            t[n] = e[n] && function(u) {
              return new Promise(function(i, l) {
                u = e[n](u), a(i, l, u.done, u.value);
              });
            };
          }
          function a(n, u, i, l) {
            Promise.resolve(l).then(function(p) {
              n({ value: p, done: i });
            }, u);
          }
        }
        function mm2(e, r) {
          return Object.defineProperty ? Object.defineProperty(e, "raw", { value: r }) : e.raw = r, e;
        }
        function dm2(e) {
          if (e && e.__esModule)
            return e;
          var r = {};
          if (e != null)
            for (var t in e)
              Object.hasOwnProperty.call(e, t) && (r[t] = e[t]);
          return r.default = e, r;
        }
        function gm2(e) {
          return e && e.__esModule ? e : { default: e };
        }
        function ym2(e, r) {
          if (!r.has(e))
            throw new TypeError("attempted to get private field on non-instance");
          return r.get(e);
        }
        function hm2(e, r, t) {
          if (!r.has(e))
            throw new TypeError("attempted to set private field on non-instance");
          return r.set(e, t), t;
        }
        var Br2, Nr2, Et2 = ht2({ "node_modules/tslib/tslib.es6.js"() {
          ne2(), Br2 = function(e, r) {
            return Br2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, s) {
              t.__proto__ = s;
            } || function(t, s) {
              for (var a in s)
                s.hasOwnProperty(a) && (t[a] = s[a]);
            }, Br2(e, r);
          }, Nr2 = function() {
            return Nr2 = Object.assign || function(r) {
              for (var t, s = 1, a = arguments.length; s < a; s++) {
                t = arguments[s];
                for (var n in t)
                  Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]);
              }
              return r;
            }, Nr2.apply(this, arguments);
          };
        } }), Za2 = te2({ "node_modules/vnopts/lib/descriptors/api.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true }), e.apiDescriptor = { key: (r) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(r) ? r : JSON.stringify(r), value(r) {
            if (r === null || typeof r != "object")
              return JSON.stringify(r);
            if (Array.isArray(r))
              return `[${r.map((s) => e.apiDescriptor.value(s)).join(", ")}]`;
            let t = Object.keys(r);
            return t.length === 0 ? "{}" : `{ ${t.map((s) => `${e.apiDescriptor.key(s)}: ${e.apiDescriptor.value(r[s])}`).join(", ")} }`;
          }, pair: (r) => {
            let { key: t, value: s } = r;
            return e.apiDescriptor.value({ [t]: s });
          } };
        } }), vm2 = te2({ "node_modules/vnopts/lib/descriptors/index.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = (Et2(), ft2(vt2));
          r.__exportStar(Za2(), e);
        } }), kr2 = te2({ "scripts/build/shims/chalk.cjs"(e, r) {
          ne2();
          var t = (s) => s;
          t.grey = t, t.red = t, t.bold = t, t.yellow = t, t.blue = t, t.default = t, r.exports = t;
        } }), eo2 = te2({ "node_modules/vnopts/lib/handlers/deprecated/common.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = kr2();
          e.commonDeprecatedHandler = (t, s, a) => {
            let { descriptor: n } = a, u = [`${r.default.yellow(typeof t == "string" ? n.key(t) : n.pair(t))} is deprecated`];
            return s && u.push(`we now treat it as ${r.default.blue(typeof s == "string" ? n.key(s) : n.pair(s))}`), u.join("; ") + ".";
          };
        } }), Cm2 = te2({ "node_modules/vnopts/lib/handlers/deprecated/index.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = (Et2(), ft2(vt2));
          r.__exportStar(eo2(), e);
        } }), Em2 = te2({ "node_modules/vnopts/lib/handlers/invalid/common.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = kr2();
          e.commonInvalidHandler = (t, s, a) => [`Invalid ${r.default.red(a.descriptor.key(t))} value.`, `Expected ${r.default.blue(a.schemas[t].expected(a))},`, `but received ${r.default.red(a.descriptor.value(s))}.`].join(" ");
        } }), to2 = te2({ "node_modules/vnopts/lib/handlers/invalid/index.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = (Et2(), ft2(vt2));
          r.__exportStar(Em2(), e);
        } }), Fm2 = te2({ "node_modules/vnopts/node_modules/leven/index.js"(e, r) {
          ne2();
          var t = [], s = [];
          r.exports = function(a, n) {
            if (a === n)
              return 0;
            var u = a;
            a.length > n.length && (a = n, n = u);
            var i = a.length, l = n.length;
            if (i === 0)
              return l;
            if (l === 0)
              return i;
            for (; i > 0 && a.charCodeAt(~-i) === n.charCodeAt(~-l); )
              i--, l--;
            if (i === 0)
              return l;
            for (var p = 0; p < i && a.charCodeAt(p) === n.charCodeAt(p); )
              p++;
            if (i -= p, l -= p, i === 0)
              return l;
            for (var y2, h, g2, c, f = 0, F = 0; f < i; )
              s[p + f] = a.charCodeAt(p + f), t[f] = ++f;
            for (; F < l; )
              for (y2 = n.charCodeAt(p + F), g2 = F++, h = F, f = 0; f < i; f++)
                c = y2 === s[p + f] ? g2 : g2 + 1, g2 = t[f], h = t[f] = g2 > h ? c > h ? h + 1 : c : c > g2 ? g2 + 1 : c;
            return h;
          };
        } }), ro2 = te2({ "node_modules/vnopts/lib/handlers/unknown/leven.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = kr2(), t = Fm2();
          e.levenUnknownHandler = (s, a, n) => {
            let { descriptor: u, logger: i, schemas: l } = n, p = [`Ignored unknown option ${r.default.yellow(u.pair({ key: s, value: a }))}.`], y2 = Object.keys(l).sort().find((h) => t(s, h) < 3);
            y2 && p.push(`Did you mean ${r.default.blue(u.key(y2))}?`), i.warn(p.join(" "));
          };
        } }), Am2 = te2({ "node_modules/vnopts/lib/handlers/unknown/index.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = (Et2(), ft2(vt2));
          r.__exportStar(ro2(), e);
        } }), Sm2 = te2({ "node_modules/vnopts/lib/handlers/index.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = (Et2(), ft2(vt2));
          r.__exportStar(Cm2(), e), r.__exportStar(to2(), e), r.__exportStar(Am2(), e);
        } }), Ft2 = te2({ "node_modules/vnopts/lib/schema.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
          function t(n, u) {
            let i = new n(u), l = Object.create(i);
            for (let p of r)
              p in u && (l[p] = a(u[p], i, s.prototype[p].length));
            return l;
          }
          e.createSchema = t;
          var s = class {
            constructor(n) {
              this.name = n.name;
            }
            static create(n) {
              return t(this, n);
            }
            default(n) {
            }
            expected(n) {
              return "nothing";
            }
            validate(n, u) {
              return false;
            }
            deprecated(n, u) {
              return false;
            }
            forward(n, u) {
            }
            redirect(n, u) {
            }
            overlap(n, u, i) {
              return n;
            }
            preprocess(n, u) {
              return n;
            }
            postprocess(n, u) {
              return n;
            }
          };
          e.Schema = s;
          function a(n, u, i) {
            return typeof n == "function" ? function() {
              for (var l = arguments.length, p = new Array(l), y2 = 0; y2 < l; y2++)
                p[y2] = arguments[y2];
              return n(...p.slice(0, i - 1), u, ...p.slice(i - 1));
            } : () => n;
          }
        } }), xm2 = te2({ "node_modules/vnopts/lib/schemas/alias.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Ft2(), t = class extends r.Schema {
            constructor(s) {
              super(s), this._sourceName = s.sourceName;
            }
            expected(s) {
              return s.schemas[this._sourceName].expected(s);
            }
            validate(s, a) {
              return a.schemas[this._sourceName].validate(s, a);
            }
            redirect(s, a) {
              return this._sourceName;
            }
          };
          e.AliasSchema = t;
        } }), bm2 = te2({ "node_modules/vnopts/lib/schemas/any.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Ft2(), t = class extends r.Schema {
            expected() {
              return "anything";
            }
            validate() {
              return true;
            }
          };
          e.AnySchema = t;
        } }), Tm2 = te2({ "node_modules/vnopts/lib/schemas/array.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = (Et2(), ft2(vt2)), t = Ft2(), s = class extends t.Schema {
            constructor(n) {
              var { valueSchema: u, name: i = u.name } = n, l = r.__rest(n, ["valueSchema", "name"]);
              super(Object.assign({}, l, { name: i })), this._valueSchema = u;
            }
            expected(n) {
              return `an array of ${this._valueSchema.expected(n)}`;
            }
            validate(n, u) {
              if (!Array.isArray(n))
                return false;
              let i = [];
              for (let l of n) {
                let p = u.normalizeValidateResult(this._valueSchema.validate(l, u), l);
                p !== true && i.push(p.value);
              }
              return i.length === 0 ? true : { value: i };
            }
            deprecated(n, u) {
              let i = [];
              for (let l of n) {
                let p = u.normalizeDeprecatedResult(this._valueSchema.deprecated(l, u), l);
                p !== false && i.push(...p.map((y2) => {
                  let { value: h } = y2;
                  return { value: [h] };
                }));
              }
              return i;
            }
            forward(n, u) {
              let i = [];
              for (let l of n) {
                let p = u.normalizeForwardResult(this._valueSchema.forward(l, u), l);
                i.push(...p.map(a));
              }
              return i;
            }
            redirect(n, u) {
              let i = [], l = [];
              for (let p of n) {
                let y2 = u.normalizeRedirectResult(this._valueSchema.redirect(p, u), p);
                "remain" in y2 && i.push(y2.remain), l.push(...y2.redirect.map(a));
              }
              return i.length === 0 ? { redirect: l } : { redirect: l, remain: i };
            }
            overlap(n, u) {
              return n.concat(u);
            }
          };
          e.ArraySchema = s;
          function a(n) {
            let { from: u, to: i } = n;
            return { from: [u], to: i };
          }
        } }), Bm2 = te2({ "node_modules/vnopts/lib/schemas/boolean.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Ft2(), t = class extends r.Schema {
            expected() {
              return "true or false";
            }
            validate(s) {
              return typeof s == "boolean";
            }
          };
          e.BooleanSchema = t;
        } }), eu2 = te2({ "node_modules/vnopts/lib/utils.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          function r(c, f) {
            let F = /* @__PURE__ */ Object.create(null);
            for (let _ of c) {
              let w = _[f];
              if (F[w])
                throw new Error(`Duplicate ${f} ${JSON.stringify(w)}`);
              F[w] = _;
            }
            return F;
          }
          e.recordFromArray = r;
          function t(c, f) {
            let F = /* @__PURE__ */ new Map();
            for (let _ of c) {
              let w = _[f];
              if (F.has(w))
                throw new Error(`Duplicate ${f} ${JSON.stringify(w)}`);
              F.set(w, _);
            }
            return F;
          }
          e.mapFromArray = t;
          function s() {
            let c = /* @__PURE__ */ Object.create(null);
            return (f) => {
              let F = JSON.stringify(f);
              return c[F] ? true : (c[F] = true, false);
            };
          }
          e.createAutoChecklist = s;
          function a(c, f) {
            let F = [], _ = [];
            for (let w of c)
              f(w) ? F.push(w) : _.push(w);
            return [F, _];
          }
          e.partition = a;
          function n(c) {
            return c === Math.floor(c);
          }
          e.isInt = n;
          function u(c, f) {
            if (c === f)
              return 0;
            let F = typeof c, _ = typeof f, w = ["undefined", "object", "boolean", "number", "string"];
            return F !== _ ? w.indexOf(F) - w.indexOf(_) : F !== "string" ? Number(c) - Number(f) : c.localeCompare(f);
          }
          e.comparePrimitive = u;
          function i(c) {
            return c === void 0 ? {} : c;
          }
          e.normalizeDefaultResult = i;
          function l(c, f) {
            return c === true ? true : c === false ? { value: f } : c;
          }
          e.normalizeValidateResult = l;
          function p(c, f) {
            let F = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            return c === false ? false : c === true ? F ? true : [{ value: f }] : "value" in c ? [c] : c.length === 0 ? false : c;
          }
          e.normalizeDeprecatedResult = p;
          function y2(c, f) {
            return typeof c == "string" || "key" in c ? { from: f, to: c } : "from" in c ? { from: c.from, to: c.to } : { from: f, to: c.to };
          }
          e.normalizeTransferResult = y2;
          function h(c, f) {
            return c === void 0 ? [] : Array.isArray(c) ? c.map((F) => y2(F, f)) : [y2(c, f)];
          }
          e.normalizeForwardResult = h;
          function g2(c, f) {
            let F = h(typeof c == "object" && "redirect" in c ? c.redirect : c, f);
            return F.length === 0 ? { remain: f, redirect: F } : typeof c == "object" && "remain" in c ? { remain: c.remain, redirect: F } : { redirect: F };
          }
          e.normalizeRedirectResult = g2;
        } }), Nm2 = te2({ "node_modules/vnopts/lib/schemas/choice.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Ft2(), t = eu2(), s = class extends r.Schema {
            constructor(a) {
              super(a), this._choices = t.mapFromArray(a.choices.map((n) => n && typeof n == "object" ? n : { value: n }), "value");
            }
            expected(a) {
              let { descriptor: n } = a, u = Array.from(this._choices.keys()).map((p) => this._choices.get(p)).filter((p) => !p.deprecated).map((p) => p.value).sort(t.comparePrimitive).map(n.value), i = u.slice(0, -2), l = u.slice(-2);
              return i.concat(l.join(" or ")).join(", ");
            }
            validate(a) {
              return this._choices.has(a);
            }
            deprecated(a) {
              let n = this._choices.get(a);
              return n && n.deprecated ? { value: a } : false;
            }
            forward(a) {
              let n = this._choices.get(a);
              return n ? n.forward : void 0;
            }
            redirect(a) {
              let n = this._choices.get(a);
              return n ? n.redirect : void 0;
            }
          };
          e.ChoiceSchema = s;
        } }), no2 = te2({ "node_modules/vnopts/lib/schemas/number.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Ft2(), t = class extends r.Schema {
            expected() {
              return "a number";
            }
            validate(s, a) {
              return typeof s == "number";
            }
          };
          e.NumberSchema = t;
        } }), wm2 = te2({ "node_modules/vnopts/lib/schemas/integer.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = eu2(), t = no2(), s = class extends t.NumberSchema {
            expected() {
              return "an integer";
            }
            validate(a, n) {
              return n.normalizeValidateResult(super.validate(a, n), a) === true && r.isInt(a);
            }
          };
          e.IntegerSchema = s;
        } }), _m2 = te2({ "node_modules/vnopts/lib/schemas/string.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Ft2(), t = class extends r.Schema {
            expected() {
              return "a string";
            }
            validate(s) {
              return typeof s == "string";
            }
          };
          e.StringSchema = t;
        } }), Pm2 = te2({ "node_modules/vnopts/lib/schemas/index.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = (Et2(), ft2(vt2));
          r.__exportStar(xm2(), e), r.__exportStar(bm2(), e), r.__exportStar(Tm2(), e), r.__exportStar(Bm2(), e), r.__exportStar(Nm2(), e), r.__exportStar(wm2(), e), r.__exportStar(no2(), e), r.__exportStar(_m2(), e);
        } }), Im2 = te2({ "node_modules/vnopts/lib/defaults.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Za2(), t = eo2(), s = to2(), a = ro2();
          e.defaultDescriptor = r.apiDescriptor, e.defaultUnknownHandler = a.levenUnknownHandler, e.defaultInvalidHandler = s.commonInvalidHandler, e.defaultDeprecatedHandler = t.commonDeprecatedHandler;
        } }), km2 = te2({ "node_modules/vnopts/lib/normalize.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Im2(), t = eu2();
          e.normalize = (a, n, u) => new s(n, u).normalize(a);
          var s = class {
            constructor(a, n) {
              let { logger: u = console, descriptor: i = r.defaultDescriptor, unknown: l = r.defaultUnknownHandler, invalid: p = r.defaultInvalidHandler, deprecated: y2 = r.defaultDeprecatedHandler } = n || {};
              this._utils = { descriptor: i, logger: u || { warn: () => {
              } }, schemas: t.recordFromArray(a, "name"), normalizeDefaultResult: t.normalizeDefaultResult, normalizeDeprecatedResult: t.normalizeDeprecatedResult, normalizeForwardResult: t.normalizeForwardResult, normalizeRedirectResult: t.normalizeRedirectResult, normalizeValidateResult: t.normalizeValidateResult }, this._unknownHandler = l, this._invalidHandler = p, this._deprecatedHandler = y2, this.cleanHistory();
            }
            cleanHistory() {
              this._hasDeprecationWarned = t.createAutoChecklist();
            }
            normalize(a) {
              let n = {}, u = [a], i = () => {
                for (; u.length !== 0; ) {
                  let l = u.shift(), p = this._applyNormalization(l, n);
                  u.push(...p);
                }
              };
              i();
              for (let l of Object.keys(this._utils.schemas)) {
                let p = this._utils.schemas[l];
                if (!(l in n)) {
                  let y2 = t.normalizeDefaultResult(p.default(this._utils));
                  "value" in y2 && u.push({ [l]: y2.value });
                }
              }
              i();
              for (let l of Object.keys(this._utils.schemas)) {
                let p = this._utils.schemas[l];
                l in n && (n[l] = p.postprocess(n[l], this._utils));
              }
              return n;
            }
            _applyNormalization(a, n) {
              let u = [], [i, l] = t.partition(Object.keys(a), (p) => p in this._utils.schemas);
              for (let p of i) {
                let y2 = this._utils.schemas[p], h = y2.preprocess(a[p], this._utils), g2 = t.normalizeValidateResult(y2.validate(h, this._utils), h);
                if (g2 !== true) {
                  let { value: w } = g2, E = this._invalidHandler(p, w, this._utils);
                  throw typeof E == "string" ? new Error(E) : E;
                }
                let c = (w) => {
                  let { from: E, to: N2 } = w;
                  u.push(typeof N2 == "string" ? { [N2]: E } : { [N2.key]: N2.value });
                }, f = (w) => {
                  let { value: E, redirectTo: N2 } = w, x = t.normalizeDeprecatedResult(y2.deprecated(E, this._utils), h, true);
                  if (x !== false)
                    if (x === true)
                      this._hasDeprecationWarned(p) || this._utils.logger.warn(this._deprecatedHandler(p, N2, this._utils));
                    else
                      for (let { value: I2 } of x) {
                        let P = { key: p, value: I2 };
                        if (!this._hasDeprecationWarned(P)) {
                          let $2 = typeof N2 == "string" ? { key: N2, value: I2 } : N2;
                          this._utils.logger.warn(this._deprecatedHandler(P, $2, this._utils));
                        }
                      }
                };
                t.normalizeForwardResult(y2.forward(h, this._utils), h).forEach(c);
                let _ = t.normalizeRedirectResult(y2.redirect(h, this._utils), h);
                if (_.redirect.forEach(c), "remain" in _) {
                  let w = _.remain;
                  n[p] = p in n ? y2.overlap(n[p], w, this._utils) : w, f({ value: w });
                }
                for (let { from: w, to: E } of _.redirect)
                  f({ value: w, redirectTo: E });
              }
              for (let p of l) {
                let y2 = a[p], h = this._unknownHandler(p, y2, this._utils);
                if (h)
                  for (let g2 of Object.keys(h)) {
                    let c = { [g2]: h[g2] };
                    g2 in this._utils.schemas ? u.push(c) : Object.assign(n, c);
                  }
              }
              return u;
            }
          };
          e.Normalizer = s;
        } }), Lm2 = te2({ "node_modules/vnopts/lib/index.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = (Et2(), ft2(vt2));
          r.__exportStar(vm2(), e), r.__exportStar(Sm2(), e), r.__exportStar(Pm2(), e), r.__exportStar(km2(), e), r.__exportStar(Ft2(), e);
        } }), Om2 = te2({ "src/main/options-normalizer.js"(e, r) {
          ne2();
          var t = Lm2(), s = lt2(), a = { key: (g2) => g2.length === 1 ? `-${g2}` : `--${g2}`, value: (g2) => t.apiDescriptor.value(g2), pair: (g2) => {
            let { key: c, value: f } = g2;
            return f === false ? `--no-${c}` : f === true ? a.key(c) : f === "" ? `${a.key(c)} without an argument` : `${a.key(c)}=${f}`;
          } }, n = (g2) => {
            let { colorsModule: c, levenshteinDistance: f } = g2;
            return class extends t.ChoiceSchema {
              constructor(_) {
                let { name: w, flags: E } = _;
                super({ name: w, choices: E }), this._flags = [...E].sort();
              }
              preprocess(_, w) {
                if (typeof _ == "string" && _.length > 0 && !this._flags.includes(_)) {
                  let E = this._flags.find((N2) => f(N2, _) < 3);
                  if (E)
                    return w.logger.warn([`Unknown flag ${c.yellow(w.descriptor.value(_))},`, `did you mean ${c.blue(w.descriptor.value(E))}?`].join(" ")), E;
                }
                return _;
              }
              expected() {
                return "a flag";
              }
            };
          }, u;
          function i(g2, c) {
            let { logger: f = false, isCLI: F = false, passThrough: _ = false, colorsModule: w = null, levenshteinDistance: E = null } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, N2 = _ ? Array.isArray(_) ? (T, m) => _.includes(T) ? { [T]: m } : void 0 : (T, m) => ({ [T]: m }) : (T, m, C) => {
              let o = C.schemas, v2 = Hn2(o, vD2);
              return t.levenUnknownHandler(T, m, Object.assign(Object.assign({}, C), {}, { schemas: v2 }));
            }, x = F ? a : t.apiDescriptor, I2 = l(c, { isCLI: F, colorsModule: w, levenshteinDistance: E }), P = new t.Normalizer(I2, { logger: f, unknown: N2, descriptor: x }), $2 = f !== false;
            $2 && u && (P._hasDeprecationWarned = u);
            let D = P.normalize(g2);
            return $2 && (u = P._hasDeprecationWarned), F && D["plugin-search"] === false && (D["plugin-search-dir"] = false), D;
          }
          function l(g2, c) {
            let { isCLI: f, colorsModule: F, levenshteinDistance: _ } = c, w = [];
            f && w.push(t.AnySchema.create({ name: "_" }));
            for (let E of g2)
              w.push(p(E, { isCLI: f, optionInfos: g2, colorsModule: F, levenshteinDistance: _ })), E.alias && f && w.push(t.AliasSchema.create({ name: E.alias, sourceName: E.name }));
            return w;
          }
          function p(g2, c) {
            let { isCLI: f, optionInfos: F, colorsModule: _, levenshteinDistance: w } = c, { name: E } = g2;
            if (E === "plugin-search-dir" || E === "pluginSearchDirs")
              return t.AnySchema.create({ name: E, preprocess(P) {
                return P === false || (P = Array.isArray(P) ? P : [P]), P;
              }, validate(P) {
                return P === false ? true : P.every(($2) => typeof $2 == "string");
              }, expected() {
                return "false or paths to plugin search dir";
              } });
            let N2 = { name: E }, x, I2 = {};
            switch (g2.type) {
              case "int":
                x = t.IntegerSchema, f && (N2.preprocess = Number);
                break;
              case "string":
                x = t.StringSchema;
                break;
              case "choice":
                x = t.ChoiceSchema, N2.choices = g2.choices.map((P) => typeof P == "object" && P.redirect ? Object.assign(Object.assign({}, P), {}, { redirect: { to: { key: g2.name, value: P.redirect } } }) : P);
                break;
              case "boolean":
                x = t.BooleanSchema;
                break;
              case "flag":
                x = n({ colorsModule: _, levenshteinDistance: w }), N2.flags = F.flatMap((P) => [P.alias, P.description && P.name, P.oppositeDescription && `no-${P.name}`].filter(Boolean));
                break;
              case "path":
                x = t.StringSchema;
                break;
              default:
                throw new Error(`Unexpected type ${g2.type}`);
            }
            if (g2.exception ? N2.validate = (P, $2, D) => g2.exception(P) || $2.validate(P, D) : N2.validate = (P, $2, D) => P === void 0 || $2.validate(P, D), g2.redirect && (I2.redirect = (P) => P ? { to: { key: g2.redirect.option, value: g2.redirect.value } } : void 0), g2.deprecated && (I2.deprecated = true), f && !g2.array) {
              let P = N2.preprocess || (($2) => $2);
              N2.preprocess = ($2, D, T) => D.preprocess(P(Array.isArray($2) ? s($2) : $2), T);
            }
            return g2.array ? t.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, f ? { preprocess: (P) => Array.isArray(P) ? P : [P] } : {}), I2), {}, { valueSchema: x.create(N2) })) : x.create(Object.assign(Object.assign({}, N2), I2));
          }
          function y2(g2, c, f) {
            return i(g2, c, f);
          }
          function h(g2, c, f) {
            return i(g2, c, Object.assign({ isCLI: true }, f));
          }
          r.exports = { normalizeApiOptions: y2, normalizeCliOptions: h };
        } }), ut2 = te2({ "src/language-js/loc.js"(e, r) {
          ne2();
          var t = Kn2();
          function s(l) {
            var p, y2;
            let h = l.range ? l.range[0] : l.start, g2 = (p = (y2 = l.declaration) === null || y2 === void 0 ? void 0 : y2.decorators) !== null && p !== void 0 ? p : l.decorators;
            return t(g2) ? Math.min(s(g2[0]), h) : h;
          }
          function a(l) {
            return l.range ? l.range[1] : l.end;
          }
          function n(l, p) {
            let y2 = s(l);
            return Number.isInteger(y2) && y2 === s(p);
          }
          function u(l, p) {
            let y2 = a(l);
            return Number.isInteger(y2) && y2 === a(p);
          }
          function i(l, p) {
            return n(l, p) && u(l, p);
          }
          r.exports = { locStart: s, locEnd: a, hasSameLocStart: n, hasSameLoc: i };
        } }), jm2 = te2({ "src/main/load-parser.js"(e, r) {
          ne2(), r.exports = () => {
          };
        } }), qm2 = te2({ "scripts/build/shims/babel-highlight.cjs"(e, r) {
          ne2();
          var t = kr2(), s = { shouldHighlight: () => false, getChalk: () => t };
          r.exports = s;
        } }), Mm2 = te2({ "node_modules/@babel/code-frame/lib/index.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true }), e.codeFrameColumns = u, e.default = i;
          var r = qm2(), t = false;
          function s(l) {
            return { gutter: l.grey, marker: l.red.bold, message: l.red.bold };
          }
          var a = /\r\n|[\n\r\u2028\u2029]/;
          function n(l, p, y2) {
            let h = Object.assign({ column: 0, line: -1 }, l.start), g2 = Object.assign({}, h, l.end), { linesAbove: c = 2, linesBelow: f = 3 } = y2 || {}, F = h.line, _ = h.column, w = g2.line, E = g2.column, N2 = Math.max(F - (c + 1), 0), x = Math.min(p.length, w + f);
            F === -1 && (N2 = 0), w === -1 && (x = p.length);
            let I2 = w - F, P = {};
            if (I2)
              for (let $2 = 0; $2 <= I2; $2++) {
                let D = $2 + F;
                if (!_)
                  P[D] = true;
                else if ($2 === 0) {
                  let T = p[D - 1].length;
                  P[D] = [_, T - _ + 1];
                } else if ($2 === I2)
                  P[D] = [0, E];
                else {
                  let T = p[D - $2].length;
                  P[D] = [0, T];
                }
              }
            else
              _ === E ? _ ? P[F] = [_, 0] : P[F] = true : P[F] = [_, E - _];
            return { start: N2, end: x, markerLines: P };
          }
          function u(l, p) {
            let y2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, h = (y2.highlightCode || y2.forceColor) && (0, r.shouldHighlight)(y2), g2 = (0, r.getChalk)(y2), c = s(g2), f = ($2, D) => h ? $2(D) : D, F = l.split(a), { start: _, end: w, markerLines: E } = n(p, F, y2), N2 = p.start && typeof p.start.column == "number", x = String(w).length, P = (h ? (0, r.default)(l, y2) : l).split(a, w).slice(_, w).map(($2, D) => {
              let T = _ + 1 + D, C = ` ${` ${T}`.slice(-x)} |`, o = E[T], d2 = !E[T + 1];
              if (o) {
                let v2 = "";
                if (Array.isArray(o)) {
                  let S = $2.slice(0, Math.max(o[0] - 1, 0)).replace(/[^\t]/g, " "), b = o[1] || 1;
                  v2 = [`
 `, f(c.gutter, C.replace(/\d/g, " ")), " ", S, f(c.marker, "^").repeat(b)].join(""), d2 && y2.message && (v2 += " " + f(c.message, y2.message));
                }
                return [f(c.marker, ">"), f(c.gutter, C), $2.length > 0 ? ` ${$2}` : "", v2].join("");
              } else
                return ` ${f(c.gutter, C)}${$2.length > 0 ? ` ${$2}` : ""}`;
            }).join(`
`);
            return y2.message && !N2 && (P = `${" ".repeat(x + 1)}${y2.message}
${P}`), h ? g2.reset(P) : P;
          }
          function i(l, p, y2) {
            let h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            if (!t) {
              t = true;
              let c = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
              if (wt2.emitWarning)
                wt2.emitWarning(c, "DeprecationWarning");
              else {
                let f = new Error(c);
                f.name = "DeprecationWarning", console.warn(new Error(c));
              }
            }
            return y2 = Math.max(y2, 0), u(l, { start: { column: y2, line: p } }, h);
          }
        } }), tu2 = te2({ "src/main/parser.js"(e, r) {
          ne2();
          var { ConfigError: t } = Qt2(), s = ut2();
          jm2();
          var { locStart: n, locEnd: u } = s, i = Object.getOwnPropertyNames, l = Object.getOwnPropertyDescriptor;
          function p(g2) {
            let c = {};
            for (let f of g2.plugins)
              if (f.parsers)
                for (let F of i(f.parsers))
                  Object.defineProperty(c, F, l(f.parsers, F));
            return c;
          }
          function y2(g2) {
            let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : p(g2);
            if (typeof g2.parser == "function")
              return { parse: g2.parser, astFormat: "estree", locStart: n, locEnd: u };
            if (typeof g2.parser == "string") {
              if (Object.prototype.hasOwnProperty.call(c, g2.parser))
                return c[g2.parser];
              throw new t(`Couldn't resolve parser "${g2.parser}". Parsers must be explicitly added to the standalone bundle.`);
            }
          }
          function h(g2, c) {
            let f = p(c), F = Object.defineProperties({}, Object.fromEntries(Object.keys(f).map((w) => [w, { enumerable: true, get() {
              return f[w].parse;
            } }]))), _ = y2(c, f);
            try {
              return _.preprocess && (g2 = _.preprocess(g2, c)), { text: g2, ast: _.parse(g2, F, c) };
            } catch (w) {
              let { loc: E } = w;
              if (E) {
                let { codeFrameColumns: N2 } = Mm2();
                throw w.codeFrame = N2(g2, E, { highlightCode: true }), w.message += `
` + w.codeFrame, w;
              }
              throw w;
            }
          }
          r.exports = { parse: h, resolveParser: y2 };
        } }), uo2 = te2({ "src/main/options.js"(e, r) {
          ne2();
          var t = ZD2(), { UndefinedParserError: s } = Qt2(), { getSupportInfo: a } = Xn2(), n = Om2(), { resolveParser: u } = tu2(), i = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
          function l(h) {
            let g2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, c = Object.assign({}, h), f = a({ plugins: h.plugins, showUnreleased: true, showDeprecated: true }).options, F = Object.assign(Object.assign({}, i), Object.fromEntries(f.filter((x) => x.default !== void 0).map((x) => [x.name, x.default])));
            if (!c.parser) {
              if (!c.filepath)
                (g2.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), c.parser = "babel";
              else if (c.parser = y2(c.filepath, c.plugins), !c.parser)
                throw new s(`No parser could be inferred for file: ${c.filepath}`);
            }
            let _ = u(n.normalizeApiOptions(c, [f.find((x) => x.name === "parser")], { passThrough: true, logger: false }));
            c.astFormat = _.astFormat, c.locEnd = _.locEnd, c.locStart = _.locStart;
            let w = p(c);
            c.printer = w.printers[c.astFormat];
            let E = Object.fromEntries(f.filter((x) => x.pluginDefaults && x.pluginDefaults[w.name] !== void 0).map((x) => [x.name, x.pluginDefaults[w.name]])), N2 = Object.assign(Object.assign({}, F), E);
            for (let [x, I2] of Object.entries(N2))
              (c[x] === null || c[x] === void 0) && (c[x] = I2);
            return c.parser === "json" && (c.trailingComma = "none"), n.normalizeApiOptions(c, f, Object.assign({ passThrough: Object.keys(i) }, g2));
          }
          function p(h) {
            let { astFormat: g2 } = h;
            if (!g2)
              throw new Error("getPlugin() requires astFormat to be set");
            let c = h.plugins.find((f) => f.printers && f.printers[g2]);
            if (!c)
              throw new Error(`Couldn't find plugin for AST format "${g2}"`);
            return c;
          }
          function y2(h, g2) {
            let c = t.basename(h).toLowerCase(), F = a({ plugins: g2 }).languages.filter((_) => _.since !== null).find((_) => _.extensions && _.extensions.some((w) => c.endsWith(w)) || _.filenames && _.filenames.some((w) => w.toLowerCase() === c));
            return F && F.parsers[0];
          }
          r.exports = { normalize: l, hiddenDefaults: i, inferParser: y2 };
        } }), Rm2 = te2({ "src/main/massage-ast.js"(e, r) {
          ne2();
          function t(s, a, n) {
            if (Array.isArray(s))
              return s.map((p) => t(p, a, n)).filter(Boolean);
            if (!s || typeof s != "object")
              return s;
            let u = a.printer.massageAstNode, i;
            u && u.ignoredProperties ? i = u.ignoredProperties : i = /* @__PURE__ */ new Set();
            let l = {};
            for (let [p, y2] of Object.entries(s))
              !i.has(p) && typeof y2 != "function" && (l[p] = t(y2, a, s));
            if (u) {
              let p = u(s, l, n);
              if (p === null)
                return;
              if (p)
                return p;
            }
            return l;
          }
          r.exports = t;
        } }), Zt2 = te2({ "scripts/build/shims/assert.cjs"(e, r) {
          ne2();
          var t = () => {
          };
          t.ok = t, t.strictEqual = t, r.exports = t;
        } }), et2 = te2({ "src/main/comments.js"(e, r) {
          ne2();
          var t = Zt2(), { builders: { line: s, hardline: a, breakParent: n, indent: u, lineSuffix: i, join: l, cursor: p } } = qe2(), { hasNewline: y2, skipNewline: h, skipSpaces: g2, isPreviousLineEmpty: c, addLeadingComment: f, addDanglingComment: F, addTrailingComment: _ } = Ue2(), w = /* @__PURE__ */ new WeakMap();
          function E(k, M2, R2) {
            if (!k)
              return;
            let { printer: q, locStart: J, locEnd: L } = M2;
            if (R2) {
              if (q.canAttachComment && q.canAttachComment(k)) {
                let V;
                for (V = R2.length - 1; V >= 0 && !(J(R2[V]) <= J(k) && L(R2[V]) <= L(k)); --V)
                  ;
                R2.splice(V + 1, 0, k);
                return;
              }
            } else if (w.has(k))
              return w.get(k);
            let Q = q.getCommentChildNodes && q.getCommentChildNodes(k, M2) || typeof k == "object" && Object.entries(k).filter((V) => {
              let [j] = V;
              return j !== "enclosingNode" && j !== "precedingNode" && j !== "followingNode" && j !== "tokens" && j !== "comments" && j !== "parent";
            }).map((V) => {
              let [, j] = V;
              return j;
            });
            if (Q) {
              R2 || (R2 = [], w.set(k, R2));
              for (let V of Q)
                E(V, M2, R2);
              return R2;
            }
          }
          function N2(k, M2, R2, q) {
            let { locStart: J, locEnd: L } = R2, Q = J(M2), V = L(M2), j = E(k, R2), Y, ie2, ee2 = 0, ce2 = j.length;
            for (; ee2 < ce2; ) {
              let W = ee2 + ce2 >> 1, K2 = j[W], de = J(K2), ue2 = L(K2);
              if (de <= Q && V <= ue2)
                return N2(K2, M2, R2, K2);
              if (ue2 <= Q) {
                Y = K2, ee2 = W + 1;
                continue;
              }
              if (V <= de) {
                ie2 = K2, ce2 = W;
                continue;
              }
              throw new Error("Comment location overlaps with node location");
            }
            if (q && q.type === "TemplateLiteral") {
              let { quasis: W } = q, K2 = C(W, M2, R2);
              Y && C(W, Y, R2) !== K2 && (Y = null), ie2 && C(W, ie2, R2) !== K2 && (ie2 = null);
            }
            return { enclosingNode: q, precedingNode: Y, followingNode: ie2 };
          }
          var x = () => false;
          function I2(k, M2, R2, q) {
            if (!Array.isArray(k))
              return;
            let J = [], { locStart: L, locEnd: Q, printer: { handleComments: V = {} } } = q, { avoidAstMutation: j, ownLine: Y = x, endOfLine: ie2 = x, remaining: ee2 = x } = V, ce2 = k.map((W, K2) => Object.assign(Object.assign({}, N2(M2, W, q)), {}, { comment: W, text: R2, options: q, ast: M2, isLastComment: k.length - 1 === K2 }));
            for (let [W, K2] of ce2.entries()) {
              let { comment: de, precedingNode: ue2, enclosingNode: Fe2, followingNode: z, text: U2, options: Z, ast: se2, isLastComment: fe2 } = K2;
              if (Z.parser === "json" || Z.parser === "json5" || Z.parser === "__js_expression" || Z.parser === "__vue_expression" || Z.parser === "__vue_ts_expression") {
                if (L(de) - L(se2) <= 0) {
                  f(se2, de);
                  continue;
                }
                if (Q(de) - Q(se2) >= 0) {
                  _(se2, de);
                  continue;
                }
              }
              let ge2;
              if (j ? ge2 = [K2] : (de.enclosingNode = Fe2, de.precedingNode = ue2, de.followingNode = z, ge2 = [de, U2, Z, se2, fe2]), $2(U2, Z, ce2, W))
                de.placement = "ownLine", Y(...ge2) || (z ? f(z, de) : ue2 ? _(ue2, de) : F(Fe2 || se2, de));
              else if (D(U2, Z, ce2, W))
                de.placement = "endOfLine", ie2(...ge2) || (ue2 ? _(ue2, de) : z ? f(z, de) : F(Fe2 || se2, de));
              else if (de.placement = "remaining", !ee2(...ge2))
                if (ue2 && z) {
                  let he2 = J.length;
                  he2 > 0 && J[he2 - 1].followingNode !== z && T(J, U2, Z), J.push(K2);
                } else
                  ue2 ? _(ue2, de) : z ? f(z, de) : F(Fe2 || se2, de);
            }
            if (T(J, R2, q), !j)
              for (let W of k)
                delete W.precedingNode, delete W.enclosingNode, delete W.followingNode;
          }
          var P = (k) => !/[\S\n\u2028\u2029]/.test(k);
          function $2(k, M2, R2, q) {
            let { comment: J, precedingNode: L } = R2[q], { locStart: Q, locEnd: V } = M2, j = Q(J);
            if (L)
              for (let Y = q - 1; Y >= 0; Y--) {
                let { comment: ie2, precedingNode: ee2 } = R2[Y];
                if (ee2 !== L || !P(k.slice(V(ie2), j)))
                  break;
                j = Q(ie2);
              }
            return y2(k, j, { backwards: true });
          }
          function D(k, M2, R2, q) {
            let { comment: J, followingNode: L } = R2[q], { locStart: Q, locEnd: V } = M2, j = V(J);
            if (L)
              for (let Y = q + 1; Y < R2.length; Y++) {
                let { comment: ie2, followingNode: ee2 } = R2[Y];
                if (ee2 !== L || !P(k.slice(j, Q(ie2))))
                  break;
                j = V(ie2);
              }
            return y2(k, j);
          }
          function T(k, M2, R2) {
            let q = k.length;
            if (q === 0)
              return;
            let { precedingNode: J, followingNode: L, enclosingNode: Q } = k[0], V = R2.printer.getGapRegex && R2.printer.getGapRegex(Q) || /^[\s(]*$/, j = R2.locStart(L), Y;
            for (Y = q; Y > 0; --Y) {
              let { comment: ie2, precedingNode: ee2, followingNode: ce2 } = k[Y - 1];
              t.strictEqual(ee2, J), t.strictEqual(ce2, L);
              let W = M2.slice(R2.locEnd(ie2), j);
              if (V.test(W))
                j = R2.locStart(ie2);
              else
                break;
            }
            for (let [ie2, { comment: ee2 }] of k.entries())
              ie2 < Y ? _(J, ee2) : f(L, ee2);
            for (let ie2 of [J, L])
              ie2.comments && ie2.comments.length > 1 && ie2.comments.sort((ee2, ce2) => R2.locStart(ee2) - R2.locStart(ce2));
            k.length = 0;
          }
          function m(k, M2) {
            let R2 = k.getValue();
            return R2.printed = true, M2.printer.printComment(k, M2);
          }
          function C(k, M2, R2) {
            let q = R2.locStart(M2) - 1;
            for (let J = 1; J < k.length; ++J)
              if (q < R2.locStart(k[J]))
                return J - 1;
            return 0;
          }
          function o(k, M2) {
            let R2 = k.getValue(), q = [m(k, M2)], { printer: J, originalText: L, locStart: Q, locEnd: V } = M2;
            if (J.isBlockComment && J.isBlockComment(R2)) {
              let ie2 = y2(L, V(R2)) ? y2(L, Q(R2), { backwards: true }) ? a : s : " ";
              q.push(ie2);
            } else
              q.push(a);
            let Y = h(L, g2(L, V(R2)));
            return Y !== false && y2(L, Y) && q.push(a), q;
          }
          function d2(k, M2) {
            let R2 = k.getValue(), q = m(k, M2), { printer: J, originalText: L, locStart: Q } = M2, V = J.isBlockComment && J.isBlockComment(R2);
            if (y2(L, Q(R2), { backwards: true })) {
              let Y = c(L, R2, Q);
              return i([a, Y ? a : "", q]);
            }
            let j = [" ", q];
            return V || (j = [i(j), n]), j;
          }
          function v2(k, M2, R2, q) {
            let J = [], L = k.getValue();
            return !L || !L.comments || (k.each(() => {
              let Q = k.getValue();
              !Q.leading && !Q.trailing && (!q || q(Q)) && J.push(m(k, M2));
            }, "comments"), J.length === 0) ? "" : R2 ? l(a, J) : u([a, l(a, J)]);
          }
          function S(k, M2, R2) {
            let q = k.getValue();
            if (!q)
              return {};
            let J = q.comments || [];
            R2 && (J = J.filter((j) => !R2.has(j)));
            let L = q === M2.cursorNode;
            if (J.length === 0) {
              let j = L ? p : "";
              return { leading: j, trailing: j };
            }
            let Q = [], V = [];
            return k.each(() => {
              let j = k.getValue();
              if (R2 && R2.has(j))
                return;
              let { leading: Y, trailing: ie2 } = j;
              Y ? Q.push(o(k, M2)) : ie2 && V.push(d2(k, M2));
            }, "comments"), L && (Q.unshift(p), V.push(p)), { leading: Q, trailing: V };
          }
          function b(k, M2, R2, q) {
            let { leading: J, trailing: L } = S(k, R2, q);
            return !J && !L ? M2 : [J, M2, L];
          }
          function B(k) {
            if (k)
              for (let M2 of k) {
                if (!M2.printed)
                  throw new Error('Comment "' + M2.value.trim() + '" was not printed. Please report this error!');
                delete M2.printed;
              }
          }
          r.exports = { attach: I2, printComments: b, printCommentsSeparately: S, printDanglingComments: v2, getSortedChildNodes: E, ensureAllCommentsPrinted: B };
        } }), $m2 = te2({ "src/common/ast-path.js"(e, r) {
          ne2();
          var t = lt2();
          function s(u, i) {
            let l = a(u.stack, i);
            return l === -1 ? null : u.stack[l];
          }
          function a(u, i) {
            for (let l = u.length - 1; l >= 0; l -= 2) {
              let p = u[l];
              if (p && !Array.isArray(p) && --i < 0)
                return l;
            }
            return -1;
          }
          var n = class {
            constructor(u) {
              this.stack = [u];
            }
            getName() {
              let { stack: u } = this, { length: i } = u;
              return i > 1 ? u[i - 2] : null;
            }
            getValue() {
              return t(this.stack);
            }
            getNode() {
              let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              return s(this, u);
            }
            getParentNode() {
              let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              return s(this, u + 1);
            }
            call(u) {
              let { stack: i } = this, { length: l } = i, p = t(i);
              for (var y2 = arguments.length, h = new Array(y2 > 1 ? y2 - 1 : 0), g2 = 1; g2 < y2; g2++)
                h[g2 - 1] = arguments[g2];
              for (let f of h)
                p = p[f], i.push(f, p);
              let c = u(this);
              return i.length = l, c;
            }
            callParent(u) {
              let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, l = a(this.stack, i + 1), p = this.stack.splice(l + 1), y2 = u(this);
              return this.stack.push(...p), y2;
            }
            each(u) {
              let { stack: i } = this, { length: l } = i, p = t(i);
              for (var y2 = arguments.length, h = new Array(y2 > 1 ? y2 - 1 : 0), g2 = 1; g2 < y2; g2++)
                h[g2 - 1] = arguments[g2];
              for (let c of h)
                p = p[c], i.push(c, p);
              for (let c = 0; c < p.length; ++c)
                i.push(c, p[c]), u(this, c, p), i.length -= 2;
              i.length = l;
            }
            map(u) {
              let i = [];
              for (var l = arguments.length, p = new Array(l > 1 ? l - 1 : 0), y2 = 1; y2 < l; y2++)
                p[y2 - 1] = arguments[y2];
              return this.each((h, g2, c) => {
                i[g2] = u(h, g2, c);
              }, ...p), i;
            }
            try(u) {
              let { stack: i } = this, l = [...i];
              try {
                return u();
              } finally {
                i.length = 0, i.push(...l);
              }
            }
            match() {
              let u = this.stack.length - 1, i = null, l = this.stack[u--];
              for (var p = arguments.length, y2 = new Array(p), h = 0; h < p; h++)
                y2[h] = arguments[h];
              for (let g2 of y2) {
                if (l === void 0)
                  return false;
                let c = null;
                if (typeof i == "number" && (c = i, i = this.stack[u--], l = this.stack[u--]), g2 && !g2(l, i, c))
                  return false;
                i = this.stack[u--], l = this.stack[u--];
              }
              return true;
            }
            findAncestor(u) {
              let i = this.stack.length - 1, l = null, p = this.stack[i--];
              for (; p; ) {
                let y2 = null;
                if (typeof l == "number" && (y2 = l, l = this.stack[i--], p = this.stack[i--]), l !== null && u(p, l, y2))
                  return p;
                l = this.stack[i--], p = this.stack[i--];
              }
            }
          };
          r.exports = n;
        } }), Vm2 = te2({ "src/main/multiparser.js"(e, r) {
          ne2();
          var { utils: { stripTrailingHardline: t } } = qe2(), { normalize: s } = uo2(), a = et2();
          function n(i, l, p, y2) {
            if (p.printer.embed && p.embeddedLanguageFormatting === "auto")
              return p.printer.embed(i, l, (h, g2, c) => u(h, g2, p, y2, c), p);
          }
          function u(i, l, p, y2) {
            let { stripTrailingHardline: h = false } = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {}, g2 = s(Object.assign(Object.assign(Object.assign({}, p), l), {}, { parentParser: p.parser, originalText: i }), { passThrough: true }), c = tu2().parse(i, g2), { ast: f } = c;
            i = c.text;
            let F = f.comments;
            delete f.comments, a.attach(F, f, i, g2), g2[Symbol.for("comments")] = F || [], g2[Symbol.for("tokens")] = f.tokens || [];
            let _ = y2(f, g2);
            return a.ensureAllCommentsPrinted(F), h ? typeof _ == "string" ? _.replace(/(?:\r?\n)*$/, "") : t(_) : _;
          }
          r.exports = { printSubtree: n };
        } }), Wm2 = te2({ "src/main/ast-to-doc.js"(e, r) {
          ne2();
          var t = $m2(), { builders: { hardline: s, addAlignmentToDoc: a }, utils: { propagateBreaks: n } } = qe2(), { printComments: u } = et2(), i = Vm2();
          function l(h, g2) {
            let c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, { printer: f } = g2;
            f.preprocess && (h = f.preprocess(h, g2));
            let F = /* @__PURE__ */ new Map(), _ = new t(h), w = E();
            return c > 0 && (w = a([s, w], c, g2.tabWidth)), n(w), w;
            function E(x, I2) {
              return x === void 0 || x === _ ? N2(I2) : Array.isArray(x) ? _.call(() => N2(I2), ...x) : _.call(() => N2(I2), x);
            }
            function N2(x) {
              let I2 = _.getValue(), P = I2 && typeof I2 == "object" && x === void 0;
              if (P && F.has(I2))
                return F.get(I2);
              let $2 = y2(_, g2, E, x);
              return P && F.set(I2, $2), $2;
            }
          }
          function p(h, g2) {
            let { originalText: c, [Symbol.for("comments")]: f, locStart: F, locEnd: _ } = g2, w = F(h), E = _(h), N2 = /* @__PURE__ */ new Set();
            for (let x of f)
              F(x) >= w && _(x) <= E && (x.printed = true, N2.add(x));
            return { doc: c.slice(w, E), printedComments: N2 };
          }
          function y2(h, g2, c, f) {
            let F = h.getValue(), { printer: _ } = g2, w, E;
            if (_.hasPrettierIgnore && _.hasPrettierIgnore(h))
              ({ doc: w, printedComments: E } = p(F, g2));
            else {
              if (F)
                try {
                  w = i.printSubtree(h, c, g2, l);
                } catch (N2) {
                  if (globalThis.PRETTIER_DEBUG)
                    throw N2;
                }
              w || (w = _.print(h, g2, c, f));
            }
            return (!_.willPrintOwnComments || !_.willPrintOwnComments(h, g2)) && (w = u(h, w, g2, E)), w;
          }
          r.exports = l;
        } }), Hm2 = te2({ "src/main/range-util.js"(e, r) {
          ne2();
          var t = Zt2(), s = et2(), a = (f) => {
            let { parser: F } = f;
            return F === "json" || F === "json5" || F === "json-stringify";
          };
          function n(f, F) {
            let _ = [f.node, ...f.parentNodes], w = /* @__PURE__ */ new Set([F.node, ...F.parentNodes]);
            return _.find((E) => y2.has(E.type) && w.has(E));
          }
          function u(f) {
            let F = f.length - 1;
            for (; ; ) {
              let _ = f[F];
              if (_ && (_.type === "Program" || _.type === "File"))
                F--;
              else
                break;
            }
            return f.slice(0, F + 1);
          }
          function i(f, F, _) {
            let { locStart: w, locEnd: E } = _, N2 = f.node, x = F.node;
            if (N2 === x)
              return { startNode: N2, endNode: x };
            let I2 = w(f.node);
            for (let $2 of u(F.parentNodes))
              if (w($2) >= I2)
                x = $2;
              else
                break;
            let P = E(F.node);
            for (let $2 of u(f.parentNodes)) {
              if (E($2) <= P)
                N2 = $2;
              else
                break;
              if (N2 === x)
                break;
            }
            return { startNode: N2, endNode: x };
          }
          function l(f, F, _, w) {
            let E = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], N2 = arguments.length > 5 ? arguments[5] : void 0, { locStart: x, locEnd: I2 } = _, P = x(f), $2 = I2(f);
            if (!(F > $2 || F < P || N2 === "rangeEnd" && F === P || N2 === "rangeStart" && F === $2)) {
              for (let D of s.getSortedChildNodes(f, _)) {
                let T = l(D, F, _, w, [f, ...E], N2);
                if (T)
                  return T;
              }
              if (!w || w(f, E[0]))
                return { node: f, parentNodes: E };
            }
          }
          function p(f, F) {
            return F !== "DeclareExportDeclaration" && f !== "TypeParameterDeclaration" && (f === "Directive" || f === "TypeAlias" || f === "TSExportAssignment" || f.startsWith("Declare") || f.startsWith("TSDeclare") || f.endsWith("Statement") || f.endsWith("Declaration"));
          }
          var y2 = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), h = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
          function g2(f, F, _) {
            if (!F)
              return false;
            switch (f.parser) {
              case "flow":
              case "babel":
              case "babel-flow":
              case "babel-ts":
              case "typescript":
              case "acorn":
              case "espree":
              case "meriyah":
              case "__babel_estree":
                return p(F.type, _ && _.type);
              case "json":
              case "json5":
              case "json-stringify":
                return y2.has(F.type);
              case "graphql":
                return h.has(F.kind);
              case "vue":
                return F.tag !== "root";
            }
            return false;
          }
          function c(f, F, _) {
            let { rangeStart: w, rangeEnd: E, locStart: N2, locEnd: x } = F;
            t.ok(E > w);
            let I2 = f.slice(w, E).search(/\S/), P = I2 === -1;
            if (!P)
              for (w += I2; E > w && !/\S/.test(f[E - 1]); --E)
                ;
            let $2 = l(_, w, F, (C, o) => g2(F, C, o), [], "rangeStart"), D = P ? $2 : l(_, E, F, (C) => g2(F, C), [], "rangeEnd");
            if (!$2 || !D)
              return { rangeStart: 0, rangeEnd: 0 };
            let T, m;
            if (a(F)) {
              let C = n($2, D);
              T = C, m = C;
            } else
              ({ startNode: T, endNode: m } = i($2, D, F));
            return { rangeStart: Math.min(N2(T), N2(m)), rangeEnd: Math.max(x(T), x(m)) };
          }
          r.exports = { calculateRange: c, findNodeAtOffset: l };
        } }), Gm2 = te2({ "src/main/core.js"(e, r) {
          ne2();
          var { diffArrays: t } = BD2(), { printer: { printDocToString: s }, debug: { printDocToDebug: a } } = qe2(), { getAlignmentSize: n } = Ue2(), { guessEndOfLine: u, convertEndOfLineToChars: i, countEndOfLineChars: l, normalizeEndOfLine: p } = Jn2(), y2 = uo2().normalize, h = Rm2(), g2 = et2(), c = tu2(), f = Wm2(), F = Hm2(), _ = "\uFEFF", w = Symbol("cursor");
          function E(m, C, o) {
            let d2 = C.comments;
            return d2 && (delete C.comments, g2.attach(d2, C, m, o)), o[Symbol.for("comments")] = d2 || [], o[Symbol.for("tokens")] = C.tokens || [], o.originalText = m, d2;
          }
          function N2(m, C) {
            let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            if (!m || m.trim().length === 0)
              return { formatted: "", cursorOffset: -1, comments: [] };
            let { ast: d2, text: v2 } = c.parse(m, C);
            if (C.cursorOffset >= 0) {
              let k = F.findNodeAtOffset(d2, C.cursorOffset, C);
              k && k.node && (C.cursorNode = k.node);
            }
            let S = E(v2, d2, C), b = f(d2, C, o), B = s(b, C);
            if (g2.ensureAllCommentsPrinted(S), o > 0) {
              let k = B.formatted.trim();
              B.cursorNodeStart !== void 0 && (B.cursorNodeStart -= B.formatted.indexOf(k)), B.formatted = k + i(C.endOfLine);
            }
            if (C.cursorOffset >= 0) {
              let k, M2, R2, q, J;
              if (C.cursorNode && B.cursorNodeText ? (k = C.locStart(C.cursorNode), M2 = v2.slice(k, C.locEnd(C.cursorNode)), R2 = C.cursorOffset - k, q = B.cursorNodeStart, J = B.cursorNodeText) : (k = 0, M2 = v2, R2 = C.cursorOffset, q = 0, J = B.formatted), M2 === J)
                return { formatted: B.formatted, cursorOffset: q + R2, comments: S };
              let L = [...M2];
              L.splice(R2, 0, w);
              let Q = [...J], V = t(L, Q), j = q;
              for (let Y of V)
                if (Y.removed) {
                  if (Y.value.includes(w))
                    break;
                } else
                  j += Y.count;
              return { formatted: B.formatted, cursorOffset: j, comments: S };
            }
            return { formatted: B.formatted, cursorOffset: -1, comments: S };
          }
          function x(m, C) {
            let { ast: o, text: d2 } = c.parse(m, C), { rangeStart: v2, rangeEnd: S } = F.calculateRange(d2, C, o), b = d2.slice(v2, S), B = Math.min(v2, d2.lastIndexOf(`
`, v2) + 1), k = d2.slice(B, v2).match(/^\s*/)[0], M2 = n(k, C.tabWidth), R2 = N2(b, Object.assign(Object.assign({}, C), {}, { rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: C.cursorOffset > v2 && C.cursorOffset <= S ? C.cursorOffset - v2 : -1, endOfLine: "lf" }), M2), q = R2.formatted.trimEnd(), { cursorOffset: J } = C;
            J > S ? J += q.length - b.length : R2.cursorOffset >= 0 && (J = R2.cursorOffset + v2);
            let L = d2.slice(0, v2) + q + d2.slice(S);
            if (C.endOfLine !== "lf") {
              let Q = i(C.endOfLine);
              J >= 0 && Q === `\r
` && (J += l(L.slice(0, J), `
`)), L = L.replace(/\n/g, Q);
            }
            return { formatted: L, cursorOffset: J, comments: R2.comments };
          }
          function I2(m, C, o) {
            return typeof C != "number" || Number.isNaN(C) || C < 0 || C > m.length ? o : C;
          }
          function P(m, C) {
            let { cursorOffset: o, rangeStart: d2, rangeEnd: v2 } = C;
            return o = I2(m, o, -1), d2 = I2(m, d2, 0), v2 = I2(m, v2, m.length), Object.assign(Object.assign({}, C), {}, { cursorOffset: o, rangeStart: d2, rangeEnd: v2 });
          }
          function $2(m, C) {
            let { cursorOffset: o, rangeStart: d2, rangeEnd: v2, endOfLine: S } = P(m, C), b = m.charAt(0) === _;
            if (b && (m = m.slice(1), o--, d2--, v2--), S === "auto" && (S = u(m)), m.includes("\r")) {
              let B = (k) => l(m.slice(0, Math.max(k, 0)), `\r
`);
              o -= B(o), d2 -= B(d2), v2 -= B(v2), m = p(m);
            }
            return { hasBOM: b, text: m, options: P(m, Object.assign(Object.assign({}, C), {}, { cursorOffset: o, rangeStart: d2, rangeEnd: v2, endOfLine: S })) };
          }
          function D(m, C) {
            let o = c.resolveParser(C);
            return !o.hasPragma || o.hasPragma(m);
          }
          function T(m, C) {
            let { hasBOM: o, text: d2, options: v2 } = $2(m, y2(C));
            if (v2.rangeStart >= v2.rangeEnd && d2 !== "" || v2.requirePragma && !D(d2, v2))
              return { formatted: m, cursorOffset: C.cursorOffset, comments: [] };
            let S;
            return v2.rangeStart > 0 || v2.rangeEnd < d2.length ? S = x(d2, v2) : (!v2.requirePragma && v2.insertPragma && v2.printer.insertPragma && !D(d2, v2) && (d2 = v2.printer.insertPragma(d2)), S = N2(d2, v2)), o && (S.formatted = _ + S.formatted, S.cursorOffset >= 0 && S.cursorOffset++), S;
          }
          r.exports = { formatWithCursor: T, parse(m, C, o) {
            let { text: d2, options: v2 } = $2(m, y2(C)), S = c.parse(d2, v2);
            return o && (S.ast = h(S.ast, v2)), S;
          }, formatAST(m, C) {
            C = y2(C);
            let o = f(m, C);
            return s(o, C);
          }, formatDoc(m, C) {
            return T(a(m), Object.assign(Object.assign({}, C), {}, { parser: "__js_expression" })).formatted;
          }, printToDoc(m, C) {
            C = y2(C);
            let { ast: o, text: d2 } = c.parse(m, C);
            return E(d2, o, C), f(o, C);
          }, printDocToString(m, C) {
            return s(m, y2(C));
          } };
        } }), Um2 = te2({ "src/common/util-shared.js"(e, r) {
          ne2();
          var { getMaxContinuousCount: t, getStringWidth: s, getAlignmentSize: a, getIndentSize: n, skip: u, skipWhitespace: i, skipSpaces: l, skipNewline: p, skipToLineEnd: y2, skipEverythingButNewLine: h, skipInlineComment: g2, skipTrailingComment: c, hasNewline: f, hasNewlineInRange: F, hasSpaces: _, isNextLineEmpty: w, isNextLineEmptyAfterIndex: E, isPreviousLineEmpty: N2, getNextNonSpaceNonCommentCharacterIndex: x, makeString: I2, addLeadingComment: P, addDanglingComment: $2, addTrailingComment: D } = Ue2();
          r.exports = { getMaxContinuousCount: t, getStringWidth: s, getAlignmentSize: a, getIndentSize: n, skip: u, skipWhitespace: i, skipSpaces: l, skipNewline: p, skipToLineEnd: y2, skipEverythingButNewLine: h, skipInlineComment: g2, skipTrailingComment: c, hasNewline: f, hasNewlineInRange: F, hasSpaces: _, isNextLineEmpty: w, isNextLineEmptyAfterIndex: E, isPreviousLineEmpty: N2, getNextNonSpaceNonCommentCharacterIndex: x, makeString: I2, addLeadingComment: P, addDanglingComment: $2, addTrailingComment: D };
        } }), _t2 = te2({ "src/utils/create-language.js"(e, r) {
          ne2(), r.exports = function(t, s) {
            let { languageId: a } = t, n = Hn2(t, CD2);
            return Object.assign(Object.assign({ linguistLanguageId: a }, n), s(t));
          };
        } }), Jm2 = te2({ "node_modules/esutils/lib/ast.js"(e, r) {
          ne2(), function() {
            function t(l) {
              if (l == null)
                return false;
              switch (l.type) {
                case "ArrayExpression":
                case "AssignmentExpression":
                case "BinaryExpression":
                case "CallExpression":
                case "ConditionalExpression":
                case "FunctionExpression":
                case "Identifier":
                case "Literal":
                case "LogicalExpression":
                case "MemberExpression":
                case "NewExpression":
                case "ObjectExpression":
                case "SequenceExpression":
                case "ThisExpression":
                case "UnaryExpression":
                case "UpdateExpression":
                  return true;
              }
              return false;
            }
            function s(l) {
              if (l == null)
                return false;
              switch (l.type) {
                case "DoWhileStatement":
                case "ForInStatement":
                case "ForStatement":
                case "WhileStatement":
                  return true;
              }
              return false;
            }
            function a(l) {
              if (l == null)
                return false;
              switch (l.type) {
                case "BlockStatement":
                case "BreakStatement":
                case "ContinueStatement":
                case "DebuggerStatement":
                case "DoWhileStatement":
                case "EmptyStatement":
                case "ExpressionStatement":
                case "ForInStatement":
                case "ForStatement":
                case "IfStatement":
                case "LabeledStatement":
                case "ReturnStatement":
                case "SwitchStatement":
                case "ThrowStatement":
                case "TryStatement":
                case "VariableDeclaration":
                case "WhileStatement":
                case "WithStatement":
                  return true;
              }
              return false;
            }
            function n(l) {
              return a(l) || l != null && l.type === "FunctionDeclaration";
            }
            function u(l) {
              switch (l.type) {
                case "IfStatement":
                  return l.alternate != null ? l.alternate : l.consequent;
                case "LabeledStatement":
                case "ForStatement":
                case "ForInStatement":
                case "WhileStatement":
                case "WithStatement":
                  return l.body;
              }
              return null;
            }
            function i(l) {
              var p;
              if (l.type !== "IfStatement" || l.alternate == null)
                return false;
              p = l.consequent;
              do {
                if (p.type === "IfStatement" && p.alternate == null)
                  return true;
                p = u(p);
              } while (p);
              return false;
            }
            r.exports = { isExpression: t, isStatement: a, isIterationStatement: s, isSourceElement: n, isProblematicIfStatement: i, trailingStatement: u };
          }();
        } }), so2 = te2({ "node_modules/esutils/lib/code.js"(e, r) {
          ne2(), function() {
            var t, s, a, n, u, i;
            s = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, t = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ };
            function l(E) {
              return 48 <= E && E <= 57;
            }
            function p(E) {
              return 48 <= E && E <= 57 || 97 <= E && E <= 102 || 65 <= E && E <= 70;
            }
            function y2(E) {
              return E >= 48 && E <= 55;
            }
            a = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279];
            function h(E) {
              return E === 32 || E === 9 || E === 11 || E === 12 || E === 160 || E >= 5760 && a.indexOf(E) >= 0;
            }
            function g2(E) {
              return E === 10 || E === 13 || E === 8232 || E === 8233;
            }
            function c(E) {
              if (E <= 65535)
                return String.fromCharCode(E);
              var N2 = String.fromCharCode(Math.floor((E - 65536) / 1024) + 55296), x = String.fromCharCode((E - 65536) % 1024 + 56320);
              return N2 + x;
            }
            for (n = new Array(128), i = 0; i < 128; ++i)
              n[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i === 36 || i === 95;
            for (u = new Array(128), i = 0; i < 128; ++i)
              u[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i >= 48 && i <= 57 || i === 36 || i === 95;
            function f(E) {
              return E < 128 ? n[E] : s.NonAsciiIdentifierStart.test(c(E));
            }
            function F(E) {
              return E < 128 ? u[E] : s.NonAsciiIdentifierPart.test(c(E));
            }
            function _(E) {
              return E < 128 ? n[E] : t.NonAsciiIdentifierStart.test(c(E));
            }
            function w(E) {
              return E < 128 ? u[E] : t.NonAsciiIdentifierPart.test(c(E));
            }
            r.exports = { isDecimalDigit: l, isHexDigit: p, isOctalDigit: y2, isWhiteSpace: h, isLineTerminator: g2, isIdentifierStartES5: f, isIdentifierPartES5: F, isIdentifierStartES6: _, isIdentifierPartES6: w };
          }();
        } }), zm2 = te2({ "node_modules/esutils/lib/keyword.js"(e, r) {
          ne2(), function() {
            var t = so2();
            function s(f) {
              switch (f) {
                case "implements":
                case "interface":
                case "package":
                case "private":
                case "protected":
                case "public":
                case "static":
                case "let":
                  return true;
                default:
                  return false;
              }
            }
            function a(f, F) {
              return !F && f === "yield" ? false : n(f, F);
            }
            function n(f, F) {
              if (F && s(f))
                return true;
              switch (f.length) {
                case 2:
                  return f === "if" || f === "in" || f === "do";
                case 3:
                  return f === "var" || f === "for" || f === "new" || f === "try";
                case 4:
                  return f === "this" || f === "else" || f === "case" || f === "void" || f === "with" || f === "enum";
                case 5:
                  return f === "while" || f === "break" || f === "catch" || f === "throw" || f === "const" || f === "yield" || f === "class" || f === "super";
                case 6:
                  return f === "return" || f === "typeof" || f === "delete" || f === "switch" || f === "export" || f === "import";
                case 7:
                  return f === "default" || f === "finally" || f === "extends";
                case 8:
                  return f === "function" || f === "continue" || f === "debugger";
                case 10:
                  return f === "instanceof";
                default:
                  return false;
              }
            }
            function u(f, F) {
              return f === "null" || f === "true" || f === "false" || a(f, F);
            }
            function i(f, F) {
              return f === "null" || f === "true" || f === "false" || n(f, F);
            }
            function l(f) {
              return f === "eval" || f === "arguments";
            }
            function p(f) {
              var F, _, w;
              if (f.length === 0 || (w = f.charCodeAt(0), !t.isIdentifierStartES5(w)))
                return false;
              for (F = 1, _ = f.length; F < _; ++F)
                if (w = f.charCodeAt(F), !t.isIdentifierPartES5(w))
                  return false;
              return true;
            }
            function y2(f, F) {
              return (f - 55296) * 1024 + (F - 56320) + 65536;
            }
            function h(f) {
              var F, _, w, E, N2;
              if (f.length === 0)
                return false;
              for (N2 = t.isIdentifierStartES6, F = 0, _ = f.length; F < _; ++F) {
                if (w = f.charCodeAt(F), 55296 <= w && w <= 56319) {
                  if (++F, F >= _ || (E = f.charCodeAt(F), !(56320 <= E && E <= 57343)))
                    return false;
                  w = y2(w, E);
                }
                if (!N2(w))
                  return false;
                N2 = t.isIdentifierPartES6;
              }
              return true;
            }
            function g2(f, F) {
              return p(f) && !u(f, F);
            }
            function c(f, F) {
              return h(f) && !i(f, F);
            }
            r.exports = { isKeywordES5: a, isKeywordES6: n, isReservedWordES5: u, isReservedWordES6: i, isRestrictedWord: l, isIdentifierNameES5: p, isIdentifierNameES6: h, isIdentifierES5: g2, isIdentifierES6: c };
          }();
        } }), Xm2 = te2({ "node_modules/esutils/lib/utils.js"(e) {
          ne2(), function() {
            e.ast = Jm2(), e.code = so2(), e.keyword = zm2();
          }();
        } }), Pt2 = te2({ "src/language-js/utils/is-block-comment.js"(e, r) {
          ne2();
          var t = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]), s = (a) => t.has(a == null ? void 0 : a.type);
          r.exports = s;
        } }), Km2 = te2({ "src/language-js/utils/is-node-matches.js"(e, r) {
          ne2();
          function t(a, n) {
            let u = n.split(".");
            for (let i = u.length - 1; i >= 0; i--) {
              let l = u[i];
              if (i === 0)
                return a.type === "Identifier" && a.name === l;
              if (a.type !== "MemberExpression" || a.optional || a.computed || a.property.type !== "Identifier" || a.property.name !== l)
                return false;
              a = a.object;
            }
          }
          function s(a, n) {
            return n.some((u) => t(a, u));
          }
          r.exports = s;
        } }), Ke2 = te2({ "src/language-js/utils/index.js"(e, r) {
          ne2();
          var t = Xm2().keyword.isIdentifierNameES5, { getLast: s, hasNewline: a, skipWhitespace: n, isNonEmptyArray: u, isNextLineEmptyAfterIndex: i, getStringWidth: l } = Ue2(), { locStart: p, locEnd: y2, hasSameLocStart: h } = ut2(), g2 = Pt2(), c = Km2(), f = "(?:(?=.)\\s)", F = new RegExp(`^${f}*:`), _ = new RegExp(`^${f}*::`);
          function w(O) {
            var me2, _e2;
            return ((me2 = O.extra) === null || me2 === void 0 ? void 0 : me2.parenthesized) && g2((_e2 = O.trailingComments) === null || _e2 === void 0 ? void 0 : _e2[0]) && F.test(O.trailingComments[0].value);
          }
          function E(O) {
            let me2 = O == null ? void 0 : O[0];
            return g2(me2) && _.test(me2.value);
          }
          function N2(O, me2) {
            if (!O || typeof O != "object")
              return false;
            if (Array.isArray(O))
              return O.some((He2) => N2(He2, me2));
            let _e2 = me2(O);
            return typeof _e2 == "boolean" ? _e2 : Object.values(O).some((He2) => N2(He2, me2));
          }
          function x(O) {
            return O.type === "AssignmentExpression" || O.type === "BinaryExpression" || O.type === "LogicalExpression" || O.type === "NGPipeExpression" || O.type === "ConditionalExpression" || de(O) || ue2(O) || O.type === "SequenceExpression" || O.type === "TaggedTemplateExpression" || O.type === "BindExpression" || O.type === "UpdateExpression" && !O.prefix || st2(O) || O.type === "TSNonNullExpression";
          }
          function I2(O) {
            var me2, _e2, He2, Ge2, it2, Qe;
            return O.expressions ? O.expressions[0] : (me2 = (_e2 = (He2 = (Ge2 = (it2 = (Qe = O.left) !== null && Qe !== void 0 ? Qe : O.test) !== null && it2 !== void 0 ? it2 : O.callee) !== null && Ge2 !== void 0 ? Ge2 : O.object) !== null && He2 !== void 0 ? He2 : O.tag) !== null && _e2 !== void 0 ? _e2 : O.argument) !== null && me2 !== void 0 ? me2 : O.expression;
          }
          function P(O, me2) {
            if (me2.expressions)
              return ["expressions", 0];
            if (me2.left)
              return ["left"];
            if (me2.test)
              return ["test"];
            if (me2.object)
              return ["object"];
            if (me2.callee)
              return ["callee"];
            if (me2.tag)
              return ["tag"];
            if (me2.argument)
              return ["argument"];
            if (me2.expression)
              return ["expression"];
            throw new Error("Unexpected node has no left side.");
          }
          function $2(O) {
            return O = new Set(O), (me2) => O.has(me2 == null ? void 0 : me2.type);
          }
          var D = $2(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose"]), T = $2(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
          function m(O) {
            let me2 = O.getParentNode();
            return O.getName() === "declaration" && T(me2) ? me2 : null;
          }
          var C = $2(["BooleanLiteral", "DirectiveLiteral", "Literal", "NullLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "RegExpLiteral", "StringLiteral", "TemplateLiteral", "TSTypeLiteral", "JSXText"]);
          function o(O) {
            return O.type === "NumericLiteral" || O.type === "Literal" && typeof O.value == "number";
          }
          function d2(O) {
            return O.type === "UnaryExpression" && (O.operator === "+" || O.operator === "-") && o(O.argument);
          }
          function v2(O) {
            return O.type === "StringLiteral" || O.type === "Literal" && typeof O.value == "string";
          }
          var S = $2(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]), b = $2(["FunctionExpression", "ArrowFunctionExpression"]);
          function B(O) {
            return O.type === "FunctionExpression" || O.type === "ArrowFunctionExpression" && O.body.type === "BlockStatement";
          }
          function k(O) {
            return de(O) && O.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(O.callee.name);
          }
          var M2 = $2(["JSXElement", "JSXFragment"]);
          function R2(O, me2) {
            if (O.parentParser !== "markdown" && O.parentParser !== "mdx")
              return false;
            let _e2 = me2.getNode();
            if (!_e2.expression || !M2(_e2.expression))
              return false;
            let He2 = me2.getParentNode();
            return He2.type === "Program" && He2.body.length === 1;
          }
          function q(O) {
            return O.kind === "get" || O.kind === "set";
          }
          function J(O) {
            return q(O) || h(O, O.value);
          }
          function L(O) {
            return (O.type === "ObjectTypeProperty" || O.type === "ObjectTypeInternalSlot") && O.value.type === "FunctionTypeAnnotation" && !O.static && !J(O);
          }
          function Q(O) {
            return (O.type === "TypeAnnotation" || O.type === "TSTypeAnnotation") && O.typeAnnotation.type === "FunctionTypeAnnotation" && !O.static && !h(O, O.typeAnnotation);
          }
          var V = $2(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
          function j(O) {
            return ue2(O) || O.type === "BindExpression" && Boolean(O.object);
          }
          var Y = /* @__PURE__ */ new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
          function ie2(O) {
            return O ? !!((O.type === "GenericTypeAnnotation" || O.type === "TSTypeReference") && !O.typeParameters || Y.has(O.type)) : false;
          }
          function ee2(O) {
            let me2 = /^(?:before|after)(?:Each|All)$/;
            return O.callee.type === "Identifier" && me2.test(O.callee.name) && O.arguments.length === 1;
          }
          var ce2 = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
          function W(O) {
            return c(O, ce2);
          }
          function K2(O, me2) {
            if (O.type !== "CallExpression")
              return false;
            if (O.arguments.length === 1) {
              if (k(O) && me2 && K2(me2))
                return b(O.arguments[0]);
              if (ee2(O))
                return k(O.arguments[0]);
            } else if ((O.arguments.length === 2 || O.arguments.length === 3) && (O.arguments[0].type === "TemplateLiteral" || v2(O.arguments[0])) && W(O.callee))
              return O.arguments[2] && !o(O.arguments[2]) ? false : (O.arguments.length === 2 ? b(O.arguments[1]) : B(O.arguments[1]) && ve2(O.arguments[1]).length <= 1) || k(O.arguments[1]);
            return false;
          }
          var de = $2(["CallExpression", "OptionalCallExpression"]), ue2 = $2(["MemberExpression", "OptionalMemberExpression"]);
          function Fe2(O) {
            let me2 = "expressions";
            O.type === "TSTemplateLiteralType" && (me2 = "types");
            let _e2 = O[me2];
            return _e2.length === 0 ? false : _e2.every((He2) => {
              if (Me2(He2))
                return false;
              if (He2.type === "Identifier" || He2.type === "ThisExpression")
                return true;
              if (ue2(He2)) {
                let Ge2 = He2;
                for (; ue2(Ge2); )
                  if (Ge2.property.type !== "Identifier" && Ge2.property.type !== "Literal" && Ge2.property.type !== "StringLiteral" && Ge2.property.type !== "NumericLiteral" || (Ge2 = Ge2.object, Me2(Ge2)))
                    return false;
                return Ge2.type === "Identifier" || Ge2.type === "ThisExpression";
              }
              return false;
            });
          }
          function z(O, me2) {
            return O === "+" || O === "-" ? O + me2 : me2;
          }
          function U2(O, me2) {
            let _e2 = p(me2), He2 = n(O, y2(me2));
            return He2 !== false && O.slice(_e2, _e2 + 2) === "/*" && O.slice(He2, He2 + 2) === "*/";
          }
          function Z(O, me2) {
            return M2(me2) ? Oe2(me2) : Me2(me2, Te2.Leading, (_e2) => a(O, y2(_e2)));
          }
          function se2(O, me2) {
            return me2.parser !== "json" && v2(O.key) && oe(O.key).slice(1, -1) === O.key.value && (t(O.key.value) && !(me2.parser === "babel-ts" && O.type === "ClassProperty" || me2.parser === "typescript" && O.type === "PropertyDefinition") || fe2(O.key.value) && String(Number(O.key.value)) === O.key.value && (me2.parser === "babel" || me2.parser === "acorn" || me2.parser === "espree" || me2.parser === "meriyah" || me2.parser === "__babel_estree"));
          }
          function fe2(O) {
            return /^(?:\d+|\d+\.\d+)$/.test(O);
          }
          function ge2(O, me2) {
            let _e2 = /^[fx]?(?:describe|it|test)$/;
            return me2.type === "TaggedTemplateExpression" && me2.quasi === O && me2.tag.type === "MemberExpression" && me2.tag.property.type === "Identifier" && me2.tag.property.name === "each" && (me2.tag.object.type === "Identifier" && _e2.test(me2.tag.object.name) || me2.tag.object.type === "MemberExpression" && me2.tag.object.property.type === "Identifier" && (me2.tag.object.property.name === "only" || me2.tag.object.property.name === "skip") && me2.tag.object.object.type === "Identifier" && _e2.test(me2.tag.object.object.name));
          }
          function he2(O) {
            return O.quasis.some((me2) => me2.value.raw.includes(`
`));
          }
          function we2(O, me2) {
            return (O.type === "TemplateLiteral" && he2(O) || O.type === "TaggedTemplateExpression" && he2(O.quasi)) && !a(me2, p(O), { backwards: true });
          }
          function ke2(O) {
            if (!Me2(O))
              return false;
            let me2 = s(ae2(O, Te2.Dangling));
            return me2 && !g2(me2);
          }
          function Re2(O) {
            if (O.length <= 1)
              return false;
            let me2 = 0;
            for (let _e2 of O)
              if (b(_e2)) {
                if (me2 += 1, me2 > 1)
                  return true;
              } else if (de(_e2)) {
                for (let He2 of _e2.arguments)
                  if (b(He2))
                    return true;
              }
            return false;
          }
          function Ne2(O) {
            let me2 = O.getValue(), _e2 = O.getParentNode();
            return de(me2) && de(_e2) && _e2.callee === me2 && me2.arguments.length > _e2.arguments.length && _e2.arguments.length > 0;
          }
          function Pe2(O, me2) {
            if (me2 >= 2)
              return false;
            let _e2 = (Qe) => Pe2(Qe, me2 + 1), He2 = O.type === "Literal" && "regex" in O && O.regex.pattern || O.type === "RegExpLiteral" && O.pattern;
            if (He2 && l(He2) > 5)
              return false;
            if (O.type === "Literal" || O.type === "BigIntLiteral" || O.type === "DecimalLiteral" || O.type === "BooleanLiteral" || O.type === "NullLiteral" || O.type === "NumericLiteral" || O.type === "RegExpLiteral" || O.type === "StringLiteral" || O.type === "Identifier" || O.type === "ThisExpression" || O.type === "Super" || O.type === "PrivateName" || O.type === "PrivateIdentifier" || O.type === "ArgumentPlaceholder" || O.type === "Import")
              return true;
            if (O.type === "TemplateLiteral")
              return O.quasis.every((Qe) => !Qe.value.raw.includes(`
`)) && O.expressions.every(_e2);
            if (O.type === "ObjectExpression")
              return O.properties.every((Qe) => !Qe.computed && (Qe.shorthand || Qe.value && _e2(Qe.value)));
            if (O.type === "ArrayExpression")
              return O.elements.every((Qe) => Qe === null || _e2(Qe));
            if (tt(O))
              return (O.type === "ImportExpression" || Pe2(O.callee, me2)) && Ye2(O).every(_e2);
            if (ue2(O))
              return Pe2(O.object, me2) && Pe2(O.property, me2);
            let Ge2 = { "!": true, "-": true, "+": true, "~": true };
            if (O.type === "UnaryExpression" && Ge2[O.operator])
              return Pe2(O.argument, me2);
            let it2 = { "++": true, "--": true };
            return O.type === "UpdateExpression" && it2[O.operator] ? Pe2(O.argument, me2) : O.type === "TSNonNullExpression" ? Pe2(O.expression, me2) : false;
          }
          function oe(O) {
            var me2, _e2;
            return (me2 = (_e2 = O.extra) === null || _e2 === void 0 ? void 0 : _e2.raw) !== null && me2 !== void 0 ? me2 : O.raw;
          }
          function H(O) {
            return O;
          }
          function pe2(O) {
            return O.filepath && /\.tsx$/i.test(O.filepath);
          }
          function X(O) {
            let me2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "es5";
            return O.trailingComma === "es5" && me2 === "es5" || O.trailingComma === "all" && (me2 === "all" || me2 === "es5");
          }
          function le2(O, me2) {
            switch (O.type) {
              case "BinaryExpression":
              case "LogicalExpression":
              case "AssignmentExpression":
              case "NGPipeExpression":
                return le2(O.left, me2);
              case "MemberExpression":
              case "OptionalMemberExpression":
                return le2(O.object, me2);
              case "TaggedTemplateExpression":
                return O.tag.type === "FunctionExpression" ? false : le2(O.tag, me2);
              case "CallExpression":
              case "OptionalCallExpression":
                return O.callee.type === "FunctionExpression" ? false : le2(O.callee, me2);
              case "ConditionalExpression":
                return le2(O.test, me2);
              case "UpdateExpression":
                return !O.prefix && le2(O.argument, me2);
              case "BindExpression":
                return O.object && le2(O.object, me2);
              case "SequenceExpression":
                return le2(O.expressions[0], me2);
              case "TSSatisfiesExpression":
              case "TSAsExpression":
              case "TSNonNullExpression":
                return le2(O.expression, me2);
              default:
                return me2(O);
            }
          }
          var Ae2 = { "==": true, "!=": true, "===": true, "!==": true }, Ee = { "*": true, "/": true, "%": true }, De2 = { ">>": true, ">>>": true, "<<": true };
          function A(O, me2) {
            return !(re(me2) !== re(O) || O === "**" || Ae2[O] && Ae2[me2] || me2 === "%" && Ee[O] || O === "%" && Ee[me2] || me2 !== O && Ee[me2] && Ee[O] || De2[O] && De2[me2]);
          }
          var G = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((O, me2) => O.map((_e2) => [_e2, me2])));
          function re(O) {
            return G.get(O);
          }
          function ye2(O) {
            return Boolean(De2[O]) || O === "|" || O === "^" || O === "&";
          }
          function Ce2(O) {
            var me2;
            if (O.rest)
              return true;
            let _e2 = ve2(O);
            return ((me2 = s(_e2)) === null || me2 === void 0 ? void 0 : me2.type) === "RestElement";
          }
          var Be = /* @__PURE__ */ new WeakMap();
          function ve2(O) {
            if (Be.has(O))
              return Be.get(O);
            let me2 = [];
            return O.this && me2.push(O.this), Array.isArray(O.parameters) ? me2.push(...O.parameters) : Array.isArray(O.params) && me2.push(...O.params), O.rest && me2.push(O.rest), Be.set(O, me2), me2;
          }
          function ze(O, me2) {
            let _e2 = O.getValue(), He2 = 0, Ge2 = (it2) => me2(it2, He2++);
            _e2.this && O.call(Ge2, "this"), Array.isArray(_e2.parameters) ? O.each(Ge2, "parameters") : Array.isArray(_e2.params) && O.each(Ge2, "params"), _e2.rest && O.call(Ge2, "rest");
          }
          var be2 = /* @__PURE__ */ new WeakMap();
          function Ye2(O) {
            if (be2.has(O))
              return be2.get(O);
            let me2 = O.arguments;
            return O.type === "ImportExpression" && (me2 = [O.source], O.attributes && me2.push(O.attributes)), be2.set(O, me2), me2;
          }
          function Se2(O, me2) {
            let _e2 = O.getValue();
            _e2.type === "ImportExpression" ? (O.call((He2) => me2(He2, 0), "source"), _e2.attributes && O.call((He2) => me2(He2, 1), "attributes")) : O.each(me2, "arguments");
          }
          function Ie2(O) {
            return O.value.trim() === "prettier-ignore" && !O.unignore;
          }
          function Oe2(O) {
            return O && (O.prettierIgnore || Me2(O, Te2.PrettierIgnore));
          }
          function Je2(O) {
            let me2 = O.getValue();
            return Oe2(me2);
          }
          var Te2 = { Leading: 1 << 1, Trailing: 1 << 2, Dangling: 1 << 3, Block: 1 << 4, Line: 1 << 5, PrettierIgnore: 1 << 6, First: 1 << 7, Last: 1 << 8 }, je2 = (O, me2) => {
            if (typeof O == "function" && (me2 = O, O = 0), O || me2)
              return (_e2, He2, Ge2) => !(O & Te2.Leading && !_e2.leading || O & Te2.Trailing && !_e2.trailing || O & Te2.Dangling && (_e2.leading || _e2.trailing) || O & Te2.Block && !g2(_e2) || O & Te2.Line && !D(_e2) || O & Te2.First && He2 !== 0 || O & Te2.Last && He2 !== Ge2.length - 1 || O & Te2.PrettierIgnore && !Ie2(_e2) || me2 && !me2(_e2));
          };
          function Me2(O, me2, _e2) {
            if (!u(O == null ? void 0 : O.comments))
              return false;
            let He2 = je2(me2, _e2);
            return He2 ? O.comments.some(He2) : true;
          }
          function ae2(O, me2, _e2) {
            if (!Array.isArray(O == null ? void 0 : O.comments))
              return [];
            let He2 = je2(me2, _e2);
            return He2 ? O.comments.filter(He2) : O.comments;
          }
          var nt = (O, me2) => {
            let { originalText: _e2 } = me2;
            return i(_e2, y2(O));
          };
          function tt(O) {
            return de(O) || O.type === "NewExpression" || O.type === "ImportExpression";
          }
          function Ve2(O) {
            return O && (O.type === "ObjectProperty" || O.type === "Property" && !O.method && O.kind === "init");
          }
          function We2(O) {
            return Boolean(O.__isUsingHackPipeline);
          }
          var Xe = Symbol("ifWithoutBlockAndSameLineComment");
          function st2(O) {
            return O.type === "TSAsExpression" || O.type === "TSSatisfiesExpression";
          }
          r.exports = { getFunctionParameters: ve2, iterateFunctionParametersPath: ze, getCallArguments: Ye2, iterateCallArgumentsPath: Se2, hasRestParameter: Ce2, getLeftSide: I2, getLeftSidePathName: P, getParentExportDeclaration: m, getTypeScriptMappedTypeModifier: z, hasFlowAnnotationComment: E, hasFlowShorthandAnnotationComment: w, hasLeadingOwnLineComment: Z, hasNakedLeftSide: x, hasNode: N2, hasIgnoreComment: Je2, hasNodeIgnoreComment: Oe2, identity: H, isBinaryish: V, isCallLikeExpression: tt, isEnabledHackPipeline: We2, isLineComment: D, isPrettierIgnoreComment: Ie2, isCallExpression: de, isMemberExpression: ue2, isExportDeclaration: T, isFlowAnnotationComment: U2, isFunctionCompositionArgs: Re2, isFunctionNotation: J, isFunctionOrArrowExpression: b, isGetterOrSetter: q, isJestEachTemplateLiteral: ge2, isJsxNode: M2, isLiteral: C, isLongCurriedCallExpression: Ne2, isSimpleCallArgument: Pe2, isMemberish: j, isNumericLiteral: o, isSignedNumericLiteral: d2, isObjectProperty: Ve2, isObjectType: S, isObjectTypePropertyAFunction: L, isSimpleType: ie2, isSimpleNumber: fe2, isSimpleTemplateLiteral: Fe2, isStringLiteral: v2, isStringPropSafeToUnquote: se2, isTemplateOnItsOwnLine: we2, isTestCall: K2, isTheOnlyJsxElementInMarkdown: R2, isTSXFile: pe2, isTypeAnnotationAFunction: Q, isNextLineEmpty: nt, needsHardlineAfterDanglingComment: ke2, rawText: oe, shouldPrintComma: X, isBitwiseOperator: ye2, shouldFlatten: A, startsWithNoLookaheadToken: le2, getPrecedence: re, hasComment: Me2, getComments: ae2, CommentCheckFlags: Te2, markerForIfWithoutBlockAndSameLineComment: Xe, isTSTypeExpression: st2 };
        } }), jt2 = te2({ "src/language-js/print/template-literal.js"(e, r) {
          ne2();
          var t = lt2(), { getStringWidth: s, getIndentSize: a } = Ue2(), { builders: { join: n, hardline: u, softline: i, group: l, indent: p, align: y2, lineSuffixBoundary: h, addAlignmentToDoc: g2 }, printer: { printDocToString: c }, utils: { mapDoc: f } } = qe2(), { isBinaryish: F, isJestEachTemplateLiteral: _, isSimpleTemplateLiteral: w, hasComment: E, isMemberExpression: N2, isTSTypeExpression: x } = Ke2();
          function I2(C, o, d2) {
            let v2 = C.getValue();
            if (v2.type === "TemplateLiteral" && _(v2, C.getParentNode())) {
              let R2 = P(C, d2, o);
              if (R2)
                return R2;
            }
            let b = "expressions";
            v2.type === "TSTemplateLiteralType" && (b = "types");
            let B = [], k = C.map(o, b), M2 = w(v2);
            return M2 && (k = k.map((R2) => c(R2, Object.assign(Object.assign({}, d2), {}, { printWidth: Number.POSITIVE_INFINITY })).formatted)), B.push(h, "`"), C.each((R2) => {
              let q = R2.getName();
              if (B.push(o()), q < k.length) {
                let { tabWidth: J } = d2, L = R2.getValue(), Q = a(L.value.raw, J), V = k[q];
                if (!M2) {
                  let Y = v2[b][q];
                  (E(Y) || N2(Y) || Y.type === "ConditionalExpression" || Y.type === "SequenceExpression" || x(Y) || F(Y)) && (V = [p([i, V]), i]);
                }
                let j = Q === 0 && L.value.raw.endsWith(`
`) ? y2(Number.NEGATIVE_INFINITY, V) : g2(V, Q, J);
                B.push(l(["${", j, h, "}"]));
              }
            }, "quasis"), B.push("`"), B;
          }
          function P(C, o, d2) {
            let v2 = C.getNode(), S = v2.quasis[0].value.raw.trim().split(/\s*\|\s*/);
            if (S.length > 1 || S.some((b) => b.length > 0)) {
              o.__inJestEach = true;
              let b = C.map(d2, "expressions");
              o.__inJestEach = false;
              let B = [], k = b.map((L) => "${" + c(L, Object.assign(Object.assign({}, o), {}, { printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" })).formatted + "}"), M2 = [{ hasLineBreak: false, cells: [] }];
              for (let L = 1; L < v2.quasis.length; L++) {
                let Q = t(M2), V = k[L - 1];
                Q.cells.push(V), V.includes(`
`) && (Q.hasLineBreak = true), v2.quasis[L].value.raw.includes(`
`) && M2.push({ hasLineBreak: false, cells: [] });
              }
              let R2 = Math.max(S.length, ...M2.map((L) => L.cells.length)), q = Array.from({ length: R2 }).fill(0), J = [{ cells: S }, ...M2.filter((L) => L.cells.length > 0)];
              for (let { cells: L } of J.filter((Q) => !Q.hasLineBreak))
                for (let [Q, V] of L.entries())
                  q[Q] = Math.max(q[Q], s(V));
              return B.push(h, "`", p([u, n(u, J.map((L) => n(" | ", L.cells.map((Q, V) => L.hasLineBreak ? Q : Q + " ".repeat(q[V] - s(Q))))))]), u, "`"), B;
            }
          }
          function $2(C, o) {
            let d2 = C.getValue(), v2 = o();
            return E(d2) && (v2 = l([p([i, v2]), i])), ["${", v2, h, "}"];
          }
          function D(C, o) {
            return C.map((d2) => $2(d2, o), "expressions");
          }
          function T(C, o) {
            return f(C, (d2) => typeof d2 == "string" ? o ? d2.replace(/(\\*)`/g, "$1$1\\`") : m(d2) : d2);
          }
          function m(C) {
            return C.replace(/([\\`]|\${)/g, "\\$1");
          }
          r.exports = { printTemplateLiteral: I2, printTemplateExpressions: D, escapeTemplateCharacters: T, uncookTemplateElementValue: m };
        } }), Ym2 = te2({ "src/language-js/embed/markdown.js"(e, r) {
          ne2();
          var { builders: { indent: t, softline: s, literalline: a, dedentToRoot: n } } = qe2(), { escapeTemplateCharacters: u } = jt2();
          function i(p, y2, h) {
            let c = p.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (w, E) => "\\".repeat(E.length / 2) + "`"), f = l(c), F = f !== "";
            F && (c = c.replace(new RegExp(`^${f}`, "gm"), ""));
            let _ = u(h(c, { parser: "markdown", __inJsTemplate: true }, { stripTrailingHardline: true }), true);
            return ["`", F ? t([s, _]) : [a, n(_)], s, "`"];
          }
          function l(p) {
            let y2 = p.match(/^([^\S\n]*)\S/m);
            return y2 === null ? "" : y2[1];
          }
          r.exports = i;
        } }), Qm2 = te2({ "src/language-js/embed/css.js"(e, r) {
          ne2();
          var { isNonEmptyArray: t } = Ue2(), { builders: { indent: s, hardline: a, softline: n }, utils: { mapDoc: u, replaceEndOfLine: i, cleanDoc: l } } = qe2(), { printTemplateExpressions: p } = jt2();
          function y2(c, f, F) {
            let _ = c.getValue(), w = _.quasis.map((P) => P.value.raw), E = 0, N2 = w.reduce((P, $2, D) => D === 0 ? $2 : P + "@prettier-placeholder-" + E++ + "-id" + $2, ""), x = F(N2, { parser: "scss" }, { stripTrailingHardline: true }), I2 = p(c, f);
            return h(x, _, I2);
          }
          function h(c, f, F) {
            if (f.quasis.length === 1 && !f.quasis[0].value.raw.trim())
              return "``";
            let w = g2(c, F);
            if (!w)
              throw new Error("Couldn't insert all the expressions");
            return ["`", s([a, w]), n, "`"];
          }
          function g2(c, f) {
            if (!t(f))
              return c;
            let F = 0, _ = u(l(c), (w) => typeof w != "string" || !w.includes("@prettier-placeholder") ? w : w.split(/@prettier-placeholder-(\d+)-id/).map((E, N2) => N2 % 2 === 0 ? i(E) : (F++, f[E])));
            return f.length === F ? _ : null;
          }
          r.exports = y2;
        } }), Zm2 = te2({ "src/language-js/embed/graphql.js"(e, r) {
          ne2();
          var { builders: { indent: t, join: s, hardline: a } } = qe2(), { escapeTemplateCharacters: n, printTemplateExpressions: u } = jt2();
          function i(p, y2, h) {
            let g2 = p.getValue(), c = g2.quasis.length;
            if (c === 1 && g2.quasis[0].value.raw.trim() === "")
              return "``";
            let f = u(p, y2), F = [];
            for (let _ = 0; _ < c; _++) {
              let w = g2.quasis[_], E = _ === 0, N2 = _ === c - 1, x = w.value.cooked, I2 = x.split(`
`), P = I2.length, $2 = f[_], D = P > 2 && I2[0].trim() === "" && I2[1].trim() === "", T = P > 2 && I2[P - 1].trim() === "" && I2[P - 2].trim() === "", m = I2.every((o) => /^\s*(?:#[^\n\r]*)?$/.test(o));
              if (!N2 && /#[^\n\r]*$/.test(I2[P - 1]))
                return null;
              let C = null;
              m ? C = l(I2) : C = h(x, { parser: "graphql" }, { stripTrailingHardline: true }), C ? (C = n(C, false), !E && D && F.push(""), F.push(C), !N2 && T && F.push("")) : !E && !N2 && D && F.push(""), $2 && F.push($2);
            }
            return ["`", t([a, s(a, F)]), a, "`"];
          }
          function l(p) {
            let y2 = [], h = false, g2 = p.map((c) => c.trim());
            for (let [c, f] of g2.entries())
              f !== "" && (g2[c - 1] === "" && h ? y2.push([a, f]) : y2.push(f), h = true);
            return y2.length === 0 ? null : s(a, y2);
          }
          r.exports = i;
        } }), ed2 = te2({ "src/language-js/embed/html.js"(e, r) {
          ne2();
          var { builders: { indent: t, line: s, hardline: a, group: n }, utils: { mapDoc: u } } = qe2(), { printTemplateExpressions: i, uncookTemplateElementValue: l } = jt2(), p = 0;
          function y2(h, g2, c, f, F) {
            let { parser: _ } = F, w = h.getValue(), E = p;
            p = p + 1 >>> 0;
            let N2 = (d2) => `PRETTIER_HTML_PLACEHOLDER_${d2}_${E}_IN_JS`, x = w.quasis.map((d2, v2, S) => v2 === S.length - 1 ? d2.value.cooked : d2.value.cooked + N2(v2)).join(""), I2 = i(h, g2);
            if (I2.length === 0 && x.trim().length === 0)
              return "``";
            let P = new RegExp(N2("(\\d+)"), "g"), $2 = 0, D = c(x, { parser: _, __onHtmlRoot(d2) {
              $2 = d2.children.length;
            } }, { stripTrailingHardline: true }), T = u(D, (d2) => {
              if (typeof d2 != "string")
                return d2;
              let v2 = [], S = d2.split(P);
              for (let b = 0; b < S.length; b++) {
                let B = S[b];
                if (b % 2 === 0) {
                  B && (B = l(B), f.__embeddedInHtml && (B = B.replace(/<\/(script)\b/gi, "<\\/$1")), v2.push(B));
                  continue;
                }
                let k = Number(B);
                v2.push(I2[k]);
              }
              return v2;
            }), m = /^\s/.test(x) ? " " : "", C = /\s$/.test(x) ? " " : "", o = f.htmlWhitespaceSensitivity === "ignore" ? a : m && C ? s : null;
            return n(o ? ["`", t([o, n(T)]), o, "`"] : ["`", m, $2 > 1 ? t(n(T)) : n(T), C, "`"]);
          }
          r.exports = y2;
        } }), td2 = te2({ "src/language-js/embed.js"(e, r) {
          ne2();
          var { hasComment: t, CommentCheckFlags: s, isObjectProperty: a } = Ke2(), n = Ym2(), u = Qm2(), i = Zm2(), l = ed2();
          function p(D) {
            if (g2(D) || _(D) || w(D) || c(D))
              return "css";
            if (x(D))
              return "graphql";
            if (P(D))
              return "html";
            if (f(D))
              return "angular";
            if (h(D))
              return "markdown";
          }
          function y2(D, T, m, C) {
            let o = D.getValue();
            if (o.type !== "TemplateLiteral" || $2(o))
              return;
            let d2 = p(D);
            if (d2) {
              if (d2 === "markdown")
                return n(D, T, m);
              if (d2 === "css")
                return u(D, T, m);
              if (d2 === "graphql")
                return i(D, T, m);
              if (d2 === "html" || d2 === "angular")
                return l(D, T, m, C, { parser: d2 });
            }
          }
          function h(D) {
            let T = D.getValue(), m = D.getParentNode();
            return m && m.type === "TaggedTemplateExpression" && T.quasis.length === 1 && m.tag.type === "Identifier" && (m.tag.name === "md" || m.tag.name === "markdown");
          }
          function g2(D) {
            let T = D.getValue(), m = D.getParentNode(), C = D.getParentNode(1);
            return C && T.quasis && m.type === "JSXExpressionContainer" && C.type === "JSXElement" && C.openingElement.name.name === "style" && C.openingElement.attributes.some((o) => o.name.name === "jsx") || m && m.type === "TaggedTemplateExpression" && m.tag.type === "Identifier" && m.tag.name === "css" || m && m.type === "TaggedTemplateExpression" && m.tag.type === "MemberExpression" && m.tag.object.name === "css" && (m.tag.property.name === "global" || m.tag.property.name === "resolve");
          }
          function c(D) {
            return D.match((T) => T.type === "TemplateLiteral", (T, m) => T.type === "ArrayExpression" && m === "elements", (T, m) => a(T) && T.key.type === "Identifier" && T.key.name === "styles" && m === "value", ...F);
          }
          function f(D) {
            return D.match((T) => T.type === "TemplateLiteral", (T, m) => a(T) && T.key.type === "Identifier" && T.key.name === "template" && m === "value", ...F);
          }
          var F = [(D, T) => D.type === "ObjectExpression" && T === "properties", (D, T) => D.type === "CallExpression" && D.callee.type === "Identifier" && D.callee.name === "Component" && T === "arguments", (D, T) => D.type === "Decorator" && T === "expression"];
          function _(D) {
            let T = D.getParentNode();
            if (!T || T.type !== "TaggedTemplateExpression")
              return false;
            let m = T.tag.type === "ParenthesizedExpression" ? T.tag.expression : T.tag;
            switch (m.type) {
              case "MemberExpression":
                return E(m.object) || N2(m);
              case "CallExpression":
                return E(m.callee) || m.callee.type === "MemberExpression" && (m.callee.object.type === "MemberExpression" && (E(m.callee.object.object) || N2(m.callee.object)) || m.callee.object.type === "CallExpression" && E(m.callee.object.callee));
              case "Identifier":
                return m.name === "css";
              default:
                return false;
            }
          }
          function w(D) {
            let T = D.getParentNode(), m = D.getParentNode(1);
            return m && T.type === "JSXExpressionContainer" && m.type === "JSXAttribute" && m.name.type === "JSXIdentifier" && m.name.name === "css";
          }
          function E(D) {
            return D.type === "Identifier" && D.name === "styled";
          }
          function N2(D) {
            return /^[A-Z]/.test(D.object.name) && D.property.name === "extend";
          }
          function x(D) {
            let T = D.getValue(), m = D.getParentNode();
            return I2(T, "GraphQL") || m && (m.type === "TaggedTemplateExpression" && (m.tag.type === "MemberExpression" && m.tag.object.name === "graphql" && m.tag.property.name === "experimental" || m.tag.type === "Identifier" && (m.tag.name === "gql" || m.tag.name === "graphql")) || m.type === "CallExpression" && m.callee.type === "Identifier" && m.callee.name === "graphql");
          }
          function I2(D, T) {
            return t(D, s.Block | s.Leading, (m) => {
              let { value: C } = m;
              return C === ` ${T} `;
            });
          }
          function P(D) {
            return I2(D.getValue(), "HTML") || D.match((T) => T.type === "TemplateLiteral", (T, m) => T.type === "TaggedTemplateExpression" && T.tag.type === "Identifier" && T.tag.name === "html" && m === "quasi");
          }
          function $2(D) {
            let { quasis: T } = D;
            return T.some((m) => {
              let { value: { cooked: C } } = m;
              return C === null;
            });
          }
          r.exports = y2;
        } }), rd2 = te2({ "src/language-js/clean.js"(e, r) {
          ne2();
          var t = Pt2(), s = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), a = (u) => {
            for (let i of u.quasis)
              delete i.value;
          };
          function n(u, i, l) {
            if (u.type === "Program" && delete i.sourceType, (u.type === "BigIntLiteral" || u.type === "BigIntLiteralTypeAnnotation") && i.value && (i.value = i.value.toLowerCase()), (u.type === "BigIntLiteral" || u.type === "Literal") && i.bigint && (i.bigint = i.bigint.toLowerCase()), u.type === "DecimalLiteral" && (i.value = Number(i.value)), u.type === "Literal" && i.decimal && (i.decimal = Number(i.decimal)), u.type === "EmptyStatement" || u.type === "JSXText" || u.type === "JSXExpressionContainer" && (u.expression.type === "Literal" || u.expression.type === "StringLiteral") && u.expression.value === " ")
              return null;
            if ((u.type === "Property" || u.type === "ObjectProperty" || u.type === "MethodDefinition" || u.type === "ClassProperty" || u.type === "ClassMethod" || u.type === "PropertyDefinition" || u.type === "TSDeclareMethod" || u.type === "TSPropertySignature" || u.type === "ObjectTypeProperty") && typeof u.key == "object" && u.key && (u.key.type === "Literal" || u.key.type === "NumericLiteral" || u.key.type === "StringLiteral" || u.key.type === "Identifier") && delete i.key, u.type === "JSXElement" && u.openingElement.name.name === "style" && u.openingElement.attributes.some((h) => h.name.name === "jsx"))
              for (let { type: h, expression: g2 } of i.children)
                h === "JSXExpressionContainer" && g2.type === "TemplateLiteral" && a(g2);
            u.type === "JSXAttribute" && u.name.name === "css" && u.value.type === "JSXExpressionContainer" && u.value.expression.type === "TemplateLiteral" && a(i.value.expression), u.type === "JSXAttribute" && u.value && u.value.type === "Literal" && /["']|&quot;|&apos;/.test(u.value.value) && (i.value.value = i.value.value.replace(/["']|&quot;|&apos;/g, '"'));
            let p = u.expression || u.callee;
            if (u.type === "Decorator" && p.type === "CallExpression" && p.callee.name === "Component" && p.arguments.length === 1) {
              let h = u.expression.arguments[0].properties;
              for (let [g2, c] of i.expression.arguments[0].properties.entries())
                switch (h[g2].key.name) {
                  case "styles":
                    c.value.type === "ArrayExpression" && a(c.value.elements[0]);
                    break;
                  case "template":
                    c.value.type === "TemplateLiteral" && a(c.value);
                    break;
                }
            }
            if (u.type === "TaggedTemplateExpression" && (u.tag.type === "MemberExpression" || u.tag.type === "Identifier" && (u.tag.name === "gql" || u.tag.name === "graphql" || u.tag.name === "css" || u.tag.name === "md" || u.tag.name === "markdown" || u.tag.name === "html") || u.tag.type === "CallExpression") && a(i.quasi), u.type === "TemplateLiteral") {
              var y2;
              (((y2 = u.leadingComments) === null || y2 === void 0 ? void 0 : y2.some((g2) => t(g2) && ["GraphQL", "HTML"].some((c) => g2.value === ` ${c} `))) || l.type === "CallExpression" && l.callee.name === "graphql" || !u.leadingComments) && a(i);
            }
            if (u.type === "InterpreterDirective" && (i.value = i.value.trimEnd()), (u.type === "TSIntersectionType" || u.type === "TSUnionType") && u.types.length === 1)
              return i.types[0];
          }
          n.ignoredProperties = s, r.exports = n;
        } }), io2 = {};
        Kt2(io2, { EOL: () => Wn2, arch: () => nd2, cpus: () => Do2, default: () => vo2, endianness: () => ao2, freemem: () => po2, getNetworkInterfaces: () => ho2, hostname: () => oo2, loadavg: () => lo2, networkInterfaces: () => yo2, platform: () => ud2, release: () => go2, tmpDir: () => $n2, tmpdir: () => Vn2, totalmem: () => fo2, type: () => mo2, uptime: () => co2 });
        function ao2() {
          if (typeof Tr2 > "u") {
            var e = new ArrayBuffer(2), r = new Uint8Array(e), t = new Uint16Array(e);
            if (r[0] = 1, r[1] = 2, t[0] === 258)
              Tr2 = "BE";
            else if (t[0] === 513)
              Tr2 = "LE";
            else
              throw new Error("unable to figure out endianess");
          }
          return Tr2;
        }
        function oo2() {
          return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
        }
        function lo2() {
          return [];
        }
        function co2() {
          return 0;
        }
        function po2() {
          return Number.MAX_VALUE;
        }
        function fo2() {
          return Number.MAX_VALUE;
        }
        function Do2() {
          return [];
        }
        function mo2() {
          return "Browser";
        }
        function go2() {
          return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
        }
        function yo2() {
        }
        function ho2() {
        }
        function nd2() {
          return "javascript";
        }
        function ud2() {
          return "browser";
        }
        function $n2() {
          return "/tmp";
        }
        var Tr2, Vn2, Wn2, vo2, sd2 = ht2({ "node-modules-polyfills:os"() {
          ne2(), Vn2 = $n2, Wn2 = `
`, vo2 = { EOL: Wn2, tmpdir: Vn2, tmpDir: $n2, networkInterfaces: yo2, getNetworkInterfaces: ho2, release: go2, type: mo2, cpus: Do2, totalmem: fo2, freemem: po2, uptime: co2, loadavg: lo2, hostname: oo2, endianness: ao2 };
        } }), id2 = te2({ "node-modules-polyfills-commonjs:os"(e, r) {
          ne2();
          var t = (sd2(), ft2(io2));
          if (t && t.default) {
            r.exports = t.default;
            for (let s in t)
              r.exports[s] = t[s];
          } else
            t && (r.exports = t);
        } }), ad2 = te2({ "node_modules/detect-newline/index.js"(e, r) {
          ne2();
          var t = (s) => {
            if (typeof s != "string")
              throw new TypeError("Expected a string");
            let a = s.match(/(?:\r?\n)/g) || [];
            if (a.length === 0)
              return;
            let n = a.filter((i) => i === `\r
`).length, u = a.length - n;
            return n > u ? `\r
` : `
`;
          };
          r.exports = t, r.exports.graceful = (s) => typeof s == "string" && t(s) || `
`;
        } }), od2 = te2({ "node_modules/jest-docblock/build/index.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true }), e.extract = c, e.parse = F, e.parseWithComments = _, e.print = w, e.strip = f;
          function r() {
            let N2 = id2();
            return r = function() {
              return N2;
            }, N2;
          }
          function t() {
            let N2 = s(ad2());
            return t = function() {
              return N2;
            }, N2;
          }
          function s(N2) {
            return N2 && N2.__esModule ? N2 : { default: N2 };
          }
          var a = /\*\/$/, n = /^\/\*\*?/, u = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, i = /(^|\s+)\/\/([^\r\n]*)/g, l = /^(\r?\n)+/, p = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, y2 = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, h = /(\r?\n|^) *\* ?/g, g2 = [];
          function c(N2) {
            let x = N2.match(u);
            return x ? x[0].trimLeft() : "";
          }
          function f(N2) {
            let x = N2.match(u);
            return x && x[0] ? N2.substring(x[0].length) : N2;
          }
          function F(N2) {
            return _(N2).pragmas;
          }
          function _(N2) {
            let x = (0, t().default)(N2) || r().EOL;
            N2 = N2.replace(n, "").replace(a, "").replace(h, "$1");
            let I2 = "";
            for (; I2 !== N2; )
              I2 = N2, N2 = N2.replace(p, `${x}$1 $2${x}`);
            N2 = N2.replace(l, "").trimRight();
            let P = /* @__PURE__ */ Object.create(null), $2 = N2.replace(y2, "").replace(l, "").trimRight(), D;
            for (; D = y2.exec(N2); ) {
              let T = D[2].replace(i, "");
              typeof P[D[1]] == "string" || Array.isArray(P[D[1]]) ? P[D[1]] = g2.concat(P[D[1]], T) : P[D[1]] = T;
            }
            return { comments: $2, pragmas: P };
          }
          function w(N2) {
            let { comments: x = "", pragmas: I2 = {} } = N2, P = (0, t().default)(x) || r().EOL, $2 = "/**", D = " *", T = " */", m = Object.keys(I2), C = m.map((d2) => E(d2, I2[d2])).reduce((d2, v2) => d2.concat(v2), []).map((d2) => `${D} ${d2}${P}`).join("");
            if (!x) {
              if (m.length === 0)
                return "";
              if (m.length === 1 && !Array.isArray(I2[m[0]])) {
                let d2 = I2[m[0]];
                return `${$2} ${E(m[0], d2)[0]}${T}`;
              }
            }
            let o = x.split(P).map((d2) => `${D} ${d2}`).join(P) + P;
            return $2 + P + (x ? o : "") + (x && m.length ? D + P : "") + C + T;
          }
          function E(N2, x) {
            return g2.concat(x).map((I2) => `@${N2} ${I2}`.trim());
          }
        } }), ld2 = te2({ "src/language-js/utils/get-shebang.js"(e, r) {
          ne2();
          function t(s) {
            if (!s.startsWith("#!"))
              return "";
            let a = s.indexOf(`
`);
            return a === -1 ? s : s.slice(0, a);
          }
          r.exports = t;
        } }), Co2 = te2({ "src/language-js/pragma.js"(e, r) {
          ne2();
          var { parseWithComments: t, strip: s, extract: a, print: n } = od2(), { normalizeEndOfLine: u } = Jn2(), i = ld2();
          function l(h) {
            let g2 = i(h);
            g2 && (h = h.slice(g2.length + 1));
            let c = a(h), { pragmas: f, comments: F } = t(c);
            return { shebang: g2, text: h, pragmas: f, comments: F };
          }
          function p(h) {
            let g2 = Object.keys(l(h).pragmas);
            return g2.includes("prettier") || g2.includes("format");
          }
          function y2(h) {
            let { shebang: g2, text: c, pragmas: f, comments: F } = l(h), _ = s(c), w = n({ pragmas: Object.assign({ format: "" }, f), comments: F.trimStart() });
            return (g2 ? `${g2}
` : "") + u(w) + (_.startsWith(`
`) ? `
` : `

`) + _;
          }
          r.exports = { hasPragma: p, insertPragma: y2 };
        } }), cd2 = te2({ "src/language-js/utils/is-type-cast-comment.js"(e, r) {
          ne2();
          var t = Pt2();
          function s(a) {
            return t(a) && a.value[0] === "*" && /@(?:type|satisfies)\b/.test(a.value);
          }
          r.exports = s;
        } }), Eo2 = te2({ "src/language-js/comments.js"(e, r) {
          ne2();
          var { getLast: t, hasNewline: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: a, getNextNonSpaceNonCommentCharacter: n, hasNewlineInRange: u, addLeadingComment: i, addTrailingComment: l, addDanglingComment: p, getNextNonSpaceNonCommentCharacterIndex: y2, isNonEmptyArray: h } = Ue2(), { getFunctionParameters: g2, isPrettierIgnoreComment: c, isJsxNode: f, hasFlowShorthandAnnotationComment: F, hasFlowAnnotationComment: _, hasIgnoreComment: w, isCallLikeExpression: E, getCallArguments: N2, isCallExpression: x, isMemberExpression: I2, isObjectProperty: P, isLineComment: $2, getComments: D, CommentCheckFlags: T, markerForIfWithoutBlockAndSameLineComment: m } = Ke2(), { locStart: C, locEnd: o } = ut2(), d2 = Pt2(), v2 = cd2();
          function S(De2) {
            return [H, Fe2, Q, q, J, L, ie2, he2, se2, ge2, we2, ke2, ce2, z, U2].some((A) => A(De2));
          }
          function b(De2) {
            return [R2, Fe2, V, we2, q, J, L, ie2, z, Z, fe2, ge2, Pe2, U2, X].some((A) => A(De2));
          }
          function B(De2) {
            return [H, q, J, j, ue2, ce2, ge2, de, K2, pe2, U2, oe].some((A) => A(De2));
          }
          function k(De2, A) {
            let G = (De2.body || De2.properties).find((re) => {
              let { type: ye2 } = re;
              return ye2 !== "EmptyStatement";
            });
            G ? i(G, A) : p(De2, A);
          }
          function M2(De2, A) {
            De2.type === "BlockStatement" ? k(De2, A) : i(De2, A);
          }
          function R2(De2) {
            let { comment: A, followingNode: G } = De2;
            return G && v2(A) ? (i(G, A), true) : false;
          }
          function q(De2) {
            let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye2, text: Ce2 } = De2;
            if ((re == null ? void 0 : re.type) !== "IfStatement" || !ye2)
              return false;
            if (n(Ce2, A, o) === ")")
              return l(G, A), true;
            if (G === re.consequent && ye2 === re.alternate) {
              if (G.type === "BlockStatement")
                l(G, A);
              else {
                let ve2 = A.type === "SingleLine" || A.loc.start.line === A.loc.end.line, ze = A.loc.start.line === G.loc.start.line;
                ve2 && ze ? p(G, A, m) : p(re, A);
              }
              return true;
            }
            return ye2.type === "BlockStatement" ? (k(ye2, A), true) : ye2.type === "IfStatement" ? (M2(ye2.consequent, A), true) : re.consequent === ye2 ? (i(ye2, A), true) : false;
          }
          function J(De2) {
            let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye2, text: Ce2 } = De2;
            return (re == null ? void 0 : re.type) !== "WhileStatement" || !ye2 ? false : n(Ce2, A, o) === ")" ? (l(G, A), true) : ye2.type === "BlockStatement" ? (k(ye2, A), true) : re.body === ye2 ? (i(ye2, A), true) : false;
          }
          function L(De2) {
            let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye2 } = De2;
            return (re == null ? void 0 : re.type) !== "TryStatement" && (re == null ? void 0 : re.type) !== "CatchClause" || !ye2 ? false : re.type === "CatchClause" && G ? (l(G, A), true) : ye2.type === "BlockStatement" ? (k(ye2, A), true) : ye2.type === "TryStatement" ? (M2(ye2.finalizer, A), true) : ye2.type === "CatchClause" ? (M2(ye2.body, A), true) : false;
          }
          function Q(De2) {
            let { comment: A, enclosingNode: G, followingNode: re } = De2;
            return I2(G) && (re == null ? void 0 : re.type) === "Identifier" ? (i(G, A), true) : false;
          }
          function V(De2) {
            let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye2, text: Ce2 } = De2, Be = G && !u(Ce2, o(G), C(A));
            return (!G || !Be) && ((re == null ? void 0 : re.type) === "ConditionalExpression" || (re == null ? void 0 : re.type) === "TSConditionalType") && ye2 ? (i(ye2, A), true) : false;
          }
          function j(De2) {
            let { comment: A, precedingNode: G, enclosingNode: re } = De2;
            return P(re) && re.shorthand && re.key === G && re.value.type === "AssignmentPattern" ? (l(re.value.left, A), true) : false;
          }
          var Y = /* @__PURE__ */ new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
          function ie2(De2) {
            let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye2 } = De2;
            if (Y.has(re == null ? void 0 : re.type)) {
              if (h(re.decorators) && !(ye2 && ye2.type === "Decorator"))
                return l(t(re.decorators), A), true;
              if (re.body && ye2 === re.body)
                return k(re.body, A), true;
              if (ye2) {
                if (re.superClass && ye2 === re.superClass && G && (G === re.id || G === re.typeParameters))
                  return l(G, A), true;
                for (let Ce2 of ["implements", "extends", "mixins"])
                  if (re[Ce2] && ye2 === re[Ce2][0])
                    return G && (G === re.id || G === re.typeParameters || G === re.superClass) ? l(G, A) : p(re, A, Ce2), true;
              }
            }
            return false;
          }
          var ee2 = /* @__PURE__ */ new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty"]);
          function ce2(De2) {
            let { comment: A, precedingNode: G, enclosingNode: re, text: ye2 } = De2;
            return re && G && n(ye2, A, o) === "(" && (re.type === "Property" || re.type === "TSDeclareMethod" || re.type === "TSAbstractMethodDefinition") && G.type === "Identifier" && re.key === G && n(ye2, G, o) !== ":" || (G == null ? void 0 : G.type) === "Decorator" && ee2.has(re == null ? void 0 : re.type) ? (l(G, A), true) : false;
          }
          var W = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
          function K2(De2) {
            let { comment: A, precedingNode: G, enclosingNode: re, text: ye2 } = De2;
            return n(ye2, A, o) !== "(" ? false : G && W.has(re == null ? void 0 : re.type) ? (l(G, A), true) : false;
          }
          function de(De2) {
            let { comment: A, enclosingNode: G, text: re } = De2;
            if ((G == null ? void 0 : G.type) !== "ArrowFunctionExpression")
              return false;
            let ye2 = y2(re, A, o);
            return ye2 !== false && re.slice(ye2, ye2 + 2) === "=>" ? (p(G, A), true) : false;
          }
          function ue2(De2) {
            let { comment: A, enclosingNode: G, text: re } = De2;
            return n(re, A, o) !== ")" ? false : G && (le2(G) && g2(G).length === 0 || E(G) && N2(G).length === 0) ? (p(G, A), true) : ((G == null ? void 0 : G.type) === "MethodDefinition" || (G == null ? void 0 : G.type) === "TSAbstractMethodDefinition") && g2(G.value).length === 0 ? (p(G.value, A), true) : false;
          }
          function Fe2(De2) {
            let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye2, text: Ce2 } = De2;
            if ((G == null ? void 0 : G.type) === "FunctionTypeParam" && (re == null ? void 0 : re.type) === "FunctionTypeAnnotation" && (ye2 == null ? void 0 : ye2.type) !== "FunctionTypeParam" || ((G == null ? void 0 : G.type) === "Identifier" || (G == null ? void 0 : G.type) === "AssignmentPattern") && re && le2(re) && n(Ce2, A, o) === ")")
              return l(G, A), true;
            if ((re == null ? void 0 : re.type) === "FunctionDeclaration" && (ye2 == null ? void 0 : ye2.type) === "BlockStatement") {
              let Be = (() => {
                let ve2 = g2(re);
                if (ve2.length > 0)
                  return a(Ce2, o(t(ve2)));
                let ze = a(Ce2, o(re.id));
                return ze !== false && a(Ce2, ze + 1);
              })();
              if (C(A) > Be)
                return k(ye2, A), true;
            }
            return false;
          }
          function z(De2) {
            let { comment: A, enclosingNode: G } = De2;
            return (G == null ? void 0 : G.type) === "LabeledStatement" ? (i(G, A), true) : false;
          }
          function U2(De2) {
            let { comment: A, enclosingNode: G } = De2;
            return ((G == null ? void 0 : G.type) === "ContinueStatement" || (G == null ? void 0 : G.type) === "BreakStatement") && !G.label ? (l(G, A), true) : false;
          }
          function Z(De2) {
            let { comment: A, precedingNode: G, enclosingNode: re } = De2;
            return x(re) && G && re.callee === G && re.arguments.length > 0 ? (i(re.arguments[0], A), true) : false;
          }
          function se2(De2) {
            let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye2 } = De2;
            return (re == null ? void 0 : re.type) === "UnionTypeAnnotation" || (re == null ? void 0 : re.type) === "TSUnionType" ? (c(A) && (ye2.prettierIgnore = true, A.unignore = true), G ? (l(G, A), true) : false) : (((ye2 == null ? void 0 : ye2.type) === "UnionTypeAnnotation" || (ye2 == null ? void 0 : ye2.type) === "TSUnionType") && c(A) && (ye2.types[0].prettierIgnore = true, A.unignore = true), false);
          }
          function fe2(De2) {
            let { comment: A, enclosingNode: G } = De2;
            return P(G) ? (i(G, A), true) : false;
          }
          function ge2(De2) {
            let { comment: A, enclosingNode: G, followingNode: re, ast: ye2, isLastComment: Ce2 } = De2;
            return ye2 && ye2.body && ye2.body.length === 0 ? (Ce2 ? p(ye2, A) : i(ye2, A), true) : (G == null ? void 0 : G.type) === "Program" && (G == null ? void 0 : G.body.length) === 0 && !h(G.directives) ? (Ce2 ? p(G, A) : i(G, A), true) : (re == null ? void 0 : re.type) === "Program" && (re == null ? void 0 : re.body.length) === 0 && (G == null ? void 0 : G.type) === "ModuleExpression" ? (p(re, A), true) : false;
          }
          function he2(De2) {
            let { comment: A, enclosingNode: G } = De2;
            return (G == null ? void 0 : G.type) === "ForInStatement" || (G == null ? void 0 : G.type) === "ForOfStatement" ? (i(G, A), true) : false;
          }
          function we2(De2) {
            let { comment: A, precedingNode: G, enclosingNode: re, text: ye2 } = De2;
            if ((re == null ? void 0 : re.type) === "ImportSpecifier" || (re == null ? void 0 : re.type) === "ExportSpecifier")
              return i(re, A), true;
            let Ce2 = (G == null ? void 0 : G.type) === "ImportSpecifier" && (re == null ? void 0 : re.type) === "ImportDeclaration", Be = (G == null ? void 0 : G.type) === "ExportSpecifier" && (re == null ? void 0 : re.type) === "ExportNamedDeclaration";
            return (Ce2 || Be) && s(ye2, o(A)) ? (l(G, A), true) : false;
          }
          function ke2(De2) {
            let { comment: A, enclosingNode: G } = De2;
            return (G == null ? void 0 : G.type) === "AssignmentPattern" ? (i(G, A), true) : false;
          }
          var Re2 = /* @__PURE__ */ new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]), Ne2 = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
          function Pe2(De2) {
            let { comment: A, enclosingNode: G, followingNode: re } = De2;
            return Re2.has(G == null ? void 0 : G.type) && re && (Ne2.has(re.type) || d2(A)) ? (i(re, A), true) : false;
          }
          function oe(De2) {
            let { comment: A, enclosingNode: G, followingNode: re, text: ye2 } = De2;
            return !re && ((G == null ? void 0 : G.type) === "TSMethodSignature" || (G == null ? void 0 : G.type) === "TSDeclareFunction" || (G == null ? void 0 : G.type) === "TSAbstractMethodDefinition") && n(ye2, A, o) === ";" ? (l(G, A), true) : false;
          }
          function H(De2) {
            let { comment: A, enclosingNode: G, followingNode: re } = De2;
            if (c(A) && (G == null ? void 0 : G.type) === "TSMappedType" && (re == null ? void 0 : re.type) === "TSTypeParameter" && re.constraint)
              return G.prettierIgnore = true, A.unignore = true, true;
          }
          function pe2(De2) {
            let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye2 } = De2;
            return (re == null ? void 0 : re.type) !== "TSMappedType" ? false : (ye2 == null ? void 0 : ye2.type) === "TSTypeParameter" && ye2.name ? (i(ye2.name, A), true) : (G == null ? void 0 : G.type) === "TSTypeParameter" && G.constraint ? (l(G.constraint, A), true) : false;
          }
          function X(De2) {
            let { comment: A, enclosingNode: G, followingNode: re } = De2;
            return !G || G.type !== "SwitchCase" || G.test || !re || re !== G.consequent[0] ? false : (re.type === "BlockStatement" && $2(A) ? k(re, A) : p(G, A), true);
          }
          function le2(De2) {
            return De2.type === "ArrowFunctionExpression" || De2.type === "FunctionExpression" || De2.type === "FunctionDeclaration" || De2.type === "ObjectMethod" || De2.type === "ClassMethod" || De2.type === "TSDeclareFunction" || De2.type === "TSCallSignatureDeclaration" || De2.type === "TSConstructSignatureDeclaration" || De2.type === "TSMethodSignature" || De2.type === "TSConstructorType" || De2.type === "TSFunctionType" || De2.type === "TSDeclareMethod";
          }
          function Ae2(De2, A) {
            if ((A.parser === "typescript" || A.parser === "flow" || A.parser === "acorn" || A.parser === "espree" || A.parser === "meriyah" || A.parser === "__babel_estree") && De2.type === "MethodDefinition" && De2.value && De2.value.type === "FunctionExpression" && g2(De2.value).length === 0 && !De2.value.returnType && !h(De2.value.typeParameters) && De2.value.body)
              return [...De2.decorators || [], De2.key, De2.value.body];
          }
          function Ee(De2) {
            let A = De2.getValue(), G = De2.getParentNode(), re = (ye2) => _(D(ye2, T.Leading)) || _(D(ye2, T.Trailing));
            return (A && (f(A) || F(A) || x(G) && re(A)) || G && (G.type === "JSXSpreadAttribute" || G.type === "JSXSpreadChild" || G.type === "UnionTypeAnnotation" || G.type === "TSUnionType" || (G.type === "ClassDeclaration" || G.type === "ClassExpression") && G.superClass === A)) && (!w(De2) || G.type === "UnionTypeAnnotation" || G.type === "TSUnionType");
          }
          r.exports = { handleOwnLineComment: S, handleEndOfLineComment: b, handleRemainingComment: B, getCommentChildNodes: Ae2, willPrintOwnComments: Ee };
        } }), qt2 = te2({ "src/language-js/needs-parens.js"(e, r) {
          ne2();
          var t = lt2(), s = Kn2(), { getFunctionParameters: a, getLeftSidePathName: n, hasFlowShorthandAnnotationComment: u, hasNakedLeftSide: i, hasNode: l, isBitwiseOperator: p, startsWithNoLookaheadToken: y2, shouldFlatten: h, getPrecedence: g2, isCallExpression: c, isMemberExpression: f, isObjectProperty: F, isTSTypeExpression: _ } = Ke2();
          function w(D, T) {
            let m = D.getParentNode();
            if (!m)
              return false;
            let C = D.getName(), o = D.getNode();
            if (T.__isInHtmlInterpolation && !T.bracketSpacing && I2(o) && P(D))
              return true;
            if (E(o))
              return false;
            if (T.parser !== "flow" && u(D.getValue()))
              return true;
            if (o.type === "Identifier") {
              if (o.extra && o.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(o.name) || C === "left" && (o.name === "async" && !m.await || o.name === "let") && m.type === "ForOfStatement")
                return true;
              if (o.name === "let") {
                var d2;
                let S = (d2 = D.findAncestor((b) => b.type === "ForOfStatement")) === null || d2 === void 0 ? void 0 : d2.left;
                if (S && y2(S, (b) => b === o))
                  return true;
              }
              if (C === "object" && o.name === "let" && m.type === "MemberExpression" && m.computed && !m.optional) {
                let S = D.findAncestor((B) => B.type === "ExpressionStatement" || B.type === "ForStatement" || B.type === "ForInStatement"), b = S ? S.type === "ExpressionStatement" ? S.expression : S.type === "ForStatement" ? S.init : S.left : void 0;
                if (b && y2(b, (B) => B === o))
                  return true;
              }
              return false;
            }
            if (o.type === "ObjectExpression" || o.type === "FunctionExpression" || o.type === "ClassExpression" || o.type === "DoExpression") {
              var v2;
              let S = (v2 = D.findAncestor((b) => b.type === "ExpressionStatement")) === null || v2 === void 0 ? void 0 : v2.expression;
              if (S && y2(S, (b) => b === o))
                return true;
            }
            switch (m.type) {
              case "ParenthesizedExpression":
                return false;
              case "ClassDeclaration":
              case "ClassExpression": {
                if (C === "superClass" && (o.type === "ArrowFunctionExpression" || o.type === "AssignmentExpression" || o.type === "AwaitExpression" || o.type === "BinaryExpression" || o.type === "ConditionalExpression" || o.type === "LogicalExpression" || o.type === "NewExpression" || o.type === "ObjectExpression" || o.type === "SequenceExpression" || o.type === "TaggedTemplateExpression" || o.type === "UnaryExpression" || o.type === "UpdateExpression" || o.type === "YieldExpression" || o.type === "TSNonNullExpression"))
                  return true;
                break;
              }
              case "ExportDefaultDeclaration":
                return $2(D, T) || o.type === "SequenceExpression";
              case "Decorator": {
                if (C === "expression") {
                  if (f(o) && o.computed)
                    return true;
                  let S = false, b = false, B = o;
                  for (; B; )
                    switch (B.type) {
                      case "MemberExpression":
                        b = true, B = B.object;
                        break;
                      case "CallExpression":
                        if (b || S)
                          return T.parser !== "typescript";
                        S = true, B = B.callee;
                        break;
                      case "Identifier":
                        return false;
                      case "TaggedTemplateExpression":
                        return T.parser !== "typescript";
                      default:
                        return true;
                    }
                  return true;
                }
                break;
              }
              case "ArrowFunctionExpression": {
                if (C === "body" && o.type !== "SequenceExpression" && y2(o, (S) => S.type === "ObjectExpression"))
                  return true;
                break;
              }
            }
            switch (o.type) {
              case "UpdateExpression":
                if (m.type === "UnaryExpression")
                  return o.prefix && (o.operator === "++" && m.operator === "+" || o.operator === "--" && m.operator === "-");
              case "UnaryExpression":
                switch (m.type) {
                  case "UnaryExpression":
                    return o.operator === m.operator && (o.operator === "+" || o.operator === "-");
                  case "BindExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return C === "object";
                  case "TaggedTemplateExpression":
                    return true;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return C === "callee";
                  case "BinaryExpression":
                    return C === "left" && m.operator === "**";
                  case "TSNonNullExpression":
                    return true;
                  default:
                    return false;
                }
              case "BinaryExpression": {
                if (m.type === "UpdateExpression" || o.operator === "in" && N2(D))
                  return true;
                if (o.operator === "|>" && o.extra && o.extra.parenthesized) {
                  let S = D.getParentNode(1);
                  if (S.type === "BinaryExpression" && S.operator === "|>")
                    return true;
                }
              }
              case "TSTypeAssertion":
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "LogicalExpression":
                switch (m.type) {
                  case "TSSatisfiesExpression":
                  case "TSAsExpression":
                    return !_(o);
                  case "ConditionalExpression":
                    return _(o);
                  case "CallExpression":
                  case "NewExpression":
                  case "OptionalCallExpression":
                    return C === "callee";
                  case "ClassExpression":
                  case "ClassDeclaration":
                    return C === "superClass";
                  case "TSTypeAssertion":
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "JSXSpreadAttribute":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "BindExpression":
                  case "AwaitExpression":
                  case "TSNonNullExpression":
                  case "UpdateExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return C === "object";
                  case "AssignmentExpression":
                  case "AssignmentPattern":
                    return C === "left" && (o.type === "TSTypeAssertion" || _(o));
                  case "LogicalExpression":
                    if (o.type === "LogicalExpression")
                      return m.operator !== o.operator;
                  case "BinaryExpression": {
                    let { operator: S, type: b } = o;
                    if (!S && b !== "TSTypeAssertion")
                      return true;
                    let B = g2(S), k = m.operator, M2 = g2(k);
                    return M2 > B || C === "right" && M2 === B || M2 === B && !h(k, S) ? true : M2 < B && S === "%" ? k === "+" || k === "-" : !!p(k);
                  }
                  default:
                    return false;
                }
              case "SequenceExpression":
                switch (m.type) {
                  case "ReturnStatement":
                    return false;
                  case "ForStatement":
                    return false;
                  case "ExpressionStatement":
                    return C !== "expression";
                  case "ArrowFunctionExpression":
                    return C !== "body";
                  default:
                    return true;
                }
              case "YieldExpression":
                if (m.type === "UnaryExpression" || m.type === "AwaitExpression" || _(m) || m.type === "TSNonNullExpression")
                  return true;
              case "AwaitExpression":
                switch (m.type) {
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "LogicalExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "TSAsExpression":
                  case "TSSatisfiesExpression":
                  case "TSNonNullExpression":
                  case "BindExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return C === "object";
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return C === "callee";
                  case "ConditionalExpression":
                    return C === "test";
                  case "BinaryExpression":
                    return !(!o.argument && m.operator === "|>");
                  default:
                    return false;
                }
              case "TSConditionalType":
              case "TSFunctionType":
              case "TSConstructorType":
                if (C === "extendsType" && m.type === "TSConditionalType") {
                  if (o.type === "TSConditionalType")
                    return true;
                  let { typeAnnotation: S } = o.returnType || o.typeAnnotation;
                  if (S.type === "TSTypePredicate" && S.typeAnnotation && (S = S.typeAnnotation.typeAnnotation), S.type === "TSInferType" && S.typeParameter.constraint)
                    return true;
                }
                if (C === "checkType" && m.type === "TSConditionalType")
                  return true;
              case "TSUnionType":
              case "TSIntersectionType":
                if ((m.type === "TSUnionType" || m.type === "TSIntersectionType") && m.types.length > 1 && (!o.types || o.types.length > 1))
                  return true;
              case "TSInferType":
                if (o.type === "TSInferType" && m.type === "TSRestType")
                  return false;
              case "TSTypeOperator":
                return m.type === "TSArrayType" || m.type === "TSOptionalType" || m.type === "TSRestType" || C === "objectType" && m.type === "TSIndexedAccessType" || m.type === "TSTypeOperator" || m.type === "TSTypeAnnotation" && D.getParentNode(1).type.startsWith("TSJSDoc");
              case "TSTypeQuery":
                return C === "objectType" && m.type === "TSIndexedAccessType" || C === "elementType" && m.type === "TSArrayType";
              case "TypeofTypeAnnotation":
                return C === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType") || C === "elementType" && m.type === "ArrayTypeAnnotation";
              case "ArrayTypeAnnotation":
                return m.type === "NullableTypeAnnotation";
              case "IntersectionTypeAnnotation":
              case "UnionTypeAnnotation":
                return m.type === "ArrayTypeAnnotation" || m.type === "NullableTypeAnnotation" || m.type === "IntersectionTypeAnnotation" || m.type === "UnionTypeAnnotation" || C === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType");
              case "NullableTypeAnnotation":
                return m.type === "ArrayTypeAnnotation" || C === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType");
              case "FunctionTypeAnnotation": {
                let S = m.type === "NullableTypeAnnotation" ? D.getParentNode(1) : m;
                return S.type === "UnionTypeAnnotation" || S.type === "IntersectionTypeAnnotation" || S.type === "ArrayTypeAnnotation" || C === "objectType" && (S.type === "IndexedAccessType" || S.type === "OptionalIndexedAccessType") || S.type === "NullableTypeAnnotation" || m.type === "FunctionTypeParam" && m.name === null && a(o).some((b) => b.typeAnnotation && b.typeAnnotation.type === "NullableTypeAnnotation");
              }
              case "OptionalIndexedAccessType":
                return C === "objectType" && m.type === "IndexedAccessType";
              case "StringLiteral":
              case "NumericLiteral":
              case "Literal":
                if (typeof o.value == "string" && m.type === "ExpressionStatement" && !m.directive) {
                  let S = D.getParentNode(1);
                  return S.type === "Program" || S.type === "BlockStatement";
                }
                return C === "object" && m.type === "MemberExpression" && typeof o.value == "number";
              case "AssignmentExpression": {
                let S = D.getParentNode(1);
                return C === "body" && m.type === "ArrowFunctionExpression" ? true : C === "key" && (m.type === "ClassProperty" || m.type === "PropertyDefinition") && m.computed || (C === "init" || C === "update") && m.type === "ForStatement" ? false : m.type === "ExpressionStatement" ? o.left.type === "ObjectPattern" : !(C === "key" && m.type === "TSPropertySignature" || m.type === "AssignmentExpression" || m.type === "SequenceExpression" && S && S.type === "ForStatement" && (S.init === m || S.update === m) || C === "value" && m.type === "Property" && S && S.type === "ObjectPattern" && S.properties.includes(m) || m.type === "NGChainedExpression");
              }
              case "ConditionalExpression":
                switch (m.type) {
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "BinaryExpression":
                  case "LogicalExpression":
                  case "NGPipeExpression":
                  case "ExportDefaultDeclaration":
                  case "AwaitExpression":
                  case "JSXSpreadAttribute":
                  case "TSTypeAssertion":
                  case "TypeCastExpression":
                  case "TSAsExpression":
                  case "TSSatisfiesExpression":
                  case "TSNonNullExpression":
                    return true;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return C === "callee";
                  case "ConditionalExpression":
                    return C === "test";
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return C === "object";
                  default:
                    return false;
                }
              case "FunctionExpression":
                switch (m.type) {
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return C === "callee";
                  case "TaggedTemplateExpression":
                    return true;
                  default:
                    return false;
                }
              case "ArrowFunctionExpression":
                switch (m.type) {
                  case "BinaryExpression":
                    return m.operator !== "|>" || o.extra && o.extra.parenthesized;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return C === "callee";
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return C === "object";
                  case "TSAsExpression":
                  case "TSSatisfiesExpression":
                  case "TSNonNullExpression":
                  case "BindExpression":
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "LogicalExpression":
                  case "AwaitExpression":
                  case "TSTypeAssertion":
                    return true;
                  case "ConditionalExpression":
                    return C === "test";
                  default:
                    return false;
                }
              case "ClassExpression":
                if (s(o.decorators))
                  return true;
                switch (m.type) {
                  case "NewExpression":
                    return C === "callee";
                  default:
                    return false;
                }
              case "OptionalMemberExpression":
              case "OptionalCallExpression": {
                let S = D.getParentNode(1);
                if (C === "object" && m.type === "MemberExpression" || C === "callee" && (m.type === "CallExpression" || m.type === "NewExpression") || m.type === "TSNonNullExpression" && S.type === "MemberExpression" && S.object === m)
                  return true;
              }
              case "CallExpression":
              case "MemberExpression":
              case "TaggedTemplateExpression":
              case "TSNonNullExpression":
                if (C === "callee" && (m.type === "BindExpression" || m.type === "NewExpression")) {
                  let S = o;
                  for (; S; )
                    switch (S.type) {
                      case "CallExpression":
                      case "OptionalCallExpression":
                        return true;
                      case "MemberExpression":
                      case "OptionalMemberExpression":
                      case "BindExpression":
                        S = S.object;
                        break;
                      case "TaggedTemplateExpression":
                        S = S.tag;
                        break;
                      case "TSNonNullExpression":
                        S = S.expression;
                        break;
                      default:
                        return false;
                    }
                }
                return false;
              case "BindExpression":
                return C === "callee" && (m.type === "BindExpression" || m.type === "NewExpression") || C === "object" && f(m);
              case "NGPipeExpression":
                return !(m.type === "NGRoot" || m.type === "NGMicrosyntaxExpression" || m.type === "ObjectProperty" && !(o.extra && o.extra.parenthesized) || m.type === "ArrayExpression" || c(m) && m.arguments[C] === o || C === "right" && m.type === "NGPipeExpression" || C === "property" && m.type === "MemberExpression" || m.type === "AssignmentExpression");
              case "JSXFragment":
              case "JSXElement":
                return C === "callee" || C === "left" && m.type === "BinaryExpression" && m.operator === "<" || m.type !== "ArrayExpression" && m.type !== "ArrowFunctionExpression" && m.type !== "AssignmentExpression" && m.type !== "AssignmentPattern" && m.type !== "BinaryExpression" && m.type !== "NewExpression" && m.type !== "ConditionalExpression" && m.type !== "ExpressionStatement" && m.type !== "JsExpressionRoot" && m.type !== "JSXAttribute" && m.type !== "JSXElement" && m.type !== "JSXExpressionContainer" && m.type !== "JSXFragment" && m.type !== "LogicalExpression" && !c(m) && !F(m) && m.type !== "ReturnStatement" && m.type !== "ThrowStatement" && m.type !== "TypeCastExpression" && m.type !== "VariableDeclarator" && m.type !== "YieldExpression";
              case "TypeAnnotation":
                return C === "returnType" && m.type === "ArrowFunctionExpression" && x(o);
            }
            return false;
          }
          function E(D) {
            return D.type === "BlockStatement" || D.type === "BreakStatement" || D.type === "ClassBody" || D.type === "ClassDeclaration" || D.type === "ClassMethod" || D.type === "ClassProperty" || D.type === "PropertyDefinition" || D.type === "ClassPrivateProperty" || D.type === "ContinueStatement" || D.type === "DebuggerStatement" || D.type === "DeclareClass" || D.type === "DeclareExportAllDeclaration" || D.type === "DeclareExportDeclaration" || D.type === "DeclareFunction" || D.type === "DeclareInterface" || D.type === "DeclareModule" || D.type === "DeclareModuleExports" || D.type === "DeclareVariable" || D.type === "DoWhileStatement" || D.type === "EnumDeclaration" || D.type === "ExportAllDeclaration" || D.type === "ExportDefaultDeclaration" || D.type === "ExportNamedDeclaration" || D.type === "ExpressionStatement" || D.type === "ForInStatement" || D.type === "ForOfStatement" || D.type === "ForStatement" || D.type === "FunctionDeclaration" || D.type === "IfStatement" || D.type === "ImportDeclaration" || D.type === "InterfaceDeclaration" || D.type === "LabeledStatement" || D.type === "MethodDefinition" || D.type === "ReturnStatement" || D.type === "SwitchStatement" || D.type === "ThrowStatement" || D.type === "TryStatement" || D.type === "TSDeclareFunction" || D.type === "TSEnumDeclaration" || D.type === "TSImportEqualsDeclaration" || D.type === "TSInterfaceDeclaration" || D.type === "TSModuleDeclaration" || D.type === "TSNamespaceExportDeclaration" || D.type === "TypeAlias" || D.type === "VariableDeclaration" || D.type === "WhileStatement" || D.type === "WithStatement";
          }
          function N2(D) {
            let T = 0, m = D.getValue();
            for (; m; ) {
              let C = D.getParentNode(T++);
              if (C && C.type === "ForStatement" && C.init === m)
                return true;
              m = C;
            }
            return false;
          }
          function x(D) {
            return l(D, (T) => T.type === "ObjectTypeAnnotation" && l(T, (m) => m.type === "FunctionTypeAnnotation" || void 0) || void 0);
          }
          function I2(D) {
            switch (D.type) {
              case "ObjectExpression":
                return true;
              default:
                return false;
            }
          }
          function P(D) {
            let T = D.getValue(), m = D.getParentNode(), C = D.getName();
            switch (m.type) {
              case "NGPipeExpression":
                if (typeof C == "number" && m.arguments[C] === T && m.arguments.length - 1 === C)
                  return D.callParent(P);
                break;
              case "ObjectProperty":
                if (C === "value") {
                  let o = D.getParentNode(1);
                  return t(o.properties) === m;
                }
                break;
              case "BinaryExpression":
              case "LogicalExpression":
                if (C === "right")
                  return D.callParent(P);
                break;
              case "ConditionalExpression":
                if (C === "alternate")
                  return D.callParent(P);
                break;
              case "UnaryExpression":
                if (m.prefix)
                  return D.callParent(P);
                break;
            }
            return false;
          }
          function $2(D, T) {
            let m = D.getValue(), C = D.getParentNode();
            return m.type === "FunctionExpression" || m.type === "ClassExpression" ? C.type === "ExportDefaultDeclaration" || !w(D, T) : !i(m) || C.type !== "ExportDefaultDeclaration" && w(D, T) ? false : D.call((o) => $2(o, T), ...n(D, m));
          }
          r.exports = w;
        } }), Fo2 = te2({ "src/language-js/print-preprocess.js"(e, r) {
          ne2();
          function t(s, a) {
            switch (a.parser) {
              case "json":
              case "json5":
              case "json-stringify":
              case "__js_expression":
              case "__vue_expression":
              case "__vue_ts_expression":
                return Object.assign(Object.assign({}, s), {}, { type: a.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: s, comments: [], rootMarker: a.rootMarker });
              default:
                return s;
            }
          }
          r.exports = t;
        } }), pd2 = te2({ "src/language-js/print/html-binding.js"(e, r) {
          ne2();
          var { builders: { join: t, line: s, group: a, softline: n, indent: u } } = qe2();
          function i(p, y2, h) {
            let g2 = p.getValue();
            if (y2.__onHtmlBindingRoot && p.getName() === null && y2.__onHtmlBindingRoot(g2, y2), g2.type === "File") {
              if (y2.__isVueForBindingLeft)
                return p.call((c) => {
                  let f = t([",", s], c.map(h, "params")), { params: F } = c.getValue();
                  return F.length === 1 ? f : ["(", u([n, a(f)]), n, ")"];
                }, "program", "body", 0);
              if (y2.__isVueBindings)
                return p.call((c) => t([",", s], c.map(h, "params")), "program", "body", 0);
            }
          }
          function l(p) {
            switch (p.type) {
              case "MemberExpression":
                switch (p.property.type) {
                  case "Identifier":
                  case "NumericLiteral":
                  case "StringLiteral":
                    return l(p.object);
                }
                return false;
              case "Identifier":
                return true;
              default:
                return false;
            }
          }
          r.exports = { isVueEventBindingExpression: l, printHtmlBinding: i };
        } }), ru2 = te2({ "src/language-js/print/binaryish.js"(e, r) {
          ne2();
          var { printComments: t } = et2(), { getLast: s } = Ue2(), { builders: { join: a, line: n, softline: u, group: i, indent: l, align: p, indentIfBreak: y2 }, utils: { cleanDoc: h, getDocParts: g2, isConcat: c } } = qe2(), { hasLeadingOwnLineComment: f, isBinaryish: F, isJsxNode: _, shouldFlatten: w, hasComment: E, CommentCheckFlags: N2, isCallExpression: x, isMemberExpression: I2, isObjectProperty: P, isEnabledHackPipeline: $2 } = Ke2(), D = 0;
          function T(o, d2, v2) {
            let S = o.getValue(), b = o.getParentNode(), B = o.getParentNode(1), k = S !== b.body && (b.type === "IfStatement" || b.type === "WhileStatement" || b.type === "SwitchStatement" || b.type === "DoWhileStatement"), M2 = $2(d2) && S.operator === "|>", R2 = m(o, v2, d2, false, k);
            if (k)
              return R2;
            if (M2)
              return i(R2);
            if (x(b) && b.callee === S || b.type === "UnaryExpression" || I2(b) && !b.computed)
              return i([l([u, ...R2]), u]);
            let q = b.type === "ReturnStatement" || b.type === "ThrowStatement" || b.type === "JSXExpressionContainer" && B.type === "JSXAttribute" || S.operator !== "|" && b.type === "JsExpressionRoot" || S.type !== "NGPipeExpression" && (b.type === "NGRoot" && d2.parser === "__ng_binding" || b.type === "NGMicrosyntaxExpression" && B.type === "NGMicrosyntax" && B.body.length === 1) || S === b.body && b.type === "ArrowFunctionExpression" || S !== b.body && b.type === "ForStatement" || b.type === "ConditionalExpression" && B.type !== "ReturnStatement" && B.type !== "ThrowStatement" && !x(B) || b.type === "TemplateLiteral", J = b.type === "AssignmentExpression" || b.type === "VariableDeclarator" || b.type === "ClassProperty" || b.type === "PropertyDefinition" || b.type === "TSAbstractPropertyDefinition" || b.type === "ClassPrivateProperty" || P(b), L = F(S.left) && w(S.operator, S.left.operator);
            if (q || C(S) && !L || !C(S) && J)
              return i(R2);
            if (R2.length === 0)
              return "";
            let Q = _(S.right), V = R2.findIndex((W) => typeof W != "string" && !Array.isArray(W) && W.type === "group"), j = R2.slice(0, V === -1 ? 1 : V + 1), Y = R2.slice(j.length, Q ? -1 : void 0), ie2 = Symbol("logicalChain-" + ++D), ee2 = i([...j, l(Y)], { id: ie2 });
            if (!Q)
              return ee2;
            let ce2 = s(R2);
            return i([ee2, y2(ce2, { groupId: ie2 })]);
          }
          function m(o, d2, v2, S, b) {
            let B = o.getValue();
            if (!F(B))
              return [i(d2())];
            let k = [];
            w(B.operator, B.left.operator) ? k = o.call((Y) => m(Y, d2, v2, true, b), "left") : k.push(i(d2("left")));
            let M2 = C(B), R2 = (B.operator === "|>" || B.type === "NGPipeExpression" || B.operator === "|" && v2.parser === "__vue_expression") && !f(v2.originalText, B.right), q = B.type === "NGPipeExpression" ? "|" : B.operator, J = B.type === "NGPipeExpression" && B.arguments.length > 0 ? i(l([n, ": ", a([n, ": "], o.map(d2, "arguments").map((Y) => p(2, i(Y))))])) : "", L;
            if (M2)
              L = [q, " ", d2("right"), J];
            else {
              let ie2 = $2(v2) && q === "|>" ? o.call((ee2) => m(ee2, d2, v2, true, b), "right") : d2("right");
              L = [R2 ? n : "", q, R2 ? " " : n, ie2, J];
            }
            let Q = o.getParentNode(), V = E(B.left, N2.Trailing | N2.Line), j = V || !(b && B.type === "LogicalExpression") && Q.type !== B.type && B.left.type !== B.type && B.right.type !== B.type;
            if (k.push(R2 ? "" : " ", j ? i(L, { shouldBreak: V }) : L), S && E(B)) {
              let Y = h(t(o, k, v2));
              return c(Y) || Y.type === "fill" ? g2(Y) : [Y];
            }
            return k;
          }
          function C(o) {
            return o.type !== "LogicalExpression" ? false : !!(o.right.type === "ObjectExpression" && o.right.properties.length > 0 || o.right.type === "ArrayExpression" && o.right.elements.length > 0 || _(o.right));
          }
          r.exports = { printBinaryishExpression: T, shouldInlineLogicalExpression: C };
        } }), fd2 = te2({ "src/language-js/print/angular.js"(e, r) {
          ne2();
          var { builders: { join: t, line: s, group: a } } = qe2(), { hasNode: n, hasComment: u, getComments: i } = Ke2(), { printBinaryishExpression: l } = ru2();
          function p(g2, c, f) {
            let F = g2.getValue();
            if (F.type.startsWith("NG"))
              switch (F.type) {
                case "NGRoot":
                  return [f("node"), u(F.node) ? " //" + i(F.node)[0].value.trimEnd() : ""];
                case "NGPipeExpression":
                  return l(g2, c, f);
                case "NGChainedExpression":
                  return a(t([";", s], g2.map((_) => h(_) ? f() : ["(", f(), ")"], "expressions")));
                case "NGEmptyExpression":
                  return "";
                case "NGQuotedExpression":
                  return [F.prefix, ": ", F.value.trim()];
                case "NGMicrosyntax":
                  return g2.map((_, w) => [w === 0 ? "" : y2(_.getValue(), w, F) ? " " : [";", s], f()], "body");
                case "NGMicrosyntaxKey":
                  return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(F.name) ? F.name : JSON.stringify(F.name);
                case "NGMicrosyntaxExpression":
                  return [f("expression"), F.alias === null ? "" : [" as ", f("alias")]];
                case "NGMicrosyntaxKeyedExpression": {
                  let _ = g2.getName(), w = g2.getParentNode(), E = y2(F, _, w) || (_ === 1 && (F.key.name === "then" || F.key.name === "else") || _ === 2 && F.key.name === "else" && w.body[_ - 1].type === "NGMicrosyntaxKeyedExpression" && w.body[_ - 1].key.name === "then") && w.body[0].type === "NGMicrosyntaxExpression";
                  return [f("key"), E ? " " : ": ", f("expression")];
                }
                case "NGMicrosyntaxLet":
                  return ["let ", f("key"), F.value === null ? "" : [" = ", f("value")]];
                case "NGMicrosyntaxAs":
                  return [f("key"), " as ", f("alias")];
                default:
                  throw new Error(`Unknown Angular node type: ${JSON.stringify(F.type)}.`);
              }
          }
          function y2(g2, c, f) {
            return g2.type === "NGMicrosyntaxKeyedExpression" && g2.key.name === "of" && c === 1 && f.body[0].type === "NGMicrosyntaxLet" && f.body[0].value === null;
          }
          function h(g2) {
            return n(g2.getValue(), (c) => {
              switch (c.type) {
                case void 0:
                  return false;
                case "CallExpression":
                case "OptionalCallExpression":
                case "AssignmentExpression":
                  return true;
              }
            });
          }
          r.exports = { printAngular: p };
        } }), Dd2 = te2({ "src/language-js/print/jsx.js"(e, r) {
          ne2();
          var { printComments: t, printDanglingComments: s, printCommentsSeparately: a } = et2(), { builders: { line: n, hardline: u, softline: i, group: l, indent: p, conditionalGroup: y2, fill: h, ifBreak: g2, lineSuffixBoundary: c, join: f }, utils: { willBreak: F } } = qe2(), { getLast: _, getPreferredQuote: w } = Ue2(), { isJsxNode: E, rawText: N2, isCallExpression: x, isStringLiteral: I2, isBinaryish: P, hasComment: $2, CommentCheckFlags: D, hasNodeIgnoreComment: T } = Ke2(), m = qt2(), { willPrintOwnComments: C } = Eo2(), o = (U2) => U2 === "" || U2 === n || U2 === u || U2 === i;
          function d2(U2, Z, se2) {
            let fe2 = U2.getValue();
            if (fe2.type === "JSXElement" && de(fe2))
              return [se2("openingElement"), se2("closingElement")];
            let ge2 = fe2.type === "JSXElement" ? se2("openingElement") : se2("openingFragment"), he2 = fe2.type === "JSXElement" ? se2("closingElement") : se2("closingFragment");
            if (fe2.children.length === 1 && fe2.children[0].type === "JSXExpressionContainer" && (fe2.children[0].expression.type === "TemplateLiteral" || fe2.children[0].expression.type === "TaggedTemplateExpression"))
              return [ge2, ...U2.map(se2, "children"), he2];
            fe2.children = fe2.children.map((A) => Fe2(A) ? { type: "JSXText", value: " ", raw: " " } : A);
            let we2 = fe2.children.some(E), ke2 = fe2.children.filter((A) => A.type === "JSXExpressionContainer").length > 1, Re2 = fe2.type === "JSXElement" && fe2.openingElement.attributes.length > 1, Ne2 = F(ge2) || we2 || Re2 || ke2, Pe2 = U2.getParentNode().rootMarker === "mdx", oe = Z.singleQuote ? "{' '}" : '{" "}', H = Pe2 ? " " : g2([oe, i], " "), pe2 = fe2.openingElement && fe2.openingElement.name && fe2.openingElement.name.name === "fbt", X = v2(U2, Z, se2, H, pe2), le2 = fe2.children.some((A) => ue2(A));
            for (let A = X.length - 2; A >= 0; A--) {
              let G = X[A] === "" && X[A + 1] === "", re = X[A] === u && X[A + 1] === "" && X[A + 2] === u, ye2 = (X[A] === i || X[A] === u) && X[A + 1] === "" && X[A + 2] === H, Ce2 = X[A] === H && X[A + 1] === "" && (X[A + 2] === i || X[A + 2] === u), Be = X[A] === H && X[A + 1] === "" && X[A + 2] === H, ve2 = X[A] === i && X[A + 1] === "" && X[A + 2] === u || X[A] === u && X[A + 1] === "" && X[A + 2] === i;
              re && le2 || G || ye2 || Be || ve2 ? X.splice(A, 2) : Ce2 && X.splice(A + 1, 2);
            }
            for (; X.length > 0 && o(_(X)); )
              X.pop();
            for (; X.length > 1 && o(X[0]) && o(X[1]); )
              X.shift(), X.shift();
            let Ae2 = [];
            for (let [A, G] of X.entries()) {
              if (G === H) {
                if (A === 1 && X[A - 1] === "") {
                  if (X.length === 2) {
                    Ae2.push(oe);
                    continue;
                  }
                  Ae2.push([oe, u]);
                  continue;
                } else if (A === X.length - 1) {
                  Ae2.push(oe);
                  continue;
                } else if (X[A - 1] === "" && X[A - 2] === u) {
                  Ae2.push(oe);
                  continue;
                }
              }
              Ae2.push(G), F(G) && (Ne2 = true);
            }
            let Ee = le2 ? h(Ae2) : l(Ae2, { shouldBreak: true });
            if (Pe2)
              return Ee;
            let De2 = l([ge2, p([u, Ee]), u, he2]);
            return Ne2 ? De2 : y2([l([ge2, ...X, he2]), De2]);
          }
          function v2(U2, Z, se2, fe2, ge2) {
            let he2 = [];
            return U2.each((we2, ke2, Re2) => {
              let Ne2 = we2.getValue();
              if (Ne2.type === "JSXText") {
                let Pe2 = N2(Ne2);
                if (ue2(Ne2)) {
                  let oe = Pe2.split(ce2);
                  if (oe[0] === "") {
                    if (he2.push(""), oe.shift(), /\n/.test(oe[0])) {
                      let pe2 = Re2[ke2 + 1];
                      he2.push(b(ge2, oe[1], Ne2, pe2));
                    } else
                      he2.push(fe2);
                    oe.shift();
                  }
                  let H;
                  if (_(oe) === "" && (oe.pop(), H = oe.pop()), oe.length === 0)
                    return;
                  for (let [pe2, X] of oe.entries())
                    pe2 % 2 === 1 ? he2.push(n) : he2.push(X);
                  if (H !== void 0)
                    if (/\n/.test(H)) {
                      let pe2 = Re2[ke2 + 1];
                      he2.push(b(ge2, _(he2), Ne2, pe2));
                    } else
                      he2.push(fe2);
                  else {
                    let pe2 = Re2[ke2 + 1];
                    he2.push(S(ge2, _(he2), Ne2, pe2));
                  }
                } else
                  /\n/.test(Pe2) ? Pe2.match(/\n/g).length > 1 && he2.push("", u) : he2.push("", fe2);
              } else {
                let Pe2 = se2();
                he2.push(Pe2);
                let oe = Re2[ke2 + 1];
                if (oe && ue2(oe)) {
                  let pe2 = K2(N2(oe)).split(ce2)[0];
                  he2.push(S(ge2, pe2, Ne2, oe));
                } else
                  he2.push(u);
              }
            }, "children"), he2;
          }
          function S(U2, Z, se2, fe2) {
            return U2 ? "" : se2.type === "JSXElement" && !se2.closingElement || fe2 && fe2.type === "JSXElement" && !fe2.closingElement ? Z.length === 1 ? i : u : i;
          }
          function b(U2, Z, se2, fe2) {
            return U2 ? u : Z.length === 1 ? se2.type === "JSXElement" && !se2.closingElement || fe2 && fe2.type === "JSXElement" && !fe2.closingElement ? u : i : u;
          }
          function B(U2, Z, se2) {
            let fe2 = U2.getParentNode();
            if (!fe2 || { ArrayExpression: true, JSXAttribute: true, JSXElement: true, JSXExpressionContainer: true, JSXFragment: true, ExpressionStatement: true, CallExpression: true, OptionalCallExpression: true, ConditionalExpression: true, JsExpressionRoot: true }[fe2.type])
              return Z;
            let he2 = U2.match(void 0, (ke2) => ke2.type === "ArrowFunctionExpression", x, (ke2) => ke2.type === "JSXExpressionContainer"), we2 = m(U2, se2);
            return l([we2 ? "" : g2("("), p([i, Z]), i, we2 ? "" : g2(")")], { shouldBreak: he2 });
          }
          function k(U2, Z, se2) {
            let fe2 = U2.getValue(), ge2 = [];
            if (ge2.push(se2("name")), fe2.value) {
              let he2;
              if (I2(fe2.value)) {
                let ke2 = N2(fe2.value).slice(1, -1).replace(/&apos;/g, "'").replace(/&quot;/g, '"'), { escaped: Re2, quote: Ne2, regex: Pe2 } = w(ke2, Z.jsxSingleQuote ? "'" : '"');
                ke2 = ke2.replace(Pe2, Re2);
                let { leading: oe, trailing: H } = U2.call(() => a(U2, Z), "value");
                he2 = [oe, Ne2, ke2, Ne2, H];
              } else
                he2 = se2("value");
              ge2.push("=", he2);
            }
            return ge2;
          }
          function M2(U2, Z, se2) {
            let fe2 = U2.getValue(), ge2 = (he2, we2) => he2.type === "JSXEmptyExpression" || !$2(he2) && (he2.type === "ArrayExpression" || he2.type === "ObjectExpression" || he2.type === "ArrowFunctionExpression" || he2.type === "AwaitExpression" && (ge2(he2.argument, he2) || he2.argument.type === "JSXElement") || x(he2) || he2.type === "FunctionExpression" || he2.type === "TemplateLiteral" || he2.type === "TaggedTemplateExpression" || he2.type === "DoExpression" || E(we2) && (he2.type === "ConditionalExpression" || P(he2)));
            return ge2(fe2.expression, U2.getParentNode(0)) ? l(["{", se2("expression"), c, "}"]) : l(["{", p([i, se2("expression")]), i, c, "}"]);
          }
          function R2(U2, Z, se2) {
            let fe2 = U2.getValue(), ge2 = fe2.name && $2(fe2.name) || fe2.typeParameters && $2(fe2.typeParameters);
            if (fe2.selfClosing && fe2.attributes.length === 0 && !ge2)
              return ["<", se2("name"), se2("typeParameters"), " />"];
            if (fe2.attributes && fe2.attributes.length === 1 && fe2.attributes[0].value && I2(fe2.attributes[0].value) && !fe2.attributes[0].value.value.includes(`
`) && !ge2 && !$2(fe2.attributes[0]))
              return l(["<", se2("name"), se2("typeParameters"), " ", ...U2.map(se2, "attributes"), fe2.selfClosing ? " />" : ">"]);
            let he2 = fe2.attributes && fe2.attributes.some((ke2) => ke2.value && I2(ke2.value) && ke2.value.value.includes(`
`)), we2 = Z.singleAttributePerLine && fe2.attributes.length > 1 ? u : n;
            return l(["<", se2("name"), se2("typeParameters"), p(U2.map(() => [we2, se2()], "attributes")), ...q(fe2, Z, ge2)], { shouldBreak: he2 });
          }
          function q(U2, Z, se2) {
            return U2.selfClosing ? [n, "/>"] : J(U2, Z, se2) ? [">"] : [i, ">"];
          }
          function J(U2, Z, se2) {
            let fe2 = U2.attributes.length > 0 && $2(_(U2.attributes), D.Trailing);
            return U2.attributes.length === 0 && !se2 || (Z.bracketSameLine || Z.jsxBracketSameLine) && (!se2 || U2.attributes.length > 0) && !fe2;
          }
          function L(U2, Z, se2) {
            let fe2 = U2.getValue(), ge2 = [];
            ge2.push("</");
            let he2 = se2("name");
            return $2(fe2.name, D.Leading | D.Line) ? ge2.push(p([u, he2]), u) : $2(fe2.name, D.Leading | D.Block) ? ge2.push(" ", he2) : ge2.push(he2), ge2.push(">"), ge2;
          }
          function Q(U2, Z) {
            let se2 = U2.getValue(), fe2 = $2(se2), ge2 = $2(se2, D.Line), he2 = se2.type === "JSXOpeningFragment";
            return [he2 ? "<" : "</", p([ge2 ? u : fe2 && !he2 ? " " : "", s(U2, Z, true)]), ge2 ? u : "", ">"];
          }
          function V(U2, Z, se2) {
            let fe2 = t(U2, d2(U2, Z, se2), Z);
            return B(U2, fe2, Z);
          }
          function j(U2, Z) {
            let se2 = U2.getValue(), fe2 = $2(se2, D.Line);
            return [s(U2, Z, !fe2), fe2 ? u : ""];
          }
          function Y(U2, Z, se2) {
            let fe2 = U2.getValue();
            return ["{", U2.call((ge2) => {
              let he2 = ["...", se2()], we2 = ge2.getValue();
              return !$2(we2) || !C(ge2) ? he2 : [p([i, t(ge2, he2, Z)]), i];
            }, fe2.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
          }
          function ie2(U2, Z, se2) {
            let fe2 = U2.getValue();
            if (fe2.type.startsWith("JSX"))
              switch (fe2.type) {
                case "JSXAttribute":
                  return k(U2, Z, se2);
                case "JSXIdentifier":
                  return String(fe2.name);
                case "JSXNamespacedName":
                  return f(":", [se2("namespace"), se2("name")]);
                case "JSXMemberExpression":
                  return f(".", [se2("object"), se2("property")]);
                case "JSXSpreadAttribute":
                  return Y(U2, Z, se2);
                case "JSXSpreadChild":
                  return Y(U2, Z, se2);
                case "JSXExpressionContainer":
                  return M2(U2, Z, se2);
                case "JSXFragment":
                case "JSXElement":
                  return V(U2, Z, se2);
                case "JSXOpeningElement":
                  return R2(U2, Z, se2);
                case "JSXClosingElement":
                  return L(U2, Z, se2);
                case "JSXOpeningFragment":
                case "JSXClosingFragment":
                  return Q(U2, Z);
                case "JSXEmptyExpression":
                  return j(U2, Z);
                case "JSXText":
                  throw new Error("JSXText should be handled by JSXElement");
                default:
                  throw new Error(`Unknown JSX node type: ${JSON.stringify(fe2.type)}.`);
              }
          }
          var ee2 = ` 
\r	`, ce2 = new RegExp("([" + ee2 + "]+)"), W = new RegExp("[^" + ee2 + "]"), K2 = (U2) => U2.replace(new RegExp("(?:^" + ce2.source + "|" + ce2.source + "$)"), "");
          function de(U2) {
            if (U2.children.length === 0)
              return true;
            if (U2.children.length > 1)
              return false;
            let Z = U2.children[0];
            return Z.type === "JSXText" && !ue2(Z);
          }
          function ue2(U2) {
            return U2.type === "JSXText" && (W.test(N2(U2)) || !/\n/.test(N2(U2)));
          }
          function Fe2(U2) {
            return U2.type === "JSXExpressionContainer" && I2(U2.expression) && U2.expression.value === " " && !$2(U2.expression);
          }
          function z(U2) {
            let Z = U2.getValue(), se2 = U2.getParentNode();
            if (!se2 || !Z || !E(Z) || !E(se2))
              return false;
            let fe2 = se2.children.indexOf(Z), ge2 = null;
            for (let he2 = fe2; he2 > 0; he2--) {
              let we2 = se2.children[he2 - 1];
              if (!(we2.type === "JSXText" && !ue2(we2))) {
                ge2 = we2;
                break;
              }
            }
            return ge2 && ge2.type === "JSXExpressionContainer" && ge2.expression.type === "JSXEmptyExpression" && T(ge2.expression);
          }
          r.exports = { hasJsxIgnoreComment: z, printJsx: ie2 };
        } }), ct2 = te2({ "src/language-js/print/misc.js"(e, r) {
          ne2();
          var { isNonEmptyArray: t } = Ue2(), { builders: { indent: s, join: a, line: n } } = qe2(), { isFlowAnnotationComment: u } = Ke2();
          function i(_) {
            let w = _.getValue();
            return !w.optional || w.type === "Identifier" && w === _.getParentNode().key ? "" : w.type === "OptionalCallExpression" || w.type === "OptionalMemberExpression" && w.computed ? "?." : "?";
          }
          function l(_) {
            return _.getValue().definite || _.match(void 0, (w, E) => E === "id" && w.type === "VariableDeclarator" && w.definite) ? "!" : "";
          }
          function p(_, w, E) {
            let N2 = _.getValue();
            return N2.typeArguments ? E("typeArguments") : N2.typeParameters ? E("typeParameters") : "";
          }
          function y2(_, w, E) {
            let N2 = _.getValue();
            if (!N2.typeAnnotation)
              return "";
            let x = _.getParentNode(), I2 = x.type === "DeclareFunction" && x.id === N2;
            return u(w.originalText, N2.typeAnnotation) ? [" /*: ", E("typeAnnotation"), " */"] : [I2 ? "" : ": ", E("typeAnnotation")];
          }
          function h(_, w, E) {
            return ["::", E("callee")];
          }
          function g2(_, w, E) {
            let N2 = _.getValue();
            return t(N2.modifiers) ? [a(" ", _.map(E, "modifiers")), " "] : "";
          }
          function c(_, w, E) {
            return _.type === "EmptyStatement" ? ";" : _.type === "BlockStatement" || E ? [" ", w] : s([n, w]);
          }
          function f(_, w, E) {
            return ["...", E("argument"), y2(_, w, E)];
          }
          function F(_, w) {
            let E = _.slice(1, -1);
            if (E.includes('"') || E.includes("'"))
              return _;
            let N2 = w.singleQuote ? "'" : '"';
            return N2 + E + N2;
          }
          r.exports = { printOptionalToken: i, printDefiniteToken: l, printFunctionTypeParameters: p, printBindExpressionCallee: h, printTypeScriptModifiers: g2, printTypeAnnotation: y2, printRestSpread: f, adjustClause: c, printDirective: F };
        } }), er2 = te2({ "src/language-js/print/array.js"(e, r) {
          ne2();
          var { printDanglingComments: t } = et2(), { builders: { line: s, softline: a, hardline: n, group: u, indent: i, ifBreak: l, fill: p } } = qe2(), { getLast: y2, hasNewline: h } = Ue2(), { shouldPrintComma: g2, hasComment: c, CommentCheckFlags: f, isNextLineEmpty: F, isNumericLiteral: _, isSignedNumericLiteral: w } = Ke2(), { locStart: E } = ut2(), { printOptionalToken: N2, printTypeAnnotation: x } = ct2();
          function I2(T, m, C) {
            let o = T.getValue(), d2 = [], v2 = o.type === "TupleExpression" ? "#[" : "[", S = "]";
            if (o.elements.length === 0)
              c(o, f.Dangling) ? d2.push(u([v2, t(T, m), a, S])) : d2.push(v2, S);
            else {
              let b = y2(o.elements), B = !(b && b.type === "RestElement"), k = b === null, M2 = Symbol("array"), R2 = !m.__inJestEach && o.elements.length > 1 && o.elements.every((L, Q, V) => {
                let j = L && L.type;
                if (j !== "ArrayExpression" && j !== "ObjectExpression")
                  return false;
                let Y = V[Q + 1];
                if (Y && j !== Y.type)
                  return false;
                let ie2 = j === "ArrayExpression" ? "elements" : "properties";
                return L[ie2] && L[ie2].length > 1;
              }), q = P(o, m), J = B ? k ? "," : g2(m) ? q ? l(",", "", { groupId: M2 }) : l(",") : "" : "";
              d2.push(u([v2, i([a, q ? D(T, m, C, J) : [$2(T, m, "elements", C), J], t(T, m, true)]), a, S], { shouldBreak: R2, id: M2 }));
            }
            return d2.push(N2(T), x(T, m, C)), d2;
          }
          function P(T, m) {
            return T.elements.length > 1 && T.elements.every((C) => C && (_(C) || w(C) && !c(C.argument)) && !c(C, f.Trailing | f.Line, (o) => !h(m.originalText, E(o), { backwards: true })));
          }
          function $2(T, m, C, o) {
            let d2 = [], v2 = [];
            return T.each((S) => {
              d2.push(v2, u(o())), v2 = [",", s], S.getValue() && F(S.getValue(), m) && v2.push(a);
            }, C), d2;
          }
          function D(T, m, C, o) {
            let d2 = [];
            return T.each((v2, S, b) => {
              let B = S === b.length - 1;
              d2.push([C(), B ? o : ","]), B || d2.push(F(v2.getValue(), m) ? [n, n] : c(b[S + 1], f.Leading | f.Line) ? n : s);
            }, "elements"), p(d2);
          }
          r.exports = { printArray: I2, printArrayItems: $2, isConciselyPrintedArray: P };
        } }), Ao2 = te2({ "src/language-js/print/call-arguments.js"(e, r) {
          ne2();
          var { printDanglingComments: t } = et2(), { getLast: s, getPenultimate: a } = Ue2(), { getFunctionParameters: n, hasComment: u, CommentCheckFlags: i, isFunctionCompositionArgs: l, isJsxNode: p, isLongCurriedCallExpression: y2, shouldPrintComma: h, getCallArguments: g2, iterateCallArgumentsPath: c, isNextLineEmpty: f, isCallExpression: F, isStringLiteral: _, isObjectProperty: w, isTSTypeExpression: E } = Ke2(), { builders: { line: N2, hardline: x, softline: I2, group: P, indent: $2, conditionalGroup: D, ifBreak: T, breakParent: m }, utils: { willBreak: C } } = qe2(), { ArgExpansionBailout: o } = Qt2(), { isConciselyPrintedArray: d2 } = er2();
          function v2(q, J, L) {
            let Q = q.getValue(), V = Q.type === "ImportExpression", j = g2(Q);
            if (j.length === 0)
              return ["(", t(q, J, true), ")"];
            if (k(j))
              return ["(", L(["arguments", 0]), ", ", L(["arguments", 1]), ")"];
            let Y = false, ie2 = false, ee2 = j.length - 1, ce2 = [];
            c(q, (z, U2) => {
              let Z = z.getNode(), se2 = [L()];
              U2 === ee2 || (f(Z, J) ? (U2 === 0 && (ie2 = true), Y = true, se2.push(",", x, x)) : se2.push(",", N2)), ce2.push(se2);
            });
            let W = !(V || Q.callee && Q.callee.type === "Import") && h(J, "all") ? "," : "";
            function K2() {
              return P(["(", $2([N2, ...ce2]), W, N2, ")"], { shouldBreak: true });
            }
            if (Y || q.getParentNode().type !== "Decorator" && l(j))
              return K2();
            let de = B(j), ue2 = b(j, J);
            if (de || ue2) {
              if (de ? ce2.slice(1).some(C) : ce2.slice(0, -1).some(C))
                return K2();
              let z = [];
              try {
                q.try(() => {
                  c(q, (U2, Z) => {
                    de && Z === 0 && (z = [[L([], { expandFirstArg: true }), ce2.length > 1 ? "," : "", ie2 ? x : N2, ie2 ? x : ""], ...ce2.slice(1)]), ue2 && Z === ee2 && (z = [...ce2.slice(0, -1), L([], { expandLastArg: true })]);
                  });
                });
              } catch (U2) {
                if (U2 instanceof o)
                  return K2();
                throw U2;
              }
              return [ce2.some(C) ? m : "", D([["(", ...z, ")"], de ? ["(", P(z[0], { shouldBreak: true }), ...z.slice(1), ")"] : ["(", ...ce2.slice(0, -1), P(s(z), { shouldBreak: true }), ")"], K2()])];
            }
            let Fe2 = ["(", $2([I2, ...ce2]), T(W), I2, ")"];
            return y2(q) ? Fe2 : P(Fe2, { shouldBreak: ce2.some(C) || Y });
          }
          function S(q) {
            let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            return q.type === "ObjectExpression" && (q.properties.length > 0 || u(q)) || q.type === "ArrayExpression" && (q.elements.length > 0 || u(q)) || q.type === "TSTypeAssertion" && S(q.expression) || E(q) && S(q.expression) || q.type === "FunctionExpression" || q.type === "ArrowFunctionExpression" && (!q.returnType || !q.returnType.typeAnnotation || q.returnType.typeAnnotation.type !== "TSTypeReference" || M2(q.body)) && (q.body.type === "BlockStatement" || q.body.type === "ArrowFunctionExpression" && S(q.body, true) || q.body.type === "ObjectExpression" || q.body.type === "ArrayExpression" || !J && (F(q.body) || q.body.type === "ConditionalExpression") || p(q.body)) || q.type === "DoExpression" || q.type === "ModuleExpression";
          }
          function b(q, J) {
            let L = s(q), Q = a(q);
            return !u(L, i.Leading) && !u(L, i.Trailing) && S(L) && (!Q || Q.type !== L.type) && (q.length !== 2 || Q.type !== "ArrowFunctionExpression" || L.type !== "ArrayExpression") && !(q.length > 1 && L.type === "ArrayExpression" && d2(L, J));
          }
          function B(q) {
            if (q.length !== 2)
              return false;
            let [J, L] = q;
            return J.type === "ModuleExpression" && R2(L) ? true : !u(J) && (J.type === "FunctionExpression" || J.type === "ArrowFunctionExpression" && J.body.type === "BlockStatement") && L.type !== "FunctionExpression" && L.type !== "ArrowFunctionExpression" && L.type !== "ConditionalExpression" && !S(L);
          }
          function k(q) {
            return q.length === 2 && q[0].type === "ArrowFunctionExpression" && n(q[0]).length === 0 && q[0].body.type === "BlockStatement" && q[1].type === "ArrayExpression" && !q.some((J) => u(J));
          }
          function M2(q) {
            return q.type === "BlockStatement" && (q.body.some((J) => J.type !== "EmptyStatement") || u(q, i.Dangling));
          }
          function R2(q) {
            return q.type === "ObjectExpression" && q.properties.length === 1 && w(q.properties[0]) && q.properties[0].key.type === "Identifier" && q.properties[0].key.name === "type" && _(q.properties[0].value) && q.properties[0].value.value === "module";
          }
          r.exports = v2;
        } }), So2 = te2({ "src/language-js/print/member.js"(e, r) {
          ne2();
          var { builders: { softline: t, group: s, indent: a, label: n } } = qe2(), { isNumericLiteral: u, isMemberExpression: i, isCallExpression: l } = Ke2(), { printOptionalToken: p } = ct2();
          function y2(g2, c, f) {
            let F = g2.getValue(), _ = g2.getParentNode(), w, E = 0;
            do
              w = g2.getParentNode(E), E++;
            while (w && (i(w) || w.type === "TSNonNullExpression"));
            let N2 = f("object"), x = h(g2, c, f), I2 = w && (w.type === "NewExpression" || w.type === "BindExpression" || w.type === "AssignmentExpression" && w.left.type !== "Identifier") || F.computed || F.object.type === "Identifier" && F.property.type === "Identifier" && !i(_) || (_.type === "AssignmentExpression" || _.type === "VariableDeclarator") && (l(F.object) && F.object.arguments.length > 0 || F.object.type === "TSNonNullExpression" && l(F.object.expression) && F.object.expression.arguments.length > 0 || N2.label === "member-chain");
            return n(N2.label === "member-chain" ? "member-chain" : "member", [N2, I2 ? x : s(a([t, x]))]);
          }
          function h(g2, c, f) {
            let F = f("property"), _ = g2.getValue(), w = p(g2);
            return _.computed ? !_.property || u(_.property) ? [w, "[", F, "]"] : s([w, "[", a([t, F]), t, "]"]) : [w, ".", F];
          }
          r.exports = { printMemberExpression: y2, printMemberLookup: h };
        } }), md2 = te2({ "src/language-js/print/member-chain.js"(e, r) {
          ne2();
          var { printComments: t } = et2(), { getLast: s, isNextLineEmptyAfterIndex: a, getNextNonSpaceNonCommentCharacterIndex: n } = Ue2(), u = qt2(), { isCallExpression: i, isMemberExpression: l, isFunctionOrArrowExpression: p, isLongCurriedCallExpression: y2, isMemberish: h, isNumericLiteral: g2, isSimpleCallArgument: c, hasComment: f, CommentCheckFlags: F, isNextLineEmpty: _ } = Ke2(), { locEnd: w } = ut2(), { builders: { join: E, hardline: N2, group: x, indent: I2, conditionalGroup: P, breakParent: $2, label: D }, utils: { willBreak: T } } = qe2(), m = Ao2(), { printMemberLookup: C } = So2(), { printOptionalToken: o, printFunctionTypeParameters: d2, printBindExpressionCallee: v2 } = ct2();
          function S(b, B, k) {
            let M2 = b.getParentNode(), R2 = !M2 || M2.type === "ExpressionStatement", q = [];
            function J(Ne2) {
              let { originalText: Pe2 } = B, oe = n(Pe2, Ne2, w);
              return Pe2.charAt(oe) === ")" ? oe !== false && a(Pe2, oe + 1) : _(Ne2, B);
            }
            function L(Ne2) {
              let Pe2 = Ne2.getValue();
              i(Pe2) && (h(Pe2.callee) || i(Pe2.callee)) ? (q.unshift({ node: Pe2, printed: [t(Ne2, [o(Ne2), d2(Ne2, B, k), m(Ne2, B, k)], B), J(Pe2) ? N2 : ""] }), Ne2.call((oe) => L(oe), "callee")) : h(Pe2) ? (q.unshift({ node: Pe2, needsParens: u(Ne2, B), printed: t(Ne2, l(Pe2) ? C(Ne2, B, k) : v2(Ne2, B, k), B) }), Ne2.call((oe) => L(oe), "object")) : Pe2.type === "TSNonNullExpression" ? (q.unshift({ node: Pe2, printed: t(Ne2, "!", B) }), Ne2.call((oe) => L(oe), "expression")) : q.unshift({ node: Pe2, printed: k() });
            }
            let Q = b.getValue();
            q.unshift({ node: Q, printed: [o(b), d2(b, B, k), m(b, B, k)] }), Q.callee && b.call((Ne2) => L(Ne2), "callee");
            let V = [], j = [q[0]], Y = 1;
            for (; Y < q.length && (q[Y].node.type === "TSNonNullExpression" || i(q[Y].node) || l(q[Y].node) && q[Y].node.computed && g2(q[Y].node.property)); ++Y)
              j.push(q[Y]);
            if (!i(q[0].node))
              for (; Y + 1 < q.length && (h(q[Y].node) && h(q[Y + 1].node)); ++Y)
                j.push(q[Y]);
            V.push(j), j = [];
            let ie2 = false;
            for (; Y < q.length; ++Y) {
              if (ie2 && h(q[Y].node)) {
                if (q[Y].node.computed && g2(q[Y].node.property)) {
                  j.push(q[Y]);
                  continue;
                }
                V.push(j), j = [], ie2 = false;
              }
              (i(q[Y].node) || q[Y].node.type === "ImportExpression") && (ie2 = true), j.push(q[Y]), f(q[Y].node, F.Trailing) && (V.push(j), j = [], ie2 = false);
            }
            j.length > 0 && V.push(j);
            function ee2(Ne2) {
              return /^[A-Z]|^[$_]+$/.test(Ne2);
            }
            function ce2(Ne2) {
              return Ne2.length <= B.tabWidth;
            }
            function W(Ne2) {
              let Pe2 = Ne2[1].length > 0 && Ne2[1][0].node.computed;
              if (Ne2[0].length === 1) {
                let H = Ne2[0][0].node;
                return H.type === "ThisExpression" || H.type === "Identifier" && (ee2(H.name) || R2 && ce2(H.name) || Pe2);
              }
              let oe = s(Ne2[0]).node;
              return l(oe) && oe.property.type === "Identifier" && (ee2(oe.property.name) || Pe2);
            }
            let K2 = V.length >= 2 && !f(V[1][0].node) && W(V);
            function de(Ne2) {
              let Pe2 = Ne2.map((oe) => oe.printed);
              return Ne2.length > 0 && s(Ne2).needsParens ? ["(", ...Pe2, ")"] : Pe2;
            }
            function ue2(Ne2) {
              return Ne2.length === 0 ? "" : I2(x([N2, E(N2, Ne2.map(de))]));
            }
            let Fe2 = V.map(de), z = Fe2, U2 = K2 ? 3 : 2, Z = V.flat(), se2 = Z.slice(1, -1).some((Ne2) => f(Ne2.node, F.Leading)) || Z.slice(0, -1).some((Ne2) => f(Ne2.node, F.Trailing)) || V[U2] && f(V[U2][0].node, F.Leading);
            if (V.length <= U2 && !se2)
              return y2(b) ? z : x(z);
            let fe2 = s(V[K2 ? 1 : 0]).node, ge2 = !i(fe2) && J(fe2), he2 = [de(V[0]), K2 ? V.slice(1, 2).map(de) : "", ge2 ? N2 : "", ue2(V.slice(K2 ? 2 : 1))], we2 = q.map((Ne2) => {
              let { node: Pe2 } = Ne2;
              return Pe2;
            }).filter(i);
            function ke2() {
              let Ne2 = s(s(V)).node, Pe2 = s(Fe2);
              return i(Ne2) && T(Pe2) && we2.slice(0, -1).some((oe) => oe.arguments.some(p));
            }
            let Re2;
            return se2 || we2.length > 2 && we2.some((Ne2) => !Ne2.arguments.every((Pe2) => c(Pe2, 0))) || Fe2.slice(0, -1).some(T) || ke2() ? Re2 = x(he2) : Re2 = [T(z) || ge2 ? $2 : "", P([z, he2])], D("member-chain", Re2);
          }
          r.exports = S;
        } }), xo2 = te2({ "src/language-js/print/call-expression.js"(e, r) {
          ne2();
          var { builders: { join: t, group: s } } = qe2(), a = qt2(), { getCallArguments: n, hasFlowAnnotationComment: u, isCallExpression: i, isMemberish: l, isStringLiteral: p, isTemplateOnItsOwnLine: y2, isTestCall: h, iterateCallArgumentsPath: g2 } = Ke2(), c = md2(), f = Ao2(), { printOptionalToken: F, printFunctionTypeParameters: _ } = ct2();
          function w(N2, x, I2) {
            let P = N2.getValue(), $2 = N2.getParentNode(), D = P.type === "NewExpression", T = P.type === "ImportExpression", m = F(N2), C = n(P);
            if (C.length > 0 && (!T && !D && E(P, $2) || C.length === 1 && y2(C[0], x.originalText) || !D && h(P, $2))) {
              let v2 = [];
              return g2(N2, () => {
                v2.push(I2());
              }), [D ? "new " : "", I2("callee"), m, _(N2, x, I2), "(", t(", ", v2), ")"];
            }
            let o = (x.parser === "babel" || x.parser === "babel-flow") && P.callee && P.callee.type === "Identifier" && u(P.callee.trailingComments);
            if (o && (P.callee.trailingComments[0].printed = true), !T && !D && l(P.callee) && !N2.call((v2) => a(v2, x), "callee"))
              return c(N2, x, I2);
            let d2 = [D ? "new " : "", T ? "import" : I2("callee"), m, o ? `/*:: ${P.callee.trailingComments[0].value.slice(2).trim()} */` : "", _(N2, x, I2), f(N2, x, I2)];
            return T || i(P.callee) ? s(d2) : d2;
          }
          function E(N2, x) {
            if (N2.callee.type !== "Identifier")
              return false;
            if (N2.callee.name === "require")
              return true;
            if (N2.callee.name === "define") {
              let I2 = n(N2);
              return x.type === "ExpressionStatement" && (I2.length === 1 || I2.length === 2 && I2[0].type === "ArrayExpression" || I2.length === 3 && p(I2[0]) && I2[1].type === "ArrayExpression");
            }
            return false;
          }
          r.exports = { printCallExpression: w };
        } }), tr2 = te2({ "src/language-js/print/assignment.js"(e, r) {
          ne2();
          var { isNonEmptyArray: t, getStringWidth: s } = Ue2(), { builders: { line: a, group: n, indent: u, indentIfBreak: i, lineSuffixBoundary: l }, utils: { cleanDoc: p, willBreak: y2, canBreak: h } } = qe2(), { hasLeadingOwnLineComment: g2, isBinaryish: c, isStringLiteral: f, isLiteral: F, isNumericLiteral: _, isCallExpression: w, isMemberExpression: E, getCallArguments: N2, rawText: x, hasComment: I2, isSignedNumericLiteral: P, isObjectProperty: $2 } = Ke2(), { shouldInlineLogicalExpression: D } = ru2(), { printCallExpression: T } = xo2();
          function m(W, K2, de, ue2, Fe2, z) {
            let U2 = d2(W, K2, de, ue2, z), Z = de(z, { assignmentLayout: U2 });
            switch (U2) {
              case "break-after-operator":
                return n([n(ue2), Fe2, n(u([a, Z]))]);
              case "never-break-after-operator":
                return n([n(ue2), Fe2, " ", Z]);
              case "fluid": {
                let se2 = Symbol("assignment");
                return n([n(ue2), Fe2, n(u(a), { id: se2 }), l, i(Z, { groupId: se2 })]);
              }
              case "break-lhs":
                return n([ue2, Fe2, " ", n(Z)]);
              case "chain":
                return [n(ue2), Fe2, a, Z];
              case "chain-tail":
                return [n(ue2), Fe2, u([a, Z])];
              case "chain-tail-arrow-chain":
                return [n(ue2), Fe2, Z];
              case "only-left":
                return ue2;
            }
          }
          function C(W, K2, de) {
            let ue2 = W.getValue();
            return m(W, K2, de, de("left"), [" ", ue2.operator], "right");
          }
          function o(W, K2, de) {
            return m(W, K2, de, de("id"), " =", "init");
          }
          function d2(W, K2, de, ue2, Fe2) {
            let z = W.getValue(), U2 = z[Fe2];
            if (!U2)
              return "only-left";
            let Z = !b(U2);
            if (W.match(b, B, (he2) => !Z || he2.type !== "ExpressionStatement" && he2.type !== "VariableDeclaration"))
              return Z ? U2.type === "ArrowFunctionExpression" && U2.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
            if (!Z && b(U2.right) || g2(K2.originalText, U2))
              return "break-after-operator";
            if (U2.type === "CallExpression" && U2.callee.name === "require" || K2.parser === "json5" || K2.parser === "json")
              return "never-break-after-operator";
            if (S(z) || k(z) || q(z) || J(z) && h(ue2))
              return "break-lhs";
            let ge2 = ie2(z, ue2, K2);
            return W.call(() => v2(W, K2, de, ge2), Fe2) ? "break-after-operator" : ge2 || U2.type === "TemplateLiteral" || U2.type === "TaggedTemplateExpression" || U2.type === "BooleanLiteral" || _(U2) || U2.type === "ClassExpression" ? "never-break-after-operator" : "fluid";
          }
          function v2(W, K2, de, ue2) {
            let Fe2 = W.getValue();
            if (c(Fe2) && !D(Fe2))
              return true;
            switch (Fe2.type) {
              case "StringLiteralTypeAnnotation":
              case "SequenceExpression":
                return true;
              case "ConditionalExpression": {
                let { test: Z } = Fe2;
                return c(Z) && !D(Z);
              }
              case "ClassExpression":
                return t(Fe2.decorators);
            }
            if (ue2)
              return false;
            let z = Fe2, U2 = [];
            for (; ; )
              if (z.type === "UnaryExpression")
                z = z.argument, U2.push("argument");
              else if (z.type === "TSNonNullExpression")
                z = z.expression, U2.push("expression");
              else
                break;
            return !!(f(z) || W.call(() => V(W, K2, de), ...U2));
          }
          function S(W) {
            if (B(W)) {
              let K2 = W.left || W.id;
              return K2.type === "ObjectPattern" && K2.properties.length > 2 && K2.properties.some((de) => $2(de) && (!de.shorthand || de.value && de.value.type === "AssignmentPattern"));
            }
            return false;
          }
          function b(W) {
            return W.type === "AssignmentExpression";
          }
          function B(W) {
            return b(W) || W.type === "VariableDeclarator";
          }
          function k(W) {
            let K2 = M2(W);
            if (t(K2)) {
              let de = W.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
              if (K2.length > 1 && K2.some((ue2) => ue2[de] || ue2.default))
                return true;
            }
            return false;
          }
          function M2(W) {
            return R2(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
          }
          function R2(W) {
            return W.type === "TSTypeAliasDeclaration" || W.type === "TypeAlias";
          }
          function q(W) {
            if (W.type !== "VariableDeclarator")
              return false;
            let { typeAnnotation: K2 } = W.id;
            if (!K2 || !K2.typeAnnotation)
              return false;
            let de = L(K2.typeAnnotation);
            return t(de) && de.length > 1 && de.some((ue2) => t(L(ue2)) || ue2.type === "TSConditionalType");
          }
          function J(W) {
            return W.type === "VariableDeclarator" && W.init && W.init.type === "ArrowFunctionExpression";
          }
          function L(W) {
            return Q(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
          }
          function Q(W) {
            return W.type === "TSTypeReference" || W.type === "GenericTypeAnnotation";
          }
          function V(W, K2, de) {
            let ue2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, Fe2 = W.getValue(), z = () => V(W, K2, de, true);
            if (Fe2.type === "TSNonNullExpression")
              return W.call(z, "expression");
            if (w(Fe2)) {
              if (T(W, K2, de).label === "member-chain")
                return false;
              let Z = N2(Fe2);
              return !(Z.length === 0 || Z.length === 1 && Y(Z[0], K2)) || ee2(Fe2, de) ? false : W.call(z, "callee");
            }
            return E(Fe2) ? W.call(z, "object") : ue2 && (Fe2.type === "Identifier" || Fe2.type === "ThisExpression");
          }
          var j = 0.25;
          function Y(W, K2) {
            let { printWidth: de } = K2;
            if (I2(W))
              return false;
            let ue2 = de * j;
            if (W.type === "ThisExpression" || W.type === "Identifier" && W.name.length <= ue2 || P(W) && !I2(W.argument))
              return true;
            let Fe2 = W.type === "Literal" && "regex" in W && W.regex.pattern || W.type === "RegExpLiteral" && W.pattern;
            return Fe2 ? Fe2.length <= ue2 : f(W) ? x(W).length <= ue2 : W.type === "TemplateLiteral" ? W.expressions.length === 0 && W.quasis[0].value.raw.length <= ue2 && !W.quasis[0].value.raw.includes(`
`) : F(W);
          }
          function ie2(W, K2, de) {
            if (!$2(W))
              return false;
            K2 = p(K2);
            let ue2 = 3;
            return typeof K2 == "string" && s(K2) < de.tabWidth + ue2;
          }
          function ee2(W, K2) {
            let de = ce2(W);
            if (t(de)) {
              if (de.length > 1)
                return true;
              if (de.length === 1) {
                let Fe2 = de[0];
                if (Fe2.type === "TSUnionType" || Fe2.type === "UnionTypeAnnotation" || Fe2.type === "TSIntersectionType" || Fe2.type === "IntersectionTypeAnnotation" || Fe2.type === "TSTypeLiteral" || Fe2.type === "ObjectTypeAnnotation")
                  return true;
              }
              let ue2 = W.typeParameters ? "typeParameters" : "typeArguments";
              if (y2(K2(ue2)))
                return true;
            }
            return false;
          }
          function ce2(W) {
            return W.typeParameters && W.typeParameters.params || W.typeArguments && W.typeArguments.params;
          }
          r.exports = { printVariableDeclarator: o, printAssignmentExpression: C, printAssignment: m, isArrowFunctionVariableDeclarator: J };
        } }), Lr2 = te2({ "src/language-js/print/function-parameters.js"(e, r) {
          ne2();
          var { getNextNonSpaceNonCommentCharacter: t } = Ue2(), { printDanglingComments: s } = et2(), { builders: { line: a, hardline: n, softline: u, group: i, indent: l, ifBreak: p }, utils: { removeLines: y2, willBreak: h } } = qe2(), { getFunctionParameters: g2, iterateFunctionParametersPath: c, isSimpleType: f, isTestCall: F, isTypeAnnotationAFunction: _, isObjectType: w, isObjectTypePropertyAFunction: E, hasRestParameter: N2, shouldPrintComma: x, hasComment: I2, isNextLineEmpty: P } = Ke2(), { locEnd: $2 } = ut2(), { ArgExpansionBailout: D } = Qt2(), { printFunctionTypeParameters: T } = ct2();
          function m(v2, S, b, B, k) {
            let M2 = v2.getValue(), R2 = g2(M2), q = k ? T(v2, b, S) : "";
            if (R2.length === 0)
              return [q, "(", s(v2, b, true, (ie2) => t(b.originalText, ie2, $2) === ")"), ")"];
            let J = v2.getParentNode(), L = F(J), Q = C(M2), V = [];
            if (c(v2, (ie2, ee2) => {
              let ce2 = ee2 === R2.length - 1;
              ce2 && M2.rest && V.push("..."), V.push(S()), !ce2 && (V.push(","), L || Q ? V.push(" ") : P(R2[ee2], b) ? V.push(n, n) : V.push(a));
            }), B) {
              if (h(q) || h(V))
                throw new D();
              return i([y2(q), "(", y2(V), ")"]);
            }
            let j = R2.every((ie2) => !ie2.decorators);
            return Q && j ? [q, "(", ...V, ")"] : L ? [q, "(", ...V, ")"] : (E(J) || _(J) || J.type === "TypeAlias" || J.type === "UnionTypeAnnotation" || J.type === "TSUnionType" || J.type === "IntersectionTypeAnnotation" || J.type === "FunctionTypeAnnotation" && J.returnType === M2) && R2.length === 1 && R2[0].name === null && M2.this !== R2[0] && R2[0].typeAnnotation && M2.typeParameters === null && f(R2[0].typeAnnotation) && !M2.rest ? b.arrowParens === "always" ? ["(", ...V, ")"] : V : [q, "(", l([u, ...V]), p(!N2(M2) && x(b, "all") ? "," : ""), u, ")"];
          }
          function C(v2) {
            if (!v2)
              return false;
            let S = g2(v2);
            if (S.length !== 1)
              return false;
            let [b] = S;
            return !I2(b) && (b.type === "ObjectPattern" || b.type === "ArrayPattern" || b.type === "Identifier" && b.typeAnnotation && (b.typeAnnotation.type === "TypeAnnotation" || b.typeAnnotation.type === "TSTypeAnnotation") && w(b.typeAnnotation.typeAnnotation) || b.type === "FunctionTypeParam" && w(b.typeAnnotation) || b.type === "AssignmentPattern" && (b.left.type === "ObjectPattern" || b.left.type === "ArrayPattern") && (b.right.type === "Identifier" || b.right.type === "ObjectExpression" && b.right.properties.length === 0 || b.right.type === "ArrayExpression" && b.right.elements.length === 0));
          }
          function o(v2) {
            let S;
            return v2.returnType ? (S = v2.returnType, S.typeAnnotation && (S = S.typeAnnotation)) : v2.typeAnnotation && (S = v2.typeAnnotation), S;
          }
          function d2(v2, S) {
            let b = o(v2);
            if (!b)
              return false;
            let B = v2.typeParameters && v2.typeParameters.params;
            if (B) {
              if (B.length > 1)
                return false;
              if (B.length === 1) {
                let k = B[0];
                if (k.constraint || k.default)
                  return false;
              }
            }
            return g2(v2).length === 1 && (w(b) || h(S));
          }
          r.exports = { printFunctionParameters: m, shouldHugFunctionParameters: C, shouldGroupFunctionParameters: d2 };
        } }), Or2 = te2({ "src/language-js/print/type-annotation.js"(e, r) {
          ne2();
          var { printComments: t, printDanglingComments: s } = et2(), { isNonEmptyArray: a } = Ue2(), { builders: { group: n, join: u, line: i, softline: l, indent: p, align: y2, ifBreak: h } } = qe2(), g2 = qt2(), { locStart: c } = ut2(), { isSimpleType: f, isObjectType: F, hasLeadingOwnLineComment: _, isObjectTypePropertyAFunction: w, shouldPrintComma: E } = Ke2(), { printAssignment: N2 } = tr2(), { printFunctionParameters: x, shouldGroupFunctionParameters: I2 } = Lr2(), { printArrayItems: P } = er2();
          function $2(b) {
            if (f(b) || F(b))
              return true;
            if (b.type === "UnionTypeAnnotation" || b.type === "TSUnionType") {
              let B = b.types.filter((M2) => M2.type === "VoidTypeAnnotation" || M2.type === "TSVoidKeyword" || M2.type === "NullLiteralTypeAnnotation" || M2.type === "TSNullKeyword").length, k = b.types.some((M2) => M2.type === "ObjectTypeAnnotation" || M2.type === "TSTypeLiteral" || M2.type === "GenericTypeAnnotation" || M2.type === "TSTypeReference");
              if (b.types.length - 1 === B && k)
                return true;
            }
            return false;
          }
          function D(b, B, k) {
            let M2 = B.semi ? ";" : "", R2 = b.getValue(), q = [];
            return q.push("opaque type ", k("id"), k("typeParameters")), R2.supertype && q.push(": ", k("supertype")), R2.impltype && q.push(" = ", k("impltype")), q.push(M2), q;
          }
          function T(b, B, k) {
            let M2 = B.semi ? ";" : "", R2 = b.getValue(), q = [];
            R2.declare && q.push("declare "), q.push("type ", k("id"), k("typeParameters"));
            let J = R2.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
            return [N2(b, B, k, q, " =", J), M2];
          }
          function m(b, B, k) {
            let M2 = b.getValue(), R2 = b.map(k, "types"), q = [], J = false;
            for (let L = 0; L < R2.length; ++L)
              L === 0 ? q.push(R2[L]) : F(M2.types[L - 1]) && F(M2.types[L]) ? q.push([" & ", J ? p(R2[L]) : R2[L]]) : !F(M2.types[L - 1]) && !F(M2.types[L]) ? q.push(p([" &", i, R2[L]])) : (L > 1 && (J = true), q.push(" & ", L > 1 ? p(R2[L]) : R2[L]));
            return n(q);
          }
          function C(b, B, k) {
            let M2 = b.getValue(), R2 = b.getParentNode(), q = R2.type !== "TypeParameterInstantiation" && R2.type !== "TSTypeParameterInstantiation" && R2.type !== "GenericTypeAnnotation" && R2.type !== "TSTypeReference" && R2.type !== "TSTypeAssertion" && R2.type !== "TupleTypeAnnotation" && R2.type !== "TSTupleType" && !(R2.type === "FunctionTypeParam" && !R2.name && b.getParentNode(1).this !== R2) && !((R2.type === "TypeAlias" || R2.type === "VariableDeclarator" || R2.type === "TSTypeAliasDeclaration") && _(B.originalText, M2)), J = $2(M2), L = b.map((j) => {
              let Y = k();
              return J || (Y = y2(2, Y)), t(j, Y, B);
            }, "types");
            if (J)
              return u(" | ", L);
            let Q = q && !_(B.originalText, M2), V = [h([Q ? i : "", "| "]), u([i, "| "], L)];
            return g2(b, B) ? n([p(V), l]) : R2.type === "TupleTypeAnnotation" && R2.types.length > 1 || R2.type === "TSTupleType" && R2.elementTypes.length > 1 ? n([p([h(["(", l]), V]), l, h(")")]) : n(q ? p(V) : V);
          }
          function o(b, B, k) {
            let M2 = b.getValue(), R2 = [], q = b.getParentNode(0), J = b.getParentNode(1), L = b.getParentNode(2), Q = M2.type === "TSFunctionType" || !((q.type === "ObjectTypeProperty" || q.type === "ObjectTypeInternalSlot") && !q.variance && !q.optional && c(q) === c(M2) || q.type === "ObjectTypeCallProperty" || L && L.type === "DeclareFunction"), V = Q && (q.type === "TypeAnnotation" || q.type === "TSTypeAnnotation"), j = V && Q && (q.type === "TypeAnnotation" || q.type === "TSTypeAnnotation") && J.type === "ArrowFunctionExpression";
            w(q) && (Q = true, V = true), j && R2.push("(");
            let Y = x(b, k, B, false, true), ie2 = M2.returnType || M2.predicate || M2.typeAnnotation ? [Q ? " => " : ": ", k("returnType"), k("predicate"), k("typeAnnotation")] : "", ee2 = I2(M2, ie2);
            return R2.push(ee2 ? n(Y) : Y), ie2 && R2.push(ie2), j && R2.push(")"), n(R2);
          }
          function d2(b, B, k) {
            let M2 = b.getValue(), R2 = M2.type === "TSTupleType" ? "elementTypes" : "types", q = M2[R2], J = a(q), L = J ? l : "";
            return n(["[", p([L, P(b, B, R2, k)]), h(J && E(B, "all") ? "," : ""), s(b, B, true), L, "]"]);
          }
          function v2(b, B, k) {
            let M2 = b.getValue(), R2 = M2.type === "OptionalIndexedAccessType" && M2.optional ? "?.[" : "[";
            return [k("objectType"), R2, k("indexType"), "]"];
          }
          function S(b, B, k) {
            let M2 = b.getValue();
            return [M2.postfix ? "" : k, B("typeAnnotation"), M2.postfix ? k : ""];
          }
          r.exports = { printOpaqueType: D, printTypeAlias: T, printIntersectionType: m, printUnionType: C, printFunctionType: o, printTupleType: d2, printIndexedAccessType: v2, shouldHugType: $2, printJSDocType: S };
        } }), jr2 = te2({ "src/language-js/print/type-parameters.js"(e, r) {
          ne2();
          var { printDanglingComments: t } = et2(), { builders: { join: s, line: a, hardline: n, softline: u, group: i, indent: l, ifBreak: p } } = qe2(), { isTestCall: y2, hasComment: h, CommentCheckFlags: g2, isTSXFile: c, shouldPrintComma: f, getFunctionParameters: F, isObjectType: _, getTypeScriptMappedTypeModifier: w } = Ke2(), { createGroupIdMapper: E } = Ue2(), { shouldHugType: N2 } = Or2(), { isArrowFunctionVariableDeclarator: x } = tr2(), I2 = E("typeParameters");
          function P(T, m, C, o) {
            let d2 = T.getValue();
            if (!d2[o])
              return "";
            if (!Array.isArray(d2[o]))
              return C(o);
            let v2 = T.getNode(2), S = v2 && y2(v2), b = T.match((M2) => !(M2[o].length === 1 && _(M2[o][0])), void 0, (M2, R2) => R2 === "typeAnnotation", (M2) => M2.type === "Identifier", x);
            if (d2[o].length === 0 || !b && (S || d2[o].length === 1 && (d2[o][0].type === "NullableTypeAnnotation" || N2(d2[o][0]))))
              return ["<", s(", ", T.map(C, o)), $2(T, m), ">"];
            let k = d2.type === "TSTypeParameterInstantiation" ? "" : F(d2).length === 1 && c(m) && !d2[o][0].constraint && T.getParentNode().type === "ArrowFunctionExpression" ? "," : f(m, "all") ? p(",") : "";
            return i(["<", l([u, s([",", a], T.map(C, o))]), k, u, ">"], { id: I2(d2) });
          }
          function $2(T, m) {
            let C = T.getValue();
            if (!h(C, g2.Dangling))
              return "";
            let o = !h(C, g2.Line), d2 = t(T, m, o);
            return o ? d2 : [d2, n];
          }
          function D(T, m, C) {
            let o = T.getValue(), d2 = [o.type === "TSTypeParameter" && o.const ? "const " : ""], v2 = T.getParentNode();
            return v2.type === "TSMappedType" ? (v2.readonly && d2.push(w(v2.readonly, "readonly"), " "), d2.push("[", C("name")), o.constraint && d2.push(" in ", C("constraint")), v2.nameType && d2.push(" as ", T.callParent(() => C("nameType"))), d2.push("]"), d2) : (o.variance && d2.push(C("variance")), o.in && d2.push("in "), o.out && d2.push("out "), d2.push(C("name")), o.bound && d2.push(": ", C("bound")), o.constraint && d2.push(" extends ", C("constraint")), o.default && d2.push(" = ", C("default")), d2);
          }
          r.exports = { printTypeParameter: D, printTypeParameters: P, getTypeParametersGroupId: I2 };
        } }), rr2 = te2({ "src/language-js/print/property.js"(e, r) {
          ne2();
          var { printComments: t } = et2(), { printString: s, printNumber: a } = Ue2(), { isNumericLiteral: n, isSimpleNumber: u, isStringLiteral: i, isStringPropSafeToUnquote: l, rawText: p } = Ke2(), { printAssignment: y2 } = tr2(), h = /* @__PURE__ */ new WeakMap();
          function g2(f, F, _) {
            let w = f.getNode();
            if (w.computed)
              return ["[", _("key"), "]"];
            let E = f.getParentNode(), { key: N2 } = w;
            if (F.quoteProps === "consistent" && !h.has(E)) {
              let x = (E.properties || E.body || E.members).some((I2) => !I2.computed && I2.key && i(I2.key) && !l(I2, F));
              h.set(E, x);
            }
            if ((N2.type === "Identifier" || n(N2) && u(a(p(N2))) && String(N2.value) === a(p(N2)) && !(F.parser === "typescript" || F.parser === "babel-ts")) && (F.parser === "json" || F.quoteProps === "consistent" && h.get(E))) {
              let x = s(JSON.stringify(N2.type === "Identifier" ? N2.name : N2.value.toString()), F);
              return f.call((I2) => t(I2, x, F), "key");
            }
            return l(w, F) && (F.quoteProps === "as-needed" || F.quoteProps === "consistent" && !h.get(E)) ? f.call((x) => t(x, /^\d/.test(N2.value) ? a(N2.value) : N2.value, F), "key") : _("key");
          }
          function c(f, F, _) {
            return f.getValue().shorthand ? _("value") : y2(f, F, _, g2(f, F, _), ":", "value");
          }
          r.exports = { printProperty: c, printPropertyKey: g2 };
        } }), qr = te2({ "src/language-js/print/function.js"(e, r) {
          ne2();
          var t = Zt2(), { printDanglingComments: s, printCommentsSeparately: a } = et2(), n = lt2(), { getNextNonSpaceNonCommentCharacterIndex: u } = Ue2(), { builders: { line: i, softline: l, group: p, indent: y2, ifBreak: h, hardline: g2, join: c, indentIfBreak: f }, utils: { removeLines: F, willBreak: _ } } = qe2(), { ArgExpansionBailout: w } = Qt2(), { getFunctionParameters: E, hasLeadingOwnLineComment: N2, isFlowAnnotationComment: x, isJsxNode: I2, isTemplateOnItsOwnLine: P, shouldPrintComma: $2, startsWithNoLookaheadToken: D, isBinaryish: T, isLineComment: m, hasComment: C, getComments: o, CommentCheckFlags: d2, isCallLikeExpression: v2, isCallExpression: S, getCallArguments: b, hasNakedLeftSide: B, getLeftSide: k } = Ke2(), { locEnd: M2 } = ut2(), { printFunctionParameters: R2, shouldGroupFunctionParameters: q } = Lr2(), { printPropertyKey: J } = rr2(), { printFunctionTypeParameters: L } = ct2();
          function Q(U2, Z, se2, fe2) {
            let ge2 = U2.getValue(), he2 = false;
            if ((ge2.type === "FunctionDeclaration" || ge2.type === "FunctionExpression") && fe2 && fe2.expandLastArg) {
              let Pe2 = U2.getParentNode();
              S(Pe2) && b(Pe2).length > 1 && (he2 = true);
            }
            let we2 = [];
            ge2.type === "TSDeclareFunction" && ge2.declare && we2.push("declare "), ge2.async && we2.push("async "), ge2.generator ? we2.push("function* ") : we2.push("function "), ge2.id && we2.push(Z("id"));
            let ke2 = R2(U2, Z, se2, he2), Re2 = K2(U2, Z, se2), Ne2 = q(ge2, Re2);
            return we2.push(L(U2, se2, Z), p([Ne2 ? p(ke2) : ke2, Re2]), ge2.body ? " " : "", Z("body")), se2.semi && (ge2.declare || !ge2.body) && we2.push(";"), we2;
          }
          function V(U2, Z, se2) {
            let fe2 = U2.getNode(), { kind: ge2 } = fe2, he2 = fe2.value || fe2, we2 = [];
            return !ge2 || ge2 === "init" || ge2 === "method" || ge2 === "constructor" ? he2.async && we2.push("async ") : (t.ok(ge2 === "get" || ge2 === "set"), we2.push(ge2, " ")), he2.generator && we2.push("*"), we2.push(J(U2, Z, se2), fe2.optional || fe2.key.optional ? "?" : ""), fe2 === he2 ? we2.push(j(U2, Z, se2)) : he2.type === "FunctionExpression" ? we2.push(U2.call((ke2) => j(ke2, Z, se2), "value")) : we2.push(se2("value")), we2;
          }
          function j(U2, Z, se2) {
            let fe2 = U2.getNode(), ge2 = R2(U2, se2, Z), he2 = K2(U2, se2, Z), we2 = q(fe2, he2), ke2 = [L(U2, Z, se2), p([we2 ? p(ge2) : ge2, he2])];
            return fe2.body ? ke2.push(" ", se2("body")) : ke2.push(Z.semi ? ";" : ""), ke2;
          }
          function Y(U2, Z, se2, fe2) {
            let ge2 = U2.getValue(), he2 = [];
            if (ge2.async && he2.push("async "), W(U2, Z))
              he2.push(se2(["params", 0]));
            else {
              let ke2 = fe2 && (fe2.expandLastArg || fe2.expandFirstArg), Re2 = K2(U2, se2, Z);
              if (ke2) {
                if (_(Re2))
                  throw new w();
                Re2 = p(F(Re2));
              }
              he2.push(p([R2(U2, se2, Z, ke2, true), Re2]));
            }
            let we2 = s(U2, Z, true, (ke2) => {
              let Re2 = u(Z.originalText, ke2, M2);
              return Re2 !== false && Z.originalText.slice(Re2, Re2 + 2) === "=>";
            });
            return we2 && he2.push(" ", we2), he2;
          }
          function ie2(U2, Z, se2, fe2, ge2, he2) {
            let we2 = U2.getName(), ke2 = U2.getParentNode(), Re2 = v2(ke2) && we2 === "callee", Ne2 = Boolean(Z && Z.assignmentLayout), Pe2 = he2.body.type !== "BlockStatement" && he2.body.type !== "ObjectExpression" && he2.body.type !== "SequenceExpression", oe = Re2 && Pe2 || Z && Z.assignmentLayout === "chain-tail-arrow-chain", H = Symbol("arrow-chain");
            return he2.body.type === "SequenceExpression" && (ge2 = p(["(", y2([l, ge2]), l, ")"])), p([p(y2([Re2 || Ne2 ? l : "", p(c([" =>", i], se2), { shouldBreak: fe2 })]), { id: H, shouldBreak: oe }), " =>", f(Pe2 ? y2([i, ge2]) : [" ", ge2], { groupId: H }), Re2 ? h(l, "", { groupId: H }) : ""]);
          }
          function ee2(U2, Z, se2, fe2) {
            let ge2 = U2.getValue(), he2 = [], we2 = [], ke2 = false;
            if (function H() {
              let pe2 = Y(U2, Z, se2, fe2);
              if (he2.length === 0)
                he2.push(pe2);
              else {
                let { leading: X, trailing: le2 } = a(U2, Z);
                he2.push([X, pe2]), we2.unshift(le2);
              }
              ke2 = ke2 || ge2.returnType && E(ge2).length > 0 || ge2.typeParameters || E(ge2).some((X) => X.type !== "Identifier"), ge2.body.type !== "ArrowFunctionExpression" || fe2 && fe2.expandLastArg ? we2.unshift(se2("body", fe2)) : (ge2 = ge2.body, U2.call(H, "body"));
            }(), he2.length > 1)
              return ie2(U2, fe2, he2, ke2, we2, ge2);
            let Re2 = he2;
            if (Re2.push(" =>"), !N2(Z.originalText, ge2.body) && (ge2.body.type === "ArrayExpression" || ge2.body.type === "ObjectExpression" || ge2.body.type === "BlockStatement" || I2(ge2.body) || P(ge2.body, Z.originalText) || ge2.body.type === "ArrowFunctionExpression" || ge2.body.type === "DoExpression"))
              return p([...Re2, " ", we2]);
            if (ge2.body.type === "SequenceExpression")
              return p([...Re2, p([" (", y2([l, we2]), l, ")"])]);
            let Ne2 = (fe2 && fe2.expandLastArg || U2.getParentNode().type === "JSXExpressionContainer") && !C(ge2), Pe2 = fe2 && fe2.expandLastArg && $2(Z, "all"), oe = ge2.body.type === "ConditionalExpression" && !D(ge2.body, (H) => H.type === "ObjectExpression");
            return p([...Re2, p([y2([i, oe ? h("", "(") : "", we2, oe ? h("", ")") : ""]), Ne2 ? [h(Pe2 ? "," : ""), l] : ""])]);
          }
          function ce2(U2) {
            let Z = E(U2);
            return Z.length === 1 && !U2.typeParameters && !C(U2, d2.Dangling) && Z[0].type === "Identifier" && !Z[0].typeAnnotation && !C(Z[0]) && !Z[0].optional && !U2.predicate && !U2.returnType;
          }
          function W(U2, Z) {
            if (Z.arrowParens === "always")
              return false;
            if (Z.arrowParens === "avoid") {
              let se2 = U2.getValue();
              return ce2(se2);
            }
            return false;
          }
          function K2(U2, Z, se2) {
            let fe2 = U2.getValue(), ge2 = Z("returnType");
            if (fe2.returnType && x(se2.originalText, fe2.returnType))
              return [" /*: ", ge2, " */"];
            let he2 = [ge2];
            return fe2.returnType && fe2.returnType.typeAnnotation && he2.unshift(": "), fe2.predicate && he2.push(fe2.returnType ? " " : ": ", Z("predicate")), he2;
          }
          function de(U2, Z, se2) {
            let fe2 = U2.getValue(), ge2 = Z.semi ? ";" : "", he2 = [];
            fe2.argument && (z(Z, fe2.argument) ? he2.push([" (", y2([g2, se2("argument")]), g2, ")"]) : T(fe2.argument) || fe2.argument.type === "SequenceExpression" ? he2.push(p([h(" (", " "), y2([l, se2("argument")]), l, h(")")])) : he2.push(" ", se2("argument")));
            let we2 = o(fe2), ke2 = n(we2), Re2 = ke2 && m(ke2);
            return Re2 && he2.push(ge2), C(fe2, d2.Dangling) && he2.push(" ", s(U2, Z, true)), Re2 || he2.push(ge2), he2;
          }
          function ue2(U2, Z, se2) {
            return ["return", de(U2, Z, se2)];
          }
          function Fe2(U2, Z, se2) {
            return ["throw", de(U2, Z, se2)];
          }
          function z(U2, Z) {
            if (N2(U2.originalText, Z))
              return true;
            if (B(Z)) {
              let se2 = Z, fe2;
              for (; fe2 = k(se2); )
                if (se2 = fe2, N2(U2.originalText, se2))
                  return true;
            }
            return false;
          }
          r.exports = { printFunction: Q, printArrowFunction: ee2, printMethod: V, printReturnStatement: ue2, printThrowStatement: Fe2, printMethodInternal: j, shouldPrintParamsWithoutParens: W };
        } }), nu2 = te2({ "src/language-js/print/decorators.js"(e, r) {
          ne2();
          var { isNonEmptyArray: t, hasNewline: s } = Ue2(), { builders: { line: a, hardline: n, join: u, breakParent: i, group: l } } = qe2(), { locStart: p, locEnd: y2 } = ut2(), { getParentExportDeclaration: h } = Ke2();
          function g2(w, E, N2) {
            let x = w.getValue();
            return l([u(a, w.map(N2, "decorators")), F(x, E) ? n : a]);
          }
          function c(w, E, N2) {
            return [u(n, w.map(N2, "declaration", "decorators")), n];
          }
          function f(w, E, N2) {
            let x = w.getValue(), { decorators: I2 } = x;
            if (!t(I2) || _(w.getParentNode()))
              return;
            let P = x.type === "ClassExpression" || x.type === "ClassDeclaration" || F(x, E);
            return [h(w) ? n : P ? i : "", u(a, w.map(N2, "decorators")), a];
          }
          function F(w, E) {
            return w.decorators.some((N2) => s(E.originalText, y2(N2)));
          }
          function _(w) {
            if (w.type !== "ExportDefaultDeclaration" && w.type !== "ExportNamedDeclaration" && w.type !== "DeclareExportDeclaration")
              return false;
            let E = w.declaration && w.declaration.decorators;
            return t(E) && p(w) === p(E[0]);
          }
          r.exports = { printDecorators: f, printClassMemberDecorators: g2, printDecoratorsBeforeExport: c, hasDecoratorsBeforeExport: _ };
        } }), nr2 = te2({ "src/language-js/print/class.js"(e, r) {
          ne2();
          var { isNonEmptyArray: t, createGroupIdMapper: s } = Ue2(), { printComments: a, printDanglingComments: n } = et2(), { builders: { join: u, line: i, hardline: l, softline: p, group: y2, indent: h, ifBreak: g2 } } = qe2(), { hasComment: c, CommentCheckFlags: f } = Ke2(), { getTypeParametersGroupId: F } = jr2(), { printMethod: _ } = qr(), { printOptionalToken: w, printTypeAnnotation: E, printDefiniteToken: N2 } = ct2(), { printPropertyKey: x } = rr2(), { printAssignment: I2 } = tr2(), { printClassMemberDecorators: P } = nu2();
          function $2(b, B, k) {
            let M2 = b.getValue(), R2 = [];
            M2.declare && R2.push("declare "), M2.abstract && R2.push("abstract "), R2.push("class");
            let q = M2.id && c(M2.id, f.Trailing) || M2.typeParameters && c(M2.typeParameters, f.Trailing) || M2.superClass && c(M2.superClass) || t(M2.extends) || t(M2.mixins) || t(M2.implements), J = [], L = [];
            if (M2.id && J.push(" ", k("id")), J.push(k("typeParameters")), M2.superClass) {
              let Q = [d2(b, B, k), k("superTypeParameters")], V = b.call((j) => ["extends ", a(j, Q, B)], "superClass");
              q ? L.push(i, y2(V)) : L.push(" ", V);
            } else
              L.push(o(b, B, k, "extends"));
            if (L.push(o(b, B, k, "mixins"), o(b, B, k, "implements")), q) {
              let Q;
              C(M2) ? Q = [...J, h(L)] : Q = h([...J, L]), R2.push(y2(Q, { id: D(M2) }));
            } else
              R2.push(...J, ...L);
            return R2.push(" ", k("body")), R2;
          }
          var D = s("heritageGroup");
          function T(b) {
            return g2(l, "", { groupId: D(b) });
          }
          function m(b) {
            return ["superClass", "extends", "mixins", "implements"].filter((B) => Boolean(b[B])).length > 1;
          }
          function C(b) {
            return b.typeParameters && !c(b.typeParameters, f.Trailing | f.Line) && !m(b);
          }
          function o(b, B, k, M2) {
            let R2 = b.getValue();
            if (!t(R2[M2]))
              return "";
            let q = n(b, B, true, (J) => {
              let { marker: L } = J;
              return L === M2;
            });
            return [C(R2) ? g2(" ", i, { groupId: F(R2.typeParameters) }) : i, q, q && l, M2, y2(h([i, u([",", i], b.map(k, M2))]))];
          }
          function d2(b, B, k) {
            let M2 = k("superClass");
            return b.getParentNode().type === "AssignmentExpression" ? y2(g2(["(", h([p, M2]), p, ")"], M2)) : M2;
          }
          function v2(b, B, k) {
            let M2 = b.getValue(), R2 = [];
            return t(M2.decorators) && R2.push(P(b, B, k)), M2.accessibility && R2.push(M2.accessibility + " "), M2.readonly && R2.push("readonly "), M2.declare && R2.push("declare "), M2.static && R2.push("static "), (M2.type === "TSAbstractMethodDefinition" || M2.abstract) && R2.push("abstract "), M2.override && R2.push("override "), R2.push(_(b, B, k)), R2;
          }
          function S(b, B, k) {
            let M2 = b.getValue(), R2 = [], q = B.semi ? ";" : "";
            return t(M2.decorators) && R2.push(P(b, B, k)), M2.accessibility && R2.push(M2.accessibility + " "), M2.declare && R2.push("declare "), M2.static && R2.push("static "), (M2.type === "TSAbstractPropertyDefinition" || M2.type === "TSAbstractAccessorProperty" || M2.abstract) && R2.push("abstract "), M2.override && R2.push("override "), M2.readonly && R2.push("readonly "), M2.variance && R2.push(k("variance")), (M2.type === "ClassAccessorProperty" || M2.type === "AccessorProperty" || M2.type === "TSAbstractAccessorProperty") && R2.push("accessor "), R2.push(x(b, B, k), w(b), N2(b), E(b, B, k)), [I2(b, B, k, R2, " =", "value"), q];
          }
          r.exports = { printClass: $2, printClassMethod: v2, printClassProperty: S, printHardlineAfterHeritage: T };
        } }), bo2 = te2({ "src/language-js/print/interface.js"(e, r) {
          ne2();
          var { isNonEmptyArray: t } = Ue2(), { builders: { join: s, line: a, group: n, indent: u, ifBreak: i } } = qe2(), { hasComment: l, identity: p, CommentCheckFlags: y2 } = Ke2(), { getTypeParametersGroupId: h } = jr2(), { printTypeScriptModifiers: g2 } = ct2();
          function c(f, F, _) {
            let w = f.getValue(), E = [];
            w.declare && E.push("declare "), w.type === "TSInterfaceDeclaration" && E.push(w.abstract ? "abstract " : "", g2(f, F, _)), E.push("interface");
            let N2 = [], x = [];
            w.type !== "InterfaceTypeAnnotation" && N2.push(" ", _("id"), _("typeParameters"));
            let I2 = w.typeParameters && !l(w.typeParameters, y2.Trailing | y2.Line);
            return t(w.extends) && x.push(I2 ? i(" ", a, { groupId: h(w.typeParameters) }) : a, "extends ", (w.extends.length === 1 ? p : u)(s([",", a], f.map(_, "extends")))), w.id && l(w.id, y2.Trailing) || t(w.extends) ? I2 ? E.push(n([...N2, u(x)])) : E.push(n(u([...N2, ...x]))) : E.push(...N2, ...x), E.push(" ", _("body")), n(E);
          }
          r.exports = { printInterface: c };
        } }), To2 = te2({ "src/language-js/print/module.js"(e, r) {
          ne2();
          var { isNonEmptyArray: t } = Ue2(), { builders: { softline: s, group: a, indent: n, join: u, line: i, ifBreak: l, hardline: p } } = qe2(), { printDanglingComments: y2 } = et2(), { hasComment: h, CommentCheckFlags: g2, shouldPrintComma: c, needsHardlineAfterDanglingComment: f, isStringLiteral: F, rawText: _ } = Ke2(), { locStart: w, hasSameLoc: E } = ut2(), { hasDecoratorsBeforeExport: N2, printDecoratorsBeforeExport: x } = nu2();
          function I2(S, b, B) {
            let k = S.getValue(), M2 = b.semi ? ";" : "", R2 = [], { importKind: q } = k;
            return R2.push("import"), q && q !== "value" && R2.push(" ", q), R2.push(m(S, b, B), T(S, b, B), o(S, b, B), M2), R2;
          }
          function P(S, b, B) {
            let k = S.getValue(), M2 = [];
            N2(k) && M2.push(x(S, b, B));
            let { type: R2, exportKind: q, declaration: J } = k;
            return M2.push("export"), (k.default || R2 === "ExportDefaultDeclaration") && M2.push(" default"), h(k, g2.Dangling) && (M2.push(" ", y2(S, b, true)), f(k) && M2.push(p)), J ? M2.push(" ", B("declaration")) : M2.push(q === "type" ? " type" : "", m(S, b, B), T(S, b, B), o(S, b, B)), D(k, b) && M2.push(";"), M2;
          }
          function $2(S, b, B) {
            let k = S.getValue(), M2 = b.semi ? ";" : "", R2 = [], { exportKind: q, exported: J } = k;
            return R2.push("export"), q === "type" && R2.push(" type"), R2.push(" *"), J && R2.push(" as ", B("exported")), R2.push(T(S, b, B), o(S, b, B), M2), R2;
          }
          function D(S, b) {
            if (!b.semi)
              return false;
            let { type: B, declaration: k } = S, M2 = S.default || B === "ExportDefaultDeclaration";
            if (!k)
              return true;
            let { type: R2 } = k;
            return !!(M2 && R2 !== "ClassDeclaration" && R2 !== "FunctionDeclaration" && R2 !== "TSInterfaceDeclaration" && R2 !== "DeclareClass" && R2 !== "DeclareFunction" && R2 !== "TSDeclareFunction" && R2 !== "EnumDeclaration");
          }
          function T(S, b, B) {
            let k = S.getValue();
            if (!k.source)
              return "";
            let M2 = [];
            return C(k, b) || M2.push(" from"), M2.push(" ", B("source")), M2;
          }
          function m(S, b, B) {
            let k = S.getValue();
            if (C(k, b))
              return "";
            let M2 = [" "];
            if (t(k.specifiers)) {
              let R2 = [], q = [];
              S.each(() => {
                let J = S.getValue().type;
                if (J === "ExportNamespaceSpecifier" || J === "ExportDefaultSpecifier" || J === "ImportNamespaceSpecifier" || J === "ImportDefaultSpecifier")
                  R2.push(B());
                else if (J === "ExportSpecifier" || J === "ImportSpecifier")
                  q.push(B());
                else
                  throw new Error(`Unknown specifier type ${JSON.stringify(J)}`);
              }, "specifiers"), M2.push(u(", ", R2)), q.length > 0 && (R2.length > 0 && M2.push(", "), q.length > 1 || R2.length > 0 || k.specifiers.some((L) => h(L)) ? M2.push(a(["{", n([b.bracketSpacing ? i : s, u([",", i], q)]), l(c(b) ? "," : ""), b.bracketSpacing ? i : s, "}"])) : M2.push(["{", b.bracketSpacing ? " " : "", ...q, b.bracketSpacing ? " " : "", "}"]));
            } else
              M2.push("{}");
            return M2;
          }
          function C(S, b) {
            let { type: B, importKind: k, source: M2, specifiers: R2 } = S;
            return B !== "ImportDeclaration" || t(R2) || k === "type" ? false : !/{\s*}/.test(b.originalText.slice(w(S), w(M2)));
          }
          function o(S, b, B) {
            let k = S.getNode();
            return t(k.assertions) ? [" assert {", b.bracketSpacing ? " " : "", u(", ", S.map(B, "assertions")), b.bracketSpacing ? " " : "", "}"] : "";
          }
          function d2(S, b, B) {
            let k = S.getNode(), { type: M2 } = k, R2 = [], q = M2 === "ImportSpecifier" ? k.importKind : k.exportKind;
            q && q !== "value" && R2.push(q, " ");
            let J = M2.startsWith("Import"), L = J ? "imported" : "local", Q = J ? "local" : "exported", V = k[L], j = k[Q], Y = "", ie2 = "";
            return M2 === "ExportNamespaceSpecifier" || M2 === "ImportNamespaceSpecifier" ? Y = "*" : V && (Y = B(L)), j && !v2(k) && (ie2 = B(Q)), R2.push(Y, Y && ie2 ? " as " : "", ie2), R2;
          }
          function v2(S) {
            if (S.type !== "ImportSpecifier" && S.type !== "ExportSpecifier")
              return false;
            let { local: b, [S.type === "ImportSpecifier" ? "imported" : "exported"]: B } = S;
            if (b.type !== B.type || !E(b, B))
              return false;
            if (F(b))
              return b.value === B.value && _(b) === _(B);
            switch (b.type) {
              case "Identifier":
                return b.name === B.name;
              default:
                return false;
            }
          }
          r.exports = { printImportDeclaration: I2, printExportDeclaration: P, printExportAllDeclaration: $2, printModuleSpecifier: d2 };
        } }), uu2 = te2({ "src/language-js/print/object.js"(e, r) {
          ne2();
          var { printDanglingComments: t } = et2(), { builders: { line: s, softline: a, group: n, indent: u, ifBreak: i, hardline: l } } = qe2(), { getLast: p, hasNewlineInRange: y2, hasNewline: h, isNonEmptyArray: g2 } = Ue2(), { shouldPrintComma: c, hasComment: f, getComments: F, CommentCheckFlags: _, isNextLineEmpty: w } = Ke2(), { locStart: E, locEnd: N2 } = ut2(), { printOptionalToken: x, printTypeAnnotation: I2 } = ct2(), { shouldHugFunctionParameters: P } = Lr2(), { shouldHugType: $2 } = Or2(), { printHardlineAfterHeritage: D } = nr2();
          function T(m, C, o) {
            let d2 = C.semi ? ";" : "", v2 = m.getValue(), S;
            v2.type === "TSTypeLiteral" ? S = "members" : v2.type === "TSInterfaceBody" ? S = "body" : S = "properties";
            let b = v2.type === "ObjectTypeAnnotation", B = [S];
            b && B.push("indexers", "callProperties", "internalSlots");
            let k = B.map((W) => v2[W][0]).sort((W, K2) => E(W) - E(K2))[0], M2 = m.getParentNode(0), R2 = b && M2 && (M2.type === "InterfaceDeclaration" || M2.type === "DeclareInterface" || M2.type === "DeclareClass") && m.getName() === "body", q = v2.type === "TSInterfaceBody" || R2 || v2.type === "ObjectPattern" && M2.type !== "FunctionDeclaration" && M2.type !== "FunctionExpression" && M2.type !== "ArrowFunctionExpression" && M2.type !== "ObjectMethod" && M2.type !== "ClassMethod" && M2.type !== "ClassPrivateMethod" && M2.type !== "AssignmentPattern" && M2.type !== "CatchClause" && v2.properties.some((W) => W.value && (W.value.type === "ObjectPattern" || W.value.type === "ArrayPattern")) || v2.type !== "ObjectPattern" && k && y2(C.originalText, E(v2), E(k)), J = R2 ? ";" : v2.type === "TSInterfaceBody" || v2.type === "TSTypeLiteral" ? i(d2, ";") : ",", L = v2.type === "RecordExpression" ? "#{" : v2.exact ? "{|" : "{", Q = v2.exact ? "|}" : "}", V = [];
            for (let W of B)
              m.each((K2) => {
                let de = K2.getValue();
                V.push({ node: de, printed: o(), loc: E(de) });
              }, W);
            B.length > 1 && V.sort((W, K2) => W.loc - K2.loc);
            let j = [], Y = V.map((W) => {
              let K2 = [...j, n(W.printed)];
              return j = [J, s], (W.node.type === "TSPropertySignature" || W.node.type === "TSMethodSignature" || W.node.type === "TSConstructSignatureDeclaration") && f(W.node, _.PrettierIgnore) && j.shift(), w(W.node, C) && j.push(l), K2;
            });
            if (v2.inexact) {
              let W;
              if (f(v2, _.Dangling)) {
                let K2 = f(v2, _.Line);
                W = [t(m, C, true), K2 || h(C.originalText, N2(p(F(v2)))) ? l : s, "..."];
              } else
                W = ["..."];
              Y.push([...j, ...W]);
            }
            let ie2 = p(v2[S]), ee2 = !(v2.inexact || ie2 && ie2.type === "RestElement" || ie2 && (ie2.type === "TSPropertySignature" || ie2.type === "TSCallSignatureDeclaration" || ie2.type === "TSMethodSignature" || ie2.type === "TSConstructSignatureDeclaration") && f(ie2, _.PrettierIgnore)), ce2;
            if (Y.length === 0) {
              if (!f(v2, _.Dangling))
                return [L, Q, I2(m, C, o)];
              ce2 = n([L, t(m, C), a, Q, x(m), I2(m, C, o)]);
            } else
              ce2 = [R2 && g2(v2.properties) ? D(M2) : "", L, u([C.bracketSpacing ? s : a, ...Y]), i(ee2 && (J !== "," || c(C)) ? J : ""), C.bracketSpacing ? s : a, Q, x(m), I2(m, C, o)];
            return m.match((W) => W.type === "ObjectPattern" && !W.decorators, (W, K2, de) => P(W) && (K2 === "params" || K2 === "parameters" || K2 === "this" || K2 === "rest") && de === 0) || m.match($2, (W, K2) => K2 === "typeAnnotation", (W, K2) => K2 === "typeAnnotation", (W, K2, de) => P(W) && (K2 === "params" || K2 === "parameters" || K2 === "this" || K2 === "rest") && de === 0) || !q && m.match((W) => W.type === "ObjectPattern", (W) => W.type === "AssignmentExpression" || W.type === "VariableDeclarator") ? ce2 : n(ce2, { shouldBreak: q });
          }
          r.exports = { printObject: T };
        } }), dd2 = te2({ "src/language-js/print/flow.js"(e, r) {
          ne2();
          var t = Zt2(), { printDanglingComments: s } = et2(), { printString: a, printNumber: n } = Ue2(), { builders: { hardline: u, softline: i, group: l, indent: p } } = qe2(), { getParentExportDeclaration: y2, isFunctionNotation: h, isGetterOrSetter: g2, rawText: c, shouldPrintComma: f } = Ke2(), { locStart: F, locEnd: _ } = ut2(), { replaceTextEndOfLine: w } = Yt2(), { printClass: E } = nr2(), { printOpaqueType: N2, printTypeAlias: x, printIntersectionType: I2, printUnionType: P, printFunctionType: $2, printTupleType: D, printIndexedAccessType: T } = Or2(), { printInterface: m } = bo2(), { printTypeParameter: C, printTypeParameters: o } = jr2(), { printExportDeclaration: d2, printExportAllDeclaration: v2 } = To2(), { printArrayItems: S } = er2(), { printObject: b } = uu2(), { printPropertyKey: B } = rr2(), { printOptionalToken: k, printTypeAnnotation: M2, printRestSpread: R2 } = ct2();
          function q(L, Q, V) {
            let j = L.getValue(), Y = Q.semi ? ";" : "", ie2 = [];
            switch (j.type) {
              case "DeclareClass":
                return J(L, E(L, Q, V));
              case "DeclareFunction":
                return J(L, ["function ", V("id"), j.predicate ? " " : "", V("predicate"), Y]);
              case "DeclareModule":
                return J(L, ["module ", V("id"), " ", V("body")]);
              case "DeclareModuleExports":
                return J(L, ["module.exports", ": ", V("typeAnnotation"), Y]);
              case "DeclareVariable":
                return J(L, ["var ", V("id"), Y]);
              case "DeclareOpaqueType":
                return J(L, N2(L, Q, V));
              case "DeclareInterface":
                return J(L, m(L, Q, V));
              case "DeclareTypeAlias":
                return J(L, x(L, Q, V));
              case "DeclareExportDeclaration":
                return J(L, d2(L, Q, V));
              case "DeclareExportAllDeclaration":
                return J(L, v2(L, Q, V));
              case "OpaqueType":
                return N2(L, Q, V);
              case "TypeAlias":
                return x(L, Q, V);
              case "IntersectionTypeAnnotation":
                return I2(L, Q, V);
              case "UnionTypeAnnotation":
                return P(L, Q, V);
              case "FunctionTypeAnnotation":
                return $2(L, Q, V);
              case "TupleTypeAnnotation":
                return D(L, Q, V);
              case "GenericTypeAnnotation":
                return [V("id"), o(L, Q, V, "typeParameters")];
              case "IndexedAccessType":
              case "OptionalIndexedAccessType":
                return T(L, Q, V);
              case "TypeAnnotation":
                return V("typeAnnotation");
              case "TypeParameter":
                return C(L, Q, V);
              case "TypeofTypeAnnotation":
                return ["typeof ", V("argument")];
              case "ExistsTypeAnnotation":
                return "*";
              case "EmptyTypeAnnotation":
                return "empty";
              case "MixedTypeAnnotation":
                return "mixed";
              case "ArrayTypeAnnotation":
                return [V("elementType"), "[]"];
              case "BooleanLiteralTypeAnnotation":
                return String(j.value);
              case "EnumDeclaration":
                return ["enum ", V("id"), " ", V("body")];
              case "EnumBooleanBody":
              case "EnumNumberBody":
              case "EnumStringBody":
              case "EnumSymbolBody": {
                if (j.type === "EnumSymbolBody" || j.explicitType) {
                  let ee2 = null;
                  switch (j.type) {
                    case "EnumBooleanBody":
                      ee2 = "boolean";
                      break;
                    case "EnumNumberBody":
                      ee2 = "number";
                      break;
                    case "EnumStringBody":
                      ee2 = "string";
                      break;
                    case "EnumSymbolBody":
                      ee2 = "symbol";
                      break;
                  }
                  ie2.push("of ", ee2, " ");
                }
                if (j.members.length === 0 && !j.hasUnknownMembers)
                  ie2.push(l(["{", s(L, Q), i, "}"]));
                else {
                  let ee2 = j.members.length > 0 ? [u, S(L, Q, "members", V), j.hasUnknownMembers || f(Q) ? "," : ""] : [];
                  ie2.push(l(["{", p([...ee2, ...j.hasUnknownMembers ? [u, "..."] : []]), s(L, Q, true), u, "}"]));
                }
                return ie2;
              }
              case "EnumBooleanMember":
              case "EnumNumberMember":
              case "EnumStringMember":
                return [V("id"), " = ", typeof j.init == "object" ? V("init") : String(j.init)];
              case "EnumDefaultedMember":
                return V("id");
              case "FunctionTypeParam": {
                let ee2 = j.name ? V("name") : L.getParentNode().this === j ? "this" : "";
                return [ee2, k(L), ee2 ? ": " : "", V("typeAnnotation")];
              }
              case "InterfaceDeclaration":
              case "InterfaceTypeAnnotation":
                return m(L, Q, V);
              case "ClassImplements":
              case "InterfaceExtends":
                return [V("id"), V("typeParameters")];
              case "NullableTypeAnnotation":
                return ["?", V("typeAnnotation")];
              case "Variance": {
                let { kind: ee2 } = j;
                return t.ok(ee2 === "plus" || ee2 === "minus"), ee2 === "plus" ? "+" : "-";
              }
              case "ObjectTypeCallProperty":
                return j.static && ie2.push("static "), ie2.push(V("value")), ie2;
              case "ObjectTypeIndexer":
                return [j.static ? "static " : "", j.variance ? V("variance") : "", "[", V("id"), j.id ? ": " : "", V("key"), "]: ", V("value")];
              case "ObjectTypeProperty": {
                let ee2 = "";
                return j.proto ? ee2 = "proto " : j.static && (ee2 = "static "), [ee2, g2(j) ? j.kind + " " : "", j.variance ? V("variance") : "", B(L, Q, V), k(L), h(j) ? "" : ": ", V("value")];
              }
              case "ObjectTypeAnnotation":
                return b(L, Q, V);
              case "ObjectTypeInternalSlot":
                return [j.static ? "static " : "", "[[", V("id"), "]]", k(L), j.method ? "" : ": ", V("value")];
              case "ObjectTypeSpreadProperty":
                return R2(L, Q, V);
              case "QualifiedTypeofIdentifier":
              case "QualifiedTypeIdentifier":
                return [V("qualification"), ".", V("id")];
              case "StringLiteralTypeAnnotation":
                return w(a(c(j), Q));
              case "NumberLiteralTypeAnnotation":
                t.strictEqual(typeof j.value, "number");
              case "BigIntLiteralTypeAnnotation":
                return j.extra ? n(j.extra.raw) : n(j.raw);
              case "TypeCastExpression":
                return ["(", V("expression"), M2(L, Q, V), ")"];
              case "TypeParameterDeclaration":
              case "TypeParameterInstantiation": {
                let ee2 = o(L, Q, V, "params");
                if (Q.parser === "flow") {
                  let ce2 = F(j), W = _(j), K2 = Q.originalText.lastIndexOf("/*", ce2), de = Q.originalText.indexOf("*/", W);
                  if (K2 !== -1 && de !== -1) {
                    let ue2 = Q.originalText.slice(K2 + 2, de).trim();
                    if (ue2.startsWith("::") && !ue2.includes("/*") && !ue2.includes("*/"))
                      return ["/*:: ", ee2, " */"];
                  }
                }
                return ee2;
              }
              case "InferredPredicate":
                return "%checks";
              case "DeclaredPredicate":
                return ["%checks(", V("value"), ")"];
              case "AnyTypeAnnotation":
                return "any";
              case "BooleanTypeAnnotation":
                return "boolean";
              case "BigIntTypeAnnotation":
                return "bigint";
              case "NullLiteralTypeAnnotation":
                return "null";
              case "NumberTypeAnnotation":
                return "number";
              case "SymbolTypeAnnotation":
                return "symbol";
              case "StringTypeAnnotation":
                return "string";
              case "VoidTypeAnnotation":
                return "void";
              case "ThisTypeAnnotation":
                return "this";
              case "Node":
              case "Printable":
              case "SourceLocation":
              case "Position":
              case "Statement":
              case "Function":
              case "Pattern":
              case "Expression":
              case "Declaration":
              case "Specifier":
              case "NamedSpecifier":
              case "Comment":
              case "MemberTypeAnnotation":
              case "Type":
                throw new Error("unprintable type: " + JSON.stringify(j.type));
            }
          }
          function J(L, Q) {
            let V = y2(L);
            return V ? (t.strictEqual(V.type, "DeclareExportDeclaration"), Q) : ["declare ", Q];
          }
          r.exports = { printFlow: q };
        } }), gd2 = te2({ "src/language-js/utils/is-ts-keyword-type.js"(e, r) {
          ne2();
          function t(s) {
            let { type: a } = s;
            return a.startsWith("TS") && a.endsWith("Keyword");
          }
          r.exports = t;
        } }), Bo2 = te2({ "src/language-js/print/ternary.js"(e, r) {
          ne2();
          var { hasNewlineInRange: t } = Ue2(), { isJsxNode: s, getComments: a, isCallExpression: n, isMemberExpression: u, isTSTypeExpression: i } = Ke2(), { locStart: l, locEnd: p } = ut2(), y2 = Pt2(), { builders: { line: h, softline: g2, group: c, indent: f, align: F, ifBreak: _, dedent: w, breakParent: E } } = qe2();
          function N2(D) {
            let T = [D];
            for (let m = 0; m < T.length; m++) {
              let C = T[m];
              for (let o of ["test", "consequent", "alternate"]) {
                let d2 = C[o];
                if (s(d2))
                  return true;
                d2.type === "ConditionalExpression" && T.push(d2);
              }
            }
            return false;
          }
          function x(D, T, m) {
            let C = D.getValue(), o = C.type === "ConditionalExpression", d2 = o ? "alternate" : "falseType", v2 = D.getParentNode(), S = o ? m("test") : [m("checkType"), " ", "extends", " ", m("extendsType")];
            return v2.type === C.type && v2[d2] === C ? F(2, S) : S;
          }
          var I2 = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
          function P(D) {
            let T = D.getValue();
            if (T.type !== "ConditionalExpression")
              return false;
            let m, C = T;
            for (let o = 0; !m; o++) {
              let d2 = D.getParentNode(o);
              if (n(d2) && d2.callee === C || u(d2) && d2.object === C || d2.type === "TSNonNullExpression" && d2.expression === C) {
                C = d2;
                continue;
              }
              d2.type === "NewExpression" && d2.callee === C || i(d2) && d2.expression === C ? (m = D.getParentNode(o + 1), C = d2) : m = d2;
            }
            return C === T ? false : m[I2.get(m.type)] === C;
          }
          function $2(D, T, m) {
            let C = D.getValue(), o = C.type === "ConditionalExpression", d2 = o ? "consequent" : "trueType", v2 = o ? "alternate" : "falseType", S = o ? ["test"] : ["checkType", "extendsType"], b = C[d2], B = C[v2], k = [], M2 = false, R2 = D.getParentNode(), q = R2.type === C.type && S.some((ue2) => R2[ue2] === C), J = R2.type === C.type && !q, L, Q, V = 0;
            do
              Q = L || C, L = D.getParentNode(V), V++;
            while (L && L.type === C.type && S.every((ue2) => L[ue2] !== Q));
            let j = L || R2, Y = Q;
            if (o && (s(C[S[0]]) || s(b) || s(B) || N2(Y))) {
              M2 = true, J = true;
              let ue2 = (z) => [_("("), f([g2, z]), g2, _(")")], Fe2 = (z) => z.type === "NullLiteral" || z.type === "Literal" && z.value === null || z.type === "Identifier" && z.name === "undefined";
              k.push(" ? ", Fe2(b) ? m(d2) : ue2(m(d2)), " : ", B.type === C.type || Fe2(B) ? m(v2) : ue2(m(v2)));
            } else {
              let ue2 = [h, "? ", b.type === C.type ? _("", "(") : "", F(2, m(d2)), b.type === C.type ? _("", ")") : "", h, ": ", B.type === C.type ? m(v2) : F(2, m(v2))];
              k.push(R2.type !== C.type || R2[v2] === C || q ? ue2 : T.useTabs ? w(f(ue2)) : F(Math.max(0, T.tabWidth - 2), ue2));
            }
            let ee2 = [...S.map((ue2) => a(C[ue2])), a(b), a(B)].flat().some((ue2) => y2(ue2) && t(T.originalText, l(ue2), p(ue2))), ce2 = (ue2) => R2 === j ? c(ue2, { shouldBreak: ee2 }) : ee2 ? [ue2, E] : ue2, W = !M2 && (u(R2) || R2.type === "NGPipeExpression" && R2.left === C) && !R2.computed, K2 = P(D), de = ce2([x(D, T, m), J ? k : f(k), o && W && !K2 ? g2 : ""]);
            return q || K2 ? c([f([g2, de]), g2]) : de;
          }
          r.exports = { printTernary: $2 };
        } }), No2 = te2({ "src/language-js/print/statement.js"(e, r) {
          ne2();
          var { builders: { hardline: t } } = qe2(), s = qt2(), { getLeftSidePathName: a, hasNakedLeftSide: n, isJsxNode: u, isTheOnlyJsxElementInMarkdown: i, hasComment: l, CommentCheckFlags: p, isNextLineEmpty: y2 } = Ke2(), { shouldPrintParamsWithoutParens: h } = qr();
          function g2(x, I2, P, $2) {
            let D = x.getValue(), T = [], m = D.type === "ClassBody", C = c(D[$2]);
            return x.each((o, d2, v2) => {
              let S = o.getValue();
              if (S.type === "EmptyStatement")
                return;
              let b = P();
              !I2.semi && !m && !i(I2, o) && f(o, I2) ? l(S, p.Leading) ? T.push(P([], { needsSemi: true })) : T.push(";", b) : T.push(b), !I2.semi && m && E(S) && N2(S, v2[d2 + 1]) && T.push(";"), S !== C && (T.push(t), y2(S, I2) && T.push(t));
            }, $2), T;
          }
          function c(x) {
            for (let I2 = x.length - 1; I2 >= 0; I2--) {
              let P = x[I2];
              if (P.type !== "EmptyStatement")
                return P;
            }
          }
          function f(x, I2) {
            return x.getNode().type !== "ExpressionStatement" ? false : x.call(($2) => F($2, I2), "expression");
          }
          function F(x, I2) {
            let P = x.getValue();
            switch (P.type) {
              case "ParenthesizedExpression":
              case "TypeCastExpression":
              case "ArrayExpression":
              case "ArrayPattern":
              case "TemplateLiteral":
              case "TemplateElement":
              case "RegExpLiteral":
                return true;
              case "ArrowFunctionExpression": {
                if (!h(x, I2))
                  return true;
                break;
              }
              case "UnaryExpression": {
                let { prefix: $2, operator: D } = P;
                if ($2 && (D === "+" || D === "-"))
                  return true;
                break;
              }
              case "BindExpression": {
                if (!P.object)
                  return true;
                break;
              }
              case "Literal": {
                if (P.regex)
                  return true;
                break;
              }
              default:
                if (u(P))
                  return true;
            }
            return s(x, I2) ? true : n(P) ? x.call(($2) => F($2, I2), ...a(x, P)) : false;
          }
          function _(x, I2, P) {
            return g2(x, I2, P, "body");
          }
          function w(x, I2, P) {
            return g2(x, I2, P, "consequent");
          }
          var E = (x) => {
            let { type: I2 } = x;
            return I2 === "ClassProperty" || I2 === "PropertyDefinition" || I2 === "ClassPrivateProperty" || I2 === "ClassAccessorProperty" || I2 === "AccessorProperty" || I2 === "TSAbstractPropertyDefinition" || I2 === "TSAbstractAccessorProperty";
          };
          function N2(x, I2) {
            let { type: P, name: $2 } = x.key;
            if (!x.computed && P === "Identifier" && ($2 === "static" || $2 === "get" || $2 === "set" || $2 === "accessor") && !x.value && !x.typeAnnotation)
              return true;
            if (!I2 || I2.static || I2.accessibility)
              return false;
            if (!I2.computed) {
              let D = I2.key && I2.key.name;
              if (D === "in" || D === "instanceof")
                return true;
            }
            if (E(I2) && I2.variance && !I2.static && !I2.declare)
              return true;
            switch (I2.type) {
              case "ClassProperty":
              case "PropertyDefinition":
              case "TSAbstractPropertyDefinition":
                return I2.computed;
              case "MethodDefinition":
              case "TSAbstractMethodDefinition":
              case "ClassMethod":
              case "ClassPrivateMethod": {
                if ((I2.value ? I2.value.async : I2.async) || I2.kind === "get" || I2.kind === "set")
                  return false;
                let T = I2.value ? I2.value.generator : I2.generator;
                return !!(I2.computed || T);
              }
              case "TSIndexSignature":
                return true;
            }
            return false;
          }
          r.exports = { printBody: _, printSwitchCaseConsequent: w };
        } }), wo2 = te2({ "src/language-js/print/block.js"(e, r) {
          ne2();
          var { printDanglingComments: t } = et2(), { isNonEmptyArray: s } = Ue2(), { builders: { hardline: a, indent: n } } = qe2(), { hasComment: u, CommentCheckFlags: i, isNextLineEmpty: l } = Ke2(), { printHardlineAfterHeritage: p } = nr2(), { printBody: y2 } = No2();
          function h(c, f, F) {
            let _ = c.getValue(), w = [];
            if (_.type === "StaticBlock" && w.push("static "), _.type === "ClassBody" && s(_.body)) {
              let N2 = c.getParentNode();
              w.push(p(N2));
            }
            w.push("{");
            let E = g2(c, f, F);
            if (E)
              w.push(n([a, E]), a);
            else {
              let N2 = c.getParentNode(), x = c.getParentNode(1);
              N2.type === "ArrowFunctionExpression" || N2.type === "FunctionExpression" || N2.type === "FunctionDeclaration" || N2.type === "ObjectMethod" || N2.type === "ClassMethod" || N2.type === "ClassPrivateMethod" || N2.type === "ForStatement" || N2.type === "WhileStatement" || N2.type === "DoWhileStatement" || N2.type === "DoExpression" || N2.type === "CatchClause" && !x.finalizer || N2.type === "TSModuleDeclaration" || N2.type === "TSDeclareFunction" || _.type === "StaticBlock" || _.type === "ClassBody" || w.push(a);
            }
            return w.push("}"), w;
          }
          function g2(c, f, F) {
            let _ = c.getValue(), w = s(_.directives), E = _.body.some((I2) => I2.type !== "EmptyStatement"), N2 = u(_, i.Dangling);
            if (!w && !E && !N2)
              return "";
            let x = [];
            if (w && c.each((I2, P, $2) => {
              x.push(F()), (P < $2.length - 1 || E || N2) && (x.push(a), l(I2.getValue(), f) && x.push(a));
            }, "directives"), E && x.push(y2(c, f, F)), N2 && x.push(t(c, f, true)), _.type === "Program") {
              let I2 = c.getParentNode();
              (!I2 || I2.type !== "ModuleExpression") && x.push(a);
            }
            return x;
          }
          r.exports = { printBlock: h, printBlockBody: g2 };
        } }), yd2 = te2({ "src/language-js/print/typescript.js"(e, r) {
          ne2();
          var { printDanglingComments: t } = et2(), { hasNewlineInRange: s } = Ue2(), { builders: { join: a, line: n, hardline: u, softline: i, group: l, indent: p, conditionalGroup: y2, ifBreak: h } } = qe2(), { isStringLiteral: g2, getTypeScriptMappedTypeModifier: c, shouldPrintComma: f, isCallExpression: F, isMemberExpression: _ } = Ke2(), w = gd2(), { locStart: E, locEnd: N2 } = ut2(), { printOptionalToken: x, printTypeScriptModifiers: I2 } = ct2(), { printTernary: P } = Bo2(), { printFunctionParameters: $2, shouldGroupFunctionParameters: D } = Lr2(), { printTemplateLiteral: T } = jt2(), { printArrayItems: m } = er2(), { printObject: C } = uu2(), { printClassProperty: o, printClassMethod: d2 } = nr2(), { printTypeParameter: v2, printTypeParameters: S } = jr2(), { printPropertyKey: b } = rr2(), { printFunction: B, printMethodInternal: k } = qr(), { printInterface: M2 } = bo2(), { printBlock: R2 } = wo2(), { printTypeAlias: q, printIntersectionType: J, printUnionType: L, printFunctionType: Q, printTupleType: V, printIndexedAccessType: j, printJSDocType: Y } = Or2();
          function ie2(ee2, ce2, W) {
            let K2 = ee2.getValue();
            if (!K2.type.startsWith("TS"))
              return;
            if (w(K2))
              return K2.type.slice(2, -7).toLowerCase();
            let de = ce2.semi ? ";" : "", ue2 = [];
            switch (K2.type) {
              case "TSThisType":
                return "this";
              case "TSTypeAssertion": {
                let Fe2 = !(K2.expression.type === "ArrayExpression" || K2.expression.type === "ObjectExpression"), z = l(["<", p([i, W("typeAnnotation")]), i, ">"]), U2 = [h("("), p([i, W("expression")]), i, h(")")];
                return Fe2 ? y2([[z, W("expression")], [z, l(U2, { shouldBreak: true })], [z, W("expression")]]) : l([z, W("expression")]);
              }
              case "TSDeclareFunction":
                return B(ee2, W, ce2);
              case "TSExportAssignment":
                return ["export = ", W("expression"), de];
              case "TSModuleBlock":
                return R2(ee2, ce2, W);
              case "TSInterfaceBody":
              case "TSTypeLiteral":
                return C(ee2, ce2, W);
              case "TSTypeAliasDeclaration":
                return q(ee2, ce2, W);
              case "TSQualifiedName":
                return a(".", [W("left"), W("right")]);
              case "TSAbstractMethodDefinition":
              case "TSDeclareMethod":
                return d2(ee2, ce2, W);
              case "TSAbstractAccessorProperty":
              case "TSAbstractPropertyDefinition":
                return o(ee2, ce2, W);
              case "TSInterfaceHeritage":
              case "TSExpressionWithTypeArguments":
                return ue2.push(W("expression")), K2.typeParameters && ue2.push(W("typeParameters")), ue2;
              case "TSTemplateLiteralType":
                return T(ee2, W, ce2);
              case "TSNamedTupleMember":
                return [W("label"), K2.optional ? "?" : "", ": ", W("elementType")];
              case "TSRestType":
                return ["...", W("typeAnnotation")];
              case "TSOptionalType":
                return [W("typeAnnotation"), "?"];
              case "TSInterfaceDeclaration":
                return M2(ee2, ce2, W);
              case "TSClassImplements":
                return [W("expression"), W("typeParameters")];
              case "TSTypeParameterDeclaration":
              case "TSTypeParameterInstantiation":
                return S(ee2, ce2, W, "params");
              case "TSTypeParameter":
                return v2(ee2, ce2, W);
              case "TSSatisfiesExpression":
              case "TSAsExpression": {
                let Fe2 = K2.type === "TSAsExpression" ? "as" : "satisfies";
                ue2.push(W("expression"), ` ${Fe2} `, W("typeAnnotation"));
                let z = ee2.getParentNode();
                return F(z) && z.callee === K2 || _(z) && z.object === K2 ? l([p([i, ...ue2]), i]) : ue2;
              }
              case "TSArrayType":
                return [W("elementType"), "[]"];
              case "TSPropertySignature":
                return K2.readonly && ue2.push("readonly "), ue2.push(b(ee2, ce2, W), x(ee2)), K2.typeAnnotation && ue2.push(": ", W("typeAnnotation")), K2.initializer && ue2.push(" = ", W("initializer")), ue2;
              case "TSParameterProperty":
                return K2.accessibility && ue2.push(K2.accessibility + " "), K2.export && ue2.push("export "), K2.static && ue2.push("static "), K2.override && ue2.push("override "), K2.readonly && ue2.push("readonly "), ue2.push(W("parameter")), ue2;
              case "TSTypeQuery":
                return ["typeof ", W("exprName"), W("typeParameters")];
              case "TSIndexSignature": {
                let Fe2 = ee2.getParentNode(), z = K2.parameters.length > 1 ? h(f(ce2) ? "," : "") : "", U2 = l([p([i, a([", ", i], ee2.map(W, "parameters"))]), z, i]);
                return [K2.export ? "export " : "", K2.accessibility ? [K2.accessibility, " "] : "", K2.static ? "static " : "", K2.readonly ? "readonly " : "", K2.declare ? "declare " : "", "[", K2.parameters ? U2 : "", K2.typeAnnotation ? "]: " : "]", K2.typeAnnotation ? W("typeAnnotation") : "", Fe2.type === "ClassBody" ? de : ""];
              }
              case "TSTypePredicate":
                return [K2.asserts ? "asserts " : "", W("parameterName"), K2.typeAnnotation ? [" is ", W("typeAnnotation")] : ""];
              case "TSNonNullExpression":
                return [W("expression"), "!"];
              case "TSImportType":
                return [K2.isTypeOf ? "typeof " : "", "import(", W(K2.parameter ? "parameter" : "argument"), ")", K2.qualifier ? [".", W("qualifier")] : "", S(ee2, ce2, W, "typeParameters")];
              case "TSLiteralType":
                return W("literal");
              case "TSIndexedAccessType":
                return j(ee2, ce2, W);
              case "TSConstructSignatureDeclaration":
              case "TSCallSignatureDeclaration":
              case "TSConstructorType": {
                if (K2.type === "TSConstructorType" && K2.abstract && ue2.push("abstract "), K2.type !== "TSCallSignatureDeclaration" && ue2.push("new "), ue2.push(l($2(ee2, W, ce2, false, true))), K2.returnType || K2.typeAnnotation) {
                  let Fe2 = K2.type === "TSConstructorType";
                  ue2.push(Fe2 ? " => " : ": ", W("returnType"), W("typeAnnotation"));
                }
                return ue2;
              }
              case "TSTypeOperator":
                return [K2.operator, " ", W("typeAnnotation")];
              case "TSMappedType": {
                let Fe2 = s(ce2.originalText, E(K2), N2(K2));
                return l(["{", p([ce2.bracketSpacing ? n : i, W("typeParameter"), K2.optional ? c(K2.optional, "?") : "", K2.typeAnnotation ? ": " : "", W("typeAnnotation"), h(de)]), t(ee2, ce2, true), ce2.bracketSpacing ? n : i, "}"], { shouldBreak: Fe2 });
              }
              case "TSMethodSignature": {
                let Fe2 = K2.kind && K2.kind !== "method" ? `${K2.kind} ` : "";
                ue2.push(K2.accessibility ? [K2.accessibility, " "] : "", Fe2, K2.export ? "export " : "", K2.static ? "static " : "", K2.readonly ? "readonly " : "", K2.abstract ? "abstract " : "", K2.declare ? "declare " : "", K2.computed ? "[" : "", W("key"), K2.computed ? "]" : "", x(ee2));
                let z = $2(ee2, W, ce2, false, true), U2 = K2.returnType ? "returnType" : "typeAnnotation", Z = K2[U2], se2 = Z ? W(U2) : "", fe2 = D(K2, se2);
                return ue2.push(fe2 ? l(z) : z), Z && ue2.push(": ", l(se2)), l(ue2);
              }
              case "TSNamespaceExportDeclaration":
                return ue2.push("export as namespace ", W("id")), ce2.semi && ue2.push(";"), l(ue2);
              case "TSEnumDeclaration":
                return K2.declare && ue2.push("declare "), K2.modifiers && ue2.push(I2(ee2, ce2, W)), K2.const && ue2.push("const "), ue2.push("enum ", W("id"), " "), K2.members.length === 0 ? ue2.push(l(["{", t(ee2, ce2), i, "}"])) : ue2.push(l(["{", p([u, m(ee2, ce2, "members", W), f(ce2, "es5") ? "," : ""]), t(ee2, ce2, true), u, "}"])), ue2;
              case "TSEnumMember":
                return K2.computed ? ue2.push("[", W("id"), "]") : ue2.push(W("id")), K2.initializer && ue2.push(" = ", W("initializer")), ue2;
              case "TSImportEqualsDeclaration":
                return K2.isExport && ue2.push("export "), ue2.push("import "), K2.importKind && K2.importKind !== "value" && ue2.push(K2.importKind, " "), ue2.push(W("id"), " = ", W("moduleReference")), ce2.semi && ue2.push(";"), l(ue2);
              case "TSExternalModuleReference":
                return ["require(", W("expression"), ")"];
              case "TSModuleDeclaration": {
                let Fe2 = ee2.getParentNode(), z = g2(K2.id), U2 = Fe2.type === "TSModuleDeclaration", Z = K2.body && K2.body.type === "TSModuleDeclaration";
                if (U2)
                  ue2.push(".");
                else {
                  K2.declare && ue2.push("declare "), ue2.push(I2(ee2, ce2, W));
                  let se2 = ce2.originalText.slice(E(K2), E(K2.id));
                  K2.id.type === "Identifier" && K2.id.name === "global" && !/namespace|module/.test(se2) || ue2.push(z || /(?:^|\s)module(?:\s|$)/.test(se2) ? "module " : "namespace ");
                }
                return ue2.push(W("id")), Z ? ue2.push(W("body")) : K2.body ? ue2.push(" ", l(W("body"))) : ue2.push(de), ue2;
              }
              case "TSConditionalType":
                return P(ee2, ce2, W);
              case "TSInferType":
                return ["infer", " ", W("typeParameter")];
              case "TSIntersectionType":
                return J(ee2, ce2, W);
              case "TSUnionType":
                return L(ee2, ce2, W);
              case "TSFunctionType":
                return Q(ee2, ce2, W);
              case "TSTupleType":
                return V(ee2, ce2, W);
              case "TSTypeReference":
                return [W("typeName"), S(ee2, ce2, W, "typeParameters")];
              case "TSTypeAnnotation":
                return W("typeAnnotation");
              case "TSEmptyBodyFunctionExpression":
                return k(ee2, ce2, W);
              case "TSJSDocAllType":
                return "*";
              case "TSJSDocUnknownType":
                return "?";
              case "TSJSDocNullableType":
                return Y(ee2, W, "?");
              case "TSJSDocNonNullableType":
                return Y(ee2, W, "!");
              case "TSInstantiationExpression":
                return [W("expression"), W("typeParameters")];
              default:
                throw new Error(`Unknown TypeScript node type: ${JSON.stringify(K2.type)}.`);
            }
          }
          r.exports = { printTypescript: ie2 };
        } }), hd2 = te2({ "src/language-js/print/comment.js"(e, r) {
          ne2();
          var { hasNewline: t } = Ue2(), { builders: { join: s, hardline: a }, utils: { replaceTextEndOfLine: n } } = qe2(), { isLineComment: u } = Ke2(), { locStart: i, locEnd: l } = ut2(), p = Pt2();
          function y2(c, f) {
            let F = c.getValue();
            if (u(F))
              return f.originalText.slice(i(F), l(F)).trimEnd();
            if (p(F)) {
              if (h(F)) {
                let E = g2(F);
                return F.trailing && !t(f.originalText, i(F), { backwards: true }) ? [a, E] : E;
              }
              let _ = l(F), w = f.originalText.slice(_ - 3, _) === "*-/";
              return ["/*", n(F.value), w ? "*-/" : "*/"];
            }
            throw new Error("Not a comment: " + JSON.stringify(F));
          }
          function h(c) {
            let f = `*${c.value}*`.split(`
`);
            return f.length > 1 && f.every((F) => F.trim()[0] === "*");
          }
          function g2(c) {
            let f = c.value.split(`
`);
            return ["/*", s(a, f.map((F, _) => _ === 0 ? F.trimEnd() : " " + (_ < f.length - 1 ? F.trim() : F.trimStart()))), "*/"];
          }
          r.exports = { printComment: y2 };
        } }), vd2 = te2({ "src/language-js/print/literal.js"(e, r) {
          ne2();
          var { printString: t, printNumber: s } = Ue2(), { replaceTextEndOfLine: a } = Yt2(), { printDirective: n } = ct2();
          function u(y2, h) {
            let g2 = y2.getNode();
            switch (g2.type) {
              case "RegExpLiteral":
                return p(g2);
              case "BigIntLiteral":
                return l(g2.bigint || g2.extra.raw);
              case "NumericLiteral":
                return s(g2.extra.raw);
              case "StringLiteral":
                return a(t(g2.extra.raw, h));
              case "NullLiteral":
                return "null";
              case "BooleanLiteral":
                return String(g2.value);
              case "DecimalLiteral":
                return s(g2.value) + "m";
              case "Literal": {
                if (g2.regex)
                  return p(g2.regex);
                if (g2.bigint)
                  return l(g2.raw);
                if (g2.decimal)
                  return s(g2.decimal) + "m";
                let { value: c } = g2;
                return typeof c == "number" ? s(g2.raw) : typeof c == "string" ? i(y2) ? n(g2.raw, h) : a(t(g2.raw, h)) : String(c);
              }
            }
          }
          function i(y2) {
            if (y2.getName() !== "expression")
              return;
            let h = y2.getParentNode();
            return h.type === "ExpressionStatement" && h.directive;
          }
          function l(y2) {
            return y2.toLowerCase();
          }
          function p(y2) {
            let { pattern: h, flags: g2 } = y2;
            return g2 = [...g2].sort().join(""), `/${h}/${g2}`;
          }
          r.exports = { printLiteral: u };
        } }), Cd2 = te2({ "src/language-js/printer-estree.js"(e, r) {
          ne2();
          var { printDanglingComments: t } = et2(), { hasNewline: s } = Ue2(), { builders: { join: a, line: n, hardline: u, softline: i, group: l, indent: p }, utils: { replaceTextEndOfLine: y2 } } = qe2(), h = td2(), g2 = rd2(), { insertPragma: c } = Co2(), f = Eo2(), F = qt2(), _ = Fo2(), { hasFlowShorthandAnnotationComment: w, hasComment: E, CommentCheckFlags: N2, isTheOnlyJsxElementInMarkdown: x, isLineComment: I2, isNextLineEmpty: P, needsHardlineAfterDanglingComment: $2, hasIgnoreComment: D, isCallExpression: T, isMemberExpression: m, markerForIfWithoutBlockAndSameLineComment: C } = Ke2(), { locStart: o, locEnd: d2 } = ut2(), v2 = Pt2(), { printHtmlBinding: S, isVueEventBindingExpression: b } = pd2(), { printAngular: B } = fd2(), { printJsx: k, hasJsxIgnoreComment: M2 } = Dd2(), { printFlow: R2 } = dd2(), { printTypescript: q } = yd2(), { printOptionalToken: J, printBindExpressionCallee: L, printTypeAnnotation: Q, adjustClause: V, printRestSpread: j, printDefiniteToken: Y, printDirective: ie2 } = ct2(), { printImportDeclaration: ee2, printExportDeclaration: ce2, printExportAllDeclaration: W, printModuleSpecifier: K2 } = To2(), { printTernary: de } = Bo2(), { printTemplateLiteral: ue2 } = jt2(), { printArray: Fe2 } = er2(), { printObject: z } = uu2(), { printClass: U2, printClassMethod: Z, printClassProperty: se2 } = nr2(), { printProperty: fe2 } = rr2(), { printFunction: ge2, printArrowFunction: he2, printMethod: we2, printReturnStatement: ke2, printThrowStatement: Re2 } = qr(), { printCallExpression: Ne2 } = xo2(), { printVariableDeclarator: Pe2, printAssignmentExpression: oe } = tr2(), { printBinaryishExpression: H } = ru2(), { printSwitchCaseConsequent: pe2 } = No2(), { printMemberExpression: X } = So2(), { printBlock: le2, printBlockBody: Ae2 } = wo2(), { printComment: Ee } = hd2(), { printLiteral: De2 } = vd2(), { printDecorators: A } = nu2();
          function G(Ce2, Be, ve2, ze) {
            let be2 = re(Ce2, Be, ve2, ze);
            if (!be2)
              return "";
            let Ye2 = Ce2.getValue(), { type: Se2 } = Ye2;
            if (Se2 === "ClassMethod" || Se2 === "ClassPrivateMethod" || Se2 === "ClassProperty" || Se2 === "ClassAccessorProperty" || Se2 === "AccessorProperty" || Se2 === "TSAbstractAccessorProperty" || Se2 === "PropertyDefinition" || Se2 === "TSAbstractPropertyDefinition" || Se2 === "ClassPrivateProperty" || Se2 === "MethodDefinition" || Se2 === "TSAbstractMethodDefinition" || Se2 === "TSDeclareMethod")
              return be2;
            let Ie2 = [be2], Oe2 = A(Ce2, Be, ve2), Je2 = Ye2.type === "ClassExpression" && Oe2;
            if (Oe2 && (Ie2 = [...Oe2, be2], !Je2))
              return l(Ie2);
            if (!F(Ce2, Be))
              return ze && ze.needsSemi && Ie2.unshift(";"), Ie2.length === 1 && Ie2[0] === be2 ? be2 : Ie2;
            if (Je2 && (Ie2 = [p([n, ...Ie2])]), Ie2.unshift("("), ze && ze.needsSemi && Ie2.unshift(";"), w(Ye2)) {
              let [je2] = Ye2.trailingComments;
              Ie2.push(" /*", je2.value.trimStart(), "*/"), je2.printed = true;
            }
            return Je2 && Ie2.push(n), Ie2.push(")"), Ie2;
          }
          function re(Ce2, Be, ve2, ze) {
            let be2 = Ce2.getValue(), Ye2 = Be.semi ? ";" : "";
            if (!be2)
              return "";
            if (typeof be2 == "string")
              return be2;
            for (let Ie2 of [De2, S, B, k, R2, q]) {
              let Oe2 = Ie2(Ce2, Be, ve2);
              if (typeof Oe2 < "u")
                return Oe2;
            }
            let Se2 = [];
            switch (be2.type) {
              case "JsExpressionRoot":
                return ve2("node");
              case "JsonRoot":
                return [ve2("node"), u];
              case "File":
                return be2.program && be2.program.interpreter && Se2.push(ve2(["program", "interpreter"])), Se2.push(ve2("program")), Se2;
              case "Program":
                return Ae2(Ce2, Be, ve2);
              case "EmptyStatement":
                return "";
              case "ExpressionStatement": {
                if (Be.parser === "__vue_event_binding" || Be.parser === "__vue_ts_event_binding") {
                  let Oe2 = Ce2.getParentNode();
                  if (Oe2.type === "Program" && Oe2.body.length === 1 && Oe2.body[0] === be2)
                    return [ve2("expression"), b(be2.expression) ? ";" : ""];
                }
                let Ie2 = t(Ce2, Be, true, (Oe2) => {
                  let { marker: Je2 } = Oe2;
                  return Je2 === C;
                });
                return [ve2("expression"), x(Be, Ce2) ? "" : Ye2, Ie2 ? [" ", Ie2] : ""];
              }
              case "ParenthesizedExpression":
                return !E(be2.expression) && (be2.expression.type === "ObjectExpression" || be2.expression.type === "ArrayExpression") ? ["(", ve2("expression"), ")"] : l(["(", p([i, ve2("expression")]), i, ")"]);
              case "AssignmentExpression":
                return oe(Ce2, Be, ve2);
              case "VariableDeclarator":
                return Pe2(Ce2, Be, ve2);
              case "BinaryExpression":
              case "LogicalExpression":
                return H(Ce2, Be, ve2);
              case "AssignmentPattern":
                return [ve2("left"), " = ", ve2("right")];
              case "OptionalMemberExpression":
              case "MemberExpression":
                return X(Ce2, Be, ve2);
              case "MetaProperty":
                return [ve2("meta"), ".", ve2("property")];
              case "BindExpression":
                return be2.object && Se2.push(ve2("object")), Se2.push(l(p([i, L(Ce2, Be, ve2)]))), Se2;
              case "Identifier":
                return [be2.name, J(Ce2), Y(Ce2), Q(Ce2, Be, ve2)];
              case "V8IntrinsicIdentifier":
                return ["%", be2.name];
              case "SpreadElement":
              case "SpreadElementPattern":
              case "SpreadProperty":
              case "SpreadPropertyPattern":
              case "RestElement":
                return j(Ce2, Be, ve2);
              case "FunctionDeclaration":
              case "FunctionExpression":
                return ge2(Ce2, ve2, Be, ze);
              case "ArrowFunctionExpression":
                return he2(Ce2, Be, ve2, ze);
              case "YieldExpression":
                return Se2.push("yield"), be2.delegate && Se2.push("*"), be2.argument && Se2.push(" ", ve2("argument")), Se2;
              case "AwaitExpression": {
                if (Se2.push("await"), be2.argument) {
                  Se2.push(" ", ve2("argument"));
                  let Ie2 = Ce2.getParentNode();
                  if (T(Ie2) && Ie2.callee === be2 || m(Ie2) && Ie2.object === be2) {
                    Se2 = [p([i, ...Se2]), i];
                    let Oe2 = Ce2.findAncestor((Je2) => Je2.type === "AwaitExpression" || Je2.type === "BlockStatement");
                    if (!Oe2 || Oe2.type !== "AwaitExpression")
                      return l(Se2);
                  }
                }
                return Se2;
              }
              case "ExportDefaultDeclaration":
              case "ExportNamedDeclaration":
                return ce2(Ce2, Be, ve2);
              case "ExportAllDeclaration":
                return W(Ce2, Be, ve2);
              case "ImportDeclaration":
                return ee2(Ce2, Be, ve2);
              case "ImportSpecifier":
              case "ExportSpecifier":
              case "ImportNamespaceSpecifier":
              case "ExportNamespaceSpecifier":
              case "ImportDefaultSpecifier":
              case "ExportDefaultSpecifier":
                return K2(Ce2, Be, ve2);
              case "ImportAttribute":
                return [ve2("key"), ": ", ve2("value")];
              case "Import":
                return "import";
              case "BlockStatement":
              case "StaticBlock":
              case "ClassBody":
                return le2(Ce2, Be, ve2);
              case "ThrowStatement":
                return Re2(Ce2, Be, ve2);
              case "ReturnStatement":
                return ke2(Ce2, Be, ve2);
              case "NewExpression":
              case "ImportExpression":
              case "OptionalCallExpression":
              case "CallExpression":
                return Ne2(Ce2, Be, ve2);
              case "ObjectExpression":
              case "ObjectPattern":
              case "RecordExpression":
                return z(Ce2, Be, ve2);
              case "ObjectProperty":
              case "Property":
                return be2.method || be2.kind === "get" || be2.kind === "set" ? we2(Ce2, Be, ve2) : fe2(Ce2, Be, ve2);
              case "ObjectMethod":
                return we2(Ce2, Be, ve2);
              case "Decorator":
                return ["@", ve2("expression")];
              case "ArrayExpression":
              case "ArrayPattern":
              case "TupleExpression":
                return Fe2(Ce2, Be, ve2);
              case "SequenceExpression": {
                let Ie2 = Ce2.getParentNode(0);
                if (Ie2.type === "ExpressionStatement" || Ie2.type === "ForStatement") {
                  let Oe2 = [];
                  return Ce2.each((Je2, Te2) => {
                    Te2 === 0 ? Oe2.push(ve2()) : Oe2.push(",", p([n, ve2()]));
                  }, "expressions"), l(Oe2);
                }
                return l(a([",", n], Ce2.map(ve2, "expressions")));
              }
              case "ThisExpression":
                return "this";
              case "Super":
                return "super";
              case "Directive":
                return [ve2("value"), Ye2];
              case "DirectiveLiteral":
                return ie2(be2.extra.raw, Be);
              case "UnaryExpression":
                return Se2.push(be2.operator), /[a-z]$/.test(be2.operator) && Se2.push(" "), E(be2.argument) ? Se2.push(l(["(", p([i, ve2("argument")]), i, ")"])) : Se2.push(ve2("argument")), Se2;
              case "UpdateExpression":
                return Se2.push(ve2("argument"), be2.operator), be2.prefix && Se2.reverse(), Se2;
              case "ConditionalExpression":
                return de(Ce2, Be, ve2);
              case "VariableDeclaration": {
                let Ie2 = Ce2.map(ve2, "declarations"), Oe2 = Ce2.getParentNode(), Je2 = Oe2.type === "ForStatement" || Oe2.type === "ForInStatement" || Oe2.type === "ForOfStatement", Te2 = be2.declarations.some((Me2) => Me2.init), je2;
                return Ie2.length === 1 && !E(be2.declarations[0]) ? je2 = Ie2[0] : Ie2.length > 0 && (je2 = p(Ie2[0])), Se2 = [be2.declare ? "declare " : "", be2.kind, je2 ? [" ", je2] : "", p(Ie2.slice(1).map((Me2) => [",", Te2 && !Je2 ? u : n, Me2]))], Je2 && Oe2.body !== be2 || Se2.push(Ye2), l(Se2);
              }
              case "WithStatement":
                return l(["with (", ve2("object"), ")", V(be2.body, ve2("body"))]);
              case "IfStatement": {
                let Ie2 = V(be2.consequent, ve2("consequent")), Oe2 = l(["if (", l([p([i, ve2("test")]), i]), ")", Ie2]);
                if (Se2.push(Oe2), be2.alternate) {
                  let Je2 = E(be2.consequent, N2.Trailing | N2.Line) || $2(be2), Te2 = be2.consequent.type === "BlockStatement" && !Je2;
                  Se2.push(Te2 ? " " : u), E(be2, N2.Dangling) && Se2.push(t(Ce2, Be, true), Je2 ? u : " "), Se2.push("else", l(V(be2.alternate, ve2("alternate"), be2.alternate.type === "IfStatement")));
                }
                return Se2;
              }
              case "ForStatement": {
                let Ie2 = V(be2.body, ve2("body")), Oe2 = t(Ce2, Be, true), Je2 = Oe2 ? [Oe2, i] : "";
                return !be2.init && !be2.test && !be2.update ? [Je2, l(["for (;;)", Ie2])] : [Je2, l(["for (", l([p([i, ve2("init"), ";", n, ve2("test"), ";", n, ve2("update")]), i]), ")", Ie2])];
              }
              case "WhileStatement":
                return l(["while (", l([p([i, ve2("test")]), i]), ")", V(be2.body, ve2("body"))]);
              case "ForInStatement":
                return l(["for (", ve2("left"), " in ", ve2("right"), ")", V(be2.body, ve2("body"))]);
              case "ForOfStatement":
                return l(["for", be2.await ? " await" : "", " (", ve2("left"), " of ", ve2("right"), ")", V(be2.body, ve2("body"))]);
              case "DoWhileStatement": {
                let Ie2 = V(be2.body, ve2("body"));
                return Se2 = [l(["do", Ie2])], be2.body.type === "BlockStatement" ? Se2.push(" ") : Se2.push(u), Se2.push("while (", l([p([i, ve2("test")]), i]), ")", Ye2), Se2;
              }
              case "DoExpression":
                return [be2.async ? "async " : "", "do ", ve2("body")];
              case "BreakStatement":
                return Se2.push("break"), be2.label && Se2.push(" ", ve2("label")), Se2.push(Ye2), Se2;
              case "ContinueStatement":
                return Se2.push("continue"), be2.label && Se2.push(" ", ve2("label")), Se2.push(Ye2), Se2;
              case "LabeledStatement":
                return be2.body.type === "EmptyStatement" ? [ve2("label"), ":;"] : [ve2("label"), ": ", ve2("body")];
              case "TryStatement":
                return ["try ", ve2("block"), be2.handler ? [" ", ve2("handler")] : "", be2.finalizer ? [" finally ", ve2("finalizer")] : ""];
              case "CatchClause":
                if (be2.param) {
                  let Ie2 = E(be2.param, (Je2) => !v2(Je2) || Je2.leading && s(Be.originalText, d2(Je2)) || Je2.trailing && s(Be.originalText, o(Je2), { backwards: true })), Oe2 = ve2("param");
                  return ["catch ", Ie2 ? ["(", p([i, Oe2]), i, ") "] : ["(", Oe2, ") "], ve2("body")];
                }
                return ["catch ", ve2("body")];
              case "SwitchStatement":
                return [l(["switch (", p([i, ve2("discriminant")]), i, ")"]), " {", be2.cases.length > 0 ? p([u, a(u, Ce2.map((Ie2, Oe2, Je2) => {
                  let Te2 = Ie2.getValue();
                  return [ve2(), Oe2 !== Je2.length - 1 && P(Te2, Be) ? u : ""];
                }, "cases"))]) : "", u, "}"];
              case "SwitchCase": {
                be2.test ? Se2.push("case ", ve2("test"), ":") : Se2.push("default:"), E(be2, N2.Dangling) && Se2.push(" ", t(Ce2, Be, true));
                let Ie2 = be2.consequent.filter((Oe2) => Oe2.type !== "EmptyStatement");
                if (Ie2.length > 0) {
                  let Oe2 = pe2(Ce2, Be, ve2);
                  Se2.push(Ie2.length === 1 && Ie2[0].type === "BlockStatement" ? [" ", Oe2] : p([u, Oe2]));
                }
                return Se2;
              }
              case "DebuggerStatement":
                return ["debugger", Ye2];
              case "ClassDeclaration":
              case "ClassExpression":
                return U2(Ce2, Be, ve2);
              case "ClassMethod":
              case "ClassPrivateMethod":
              case "MethodDefinition":
                return Z(Ce2, Be, ve2);
              case "ClassProperty":
              case "PropertyDefinition":
              case "ClassPrivateProperty":
              case "ClassAccessorProperty":
              case "AccessorProperty":
                return se2(Ce2, Be, ve2);
              case "TemplateElement":
                return y2(be2.value.raw);
              case "TemplateLiteral":
                return ue2(Ce2, ve2, Be);
              case "TaggedTemplateExpression":
                return [ve2("tag"), ve2("typeParameters"), ve2("quasi")];
              case "PrivateIdentifier":
                return ["#", ve2("name")];
              case "PrivateName":
                return ["#", ve2("id")];
              case "InterpreterDirective":
                return Se2.push("#!", be2.value, u), P(be2, Be) && Se2.push(u), Se2;
              case "TopicReference":
                return "%";
              case "ArgumentPlaceholder":
                return "?";
              case "ModuleExpression": {
                Se2.push("module {");
                let Ie2 = ve2("body");
                return Ie2 && Se2.push(p([u, Ie2]), u), Se2.push("}"), Se2;
              }
              default:
                throw new Error("unknown type: " + JSON.stringify(be2.type));
            }
          }
          function ye2(Ce2) {
            return Ce2.type && !v2(Ce2) && !I2(Ce2) && Ce2.type !== "EmptyStatement" && Ce2.type !== "TemplateElement" && Ce2.type !== "Import" && Ce2.type !== "TSEmptyBodyFunctionExpression";
          }
          r.exports = { preprocess: _, print: G, embed: h, insertPragma: c, massageAstNode: g2, hasPrettierIgnore(Ce2) {
            return D(Ce2) || M2(Ce2);
          }, willPrintOwnComments: f.willPrintOwnComments, canAttachComment: ye2, printComment: Ee, isBlockComment: v2, handleComments: { avoidAstMutation: true, ownLine: f.handleOwnLineComment, endOfLine: f.handleEndOfLineComment, remaining: f.handleRemainingComment }, getCommentChildNodes: f.getCommentChildNodes };
        } }), Ed2 = te2({ "src/language-js/printer-estree-json.js"(e, r) {
          ne2();
          var { builders: { hardline: t, indent: s, join: a } } = qe2(), n = Fo2();
          function u(y2, h, g2) {
            let c = y2.getValue();
            switch (c.type) {
              case "JsonRoot":
                return [g2("node"), t];
              case "ArrayExpression": {
                if (c.elements.length === 0)
                  return "[]";
                let f = y2.map(() => y2.getValue() === null ? "null" : g2(), "elements");
                return ["[", s([t, a([",", t], f)]), t, "]"];
              }
              case "ObjectExpression":
                return c.properties.length === 0 ? "{}" : ["{", s([t, a([",", t], y2.map(g2, "properties"))]), t, "}"];
              case "ObjectProperty":
                return [g2("key"), ": ", g2("value")];
              case "UnaryExpression":
                return [c.operator === "+" ? "" : c.operator, g2("argument")];
              case "NullLiteral":
                return "null";
              case "BooleanLiteral":
                return c.value ? "true" : "false";
              case "StringLiteral":
                return JSON.stringify(c.value);
              case "NumericLiteral":
                return i(y2) ? JSON.stringify(String(c.value)) : JSON.stringify(c.value);
              case "Identifier":
                return i(y2) ? JSON.stringify(c.name) : c.name;
              case "TemplateLiteral":
                return g2(["quasis", 0]);
              case "TemplateElement":
                return JSON.stringify(c.value.cooked);
              default:
                throw new Error("unknown type: " + JSON.stringify(c.type));
            }
          }
          function i(y2) {
            return y2.getName() === "key" && y2.getParentNode().type === "ObjectProperty";
          }
          var l = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
          function p(y2, h) {
            let { type: g2 } = y2;
            if (g2 === "ObjectProperty") {
              let { key: c } = y2;
              c.type === "Identifier" ? h.key = { type: "StringLiteral", value: c.name } : c.type === "NumericLiteral" && (h.key = { type: "StringLiteral", value: String(c.value) });
              return;
            }
            if (g2 === "UnaryExpression" && y2.operator === "+")
              return h.argument;
            if (g2 === "ArrayExpression") {
              for (let [c, f] of y2.elements.entries())
                f === null && h.elements.splice(c, 0, { type: "NullLiteral" });
              return;
            }
            if (g2 === "TemplateLiteral")
              return { type: "StringLiteral", value: y2.quasis[0].value.cooked };
          }
          p.ignoredProperties = l, r.exports = { preprocess: n, print: u, massageAstNode: p };
        } }), Mt2 = te2({ "src/common/common-options.js"(e, r) {
          ne2();
          var t = "Common";
          r.exports = { bracketSpacing: { since: "0.0.0", category: t, type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: t, type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { since: "1.8.2", category: t, type: "choice", default: [{ since: "1.8.2", value: true }, { since: "1.9.0", value: "preserve" }], description: "How to wrap prose.", choices: [{ since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width." }, { since: "1.9.0", value: "never", description: "Do not wrap prose." }, { since: "1.9.0", value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { since: "2.4.0", category: t, type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { since: "2.6.0", category: t, type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
        } }), Fd2 = te2({ "src/language-js/options.js"(e, r) {
          ne2();
          var t = Mt2(), s = "JavaScript";
          r.exports = { arrowParens: { since: "1.9.0", category: s, type: "choice", default: [{ since: "1.9.0", value: "avoid" }, { since: "2.0.0", value: "always" }], description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: t.bracketSameLine, bracketSpacing: t.bracketSpacing, jsxBracketSameLine: { since: "0.17.0", category: s, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { since: "1.0.0", category: s, type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, singleQuote: t.singleQuote, jsxSingleQuote: { since: "1.15.0", category: s, type: "boolean", default: false, description: "Use single quotes in JSX." }, quoteProps: { since: "1.17.0", category: s, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { since: "0.0.0", category: s, type: "choice", default: [{ since: "0.0.0", value: false }, { since: "0.19.0", value: "none" }, { since: "2.0.0", value: "es5" }], description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }, { value: "all", description: "Trailing commas wherever possible (including function arguments)." }] }, singleAttributePerLine: t.singleAttributePerLine };
        } }), Ad2 = te2({ "src/language-js/parse/parsers.js"() {
          ne2();
        } }), Ln2 = te2({ "node_modules/linguist-languages/data/JavaScript.json"(e, r) {
          r.exports = { name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], languageId: 183 };
        } }), Sd2 = te2({ "node_modules/linguist-languages/data/TypeScript.json"(e, r) {
          r.exports = { name: "TypeScript", type: "programming", color: "#3178c6", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts", ".cts", ".mts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378 };
        } }), xd2 = te2({ "node_modules/linguist-languages/data/TSX.json"(e, r) {
          r.exports = { name: "TSX", type: "programming", color: "#3178c6", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924 };
        } }), wa2 = te2({ "node_modules/linguist-languages/data/JSON.json"(e, r) {
          r.exports = { name: "JSON", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"], languageId: 174 };
        } }), bd2 = te2({ "node_modules/linguist-languages/data/JSON with Comments.json"(e, r) {
          r.exports = { name: "JSON with Comments", type: "data", color: "#292929", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".code-snippets", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [".babelrc", ".devcontainer.json", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"], languageId: 423 };
        } }), Td2 = te2({ "node_modules/linguist-languages/data/JSON5.json"(e, r) {
          r.exports = { name: "JSON5", type: "data", color: "#267CB9", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175 };
        } }), Bd2 = te2({ "src/language-js/index.js"(e, r) {
          ne2();
          var t = _t2(), s = Cd2(), a = Ed2(), n = Fd2(), u = Ad2(), i = [t(Ln2(), (p) => ({ since: "0.0.0", parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: [...p.interpreters, "zx"], extensions: [...p.extensions.filter((y2) => y2 !== ".jsx"), ".wxs"] })), t(Ln2(), () => ({ name: "Flow", since: "0.0.0", parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"] })), t(Ln2(), () => ({ name: "JSX", since: "0.0.0", parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], aliases: void 0, filenames: void 0, extensions: [".jsx"], group: "JavaScript", interpreters: void 0, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0 })), t(Sd2(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] })), t(xd2(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] })), t(wa2(), () => ({ name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [".importmap"], filenames: ["package.json", "package-lock.json", "composer.json"] })), t(wa2(), (p) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], extensions: p.extensions.filter((y2) => y2 !== ".jsonl") })), t(bd2(), (p) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: [...p.filenames, ".eslintrc", ".swcrc"] })), t(Td2(), () => ({ since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"] }))], l = { estree: s, "estree-json": a };
          r.exports = { languages: i, options: n, printers: l, parsers: u };
        } }), Nd2 = te2({ "src/language-css/clean.js"(e, r) {
          ne2();
          var { isFrontMatterNode: t } = Ue2(), s = lt2(), a = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
          function n(i, l, p) {
            if (t(i) && i.lang === "yaml" && delete l.value, i.type === "css-comment" && p.type === "css-root" && p.nodes.length > 0 && ((p.nodes[0] === i || t(p.nodes[0]) && p.nodes[1] === i) && (delete l.text, /^\*\s*@(?:format|prettier)\s*$/.test(i.text)) || p.type === "css-root" && s(p.nodes) === i))
              return null;
            if (i.type === "value-root" && delete l.text, (i.type === "media-query" || i.type === "media-query-list" || i.type === "media-feature-expression") && delete l.value, i.type === "css-rule" && delete l.params, i.type === "selector-combinator" && (l.value = l.value.replace(/\s+/g, " ")), i.type === "media-feature" && (l.value = l.value.replace(/ /g, "")), (i.type === "value-word" && (i.isColor && i.isHex || ["initial", "inherit", "unset", "revert"].includes(l.value.replace().toLowerCase())) || i.type === "media-feature" || i.type === "selector-root-invalid" || i.type === "selector-pseudo") && (l.value = l.value.toLowerCase()), i.type === "css-decl" && (l.prop = l.prop.toLowerCase()), (i.type === "css-atrule" || i.type === "css-import") && (l.name = l.name.toLowerCase()), i.type === "value-number" && (l.unit = l.unit.toLowerCase()), (i.type === "media-feature" || i.type === "media-keyword" || i.type === "media-type" || i.type === "media-unknown" || i.type === "media-url" || i.type === "media-value" || i.type === "selector-attribute" || i.type === "selector-string" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "value-string") && l.value && (l.value = u(l.value)), i.type === "selector-attribute" && (l.attribute = l.attribute.trim(), l.namespace && typeof l.namespace == "string" && (l.namespace = l.namespace.trim(), l.namespace.length === 0 && (l.namespace = true)), l.value && (l.value = l.value.trim().replace(/^["']|["']$/g, ""), delete l.quoted)), (i.type === "media-value" || i.type === "media-type" || i.type === "value-number" || i.type === "selector-root-invalid" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "selector-tag") && l.value && (l.value = l.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (y2, h, g2) => {
              let c = Number(h);
              return Number.isNaN(c) ? y2 : c + g2.toLowerCase();
            })), i.type === "selector-tag") {
              let y2 = i.value.toLowerCase();
              ["from", "to"].includes(y2) && (l.value = y2);
            }
            if (i.type === "css-atrule" && i.name.toLowerCase() === "supports" && delete l.value, i.type === "selector-unknown" && delete l.value, i.type === "value-comma_group") {
              let y2 = i.groups.findIndex((h) => h.type === "value-number" && h.unit === "...");
              y2 !== -1 && (l.groups[y2].unit = "", l.groups.splice(y2 + 1, 0, { type: "value-word", value: "...", isColor: false, isHex: false }));
            }
            if (i.type === "value-comma_group" && i.groups.some((y2) => y2.type === "value-atword" && y2.value.endsWith("[") || y2.type === "value-word" && y2.value.startsWith("]")))
              return { type: "value-atword", value: i.groups.map((y2) => y2.value).join(""), group: { open: null, close: null, groups: [], type: "value-paren_group" } };
          }
          n.ignoredProperties = a;
          function u(i) {
            return i.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1");
          }
          r.exports = n;
        } }), su = te2({ "src/utils/front-matter/print.js"(e, r) {
          ne2();
          var { builders: { hardline: t, markAsRoot: s } } = qe2();
          function a(n, u) {
            if (n.lang === "yaml") {
              let i = n.value.trim(), l = i ? u(i, { parser: "yaml" }, { stripTrailingHardline: true }) : "";
              return s([n.startDelimiter, t, l, l ? t : "", n.endDelimiter]);
            }
          }
          r.exports = a;
        } }), wd2 = te2({ "src/language-css/embed.js"(e, r) {
          ne2();
          var { builders: { hardline: t } } = qe2(), s = su();
          function a(n, u, i) {
            let l = n.getValue();
            if (l.type === "front-matter") {
              let p = s(l, i);
              return p ? [p, t] : "";
            }
          }
          r.exports = a;
        } }), _o2 = te2({ "src/utils/front-matter/parse.js"(e, r) {
          ne2();
          var t = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
          function s(a) {
            let n = a.match(t);
            if (!n)
              return { content: a };
            let { startDelimiter: u, language: i, value: l = "", endDelimiter: p } = n.groups, y2 = i.trim() || "yaml";
            if (u === "+++" && (y2 = "toml"), y2 !== "yaml" && u !== p)
              return { content: a };
            let [h] = n;
            return { frontMatter: { type: "front-matter", lang: y2, value: l, startDelimiter: u, endDelimiter: p, raw: h.replace(/\n$/, "") }, content: h.replace(/[^\n]/g, " ") + a.slice(h.length) };
          }
          r.exports = s;
        } }), _d2 = te2({ "src/language-css/pragma.js"(e, r) {
          ne2();
          var t = Co2(), s = _o2();
          function a(u) {
            return t.hasPragma(s(u).content);
          }
          function n(u) {
            let { frontMatter: i, content: l } = s(u);
            return (i ? i.raw + `

` : "") + t.insertPragma(l);
          }
          r.exports = { hasPragma: a, insertPragma: n };
        } }), Pd2 = te2({ "src/language-css/utils/index.js"(e, r) {
          ne2();
          var t = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
          function s(z, U2) {
            let Z = Array.isArray(U2) ? U2 : [U2], se2 = -1, fe2;
            for (; fe2 = z.getParentNode(++se2); )
              if (Z.includes(fe2.type))
                return se2;
            return -1;
          }
          function a(z, U2) {
            let Z = s(z, U2);
            return Z === -1 ? null : z.getParentNode(Z);
          }
          function n(z) {
            var U2;
            let Z = a(z, "css-decl");
            return Z == null || (U2 = Z.prop) === null || U2 === void 0 ? void 0 : U2.toLowerCase();
          }
          var u = /* @__PURE__ */ new Set(["initial", "inherit", "unset", "revert"]);
          function i(z) {
            return u.has(z.toLowerCase());
          }
          function l(z, U2) {
            let Z = a(z, "css-atrule");
            return (Z == null ? void 0 : Z.name) && Z.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(U2.toLowerCase());
          }
          function p(z) {
            return z.includes("$") || z.includes("@") || z.includes("#") || z.startsWith("%") || z.startsWith("--") || z.startsWith(":--") || z.includes("(") && z.includes(")") ? z : z.toLowerCase();
          }
          function y2(z, U2) {
            var Z;
            let se2 = a(z, "value-func");
            return (se2 == null || (Z = se2.value) === null || Z === void 0 ? void 0 : Z.toLowerCase()) === U2;
          }
          function h(z) {
            var U2;
            let Z = a(z, "css-rule"), se2 = Z == null || (U2 = Z.raws) === null || U2 === void 0 ? void 0 : U2.selector;
            return se2 && (se2.startsWith(":import") || se2.startsWith(":export"));
          }
          function g2(z, U2) {
            let Z = Array.isArray(U2) ? U2 : [U2], se2 = a(z, "css-atrule");
            return se2 && Z.includes(se2.name.toLowerCase());
          }
          function c(z) {
            let U2 = z.getValue(), Z = a(z, "css-atrule");
            return (Z == null ? void 0 : Z.name) === "import" && U2.groups[0].value === "url" && U2.groups.length === 2;
          }
          function f(z) {
            return z.type === "value-func" && z.value.toLowerCase() === "url";
          }
          function F(z, U2) {
            var Z;
            let se2 = (Z = z.getParentNode()) === null || Z === void 0 ? void 0 : Z.nodes;
            return se2 && se2.indexOf(U2) === se2.length - 1;
          }
          function _(z) {
            let { selector: U2 } = z;
            return U2 ? typeof U2 == "string" && /^@.+:.*$/.test(U2) || U2.value && /^@.+:.*$/.test(U2.value) : false;
          }
          function w(z) {
            return z.type === "value-word" && ["from", "through", "end"].includes(z.value);
          }
          function E(z) {
            return z.type === "value-word" && ["and", "or", "not"].includes(z.value);
          }
          function N2(z) {
            return z.type === "value-word" && z.value === "in";
          }
          function x(z) {
            return z.type === "value-operator" && z.value === "*";
          }
          function I2(z) {
            return z.type === "value-operator" && z.value === "/";
          }
          function P(z) {
            return z.type === "value-operator" && z.value === "+";
          }
          function $2(z) {
            return z.type === "value-operator" && z.value === "-";
          }
          function D(z) {
            return z.type === "value-operator" && z.value === "%";
          }
          function T(z) {
            return x(z) || I2(z) || P(z) || $2(z) || D(z);
          }
          function m(z) {
            return z.type === "value-word" && ["==", "!="].includes(z.value);
          }
          function C(z) {
            return z.type === "value-word" && ["<", ">", "<=", ">="].includes(z.value);
          }
          function o(z) {
            return z.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(z.name);
          }
          function d2(z) {
            var U2;
            return ((U2 = z.raws) === null || U2 === void 0 ? void 0 : U2.params) && /^\(\s*\)$/.test(z.raws.params);
          }
          function v2(z) {
            return z.name.startsWith("prettier-placeholder");
          }
          function S(z) {
            return z.prop.startsWith("@prettier-placeholder");
          }
          function b(z, U2) {
            return z.value === "$$" && z.type === "value-func" && (U2 == null ? void 0 : U2.type) === "value-word" && !U2.raws.before;
          }
          function B(z) {
            var U2, Z;
            return ((U2 = z.value) === null || U2 === void 0 ? void 0 : U2.type) === "value-root" && ((Z = z.value.group) === null || Z === void 0 ? void 0 : Z.type) === "value-value" && z.prop.toLowerCase() === "composes";
          }
          function k(z) {
            var U2, Z, se2;
            return ((U2 = z.value) === null || U2 === void 0 || (Z = U2.group) === null || Z === void 0 || (se2 = Z.group) === null || se2 === void 0 ? void 0 : se2.type) === "value-paren_group" && z.value.group.group.open !== null && z.value.group.group.close !== null;
          }
          function M2(z) {
            var U2;
            return ((U2 = z.raws) === null || U2 === void 0 ? void 0 : U2.before) === "";
          }
          function R2(z) {
            var U2, Z;
            return z.type === "value-comma_group" && ((U2 = z.groups) === null || U2 === void 0 || (Z = U2[1]) === null || Z === void 0 ? void 0 : Z.type) === "value-colon";
          }
          function q(z) {
            var U2;
            return z.type === "value-paren_group" && ((U2 = z.groups) === null || U2 === void 0 ? void 0 : U2[0]) && R2(z.groups[0]);
          }
          function J(z) {
            var U2;
            let Z = z.getValue();
            if (Z.groups.length === 0)
              return false;
            let se2 = z.getParentNode(1);
            if (!q(Z) && !(se2 && q(se2)))
              return false;
            let fe2 = a(z, "css-decl");
            return !!(fe2 != null && (U2 = fe2.prop) !== null && U2 !== void 0 && U2.startsWith("$") || q(se2) || se2.type === "value-func");
          }
          function L(z) {
            return z.type === "value-comment" && z.inline;
          }
          function Q(z) {
            return z.type === "value-word" && z.value === "#";
          }
          function V(z) {
            return z.type === "value-word" && z.value === "{";
          }
          function j(z) {
            return z.type === "value-word" && z.value === "}";
          }
          function Y(z) {
            return ["value-word", "value-atword"].includes(z.type);
          }
          function ie2(z) {
            return (z == null ? void 0 : z.type) === "value-colon";
          }
          function ee2(z, U2) {
            if (!R2(U2))
              return false;
            let { groups: Z } = U2, se2 = Z.indexOf(z);
            return se2 === -1 ? false : ie2(Z[se2 + 1]);
          }
          function ce2(z) {
            return z.value && ["not", "and", "or"].includes(z.value.toLowerCase());
          }
          function W(z) {
            return z.type !== "value-func" ? false : t.has(z.value.toLowerCase());
          }
          function K2(z) {
            return /\/\//.test(z.split(/[\n\r]/).pop());
          }
          function de(z) {
            return (z == null ? void 0 : z.type) === "value-atword" && z.value.startsWith("prettier-placeholder-");
          }
          function ue2(z, U2) {
            var Z, se2;
            if (((Z = z.open) === null || Z === void 0 ? void 0 : Z.value) !== "(" || ((se2 = z.close) === null || se2 === void 0 ? void 0 : se2.value) !== ")" || z.groups.some((fe2) => fe2.type !== "value-comma_group"))
              return false;
            if (U2.type === "value-comma_group") {
              let fe2 = U2.groups.indexOf(z) - 1, ge2 = U2.groups[fe2];
              if ((ge2 == null ? void 0 : ge2.type) === "value-word" && ge2.value === "with")
                return true;
            }
            return false;
          }
          function Fe2(z) {
            var U2, Z;
            return z.type === "value-paren_group" && ((U2 = z.open) === null || U2 === void 0 ? void 0 : U2.value) === "(" && ((Z = z.close) === null || Z === void 0 ? void 0 : Z.value) === ")";
          }
          r.exports = { getAncestorCounter: s, getAncestorNode: a, getPropOfDeclNode: n, maybeToLowerCase: p, insideValueFunctionNode: y2, insideICSSRuleNode: h, insideAtRuleNode: g2, insideURLFunctionInImportAtRuleNode: c, isKeyframeAtRuleKeywords: l, isWideKeywords: i, isLastNode: F, isSCSSControlDirectiveNode: o, isDetachedRulesetDeclarationNode: _, isRelationalOperatorNode: C, isEqualityOperatorNode: m, isMultiplicationNode: x, isDivisionNode: I2, isAdditionNode: P, isSubtractionNode: $2, isModuloNode: D, isMathOperatorNode: T, isEachKeywordNode: N2, isForKeywordNode: w, isURLFunctionNode: f, isIfElseKeywordNode: E, hasComposesNode: B, hasParensAroundNode: k, hasEmptyRawBefore: M2, isDetachedRulesetCallNode: d2, isTemplatePlaceholderNode: v2, isTemplatePropNode: S, isPostcssSimpleVarNode: b, isKeyValuePairNode: R2, isKeyValuePairInParenGroupNode: q, isKeyInValuePairNode: ee2, isSCSSMapItemNode: J, isInlineValueCommentNode: L, isHashNode: Q, isLeftCurlyBraceNode: V, isRightCurlyBraceNode: j, isWordNode: Y, isColonNode: ie2, isMediaAndSupportsKeywords: ce2, isColorAdjusterFuncNode: W, lastLineHasInlineComment: K2, isAtWordPlaceholderNode: de, isConfigurationNode: ue2, isParenGroupNode: Fe2 };
        } }), Id2 = te2({ "src/utils/line-column-to-index.js"(e, r) {
          ne2(), r.exports = function(t, s) {
            let a = 0;
            for (let n = 0; n < t.line - 1; ++n)
              a = s.indexOf(`
`, a) + 1;
            return a + t.column;
          };
        } }), kd2 = te2({ "src/language-css/loc.js"(e, r) {
          ne2();
          var { skipEverythingButNewLine: t } = Pr2(), s = lt2(), a = Id2();
          function n(c, f) {
            return typeof c.sourceIndex == "number" ? c.sourceIndex : c.source ? a(c.source.start, f) - 1 : null;
          }
          function u(c, f) {
            if (c.type === "css-comment" && c.inline)
              return t(f, c.source.startOffset);
            let F = c.nodes && s(c.nodes);
            return F && c.source && !c.source.end && (c = F), c.source && c.source.end ? a(c.source.end, f) : null;
          }
          function i(c, f) {
            c.source && (c.source.startOffset = n(c, f), c.source.endOffset = u(c, f));
            for (let F in c) {
              let _ = c[F];
              F === "source" || !_ || typeof _ != "object" || (_.type === "value-root" || _.type === "value-unknown" ? l(_, p(c), _.text || _.value) : i(_, f));
            }
          }
          function l(c, f, F) {
            c.source && (c.source.startOffset = n(c, F) + f, c.source.endOffset = u(c, F) + f);
            for (let _ in c) {
              let w = c[_];
              _ === "source" || !w || typeof w != "object" || l(w, f, F);
            }
          }
          function p(c) {
            let f = c.source.startOffset;
            return typeof c.prop == "string" && (f += c.prop.length), c.type === "css-atrule" && typeof c.name == "string" && (f += 1 + c.name.length + c.raws.afterName.match(/^\s*:?\s*/)[0].length), c.type !== "css-atrule" && c.raws && typeof c.raws.between == "string" && (f += c.raws.between.length), f;
          }
          function y2(c) {
            let f = "initial", F = "initial", _, w = false, E = [];
            for (let N2 = 0; N2 < c.length; N2++) {
              let x = c[N2];
              switch (f) {
                case "initial":
                  if (x === "'") {
                    f = "single-quotes";
                    continue;
                  }
                  if (x === '"') {
                    f = "double-quotes";
                    continue;
                  }
                  if ((x === "u" || x === "U") && c.slice(N2, N2 + 4).toLowerCase() === "url(") {
                    f = "url", N2 += 3;
                    continue;
                  }
                  if (x === "*" && c[N2 - 1] === "/") {
                    f = "comment-block";
                    continue;
                  }
                  if (x === "/" && c[N2 - 1] === "/") {
                    f = "comment-inline", _ = N2 - 1;
                    continue;
                  }
                  continue;
                case "single-quotes":
                  if (x === "'" && c[N2 - 1] !== "\\" && (f = F, F = "initial"), x === `
` || x === "\r")
                    return c;
                  continue;
                case "double-quotes":
                  if (x === '"' && c[N2 - 1] !== "\\" && (f = F, F = "initial"), x === `
` || x === "\r")
                    return c;
                  continue;
                case "url":
                  if (x === ")" && (f = "initial"), x === `
` || x === "\r")
                    return c;
                  if (x === "'") {
                    f = "single-quotes", F = "url";
                    continue;
                  }
                  if (x === '"') {
                    f = "double-quotes", F = "url";
                    continue;
                  }
                  continue;
                case "comment-block":
                  x === "/" && c[N2 - 1] === "*" && (f = "initial");
                  continue;
                case "comment-inline":
                  (x === '"' || x === "'" || x === "*") && (w = true), (x === `
` || x === "\r") && (w && E.push([_, N2]), f = "initial", w = false);
                  continue;
              }
            }
            for (let [N2, x] of E)
              c = c.slice(0, N2) + c.slice(N2, x).replace(/["'*]/g, " ") + c.slice(x);
            return c;
          }
          function h(c) {
            return c.source.startOffset;
          }
          function g2(c) {
            return c.source.endOffset;
          }
          r.exports = { locStart: h, locEnd: g2, calculateLoc: i, replaceQuotesInInlineComments: y2 };
        } }), Ld2 = te2({ "src/language-css/utils/is-less-parser.js"(e, r) {
          ne2();
          function t(s) {
            return s.parser === "css" || s.parser === "less";
          }
          r.exports = t;
        } }), Od2 = te2({ "src/language-css/utils/is-scss.js"(e, r) {
          ne2();
          function t(s, a) {
            return s === "less" || s === "scss" ? s === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(a);
          }
          r.exports = t;
        } }), jd2 = te2({ "src/language-css/utils/css-units.evaluate.js"(e, r) {
          r.exports = { em: "em", rem: "rem", ex: "ex", rex: "rex", cap: "cap", rcap: "rcap", ch: "ch", rch: "rch", ic: "ic", ric: "ric", lh: "lh", rlh: "rlh", vw: "vw", svw: "svw", lvw: "lvw", dvw: "dvw", vh: "vh", svh: "svh", lvh: "lvh", dvh: "dvh", vi: "vi", svi: "svi", lvi: "lvi", dvi: "dvi", vb: "vb", svb: "svb", lvb: "lvb", dvb: "dvb", vmin: "vmin", svmin: "svmin", lvmin: "lvmin", dvmin: "dvmin", vmax: "vmax", svmax: "svmax", lvmax: "lvmax", dvmax: "dvmax", cm: "cm", mm: "mm", q: "Q", in: "in", pt: "pt", pc: "pc", px: "px", deg: "deg", grad: "grad", rad: "rad", turn: "turn", s: "s", ms: "ms", hz: "Hz", khz: "kHz", dpi: "dpi", dpcm: "dpcm", dppx: "dppx", x: "x" };
        } }), qd2 = te2({ "src/language-css/utils/print-unit.js"(e, r) {
          ne2();
          var t = jd2();
          function s(a) {
            let n = a.toLowerCase();
            return Object.prototype.hasOwnProperty.call(t, n) ? t[n] : a;
          }
          r.exports = s;
        } }), Md2 = te2({ "src/language-css/printer-postcss.js"(e, r) {
          ne2();
          var t = lt2(), { printNumber: s, printString: a, hasNewline: n, isFrontMatterNode: u, isNextLineEmpty: i, isNonEmptyArray: l } = Ue2(), { builders: { join: p, line: y2, hardline: h, softline: g2, group: c, fill: f, indent: F, dedent: _, ifBreak: w, breakParent: E }, utils: { removeLines: N2, getDocParts: x } } = qe2(), I2 = Nd2(), P = wd2(), { insertPragma: $2 } = _d2(), { getAncestorNode: D, getPropOfDeclNode: T, maybeToLowerCase: m, insideValueFunctionNode: C, insideICSSRuleNode: o, insideAtRuleNode: d2, insideURLFunctionInImportAtRuleNode: v2, isKeyframeAtRuleKeywords: S, isWideKeywords: b, isLastNode: B, isSCSSControlDirectiveNode: k, isDetachedRulesetDeclarationNode: M2, isRelationalOperatorNode: R2, isEqualityOperatorNode: q, isMultiplicationNode: J, isDivisionNode: L, isAdditionNode: Q, isSubtractionNode: V, isMathOperatorNode: j, isEachKeywordNode: Y, isForKeywordNode: ie2, isURLFunctionNode: ee2, isIfElseKeywordNode: ce2, hasComposesNode: W, hasParensAroundNode: K2, hasEmptyRawBefore: de, isKeyValuePairNode: ue2, isKeyInValuePairNode: Fe2, isDetachedRulesetCallNode: z, isTemplatePlaceholderNode: U2, isTemplatePropNode: Z, isPostcssSimpleVarNode: se2, isSCSSMapItemNode: fe2, isInlineValueCommentNode: ge2, isHashNode: he2, isLeftCurlyBraceNode: we2, isRightCurlyBraceNode: ke2, isWordNode: Re2, isColonNode: Ne2, isMediaAndSupportsKeywords: Pe2, isColorAdjusterFuncNode: oe, lastLineHasInlineComment: H, isAtWordPlaceholderNode: pe2, isConfigurationNode: X, isParenGroupNode: le2 } = Pd2(), { locStart: Ae2, locEnd: Ee } = kd2(), De2 = Ld2(), A = Od2(), G = qd2();
          function re(Te2) {
            return Te2.trailingComma === "es5" || Te2.trailingComma === "all";
          }
          function ye2(Te2, je2, Me2) {
            let ae2 = Te2.getValue();
            if (!ae2)
              return "";
            if (typeof ae2 == "string")
              return ae2;
            switch (ae2.type) {
              case "front-matter":
                return [ae2.raw, h];
              case "css-root": {
                let Ve2 = Ce2(Te2, je2, Me2), We2 = ae2.raws.after.trim();
                return We2.startsWith(";") && (We2 = We2.slice(1).trim()), [Ve2, We2 ? ` ${We2}` : "", x(Ve2).length > 0 ? h : ""];
              }
              case "css-comment": {
                let Ve2 = ae2.inline || ae2.raws.inline, We2 = je2.originalText.slice(Ae2(ae2), Ee(ae2));
                return Ve2 ? We2.trimEnd() : We2;
              }
              case "css-rule":
                return [Me2("selector"), ae2.important ? " !important" : "", ae2.nodes ? [ae2.selector && ae2.selector.type === "selector-unknown" && H(ae2.selector.value) ? y2 : " ", "{", ae2.nodes.length > 0 ? F([h, Ce2(Te2, je2, Me2)]) : "", h, "}", M2(ae2) ? ";" : ""] : ";"];
              case "css-decl": {
                let Ve2 = Te2.getParentNode(), { between: We2 } = ae2.raws, Xe = We2.trim(), st2 = Xe === ":", O = W(ae2) ? N2(Me2("value")) : Me2("value");
                return !st2 && H(Xe) && (O = F([h, _(O)])), [ae2.raws.before.replace(/[\s;]/g, ""), Ve2.type === "css-atrule" && Ve2.variable || o(Te2) ? ae2.prop : m(ae2.prop), Xe.startsWith("//") ? " " : "", Xe, ae2.extend ? "" : " ", De2(je2) && ae2.extend && ae2.selector ? ["extend(", Me2("selector"), ")"] : "", O, ae2.raws.important ? ae2.raws.important.replace(/\s*!\s*important/i, " !important") : ae2.important ? " !important" : "", ae2.raws.scssDefault ? ae2.raws.scssDefault.replace(/\s*!default/i, " !default") : ae2.scssDefault ? " !default" : "", ae2.raws.scssGlobal ? ae2.raws.scssGlobal.replace(/\s*!global/i, " !global") : ae2.scssGlobal ? " !global" : "", ae2.nodes ? [" {", F([g2, Ce2(Te2, je2, Me2)]), g2, "}"] : Z(ae2) && !Ve2.raws.semicolon && je2.originalText[Ee(ae2) - 1] !== ";" ? "" : je2.__isHTMLStyleAttribute && B(Te2, ae2) ? w(";") : ";"];
              }
              case "css-atrule": {
                let Ve2 = Te2.getParentNode(), We2 = U2(ae2) && !Ve2.raws.semicolon && je2.originalText[Ee(ae2) - 1] !== ";";
                if (De2(je2)) {
                  if (ae2.mixin)
                    return [Me2("selector"), ae2.important ? " !important" : "", We2 ? "" : ";"];
                  if (ae2.function)
                    return [ae2.name, Me2("params"), We2 ? "" : ";"];
                  if (ae2.variable)
                    return ["@", ae2.name, ": ", ae2.value ? Me2("value") : "", ae2.raws.between.trim() ? ae2.raws.between.trim() + " " : "", ae2.nodes ? ["{", F([ae2.nodes.length > 0 ? g2 : "", Ce2(Te2, je2, Me2)]), g2, "}"] : "", We2 ? "" : ";"];
                }
                return ["@", z(ae2) || ae2.name.endsWith(":") ? ae2.name : m(ae2.name), ae2.params ? [z(ae2) ? "" : U2(ae2) ? ae2.raws.afterName === "" ? "" : ae2.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(ae2.raws.afterName) ? [h, h] : /^\s*\n/.test(ae2.raws.afterName) ? h : " " : " ", Me2("params")] : "", ae2.selector ? F([" ", Me2("selector")]) : "", ae2.value ? c([" ", Me2("value"), k(ae2) ? K2(ae2) ? " " : y2 : ""]) : ae2.name === "else" ? " " : "", ae2.nodes ? [k(ae2) ? "" : ae2.selector && !ae2.selector.nodes && typeof ae2.selector.value == "string" && H(ae2.selector.value) || !ae2.selector && typeof ae2.params == "string" && H(ae2.params) ? y2 : " ", "{", F([ae2.nodes.length > 0 ? g2 : "", Ce2(Te2, je2, Me2)]), g2, "}"] : We2 ? "" : ";"];
              }
              case "media-query-list": {
                let Ve2 = [];
                return Te2.each((We2) => {
                  let Xe = We2.getValue();
                  Xe.type === "media-query" && Xe.value === "" || Ve2.push(Me2());
                }, "nodes"), c(F(p(y2, Ve2)));
              }
              case "media-query":
                return [p(" ", Te2.map(Me2, "nodes")), B(Te2, ae2) ? "" : ","];
              case "media-type":
                return Oe2(Se2(ae2.value, je2));
              case "media-feature-expression":
                return ae2.nodes ? ["(", ...Te2.map(Me2, "nodes"), ")"] : ae2.value;
              case "media-feature":
                return m(Se2(ae2.value.replace(/ +/g, " "), je2));
              case "media-colon":
                return [ae2.value, " "];
              case "media-value":
                return Oe2(Se2(ae2.value, je2));
              case "media-keyword":
                return Se2(ae2.value, je2);
              case "media-url":
                return Se2(ae2.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), je2);
              case "media-unknown":
                return ae2.value;
              case "selector-root":
                return c([d2(Te2, "custom-selector") ? [D(Te2, "css-atrule").customSelector, y2] : "", p([",", d2(Te2, ["extend", "custom-selector", "nest"]) ? y2 : h], Te2.map(Me2, "nodes"))]);
              case "selector-selector":
                return c(F(Te2.map(Me2, "nodes")));
              case "selector-comment":
                return ae2.value;
              case "selector-string":
                return Se2(ae2.value, je2);
              case "selector-tag": {
                let Ve2 = Te2.getParentNode(), We2 = Ve2 && Ve2.nodes.indexOf(ae2), Xe = We2 && Ve2.nodes[We2 - 1];
                return [ae2.namespace ? [ae2.namespace === true ? "" : ae2.namespace.trim(), "|"] : "", Xe.type === "selector-nesting" ? ae2.value : Oe2(S(Te2, ae2.value) ? ae2.value.toLowerCase() : ae2.value)];
              }
              case "selector-id":
                return ["#", ae2.value];
              case "selector-class":
                return [".", Oe2(Se2(ae2.value, je2))];
              case "selector-attribute": {
                var nt;
                return ["[", ae2.namespace ? [ae2.namespace === true ? "" : ae2.namespace.trim(), "|"] : "", ae2.attribute.trim(), (nt = ae2.operator) !== null && nt !== void 0 ? nt : "", ae2.value ? Ie2(Se2(ae2.value.trim(), je2), je2) : "", ae2.insensitive ? " i" : "", "]"];
              }
              case "selector-combinator": {
                if (ae2.value === "+" || ae2.value === ">" || ae2.value === "~" || ae2.value === ">>>") {
                  let Xe = Te2.getParentNode();
                  return [Xe.type === "selector-selector" && Xe.nodes[0] === ae2 ? "" : y2, ae2.value, B(Te2, ae2) ? "" : " "];
                }
                let Ve2 = ae2.value.trim().startsWith("(") ? y2 : "", We2 = Oe2(Se2(ae2.value.trim(), je2)) || y2;
                return [Ve2, We2];
              }
              case "selector-universal":
                return [ae2.namespace ? [ae2.namespace === true ? "" : ae2.namespace.trim(), "|"] : "", ae2.value];
              case "selector-pseudo":
                return [m(ae2.value), l(ae2.nodes) ? c(["(", F([g2, p([",", y2], Te2.map(Me2, "nodes"))]), g2, ")"]) : ""];
              case "selector-nesting":
                return ae2.value;
              case "selector-unknown": {
                let Ve2 = D(Te2, "css-rule");
                if (Ve2 && Ve2.isSCSSNesterProperty)
                  return Oe2(Se2(m(ae2.value), je2));
                let We2 = Te2.getParentNode();
                if (We2.raws && We2.raws.selector) {
                  let st2 = Ae2(We2), O = st2 + We2.raws.selector.length;
                  return je2.originalText.slice(st2, O).trim();
                }
                let Xe = Te2.getParentNode(1);
                if (We2.type === "value-paren_group" && Xe && Xe.type === "value-func" && Xe.value === "selector") {
                  let st2 = Ee(We2.open) + 1, O = Ae2(We2.close), me2 = je2.originalText.slice(st2, O).trim();
                  return H(me2) ? [E, me2] : me2;
                }
                return ae2.value;
              }
              case "value-value":
              case "value-root":
                return Me2("group");
              case "value-comment":
                return je2.originalText.slice(Ae2(ae2), Ee(ae2));
              case "value-comma_group": {
                let Ve2 = Te2.getParentNode(), We2 = Te2.getParentNode(1), Xe = T(Te2), st2 = Xe && Ve2.type === "value-value" && (Xe === "grid" || Xe.startsWith("grid-template")), O = D(Te2, "css-atrule"), me2 = O && k(O), _e2 = ae2.groups.some((at2) => ge2(at2)), He2 = Te2.map(Me2, "groups"), Ge2 = [], it2 = C(Te2, "url"), Qe = false, rt2 = false;
                for (let at2 = 0; at2 < ae2.groups.length; ++at2) {
                  var tt;
                  Ge2.push(He2[at2]);
                  let Ze2 = ae2.groups[at2 - 1], Le = ae2.groups[at2], $e2 = ae2.groups[at2 + 1], sr2 = ae2.groups[at2 + 2];
                  if (it2) {
                    ($e2 && Q($e2) || Q(Le)) && Ge2.push(" ");
                    continue;
                  }
                  if (d2(Te2, "forward") && Le.type === "value-word" && Le.value && Ze2 !== void 0 && Ze2.type === "value-word" && Ze2.value === "as" && $e2.type === "value-operator" && $e2.value === "*" || !$e2 || Le.type === "value-word" && Le.value.endsWith("-") && pe2($e2))
                    continue;
                  if (Le.type === "value-string" && Le.quoted) {
                    let $r2 = Le.value.lastIndexOf("#{"), Vr2 = Le.value.lastIndexOf("}");
                    $r2 !== -1 && Vr2 !== -1 ? Qe = $r2 > Vr2 : $r2 !== -1 ? Qe = true : Vr2 !== -1 && (Qe = false);
                  }
                  if (Qe || Ne2(Le) || Ne2($e2) || Le.type === "value-atword" && (Le.value === "" || Le.value.endsWith("[")) || $e2.type === "value-word" && $e2.value.startsWith("]") || Le.value === "~" || Le.value && Le.value.includes("\\") && $e2 && $e2.type !== "value-comment" || Ze2 && Ze2.value && Ze2.value.indexOf("\\") === Ze2.value.length - 1 && Le.type === "value-operator" && Le.value === "/" || Le.value === "\\" || se2(Le, $e2) || he2(Le) || we2(Le) || ke2($e2) || we2($e2) && de($e2) || ke2(Le) && de($e2) || Le.value === "--" && he2($e2))
                    continue;
                  let Rr2 = j(Le), ou = j($e2);
                  if ((Rr2 && he2($e2) || ou && ke2(Le)) && de($e2) || !Ze2 && L(Le) || C(Te2, "calc") && (Q(Le) || Q($e2) || V(Le) || V($e2)) && de($e2))
                    continue;
                  let qo2 = (Q(Le) || V(Le)) && at2 === 0 && ($e2.type === "value-number" || $e2.isHex) && We2 && oe(We2) && !de($e2), lu2 = sr2 && sr2.type === "value-func" || sr2 && Re2(sr2) || Le.type === "value-func" || Re2(Le), cu = $e2.type === "value-func" || Re2($e2) || Ze2 && Ze2.type === "value-func" || Ze2 && Re2(Ze2);
                  if (!(!(J($e2) || J(Le)) && !C(Te2, "calc") && !qo2 && (L($e2) && !lu2 || L(Le) && !cu || Q($e2) && !lu2 || Q(Le) && !cu || V($e2) || V(Le)) && (de($e2) || Rr2 && (!Ze2 || Ze2 && j(Ze2)))) && !((je2.parser === "scss" || je2.parser === "less") && Rr2 && Le.value === "-" && le2($e2) && Ee(Le) === Ae2($e2.open) && $e2.open.value === "(")) {
                    if (ge2(Le)) {
                      if (Ve2.type === "value-paren_group") {
                        Ge2.push(_(h));
                        continue;
                      }
                      Ge2.push(h);
                      continue;
                    }
                    if (me2 && (q($e2) || R2($e2) || ce2($e2) || Y(Le) || ie2(Le))) {
                      Ge2.push(" ");
                      continue;
                    }
                    if (O && O.name.toLowerCase() === "namespace") {
                      Ge2.push(" ");
                      continue;
                    }
                    if (st2) {
                      Le.source && $e2.source && Le.source.start.line !== $e2.source.start.line ? (Ge2.push(h), rt2 = true) : Ge2.push(" ");
                      continue;
                    }
                    if (ou) {
                      Ge2.push(" ");
                      continue;
                    }
                    if (!($e2 && $e2.value === "...") && !(pe2(Le) && pe2($e2) && Ee(Le) === Ae2($e2))) {
                      if (pe2(Le) && le2($e2) && Ee(Le) === Ae2($e2.open)) {
                        Ge2.push(g2);
                        continue;
                      }
                      if (Le.value === "with" && le2($e2)) {
                        Ge2.push(" ");
                        continue;
                      }
                      (tt = Le.value) !== null && tt !== void 0 && tt.endsWith("#") && $e2.value === "{" && le2($e2.group) || Ge2.push(y2);
                    }
                  }
                }
                return _e2 && Ge2.push(E), rt2 && Ge2.unshift(h), me2 ? c(F(Ge2)) : v2(Te2) ? c(f(Ge2)) : c(F(f(Ge2)));
              }
              case "value-paren_group": {
                let Ve2 = Te2.getParentNode();
                if (Ve2 && ee2(Ve2) && (ae2.groups.length === 1 || ae2.groups.length > 0 && ae2.groups[0].type === "value-comma_group" && ae2.groups[0].groups.length > 0 && ae2.groups[0].groups[0].type === "value-word" && ae2.groups[0].groups[0].value.startsWith("data:")))
                  return [ae2.open ? Me2("open") : "", p(",", Te2.map(Me2, "groups")), ae2.close ? Me2("close") : ""];
                if (!ae2.open) {
                  let it2 = Te2.map(Me2, "groups"), Qe = [];
                  for (let rt2 = 0; rt2 < it2.length; rt2++)
                    rt2 !== 0 && Qe.push([",", y2]), Qe.push(it2[rt2]);
                  return c(F(f(Qe)));
                }
                let We2 = fe2(Te2), Xe = t(ae2.groups), st2 = Xe && Xe.type === "value-comment", O = Fe2(ae2, Ve2), me2 = X(ae2, Ve2), _e2 = me2 || We2 && !O, He2 = me2 || O, Ge2 = c([ae2.open ? Me2("open") : "", F([g2, p([y2], Te2.map((it2, Qe) => {
                  let rt2 = it2.getValue(), at2 = Qe === ae2.groups.length - 1, Ze2 = [Me2(), at2 ? "" : ","];
                  if (ue2(rt2) && rt2.type === "value-comma_group" && rt2.groups && rt2.groups[0].type !== "value-paren_group" && rt2.groups[2] && rt2.groups[2].type === "value-paren_group") {
                    let Le = x(Ze2[0].contents.contents);
                    Le[1] = c(Le[1]), Ze2 = [c(_(Ze2))];
                  }
                  if (!at2 && rt2.type === "value-comma_group" && l(rt2.groups)) {
                    let Le = t(rt2.groups);
                    !Le.source && Le.close && (Le = Le.close), Le.source && i(je2.originalText, Le, Ee) && Ze2.push(h);
                  }
                  return Ze2;
                }, "groups"))]), w(!st2 && A(je2.parser, je2.originalText) && We2 && re(je2) ? "," : ""), g2, ae2.close ? Me2("close") : ""], { shouldBreak: _e2 });
                return He2 ? _(Ge2) : Ge2;
              }
              case "value-func":
                return [ae2.value, d2(Te2, "supports") && Pe2(ae2) ? " " : "", Me2("group")];
              case "value-paren":
                return ae2.value;
              case "value-number":
                return [Je2(ae2.value), G(ae2.unit)];
              case "value-operator":
                return ae2.value;
              case "value-word":
                return ae2.isColor && ae2.isHex || b(ae2.value) ? ae2.value.toLowerCase() : ae2.value;
              case "value-colon": {
                let Ve2 = Te2.getParentNode(), We2 = Ve2 && Ve2.groups.indexOf(ae2), Xe = We2 && Ve2.groups[We2 - 1];
                return [ae2.value, Xe && typeof Xe.value == "string" && t(Xe.value) === "\\" || C(Te2, "url") ? "" : y2];
              }
              case "value-comma":
                return [ae2.value, " "];
              case "value-string":
                return a(ae2.raws.quote + ae2.value + ae2.raws.quote, je2);
              case "value-atword":
                return ["@", ae2.value];
              case "value-unicode-range":
                return ae2.value;
              case "value-unknown":
                return ae2.value;
              default:
                throw new Error(`Unknown postcss type ${JSON.stringify(ae2.type)}`);
            }
          }
          function Ce2(Te2, je2, Me2) {
            let ae2 = [];
            return Te2.each((nt, tt, Ve2) => {
              let We2 = Ve2[tt - 1];
              if (We2 && We2.type === "css-comment" && We2.text.trim() === "prettier-ignore") {
                let Xe = nt.getValue();
                ae2.push(je2.originalText.slice(Ae2(Xe), Ee(Xe)));
              } else
                ae2.push(Me2());
              tt !== Ve2.length - 1 && (Ve2[tt + 1].type === "css-comment" && !n(je2.originalText, Ae2(Ve2[tt + 1]), { backwards: true }) && !u(Ve2[tt]) || Ve2[tt + 1].type === "css-atrule" && Ve2[tt + 1].name === "else" && Ve2[tt].type !== "css-comment" ? ae2.push(" ") : (ae2.push(je2.__isHTMLStyleAttribute ? y2 : h), i(je2.originalText, nt.getValue(), Ee) && !u(Ve2[tt]) && ae2.push(h)));
            }, "nodes"), ae2;
          }
          var Be = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, ve2 = /(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g, ze = /[A-Za-z]+/g, be2 = /[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g, Ye2 = new RegExp(Be.source + `|(${be2.source})?(${ve2.source})(${ze.source})?`, "g");
          function Se2(Te2, je2) {
            return Te2.replace(Be, (Me2) => a(Me2, je2));
          }
          function Ie2(Te2, je2) {
            let Me2 = je2.singleQuote ? "'" : '"';
            return Te2.includes('"') || Te2.includes("'") ? Te2 : Me2 + Te2 + Me2;
          }
          function Oe2(Te2) {
            return Te2.replace(Ye2, (je2, Me2, ae2, nt, tt) => !ae2 && nt ? Je2(nt) + m(tt || "") : je2);
          }
          function Je2(Te2) {
            return s(Te2).replace(/\.0(?=$|e)/, "");
          }
          r.exports = { print: ye2, embed: P, insertPragma: $2, massageAstNode: I2 };
        } }), Rd2 = te2({ "src/language-css/options.js"(e, r) {
          ne2();
          var t = Mt2();
          r.exports = { singleQuote: t.singleQuote };
        } }), $d2 = te2({ "src/language-css/parsers.js"() {
          ne2();
        } }), Vd2 = te2({ "node_modules/linguist-languages/data/CSS.json"(e, r) {
          r.exports = { name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css"], languageId: 50 };
        } }), Wd2 = te2({ "node_modules/linguist-languages/data/PostCSS.json"(e, r) {
          r.exports = { name: "PostCSS", type: "markup", color: "#dc3a0c", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", languageId: 262764437 };
        } }), Hd2 = te2({ "node_modules/linguist-languages/data/Less.json"(e, r) {
          r.exports = { name: "Less", type: "markup", color: "#1d365d", aliases: ["less-css"], extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198 };
        } }), Gd2 = te2({ "node_modules/linguist-languages/data/SCSS.json"(e, r) {
          r.exports = { name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], languageId: 329 };
        } }), Ud2 = te2({ "src/language-css/index.js"(e, r) {
          ne2();
          var t = _t2(), s = Md2(), a = Rd2(), n = $d2(), u = [t(Vd2(), (l) => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"], extensions: [...l.extensions, ".wxss"] })), t(Wd2(), () => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"] })), t(Hd2(), () => ({ since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"] })), t(Gd2(), () => ({ since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"] }))], i = { postcss: s };
          r.exports = { languages: u, options: a, printers: i, parsers: n };
        } }), Jd2 = te2({ "src/language-handlebars/loc.js"(e, r) {
          ne2();
          function t(a) {
            return a.loc.start.offset;
          }
          function s(a) {
            return a.loc.end.offset;
          }
          r.exports = { locStart: t, locEnd: s };
        } }), zd2 = te2({ "src/language-handlebars/clean.js"(e, r) {
          ne2();
          function t(s, a) {
            if (s.type === "TextNode") {
              let n = s.chars.trim();
              if (!n)
                return null;
              a.chars = n.replace(/[\t\n\f\r ]+/g, " ");
            }
            s.type === "AttrNode" && s.name.toLowerCase() === "class" && delete a.value;
          }
          t.ignoredProperties = /* @__PURE__ */ new Set(["loc", "selfClosing"]), r.exports = t;
        } }), Xd2 = te2({ "src/language-handlebars/html-void-elements.evaluate.js"(e, r) {
          r.exports = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
        } }), Kd2 = te2({ "src/language-handlebars/utils.js"(e, r) {
          ne2();
          var t = lt2(), s = Xd2();
          function a(x) {
            let I2 = x.getValue(), P = x.getParentNode(0);
            return !!(g2(x, ["ElementNode"]) && t(P.children) === I2 || g2(x, ["Block"]) && t(P.body) === I2);
          }
          function n(x) {
            return x.toUpperCase() === x;
          }
          function u(x) {
            return h(x, ["ElementNode"]) && typeof x.tag == "string" && !x.tag.startsWith(":") && (n(x.tag[0]) || x.tag.includes("."));
          }
          var i = new Set(s);
          function l(x) {
            return i.has(x.toLowerCase()) && !n(x[0]);
          }
          function p(x) {
            return x.selfClosing === true || l(x.tag) || u(x) && x.children.every((I2) => y2(I2));
          }
          function y2(x) {
            return h(x, ["TextNode"]) && !/\S/.test(x.chars);
          }
          function h(x, I2) {
            return x && I2.includes(x.type);
          }
          function g2(x, I2) {
            let P = x.getParentNode(0);
            return h(P, I2);
          }
          function c(x, I2) {
            let P = _(x);
            return h(P, I2);
          }
          function f(x, I2) {
            let P = w(x);
            return h(P, I2);
          }
          function F(x, I2) {
            var P, $2, D, T;
            let m = x.getValue(), C = (P = x.getParentNode(0)) !== null && P !== void 0 ? P : {}, o = ($2 = (D = (T = C.children) !== null && T !== void 0 ? T : C.body) !== null && D !== void 0 ? D : C.parts) !== null && $2 !== void 0 ? $2 : [], d2 = o.indexOf(m);
            return d2 !== -1 && o[d2 + I2];
          }
          function _(x) {
            let I2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
            return F(x, -I2);
          }
          function w(x) {
            return F(x, 1);
          }
          function E(x) {
            return h(x, ["MustacheCommentStatement"]) && typeof x.value == "string" && x.value.trim() === "prettier-ignore";
          }
          function N2(x) {
            let I2 = x.getValue(), P = _(x, 2);
            return E(I2) || E(P);
          }
          r.exports = { getNextNode: w, getPreviousNode: _, hasPrettierIgnore: N2, isLastNodeOfSiblings: a, isNextNodeOfSomeType: f, isNodeOfSomeType: h, isParentOfSomeType: g2, isPreviousNodeOfSomeType: c, isVoid: p, isWhitespaceNode: y2 };
        } }), Yd2 = te2({ "src/language-handlebars/printer-glimmer.js"(e, r) {
          ne2();
          var { builders: { dedent: t, fill: s, group: a, hardline: n, ifBreak: u, indent: i, join: l, line: p, softline: y2 }, utils: { getDocParts: h, replaceTextEndOfLine: g2 } } = qe2(), { getPreferredQuote: c, isNonEmptyArray: f } = Ue2(), { locStart: F, locEnd: _ } = Jd2(), w = zd2(), { getNextNode: E, getPreviousNode: N2, hasPrettierIgnore: x, isLastNodeOfSiblings: I2, isNextNodeOfSomeType: P, isNodeOfSomeType: $2, isParentOfSomeType: D, isPreviousNodeOfSomeType: T, isVoid: m, isWhitespaceNode: C } = Kd2(), o = 2;
          function d2(H, pe2, X) {
            let le2 = H.getValue();
            if (!le2)
              return "";
            if (x(H))
              return pe2.originalText.slice(F(le2), _(le2));
            let Ae2 = pe2.singleQuote ? "'" : '"';
            switch (le2.type) {
              case "Block":
              case "Program":
              case "Template":
                return a(H.map(X, "body"));
              case "ElementNode": {
                let Ee = a(S(H, X)), De2 = pe2.htmlWhitespaceSensitivity === "ignore" && P(H, ["ElementNode"]) ? y2 : "";
                if (m(le2))
                  return [Ee, De2];
                let A = ["</", le2.tag, ">"];
                return le2.children.length === 0 ? [Ee, i(A), De2] : pe2.htmlWhitespaceSensitivity === "ignore" ? [Ee, i(b(H, pe2, X)), n, i(A), De2] : [Ee, i(a(b(H, pe2, X))), i(A), De2];
              }
              case "BlockStatement": {
                let Ee = H.getParentNode(1);
                return Ee && Ee.inverse && Ee.inverse.body.length === 1 && Ee.inverse.body[0] === le2 && Ee.inverse.body[0].path.parts[0] === Ee.path.parts[0] ? [ie2(H, X, Ee.inverse.body[0].path.parts[0]), de(H, X, pe2), ue2(H, X, pe2)] : [j(H, X), a([de(H, X, pe2), ue2(H, X, pe2), ee2(H, X, pe2)])];
              }
              case "ElementModifierStatement":
                return a(["{{", Re2(H, X), "}}"]);
              case "MustacheStatement":
                return a([k(le2), Re2(H, X), M2(le2)]);
              case "SubExpression":
                return a(["(", ke2(H, X), y2, ")"]);
              case "AttrNode": {
                let Ee = le2.value.type === "TextNode";
                if (Ee && le2.value.chars === "" && F(le2.value) === _(le2.value))
                  return le2.name;
                let A = Ee ? c(le2.value.chars, Ae2).quote : le2.value.type === "ConcatStatement" ? c(le2.value.parts.filter((re) => re.type === "TextNode").map((re) => re.chars).join(""), Ae2).quote : "", G = X("value");
                return [le2.name, "=", A, le2.name === "class" && A ? a(i(G)) : G, A];
              }
              case "ConcatStatement":
                return H.map(X, "parts");
              case "Hash":
                return l(p, H.map(X, "pairs"));
              case "HashPair":
                return [le2.key, "=", X("value")];
              case "TextNode": {
                let Ee = le2.chars.replace(/{{/g, "\\{{"), De2 = U2(H);
                if (De2) {
                  if (De2 === "class") {
                    let Ye2 = Ee.trim().split(/\s+/).join(" "), Se2 = false, Ie2 = false;
                    return D(H, ["ConcatStatement"]) && (T(H, ["MustacheStatement"]) && /^\s/.test(Ee) && (Se2 = true), P(H, ["MustacheStatement"]) && /\s$/.test(Ee) && Ye2 !== "" && (Ie2 = true)), [Se2 ? p : "", Ye2, Ie2 ? p : ""];
                  }
                  return g2(Ee);
                }
                let G = /^[\t\n\f\r ]*$/.test(Ee), re = !N2(H), ye2 = !E(H);
                if (pe2.htmlWhitespaceSensitivity !== "ignore") {
                  let Ye2 = /^[\t\n\f\r ]*/, Se2 = /[\t\n\f\r ]*$/, Ie2 = ye2 && D(H, ["Template"]), Oe2 = re && D(H, ["Template"]);
                  if (G) {
                    if (Oe2 || Ie2)
                      return "";
                    let ae2 = [p], nt = Z(Ee);
                    return nt && (ae2 = ge2(nt)), I2(H) && (ae2 = ae2.map((tt) => t(tt))), ae2;
                  }
                  let [Je2] = Ee.match(Ye2), [Te2] = Ee.match(Se2), je2 = [];
                  if (Je2) {
                    je2 = [p];
                    let ae2 = Z(Je2);
                    ae2 && (je2 = ge2(ae2)), Ee = Ee.replace(Ye2, "");
                  }
                  let Me2 = [];
                  if (Te2) {
                    if (!Ie2) {
                      Me2 = [p];
                      let ae2 = Z(Te2);
                      ae2 && (Me2 = ge2(ae2)), I2(H) && (Me2 = Me2.map((nt) => t(nt)));
                    }
                    Ee = Ee.replace(Se2, "");
                  }
                  return [...je2, s(Fe2(Ee)), ...Me2];
                }
                let Ce2 = Z(Ee), Be = se2(Ee), ve2 = fe2(Ee);
                if ((re || ye2) && G && D(H, ["Block", "ElementNode", "Template"]))
                  return "";
                G && Ce2 ? (Be = Math.min(Ce2, o), ve2 = 0) : (P(H, ["BlockStatement", "ElementNode"]) && (ve2 = Math.max(ve2, 1)), T(H, ["BlockStatement", "ElementNode"]) && (Be = Math.max(Be, 1)));
                let ze = "", be2 = "";
                return ve2 === 0 && P(H, ["MustacheStatement"]) && (be2 = " "), Be === 0 && T(H, ["MustacheStatement"]) && (ze = " "), re && (Be = 0, ze = ""), ye2 && (ve2 = 0, be2 = ""), Ee = Ee.replace(/^[\t\n\f\r ]+/g, ze).replace(/[\t\n\f\r ]+$/, be2), [...ge2(Be), s(Fe2(Ee)), ...ge2(ve2)];
              }
              case "MustacheCommentStatement": {
                let Ee = F(le2), De2 = _(le2), A = pe2.originalText.charAt(Ee + 2) === "~", G = pe2.originalText.charAt(De2 - 3) === "~", re = le2.value.includes("}}") ? "--" : "";
                return ["{{", A ? "~" : "", "!", re, le2.value, re, G ? "~" : "", "}}"];
              }
              case "PathExpression":
                return le2.original;
              case "BooleanLiteral":
                return String(le2.value);
              case "CommentStatement":
                return ["<!--", le2.value, "-->"];
              case "StringLiteral": {
                if (we2(H)) {
                  let Ee = pe2.singleQuote ? '"' : "'";
                  return he2(le2.value, Ee);
                }
                return he2(le2.value, Ae2);
              }
              case "NumberLiteral":
                return String(le2.value);
              case "UndefinedLiteral":
                return "undefined";
              case "NullLiteral":
                return "null";
              default:
                throw new Error("unknown glimmer type: " + JSON.stringify(le2.type));
            }
          }
          function v2(H, pe2) {
            return F(H) - F(pe2);
          }
          function S(H, pe2) {
            let X = H.getValue(), le2 = ["attributes", "modifiers", "comments"].filter((Ee) => f(X[Ee])), Ae2 = le2.flatMap((Ee) => X[Ee]).sort(v2);
            for (let Ee of le2)
              H.each((De2) => {
                let A = Ae2.indexOf(De2.getValue());
                Ae2.splice(A, 1, [p, pe2()]);
              }, Ee);
            return f(X.blockParams) && Ae2.push(p, oe(X)), ["<", X.tag, i(Ae2), B(X)];
          }
          function b(H, pe2, X) {
            let Ae2 = H.getValue().children.every((Ee) => C(Ee));
            return pe2.htmlWhitespaceSensitivity === "ignore" && Ae2 ? "" : H.map((Ee, De2) => {
              let A = X();
              return De2 === 0 && pe2.htmlWhitespaceSensitivity === "ignore" ? [y2, A] : A;
            }, "children");
          }
          function B(H) {
            return m(H) ? u([y2, "/>"], [" />", y2]) : u([y2, ">"], ">");
          }
          function k(H) {
            let pe2 = H.escaped === false ? "{{{" : "{{", X = H.strip && H.strip.open ? "~" : "";
            return [pe2, X];
          }
          function M2(H) {
            let pe2 = H.escaped === false ? "}}}" : "}}";
            return [H.strip && H.strip.close ? "~" : "", pe2];
          }
          function R2(H) {
            let pe2 = k(H), X = H.openStrip.open ? "~" : "";
            return [pe2, X, "#"];
          }
          function q(H) {
            let pe2 = M2(H);
            return [H.openStrip.close ? "~" : "", pe2];
          }
          function J(H) {
            let pe2 = k(H), X = H.closeStrip.open ? "~" : "";
            return [pe2, X, "/"];
          }
          function L(H) {
            let pe2 = M2(H);
            return [H.closeStrip.close ? "~" : "", pe2];
          }
          function Q(H) {
            let pe2 = k(H), X = H.inverseStrip.open ? "~" : "";
            return [pe2, X];
          }
          function V(H) {
            let pe2 = M2(H);
            return [H.inverseStrip.close ? "~" : "", pe2];
          }
          function j(H, pe2) {
            let X = H.getValue(), le2 = [], Ae2 = Pe2(H, pe2);
            return Ae2 && le2.push(a(Ae2)), f(X.program.blockParams) && le2.push(oe(X.program)), a([R2(X), Ne2(H, pe2), le2.length > 0 ? i([p, l(p, le2)]) : "", y2, q(X)]);
          }
          function Y(H, pe2) {
            return [pe2.htmlWhitespaceSensitivity === "ignore" ? n : "", Q(H), "else", V(H)];
          }
          function ie2(H, pe2, X) {
            let le2 = H.getValue(), Ae2 = H.getParentNode(1);
            return a([Q(Ae2), ["else", " ", X], i([p, a(Pe2(H, pe2)), ...f(le2.program.blockParams) ? [p, oe(le2.program)] : []]), y2, V(Ae2)]);
          }
          function ee2(H, pe2, X) {
            let le2 = H.getValue();
            return X.htmlWhitespaceSensitivity === "ignore" ? [ce2(le2) ? y2 : n, J(le2), pe2("path"), L(le2)] : [J(le2), pe2("path"), L(le2)];
          }
          function ce2(H) {
            return $2(H, ["BlockStatement"]) && H.program.body.every((pe2) => C(pe2));
          }
          function W(H) {
            return K2(H) && H.inverse.body.length === 1 && $2(H.inverse.body[0], ["BlockStatement"]) && H.inverse.body[0].path.parts[0] === H.path.parts[0];
          }
          function K2(H) {
            return $2(H, ["BlockStatement"]) && H.inverse;
          }
          function de(H, pe2, X) {
            let le2 = H.getValue();
            if (ce2(le2))
              return "";
            let Ae2 = pe2("program");
            return X.htmlWhitespaceSensitivity === "ignore" ? i([n, Ae2]) : i(Ae2);
          }
          function ue2(H, pe2, X) {
            let le2 = H.getValue(), Ae2 = pe2("inverse"), Ee = X.htmlWhitespaceSensitivity === "ignore" ? [n, Ae2] : Ae2;
            return W(le2) ? Ee : K2(le2) ? [Y(le2, X), i(Ee)] : "";
          }
          function Fe2(H) {
            return h(l(p, z(H)));
          }
          function z(H) {
            return H.split(/[\t\n\f\r ]+/);
          }
          function U2(H) {
            for (let pe2 = 0; pe2 < 2; pe2++) {
              let X = H.getParentNode(pe2);
              if (X && X.type === "AttrNode")
                return X.name.toLowerCase();
            }
          }
          function Z(H) {
            return H = typeof H == "string" ? H : "", H.split(`
`).length - 1;
          }
          function se2(H) {
            H = typeof H == "string" ? H : "";
            let pe2 = (H.match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "";
            return Z(pe2);
          }
          function fe2(H) {
            H = typeof H == "string" ? H : "";
            let pe2 = (H.match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "";
            return Z(pe2);
          }
          function ge2() {
            let H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            return Array.from({ length: Math.min(H, o) }).fill(n);
          }
          function he2(H, pe2) {
            let { quote: X, regex: le2 } = c(H, pe2);
            return [X, H.replace(le2, `\\${X}`), X];
          }
          function we2(H) {
            let pe2 = 0, X = H.getParentNode(pe2);
            for (; X && $2(X, ["SubExpression"]); )
              pe2++, X = H.getParentNode(pe2);
            return !!(X && $2(H.getParentNode(pe2 + 1), ["ConcatStatement"]) && $2(H.getParentNode(pe2 + 2), ["AttrNode"]));
          }
          function ke2(H, pe2) {
            let X = Ne2(H, pe2), le2 = Pe2(H, pe2);
            return le2 ? i([X, p, a(le2)]) : X;
          }
          function Re2(H, pe2) {
            let X = Ne2(H, pe2), le2 = Pe2(H, pe2);
            return le2 ? [i([X, p, le2]), y2] : X;
          }
          function Ne2(H, pe2) {
            return pe2("path");
          }
          function Pe2(H, pe2) {
            let X = H.getValue(), le2 = [];
            if (X.params.length > 0) {
              let Ae2 = H.map(pe2, "params");
              le2.push(...Ae2);
            }
            if (X.hash && X.hash.pairs.length > 0) {
              let Ae2 = pe2("hash");
              le2.push(Ae2);
            }
            return le2.length === 0 ? "" : l(p, le2);
          }
          function oe(H) {
            return ["as |", H.blockParams.join(" "), "|"];
          }
          r.exports = { print: d2, massageAstNode: w };
        } }), Qd2 = te2({ "src/language-handlebars/parsers.js"() {
          ne2();
        } }), Zd2 = te2({ "node_modules/linguist-languages/data/Handlebars.json"(e, r) {
          r.exports = { name: "Handlebars", type: "markup", color: "#f7931e", aliases: ["hbs", "htmlbars"], extensions: [".handlebars", ".hbs"], tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155 };
        } }), eg2 = te2({ "src/language-handlebars/index.js"(e, r) {
          ne2();
          var t = _t2(), s = Yd2(), a = Qd2(), n = [t(Zd2(), () => ({ since: "2.3.0", parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"] }))], u = { glimmer: s };
          r.exports = { languages: n, printers: u, parsers: a };
        } }), tg2 = te2({ "src/language-graphql/pragma.js"(e, r) {
          ne2();
          function t(a) {
            return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(a);
          }
          function s(a) {
            return `# @format

` + a;
          }
          r.exports = { hasPragma: t, insertPragma: s };
        } }), rg2 = te2({ "src/language-graphql/loc.js"(e, r) {
          ne2();
          function t(a) {
            return typeof a.start == "number" ? a.start : a.loc && a.loc.start;
          }
          function s(a) {
            return typeof a.end == "number" ? a.end : a.loc && a.loc.end;
          }
          r.exports = { locStart: t, locEnd: s };
        } }), ng2 = te2({ "src/language-graphql/printer-graphql.js"(e, r) {
          ne2();
          var { builders: { join: t, hardline: s, line: a, softline: n, group: u, indent: i, ifBreak: l } } = qe2(), { isNextLineEmpty: p, isNonEmptyArray: y2 } = Ue2(), { insertPragma: h } = tg2(), { locStart: g2, locEnd: c } = rg2();
          function f(P, $2, D) {
            let T = P.getValue();
            if (!T)
              return "";
            if (typeof T == "string")
              return T;
            switch (T.kind) {
              case "Document": {
                let m = [];
                return P.each((C, o, d2) => {
                  m.push(D()), o !== d2.length - 1 && (m.push(s), p($2.originalText, C.getValue(), c) && m.push(s));
                }, "definitions"), [...m, s];
              }
              case "OperationDefinition": {
                let m = $2.originalText[g2(T)] !== "{", C = Boolean(T.name);
                return [m ? T.operation : "", m && C ? [" ", D("name")] : "", m && !C && y2(T.variableDefinitions) ? " " : "", y2(T.variableDefinitions) ? u(["(", i([n, t([l("", ", "), n], P.map(D, "variableDefinitions"))]), n, ")"]) : "", F(P, D, T), T.selectionSet ? !m && !C ? "" : " " : "", D("selectionSet")];
              }
              case "FragmentDefinition":
                return ["fragment ", D("name"), y2(T.variableDefinitions) ? u(["(", i([n, t([l("", ", "), n], P.map(D, "variableDefinitions"))]), n, ")"]) : "", " on ", D("typeCondition"), F(P, D, T), " ", D("selectionSet")];
              case "SelectionSet":
                return ["{", i([s, t(s, _(P, $2, D, "selections"))]), s, "}"];
              case "Field":
                return u([T.alias ? [D("alias"), ": "] : "", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $2, D, "arguments"))]), n, ")"]) : "", F(P, D, T), T.selectionSet ? " " : "", D("selectionSet")]);
              case "Name":
                return T.value;
              case "StringValue": {
                if (T.block) {
                  let m = T.value.replace(/"""/g, "\\$&").split(`
`);
                  return m.length === 1 && (m[0] = m[0].trim()), m.every((C) => C === "") && (m.length = 0), t(s, ['"""', ...m, '"""']);
                }
                return ['"', T.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
              }
              case "IntValue":
              case "FloatValue":
              case "EnumValue":
                return T.value;
              case "BooleanValue":
                return T.value ? "true" : "false";
              case "NullValue":
                return "null";
              case "Variable":
                return ["$", D("name")];
              case "ListValue":
                return u(["[", i([n, t([l("", ", "), n], P.map(D, "values"))]), n, "]"]);
              case "ObjectValue":
                return u(["{", $2.bracketSpacing && T.fields.length > 0 ? " " : "", i([n, t([l("", ", "), n], P.map(D, "fields"))]), n, l("", $2.bracketSpacing && T.fields.length > 0 ? " " : ""), "}"]);
              case "ObjectField":
              case "Argument":
                return [D("name"), ": ", D("value")];
              case "Directive":
                return ["@", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $2, D, "arguments"))]), n, ")"]) : ""];
              case "NamedType":
                return D("name");
              case "VariableDefinition":
                return [D("variable"), ": ", D("type"), T.defaultValue ? [" = ", D("defaultValue")] : "", F(P, D, T)];
              case "ObjectTypeExtension":
              case "ObjectTypeDefinition":
                return [D("description"), T.description ? s : "", T.kind === "ObjectTypeExtension" ? "extend " : "", "type ", D("name"), T.interfaces.length > 0 ? [" implements ", ...N2(P, $2, D)] : "", F(P, D, T), T.fields.length > 0 ? [" {", i([s, t(s, _(P, $2, D, "fields"))]), s, "}"] : ""];
              case "FieldDefinition":
                return [D("description"), T.description ? s : "", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $2, D, "arguments"))]), n, ")"]) : "", ": ", D("type"), F(P, D, T)];
              case "DirectiveDefinition":
                return [D("description"), T.description ? s : "", "directive ", "@", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $2, D, "arguments"))]), n, ")"]) : "", T.repeatable ? " repeatable" : "", " on ", t(" | ", P.map(D, "locations"))];
              case "EnumTypeExtension":
              case "EnumTypeDefinition":
                return [D("description"), T.description ? s : "", T.kind === "EnumTypeExtension" ? "extend " : "", "enum ", D("name"), F(P, D, T), T.values.length > 0 ? [" {", i([s, t(s, _(P, $2, D, "values"))]), s, "}"] : ""];
              case "EnumValueDefinition":
                return [D("description"), T.description ? s : "", D("name"), F(P, D, T)];
              case "InputValueDefinition":
                return [D("description"), T.description ? T.description.block ? s : a : "", D("name"), ": ", D("type"), T.defaultValue ? [" = ", D("defaultValue")] : "", F(P, D, T)];
              case "InputObjectTypeExtension":
              case "InputObjectTypeDefinition":
                return [D("description"), T.description ? s : "", T.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", D("name"), F(P, D, T), T.fields.length > 0 ? [" {", i([s, t(s, _(P, $2, D, "fields"))]), s, "}"] : ""];
              case "SchemaExtension":
                return ["extend schema", F(P, D, T), ...T.operationTypes.length > 0 ? [" {", i([s, t(s, _(P, $2, D, "operationTypes"))]), s, "}"] : []];
              case "SchemaDefinition":
                return [D("description"), T.description ? s : "", "schema", F(P, D, T), " {", T.operationTypes.length > 0 ? i([s, t(s, _(P, $2, D, "operationTypes"))]) : "", s, "}"];
              case "OperationTypeDefinition":
                return [D("operation"), ": ", D("type")];
              case "InterfaceTypeExtension":
              case "InterfaceTypeDefinition":
                return [D("description"), T.description ? s : "", T.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", D("name"), T.interfaces.length > 0 ? [" implements ", ...N2(P, $2, D)] : "", F(P, D, T), T.fields.length > 0 ? [" {", i([s, t(s, _(P, $2, D, "fields"))]), s, "}"] : ""];
              case "FragmentSpread":
                return ["...", D("name"), F(P, D, T)];
              case "InlineFragment":
                return ["...", T.typeCondition ? [" on ", D("typeCondition")] : "", F(P, D, T), " ", D("selectionSet")];
              case "UnionTypeExtension":
              case "UnionTypeDefinition":
                return u([D("description"), T.description ? s : "", u([T.kind === "UnionTypeExtension" ? "extend " : "", "union ", D("name"), F(P, D, T), T.types.length > 0 ? [" =", l("", " "), i([l([a, "  "]), t([a, "| "], P.map(D, "types"))])] : ""])]);
              case "ScalarTypeExtension":
              case "ScalarTypeDefinition":
                return [D("description"), T.description ? s : "", T.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", D("name"), F(P, D, T)];
              case "NonNullType":
                return [D("type"), "!"];
              case "ListType":
                return ["[", D("type"), "]"];
              default:
                throw new Error("unknown graphql type: " + JSON.stringify(T.kind));
            }
          }
          function F(P, $2, D) {
            if (D.directives.length === 0)
              return "";
            let T = t(a, P.map($2, "directives"));
            return D.kind === "FragmentDefinition" || D.kind === "OperationDefinition" ? u([a, T]) : [" ", u(i([n, T]))];
          }
          function _(P, $2, D, T) {
            return P.map((m, C, o) => {
              let d2 = D();
              return C < o.length - 1 && p($2.originalText, m.getValue(), c) ? [d2, s] : d2;
            }, T);
          }
          function w(P) {
            return P.kind && P.kind !== "Comment";
          }
          function E(P) {
            let $2 = P.getValue();
            if ($2.kind === "Comment")
              return "#" + $2.value.trimEnd();
            throw new Error("Not a comment: " + JSON.stringify($2));
          }
          function N2(P, $2, D) {
            let T = P.getNode(), m = [], { interfaces: C } = T, o = P.map((d2) => D(d2), "interfaces");
            for (let d2 = 0; d2 < C.length; d2++) {
              let v2 = C[d2];
              m.push(o[d2]);
              let S = C[d2 + 1];
              if (S) {
                let b = $2.originalText.slice(v2.loc.end, S.loc.start), B = b.includes("#"), k = b.replace(/#.*/g, "").trim();
                m.push(k === "," ? "," : " &", B ? a : " ");
              }
            }
            return m;
          }
          function x(P, $2) {
            P.kind === "StringValue" && P.block && !P.value.includes(`
`) && ($2.value = $2.value.trim());
          }
          x.ignoredProperties = /* @__PURE__ */ new Set(["loc", "comments"]);
          function I2(P) {
            var $2;
            let D = P.getValue();
            return D == null || ($2 = D.comments) === null || $2 === void 0 ? void 0 : $2.some((T) => T.value.trim() === "prettier-ignore");
          }
          r.exports = { print: f, massageAstNode: x, hasPrettierIgnore: I2, insertPragma: h, printComment: E, canAttachComment: w };
        } }), ug2 = te2({ "src/language-graphql/options.js"(e, r) {
          ne2();
          var t = Mt2();
          r.exports = { bracketSpacing: t.bracketSpacing };
        } }), sg2 = te2({ "src/language-graphql/parsers.js"() {
          ne2();
        } }), ig2 = te2({ "node_modules/linguist-languages/data/GraphQL.json"(e, r) {
          r.exports = { name: "GraphQL", type: "data", color: "#e10098", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", aceMode: "text", languageId: 139 };
        } }), ag2 = te2({ "src/language-graphql/index.js"(e, r) {
          ne2();
          var t = _t2(), s = ng2(), a = ug2(), n = sg2(), u = [t(ig2(), () => ({ since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"] }))], i = { graphql: s };
          r.exports = { languages: u, options: a, printers: i, parsers: n };
        } }), Po2 = te2({ "node_modules/collapse-white-space/index.js"(e, r) {
          ne2(), r.exports = t;
          function t(s) {
            return String(s).replace(/\s+/g, " ");
          }
        } }), Io2 = te2({ "src/language-markdown/loc.js"(e, r) {
          ne2();
          function t(a) {
            return a.position.start.offset;
          }
          function s(a) {
            return a.position.end.offset;
          }
          r.exports = { locStart: t, locEnd: s };
        } }), og2 = te2({ "src/language-markdown/constants.evaluate.js"(e, r) {
          r.exports = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" };
        } }), iu = te2({ "src/language-markdown/utils.js"(e, r) {
          ne2();
          var { getLast: t } = Ue2(), { locStart: s, locEnd: a } = Io2(), { cjkPattern: n, kPattern: u, punctuationPattern: i } = og2(), l = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], p = [...l, "tableCell", "paragraph", "heading"], y2 = new RegExp(u), h = new RegExp(i);
          function g2(E, N2) {
            let x = "non-cjk", I2 = "cj-letter", P = "k-letter", $2 = "cjk-punctuation", D = [], T = (N2.proseWrap === "preserve" ? E : E.replace(new RegExp(`(${n})
(${n})`, "g"), "$1$2")).split(/([\t\n ]+)/);
            for (let [C, o] of T.entries()) {
              if (C % 2 === 1) {
                D.push({ type: "whitespace", value: /\n/.test(o) ? `
` : " " });
                continue;
              }
              if ((C === 0 || C === T.length - 1) && o === "")
                continue;
              let d2 = o.split(new RegExp(`(${n})`));
              for (let [v2, S] of d2.entries())
                if (!((v2 === 0 || v2 === d2.length - 1) && S === "")) {
                  if (v2 % 2 === 0) {
                    S !== "" && m({ type: "word", value: S, kind: x, hasLeadingPunctuation: h.test(S[0]), hasTrailingPunctuation: h.test(t(S)) });
                    continue;
                  }
                  m(h.test(S) ? { type: "word", value: S, kind: $2, hasLeadingPunctuation: true, hasTrailingPunctuation: true } : { type: "word", value: S, kind: y2.test(S) ? P : I2, hasLeadingPunctuation: false, hasTrailingPunctuation: false });
                }
            }
            return D;
            function m(C) {
              let o = t(D);
              o && o.type === "word" && (o.kind === x && C.kind === I2 && !o.hasTrailingPunctuation || o.kind === I2 && C.kind === x && !C.hasLeadingPunctuation ? D.push({ type: "whitespace", value: " " }) : !d2(x, $2) && ![o.value, C.value].some((v2) => /\u3000/.test(v2)) && D.push({ type: "whitespace", value: "" })), D.push(C);
              function d2(v2, S) {
                return o.kind === v2 && C.kind === S || o.kind === S && C.kind === v2;
              }
            }
          }
          function c(E, N2) {
            let [, x, I2, P] = N2.slice(E.position.start.offset, E.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
            return { numberText: x, marker: I2, leadingSpaces: P };
          }
          function f(E, N2) {
            if (!E.ordered || E.children.length < 2)
              return false;
            let x = Number(c(E.children[0], N2.originalText).numberText), I2 = Number(c(E.children[1], N2.originalText).numberText);
            if (x === 0 && E.children.length > 2) {
              let P = Number(c(E.children[2], N2.originalText).numberText);
              return I2 === 1 && P === 1;
            }
            return I2 === 1;
          }
          function F(E, N2) {
            let { value: x } = E;
            return E.position.end.offset === N2.length && x.endsWith(`
`) && N2.endsWith(`
`) ? x.slice(0, -1) : x;
          }
          function _(E, N2) {
            return function x(I2, P, $2) {
              let D = Object.assign({}, N2(I2, P, $2));
              return D.children && (D.children = D.children.map((T, m) => x(T, m, [D, ...$2]))), D;
            }(E, null, []);
          }
          function w(E) {
            if ((E == null ? void 0 : E.type) !== "link" || E.children.length !== 1)
              return false;
            let [N2] = E.children;
            return s(E) === s(N2) && a(E) === a(N2);
          }
          r.exports = { mapAst: _, splitText: g2, punctuationPattern: i, getFencedCodeBlockValue: F, getOrderedListItemInfo: c, hasGitDiffFriendlyOrderedList: f, INLINE_NODE_TYPES: l, INLINE_NODE_WRAPPER_TYPES: p, isAutolink: w };
        } }), lg2 = te2({ "src/language-markdown/embed.js"(e, r) {
          ne2();
          var { inferParserByLanguage: t, getMaxContinuousCount: s } = Ue2(), { builders: { hardline: a, markAsRoot: n }, utils: { replaceEndOfLine: u } } = qe2(), i = su(), { getFencedCodeBlockValue: l } = iu();
          function p(y2, h, g2, c) {
            let f = y2.getValue();
            if (f.type === "code" && f.lang !== null) {
              let F = t(f.lang, c);
              if (F) {
                let _ = c.__inJsTemplate ? "~" : "`", w = _.repeat(Math.max(3, s(f.value, _) + 1)), E = { parser: F };
                f.lang === "tsx" && (E.filepath = "dummy.tsx");
                let N2 = g2(l(f, c.originalText), E, { stripTrailingHardline: true });
                return n([w, f.lang, f.meta ? " " + f.meta : "", a, u(N2), a, w]);
              }
            }
            switch (f.type) {
              case "front-matter":
                return i(f, g2);
              case "importExport":
                return [g2(f.value, { parser: "babel" }, { stripTrailingHardline: true }), a];
              case "jsx":
                return g2(`<$>${f.value}</$>`, { parser: "__js_expression", rootMarker: "mdx" }, { stripTrailingHardline: true });
            }
            return null;
          }
          r.exports = p;
        } }), ko2 = te2({ "src/language-markdown/pragma.js"(e, r) {
          ne2();
          var t = _o2(), s = ["format", "prettier"];
          function a(n) {
            let u = `@(${s.join("|")})`, i = new RegExp([`<!--\\s*${u}\\s*-->`, `{\\s*\\/\\*\\s*${u}\\s*\\*\\/\\s*}`, `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*${u}[^\\S
]*($|
)[\\s\\S]*
.*-->`].join("|"), "m"), l = n.match(i);
            return (l == null ? void 0 : l.index) === 0;
          }
          r.exports = { startWithPragma: a, hasPragma: (n) => a(t(n).content.trimStart()), insertPragma: (n) => {
            let u = t(n), i = `<!-- @${s[0]} -->`;
            return u.frontMatter ? `${u.frontMatter.raw}

${i}

${u.content}` : `${i}

${u.content}`;
          } };
        } }), cg2 = te2({ "src/language-markdown/print-preprocess.js"(e, r) {
          ne2();
          var t = lt2(), { getOrderedListItemInfo: s, mapAst: a, splitText: n } = iu(), u = /^.$/su;
          function i(w, E) {
            return w = y2(w, E), w = c(w), w = p(w, E), w = F(w, E), w = _(w, E), w = f(w, E), w = l(w), w = h(w), w;
          }
          function l(w) {
            return a(w, (E) => E.type !== "import" && E.type !== "export" ? E : Object.assign(Object.assign({}, E), {}, { type: "importExport" }));
          }
          function p(w, E) {
            return a(w, (N2) => N2.type !== "inlineCode" || E.proseWrap === "preserve" ? N2 : Object.assign(Object.assign({}, N2), {}, { value: N2.value.replace(/\s+/g, " ") }));
          }
          function y2(w, E) {
            return a(w, (N2) => N2.type !== "text" || N2.value === "*" || N2.value === "_" || !u.test(N2.value) || N2.position.end.offset - N2.position.start.offset === N2.value.length ? N2 : Object.assign(Object.assign({}, N2), {}, { value: E.originalText.slice(N2.position.start.offset, N2.position.end.offset) }));
          }
          function h(w) {
            return g2(w, (E, N2) => E.type === "importExport" && N2.type === "importExport", (E, N2) => ({ type: "importExport", value: E.value + `

` + N2.value, position: { start: E.position.start, end: N2.position.end } }));
          }
          function g2(w, E, N2) {
            return a(w, (x) => {
              if (!x.children)
                return x;
              let I2 = x.children.reduce((P, $2) => {
                let D = t(P);
                return D && E(D, $2) ? P.splice(-1, 1, N2(D, $2)) : P.push($2), P;
              }, []);
              return Object.assign(Object.assign({}, x), {}, { children: I2 });
            });
          }
          function c(w) {
            return g2(w, (E, N2) => E.type === "text" && N2.type === "text", (E, N2) => ({ type: "text", value: E.value + N2.value, position: { start: E.position.start, end: N2.position.end } }));
          }
          function f(w, E) {
            return a(w, (N2, x, I2) => {
              let [P] = I2;
              if (N2.type !== "text")
                return N2;
              let { value: $2 } = N2;
              return P.type === "paragraph" && (x === 0 && ($2 = $2.trimStart()), x === P.children.length - 1 && ($2 = $2.trimEnd())), { type: "sentence", position: N2.position, children: n($2, E) };
            });
          }
          function F(w, E) {
            return a(w, (N2, x, I2) => {
              if (N2.type === "code") {
                let P = /^\n?(?: {4,}|\t)/.test(E.originalText.slice(N2.position.start.offset, N2.position.end.offset));
                if (N2.isIndented = P, P)
                  for (let $2 = 0; $2 < I2.length; $2++) {
                    let D = I2[$2];
                    if (D.hasIndentedCodeblock)
                      break;
                    D.type === "list" && (D.hasIndentedCodeblock = true);
                  }
              }
              return N2;
            });
          }
          function _(w, E) {
            return a(w, (I2, P, $2) => {
              if (I2.type === "list" && I2.children.length > 0) {
                for (let D = 0; D < $2.length; D++) {
                  let T = $2[D];
                  if (T.type === "list" && !T.isAligned)
                    return I2.isAligned = false, I2;
                }
                I2.isAligned = x(I2);
              }
              return I2;
            });
            function N2(I2) {
              return I2.children.length === 0 ? -1 : I2.children[0].position.start.column - 1;
            }
            function x(I2) {
              if (!I2.ordered)
                return true;
              let [P, $2] = I2.children;
              if (s(P, E.originalText).leadingSpaces.length > 1)
                return true;
              let T = N2(P);
              if (T === -1)
                return false;
              if (I2.children.length === 1)
                return T % E.tabWidth === 0;
              let m = N2($2);
              return T !== m ? false : T % E.tabWidth === 0 ? true : s($2, E.originalText).leadingSpaces.length > 1;
            }
          }
          r.exports = i;
        } }), pg2 = te2({ "src/language-markdown/clean.js"(e, r) {
          ne2();
          var t = Po2(), { isFrontMatterNode: s } = Ue2(), { startWithPragma: a } = ko2(), n = /* @__PURE__ */ new Set(["position", "raw"]);
          function u(i, l, p) {
            if ((i.type === "front-matter" || i.type === "code" || i.type === "yaml" || i.type === "import" || i.type === "export" || i.type === "jsx") && delete l.value, i.type === "list" && delete l.isAligned, (i.type === "list" || i.type === "listItem") && (delete l.spread, delete l.loose), i.type === "text" || (i.type === "inlineCode" && (l.value = i.value.replace(/[\t\n ]+/g, " ")), i.type === "wikiLink" && (l.value = i.value.trim().replace(/[\t\n]+/g, " ")), (i.type === "definition" || i.type === "linkReference" || i.type === "imageReference") && (l.label = t(i.label)), (i.type === "definition" || i.type === "link" || i.type === "image") && i.title && (l.title = i.title.replace(/\\(["')])/g, "$1")), p && p.type === "root" && p.children.length > 0 && (p.children[0] === i || s(p.children[0]) && p.children[1] === i) && i.type === "html" && a(i.value)))
              return null;
          }
          u.ignoredProperties = n, r.exports = u;
        } }), fg2 = te2({ "src/language-markdown/printer-markdown.js"(e, r) {
          ne2();
          var t = Po2(), { getLast: s, getMinNotPresentContinuousCount: a, getMaxContinuousCount: n, getStringWidth: u, isNonEmptyArray: i } = Ue2(), { builders: { breakParent: l, join: p, line: y2, literalline: h, markAsRoot: g2, hardline: c, softline: f, ifBreak: F, fill: _, align: w, indent: E, group: N2, hardlineWithoutBreakParent: x }, utils: { normalizeDoc: I2, replaceTextEndOfLine: P }, printer: { printDocToString: $2 } } = qe2(), D = lg2(), { insertPragma: T } = ko2(), { locStart: m, locEnd: C } = Io2(), o = cg2(), d2 = pg2(), { getFencedCodeBlockValue: v2, hasGitDiffFriendlyOrderedList: S, splitText: b, punctuationPattern: B, INLINE_NODE_TYPES: k, INLINE_NODE_WRAPPER_TYPES: M2, isAutolink: R2 } = iu(), q = /* @__PURE__ */ new Set(["importExport"]), J = ["heading", "tableCell", "link", "wikiLink"], L = /* @__PURE__ */ new Set(["listItem", "definition", "footnoteDefinition"]);
          function Q(oe, H, pe2) {
            let X = oe.getValue();
            if (ge2(oe))
              return b(H.originalText.slice(X.position.start.offset, X.position.end.offset), H).map((le2) => le2.type === "word" ? le2.value : le2.value === "" ? "" : W(oe, le2.value, H));
            switch (X.type) {
              case "front-matter":
                return H.originalText.slice(X.position.start.offset, X.position.end.offset);
              case "root":
                return X.children.length === 0 ? "" : [I2(de(oe, H, pe2)), q.has(z(X).type) ? "" : c];
              case "paragraph":
                return ue2(oe, H, pe2, { postprocessor: _ });
              case "sentence":
                return ue2(oe, H, pe2);
              case "word": {
                let le2 = X.value.replace(/\*/g, "\\$&").replace(new RegExp([`(^|${B})(_+)`, `(_+)(${B}|$)`].join("|"), "g"), (De2, A, G, re, ye2) => (G ? `${A}${G}` : `${re}${ye2}`).replace(/_/g, "\\_")), Ae2 = (De2, A, G) => De2.type === "sentence" && G === 0, Ee = (De2, A, G) => R2(De2.children[G - 1]);
                return le2 !== X.value && (oe.match(void 0, Ae2, Ee) || oe.match(void 0, Ae2, (De2, A, G) => De2.type === "emphasis" && G === 0, Ee)) && (le2 = le2.replace(/^(\\?[*_])+/, (De2) => De2.replace(/\\/g, ""))), le2;
              }
              case "whitespace": {
                let le2 = oe.getParentNode(), Ae2 = le2.children.indexOf(X), Ee = le2.children[Ae2 + 1], De2 = Ee && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(Ee.value) ? "never" : H.proseWrap;
                return W(oe, X.value, { proseWrap: De2 });
              }
              case "emphasis": {
                let le2;
                if (R2(X.children[0]))
                  le2 = H.originalText[X.position.start.offset];
                else {
                  let Ae2 = oe.getParentNode(), Ee = Ae2.children.indexOf(X), De2 = Ae2.children[Ee - 1], A = Ae2.children[Ee + 1];
                  le2 = De2 && De2.type === "sentence" && De2.children.length > 0 && s(De2.children).type === "word" && !s(De2.children).hasTrailingPunctuation || A && A.type === "sentence" && A.children.length > 0 && A.children[0].type === "word" && !A.children[0].hasLeadingPunctuation || ce2(oe, "emphasis") ? "*" : "_";
                }
                return [le2, ue2(oe, H, pe2), le2];
              }
              case "strong":
                return ["**", ue2(oe, H, pe2), "**"];
              case "delete":
                return ["~~", ue2(oe, H, pe2), "~~"];
              case "inlineCode": {
                let le2 = a(X.value, "`"), Ae2 = "`".repeat(le2 || 1), Ee = le2 && !/^\s/.test(X.value) ? " " : "";
                return [Ae2, Ee, X.value, Ee, Ae2];
              }
              case "wikiLink": {
                let le2 = "";
                return H.proseWrap === "preserve" ? le2 = X.value : le2 = X.value.replace(/[\t\n]+/g, " "), ["[[", le2, "]]"];
              }
              case "link":
                switch (H.originalText[X.position.start.offset]) {
                  case "<": {
                    let le2 = "mailto:";
                    return ["<", X.url.startsWith(le2) && H.originalText.slice(X.position.start.offset + 1, X.position.start.offset + 1 + le2.length) !== le2 ? X.url.slice(le2.length) : X.url, ">"];
                  }
                  case "[":
                    return ["[", ue2(oe, H, pe2), "](", he2(X.url, ")"), we2(X.title, H), ")"];
                  default:
                    return H.originalText.slice(X.position.start.offset, X.position.end.offset);
                }
              case "image":
                return ["![", X.alt || "", "](", he2(X.url, ")"), we2(X.title, H), ")"];
              case "blockquote":
                return ["> ", w("> ", ue2(oe, H, pe2))];
              case "heading":
                return ["#".repeat(X.depth) + " ", ue2(oe, H, pe2)];
              case "code": {
                if (X.isIndented) {
                  let Ee = " ".repeat(4);
                  return w(Ee, [Ee, ...P(X.value, c)]);
                }
                let le2 = H.__inJsTemplate ? "~" : "`", Ae2 = le2.repeat(Math.max(3, n(X.value, le2) + 1));
                return [Ae2, X.lang || "", X.meta ? " " + X.meta : "", c, ...P(v2(X, H.originalText), c), c, Ae2];
              }
              case "html": {
                let le2 = oe.getParentNode(), Ae2 = le2.type === "root" && s(le2.children) === X ? X.value.trimEnd() : X.value, Ee = /^<!--.*-->$/s.test(Ae2);
                return P(Ae2, Ee ? c : g2(h));
              }
              case "list": {
                let le2 = Y(X, oe.getParentNode()), Ae2 = S(X, H);
                return ue2(oe, H, pe2, { processor: (Ee, De2) => {
                  let A = re(), G = Ee.getValue();
                  if (G.children.length === 2 && G.children[1].type === "html" && G.children[0].position.start.column !== G.children[1].position.start.column)
                    return [A, V(Ee, H, pe2, A)];
                  return [A, w(" ".repeat(A.length), V(Ee, H, pe2, A))];
                  function re() {
                    let ye2 = X.ordered ? (De2 === 0 ? X.start : Ae2 ? 1 : X.start + De2) + (le2 % 2 === 0 ? ". " : ") ") : le2 % 2 === 0 ? "- " : "* ";
                    return X.isAligned || X.hasIndentedCodeblock ? j(ye2, H) : ye2;
                  }
                } });
              }
              case "thematicBreak": {
                let le2 = ee2(oe, "list");
                return le2 === -1 ? "---" : Y(oe.getParentNode(le2), oe.getParentNode(le2 + 1)) % 2 === 0 ? "***" : "---";
              }
              case "linkReference":
                return ["[", ue2(oe, H, pe2), "]", X.referenceType === "full" ? Ne2(X) : X.referenceType === "collapsed" ? "[]" : ""];
              case "imageReference":
                switch (X.referenceType) {
                  case "full":
                    return ["![", X.alt || "", "]", Ne2(X)];
                  default:
                    return ["![", X.alt, "]", X.referenceType === "collapsed" ? "[]" : ""];
                }
              case "definition": {
                let le2 = H.proseWrap === "always" ? y2 : " ";
                return N2([Ne2(X), ":", E([le2, he2(X.url), X.title === null ? "" : [le2, we2(X.title, H, false)]])]);
              }
              case "footnote":
                return ["[^", ue2(oe, H, pe2), "]"];
              case "footnoteReference":
                return Pe2(X);
              case "footnoteDefinition": {
                let le2 = oe.getParentNode().children[oe.getName() + 1], Ae2 = X.children.length === 1 && X.children[0].type === "paragraph" && (H.proseWrap === "never" || H.proseWrap === "preserve" && X.children[0].position.start.line === X.children[0].position.end.line);
                return [Pe2(X), ": ", Ae2 ? ue2(oe, H, pe2) : N2([w(" ".repeat(4), ue2(oe, H, pe2, { processor: (Ee, De2) => De2 === 0 ? N2([f, pe2()]) : pe2() })), le2 && le2.type === "footnoteDefinition" ? f : ""])];
              }
              case "table":
                return K2(oe, H, pe2);
              case "tableCell":
                return ue2(oe, H, pe2);
              case "break":
                return /\s/.test(H.originalText[X.position.start.offset]) ? ["  ", g2(h)] : ["\\", c];
              case "liquidNode":
                return P(X.value, c);
              case "importExport":
                return [X.value, c];
              case "esComment":
                return ["{/* ", X.value, " */}"];
              case "jsx":
                return X.value;
              case "math":
                return ["$$", c, X.value ? [...P(X.value, c), c] : "", "$$"];
              case "inlineMath":
                return H.originalText.slice(m(X), C(X));
              case "tableRow":
              case "listItem":
              default:
                throw new Error(`Unknown markdown type ${JSON.stringify(X.type)}`);
            }
          }
          function V(oe, H, pe2, X) {
            let le2 = oe.getValue(), Ae2 = le2.checked === null ? "" : le2.checked ? "[x] " : "[ ] ";
            return [Ae2, ue2(oe, H, pe2, { processor: (Ee, De2) => {
              if (De2 === 0 && Ee.getValue().type !== "list")
                return w(" ".repeat(Ae2.length), pe2());
              let A = " ".repeat(ke2(H.tabWidth - X.length, 0, 3));
              return [A, w(A, pe2())];
            } })];
          }
          function j(oe, H) {
            let pe2 = X();
            return oe + " ".repeat(pe2 >= 4 ? 0 : pe2);
            function X() {
              let le2 = oe.length % H.tabWidth;
              return le2 === 0 ? 0 : H.tabWidth - le2;
            }
          }
          function Y(oe, H) {
            return ie2(oe, H, (pe2) => pe2.ordered === oe.ordered);
          }
          function ie2(oe, H, pe2) {
            let X = -1;
            for (let le2 of H.children)
              if (le2.type === oe.type && pe2(le2) ? X++ : X = -1, le2 === oe)
                return X;
          }
          function ee2(oe, H) {
            let pe2 = Array.isArray(H) ? H : [H], X = -1, le2;
            for (; le2 = oe.getParentNode(++X); )
              if (pe2.includes(le2.type))
                return X;
            return -1;
          }
          function ce2(oe, H) {
            let pe2 = ee2(oe, H);
            return pe2 === -1 ? null : oe.getParentNode(pe2);
          }
          function W(oe, H, pe2) {
            if (pe2.proseWrap === "preserve" && H === `
`)
              return c;
            let X = pe2.proseWrap === "always" && !ce2(oe, J);
            return H !== "" ? X ? y2 : " " : X ? f : "";
          }
          function K2(oe, H, pe2) {
            let X = oe.getValue(), le2 = [], Ae2 = oe.map((ye2) => ye2.map((Ce2, Be) => {
              let ve2 = $2(pe2(), H).formatted, ze = u(ve2);
              return le2[Be] = Math.max(le2[Be] || 3, ze), { text: ve2, width: ze };
            }, "children"), "children"), Ee = A(false);
            if (H.proseWrap !== "never")
              return [l, Ee];
            let De2 = A(true);
            return [l, N2(F(De2, Ee))];
            function A(ye2) {
              let Ce2 = [re(Ae2[0], ye2), G(ye2)];
              return Ae2.length > 1 && Ce2.push(p(x, Ae2.slice(1).map((Be) => re(Be, ye2)))), p(x, Ce2);
            }
            function G(ye2) {
              return `| ${le2.map((Be, ve2) => {
                let ze = X.align[ve2], be2 = ze === "center" || ze === "left" ? ":" : "-", Ye2 = ze === "center" || ze === "right" ? ":" : "-", Se2 = ye2 ? "-" : "-".repeat(Be - 2);
                return `${be2}${Se2}${Ye2}`;
              }).join(" | ")} |`;
            }
            function re(ye2, Ce2) {
              return `| ${ye2.map((ve2, ze) => {
                let { text: be2, width: Ye2 } = ve2;
                if (Ce2)
                  return be2;
                let Se2 = le2[ze] - Ye2, Ie2 = X.align[ze], Oe2 = 0;
                Ie2 === "right" ? Oe2 = Se2 : Ie2 === "center" && (Oe2 = Math.floor(Se2 / 2));
                let Je2 = Se2 - Oe2;
                return `${" ".repeat(Oe2)}${be2}${" ".repeat(Je2)}`;
              }).join(" | ")} |`;
            }
          }
          function de(oe, H, pe2) {
            let X = [], le2 = null, { children: Ae2 } = oe.getValue();
            for (let [Ee, De2] of Ae2.entries())
              switch (U2(De2)) {
                case "start":
                  le2 === null && (le2 = { index: Ee, offset: De2.position.end.offset });
                  break;
                case "end":
                  le2 !== null && (X.push({ start: le2, end: { index: Ee, offset: De2.position.start.offset } }), le2 = null);
                  break;
              }
            return ue2(oe, H, pe2, { processor: (Ee, De2) => {
              if (X.length > 0) {
                let A = X[0];
                if (De2 === A.start.index)
                  return [Fe2(Ae2[A.start.index]), H.originalText.slice(A.start.offset, A.end.offset), Fe2(Ae2[A.end.index])];
                if (A.start.index < De2 && De2 < A.end.index)
                  return false;
                if (De2 === A.end.index)
                  return X.shift(), false;
              }
              return pe2();
            } });
          }
          function ue2(oe, H, pe2) {
            let X = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, { postprocessor: le2 } = X, Ae2 = X.processor || (() => pe2()), Ee = oe.getValue(), De2 = [], A;
            return oe.each((G, re) => {
              let ye2 = G.getValue(), Ce2 = Ae2(G, re);
              if (Ce2 !== false) {
                let Be = { parts: De2, prevNode: A, parentNode: Ee, options: H };
                Z(ye2, Be) && (De2.push(c), A && q.has(A.type) || (se2(ye2, Be) || fe2(ye2, Be)) && De2.push(c), fe2(ye2, Be) && De2.push(c)), De2.push(Ce2), A = ye2;
              }
            }, "children"), le2 ? le2(De2) : De2;
          }
          function Fe2(oe) {
            if (oe.type === "html")
              return oe.value;
            if (oe.type === "paragraph" && Array.isArray(oe.children) && oe.children.length === 1 && oe.children[0].type === "esComment")
              return ["{/* ", oe.children[0].value, " */}"];
          }
          function z(oe) {
            let H = oe;
            for (; i(H.children); )
              H = s(H.children);
            return H;
          }
          function U2(oe) {
            let H;
            if (oe.type === "html")
              H = oe.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
            else {
              let pe2;
              oe.type === "esComment" ? pe2 = oe : oe.type === "paragraph" && oe.children.length === 1 && oe.children[0].type === "esComment" && (pe2 = oe.children[0]), pe2 && (H = pe2.value.match(/^prettier-ignore(?:-(start|end))?$/));
            }
            return H ? H[1] || "next" : false;
          }
          function Z(oe, H) {
            let pe2 = H.parts.length === 0, X = k.includes(oe.type), le2 = oe.type === "html" && M2.includes(H.parentNode.type);
            return !pe2 && !X && !le2;
          }
          function se2(oe, H) {
            var pe2, X, le2;
            let Ee = (H.prevNode && H.prevNode.type) === oe.type && L.has(oe.type), De2 = H.parentNode.type === "listItem" && !H.parentNode.loose, A = ((pe2 = H.prevNode) === null || pe2 === void 0 ? void 0 : pe2.type) === "listItem" && H.prevNode.loose, G = U2(H.prevNode) === "next", re = oe.type === "html" && ((X = H.prevNode) === null || X === void 0 ? void 0 : X.type) === "html" && H.prevNode.position.end.line + 1 === oe.position.start.line, ye2 = oe.type === "html" && H.parentNode.type === "listItem" && ((le2 = H.prevNode) === null || le2 === void 0 ? void 0 : le2.type) === "paragraph" && H.prevNode.position.end.line + 1 === oe.position.start.line;
            return A || !(Ee || De2 || G || re || ye2);
          }
          function fe2(oe, H) {
            let pe2 = H.prevNode && H.prevNode.type === "list", X = oe.type === "code" && oe.isIndented;
            return pe2 && X;
          }
          function ge2(oe) {
            let H = ce2(oe, ["linkReference", "imageReference"]);
            return H && (H.type !== "linkReference" || H.referenceType !== "full");
          }
          function he2(oe) {
            let H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], pe2 = [" ", ...Array.isArray(H) ? H : [H]];
            return new RegExp(pe2.map((X) => `\\${X}`).join("|")).test(oe) ? `<${oe}>` : oe;
          }
          function we2(oe, H) {
            let pe2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
            if (!oe)
              return "";
            if (pe2)
              return " " + we2(oe, H, false);
            if (oe = oe.replace(/\\(["')])/g, "$1"), oe.includes('"') && oe.includes("'") && !oe.includes(")"))
              return `(${oe})`;
            let X = oe.split("'").length - 1, le2 = oe.split('"').length - 1, Ae2 = X > le2 ? '"' : le2 > X || H.singleQuote ? "'" : '"';
            return oe = oe.replace(/\\/, "\\\\"), oe = oe.replace(new RegExp(`(${Ae2})`, "g"), "\\$1"), `${Ae2}${oe}${Ae2}`;
          }
          function ke2(oe, H, pe2) {
            return oe < H ? H : oe > pe2 ? pe2 : oe;
          }
          function Re2(oe) {
            let H = Number(oe.getName());
            if (H === 0)
              return false;
            let pe2 = oe.getParentNode().children[H - 1];
            return U2(pe2) === "next";
          }
          function Ne2(oe) {
            return `[${t(oe.label)}]`;
          }
          function Pe2(oe) {
            return `[^${oe.label}]`;
          }
          r.exports = { preprocess: o, print: Q, embed: D, massageAstNode: d2, hasPrettierIgnore: Re2, insertPragma: T };
        } }), Dg2 = te2({ "src/language-markdown/options.js"(e, r) {
          ne2();
          var t = Mt2();
          r.exports = { proseWrap: t.proseWrap, singleQuote: t.singleQuote };
        } }), mg2 = te2({ "src/language-markdown/parsers.js"() {
          ne2();
        } }), _a2 = te2({ "node_modules/linguist-languages/data/Markdown.json"(e, r) {
          r.exports = { name: "Markdown", type: "prose", color: "#083fa1", aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: [".md", ".livemd", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"], filenames: ["contents.lr"], tmScope: "source.gfm", languageId: 222 };
        } }), dg2 = te2({ "src/language-markdown/index.js"(e, r) {
          ne2();
          var t = _t2(), s = fg2(), a = Dg2(), n = mg2(), u = [t(_a2(), (l) => ({ since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: [...l.filenames, "README"], extensions: l.extensions.filter((p) => p !== ".mdx") })), t(_a2(), () => ({ name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"] }))], i = { mdast: s };
          r.exports = { languages: u, options: a, printers: i, parsers: n };
        } }), gg2 = te2({ "src/language-html/clean.js"(e, r) {
          ne2();
          var { isFrontMatterNode: t } = Ue2(), s = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]);
          function a(n, u) {
            if (n.type === "text" || n.type === "comment" || t(n) || n.type === "yaml" || n.type === "toml")
              return null;
            n.type === "attribute" && delete u.value, n.type === "docType" && delete u.value;
          }
          a.ignoredProperties = s, r.exports = a;
        } }), yg2 = te2({ "src/language-html/constants.evaluate.js"(e, r) {
          r.exports = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" };
        } }), hg2 = te2({ "src/language-html/utils/is-unknown-namespace.js"(e, r) {
          ne2();
          function t(s) {
            return s.type === "element" && !s.hasExplicitNamespace && !["html", "svg"].includes(s.namespace);
          }
          r.exports = t;
        } }), Rt2 = te2({ "src/language-html/utils/index.js"(e, r) {
          ne2();
          var { inferParserByLanguage: t, isFrontMatterNode: s } = Ue2(), { builders: { line: a, hardline: n, join: u }, utils: { getDocParts: i, replaceTextEndOfLine: l } } = qe2(), { CSS_DISPLAY_TAGS: p, CSS_DISPLAY_DEFAULT: y2, CSS_WHITE_SPACE_TAGS: h, CSS_WHITE_SPACE_DEFAULT: g2 } = yg2(), c = hg2(), f = /* @__PURE__ */ new Set(["	", `
`, "\f", "\r", " "]), F = (A) => A.replace(/^[\t\n\f\r ]+/, ""), _ = (A) => A.replace(/[\t\n\f\r ]+$/, ""), w = (A) => F(_(A)), E = (A) => A.replace(/^[\t\f\r ]*\n/g, ""), N2 = (A) => E(_(A)), x = (A) => A.split(/[\t\n\f\r ]+/), I2 = (A) => A.match(/^[\t\n\f\r ]*/)[0], P = (A) => {
            let [, G, re, ye2] = A.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
            return { leadingWhitespace: G, trailingWhitespace: ye2, text: re };
          }, $2 = (A) => /[\t\n\f\r ]/.test(A);
          function D(A, G) {
            return !!(A.type === "ieConditionalComment" && A.lastChild && !A.lastChild.isSelfClosing && !A.lastChild.endSourceSpan || A.type === "ieConditionalComment" && !A.complete || se2(A) && A.children.some((re) => re.type !== "text" && re.type !== "interpolation") || X(A, G) && !o(A) && A.type !== "interpolation");
          }
          function T(A) {
            return A.type === "attribute" || !A.parent || !A.prev ? false : m(A.prev);
          }
          function m(A) {
            return A.type === "comment" && A.value.trim() === "prettier-ignore";
          }
          function C(A) {
            return A.type === "text" || A.type === "comment";
          }
          function o(A) {
            return A.type === "element" && (A.fullName === "script" || A.fullName === "style" || A.fullName === "svg:style" || c(A) && (A.name === "script" || A.name === "style"));
          }
          function d2(A) {
            return A.children && !o(A);
          }
          function v2(A) {
            return o(A) || A.type === "interpolation" || S(A);
          }
          function S(A) {
            return we2(A).startsWith("pre");
          }
          function b(A, G) {
            let re = ye2();
            if (re && !A.prev && A.parent && A.parent.tagDefinition && A.parent.tagDefinition.ignoreFirstLf)
              return A.type === "interpolation";
            return re;
            function ye2() {
              return s(A) ? false : (A.type === "text" || A.type === "interpolation") && A.prev && (A.prev.type === "text" || A.prev.type === "interpolation") ? true : !A.parent || A.parent.cssDisplay === "none" ? false : se2(A.parent) ? true : !(!A.prev && (A.parent.type === "root" || se2(A) && A.parent || o(A.parent) || H(A.parent, G) || !ue2(A.parent.cssDisplay)) || A.prev && !U2(A.prev.cssDisplay));
            }
          }
          function B(A, G) {
            return s(A) ? false : (A.type === "text" || A.type === "interpolation") && A.next && (A.next.type === "text" || A.next.type === "interpolation") ? true : !A.parent || A.parent.cssDisplay === "none" ? false : se2(A.parent) ? true : !(!A.next && (A.parent.type === "root" || se2(A) && A.parent || o(A.parent) || H(A.parent, G) || !Fe2(A.parent.cssDisplay)) || A.next && !z(A.next.cssDisplay));
          }
          function k(A) {
            return Z(A.cssDisplay) && !o(A);
          }
          function M2(A) {
            return s(A) || A.next && A.sourceSpan.end && A.sourceSpan.end.line + 1 < A.next.sourceSpan.start.line;
          }
          function R2(A) {
            return q(A) || A.type === "element" && A.children.length > 0 && (["body", "script", "style"].includes(A.name) || A.children.some((G) => ee2(G))) || A.firstChild && A.firstChild === A.lastChild && A.firstChild.type !== "text" && V(A.firstChild) && (!A.lastChild.isTrailingSpaceSensitive || j(A.lastChild));
          }
          function q(A) {
            return A.type === "element" && A.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(A.name) || A.cssDisplay.startsWith("table") && A.cssDisplay !== "table-cell");
          }
          function J(A) {
            return Y(A) || A.prev && L(A.prev) || Q(A);
          }
          function L(A) {
            return Y(A) || A.type === "element" && A.fullName === "br" || Q(A);
          }
          function Q(A) {
            return V(A) && j(A);
          }
          function V(A) {
            return A.hasLeadingSpaces && (A.prev ? A.prev.sourceSpan.end.line < A.sourceSpan.start.line : A.parent.type === "root" || A.parent.startSourceSpan.end.line < A.sourceSpan.start.line);
          }
          function j(A) {
            return A.hasTrailingSpaces && (A.next ? A.next.sourceSpan.start.line > A.sourceSpan.end.line : A.parent.type === "root" || A.parent.endSourceSpan && A.parent.endSourceSpan.start.line > A.sourceSpan.end.line);
          }
          function Y(A) {
            switch (A.type) {
              case "ieConditionalComment":
              case "comment":
              case "directive":
                return true;
              case "element":
                return ["script", "select"].includes(A.name);
            }
            return false;
          }
          function ie2(A) {
            return A.lastChild ? ie2(A.lastChild) : A;
          }
          function ee2(A) {
            return A.children && A.children.some((G) => G.type !== "text");
          }
          function ce2(A) {
            let { type: G, lang: re } = A.attrMap;
            if (G === "module" || G === "text/javascript" || G === "text/babel" || G === "application/javascript" || re === "jsx")
              return "babel";
            if (G === "application/x-typescript" || re === "ts" || re === "tsx")
              return "typescript";
            if (G === "text/markdown")
              return "markdown";
            if (G === "text/html")
              return "html";
            if (G && (G.endsWith("json") || G.endsWith("importmap")) || G === "speculationrules")
              return "json";
            if (G === "text/x-handlebars-template")
              return "glimmer";
          }
          function W(A, G) {
            let { lang: re } = A.attrMap;
            if (!re || re === "postcss" || re === "css")
              return "css";
            if (re === "scss")
              return "scss";
            if (re === "less")
              return "less";
            if (re === "stylus")
              return t("stylus", G);
          }
          function K2(A, G) {
            if (A.name === "script" && !A.attrMap.src)
              return !A.attrMap.lang && !A.attrMap.type ? "babel" : ce2(A);
            if (A.name === "style")
              return W(A, G);
            if (G && X(A, G))
              return ce2(A) || !("src" in A.attrMap) && t(A.attrMap.lang, G);
          }
          function de(A) {
            return A === "block" || A === "list-item" || A.startsWith("table");
          }
          function ue2(A) {
            return !de(A) && A !== "inline-block";
          }
          function Fe2(A) {
            return !de(A) && A !== "inline-block";
          }
          function z(A) {
            return !de(A);
          }
          function U2(A) {
            return !de(A);
          }
          function Z(A) {
            return !de(A) && A !== "inline-block";
          }
          function se2(A) {
            return we2(A).startsWith("pre");
          }
          function fe2(A, G) {
            let re = 0;
            for (let ye2 = A.stack.length - 1; ye2 >= 0; ye2--) {
              let Ce2 = A.stack[ye2];
              Ce2 && typeof Ce2 == "object" && !Array.isArray(Ce2) && G(Ce2) && re++;
            }
            return re;
          }
          function ge2(A, G) {
            let re = A;
            for (; re; ) {
              if (G(re))
                return true;
              re = re.parent;
            }
            return false;
          }
          function he2(A, G) {
            if (A.prev && A.prev.type === "comment") {
              let ye2 = A.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
              if (ye2)
                return ye2[1];
            }
            let re = false;
            if (A.type === "element" && A.namespace === "svg")
              if (ge2(A, (ye2) => ye2.fullName === "svg:foreignObject"))
                re = true;
              else
                return A.name === "svg" ? "inline-block" : "block";
            switch (G.htmlWhitespaceSensitivity) {
              case "strict":
                return "inline";
              case "ignore":
                return "block";
              default:
                return G.parser === "vue" && A.parent && A.parent.type === "root" ? "block" : A.type === "element" && (!A.namespace || re || c(A)) && p[A.name] || y2;
            }
          }
          function we2(A) {
            return A.type === "element" && (!A.namespace || c(A)) && h[A.name] || g2;
          }
          function ke2(A) {
            let G = Number.POSITIVE_INFINITY;
            for (let re of A.split(`
`)) {
              if (re.length === 0)
                continue;
              if (!f.has(re[0]))
                return 0;
              let ye2 = I2(re).length;
              re.length !== ye2 && ye2 < G && (G = ye2);
            }
            return G === Number.POSITIVE_INFINITY ? 0 : G;
          }
          function Re2(A) {
            let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ke2(A);
            return G === 0 ? A : A.split(`
`).map((re) => re.slice(G)).join(`
`);
          }
          function Ne2(A, G) {
            let re = 0;
            for (let ye2 = 0; ye2 < A.length; ye2++)
              A[ye2] === G && re++;
            return re;
          }
          function Pe2(A) {
            return A.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
          }
          var oe = /* @__PURE__ */ new Set(["template", "style", "script"]);
          function H(A, G) {
            return pe2(A, G) && !oe.has(A.fullName);
          }
          function pe2(A, G) {
            return G.parser === "vue" && A.type === "element" && A.parent.type === "root" && A.fullName.toLowerCase() !== "html";
          }
          function X(A, G) {
            return pe2(A, G) && (H(A, G) || A.attrMap.lang && A.attrMap.lang !== "html");
          }
          function le2(A) {
            let G = A.fullName;
            return G.charAt(0) === "#" || G === "slot-scope" || G === "v-slot" || G.startsWith("v-slot:");
          }
          function Ae2(A, G) {
            let re = A.parent;
            if (!pe2(re, G))
              return false;
            let ye2 = re.fullName, Ce2 = A.fullName;
            return ye2 === "script" && Ce2 === "setup" || ye2 === "style" && Ce2 === "vars";
          }
          function Ee(A) {
            let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : A.value;
            return A.parent.isWhitespaceSensitive ? A.parent.isIndentationSensitive ? l(G) : l(Re2(N2(G)), n) : i(u(a, x(G)));
          }
          function De2(A, G) {
            return pe2(A, G) && A.name === "script";
          }
          r.exports = { htmlTrim: w, htmlTrimPreserveIndentation: N2, hasHtmlWhitespace: $2, getLeadingAndTrailingHtmlWhitespace: P, canHaveInterpolation: d2, countChars: Ne2, countParents: fe2, dedentString: Re2, forceBreakChildren: q, forceBreakContent: R2, forceNextEmptyLine: M2, getLastDescendant: ie2, getNodeCssStyleDisplay: he2, getNodeCssStyleWhiteSpace: we2, hasPrettierIgnore: T, inferScriptParser: K2, isVueCustomBlock: H, isVueNonHtmlBlock: X, isVueScriptTag: De2, isVueSlotAttribute: le2, isVueSfcBindingsAttribute: Ae2, isVueSfcBlock: pe2, isDanglingSpaceSensitiveNode: k, isIndentationSensitiveNode: S, isLeadingSpaceSensitiveNode: b, isPreLikeNode: se2, isScriptLikeTag: o, isTextLikeNode: C, isTrailingSpaceSensitiveNode: B, isWhitespaceSensitiveNode: v2, isUnknownNamespace: c, preferHardlineAsLeadingSpaces: J, preferHardlineAsTrailingSpaces: L, shouldPreserveContent: D, unescapeQuoteEntities: Pe2, getTextValueParts: Ee };
        } }), vg2 = te2({ "node_modules/angular-html-parser/lib/compiler/src/chars.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true }), e.$EOF = 0, e.$BSPACE = 8, e.$TAB = 9, e.$LF = 10, e.$VTAB = 11, e.$FF = 12, e.$CR = 13, e.$SPACE = 32, e.$BANG = 33, e.$DQ = 34, e.$HASH = 35, e.$$ = 36, e.$PERCENT = 37, e.$AMPERSAND = 38, e.$SQ = 39, e.$LPAREN = 40, e.$RPAREN = 41, e.$STAR = 42, e.$PLUS = 43, e.$COMMA = 44, e.$MINUS = 45, e.$PERIOD = 46, e.$SLASH = 47, e.$COLON = 58, e.$SEMICOLON = 59, e.$LT = 60, e.$EQ = 61, e.$GT = 62, e.$QUESTION = 63, e.$0 = 48, e.$7 = 55, e.$9 = 57, e.$A = 65, e.$E = 69, e.$F = 70, e.$X = 88, e.$Z = 90, e.$LBRACKET = 91, e.$BACKSLASH = 92, e.$RBRACKET = 93, e.$CARET = 94, e.$_ = 95, e.$a = 97, e.$b = 98, e.$e = 101, e.$f = 102, e.$n = 110, e.$r = 114, e.$t = 116, e.$u = 117, e.$v = 118, e.$x = 120, e.$z = 122, e.$LBRACE = 123, e.$BAR = 124, e.$RBRACE = 125, e.$NBSP = 160, e.$PIPE = 124, e.$TILDA = 126, e.$AT = 64, e.$BT = 96;
          function r(i) {
            return i >= e.$TAB && i <= e.$SPACE || i == e.$NBSP;
          }
          e.isWhitespace = r;
          function t(i) {
            return e.$0 <= i && i <= e.$9;
          }
          e.isDigit = t;
          function s(i) {
            return i >= e.$a && i <= e.$z || i >= e.$A && i <= e.$Z;
          }
          e.isAsciiLetter = s;
          function a(i) {
            return i >= e.$a && i <= e.$f || i >= e.$A && i <= e.$F || t(i);
          }
          e.isAsciiHexDigit = a;
          function n(i) {
            return i === e.$LF || i === e.$CR;
          }
          e.isNewLine = n;
          function u(i) {
            return e.$0 <= i && i <= e.$7;
          }
          e.isOctalDigit = u;
        } }), Cg2 = te2({ "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = class {
            constructor(s, a, n) {
              this.filePath = s, this.name = a, this.members = n;
            }
            assertNoMembers() {
              if (this.members.length)
                throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
            }
          };
          e.StaticSymbol = r;
          var t = class {
            constructor() {
              this.cache = /* @__PURE__ */ new Map();
            }
            get(s, a, n) {
              n = n || [];
              let u = n.length ? `.${n.join(".")}` : "", i = `"${s}".${a}${u}`, l = this.cache.get(i);
              return l || (l = new r(s, a, n), this.cache.set(i, l)), l;
            }
          };
          e.StaticSymbolCache = t;
        } }), Eg2 = te2({ "node_modules/angular-html-parser/lib/compiler/src/util.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = /-+([a-z0-9])/g;
          function t(o) {
            return o.replace(r, function() {
              for (var d2 = arguments.length, v2 = new Array(d2), S = 0; S < d2; S++)
                v2[S] = arguments[S];
              return v2[1].toUpperCase();
            });
          }
          e.dashCaseToCamelCase = t;
          function s(o, d2) {
            return n(o, ":", d2);
          }
          e.splitAtColon = s;
          function a(o, d2) {
            return n(o, ".", d2);
          }
          e.splitAtPeriod = a;
          function n(o, d2, v2) {
            let S = o.indexOf(d2);
            return S == -1 ? v2 : [o.slice(0, S).trim(), o.slice(S + 1).trim()];
          }
          function u(o, d2, v2) {
            return Array.isArray(o) ? d2.visitArray(o, v2) : E(o) ? d2.visitStringMap(o, v2) : o == null || typeof o == "string" || typeof o == "number" || typeof o == "boolean" ? d2.visitPrimitive(o, v2) : d2.visitOther(o, v2);
          }
          e.visitValue = u;
          function i(o) {
            return o != null;
          }
          e.isDefined = i;
          function l(o) {
            return o === void 0 ? null : o;
          }
          e.noUndefined = l;
          var p = class {
            visitArray(o, d2) {
              return o.map((v2) => u(v2, this, d2));
            }
            visitStringMap(o, d2) {
              let v2 = {};
              return Object.keys(o).forEach((S) => {
                v2[S] = u(o[S], this, d2);
              }), v2;
            }
            visitPrimitive(o, d2) {
              return o;
            }
            visitOther(o, d2) {
              return o;
            }
          };
          e.ValueTransformer = p, e.SyncAsync = { assertSync: (o) => {
            if (P(o))
              throw new Error("Illegal state: value cannot be a promise");
            return o;
          }, then: (o, d2) => P(o) ? o.then(d2) : d2(o), all: (o) => o.some(P) ? Promise.all(o) : o };
          function y2(o) {
            throw new Error(`Internal Error: ${o}`);
          }
          e.error = y2;
          function h(o, d2) {
            let v2 = Error(o);
            return v2[g2] = true, d2 && (v2[c] = d2), v2;
          }
          e.syntaxError = h;
          var g2 = "ngSyntaxError", c = "ngParseErrors";
          function f(o) {
            return o[g2];
          }
          e.isSyntaxError = f;
          function F(o) {
            return o[c] || [];
          }
          e.getParseErrors = F;
          function _(o) {
            return o.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
          }
          e.escapeRegExp = _;
          var w = Object.getPrototypeOf({});
          function E(o) {
            return typeof o == "object" && o !== null && Object.getPrototypeOf(o) === w;
          }
          function N2(o) {
            let d2 = "";
            for (let v2 = 0; v2 < o.length; v2++) {
              let S = o.charCodeAt(v2);
              if (S >= 55296 && S <= 56319 && o.length > v2 + 1) {
                let b = o.charCodeAt(v2 + 1);
                b >= 56320 && b <= 57343 && (v2++, S = (S - 55296 << 10) + b - 56320 + 65536);
              }
              S <= 127 ? d2 += String.fromCharCode(S) : S <= 2047 ? d2 += String.fromCharCode(S >> 6 & 31 | 192, S & 63 | 128) : S <= 65535 ? d2 += String.fromCharCode(S >> 12 | 224, S >> 6 & 63 | 128, S & 63 | 128) : S <= 2097151 && (d2 += String.fromCharCode(S >> 18 & 7 | 240, S >> 12 & 63 | 128, S >> 6 & 63 | 128, S & 63 | 128));
            }
            return d2;
          }
          e.utf8Encode = N2;
          function x(o) {
            if (typeof o == "string")
              return o;
            if (o instanceof Array)
              return "[" + o.map(x).join(", ") + "]";
            if (o == null)
              return "" + o;
            if (o.overriddenName)
              return `${o.overriddenName}`;
            if (o.name)
              return `${o.name}`;
            if (!o.toString)
              return "object";
            let d2 = o.toString();
            if (d2 == null)
              return "" + d2;
            let v2 = d2.indexOf(`
`);
            return v2 === -1 ? d2 : d2.substring(0, v2);
          }
          e.stringify = x;
          function I2(o) {
            return typeof o == "function" && o.hasOwnProperty("__forward_ref__") ? o() : o;
          }
          e.resolveForwardRef = I2;
          function P(o) {
            return !!o && typeof o.then == "function";
          }
          e.isPromise = P;
          var $2 = class {
            constructor(o) {
              this.full = o;
              let d2 = o.split(".");
              this.major = d2[0], this.minor = d2[1], this.patch = d2.slice(2).join(".");
            }
          };
          e.Version = $2;
          var D = typeof window < "u" && window, T = typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self, m = typeof globalThis < "u" && globalThis, C = m || D || T;
          e.global = C;
        } }), Fg2 = te2({ "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Cg2(), t = Eg2(), s = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
          function a(v2) {
            return v2.replace(/\W/g, "_");
          }
          e.sanitizeIdentifier = a;
          var n = 0;
          function u(v2) {
            if (!v2 || !v2.reference)
              return null;
            let S = v2.reference;
            if (S instanceof r.StaticSymbol)
              return S.name;
            if (S.__anonymousType)
              return S.__anonymousType;
            let b = t.stringify(S);
            return b.indexOf("(") >= 0 ? (b = `anonymous_${n++}`, S.__anonymousType = b) : b = a(b), b;
          }
          e.identifierName = u;
          function i(v2) {
            let S = v2.reference;
            return S instanceof r.StaticSymbol ? S.filePath : `./${t.stringify(S)}`;
          }
          e.identifierModuleUrl = i;
          function l(v2, S) {
            return `View_${u({ reference: v2 })}_${S}`;
          }
          e.viewClassName = l;
          function p(v2) {
            return `RenderType_${u({ reference: v2 })}`;
          }
          e.rendererTypeName = p;
          function y2(v2) {
            return `HostView_${u({ reference: v2 })}`;
          }
          e.hostViewClassName = y2;
          function h(v2) {
            return `${u({ reference: v2 })}NgFactory`;
          }
          e.componentFactoryName = h;
          var g2;
          (function(v2) {
            v2[v2.Pipe = 0] = "Pipe", v2[v2.Directive = 1] = "Directive", v2[v2.NgModule = 2] = "NgModule", v2[v2.Injectable = 3] = "Injectable";
          })(g2 = e.CompileSummaryKind || (e.CompileSummaryKind = {}));
          function c(v2) {
            return v2.value != null ? a(v2.value) : u(v2.identifier);
          }
          e.tokenName = c;
          function f(v2) {
            return v2.identifier != null ? v2.identifier.reference : v2.value;
          }
          e.tokenReference = f;
          var F = class {
            constructor() {
              let { moduleUrl: v2, styles: S, styleUrls: b } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              this.moduleUrl = v2 || null, this.styles = P(S), this.styleUrls = P(b);
            }
          };
          e.CompileStylesheetMetadata = F;
          var _ = class {
            constructor(v2) {
              let { encapsulation: S, template: b, templateUrl: B, htmlAst: k, styles: M2, styleUrls: R2, externalStylesheets: q, animations: J, ngContentSelectors: L, interpolation: Q, isInline: V, preserveWhitespaces: j } = v2;
              if (this.encapsulation = S, this.template = b, this.templateUrl = B, this.htmlAst = k, this.styles = P(M2), this.styleUrls = P(R2), this.externalStylesheets = P(q), this.animations = J ? D(J) : [], this.ngContentSelectors = L || [], Q && Q.length != 2)
                throw new Error("'interpolation' should have a start and an end symbol.");
              this.interpolation = Q, this.isInline = V, this.preserveWhitespaces = j;
            }
            toSummary() {
              return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
            }
          };
          e.CompileTemplateMetadata = _;
          var w = class {
            static create(v2) {
              let { isHost: S, type: b, isComponent: B, selector: k, exportAs: M2, changeDetection: R2, inputs: q, outputs: J, host: L, providers: Q, viewProviders: V, queries: j, guards: Y, viewQueries: ie2, entryComponents: ee2, template: ce2, componentViewType: W, rendererType: K2, componentFactory: de } = v2, ue2 = {}, Fe2 = {}, z = {};
              L != null && Object.keys(L).forEach((se2) => {
                let fe2 = L[se2], ge2 = se2.match(s);
                ge2 === null ? z[se2] = fe2 : ge2[1] != null ? Fe2[ge2[1]] = fe2 : ge2[2] != null && (ue2[ge2[2]] = fe2);
              });
              let U2 = {};
              q != null && q.forEach((se2) => {
                let fe2 = t.splitAtColon(se2, [se2, se2]);
                U2[fe2[0]] = fe2[1];
              });
              let Z = {};
              return J != null && J.forEach((se2) => {
                let fe2 = t.splitAtColon(se2, [se2, se2]);
                Z[fe2[0]] = fe2[1];
              }), new w({ isHost: S, type: b, isComponent: !!B, selector: k, exportAs: M2, changeDetection: R2, inputs: U2, outputs: Z, hostListeners: ue2, hostProperties: Fe2, hostAttributes: z, providers: Q, viewProviders: V, queries: j, guards: Y, viewQueries: ie2, entryComponents: ee2, template: ce2, componentViewType: W, rendererType: K2, componentFactory: de });
            }
            constructor(v2) {
              let { isHost: S, type: b, isComponent: B, selector: k, exportAs: M2, changeDetection: R2, inputs: q, outputs: J, hostListeners: L, hostProperties: Q, hostAttributes: V, providers: j, viewProviders: Y, queries: ie2, guards: ee2, viewQueries: ce2, entryComponents: W, template: K2, componentViewType: de, rendererType: ue2, componentFactory: Fe2 } = v2;
              this.isHost = !!S, this.type = b, this.isComponent = B, this.selector = k, this.exportAs = M2, this.changeDetection = R2, this.inputs = q, this.outputs = J, this.hostListeners = L, this.hostProperties = Q, this.hostAttributes = V, this.providers = P(j), this.viewProviders = P(Y), this.queries = P(ie2), this.guards = ee2, this.viewQueries = P(ce2), this.entryComponents = P(W), this.template = K2, this.componentViewType = de, this.rendererType = ue2, this.componentFactory = Fe2;
            }
            toSummary() {
              return { summaryKind: g2.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
            }
          };
          e.CompileDirectiveMetadata = w;
          var E = class {
            constructor(v2) {
              let { type: S, name: b, pure: B } = v2;
              this.type = S, this.name = b, this.pure = !!B;
            }
            toSummary() {
              return { summaryKind: g2.Pipe, type: this.type, name: this.name, pure: this.pure };
            }
          };
          e.CompilePipeMetadata = E;
          var N2 = class {
          };
          e.CompileShallowModuleMetadata = N2;
          var x = class {
            constructor(v2) {
              let { type: S, providers: b, declaredDirectives: B, exportedDirectives: k, declaredPipes: M2, exportedPipes: R2, entryComponents: q, bootstrapComponents: J, importedModules: L, exportedModules: Q, schemas: V, transitiveModule: j, id: Y } = v2;
              this.type = S || null, this.declaredDirectives = P(B), this.exportedDirectives = P(k), this.declaredPipes = P(M2), this.exportedPipes = P(R2), this.providers = P(b), this.entryComponents = P(q), this.bootstrapComponents = P(J), this.importedModules = P(L), this.exportedModules = P(Q), this.schemas = P(V), this.id = Y || null, this.transitiveModule = j || null;
            }
            toSummary() {
              let v2 = this.transitiveModule;
              return { summaryKind: g2.NgModule, type: this.type, entryComponents: v2.entryComponents, providers: v2.providers, modules: v2.modules, exportedDirectives: v2.exportedDirectives, exportedPipes: v2.exportedPipes };
            }
          };
          e.CompileNgModuleMetadata = x;
          var I2 = class {
            constructor() {
              this.directivesSet = /* @__PURE__ */ new Set(), this.directives = [], this.exportedDirectivesSet = /* @__PURE__ */ new Set(), this.exportedDirectives = [], this.pipesSet = /* @__PURE__ */ new Set(), this.pipes = [], this.exportedPipesSet = /* @__PURE__ */ new Set(), this.exportedPipes = [], this.modulesSet = /* @__PURE__ */ new Set(), this.modules = [], this.entryComponentsSet = /* @__PURE__ */ new Set(), this.entryComponents = [], this.providers = [];
            }
            addProvider(v2, S) {
              this.providers.push({ provider: v2, module: S });
            }
            addDirective(v2) {
              this.directivesSet.has(v2.reference) || (this.directivesSet.add(v2.reference), this.directives.push(v2));
            }
            addExportedDirective(v2) {
              this.exportedDirectivesSet.has(v2.reference) || (this.exportedDirectivesSet.add(v2.reference), this.exportedDirectives.push(v2));
            }
            addPipe(v2) {
              this.pipesSet.has(v2.reference) || (this.pipesSet.add(v2.reference), this.pipes.push(v2));
            }
            addExportedPipe(v2) {
              this.exportedPipesSet.has(v2.reference) || (this.exportedPipesSet.add(v2.reference), this.exportedPipes.push(v2));
            }
            addModule(v2) {
              this.modulesSet.has(v2.reference) || (this.modulesSet.add(v2.reference), this.modules.push(v2));
            }
            addEntryComponent(v2) {
              this.entryComponentsSet.has(v2.componentType) || (this.entryComponentsSet.add(v2.componentType), this.entryComponents.push(v2));
            }
          };
          e.TransitiveCompileNgModuleMetadata = I2;
          function P(v2) {
            return v2 || [];
          }
          var $2 = class {
            constructor(v2, S) {
              let { useClass: b, useValue: B, useExisting: k, useFactory: M2, deps: R2, multi: q } = S;
              this.token = v2, this.useClass = b || null, this.useValue = B, this.useExisting = k, this.useFactory = M2 || null, this.dependencies = R2 || null, this.multi = !!q;
            }
          };
          e.ProviderMeta = $2;
          function D(v2) {
            return v2.reduce((S, b) => {
              let B = Array.isArray(b) ? D(b) : b;
              return S.concat(B);
            }, []);
          }
          e.flatten = D;
          function T(v2) {
            return v2.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
          }
          function m(v2, S, b) {
            let B;
            return b.isInline ? S.type.reference instanceof r.StaticSymbol ? B = `${S.type.reference.filePath}.${S.type.reference.name}.html` : B = `${u(v2)}/${u(S.type)}.html` : B = b.templateUrl, S.type.reference instanceof r.StaticSymbol ? B : T(B);
          }
          e.templateSourceUrl = m;
          function C(v2, S) {
            let b = v2.moduleUrl.split(/\/\\/g), B = b[b.length - 1];
            return T(`css/${S}${B}.ngstyle.js`);
          }
          e.sharedStylesheetJitUrl = C;
          function o(v2) {
            return T(`${u(v2.type)}/module.ngfactory.js`);
          }
          e.ngModuleJitUrl = o;
          function d2(v2, S) {
            return T(`${u(v2)}/${u(S.type)}.ngfactory.js`);
          }
          e.templateJitUrl = d2;
        } }), Ag2 = te2({ "node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(e) {
          ne2(), Object.defineProperty(e, "__esModule", { value: true });
          var r = vg2(), t = Fg2(), s = class {
            constructor(y2, h, g2, c) {
              this.file = y2, this.offset = h, this.line = g2, this.col = c;
            }
            toString() {
              return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
            }
            moveBy(y2) {
              let h = this.file.content, g2 = h.length, c = this.offset, f = this.line, F = this.col;
              for (; c > 0 && y2 < 0; )
                if (c--, y2++, h.charCodeAt(c) == r.$LF) {
                  f--;
                  let w = h.substr(0, c - 1).lastIndexOf(String.fromCharCode(r.$LF));
                  F = w > 0 ? c - w : c;
                } else
                  F--;
              for (; c < g2 && y2 > 0; ) {
                let _ = h.charCodeAt(c);
                c++, y2--, _ == r.$LF ? (f++, F = 0) : F++;
              }
              return new s(this.file, c, f, F);
            }
            getContext(y2, h) {
              let g2 = this.file.content, c = this.offset;
              if (c != null) {
                c > g2.length - 1 && (c = g2.length - 1);
                let f = c, F = 0, _ = 0;
                for (; F < y2 && c > 0 && (c--, F++, !(g2[c] == `
` && ++_ == h)); )
                  ;
                for (F = 0, _ = 0; F < y2 && f < g2.length - 1 && (f++, F++, !(g2[f] == `
` && ++_ == h)); )
                  ;
                return { before: g2.substring(c, this.offset), after: g2.substring(this.offset, f + 1) };
              }
              return null;
            }
          };
          e.ParseLocation = s;
          var a = class {
            constructor(y2, h) {
              this.content = y2, this.url = h;
            }
          };
          e.ParseSourceFile = a;
          var n = class {
            constructor(y2, h) {
              let g2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
              this.start = y2, this.end = h, this.details = g2;
            }
            toString() {
              return this.start.file.content.substring(this.start.offset, this.end.offset);
            }
          };
          e.ParseSourceSpan = n, e.EMPTY_PARSE_LOCATION = new s(new a("", ""), 0, 0, 0), e.EMPTY_SOURCE_SPAN = new n(e.EMPTY_PARSE_LOCATION, e.EMPTY_PARSE_LOCATION);
          var u;
          (function(y2) {
            y2[y2.WARNING = 0] = "WARNING", y2[y2.ERROR = 1] = "ERROR";
          })(u = e.ParseErrorLevel || (e.ParseErrorLevel = {}));
          var i = class {
            constructor(y2, h) {
              let g2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : u.ERROR;
              this.span = y2, this.msg = h, this.level = g2;
            }
            contextualMessage() {
              let y2 = this.span.start.getContext(100, 3);
              return y2 ? `${this.msg} ("${y2.before}[${u[this.level]} ->]${y2.after}")` : this.msg;
            }
            toString() {
              let y2 = this.span.details ? `, ${this.span.details}` : "";
              return `${this.contextualMessage()}: ${this.span.start}${y2}`;
            }
          };
          e.ParseError = i;
          function l(y2, h) {
            let g2 = t.identifierModuleUrl(h), c = g2 != null ? `in ${y2} ${t.identifierName(h)} in ${g2}` : `in ${y2} ${t.identifierName(h)}`, f = new a("", c);
            return new n(new s(f, -1, -1, -1), new s(f, -1, -1, -1));
          }
          e.typeSourceSpan = l;
          function p(y2, h, g2) {
            let c = `in ${y2} ${h} in ${g2}`, f = new a("", c);
            return new n(new s(f, -1, -1, -1), new s(f, -1, -1, -1));
          }
          e.r3JitTypeSourceSpan = p;
        } }), Sg2 = te2({ "src/language-html/print-preprocess.js"(e, r) {
          ne2();
          var { ParseSourceSpan: t } = Ag2(), { htmlTrim: s, getLeadingAndTrailingHtmlWhitespace: a, hasHtmlWhitespace: n, canHaveInterpolation: u, getNodeCssStyleDisplay: i, isDanglingSpaceSensitiveNode: l, isIndentationSensitiveNode: p, isLeadingSpaceSensitiveNode: y2, isTrailingSpaceSensitiveNode: h, isWhitespaceSensitiveNode: g2, isVueScriptTag: c } = Rt2(), f = [_, w, N2, I2, P, T, $2, D, m, x, C];
          function F(o, d2) {
            for (let v2 of f)
              v2(o, d2);
            return o;
          }
          function _(o) {
            o.walk((d2) => {
              if (d2.type === "element" && d2.tagDefinition.ignoreFirstLf && d2.children.length > 0 && d2.children[0].type === "text" && d2.children[0].value[0] === `
`) {
                let v2 = d2.children[0];
                v2.value.length === 1 ? d2.removeChild(v2) : v2.value = v2.value.slice(1);
              }
            });
          }
          function w(o) {
            let d2 = (v2) => v2.type === "element" && v2.prev && v2.prev.type === "ieConditionalStartComment" && v2.prev.sourceSpan.end.offset === v2.startSourceSpan.start.offset && v2.firstChild && v2.firstChild.type === "ieConditionalEndComment" && v2.firstChild.sourceSpan.start.offset === v2.startSourceSpan.end.offset;
            o.walk((v2) => {
              if (v2.children)
                for (let S = 0; S < v2.children.length; S++) {
                  let b = v2.children[S];
                  if (!d2(b))
                    continue;
                  let B = b.prev, k = b.firstChild;
                  v2.removeChild(B), S--;
                  let M2 = new t(B.sourceSpan.start, k.sourceSpan.end), R2 = new t(M2.start, b.sourceSpan.end);
                  b.condition = B.condition, b.sourceSpan = R2, b.startSourceSpan = M2, b.removeChild(k);
                }
            });
          }
          function E(o, d2, v2) {
            o.walk((S) => {
              if (S.children)
                for (let b = 0; b < S.children.length; b++) {
                  let B = S.children[b];
                  if (B.type !== "text" && !d2(B))
                    continue;
                  B.type !== "text" && (B.type = "text", B.value = v2(B));
                  let k = B.prev;
                  !k || k.type !== "text" || (k.value += B.value, k.sourceSpan = new t(k.sourceSpan.start, B.sourceSpan.end), S.removeChild(B), b--);
                }
            });
          }
          function N2(o) {
            return E(o, (d2) => d2.type === "cdata", (d2) => `<![CDATA[${d2.value}]]>`);
          }
          function x(o) {
            let d2 = (v2) => v2.type === "element" && v2.attrs.length === 0 && v2.children.length === 1 && v2.firstChild.type === "text" && !n(v2.children[0].value) && !v2.firstChild.hasLeadingSpaces && !v2.firstChild.hasTrailingSpaces && v2.isLeadingSpaceSensitive && !v2.hasLeadingSpaces && v2.isTrailingSpaceSensitive && !v2.hasTrailingSpaces && v2.prev && v2.prev.type === "text" && v2.next && v2.next.type === "text";
            o.walk((v2) => {
              if (v2.children)
                for (let S = 0; S < v2.children.length; S++) {
                  let b = v2.children[S];
                  if (!d2(b))
                    continue;
                  let B = b.prev, k = b.next;
                  B.value += `<${b.rawName}>` + b.firstChild.value + `</${b.rawName}>` + k.value, B.sourceSpan = new t(B.sourceSpan.start, k.sourceSpan.end), B.isTrailingSpaceSensitive = k.isTrailingSpaceSensitive, B.hasTrailingSpaces = k.hasTrailingSpaces, v2.removeChild(b), S--, v2.removeChild(k);
                }
            });
          }
          function I2(o, d2) {
            if (d2.parser === "html")
              return;
            let v2 = /{{(.+?)}}/s;
            o.walk((S) => {
              if (u(S))
                for (let b of S.children) {
                  if (b.type !== "text")
                    continue;
                  let B = b.sourceSpan.start, k = null, M2 = b.value.split(v2);
                  for (let R2 = 0; R2 < M2.length; R2++, B = k) {
                    let q = M2[R2];
                    if (R2 % 2 === 0) {
                      k = B.moveBy(q.length), q.length > 0 && S.insertChildBefore(b, { type: "text", value: q, sourceSpan: new t(B, k) });
                      continue;
                    }
                    k = B.moveBy(q.length + 4), S.insertChildBefore(b, { type: "interpolation", sourceSpan: new t(B, k), children: q.length === 0 ? [] : [{ type: "text", value: q, sourceSpan: new t(B.moveBy(2), k.moveBy(-2)) }] });
                  }
                  S.removeChild(b);
                }
            });
          }
          function P(o) {
            o.walk((d2) => {
              if (!d2.children)
                return;
              if (d2.children.length === 0 || d2.children.length === 1 && d2.children[0].type === "text" && s(d2.children[0].value).length === 0) {
                d2.hasDanglingSpaces = d2.children.length > 0, d2.children = [];
                return;
              }
              let v2 = g2(d2), S = p(d2);
              if (!v2)
                for (let b = 0; b < d2.children.length; b++) {
                  let B = d2.children[b];
                  if (B.type !== "text")
                    continue;
                  let { leadingWhitespace: k, text: M2, trailingWhitespace: R2 } = a(B.value), q = B.prev, J = B.next;
                  M2 ? (B.value = M2, B.sourceSpan = new t(B.sourceSpan.start.moveBy(k.length), B.sourceSpan.end.moveBy(-R2.length)), k && (q && (q.hasTrailingSpaces = true), B.hasLeadingSpaces = true), R2 && (B.hasTrailingSpaces = true, J && (J.hasLeadingSpaces = true))) : (d2.removeChild(B), b--, (k || R2) && (q && (q.hasTrailingSpaces = true), J && (J.hasLeadingSpaces = true)));
                }
              d2.isWhitespaceSensitive = v2, d2.isIndentationSensitive = S;
            });
          }
          function $2(o) {
            o.walk((d2) => {
              d2.isSelfClosing = !d2.children || d2.type === "element" && (d2.tagDefinition.isVoid || d2.startSourceSpan === d2.endSourceSpan);
            });
          }
          function D(o, d2) {
            o.walk((v2) => {
              v2.type === "element" && (v2.hasHtmComponentClosingTag = v2.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(d2.originalText.slice(v2.endSourceSpan.start.offset, v2.endSourceSpan.end.offset)));
            });
          }
          function T(o, d2) {
            o.walk((v2) => {
              v2.cssDisplay = i(v2, d2);
            });
          }
          function m(o, d2) {
            o.walk((v2) => {
              let { children: S } = v2;
              if (S) {
                if (S.length === 0) {
                  v2.isDanglingSpaceSensitive = l(v2);
                  return;
                }
                for (let b of S)
                  b.isLeadingSpaceSensitive = y2(b, d2), b.isTrailingSpaceSensitive = h(b, d2);
                for (let b = 0; b < S.length; b++) {
                  let B = S[b];
                  B.isLeadingSpaceSensitive = (b === 0 || B.prev.isTrailingSpaceSensitive) && B.isLeadingSpaceSensitive, B.isTrailingSpaceSensitive = (b === S.length - 1 || B.next.isLeadingSpaceSensitive) && B.isTrailingSpaceSensitive;
                }
              }
            });
          }
          function C(o, d2) {
            if (d2.parser === "vue") {
              let v2 = o.children.find((b) => c(b, d2));
              if (!v2)
                return;
              let { lang: S } = v2.attrMap;
              (S === "ts" || S === "typescript") && (d2.__should_parse_vue_template_with_ts = true);
            }
          }
          r.exports = F;
        } }), xg2 = te2({ "src/language-html/pragma.js"(e, r) {
          ne2();
          function t(a) {
            return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(a);
          }
          function s(a) {
            return `<!-- @format -->

` + a.replace(/^\s*\n/, "");
          }
          r.exports = { hasPragma: t, insertPragma: s };
        } }), au = te2({ "src/language-html/loc.js"(e, r) {
          ne2();
          function t(a) {
            return a.sourceSpan.start.offset;
          }
          function s(a) {
            return a.sourceSpan.end.offset;
          }
          r.exports = { locStart: t, locEnd: s };
        } }), ur2 = te2({ "src/language-html/print/tag.js"(e, r) {
          ne2();
          var t = Zt2(), { isNonEmptyArray: s } = Ue2(), { builders: { indent: a, join: n, line: u, softline: i, hardline: l }, utils: { replaceTextEndOfLine: p } } = qe2(), { locStart: y2, locEnd: h } = au(), { isTextLikeNode: g2, getLastDescendant: c, isPreLikeNode: f, hasPrettierIgnore: F, shouldPreserveContent: _, isVueSfcBlock: w } = Rt2();
          function E(L, Q) {
            return [L.isSelfClosing ? "" : N2(L, Q), x(L, Q)];
          }
          function N2(L, Q) {
            return L.lastChild && o(L.lastChild) ? "" : [I2(L, Q), $2(L, Q)];
          }
          function x(L, Q) {
            return (L.next ? m(L.next) : C(L.parent)) ? "" : [D(L, Q), P(L, Q)];
          }
          function I2(L, Q) {
            return C(L) ? D(L.lastChild, Q) : "";
          }
          function P(L, Q) {
            return o(L) ? $2(L.parent, Q) : d2(L) ? q(L.next) : "";
          }
          function $2(L, Q) {
            if (t(!L.isSelfClosing), T(L, Q))
              return "";
            switch (L.type) {
              case "ieConditionalComment":
                return "<!";
              case "element":
                if (L.hasHtmComponentClosingTag)
                  return "<//";
              default:
                return `</${L.rawName}`;
            }
          }
          function D(L, Q) {
            if (T(L, Q))
              return "";
            switch (L.type) {
              case "ieConditionalComment":
              case "ieConditionalEndComment":
                return "[endif]-->";
              case "ieConditionalStartComment":
                return "]><!-->";
              case "interpolation":
                return "}}";
              case "element":
                if (L.isSelfClosing)
                  return "/>";
              default:
                return ">";
            }
          }
          function T(L, Q) {
            return !L.isSelfClosing && !L.endSourceSpan && (F(L) || _(L.parent, Q));
          }
          function m(L) {
            return L.prev && L.prev.type !== "docType" && !g2(L.prev) && L.isLeadingSpaceSensitive && !L.hasLeadingSpaces;
          }
          function C(L) {
            return L.lastChild && L.lastChild.isTrailingSpaceSensitive && !L.lastChild.hasTrailingSpaces && !g2(c(L.lastChild)) && !f(L);
          }
          function o(L) {
            return !L.next && !L.hasTrailingSpaces && L.isTrailingSpaceSensitive && g2(c(L));
          }
          function d2(L) {
            return L.next && !g2(L.next) && g2(L) && L.isTrailingSpaceSensitive && !L.hasTrailingSpaces;
          }
          function v2(L) {
            let Q = L.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
            return Q ? Q[1] ? Q[1].split(/\s+/) : true : false;
          }
          function S(L) {
            return !L.prev && L.isLeadingSpaceSensitive && !L.hasLeadingSpaces;
          }
          function b(L, Q, V) {
            let j = L.getValue();
            if (!s(j.attrs))
              return j.isSelfClosing ? " " : "";
            let Y = j.prev && j.prev.type === "comment" && v2(j.prev.value), ie2 = typeof Y == "boolean" ? () => Y : Array.isArray(Y) ? (ue2) => Y.includes(ue2.rawName) : () => false, ee2 = L.map((ue2) => {
              let Fe2 = ue2.getValue();
              return ie2(Fe2) ? p(Q.originalText.slice(y2(Fe2), h(Fe2))) : V();
            }, "attrs"), ce2 = j.type === "element" && j.fullName === "script" && j.attrs.length === 1 && j.attrs[0].fullName === "src" && j.children.length === 0, K2 = Q.singleAttributePerLine && j.attrs.length > 1 && !w(j, Q) ? l : u, de = [a([ce2 ? " " : u, n(K2, ee2)])];
            return j.firstChild && S(j.firstChild) || j.isSelfClosing && C(j.parent) || ce2 ? de.push(j.isSelfClosing ? " " : "") : de.push(Q.bracketSameLine ? j.isSelfClosing ? " " : "" : j.isSelfClosing ? u : i), de;
          }
          function B(L) {
            return L.firstChild && S(L.firstChild) ? "" : J(L);
          }
          function k(L, Q, V) {
            let j = L.getValue();
            return [M2(j, Q), b(L, Q, V), j.isSelfClosing ? "" : B(j)];
          }
          function M2(L, Q) {
            return L.prev && d2(L.prev) ? "" : [R2(L, Q), q(L)];
          }
          function R2(L, Q) {
            return S(L) ? J(L.parent) : m(L) ? D(L.prev, Q) : "";
          }
          function q(L) {
            switch (L.type) {
              case "ieConditionalComment":
              case "ieConditionalStartComment":
                return `<!--[if ${L.condition}`;
              case "ieConditionalEndComment":
                return "<!--<!";
              case "interpolation":
                return "{{";
              case "docType":
                return "<!DOCTYPE";
              case "element":
                if (L.condition)
                  return `<!--[if ${L.condition}]><!--><${L.rawName}`;
              default:
                return `<${L.rawName}`;
            }
          }
          function J(L) {
            switch (t(!L.isSelfClosing), L.type) {
              case "ieConditionalComment":
                return "]>";
              case "element":
                if (L.condition)
                  return "><!--<![endif]-->";
              default:
                return ">";
            }
          }
          r.exports = { printClosingTag: E, printClosingTagStart: N2, printClosingTagStartMarker: $2, printClosingTagEndMarker: D, printClosingTagSuffix: P, printClosingTagEnd: x, needsToBorrowLastChildClosingTagEndMarker: C, needsToBorrowParentClosingTagStartMarker: o, needsToBorrowPrevClosingTagEndMarker: m, printOpeningTag: k, printOpeningTagStart: M2, printOpeningTagPrefix: R2, printOpeningTagStartMarker: q, printOpeningTagEndMarker: J, needsToBorrowNextOpeningTagStartMarker: d2, needsToBorrowParentOpeningTagEndMarker: S };
        } }), bg2 = te2({ "node_modules/parse-srcset/src/parse-srcset.js"(e, r) {
          ne2(), function(t, s) {
            typeof r == "object" && r.exports ? r.exports = s() : t.parseSrcset = s();
          }(e, function() {
            return function(t, s) {
              var a = s && s.logger || console;
              function n($2) {
                return $2 === " " || $2 === "	" || $2 === `
` || $2 === "\f" || $2 === "\r";
              }
              function u($2) {
                var D, T = $2.exec(t.substring(N2));
                if (T)
                  return D = T[0], N2 += D.length, D;
              }
              for (var i = t.length, l = /^[ \t\n\r\u000c]+/, p = /^[, \t\n\r\u000c]+/, y2 = /^[^ \t\n\r\u000c]+/, h = /[,]+$/, g2 = /^\d+$/, c = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, f, F, _, w, E, N2 = 0, x = []; ; ) {
                if (u(p), N2 >= i)
                  return x;
                f = u(y2), F = [], f.slice(-1) === "," ? (f = f.replace(h, ""), P()) : I2();
              }
              function I2() {
                for (u(l), _ = "", w = "in descriptor"; ; ) {
                  if (E = t.charAt(N2), w === "in descriptor")
                    if (n(E))
                      _ && (F.push(_), _ = "", w = "after descriptor");
                    else if (E === ",") {
                      N2 += 1, _ && F.push(_), P();
                      return;
                    } else if (E === "(")
                      _ = _ + E, w = "in parens";
                    else if (E === "") {
                      _ && F.push(_), P();
                      return;
                    } else
                      _ = _ + E;
                  else if (w === "in parens")
                    if (E === ")")
                      _ = _ + E, w = "in descriptor";
                    else if (E === "") {
                      F.push(_), P();
                      return;
                    } else
                      _ = _ + E;
                  else if (w === "after descriptor" && !n(E))
                    if (E === "") {
                      P();
                      return;
                    } else
                      w = "in descriptor", N2 -= 1;
                  N2 += 1;
                }
              }
              function P() {
                var $2 = false, D, T, m, C, o = {}, d2, v2, S, b, B;
                for (C = 0; C < F.length; C++)
                  d2 = F[C], v2 = d2[d2.length - 1], S = d2.substring(0, d2.length - 1), b = parseInt(S, 10), B = parseFloat(S), g2.test(S) && v2 === "w" ? ((D || T) && ($2 = true), b === 0 ? $2 = true : D = b) : c.test(S) && v2 === "x" ? ((D || T || m) && ($2 = true), B < 0 ? $2 = true : T = B) : g2.test(S) && v2 === "h" ? ((m || T) && ($2 = true), b === 0 ? $2 = true : m = b) : $2 = true;
                $2 ? a && a.error && a.error("Invalid srcset descriptor found in '" + t + "' at '" + d2 + "'.") : (o.url = f, D && (o.w = D), T && (o.d = T), m && (o.h = m), x.push(o));
              }
            };
          });
        } }), Tg2 = te2({ "src/language-html/syntax-attribute.js"(e, r) {
          ne2();
          var t = bg2(), { builders: { ifBreak: s, join: a, line: n } } = qe2();
          function u(l) {
            let p = t(l, { logger: { error(I2) {
              throw new Error(I2);
            } } }), y2 = p.some((I2) => {
              let { w: P } = I2;
              return P;
            }), h = p.some((I2) => {
              let { h: P } = I2;
              return P;
            }), g2 = p.some((I2) => {
              let { d: P } = I2;
              return P;
            });
            if (y2 + h + g2 > 1)
              throw new Error("Mixed descriptor in srcset is not supported");
            let c = y2 ? "w" : h ? "h" : "d", f = y2 ? "w" : h ? "h" : "x", F = (I2) => Math.max(...I2), _ = p.map((I2) => I2.url), w = F(_.map((I2) => I2.length)), E = p.map((I2) => I2[c]).map((I2) => I2 ? I2.toString() : ""), N2 = E.map((I2) => {
              let P = I2.indexOf(".");
              return P === -1 ? I2.length : P;
            }), x = F(N2);
            return a([",", n], _.map((I2, P) => {
              let $2 = [I2], D = E[P];
              if (D) {
                let T = w - I2.length + 1, m = x - N2[P], C = " ".repeat(T + m);
                $2.push(s(C, " "), D + f);
              }
              return $2;
            }));
          }
          function i(l) {
            return l.trim().split(/\s+/).join(" ");
          }
          r.exports = { printImgSrcset: u, printClassNames: i };
        } }), Bg2 = te2({ "src/language-html/syntax-vue.js"(e, r) {
          ne2();
          var { builders: { group: t } } = qe2();
          function s(i, l) {
            let { left: p, operator: y2, right: h } = a(i);
            return [t(l(`function _(${p}) {}`, { parser: "babel", __isVueForBindingLeft: true })), " ", y2, " ", l(h, { parser: "__js_expression" }, { stripTrailingHardline: true })];
          }
          function a(i) {
            let l = /(.*?)\s+(in|of)\s+(.*)/s, p = /,([^,\]}]*)(?:,([^,\]}]*))?$/, y2 = /^\(|\)$/g, h = i.match(l);
            if (!h)
              return;
            let g2 = {};
            if (g2.for = h[3].trim(), !g2.for)
              return;
            let c = h[1].trim().replace(y2, ""), f = c.match(p);
            f ? (g2.alias = c.replace(p, ""), g2.iterator1 = f[1].trim(), f[2] && (g2.iterator2 = f[2].trim())) : g2.alias = c;
            let F = [g2.alias, g2.iterator1, g2.iterator2];
            if (!F.some((_, w) => !_ && (w === 0 || F.slice(w + 1).some(Boolean))))
              return { left: F.filter(Boolean).join(","), operator: h[2], right: g2.for };
          }
          function n(i, l) {
            return l(`function _(${i}) {}`, { parser: "babel", __isVueBindings: true });
          }
          function u(i) {
            let l = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/, p = /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/, y2 = i.trim();
            return l.test(y2) || p.test(y2);
          }
          r.exports = { isVueEventBindingExpression: u, printVueFor: s, printVueBindings: n };
        } }), Lo2 = te2({ "src/language-html/get-node-content.js"(e, r) {
          ne2();
          var { needsToBorrowParentClosingTagStartMarker: t, printClosingTagStartMarker: s, needsToBorrowLastChildClosingTagEndMarker: a, printClosingTagEndMarker: n, needsToBorrowParentOpeningTagEndMarker: u, printOpeningTagEndMarker: i } = ur2();
          function l(p, y2) {
            let h = p.startSourceSpan.end.offset;
            p.firstChild && u(p.firstChild) && (h -= i(p).length);
            let g2 = p.endSourceSpan.start.offset;
            return p.lastChild && t(p.lastChild) ? g2 += s(p, y2).length : a(p) && (g2 -= n(p.lastChild, y2).length), y2.originalText.slice(h, g2);
          }
          r.exports = l;
        } }), Ng2 = te2({ "src/language-html/embed.js"(e, r) {
          ne2();
          var { builders: { breakParent: t, group: s, hardline: a, indent: n, line: u, fill: i, softline: l }, utils: { mapDoc: p, replaceTextEndOfLine: y2 } } = qe2(), h = su(), { printClosingTag: g2, printClosingTagSuffix: c, needsToBorrowPrevClosingTagEndMarker: f, printOpeningTagPrefix: F, printOpeningTag: _ } = ur2(), { printImgSrcset: w, printClassNames: E } = Tg2(), { printVueFor: N2, printVueBindings: x, isVueEventBindingExpression: I2 } = Bg2(), { isScriptLikeTag: P, isVueNonHtmlBlock: $2, inferScriptParser: D, htmlTrimPreserveIndentation: T, dedentString: m, unescapeQuoteEntities: C, isVueSlotAttribute: o, isVueSfcBindingsAttribute: d2, getTextValueParts: v2 } = Rt2(), S = Lo2();
          function b(k, M2, R2) {
            let q = (ee2) => new RegExp(ee2.join("|")).test(k.fullName), J = () => C(k.value), L = false, Q = (ee2, ce2) => {
              let W = ee2.type === "NGRoot" ? ee2.node.type === "NGMicrosyntax" && ee2.node.body.length === 1 && ee2.node.body[0].type === "NGMicrosyntaxExpression" ? ee2.node.body[0].expression : ee2.node : ee2.type === "JsExpressionRoot" ? ee2.node : ee2;
              W && (W.type === "ObjectExpression" || W.type === "ArrayExpression" || ce2.parser === "__vue_expression" && (W.type === "TemplateLiteral" || W.type === "StringLiteral")) && (L = true);
            }, V = (ee2) => s(ee2), j = function(ee2) {
              let ce2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
              return s([n([l, ee2]), ce2 ? l : ""]);
            }, Y = (ee2) => L ? V(ee2) : j(ee2), ie2 = (ee2, ce2) => M2(ee2, Object.assign({ __onHtmlBindingRoot: Q, __embeddedInHtml: true }, ce2));
            if (k.fullName === "srcset" && (k.parent.fullName === "img" || k.parent.fullName === "source"))
              return j(w(J()));
            if (k.fullName === "class" && !R2.parentParser) {
              let ee2 = J();
              if (!ee2.includes("{{"))
                return E(ee2);
            }
            if (k.fullName === "style" && !R2.parentParser) {
              let ee2 = J();
              if (!ee2.includes("{{"))
                return j(ie2(ee2, { parser: "css", __isHTMLStyleAttribute: true }));
            }
            if (R2.parser === "vue") {
              if (k.fullName === "v-for")
                return N2(J(), ie2);
              if (o(k) || d2(k, R2))
                return x(J(), ie2);
              let ee2 = ["^@", "^v-on:"], ce2 = ["^:", "^v-bind:"], W = ["^v-"];
              if (q(ee2)) {
                let K2 = J(), de = I2(K2) ? "__js_expression" : R2.__should_parse_vue_template_with_ts ? "__vue_ts_event_binding" : "__vue_event_binding";
                return Y(ie2(K2, { parser: de }));
              }
              if (q(ce2))
                return Y(ie2(J(), { parser: "__vue_expression" }));
              if (q(W))
                return Y(ie2(J(), { parser: "__js_expression" }));
            }
            if (R2.parser === "angular") {
              let ee2 = (z, U2) => ie2(z, Object.assign(Object.assign({}, U2), {}, { trailingComma: "none" })), ce2 = ["^\\*"], W = ["^\\(.+\\)$", "^on-"], K2 = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], de = ["^i18n(-.+)?$"];
              if (q(W))
                return Y(ee2(J(), { parser: "__ng_action" }));
              if (q(K2))
                return Y(ee2(J(), { parser: "__ng_binding" }));
              if (q(de)) {
                let z = J().trim();
                return j(i(v2(k, z)), !z.includes("@@"));
              }
              if (q(ce2))
                return Y(ee2(J(), { parser: "__ng_directive" }));
              let ue2 = /{{(.+?)}}/s, Fe2 = J();
              if (ue2.test(Fe2)) {
                let z = [];
                for (let [U2, Z] of Fe2.split(ue2).entries())
                  if (U2 % 2 === 0)
                    z.push(y2(Z));
                  else
                    try {
                      z.push(s(["{{", n([u, ee2(Z, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), u, "}}"]));
                    } catch {
                      z.push("{{", y2(Z), "}}");
                    }
                return s(z);
              }
            }
            return null;
          }
          function B(k, M2, R2, q) {
            let J = k.getValue();
            switch (J.type) {
              case "element": {
                if (P(J) || J.type === "interpolation")
                  return;
                if (!J.isSelfClosing && $2(J, q)) {
                  let L = D(J, q);
                  if (!L)
                    return;
                  let Q = S(J, q), V = /^\s*$/.test(Q), j = "";
                  return V || (j = R2(T(Q), { parser: L, __embeddedInHtml: true }, { stripTrailingHardline: true }), V = j === ""), [F(J, q), s(_(k, q, M2)), V ? "" : a, j, V ? "" : a, g2(J, q), c(J, q)];
                }
                break;
              }
              case "text": {
                if (P(J.parent)) {
                  let L = D(J.parent, q);
                  if (L) {
                    let Q = L === "markdown" ? m(J.value.replace(/^[^\S\n]*\n/, "")) : J.value, V = { parser: L, __embeddedInHtml: true };
                    if (q.parser === "html" && L === "babel") {
                      let j = "script", { attrMap: Y } = J.parent;
                      Y && (Y.type === "module" || Y.type === "text/babel" && Y["data-type"] === "module") && (j = "module"), V.__babelSourceType = j;
                    }
                    return [t, F(J, q), R2(Q, V, { stripTrailingHardline: true }), c(J, q)];
                  }
                } else if (J.parent.type === "interpolation") {
                  let L = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
                  return q.parser === "angular" ? (L.parser = "__ng_interpolation", L.trailingComma = "none") : q.parser === "vue" ? L.parser = q.__should_parse_vue_template_with_ts ? "__vue_ts_expression" : "__vue_expression" : L.parser = "__js_expression", [n([u, R2(J.value, L, { stripTrailingHardline: true })]), J.parent.next && f(J.parent.next) ? " " : u];
                }
                break;
              }
              case "attribute": {
                if (!J.value)
                  break;
                if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(q.originalText.slice(J.valueSpan.start.offset, J.valueSpan.end.offset)))
                  return [J.rawName, "=", J.value];
                if (q.parser === "lwc" && /^{.*}$/s.test(q.originalText.slice(J.valueSpan.start.offset, J.valueSpan.end.offset)))
                  return [J.rawName, "=", J.value];
                let L = b(J, (Q, V) => R2(Q, Object.assign({ __isInHtmlAttribute: true, __embeddedInHtml: true }, V), { stripTrailingHardline: true }), q);
                if (L)
                  return [J.rawName, '="', s(p(L, (Q) => typeof Q == "string" ? Q.replace(/"/g, "&quot;") : Q)), '"'];
                break;
              }
              case "front-matter":
                return h(J, R2);
            }
          }
          r.exports = B;
        } }), Oo2 = te2({ "src/language-html/print/children.js"(e, r) {
          ne2();
          var { builders: { breakParent: t, group: s, ifBreak: a, line: n, softline: u, hardline: i }, utils: { replaceTextEndOfLine: l } } = qe2(), { locStart: p, locEnd: y2 } = au(), { forceBreakChildren: h, forceNextEmptyLine: g2, isTextLikeNode: c, hasPrettierIgnore: f, preferHardlineAsLeadingSpaces: F } = Rt2(), { printOpeningTagPrefix: _, needsToBorrowNextOpeningTagStartMarker: w, printOpeningTagStartMarker: E, needsToBorrowPrevClosingTagEndMarker: N2, printClosingTagEndMarker: x, printClosingTagSuffix: I2, needsToBorrowParentClosingTagStartMarker: P } = ur2();
          function $2(m, C, o) {
            let d2 = m.getValue();
            return f(d2) ? [_(d2, C), ...l(C.originalText.slice(p(d2) + (d2.prev && w(d2.prev) ? E(d2).length : 0), y2(d2) - (d2.next && N2(d2.next) ? x(d2, C).length : 0))), I2(d2, C)] : o();
          }
          function D(m, C) {
            return c(m) && c(C) ? m.isTrailingSpaceSensitive ? m.hasTrailingSpaces ? F(C) ? i : n : "" : F(C) ? i : u : w(m) && (f(C) || C.firstChild || C.isSelfClosing || C.type === "element" && C.attrs.length > 0) || m.type === "element" && m.isSelfClosing && N2(C) ? "" : !C.isLeadingSpaceSensitive || F(C) || N2(C) && m.lastChild && P(m.lastChild) && m.lastChild.lastChild && P(m.lastChild.lastChild) ? i : C.hasLeadingSpaces ? n : u;
          }
          function T(m, C, o) {
            let d2 = m.getValue();
            if (h(d2))
              return [t, ...m.map((S) => {
                let b = S.getValue(), B = b.prev ? D(b.prev, b) : "";
                return [B ? [B, g2(b.prev) ? i : ""] : "", $2(S, C, o)];
              }, "children")];
            let v2 = d2.children.map(() => Symbol(""));
            return m.map((S, b) => {
              let B = S.getValue();
              if (c(B)) {
                if (B.prev && c(B.prev)) {
                  let Q = D(B.prev, B);
                  if (Q)
                    return g2(B.prev) ? [i, i, $2(S, C, o)] : [Q, $2(S, C, o)];
                }
                return $2(S, C, o);
              }
              let k = [], M2 = [], R2 = [], q = [], J = B.prev ? D(B.prev, B) : "", L = B.next ? D(B, B.next) : "";
              return J && (g2(B.prev) ? k.push(i, i) : J === i ? k.push(i) : c(B.prev) ? M2.push(J) : M2.push(a("", u, { groupId: v2[b - 1] }))), L && (g2(B) ? c(B.next) && q.push(i, i) : L === i ? c(B.next) && q.push(i) : R2.push(L)), [...k, s([...M2, s([$2(S, C, o), ...R2], { id: v2[b] })]), ...q];
            }, "children");
          }
          r.exports = { printChildren: T };
        } }), wg2 = te2({ "src/language-html/print/element.js"(e, r) {
          ne2();
          var { builders: { breakParent: t, dedentToRoot: s, group: a, ifBreak: n, indentIfBreak: u, indent: i, line: l, softline: p }, utils: { replaceTextEndOfLine: y2 } } = qe2(), h = Lo2(), { shouldPreserveContent: g2, isScriptLikeTag: c, isVueCustomBlock: f, countParents: F, forceBreakContent: _ } = Rt2(), { printOpeningTagPrefix: w, printOpeningTag: E, printClosingTagSuffix: N2, printClosingTag: x, needsToBorrowPrevClosingTagEndMarker: I2, needsToBorrowLastChildClosingTagEndMarker: P } = ur2(), { printChildren: $2 } = Oo2();
          function D(T, m, C) {
            let o = T.getValue();
            if (g2(o, m))
              return [w(o, m), a(E(T, m, C)), ...y2(h(o, m)), ...x(o, m), N2(o, m)];
            let d2 = o.children.length === 1 && o.firstChild.type === "interpolation" && o.firstChild.isLeadingSpaceSensitive && !o.firstChild.hasLeadingSpaces && o.lastChild.isTrailingSpaceSensitive && !o.lastChild.hasTrailingSpaces, v2 = Symbol("element-attr-group-id"), S = (M2) => a([a(E(T, m, C), { id: v2 }), M2, x(o, m)]), b = (M2) => d2 ? u(M2, { groupId: v2 }) : (c(o) || f(o, m)) && o.parent.type === "root" && m.parser === "vue" && !m.vueIndentScriptAndStyle ? M2 : i(M2), B = () => d2 ? n(p, "", { groupId: v2 }) : o.firstChild.hasLeadingSpaces && o.firstChild.isLeadingSpaceSensitive ? l : o.firstChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive ? s(p) : p, k = () => (o.next ? I2(o.next) : P(o.parent)) ? o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? " " : "" : d2 ? n(p, "", { groupId: v2 }) : o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? l : (o.lastChild.type === "comment" || o.lastChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${m.tabWidth * F(T, (R2) => R2.parent && R2.parent.type !== "root")}}$`).test(o.lastChild.value) ? "" : p;
            return o.children.length === 0 ? S(o.hasDanglingSpaces && o.isDanglingSpaceSensitive ? l : "") : S([_(o) ? t : "", b([B(), $2(T, m, C)]), k()]);
          }
          r.exports = { printElement: D };
        } }), _g2 = te2({ "src/language-html/printer-html.js"(e, r) {
          ne2();
          var { builders: { fill: t, group: s, hardline: a, literalline: n }, utils: { cleanDoc: u, getDocParts: i, isConcat: l, replaceTextEndOfLine: p } } = qe2(), y2 = gg2(), { countChars: h, unescapeQuoteEntities: g2, getTextValueParts: c } = Rt2(), f = Sg2(), { insertPragma: F } = xg2(), { locStart: _, locEnd: w } = au(), E = Ng2(), { printClosingTagSuffix: N2, printClosingTagEnd: x, printOpeningTagPrefix: I2, printOpeningTagStart: P } = ur2(), { printElement: $2 } = wg2(), { printChildren: D } = Oo2();
          function T(m, C, o) {
            let d2 = m.getValue();
            switch (d2.type) {
              case "front-matter":
                return p(d2.raw);
              case "root":
                return C.__onHtmlRoot && C.__onHtmlRoot(d2), [s(D(m, C, o)), a];
              case "element":
              case "ieConditionalComment":
                return $2(m, C, o);
              case "ieConditionalStartComment":
              case "ieConditionalEndComment":
                return [P(d2), x(d2)];
              case "interpolation":
                return [P(d2, C), ...m.map(o, "children"), x(d2, C)];
              case "text": {
                if (d2.parent.type === "interpolation") {
                  let S = /\n[^\S\n]*$/, b = S.test(d2.value), B = b ? d2.value.replace(S, "") : d2.value;
                  return [...p(B), b ? a : ""];
                }
                let v2 = u([I2(d2, C), ...c(d2), N2(d2, C)]);
                return l(v2) || v2.type === "fill" ? t(i(v2)) : v2;
              }
              case "docType":
                return [s([P(d2, C), " ", d2.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), x(d2, C)];
              case "comment":
                return [I2(d2, C), ...p(C.originalText.slice(_(d2), w(d2)), n), N2(d2, C)];
              case "attribute": {
                if (d2.value === null)
                  return d2.rawName;
                let v2 = g2(d2.value), S = h(v2, "'"), b = h(v2, '"'), B = S < b ? "'" : '"';
                return [d2.rawName, "=", B, ...p(B === '"' ? v2.replace(/"/g, "&quot;") : v2.replace(/'/g, "&apos;")), B];
              }
              default:
                throw new Error(`Unexpected node type ${d2.type}`);
            }
          }
          r.exports = { preprocess: f, print: T, insertPragma: F, massageAstNode: y2, embed: E };
        } }), Pg2 = te2({ "src/language-html/options.js"(e, r) {
          ne2();
          var t = Mt2(), s = "HTML";
          r.exports = { bracketSameLine: t.bracketSameLine, htmlWhitespaceSensitivity: { since: "1.15.0", category: s, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: t.singleAttributePerLine, vueIndentScriptAndStyle: { since: "1.19.0", category: s, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } };
        } }), Ig2 = te2({ "src/language-html/parsers.js"() {
          ne2();
        } }), On2 = te2({ "node_modules/linguist-languages/data/HTML.json"(e, r) {
          r.exports = { name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], languageId: 146 };
        } }), kg2 = te2({ "node_modules/linguist-languages/data/Vue.json"(e, r) {
          r.exports = { name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", languageId: 391 };
        } }), Lg2 = te2({ "src/language-html/index.js"(e, r) {
          ne2();
          var t = _t2(), s = _g2(), a = Pg2(), n = Ig2(), u = [t(On2(), () => ({ name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: [] })), t(On2(), (l) => ({ since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: [...l.extensions, ".mjml"] })), t(On2(), () => ({ name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: [] })), t(kg2(), () => ({ since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"] }))], i = { html: s };
          r.exports = { languages: u, printers: i, options: a, parsers: n };
        } }), Og2 = te2({ "src/language-yaml/pragma.js"(e, r) {
          ne2();
          function t(n) {
            return /^\s*@(?:prettier|format)\s*$/.test(n);
          }
          function s(n) {
            return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(n);
          }
          function a(n) {
            return `# @format

${n}`;
          }
          r.exports = { isPragma: t, hasPragma: s, insertPragma: a };
        } }), jg2 = te2({ "src/language-yaml/loc.js"(e, r) {
          ne2();
          function t(a) {
            return a.position.start.offset;
          }
          function s(a) {
            return a.position.end.offset;
          }
          r.exports = { locStart: t, locEnd: s };
        } }), qg2 = te2({ "src/language-yaml/embed.js"(e, r) {
          ne2();
          function t(s, a, n, u) {
            if (s.getValue().type === "root" && u.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint|lintstaged)rc$/.test(u.filepath))
              return n(u.originalText, Object.assign(Object.assign({}, u), {}, { parser: "json" }));
          }
          r.exports = t;
        } }), $t2 = te2({ "src/language-yaml/utils.js"(e, r) {
          ne2();
          var { getLast: t, isNonEmptyArray: s } = Ue2();
          function a(D, T) {
            let m = 0, C = D.stack.length - 1;
            for (let o = 0; o < C; o++) {
              let d2 = D.stack[o];
              n(d2) && T(d2) && m++;
            }
            return m;
          }
          function n(D, T) {
            return D && typeof D.type == "string" && (!T || T.includes(D.type));
          }
          function u(D, T, m) {
            return T("children" in D ? Object.assign(Object.assign({}, D), {}, { children: D.children.map((C) => u(C, T, D)) }) : D, m);
          }
          function i(D, T, m) {
            Object.defineProperty(D, T, { get: m, enumerable: false });
          }
          function l(D, T) {
            let m = 0, C = T.length;
            for (let o = D.position.end.offset - 1; o < C; o++) {
              let d2 = T[o];
              if (d2 === `
` && m++, m === 1 && /\S/.test(d2))
                return false;
              if (m === 2)
                return true;
            }
            return false;
          }
          function p(D) {
            switch (D.getValue().type) {
              case "tag":
              case "anchor":
              case "comment":
                return false;
            }
            let m = D.stack.length;
            for (let C = 1; C < m; C++) {
              let o = D.stack[C], d2 = D.stack[C - 1];
              if (Array.isArray(d2) && typeof o == "number" && o !== d2.length - 1)
                return false;
            }
            return true;
          }
          function y2(D) {
            return s(D.children) ? y2(t(D.children)) : D;
          }
          function h(D) {
            return D.value.trim() === "prettier-ignore";
          }
          function g2(D) {
            let T = D.getValue();
            if (T.type === "documentBody") {
              let m = D.getParentNode();
              return N2(m.head) && h(t(m.head.endComments));
            }
            return F(T) && h(t(T.leadingComments));
          }
          function c(D) {
            return !s(D.children) && !f(D);
          }
          function f(D) {
            return F(D) || _(D) || w(D) || E(D) || N2(D);
          }
          function F(D) {
            return s(D == null ? void 0 : D.leadingComments);
          }
          function _(D) {
            return s(D == null ? void 0 : D.middleComments);
          }
          function w(D) {
            return D == null ? void 0 : D.indicatorComment;
          }
          function E(D) {
            return D == null ? void 0 : D.trailingComment;
          }
          function N2(D) {
            return s(D == null ? void 0 : D.endComments);
          }
          function x(D) {
            let T = [], m;
            for (let C of D.split(/( +)/))
              C !== " " ? m === " " ? T.push(C) : T.push((T.pop() || "") + C) : m === void 0 && T.unshift(""), m = C;
            return m === " " && T.push((T.pop() || "") + " "), T[0] === "" && (T.shift(), T.unshift(" " + (T.shift() || ""))), T;
          }
          function I2(D, T, m) {
            let C = T.split(`
`).map((o, d2, v2) => d2 === 0 && d2 === v2.length - 1 ? o : d2 !== 0 && d2 !== v2.length - 1 ? o.trim() : d2 === 0 ? o.trimEnd() : o.trimStart());
            return m.proseWrap === "preserve" ? C.map((o) => o.length === 0 ? [] : [o]) : C.map((o) => o.length === 0 ? [] : x(o)).reduce((o, d2, v2) => v2 !== 0 && C[v2 - 1].length > 0 && d2.length > 0 && !(D === "quoteDouble" && t(t(o)).endsWith("\\")) ? [...o.slice(0, -1), [...t(o), ...d2]] : [...o, d2], []).map((o) => m.proseWrap === "never" ? [o.join(" ")] : o);
          }
          function P(D, T) {
            let { parentIndent: m, isLastDescendant: C, options: o } = T, d2 = D.position.start.line === D.position.end.line ? "" : o.originalText.slice(D.position.start.offset, D.position.end.offset).match(/^[^\n]*\n(.*)$/s)[1], v2;
            if (D.indent === null) {
              let B = d2.match(/^(?<leadingSpace> *)[^\n\r ]/m);
              v2 = B ? B.groups.leadingSpace.length : Number.POSITIVE_INFINITY;
            } else
              v2 = D.indent - 1 + m;
            let S = d2.split(`
`).map((B) => B.slice(v2));
            if (o.proseWrap === "preserve" || D.type === "blockLiteral")
              return b(S.map((B) => B.length === 0 ? [] : [B]));
            return b(S.map((B) => B.length === 0 ? [] : x(B)).reduce((B, k, M2) => M2 !== 0 && S[M2 - 1].length > 0 && k.length > 0 && !/^\s/.test(k[0]) && !/^\s|\s$/.test(t(B)) ? [...B.slice(0, -1), [...t(B), ...k]] : [...B, k], []).map((B) => B.reduce((k, M2) => k.length > 0 && /\s$/.test(t(k)) ? [...k.slice(0, -1), t(k) + " " + M2] : [...k, M2], [])).map((B) => o.proseWrap === "never" ? [B.join(" ")] : B));
            function b(B) {
              if (D.chomping === "keep")
                return t(B).length === 0 ? B.slice(0, -1) : B;
              let k = 0;
              for (let M2 = B.length - 1; M2 >= 0 && B[M2].length === 0; M2--)
                k++;
              return k === 0 ? B : k >= 2 && !C ? B.slice(0, -(k - 1)) : B.slice(0, -k);
            }
          }
          function $2(D) {
            if (!D)
              return true;
            switch (D.type) {
              case "plain":
              case "quoteDouble":
              case "quoteSingle":
              case "alias":
              case "flowMapping":
              case "flowSequence":
                return true;
              default:
                return false;
            }
          }
          r.exports = { getLast: t, getAncestorCount: a, isNode: n, isEmptyNode: c, isInlineNode: $2, mapNode: u, defineShortcut: i, isNextLineEmpty: l, isLastDescendantNode: p, getBlockValueLineContents: P, getFlowScalarLineContents: I2, getLastDescendantNode: y2, hasPrettierIgnore: g2, hasLeadingComments: F, hasMiddleComments: _, hasIndicatorComment: w, hasTrailingComment: E, hasEndComments: N2 };
        } }), Mg2 = te2({ "src/language-yaml/print-preprocess.js"(e, r) {
          ne2();
          var { defineShortcut: t, mapNode: s } = $t2();
          function a(u) {
            return s(u, n);
          }
          function n(u) {
            switch (u.type) {
              case "document":
                t(u, "head", () => u.children[0]), t(u, "body", () => u.children[1]);
                break;
              case "documentBody":
              case "sequenceItem":
              case "flowSequenceItem":
              case "mappingKey":
              case "mappingValue":
                t(u, "content", () => u.children[0]);
                break;
              case "mappingItem":
              case "flowMappingItem":
                t(u, "key", () => u.children[0]), t(u, "value", () => u.children[1]);
                break;
            }
            return u;
          }
          r.exports = a;
        } }), Mr2 = te2({ "src/language-yaml/print/misc.js"(e, r) {
          ne2();
          var { builders: { softline: t, align: s } } = qe2(), { hasEndComments: a, isNextLineEmpty: n, isNode: u } = $t2(), i = /* @__PURE__ */ new WeakMap();
          function l(h, g2) {
            let c = h.getValue(), f = h.stack[0], F;
            return i.has(f) ? F = i.get(f) : (F = /* @__PURE__ */ new Set(), i.set(f, F)), !F.has(c.position.end.line) && (F.add(c.position.end.line), n(c, g2) && !p(h.getParentNode())) ? t : "";
          }
          function p(h) {
            return a(h) && !u(h, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
          }
          function y2(h, g2) {
            return s(" ".repeat(h), g2);
          }
          r.exports = { alignWithSpaces: y2, shouldPrintEndComments: p, printNextEmptyLine: l };
        } }), Rg2 = te2({ "src/language-yaml/print/flow-mapping-sequence.js"(e, r) {
          ne2();
          var { builders: { ifBreak: t, line: s, softline: a, hardline: n, join: u } } = qe2(), { isEmptyNode: i, getLast: l, hasEndComments: p } = $t2(), { printNextEmptyLine: y2, alignWithSpaces: h } = Mr2();
          function g2(f, F, _) {
            let w = f.getValue(), E = w.type === "flowMapping", N2 = E ? "{" : "[", x = E ? "}" : "]", I2 = a;
            E && w.children.length > 0 && _.bracketSpacing && (I2 = s);
            let P = l(w.children), $2 = P && P.type === "flowMappingItem" && i(P.key) && i(P.value);
            return [N2, h(_.tabWidth, [I2, c(f, F, _), _.trailingComma === "none" ? "" : t(","), p(w) ? [n, u(n, f.map(F, "endComments"))] : ""]), $2 ? "" : I2, x];
          }
          function c(f, F, _) {
            let w = f.getValue();
            return f.map((N2, x) => [F(), x === w.children.length - 1 ? "" : [",", s, w.children[x].position.start.line !== w.children[x + 1].position.start.line ? y2(N2, _.originalText) : ""]], "children");
          }
          r.exports = { printFlowMapping: g2, printFlowSequence: g2 };
        } }), $g = te2({ "src/language-yaml/print/mapping-item.js"(e, r) {
          ne2();
          var { builders: { conditionalGroup: t, group: s, hardline: a, ifBreak: n, join: u, line: i } } = qe2(), { hasLeadingComments: l, hasMiddleComments: p, hasTrailingComment: y2, hasEndComments: h, isNode: g2, isEmptyNode: c, isInlineNode: f } = $t2(), { alignWithSpaces: F } = Mr2();
          function _(x, I2, P, $2, D) {
            let { key: T, value: m } = x, C = c(T), o = c(m);
            if (C && o)
              return ": ";
            let d2 = $2("key"), v2 = E(x) ? " " : "";
            if (o)
              return x.type === "flowMappingItem" && I2.type === "flowMapping" ? d2 : x.type === "mappingItem" && w(T.content, D) && !y2(T.content) && (!I2.tag || I2.tag.value !== "tag:yaml.org,2002:set") ? [d2, v2, ":"] : ["? ", F(2, d2)];
            let S = $2("value");
            if (C)
              return [": ", F(2, S)];
            if (l(m) || !f(T.content))
              return ["? ", F(2, d2), a, u("", P.map($2, "value", "leadingComments").map((q) => [q, a])), ": ", F(2, S)];
            if (N2(T.content) && !l(T.content) && !p(T.content) && !y2(T.content) && !h(T) && !l(m.content) && !p(m.content) && !h(m) && w(m.content, D))
              return [d2, v2, ": ", S];
            let b = Symbol("mappingKey"), B = s([n("? "), s(F(2, d2), { id: b })]), k = [a, ": ", F(2, S)], M2 = [v2, ":"];
            l(m.content) || h(m) && m.content && !g2(m.content, ["mapping", "sequence"]) || I2.type === "mapping" && y2(T.content) && f(m.content) || g2(m.content, ["mapping", "sequence"]) && m.content.tag === null && m.content.anchor === null ? M2.push(a) : m.content && M2.push(i), M2.push(S);
            let R2 = F(D.tabWidth, M2);
            return w(T.content, D) && !l(T.content) && !p(T.content) && !h(T) ? t([[d2, R2]]) : t([[B, n(k, R2, { groupId: b })]]);
          }
          function w(x, I2) {
            if (!x)
              return true;
            switch (x.type) {
              case "plain":
              case "quoteSingle":
              case "quoteDouble":
                break;
              case "alias":
                return true;
              default:
                return false;
            }
            if (I2.proseWrap === "preserve")
              return x.position.start.line === x.position.end.line;
            if (/\\$/m.test(I2.originalText.slice(x.position.start.offset, x.position.end.offset)))
              return false;
            switch (I2.proseWrap) {
              case "never":
                return !x.value.includes(`
`);
              case "always":
                return !/[\n ]/.test(x.value);
              default:
                return false;
            }
          }
          function E(x) {
            return x.key.content && x.key.content.type === "alias";
          }
          function N2(x) {
            if (!x)
              return true;
            switch (x.type) {
              case "plain":
              case "quoteDouble":
              case "quoteSingle":
                return x.position.start.line === x.position.end.line;
              case "alias":
                return true;
              default:
                return false;
            }
          }
          r.exports = _;
        } }), Vg = te2({ "src/language-yaml/print/block.js"(e, r) {
          ne2();
          var { builders: { dedent: t, dedentToRoot: s, fill: a, hardline: n, join: u, line: i, literalline: l, markAsRoot: p }, utils: { getDocParts: y2 } } = qe2(), { getAncestorCount: h, getBlockValueLineContents: g2, hasIndicatorComment: c, isLastDescendantNode: f, isNode: F } = $t2(), { alignWithSpaces: _ } = Mr2();
          function w(E, N2, x) {
            let I2 = E.getValue(), P = h(E, (C) => F(C, ["sequence", "mapping"])), $2 = f(E), D = [I2.type === "blockFolded" ? ">" : "|"];
            I2.indent !== null && D.push(I2.indent.toString()), I2.chomping !== "clip" && D.push(I2.chomping === "keep" ? "+" : "-"), c(I2) && D.push(" ", N2("indicatorComment"));
            let T = g2(I2, { parentIndent: P, isLastDescendant: $2, options: x }), m = [];
            for (let [C, o] of T.entries())
              C === 0 && m.push(n), m.push(a(y2(u(i, o)))), C !== T.length - 1 ? m.push(o.length === 0 ? n : p(l)) : I2.chomping === "keep" && $2 && m.push(s(o.length === 0 ? n : l));
            return I2.indent === null ? D.push(t(_(x.tabWidth, m))) : D.push(s(_(I2.indent - 1 + P, m))), D;
          }
          r.exports = w;
        } }), Wg = te2({ "src/language-yaml/printer-yaml.js"(e, r) {
          ne2();
          var { builders: { breakParent: t, fill: s, group: a, hardline: n, join: u, line: i, lineSuffix: l, literalline: p }, utils: { getDocParts: y2, replaceTextEndOfLine: h } } = qe2(), { isPreviousLineEmpty: g2 } = Ue2(), { insertPragma: c, isPragma: f } = Og2(), { locStart: F } = jg2(), _ = qg2(), { getFlowScalarLineContents: w, getLastDescendantNode: E, hasLeadingComments: N2, hasMiddleComments: x, hasTrailingComment: I2, hasEndComments: P, hasPrettierIgnore: $2, isLastDescendantNode: D, isNode: T, isInlineNode: m } = $t2(), C = Mg2(), { alignWithSpaces: o, printNextEmptyLine: d2, shouldPrintEndComments: v2 } = Mr2(), { printFlowMapping: S, printFlowSequence: b } = Rg2(), B = $g(), k = Vg();
          function M2(j, Y, ie2) {
            let ee2 = j.getValue(), ce2 = [];
            ee2.type !== "mappingValue" && N2(ee2) && ce2.push([u(n, j.map(ie2, "leadingComments")), n]);
            let { tag: W, anchor: K2 } = ee2;
            W && ce2.push(ie2("tag")), W && K2 && ce2.push(" "), K2 && ce2.push(ie2("anchor"));
            let de = "";
            T(ee2, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !D(j) && (de = d2(j, Y.originalText)), (W || K2) && (T(ee2, ["sequence", "mapping"]) && !x(ee2) ? ce2.push(n) : ce2.push(" ")), x(ee2) && ce2.push([ee2.middleComments.length === 1 ? "" : n, u(n, j.map(ie2, "middleComments")), n]);
            let ue2 = j.getParentNode();
            return $2(j) ? ce2.push(h(Y.originalText.slice(ee2.position.start.offset, ee2.position.end.offset).trimEnd(), p)) : ce2.push(a(R2(ee2, ue2, j, Y, ie2))), I2(ee2) && !T(ee2, ["document", "documentHead"]) && ce2.push(l([ee2.type === "mappingValue" && !ee2.content ? "" : " ", ue2.type === "mappingKey" && j.getParentNode(2).type === "mapping" && m(ee2) ? "" : t, ie2("trailingComment")])), v2(ee2) && ce2.push(o(ee2.type === "sequenceItem" ? 2 : 0, [n, u(n, j.map((Fe2) => [g2(Y.originalText, Fe2.getValue(), F) ? n : "", ie2()], "endComments"))])), ce2.push(de), ce2;
          }
          function R2(j, Y, ie2, ee2, ce2) {
            switch (j.type) {
              case "root": {
                let { children: W } = j, K2 = [];
                ie2.each((ue2, Fe2) => {
                  let z = W[Fe2], U2 = W[Fe2 + 1];
                  Fe2 !== 0 && K2.push(n), K2.push(ce2()), J(z, U2) ? (K2.push(n, "..."), I2(z) && K2.push(" ", ce2("trailingComment"))) : U2 && !I2(U2.head) && K2.push(n, "---");
                }, "children");
                let de = E(j);
                return (!T(de, ["blockLiteral", "blockFolded"]) || de.chomping !== "keep") && K2.push(n), K2;
              }
              case "document": {
                let W = Y.children[ie2.getName() + 1], K2 = [];
                return L(j, W, Y, ee2) === "head" && ((j.head.children.length > 0 || j.head.endComments.length > 0) && K2.push(ce2("head")), I2(j.head) ? K2.push(["---", " ", ce2(["head", "trailingComment"])]) : K2.push("---")), q(j) && K2.push(ce2("body")), u(n, K2);
              }
              case "documentHead":
                return u(n, [...ie2.map(ce2, "children"), ...ie2.map(ce2, "endComments")]);
              case "documentBody": {
                let { children: W, endComments: K2 } = j, de = "";
                if (W.length > 0 && K2.length > 0) {
                  let ue2 = E(j);
                  T(ue2, ["blockFolded", "blockLiteral"]) ? ue2.chomping !== "keep" && (de = [n, n]) : de = n;
                }
                return [u(n, ie2.map(ce2, "children")), de, u(n, ie2.map(ce2, "endComments"))];
              }
              case "directive":
                return ["%", u(" ", [j.name, ...j.parameters])];
              case "comment":
                return ["#", j.value];
              case "alias":
                return ["*", j.value];
              case "tag":
                return ee2.originalText.slice(j.position.start.offset, j.position.end.offset);
              case "anchor":
                return ["&", j.value];
              case "plain":
                return Q(j.type, ee2.originalText.slice(j.position.start.offset, j.position.end.offset), ee2);
              case "quoteDouble":
              case "quoteSingle": {
                let W = "'", K2 = '"', de = ee2.originalText.slice(j.position.start.offset + 1, j.position.end.offset - 1);
                if (j.type === "quoteSingle" && de.includes("\\") || j.type === "quoteDouble" && /\\[^"]/.test(de)) {
                  let Fe2 = j.type === "quoteDouble" ? K2 : W;
                  return [Fe2, Q(j.type, de, ee2), Fe2];
                }
                if (de.includes(K2))
                  return [W, Q(j.type, j.type === "quoteDouble" ? de.replace(/\\"/g, K2).replace(/'/g, W.repeat(2)) : de, ee2), W];
                if (de.includes(W))
                  return [K2, Q(j.type, j.type === "quoteSingle" ? de.replace(/''/g, W) : de, ee2), K2];
                let ue2 = ee2.singleQuote ? W : K2;
                return [ue2, Q(j.type, de, ee2), ue2];
              }
              case "blockFolded":
              case "blockLiteral":
                return k(ie2, ce2, ee2);
              case "mapping":
              case "sequence":
                return u(n, ie2.map(ce2, "children"));
              case "sequenceItem":
                return ["- ", o(2, j.content ? ce2("content") : "")];
              case "mappingKey":
              case "mappingValue":
                return j.content ? ce2("content") : "";
              case "mappingItem":
              case "flowMappingItem":
                return B(j, Y, ie2, ce2, ee2);
              case "flowMapping":
                return S(ie2, ce2, ee2);
              case "flowSequence":
                return b(ie2, ce2, ee2);
              case "flowSequenceItem":
                return ce2("content");
              default:
                throw new Error(`Unexpected node type ${j.type}`);
            }
          }
          function q(j) {
            return j.body.children.length > 0 || P(j.body);
          }
          function J(j, Y) {
            return I2(j) || Y && (Y.head.children.length > 0 || P(Y.head));
          }
          function L(j, Y, ie2, ee2) {
            return ie2.children[0] === j && /---(?:\s|$)/.test(ee2.originalText.slice(F(j), F(j) + 4)) || j.head.children.length > 0 || P(j.head) || I2(j.head) ? "head" : J(j, Y) ? false : Y ? "root" : false;
          }
          function Q(j, Y, ie2) {
            let ee2 = w(j, Y, ie2);
            return u(n, ee2.map((ce2) => s(y2(u(i, ce2)))));
          }
          function V(j, Y) {
            if (T(Y))
              switch (delete Y.position, Y.type) {
                case "comment":
                  if (f(Y.value))
                    return null;
                  break;
                case "quoteDouble":
                case "quoteSingle":
                  Y.type = "quote";
                  break;
              }
          }
          r.exports = { preprocess: C, embed: _, print: M2, massageAstNode: V, insertPragma: c };
        } }), Hg = te2({ "src/language-yaml/options.js"(e, r) {
          ne2();
          var t = Mt2();
          r.exports = { bracketSpacing: t.bracketSpacing, singleQuote: t.singleQuote, proseWrap: t.proseWrap };
        } }), Gg = te2({ "src/language-yaml/parsers.js"() {
          ne2();
        } }), Ug = te2({ "node_modules/linguist-languages/data/YAML.json"(e, r) {
          r.exports = { name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "CITATION.cff", "glide.lock", "yarn.lock"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407 };
        } }), Jg = te2({ "src/language-yaml/index.js"(e, r) {
          ne2();
          var t = _t2(), s = Wg(), a = Hg(), n = Gg(), u = [t(Ug(), (i) => ({ since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: [...i.filenames.filter((l) => l !== "yarn.lock"), ".prettierrc", ".stylelintrc", ".lintstagedrc"] }))];
          r.exports = { languages: u, printers: { yaml: s }, options: a, parsers: n };
        } }), zg = te2({ "src/languages.js"(e, r) {
          ne2(), r.exports = [Bd2(), Ud2(), eg2(), ag2(), dg2(), Lg2(), Jg()];
        } });
        ne2();
        var { version: Xg } = Ia2(), Ot2 = Gm2(), { getSupportInfo: Kg } = Xn2(), Yg = Um2(), Qg = zg(), Zg = qe2();
        function Nt2(e) {
          let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return function() {
            for (var t = arguments.length, s = new Array(t), a = 0; a < t; a++)
              s[a] = arguments[a];
            let n = s[r] || {}, u = n.plugins || [];
            return s[r] = Object.assign(Object.assign({}, n), {}, { plugins: [...Qg, ...Array.isArray(u) ? u : Object.values(u)] }), e(...s);
          };
        }
        var jn2 = Nt2(Ot2.formatWithCursor);
        jo2.exports = { formatWithCursor: jn2, format(e, r) {
          return jn2(e, r).formatted;
        }, check(e, r) {
          let { formatted: t } = jn2(e, r);
          return t === e;
        }, doc: Zg, getSupportInfo: Nt2(Kg, 0), version: Xg, util: Yg, __debug: { parse: Nt2(Ot2.parse), formatAST: Nt2(Ot2.formatAST), formatDoc: Nt2(Ot2.formatDoc), printToDoc: Nt2(Ot2.printToDoc), printDocToString: Nt2(Ot2.printDocToString) } };
      });
      return e0();
    });
  })(standalone);
  return standalone.exports;
}
(function(module, exports) {
  !function(t, e) {
    e(exports, requireStandalone());
  }(commonjsGlobal, function(t, e) {
    function i(t2) {
      return t2 && "object" == typeof t2 && "default" in t2 ? t2 : { default: t2 };
    }
    var n = i(e);
    function s(t2, e2) {
      var i2 = Object.keys(t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(t2);
        e2 && (n2 = n2.filter(function(e3) {
          return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
        })), i2.push.apply(i2, n2);
      }
      return i2;
    }
    function r(t2) {
      for (var e2 = 1; e2 < arguments.length; e2++) {
        var i2 = null != arguments[e2] ? arguments[e2] : {};
        e2 % 2 ? s(Object(i2), true).forEach(function(e3) {
          h(t2, e3, i2[e3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(i2)) : s(Object(i2)).forEach(function(e3) {
          Object.defineProperty(t2, e3, Object.getOwnPropertyDescriptor(i2, e3));
        });
      }
      return t2;
    }
    function o() {
      /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
      /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
      o = function() {
        return t2;
      };
      var t2 = {}, e2 = Object.prototype, i2 = e2.hasOwnProperty, n2 = "function" == typeof Symbol ? Symbol : {}, s2 = n2.iterator || "@@iterator", r2 = n2.asyncIterator || "@@asyncIterator", a2 = n2.toStringTag || "@@toStringTag";
      function h2(t3, e3, i3) {
        return Object.defineProperty(t3, e3, { value: i3, enumerable: true, configurable: true, writable: true }), t3[e3];
      }
      try {
        h2({}, "");
      } catch (t3) {
        h2 = function(t4, e3, i3) {
          return t4[e3] = i3;
        };
      }
      function l2(t3, e3, i3, n3) {
        var s3 = e3 && e3.prototype instanceof _3 ? e3 : _3, r3 = Object.create(s3.prototype), o2 = new g3(n3 || []);
        return r3._invoke = function(t4, e4, i4) {
          var n4 = "suspendedStart";
          return function(s4, r4) {
            if ("executing" === n4)
              throw new Error("Generator is already running");
            if ("completed" === n4) {
              if ("throw" === s4)
                throw r4;
              return L2();
            }
            for (i4.method = s4, i4.arg = r4; ; ) {
              var o3 = i4.delegate;
              if (o3) {
                var a3 = y3(o3, i4);
                if (a3) {
                  if (a3 === u2)
                    continue;
                  return a3;
                }
              }
              if ("next" === i4.method)
                i4.sent = i4._sent = i4.arg;
              else if ("throw" === i4.method) {
                if ("suspendedStart" === n4)
                  throw n4 = "completed", i4.arg;
                i4.dispatchException(i4.arg);
              } else
                "return" === i4.method && i4.abrupt("return", i4.arg);
              n4 = "executing";
              var h3 = c2(t4, e4, i4);
              if ("normal" === h3.type) {
                if (n4 = i4.done ? "completed" : "suspendedYield", h3.arg === u2)
                  continue;
                return { value: h3.arg, done: i4.done };
              }
              "throw" === h3.type && (n4 = "completed", i4.method = "throw", i4.arg = h3.arg);
            }
          };
        }(t3, i3, o2), r3;
      }
      function c2(t3, e3, i3) {
        try {
          return { type: "normal", arg: t3.call(e3, i3) };
        } catch (t4) {
          return { type: "throw", arg: t4 };
        }
      }
      t2.wrap = l2;
      var u2 = {};
      function _3() {
      }
      function d3() {
      }
      function p2() {
      }
      var f2 = {};
      h2(f2, s2, function() {
        return this;
      });
      var T2 = Object.getPrototypeOf, k2 = T2 && T2(T2(N3([])));
      k2 && k2 !== e2 && i2.call(k2, s2) && (f2 = k2);
      var E2 = p2.prototype = _3.prototype = Object.create(f2);
      function m2(t3) {
        ["next", "throw", "return"].forEach(function(e3) {
          h2(t3, e3, function(t4) {
            return this._invoke(e3, t4);
          });
        });
      }
      function x2(t3, e3) {
        function n3(s4, r3, o2, a3) {
          var h3 = c2(t3[s4], t3, r3);
          if ("throw" !== h3.type) {
            var l3 = h3.arg, u3 = l3.value;
            return u3 && "object" == typeof u3 && i2.call(u3, "__await") ? e3.resolve(u3.__await).then(function(t4) {
              n3("next", t4, o2, a3);
            }, function(t4) {
              n3("throw", t4, o2, a3);
            }) : e3.resolve(u3).then(function(t4) {
              l3.value = t4, o2(l3);
            }, function(t4) {
              return n3("throw", t4, o2, a3);
            });
          }
          a3(h3.arg);
        }
        var s3;
        this._invoke = function(t4, i3) {
          function r3() {
            return new e3(function(e4, s4) {
              n3(t4, i3, e4, s4);
            });
          }
          return s3 = s3 ? s3.then(r3, r3) : r3();
        };
      }
      function y3(t3, e3) {
        var i3 = t3.iterator[e3.method];
        if (void 0 === i3) {
          if (e3.delegate = null, "throw" === e3.method) {
            if (t3.iterator.return && (e3.method = "return", e3.arg = void 0, y3(t3, e3), "throw" === e3.method))
              return u2;
            e3.method = "throw", e3.arg = new TypeError("The iterator does not provide a 'throw' method");
          }
          return u2;
        }
        var n3 = c2(i3, t3.iterator, e3.arg);
        if ("throw" === n3.type)
          return e3.method = "throw", e3.arg = n3.arg, e3.delegate = null, u2;
        var s3 = n3.arg;
        return s3 ? s3.done ? (e3[t3.resultName] = s3.value, e3.next = t3.nextLoc, "return" !== e3.method && (e3.method = "next", e3.arg = void 0), e3.delegate = null, u2) : s3 : (e3.method = "throw", e3.arg = new TypeError("iterator result is not an object"), e3.delegate = null, u2);
      }
      function v3(t3) {
        var e3 = { tryLoc: t3[0] };
        1 in t3 && (e3.catchLoc = t3[1]), 2 in t3 && (e3.finallyLoc = t3[2], e3.afterLoc = t3[3]), this.tryEntries.push(e3);
      }
      function A2(t3) {
        var e3 = t3.completion || {};
        e3.type = "normal", delete e3.arg, t3.completion = e3;
      }
      function g3(t3) {
        this.tryEntries = [{ tryLoc: "root" }], t3.forEach(v3, this), this.reset(true);
      }
      function N3(t3) {
        if (t3) {
          var e3 = t3[s2];
          if (e3)
            return e3.call(t3);
          if ("function" == typeof t3.next)
            return t3;
          if (!isNaN(t3.length)) {
            var n3 = -1, r3 = function e4() {
              for (; ++n3 < t3.length; )
                if (i2.call(t3, n3))
                  return e4.value = t3[n3], e4.done = false, e4;
              return e4.value = void 0, e4.done = true, e4;
            };
            return r3.next = r3;
          }
        }
        return { next: L2 };
      }
      function L2() {
        return { value: void 0, done: true };
      }
      return d3.prototype = p2, h2(E2, "constructor", p2), h2(p2, "constructor", d3), d3.displayName = h2(p2, a2, "GeneratorFunction"), t2.isGeneratorFunction = function(t3) {
        var e3 = "function" == typeof t3 && t3.constructor;
        return !!e3 && (e3 === d3 || "GeneratorFunction" === (e3.displayName || e3.name));
      }, t2.mark = function(t3) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t3, p2) : (t3.__proto__ = p2, h2(t3, a2, "GeneratorFunction")), t3.prototype = Object.create(E2), t3;
      }, t2.awrap = function(t3) {
        return { __await: t3 };
      }, m2(x2.prototype), h2(x2.prototype, r2, function() {
        return this;
      }), t2.AsyncIterator = x2, t2.async = function(e3, i3, n3, s3, r3) {
        void 0 === r3 && (r3 = Promise);
        var o2 = new x2(l2(e3, i3, n3, s3), r3);
        return t2.isGeneratorFunction(i3) ? o2 : o2.next().then(function(t3) {
          return t3.done ? t3.value : o2.next();
        });
      }, m2(E2), h2(E2, a2, "Generator"), h2(E2, s2, function() {
        return this;
      }), h2(E2, "toString", function() {
        return "[object Generator]";
      }), t2.keys = function(t3) {
        var e3 = [];
        for (var i3 in t3)
          e3.push(i3);
        return e3.reverse(), function i4() {
          for (; e3.length; ) {
            var n3 = e3.pop();
            if (n3 in t3)
              return i4.value = n3, i4.done = false, i4;
          }
          return i4.done = true, i4;
        };
      }, t2.values = N3, g3.prototype = { constructor: g3, reset: function(t3) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(A2), !t3)
          for (var e3 in this)
            "t" === e3.charAt(0) && i2.call(this, e3) && !isNaN(+e3.slice(1)) && (this[e3] = void 0);
      }, stop: function() {
        this.done = true;
        var t3 = this.tryEntries[0].completion;
        if ("throw" === t3.type)
          throw t3.arg;
        return this.rval;
      }, dispatchException: function(t3) {
        if (this.done)
          throw t3;
        var e3 = this;
        function n3(i3, n4) {
          return o2.type = "throw", o2.arg = t3, e3.next = i3, n4 && (e3.method = "next", e3.arg = void 0), !!n4;
        }
        for (var s3 = this.tryEntries.length - 1; s3 >= 0; --s3) {
          var r3 = this.tryEntries[s3], o2 = r3.completion;
          if ("root" === r3.tryLoc)
            return n3("end");
          if (r3.tryLoc <= this.prev) {
            var a3 = i2.call(r3, "catchLoc"), h3 = i2.call(r3, "finallyLoc");
            if (a3 && h3) {
              if (this.prev < r3.catchLoc)
                return n3(r3.catchLoc, true);
              if (this.prev < r3.finallyLoc)
                return n3(r3.finallyLoc);
            } else if (a3) {
              if (this.prev < r3.catchLoc)
                return n3(r3.catchLoc, true);
            } else {
              if (!h3)
                throw new Error("try statement without catch or finally");
              if (this.prev < r3.finallyLoc)
                return n3(r3.finallyLoc);
            }
          }
        }
      }, abrupt: function(t3, e3) {
        for (var n3 = this.tryEntries.length - 1; n3 >= 0; --n3) {
          var s3 = this.tryEntries[n3];
          if (s3.tryLoc <= this.prev && i2.call(s3, "finallyLoc") && this.prev < s3.finallyLoc) {
            var r3 = s3;
            break;
          }
        }
        r3 && ("break" === t3 || "continue" === t3) && r3.tryLoc <= e3 && e3 <= r3.finallyLoc && (r3 = null);
        var o2 = r3 ? r3.completion : {};
        return o2.type = t3, o2.arg = e3, r3 ? (this.method = "next", this.next = r3.finallyLoc, u2) : this.complete(o2);
      }, complete: function(t3, e3) {
        if ("throw" === t3.type)
          throw t3.arg;
        return "break" === t3.type || "continue" === t3.type ? this.next = t3.arg : "return" === t3.type ? (this.rval = this.arg = t3.arg, this.method = "return", this.next = "end") : "normal" === t3.type && e3 && (this.next = e3), u2;
      }, finish: function(t3) {
        for (var e3 = this.tryEntries.length - 1; e3 >= 0; --e3) {
          var i3 = this.tryEntries[e3];
          if (i3.finallyLoc === t3)
            return this.complete(i3.completion, i3.afterLoc), A2(i3), u2;
        }
      }, catch: function(t3) {
        for (var e3 = this.tryEntries.length - 1; e3 >= 0; --e3) {
          var i3 = this.tryEntries[e3];
          if (i3.tryLoc === t3) {
            var n3 = i3.completion;
            if ("throw" === n3.type) {
              var s3 = n3.arg;
              A2(i3);
            }
            return s3;
          }
        }
        throw new Error("illegal catch attempt");
      }, delegateYield: function(t3, e3, i3) {
        return this.delegate = { iterator: N3(t3), resultName: e3, nextLoc: i3 }, "next" === this.method && (this.arg = void 0), u2;
      } }, t2;
    }
    function a(t2) {
      return a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
        return typeof t3;
      } : function(t3) {
        return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
      }, a(t2);
    }
    function h(t2, e2, i2) {
      return e2 in t2 ? Object.defineProperty(t2, e2, { value: i2, enumerable: true, configurable: true, writable: true }) : t2[e2] = i2, t2;
    }
    function l(t2, e2) {
      return function(t3) {
        if (Array.isArray(t3))
          return t3;
      }(t2) || function(t3, e3) {
        var i2 = null == t3 ? null : "undefined" != typeof Symbol && t3[Symbol.iterator] || t3["@@iterator"];
        if (null == i2)
          return;
        var n2, s2, r2 = [], o2 = true, a2 = false;
        try {
          for (i2 = i2.call(t3); !(o2 = (n2 = i2.next()).done) && (r2.push(n2.value), !e3 || r2.length !== e3); o2 = true)
            ;
        } catch (t4) {
          a2 = true, s2 = t4;
        } finally {
          try {
            o2 || null == i2.return || i2.return();
          } finally {
            if (a2)
              throw s2;
          }
        }
        return r2;
      }(t2, e2) || u(t2, e2) || function() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }();
    }
    function c(t2) {
      return function(t3) {
        if (Array.isArray(t3))
          return _(t3);
      }(t2) || function(t3) {
        if ("undefined" != typeof Symbol && null != t3[Symbol.iterator] || null != t3["@@iterator"])
          return Array.from(t3);
      }(t2) || u(t2) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }();
    }
    function u(t2, e2) {
      if (t2) {
        if ("string" == typeof t2)
          return _(t2, e2);
        var i2 = Object.prototype.toString.call(t2).slice(8, -1);
        return "Object" === i2 && t2.constructor && (i2 = t2.constructor.name), "Map" === i2 || "Set" === i2 ? Array.from(t2) : "Arguments" === i2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i2) ? _(t2, e2) : void 0;
      }
    }
    function _(t2, e2) {
      (null == e2 || e2 > t2.length) && (e2 = t2.length);
      for (var i2 = 0, n2 = new Array(e2); i2 < e2; i2++)
        n2[i2] = t2[i2];
      return n2;
    }
    function d2(t2, e2) {
      var i2 = "undefined" != typeof Symbol && t2[Symbol.iterator] || t2["@@iterator"];
      if (!i2) {
        if (Array.isArray(t2) || (i2 = u(t2)) || e2 && t2 && "number" == typeof t2.length) {
          i2 && (t2 = i2);
          var n2 = 0, s2 = function() {
          };
          return { s: s2, n: function() {
            return n2 >= t2.length ? { done: true } : { done: false, value: t2[n2++] };
          }, e: function(t3) {
            throw t3;
          }, f: s2 };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var r2, o2 = true, a2 = false;
      return { s: function() {
        i2 = i2.call(t2);
      }, n: function() {
        var t3 = i2.next();
        return o2 = t3.done, t3;
      }, e: function(t3) {
        a2 = true, r2 = t3;
      }, f: function() {
        try {
          o2 || null == i2.return || i2.return();
        } finally {
          if (a2)
            throw r2;
        }
      } };
    }
    var p = { attributeIndex: 0, attributeListDepth: {}, matchST_ATTRIBUTE: function() {
      var t2 = this.input();
      if (this.is_WHITESPACE()) {
        do {
          t2 = this.input();
        } while (this.is_WHITESPACE());
        return this.unput(1), null;
      }
      switch (t2) {
        case "]":
          return 0 === this.attributeListDepth[this.attributeIndex] ? (delete this.attributeListDepth[this.attributeIndex], this.attributeIndex--, this.popState()) : this.attributeListDepth[this.attributeIndex]--, "]";
        case "(":
        case ")":
        case ":":
        case "=":
        case "|":
        case "&":
        case "^":
        case "-":
        case "+":
        case "*":
        case "%":
        case "~":
        case "<":
        case ">":
        case "!":
          return this.consume_TOKEN();
        case "[":
          return this.attributeListDepth[this.attributeIndex]++, "[";
        case ",":
          return ",";
        case '"':
          return this.ST_DOUBLE_QUOTES();
        case "'":
          return this.T_CONSTANT_ENCAPSED_STRING();
        case "/":
          return "/" === this._input[this.offset] ? this.T_COMMENT() : "*" === this._input[this.offset] ? (this.input(), this.T_DOC_COMMENT()) : this.consume_TOKEN();
      }
      if (this.is_LABEL_START() || "\\" === t2) {
        for (; this.offset < this.size; ) {
          var e2 = this.input();
          if (!this.is_LABEL() && "\\" !== e2) {
            e2 && this.unput(1);
            break;
          }
        }
        return this.T_STRING();
      }
      if (this.is_NUM())
        return this.consume_NUM();
      throw new Error('Bad terminal sequence "'.concat(t2, '" at line ').concat(this.yylineno, " (offset ").concat(this.offset, ")"));
    } };
    p.attributeIndex, p.attributeListDepth, p.matchST_ATTRIBUTE;
    var f = { T_COMMENT: function() {
      for (; this.offset < this.size; ) {
        var t2 = this.input();
        if ("\n" === t2 || "\r" === t2)
          return this.tok.T_COMMENT;
        if ("?" === t2 && !this.aspTagMode && ">" === this._input[this.offset])
          return this.unput(1), this.tok.T_COMMENT;
        if ("%" === t2 && this.aspTagMode && ">" === this._input[this.offset])
          return this.unput(1), this.tok.T_COMMENT;
      }
      return this.tok.T_COMMENT;
    }, T_DOC_COMMENT: function() {
      var t2 = this.input(), e2 = this.tok.T_COMMENT;
      if ("*" === t2) {
        if (t2 = this.input(), this.is_WHITESPACE() && (e2 = this.tok.T_DOC_COMMENT), "/" === t2)
          return e2;
        this.unput(1);
      }
      for (; this.offset < this.size; )
        if ("*" === (t2 = this.input()) && "/" === this._input[this.offset]) {
          this.input();
          break;
        }
      return e2;
    } };
    f.T_COMMENT, f.T_DOC_COMMENT;
    var T = { nextINITIAL: function() {
      return this.conditionStack.length > 1 && "INITIAL" === this.conditionStack[this.conditionStack.length - 1] ? this.popState() : this.begin("ST_IN_SCRIPTING"), this;
    }, matchINITIAL: function() {
      for (; this.offset < this.size; ) {
        var t2 = this.input();
        if ("<" == t2) {
          if ("?" == (t2 = this.ahead(1))) {
            if (this.tryMatch("?=")) {
              this.unput(1).appendToken(this.tok.T_OPEN_TAG_WITH_ECHO, 3).nextINITIAL();
              break;
            }
            if (this.tryMatchCaseless("?php") && (" " === (t2 = this._input[this.offset + 4]) || "	" === t2 || "\n" === t2 || "\r" === t2)) {
              this.unput(1).appendToken(this.tok.T_OPEN_TAG, 6).nextINITIAL();
              break;
            }
            if (this.short_tags) {
              this.unput(1).appendToken(this.tok.T_OPEN_TAG, 2).nextINITIAL();
              break;
            }
          } else if (this.asp_tags && "%" == t2) {
            if (this.tryMatch("%=")) {
              this.aspTagMode = true, this.unput(1).appendToken(this.tok.T_OPEN_TAG_WITH_ECHO, 3).nextINITIAL();
              break;
            }
            this.aspTagMode = true, this.unput(1).appendToken(this.tok.T_OPEN_TAG, 2).nextINITIAL();
            break;
          }
        }
      }
      return this.yytext.length > 0 && this.tok.T_INLINE_HTML;
    } };
    T.nextINITIAL, T.matchINITIAL;
    var k = { consume_NUM: function() {
      var t2 = this.yytext[0], e2 = "." === t2;
      if ("0" === t2)
        if ("x" === (t2 = this.input()) || "X" === t2) {
          if ("_" !== (t2 = this.input()) && this.is_HEX())
            return this.consume_HNUM();
          this.unput(t2 ? 2 : 1);
        } else if ("b" === t2 || "B" === t2) {
          if ("_" !== (t2 = this.input()) && "0" === t2 || "1" === t2)
            return this.consume_BNUM();
          this.unput(t2 ? 2 : 1);
        } else if ("o" === t2 || "O" === t2) {
          if ("_" !== (t2 = this.input()) && this.is_OCTAL())
            return this.consume_ONUM();
          this.unput(t2 ? 2 : 1);
        } else
          this.is_NUM() || t2 && this.unput(1);
      for (; this.offset < this.size; ) {
        var i2 = t2;
        if ("_" === (t2 = this.input())) {
          if ("_" === i2) {
            this.unput(2);
            break;
          }
          if ("." === i2) {
            this.unput(1);
            break;
          }
          if ("e" === i2 || "E" === i2) {
            this.unput(2);
            break;
          }
        } else {
          if ("." === t2) {
            if (e2) {
              this.unput(1);
              break;
            }
            if ("_" === i2) {
              this.unput(2);
              break;
            }
            e2 = true;
            continue;
          }
          if ("e" === t2 || "E" === t2) {
            if ("_" === i2) {
              this.unput(1);
              break;
            }
            var n2 = 2;
            if ("+" !== (t2 = this.input()) && "-" !== t2 || (n2 = 3, t2 = this.input()), this.is_NUM_START())
              return this.consume_LNUM(), this.tok.T_DNUMBER;
            this.unput(t2 ? n2 : n2 - 1);
            break;
          }
        }
        if (!this.is_NUM()) {
          t2 && this.unput(1);
          break;
        }
      }
      return e2 ? this.tok.T_DNUMBER : this.yytext.length < 9 || this.yytext.length < 10 || 10 == this.yytext.length && this.yytext < "2147483648" ? this.tok.T_LNUMBER : this.tok.T_DNUMBER;
    }, consume_HNUM: function() {
      for (; this.offset < this.size; ) {
        var t2 = this.input();
        if (!this.is_HEX()) {
          t2 && this.unput(1);
          break;
        }
      }
      return this.tok.T_LNUMBER;
    }, consume_LNUM: function() {
      for (; this.offset < this.size; ) {
        var t2 = this.input();
        if (!this.is_NUM()) {
          t2 && this.unput(1);
          break;
        }
      }
      return this.tok.T_LNUMBER;
    }, consume_BNUM: function() {
      for (var t2; this.offset < this.size; )
        if ("0" !== (t2 = this.input()) && "1" !== t2 && "_" !== t2) {
          t2 && this.unput(1);
          break;
        }
      return this.tok.T_LNUMBER;
    }, consume_ONUM: function() {
      for (; this.offset < this.size; ) {
        var t2 = this.input();
        if (!this.is_OCTAL()) {
          t2 && this.unput(1);
          break;
        }
      }
      return this.tok.T_LNUMBER;
    } };
    k.consume_NUM, k.consume_HNUM, k.consume_LNUM, k.consume_BNUM, k.consume_ONUM;
    var E = { matchST_LOOKING_FOR_PROPERTY: function() {
      var t2 = this.input();
      if ("-" === t2) {
        if (">" === (t2 = this.input()))
          return this.tok.T_OBJECT_OPERATOR;
        t2 && this.unput(1);
      } else {
        if (this.is_WHITESPACE())
          return this.tok.T_WHITESPACE;
        if (this.is_LABEL_START())
          return this.consume_LABEL(), this.popState(), this.tok.T_STRING;
      }
      return this.popState(), t2 && this.unput(1), false;
    }, matchST_LOOKING_FOR_VARNAME: function() {
      var t2 = this.input();
      if (this.popState(), this.begin("ST_IN_SCRIPTING"), this.is_LABEL_START()) {
        if (this.consume_LABEL(), "[" === (t2 = this.input()) || "}" === t2)
          return this.unput(1), this.tok.T_STRING_VARNAME;
        this.unput(this.yytext.length);
      } else
        t2 && this.unput(1);
      return false;
    }, matchST_VAR_OFFSET: function() {
      var t2 = this.input();
      if (this.is_NUM_START())
        return this.consume_NUM(), this.tok.T_NUM_STRING;
      if ("]" === t2)
        return this.popState(), "]";
      if ("$" === t2) {
        if (this.input(), this.is_LABEL_START())
          return this.consume_LABEL(), this.tok.T_VARIABLE;
        throw new Error("Unexpected terminal");
      }
      if (this.is_LABEL_START())
        return this.consume_LABEL(), this.tok.T_STRING;
      if (this.is_WHITESPACE() || "\\" === t2 || "'" === t2 || "#" === t2)
        return this.tok.T_ENCAPSED_AND_WHITESPACE;
      if ("[" === t2 || "{" === t2 || "}" === t2 || '"' === t2 || "`" === t2 || this.is_TOKEN())
        return t2;
      throw new Error("Unexpected terminal");
    } };
    E.matchST_LOOKING_FOR_PROPERTY, E.matchST_LOOKING_FOR_VARNAME, E.matchST_VAR_OFFSET;
    var m = { matchST_IN_SCRIPTING: function() {
      var t2 = this.input();
      switch (t2) {
        case " ":
        case "	":
        case "\n":
        case "\r":
        case "\r\n":
          return this.T_WHITESPACE();
        case "#":
          return this.version >= 800 && "[" === this._input[this.offset] ? (this.input(), this.attributeListDepth[++this.attributeIndex] = 0, this.begin("ST_ATTRIBUTE"), this.tok.T_ATTRIBUTE) : this.T_COMMENT();
        case "/":
          return "/" === this._input[this.offset] ? this.T_COMMENT() : "*" === this._input[this.offset] ? (this.input(), this.T_DOC_COMMENT()) : this.consume_TOKEN();
        case "'":
          return this.T_CONSTANT_ENCAPSED_STRING();
        case '"':
          return this.ST_DOUBLE_QUOTES();
        case "`":
          return this.begin("ST_BACKQUOTE"), "`";
        case "?":
          if (!this.aspTagMode && this.tryMatch(">")) {
            this.input();
            var e2 = this._input[this.offset];
            return "\n" !== e2 && "\r" !== e2 || this.input(), this.conditionStack.length > 1 && this.begin("INITIAL"), this.tok.T_CLOSE_TAG;
          }
          return this.consume_TOKEN();
        case "%":
          return this.aspTagMode && ">" === this._input[this.offset] ? (this.input(), "\n" !== (t2 = this._input[this.offset]) && "\r" !== t2 || this.input(), this.aspTagMode = false, this.conditionStack.length > 1 && this.begin("INITIAL"), this.tok.T_CLOSE_TAG) : this.consume_TOKEN();
        case "{":
          return this.begin("ST_IN_SCRIPTING"), "{";
        case "}":
          return this.conditionStack.length > 2 && this.popState(), "}";
        default:
          if ("." === t2) {
            if (t2 = this.input(), this.is_NUM_START())
              return this.consume_NUM();
            t2 && this.unput(1);
          }
          if (this.is_NUM_START())
            return this.consume_NUM();
          if (this.is_LABEL_START())
            return this.consume_LABEL().T_STRING();
          if (this.is_TOKEN())
            return this.consume_TOKEN();
      }
      throw new Error('Bad terminal sequence "' + t2 + '" at line ' + this.yylineno + " (offset " + this.offset + ")");
    }, T_WHITESPACE: function() {
      for (; this.offset < this.size; ) {
        var t2 = this.input();
        if (" " !== t2 && "	" !== t2 && "\n" !== t2 && "\r" !== t2) {
          t2 && this.unput(1);
          break;
        }
      }
      return this.tok.T_WHITESPACE;
    } };
    m.matchST_IN_SCRIPTING, m.T_WHITESPACE;
    var x = ["\n", "\r"], y2 = ["\n", "\r", ";"], v2 = y2.concat(["	", " ", ",", "]", ")", "/", "=", "!"]), A = { T_CONSTANT_ENCAPSED_STRING: function() {
      for (var t2; this.offset < this.size; )
        if ("\\" == (t2 = this.input()))
          this.input();
        else if ("'" == t2)
          break;
      return this.tok.T_CONSTANT_ENCAPSED_STRING;
    }, is_HEREDOC: function() {
      var t2 = this.offset;
      if ("<" === this._input[this.offset - 1] && "<" === this._input[this.offset] && "<" === this._input[this.offset + 1]) {
        if (this.offset += 3, this.is_TABSPACE())
          for (; this.offset < this.size && (this.offset++, this.is_TABSPACE()); )
            ;
        var e2 = this._input[this.offset - 1];
        if ("'" === e2 || '"' === e2 ? this.offset++ : e2 = null, this.is_LABEL_START()) {
          for (var i2 = this.offset - 1; this.offset < this.size && (this.offset++, this.is_LABEL()); )
            ;
          var n2 = this._input.substring(i2, this.offset - 1);
          if ((!e2 || e2 === this._input[this.offset - 1]) && (e2 && this.offset++, x.includes(this._input[this.offset - 1])))
            return this.heredoc_label.label = n2, this.heredoc_label.length = n2.length, this.heredoc_label.finished = false, i2 = this.offset - t2, this.offset = t2, this.consume(i2), "'" === e2 ? this.begin("ST_NOWDOC") : this.begin("ST_HEREDOC"), this.prematch_ENDOFDOC(), this.tok.T_START_HEREDOC;
        }
      }
      return this.offset = t2, false;
    }, ST_DOUBLE_QUOTES: function() {
      for (var t2; this.offset < this.size; )
        if ("\\" == (t2 = this.input()))
          this.input();
        else {
          if ('"' == t2)
            break;
          if ("$" == t2) {
            if ("{" == (t2 = this.input()) || this.is_LABEL_START()) {
              this.unput(2);
              break;
            }
            t2 && this.unput(1);
          } else if ("{" == t2) {
            if ("$" == (t2 = this.input())) {
              this.unput(2);
              break;
            }
            t2 && this.unput(1);
          }
        }
      if ('"' == t2)
        return this.tok.T_CONSTANT_ENCAPSED_STRING;
      var e2 = 1;
      return "b" !== this.yytext[0] && "B" !== this.yytext[0] || (e2 = 2), this.yytext.length > 2 && this.appendToken(this.tok.T_ENCAPSED_AND_WHITESPACE, this.yytext.length - e2), this.unput(this.yytext.length - e2), this.begin("ST_DOUBLE_QUOTES"), this.yytext;
    }, isDOC_MATCH: function(t2, e2) {
      var i2 = this._input[t2 - 2];
      if (!x.includes(i2))
        return false;
      var n2 = false, s2 = false, r2 = 0, o2 = this._input[t2 - 1];
      if (this.version >= 703) {
        for (; "	" === o2 || " " === o2; )
          " " === o2 ? n2 = true : "	" === o2 && (s2 = true), o2 = this._input[t2 + r2], r2++;
        if (t2 += r2, x.includes(this._input[t2 - 1]))
          return false;
      }
      if (this._input.substring(t2 - 1, t2 - 1 + this.heredoc_label.length) === this.heredoc_label.label) {
        var a2 = this._input[t2 - 1 + this.heredoc_label.length];
        if ((this.version >= 703 ? v2 : y2).includes(a2)) {
          if (e2) {
            if (this.consume(r2), n2 && s2)
              throw new Error("Parse error:  mixing spaces and tabs in ending marker at line " + this.yylineno + " (offset " + this.offset + ")");
          } else
            this.heredoc_label.indentation = r2, this.heredoc_label.indentation_uses_spaces = n2, this.heredoc_label.first_encaps_node = true;
          return true;
        }
      }
      return false;
    }, prematch_ENDOFDOC: function() {
      this.heredoc_label.indentation_uses_spaces = false, this.heredoc_label.indentation = 0, this.heredoc_label.first_encaps_node = true;
      for (var t2 = this.offset + 1; t2 < this._input.length; ) {
        if (this.isDOC_MATCH(t2, false))
          return;
        if (!x.includes(this._input[t2 - 1]))
          for (; !x.includes(this._input[t2++]) && t2 < this._input.length; )
            ;
        t2++;
      }
    }, matchST_NOWDOC: function() {
      if (this.isDOC_MATCH(this.offset, true))
        return this.consume(this.heredoc_label.length), this.popState(), this.tok.T_END_HEREDOC;
      for (var t2 = this._input[this.offset - 1]; this.offset < this.size; )
        if (x.includes(t2)) {
          if (t2 = this.input(), this.isDOC_MATCH(this.offset, true))
            return this.unput(1).popState(), this.appendToken(this.tok.T_END_HEREDOC, this.heredoc_label.length), this.tok.T_ENCAPSED_AND_WHITESPACE;
        } else
          t2 = this.input();
      return this.tok.T_ENCAPSED_AND_WHITESPACE;
    }, matchST_HEREDOC: function() {
      var t2 = this.input();
      if (this.isDOC_MATCH(this.offset, true))
        return this.consume(this.heredoc_label.length - 1), this.popState(), this.tok.T_END_HEREDOC;
      for (; this.offset < this.size; )
        if ("\\" === t2 && (t2 = this.input(), x.includes(t2) || (t2 = this.input())), x.includes(t2)) {
          if (t2 = this.input(), this.isDOC_MATCH(this.offset, true))
            return this.unput(1).popState(), this.appendToken(this.tok.T_END_HEREDOC, this.heredoc_label.length), this.tok.T_ENCAPSED_AND_WHITESPACE;
        } else if ("$" === t2) {
          if ("{" === (t2 = this.input()))
            return this.begin("ST_LOOKING_FOR_VARNAME"), this.yytext.length > 2 ? (this.appendToken(this.tok.T_DOLLAR_OPEN_CURLY_BRACES, 2), this.unput(2), this.tok.T_ENCAPSED_AND_WHITESPACE) : this.tok.T_DOLLAR_OPEN_CURLY_BRACES;
          if (this.is_LABEL_START()) {
            var e2 = this.offset, i2 = this.consume_VARIABLE();
            return this.yytext.length > this.offset - e2 + 2 ? (this.appendToken(i2, this.offset - e2 + 2), this.unput(this.offset - e2 + 2), this.tok.T_ENCAPSED_AND_WHITESPACE) : i2;
          }
        } else if ("{" === t2) {
          if ("$" === (t2 = this.input()))
            return this.begin("ST_IN_SCRIPTING"), this.yytext.length > 2 ? (this.appendToken(this.tok.T_CURLY_OPEN, 1), this.unput(2), this.tok.T_ENCAPSED_AND_WHITESPACE) : (this.unput(1), this.tok.T_CURLY_OPEN);
        } else
          t2 = this.input();
      return this.tok.T_ENCAPSED_AND_WHITESPACE;
    }, consume_VARIABLE: function() {
      this.consume_LABEL();
      var t2 = this.input();
      if ("[" == t2)
        return this.unput(1), this.begin("ST_VAR_OFFSET"), this.tok.T_VARIABLE;
      if ("-" === t2) {
        if (">" === this.input())
          return this.input(), this.is_LABEL_START() && this.begin("ST_LOOKING_FOR_PROPERTY"), this.unput(3), this.tok.T_VARIABLE;
        this.unput(2);
      } else
        t2 && this.unput(1);
      return this.tok.T_VARIABLE;
    }, matchST_BACKQUOTE: function() {
      var t2 = this.input();
      if ("$" === t2) {
        if ("{" === (t2 = this.input()))
          return this.begin("ST_LOOKING_FOR_VARNAME"), this.tok.T_DOLLAR_OPEN_CURLY_BRACES;
        if (this.is_LABEL_START())
          return this.consume_VARIABLE();
      } else if ("{" === t2) {
        if ("$" === this._input[this.offset])
          return this.begin("ST_IN_SCRIPTING"), this.tok.T_CURLY_OPEN;
      } else if ("`" === t2)
        return this.popState(), "`";
      for (; this.offset < this.size; ) {
        if ("\\" === t2)
          this.input();
        else {
          if ("`" === t2) {
            this.unput(1), this.popState(), this.appendToken("`", 1);
            break;
          }
          if ("$" === t2) {
            if ("{" === (t2 = this.input()))
              return this.begin("ST_LOOKING_FOR_VARNAME"), this.yytext.length > 2 ? (this.appendToken(this.tok.T_DOLLAR_OPEN_CURLY_BRACES, 2), this.unput(2), this.tok.T_ENCAPSED_AND_WHITESPACE) : this.tok.T_DOLLAR_OPEN_CURLY_BRACES;
            if (this.is_LABEL_START()) {
              var e2 = this.offset, i2 = this.consume_VARIABLE();
              return this.yytext.length > this.offset - e2 + 2 ? (this.appendToken(i2, this.offset - e2 + 2), this.unput(this.offset - e2 + 2), this.tok.T_ENCAPSED_AND_WHITESPACE) : i2;
            }
            continue;
          }
          if ("{" === t2) {
            if ("$" === (t2 = this.input()))
              return this.begin("ST_IN_SCRIPTING"), this.yytext.length > 2 ? (this.appendToken(this.tok.T_CURLY_OPEN, 1), this.unput(2), this.tok.T_ENCAPSED_AND_WHITESPACE) : (this.unput(1), this.tok.T_CURLY_OPEN);
            continue;
          }
        }
        t2 = this.input();
      }
      return this.tok.T_ENCAPSED_AND_WHITESPACE;
    }, matchST_DOUBLE_QUOTES: function() {
      var t2 = this.input();
      if ("$" === t2) {
        if ("{" === (t2 = this.input()))
          return this.begin("ST_LOOKING_FOR_VARNAME"), this.tok.T_DOLLAR_OPEN_CURLY_BRACES;
        if (this.is_LABEL_START())
          return this.consume_VARIABLE();
      } else if ("{" === t2) {
        if ("$" === this._input[this.offset])
          return this.begin("ST_IN_SCRIPTING"), this.tok.T_CURLY_OPEN;
      } else if ('"' === t2)
        return this.popState(), '"';
      for (; this.offset < this.size; ) {
        if ("\\" === t2)
          this.input();
        else {
          if ('"' === t2) {
            this.unput(1), this.popState(), this.appendToken('"', 1);
            break;
          }
          if ("$" === t2) {
            if ("{" === (t2 = this.input()))
              return this.begin("ST_LOOKING_FOR_VARNAME"), this.yytext.length > 2 ? (this.appendToken(this.tok.T_DOLLAR_OPEN_CURLY_BRACES, 2), this.unput(2), this.tok.T_ENCAPSED_AND_WHITESPACE) : this.tok.T_DOLLAR_OPEN_CURLY_BRACES;
            if (this.is_LABEL_START()) {
              var e2 = this.offset, i2 = this.consume_VARIABLE();
              return this.yytext.length > this.offset - e2 + 2 ? (this.appendToken(i2, this.offset - e2 + 2), this.unput(this.offset - e2 + 2), this.tok.T_ENCAPSED_AND_WHITESPACE) : i2;
            }
            t2 && this.unput(1);
          } else if ("{" === t2) {
            if ("$" === (t2 = this.input()))
              return this.begin("ST_IN_SCRIPTING"), this.yytext.length > 2 ? (this.appendToken(this.tok.T_CURLY_OPEN, 1), this.unput(2), this.tok.T_ENCAPSED_AND_WHITESPACE) : (this.unput(1), this.tok.T_CURLY_OPEN);
            t2 && this.unput(1);
          }
        }
        t2 = this.input();
      }
      return this.tok.T_ENCAPSED_AND_WHITESPACE;
    } };
    A.T_CONSTANT_ENCAPSED_STRING, A.is_HEREDOC, A.ST_DOUBLE_QUOTES, A.isDOC_MATCH, A.prematch_ENDOFDOC, A.matchST_NOWDOC, A.matchST_HEREDOC, A.consume_VARIABLE, A.matchST_BACKQUOTE, A.matchST_DOUBLE_QUOTES;
    var g2 = { T_STRING: function() {
      var t2 = this.yytext.toLowerCase(), e2 = this.keywords[t2];
      if ("number" != typeof e2) {
        if ("yield" === t2)
          this.version >= 700 && this.tryMatch(" from") ? (this.consume(5), e2 = this.tok.T_YIELD_FROM) : e2 = this.tok.T_YIELD;
        else if (e2 = this.tok.T_STRING, "b" === t2 || "B" === t2) {
          var i2 = this.input();
          if ('"' === i2)
            return this.ST_DOUBLE_QUOTES();
          if ("'" === i2)
            return this.T_CONSTANT_ENCAPSED_STRING();
          i2 && this.unput(1);
        }
      }
      if (e2 === this.tok.T_ENUM) {
        if (this.version < 801)
          return this.tok.T_STRING;
        for (var n2 = this.offset, s2 = this.input(); " " == s2; )
          s2 = this.input();
        var r2 = false;
        if (this.is_LABEL_START()) {
          for (; this.is_LABEL(); )
            s2 += this.input();
          var o2 = s2.slice(0, -1).toLowerCase();
          r2 = "extends" !== o2 && "implements" !== o2;
        }
        return this.unput(this.offset - n2), r2 ? this.tok.T_ENUM : this.tok.T_STRING;
      }
      if (this.offset < this.size && e2 !== this.tok.T_YIELD_FROM) {
        var a2 = this.input();
        if ("\\" === a2) {
          e2 = "namespace" === t2 ? this.tok.T_NAME_RELATIVE : this.tok.T_NAME_QUALIFIED;
          do {
            if ("{" === this._input[this.offset]) {
              this.input();
              break;
            }
            this.consume_LABEL(), a2 = this.input();
          } while ("\\" === a2);
        }
        a2 && this.unput(1);
      }
      return e2;
    }, consume_TOKEN: function() {
      var t2 = this._input[this.offset - 1], e2 = this.tokenTerminals[t2];
      return e2 ? e2.apply(this, []) : this.yytext;
    }, tokenTerminals: { $: function() {
      return this.offset++, this.is_LABEL_START() ? (this.offset--, this.consume_LABEL(), this.tok.T_VARIABLE) : (this.offset--, "$");
    }, "-": function() {
      var t2 = this._input[this.offset];
      return ">" === t2 ? (this.begin("ST_LOOKING_FOR_PROPERTY").input(), this.tok.T_OBJECT_OPERATOR) : "-" === t2 ? (this.input(), this.tok.T_DEC) : "=" === t2 ? (this.input(), this.tok.T_MINUS_EQUAL) : "-";
    }, "\\": function() {
      if (this.offset < this.size) {
        if (this.input(), this.is_LABEL_START()) {
          var t2;
          do {
            if ("{" === this._input[this.offset]) {
              this.input();
              break;
            }
            this.consume_LABEL(), t2 = this.input();
          } while ("\\" === t2);
          return this.unput(1), this.tok.T_NAME_FULLY_QUALIFIED;
        }
        this.unput(1);
      }
      return this.tok.T_NS_SEPARATOR;
    }, "/": function() {
      return "=" === this._input[this.offset] ? (this.input(), this.tok.T_DIV_EQUAL) : "/";
    }, ":": function() {
      return ":" === this._input[this.offset] ? (this.input(), this.tok.T_DOUBLE_COLON) : ":";
    }, "(": function() {
      var t2 = this.offset;
      if (this.input(), this.is_TABSPACE() && this.consume_TABSPACE().input(), this.is_LABEL_START()) {
        var e2 = this.yytext.length;
        this.consume_LABEL();
        var i2 = this.yytext.substring(e2 - 1).toLowerCase(), n2 = this.castKeywords[i2];
        if ("number" == typeof n2 && (this.input(), this.is_TABSPACE() && this.consume_TABSPACE().input(), ")" === this._input[this.offset - 1]))
          return n2;
      }
      return this.unput(this.offset - t2), "(";
    }, "=": function() {
      var t2 = this._input[this.offset];
      return ">" === t2 ? (this.input(), this.tok.T_DOUBLE_ARROW) : "=" === t2 ? "=" === this._input[this.offset + 1] ? (this.consume(2), this.tok.T_IS_IDENTICAL) : (this.input(), this.tok.T_IS_EQUAL) : "=";
    }, "+": function() {
      var t2 = this._input[this.offset];
      return "+" === t2 ? (this.input(), this.tok.T_INC) : "=" === t2 ? (this.input(), this.tok.T_PLUS_EQUAL) : "+";
    }, "!": function() {
      return "=" === this._input[this.offset] ? "=" === this._input[this.offset + 1] ? (this.consume(2), this.tok.T_IS_NOT_IDENTICAL) : (this.input(), this.tok.T_IS_NOT_EQUAL) : "!";
    }, "?": function() {
      return this.version >= 700 && "?" === this._input[this.offset] ? this.version >= 704 && "=" === this._input[this.offset + 1] ? (this.consume(2), this.tok.T_COALESCE_EQUAL) : (this.input(), this.tok.T_COALESCE) : this.version >= 800 && "-" === this._input[this.offset] && ">" === this._input[this.offset + 1] ? (this.consume(2), this.tok.T_NULLSAFE_OBJECT_OPERATOR) : "?";
    }, "<": function() {
      var t2 = this._input[this.offset];
      return "<" === t2 ? "=" === (t2 = this._input[this.offset + 1]) ? (this.consume(2), this.tok.T_SL_EQUAL) : "<" === t2 && this.is_HEREDOC() ? this.tok.T_START_HEREDOC : (this.input(), this.tok.T_SL) : "=" === t2 ? (this.input(), this.version >= 700 && ">" === this._input[this.offset] ? (this.input(), this.tok.T_SPACESHIP) : this.tok.T_IS_SMALLER_OR_EQUAL) : ">" === t2 ? (this.input(), this.tok.T_IS_NOT_EQUAL) : "<";
    }, ">": function() {
      var t2 = this._input[this.offset];
      return "=" === t2 ? (this.input(), this.tok.T_IS_GREATER_OR_EQUAL) : ">" === t2 ? "=" === (t2 = this._input[this.offset + 1]) ? (this.consume(2), this.tok.T_SR_EQUAL) : (this.input(), this.tok.T_SR) : ">";
    }, "*": function() {
      var t2 = this._input[this.offset];
      return "=" === t2 ? (this.input(), this.tok.T_MUL_EQUAL) : "*" === t2 ? (this.input(), "=" === this._input[this.offset] ? (this.input(), this.tok.T_POW_EQUAL) : this.tok.T_POW) : "*";
    }, ".": function() {
      var t2 = this._input[this.offset];
      return "=" === t2 ? (this.input(), this.tok.T_CONCAT_EQUAL) : "." === t2 && "." === this._input[this.offset + 1] ? (this.consume(2), this.tok.T_ELLIPSIS) : ".";
    }, "%": function() {
      return "=" === this._input[this.offset] ? (this.input(), this.tok.T_MOD_EQUAL) : "%";
    }, "&": function() {
      var t2 = this._input[this.offset];
      return "=" === t2 ? (this.input(), this.tok.T_AND_EQUAL) : "&" === t2 ? (this.input(), this.tok.T_BOOLEAN_AND) : "&";
    }, "|": function() {
      var t2 = this._input[this.offset];
      return "=" === t2 ? (this.input(), this.tok.T_OR_EQUAL) : "|" === t2 ? (this.input(), this.tok.T_BOOLEAN_OR) : "|";
    }, "^": function() {
      return "=" === this._input[this.offset] ? (this.input(), this.tok.T_XOR_EQUAL) : "^";
    } } };
    g2.T_STRING, g2.consume_TOKEN, g2.tokenTerminals;
    var N2 = { is_NUM: function() {
      var t2 = this._input.charCodeAt(this.offset - 1);
      return t2 > 47 && t2 < 58 || 95 === t2;
    }, is_NUM_START: function() {
      var t2 = this._input.charCodeAt(this.offset - 1);
      return t2 > 47 && t2 < 58;
    }, is_LABEL: function() {
      var t2 = this._input.charCodeAt(this.offset - 1);
      return t2 > 96 && t2 < 123 || t2 > 64 && t2 < 91 || 95 === t2 || t2 > 47 && t2 < 58 || t2 > 126;
    }, is_LABEL_START: function() {
      var t2 = this._input.charCodeAt(this.offset - 1);
      return t2 > 64 && t2 < 91 || (t2 > 96 && t2 < 123 || (95 === t2 || t2 > 126));
    }, consume_LABEL: function() {
      for (; this.offset < this.size; ) {
        var t2 = this.input();
        if (!this.is_LABEL()) {
          t2 && this.unput(1);
          break;
        }
      }
      return this;
    }, is_TOKEN: function() {
      var t2 = this._input[this.offset - 1];
      return -1 !== ";:,.\\[]()|^&+-/*=%!~$<>?@".indexOf(t2);
    }, is_WHITESPACE: function() {
      var t2 = this._input[this.offset - 1];
      return " " === t2 || "	" === t2 || "\n" === t2 || "\r" === t2;
    }, is_TABSPACE: function() {
      var t2 = this._input[this.offset - 1];
      return " " === t2 || "	" === t2;
    }, consume_TABSPACE: function() {
      for (; this.offset < this.size; ) {
        var t2 = this.input();
        if (!this.is_TABSPACE()) {
          t2 && this.unput(1);
          break;
        }
      }
      return this;
    }, is_HEX: function() {
      var t2 = this._input.charCodeAt(this.offset - 1);
      return t2 > 47 && t2 < 58 || (t2 > 64 && t2 < 71 || (t2 > 96 && t2 < 103 || 95 === t2));
    }, is_OCTAL: function() {
      var t2 = this._input.charCodeAt(this.offset - 1);
      return t2 > 47 && t2 < 56 || 95 === t2;
    } };
    N2.is_NUM, N2.is_NUM_START, N2.is_LABEL, N2.is_LABEL_START, N2.consume_LABEL, N2.is_TOKEN, N2.is_WHITESPACE, N2.is_TABSPACE, N2.consume_TABSPACE, N2.is_HEX, N2.is_OCTAL;
    var L = function(t2) {
      this.engine = t2, this.tok = this.engine.tokens.names, this.EOF = 1, this.debug = false, this.all_tokens = true, this.comment_tokens = false, this.mode_eval = false, this.asp_tags = false, this.short_tags = false, this.version = 801, this.yyprevcol = 0, this.keywords = { __class__: this.tok.T_CLASS_C, __trait__: this.tok.T_TRAIT_C, __function__: this.tok.T_FUNC_C, __method__: this.tok.T_METHOD_C, __line__: this.tok.T_LINE, __file__: this.tok.T_FILE, __dir__: this.tok.T_DIR, __namespace__: this.tok.T_NS_C, exit: this.tok.T_EXIT, die: this.tok.T_EXIT, function: this.tok.T_FUNCTION, const: this.tok.T_CONST, return: this.tok.T_RETURN, try: this.tok.T_TRY, catch: this.tok.T_CATCH, finally: this.tok.T_FINALLY, throw: this.tok.T_THROW, if: this.tok.T_IF, elseif: this.tok.T_ELSEIF, endif: this.tok.T_ENDIF, else: this.tok.T_ELSE, while: this.tok.T_WHILE, endwhile: this.tok.T_ENDWHILE, do: this.tok.T_DO, for: this.tok.T_FOR, endfor: this.tok.T_ENDFOR, foreach: this.tok.T_FOREACH, endforeach: this.tok.T_ENDFOREACH, declare: this.tok.T_DECLARE, enddeclare: this.tok.T_ENDDECLARE, instanceof: this.tok.T_INSTANCEOF, as: this.tok.T_AS, switch: this.tok.T_SWITCH, endswitch: this.tok.T_ENDSWITCH, case: this.tok.T_CASE, default: this.tok.T_DEFAULT, break: this.tok.T_BREAK, continue: this.tok.T_CONTINUE, goto: this.tok.T_GOTO, echo: this.tok.T_ECHO, print: this.tok.T_PRINT, class: this.tok.T_CLASS, interface: this.tok.T_INTERFACE, trait: this.tok.T_TRAIT, enum: this.tok.T_ENUM, extends: this.tok.T_EXTENDS, implements: this.tok.T_IMPLEMENTS, new: this.tok.T_NEW, clone: this.tok.T_CLONE, var: this.tok.T_VAR, eval: this.tok.T_EVAL, include: this.tok.T_INCLUDE, include_once: this.tok.T_INCLUDE_ONCE, require: this.tok.T_REQUIRE, require_once: this.tok.T_REQUIRE_ONCE, namespace: this.tok.T_NAMESPACE, use: this.tok.T_USE, insteadof: this.tok.T_INSTEADOF, global: this.tok.T_GLOBAL, isset: this.tok.T_ISSET, empty: this.tok.T_EMPTY, __halt_compiler: this.tok.T_HALT_COMPILER, static: this.tok.T_STATIC, abstract: this.tok.T_ABSTRACT, final: this.tok.T_FINAL, private: this.tok.T_PRIVATE, protected: this.tok.T_PROTECTED, public: this.tok.T_PUBLIC, unset: this.tok.T_UNSET, list: this.tok.T_LIST, array: this.tok.T_ARRAY, callable: this.tok.T_CALLABLE, or: this.tok.T_LOGICAL_OR, and: this.tok.T_LOGICAL_AND, xor: this.tok.T_LOGICAL_XOR, match: this.tok.T_MATCH, readonly: this.tok.T_READ_ONLY }, this.castKeywords = { int: this.tok.T_INT_CAST, integer: this.tok.T_INT_CAST, real: this.tok.T_DOUBLE_CAST, double: this.tok.T_DOUBLE_CAST, float: this.tok.T_DOUBLE_CAST, string: this.tok.T_STRING_CAST, binary: this.tok.T_STRING_CAST, array: this.tok.T_ARRAY_CAST, object: this.tok.T_OBJECT_CAST, bool: this.tok.T_BOOL_CAST, boolean: this.tok.T_BOOL_CAST, unset: this.tok.T_UNSET_CAST };
    };
    L.prototype.setInput = function(t2) {
      return this._input = t2, this.size = t2.length, this.yylineno = 1, this.offset = 0, this.yyprevcol = 0, this.yytext = "", this.yylloc = { first_offset: 0, first_line: 1, first_column: 0, prev_offset: 0, prev_line: 1, prev_column: 0, last_line: 1, last_column: 0 }, this.tokens = [], this.version > 703 ? this.keywords.fn = this.tok.T_FN : delete this.keywords.fn, this.done = this.offset >= this.size, !this.all_tokens && this.mode_eval ? (this.conditionStack = ["INITIAL"], this.begin("ST_IN_SCRIPTING")) : (this.conditionStack = [], this.begin("INITIAL")), this.heredoc_label = { label: "", length: 0, indentation: 0, indentation_uses_spaces: false, finished: false, first_encaps_node: false, toString: function() {
        this.label;
      } }, this;
    }, L.prototype.input = function() {
      var t2 = this._input[this.offset];
      return t2 ? (this.yytext += t2, this.offset++, "\r" === t2 && "\n" === this._input[this.offset] && (this.yytext += "\n", this.offset++), "\n" === t2 || "\r" === t2 ? (this.yylloc.last_line = ++this.yylineno, this.yyprevcol = this.yylloc.last_column, this.yylloc.last_column = 0) : this.yylloc.last_column++, t2) : "";
    }, L.prototype.unput = function(t2) {
      if (1 === t2)
        this.offset--, "\n" === this._input[this.offset] && "\r" === this._input[this.offset - 1] && (this.offset--, t2++), "\r" === this._input[this.offset] || "\n" === this._input[this.offset] ? (this.yylloc.last_line--, this.yylineno--, this.yylloc.last_column = this.yyprevcol) : this.yylloc.last_column--, this.yytext = this.yytext.substring(0, this.yytext.length - t2);
      else if (t2 > 0)
        if (this.offset -= t2, t2 < this.yytext.length) {
          this.yytext = this.yytext.substring(0, this.yytext.length - t2), this.yylloc.last_line = this.yylloc.first_line, this.yylloc.last_column = this.yyprevcol = this.yylloc.first_column;
          for (var e2 = 0; e2 < this.yytext.length; e2++) {
            var i2 = this.yytext[e2];
            "\r" === i2 ? (i2 = this.yytext[++e2], this.yyprevcol = this.yylloc.last_column, this.yylloc.last_line++, this.yylloc.last_column = 0, "\n" !== i2 && ("\r" === i2 ? this.yylloc.last_line++ : this.yylloc.last_column++)) : "\n" === i2 ? (this.yyprevcol = this.yylloc.last_column, this.yylloc.last_line++, this.yylloc.last_column = 0) : this.yylloc.last_column++;
          }
          this.yylineno = this.yylloc.last_line;
        } else
          this.yytext = "", this.yylloc.last_line = this.yylineno = this.yylloc.first_line, this.yylloc.last_column = this.yylloc.first_column;
      return this;
    }, L.prototype.tryMatch = function(t2) {
      return t2 === this.ahead(t2.length);
    }, L.prototype.tryMatchCaseless = function(t2) {
      return t2 === this.ahead(t2.length).toLowerCase();
    }, L.prototype.ahead = function(t2) {
      var e2 = this._input.substring(this.offset, this.offset + t2);
      return "\r" === e2[e2.length - 1] && "\n" === this._input[this.offset + t2 + 1] && (e2 += "\n"), e2;
    }, L.prototype.consume = function(t2) {
      for (var e2 = 0; e2 < t2; e2++) {
        var i2 = this._input[this.offset];
        if (!i2)
          break;
        this.yytext += i2, this.offset++, "\r" === i2 && "\n" === this._input[this.offset] && (this.yytext += "\n", this.offset++, e2++), "\n" === i2 || "\r" === i2 ? (this.yylloc.last_line = ++this.yylineno, this.yyprevcol = this.yylloc.last_column, this.yylloc.last_column = 0) : this.yylloc.last_column++;
      }
      return this;
    }, L.prototype.getState = function() {
      return { yytext: this.yytext, offset: this.offset, yylineno: this.yylineno, yyprevcol: this.yyprevcol, yylloc: { first_offset: this.yylloc.first_offset, first_line: this.yylloc.first_line, first_column: this.yylloc.first_column, last_line: this.yylloc.last_line, last_column: this.yylloc.last_column }, heredoc_label: this.heredoc_label };
    }, L.prototype.setState = function(t2) {
      return this.yytext = t2.yytext, this.offset = t2.offset, this.yylineno = t2.yylineno, this.yyprevcol = t2.yyprevcol, this.yylloc = t2.yylloc, t2.heredoc_label && (this.heredoc_label = t2.heredoc_label), this;
    }, L.prototype.appendToken = function(t2, e2) {
      return this.tokens.push([t2, e2]), this;
    }, L.prototype.lex = function() {
      this.yylloc.prev_offset = this.offset, this.yylloc.prev_line = this.yylloc.last_line, this.yylloc.prev_column = this.yylloc.last_column;
      var t2 = this.next() || this.lex();
      if (!this.all_tokens) {
        for (; t2 === this.tok.T_WHITESPACE || !this.comment_tokens && (t2 === this.tok.T_COMMENT || t2 === this.tok.T_DOC_COMMENT) || t2 === this.tok.T_OPEN_TAG; )
          t2 = this.next() || this.lex();
        if (t2 == this.tok.T_OPEN_TAG_WITH_ECHO)
          return this.tok.T_ECHO;
        if (t2 === this.tok.T_CLOSE_TAG)
          return ";";
      }
      return this.yylloc.prev_offset || (this.yylloc.prev_offset = this.yylloc.first_offset, this.yylloc.prev_line = this.yylloc.first_line, this.yylloc.prev_column = this.yylloc.first_column), t2;
    }, L.prototype.begin = function(t2) {
      if (this.conditionStack.push(t2), this.curCondition = t2, this.stateCb = this["match" + t2], "function" != typeof this.stateCb)
        throw new Error('Undefined condition state "' + t2 + '"');
      return this;
    }, L.prototype.popState = function() {
      var t2 = this.conditionStack.length - 1 > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      if (this.curCondition = this.conditionStack[this.conditionStack.length - 1], this.stateCb = this["match" + this.curCondition], "function" != typeof this.stateCb)
        throw new Error('Undefined condition state "' + this.curCondition + '"');
      return t2;
    }, L.prototype.next = function() {
      var t2;
      if (this._input || (this.done = true), this.yylloc.first_offset = this.offset, this.yylloc.first_line = this.yylloc.last_line, this.yylloc.first_column = this.yylloc.last_column, this.yytext = "", this.done)
        return this.yylloc.prev_offset = this.yylloc.first_offset, this.yylloc.prev_line = this.yylloc.first_line, this.yylloc.prev_column = this.yylloc.first_column, this.EOF;
      if (this.tokens.length > 0 ? ("object" === a((t2 = this.tokens.shift())[1]) ? this.setState(t2[1]) : this.consume(t2[1]), t2 = t2[0]) : t2 = this.stateCb.apply(this, []), this.offset >= this.size && 0 === this.tokens.length && (this.done = true), this.debug) {
        var e2 = t2;
        e2 = "number" == typeof e2 ? this.engine.tokens.values[e2] : '"' + e2 + '"';
        var i2 = new Error(e2 + "	from " + this.yylloc.first_line + "," + this.yylloc.first_column + "	 - to " + this.yylloc.last_line + "," + this.yylloc.last_column + '	"' + this.yytext + '"');
        console.error(i2.stack);
      }
      return t2;
    }, [p, f, T, k, E, m, A, g2, N2].forEach(function(t2) {
      for (var e2 in t2)
        L.prototype[e2] = t2[e2];
    });
    var C = L, b = function(t2, e2, i2) {
      this.line = t2, this.column = e2, this.offset = i2;
    }, I2 = { read_array: function() {
      var t2 = null, e2 = false, i2 = this.node("array");
      this.token === this.tok.T_ARRAY ? (this.next().expect("("), t2 = ")") : (e2 = true, t2 = "]");
      var n2 = [];
      return this.next().token !== t2 && (n2 = this.read_array_pair_list(e2)), this.expect(t2), this.next(), i2(e2, n2);
    }, read_array_pair_list: function(t2) {
      var e2 = this;
      return this.read_list(function() {
        return e2.read_array_pair(t2);
      }, ",", true);
    }, read_array_pair: function(t2) {
      if (!(!t2 && ")" === this.token || t2 && "]" === this.token)) {
        if ("," === this.token)
          return this.node("noop")();
        var e2 = this.node("entry"), i2 = null, n2 = null, s2 = false, r2 = false;
        if ("&" === this.token)
          this.next(), s2 = true, n2 = this.read_variable(true, false);
        else if (this.token === this.tok.T_ELLIPSIS && this.version >= 704)
          this.next(), "&" === this.token && this.error(), r2 = true, n2 = this.read_expr();
        else {
          var o2 = this.read_expr();
          this.token === this.tok.T_DOUBLE_ARROW ? (this.next(), i2 = o2, "&" === this.token ? (this.next(), s2 = true, n2 = this.read_variable(true, false)) : n2 = this.read_expr()) : n2 = o2;
        }
        return e2(i2, n2, s2, r2);
      }
    } };
    I2.read_array, I2.read_array_pair_list, I2.read_array_pair;
    var S = { read_class_declaration_statement: function(t2) {
      var e2 = this.node("class"), i2 = this.read_class_modifiers();
      if (this.token !== this.tok.T_CLASS)
        return this.error(this.tok.T_CLASS), this.next(), null;
      this.next().expect(this.tok.T_STRING);
      var n2 = this.node("identifier"), s2 = this.text();
      this.next(), n2 = n2(s2);
      var r2 = this.read_extends_from(), o2 = this.read_implements_list();
      this.expect("{");
      var a2 = e2(n2, r2, o2, this.next().read_class_body(true, false), i2);
      return t2 && (a2.attrGroups = t2), a2;
    }, read_class_modifiers: function() {
      return [0, 0, this.read_class_modifier()];
    }, read_class_modifier: function() {
      return this.token === this.tok.T_ABSTRACT ? (this.next(), 1) : this.token === this.tok.T_FINAL ? (this.next(), 2) : 0;
    }, read_class_body: function(t2, e2) {
      for (var i2 = [], n2 = []; this.token !== this.EOF && "}" !== this.token; )
        if (this.token !== this.tok.T_COMMENT)
          if (this.token !== this.tok.T_DOC_COMMENT)
            if (this.token !== this.tok.T_USE)
              if (e2 && this.token === this.tok.T_CASE) {
                var s2 = this.read_enum_case();
                this.expect(";") && this.next(), i2 = i2.concat(s2);
              } else {
                this.token === this.tok.T_ATTRIBUTE && (n2 = this.read_attr_list());
                var r2 = this.position(), o2 = this.read_member_flags(false);
                if (this.token !== this.tok.T_CONST)
                  if (t2 && this.token === this.tok.T_VAR && (this.next().expect(this.tok.T_VARIABLE), o2[0] = null, o2[1] = 0), this.token === this.tok.T_FUNCTION)
                    i2.push(this.read_function(false, o2, n2, r2)), n2 = [];
                  else if (t2 && (this.token === this.tok.T_VARIABLE || this.version >= 801 && this.token === this.tok.T_READ_ONLY || this.version >= 704 && ("?" === this.token || this.token === this.tok.T_ARRAY || this.token === this.tok.T_CALLABLE || this.token === this.tok.T_NAMESPACE || this.token === this.tok.T_NAME_FULLY_QUALIFIED || this.token === this.tok.T_NAME_QUALIFIED || this.token === this.tok.T_NAME_RELATIVE || this.token === this.tok.T_NS_SEPARATOR || this.token === this.tok.T_STRING))) {
                    var a2 = this.read_variable_list(o2, n2);
                    n2 = [], this.expect(";"), this.next(), i2 = i2.concat(a2);
                  } else
                    this.error([this.tok.T_CONST].concat(c(t2 ? [this.tok.T_VARIABLE] : []), c(e2 ? [this.tok.T_CASE] : []), [this.tok.T_FUNCTION])), this.next();
                else {
                  var h2 = this.read_constant_list(o2, n2);
                  this.expect(";") && this.next(), i2 = i2.concat(h2);
                }
              }
            else
              i2 = i2.concat(this.read_trait_use_statement());
          else
            i2.push(this.read_doc_comment());
        else
          i2.push(this.read_comment());
      return this.expect("}"), this.next(), i2;
    }, read_variable_list: function(t2, e2) {
      var i2 = this.node("propertystatement"), n2 = this.read_list(function() {
        var t3 = this.node("property"), i3 = false;
        this.token === this.tok.T_READ_ONLY && (i3 = true, this.next());
        var n3 = l(this.read_optional_type(), 2), s2 = n3[0], r2 = n3[1];
        this.expect(this.tok.T_VARIABLE);
        var o2 = this.node("identifier"), a2 = this.text().substring(1);
        return this.next(), o2 = o2(a2), ";" === this.token || "," === this.token ? t3(o2, null, i3, s2, r2, e2 || []) : "=" === this.token ? t3(o2, this.next().read_expr(), i3, s2, r2, e2 || []) : (this.expect([",", ";", "="]), t3(o2, null, s2, r2, e2 || []));
      }, ",");
      return i2(null, n2, t2);
    }, read_constant_list: function(t2, e2) {
      this.expect(this.tok.T_CONST) && this.next();
      var i2 = this.node("classconstant"), n2 = this.read_list(function() {
        var t3 = this.node("constant"), e3 = null, i3 = null;
        if (this.token === this.tok.T_STRING || this.version >= 700 && this.is("IDENTIFIER")) {
          e3 = this.node("identifier");
          var n3 = this.text();
          this.next(), e3 = e3(n3);
        } else
          this.expect("IDENTIFIER");
        return this.expect("=") && (i3 = this.next().read_expr()), t3(e3, i3);
      }, ",");
      return i2(null, n2, t2, e2 || []);
    }, read_member_flags: function(t2) {
      var e2 = [-1, -1, -1];
      if (this.is("T_MEMBER_FLAGS")) {
        var i2 = 0, n2 = 0;
        do {
          switch (this.token) {
            case this.tok.T_PUBLIC:
              i2 = 0, n2 = 0;
              break;
            case this.tok.T_PROTECTED:
              i2 = 0, n2 = 1;
              break;
            case this.tok.T_PRIVATE:
              i2 = 0, n2 = 2;
              break;
            case this.tok.T_STATIC:
              i2 = 1, n2 = 1;
              break;
            case this.tok.T_ABSTRACT:
              i2 = 2, n2 = 1;
              break;
            case this.tok.T_FINAL:
              i2 = 2, n2 = 2;
          }
          t2 && (0 == i2 && 2 == n2 ? (this.expect([this.tok.T_PUBLIC, this.tok.T_PROTECTED]), n2 = -1) : 2 == i2 && 1 == n2 && (this.error(), n2 = -1)), -1 !== e2[i2] ? this.error() : -1 !== n2 && (e2[i2] = n2);
        } while (this.next().is("T_MEMBER_FLAGS"));
      }
      return -1 == e2[1] && (e2[1] = 0), -1 == e2[2] && (e2[2] = 0), e2;
    }, read_optional_type: function() {
      var t2 = false;
      "?" === this.token && (t2 = true, this.next());
      var e2 = this.read_types();
      if (t2 && !e2 && this.raiseError("Expecting a type definition combined with nullable operator"), !t2 && !e2)
        return [false, null];
      if ("|" === this.token) {
        e2 = [e2];
        do {
          this.next();
          var i2 = this.read_type();
          if (!i2) {
            this.raiseError("Expecting a type definition");
            break;
          }
          e2.push(i2);
        } while ("|" === this.token);
      }
      return [t2, e2];
    }, read_interface_declaration_statement: function(t2) {
      var e2 = this.node("interface");
      if (this.token !== this.tok.T_INTERFACE)
        return this.error(this.tok.T_INTERFACE), this.next(), null;
      this.next().expect(this.tok.T_STRING);
      var i2 = this.node("identifier"), n2 = this.text();
      this.next(), i2 = i2(n2);
      var s2 = this.read_interface_extends_list();
      return this.expect("{"), e2(i2, s2, this.next().read_interface_body(), t2 || []);
    }, read_interface_body: function() {
      for (var t2 = [], e2 = []; this.token !== this.EOF && "}" !== this.token; )
        if (this.token !== this.tok.T_COMMENT)
          if (this.token !== this.tok.T_DOC_COMMENT) {
            var i2 = this.position();
            e2 = this.read_attr_list();
            var n2 = this.read_member_flags(true);
            if (this.token == this.tok.T_CONST) {
              var s2 = this.read_constant_list(n2, e2);
              this.expect(";") && this.next(), t2 = t2.concat(s2), e2 = [];
            } else if (this.token === this.tok.T_FUNCTION) {
              var r2 = this.read_function_declaration(2, n2, e2, i2);
              r2.parseFlags(n2), t2.push(r2), this.expect(";") && this.next(), e2 = [];
            } else
              this.error([this.tok.T_CONST, this.tok.T_FUNCTION]), this.next();
          } else
            t2.push(this.read_doc_comment());
        else
          t2.push(this.read_comment());
      return this.expect("}") && this.next(), t2;
    }, read_trait_declaration_statement: function() {
      var t2 = this.node("trait");
      if (this.token !== this.tok.T_TRAIT)
        return this.error(this.tok.T_TRAIT), this.next(), null;
      this.next().expect(this.tok.T_STRING);
      var e2 = this.node("identifier"), i2 = this.text();
      return this.next(), e2 = e2(i2), this.expect("{"), t2(e2, this.next().read_class_body(true, false));
    }, read_trait_use_statement: function() {
      var t2 = this.node("traituse");
      this.expect(this.tok.T_USE) && this.next();
      for (var e2 = [this.read_namespace_name()], i2 = null; "," === this.token; )
        e2.push(this.next().read_namespace_name());
      if ("{" === this.token) {
        for (i2 = []; this.next().token !== this.EOF && "}" !== this.token; )
          i2.push(this.read_trait_use_alias()), this.expect(";");
        this.expect("}") && this.next();
      } else
        this.expect(";") && this.next();
      return t2(e2, i2);
    }, read_trait_use_alias: function() {
      var t2, e2 = this.node(), i2 = null;
      if (this.is("IDENTIFIER")) {
        t2 = this.node("identifier");
        var n2 = this.text();
        this.next(), t2 = t2(n2);
      } else if (t2 = this.read_namespace_name(), this.token === this.tok.T_DOUBLE_COLON)
        if (this.next(), this.token === this.tok.T_STRING || this.version >= 700 && this.is("IDENTIFIER")) {
          i2 = t2, t2 = this.node("identifier");
          var s2 = this.text();
          this.next(), t2 = t2(s2);
        } else
          this.expect(this.tok.T_STRING);
      else
        t2 = t2.name;
      if (this.token === this.tok.T_INSTEADOF)
        return e2("traitprecedence", i2, t2, this.next().read_name_list());
      if (this.token === this.tok.T_AS) {
        var r2 = null, o2 = null;
        if (this.next().is("T_MEMBER_FLAGS") && (r2 = this.read_member_flags()), this.token === this.tok.T_STRING || this.version >= 700 && this.is("IDENTIFIER")) {
          o2 = this.node("identifier");
          var a2 = this.text();
          this.next(), o2 = o2(a2);
        } else
          false === r2 && this.expect(this.tok.T_STRING);
        return e2("traitalias", i2, t2, o2, r2);
      }
      return this.expect([this.tok.T_AS, this.tok.T_INSTEADOF]), e2("traitalias", i2, t2, null, null);
    } };
    S.read_class_declaration_statement, S.read_class_modifiers, S.read_class_modifier, S.read_class_body, S.read_variable_list, S.read_constant_list, S.read_member_flags, S.read_optional_type, S.read_interface_declaration_statement, S.read_interface_body, S.read_trait_declaration_statement, S.read_trait_use_statement, S.read_trait_use_alias;
    var O = { read_comment: function() {
      var t2 = this.text(), e2 = this.ast.prepare("/*" === t2.substring(0, 2) ? "commentblock" : "commentline", null, this), i2 = this.lexer.yylloc.first_offset, n2 = this.prev;
      return this.prev = [this.lexer.yylloc.last_line, this.lexer.yylloc.last_column, this.lexer.offset], this.lex(), (e2 = e2(t2)).offset = i2, this.prev = n2, e2;
    }, read_doc_comment: function() {
      var t2 = this.ast.prepare("commentblock", null, this), e2 = this.lexer.yylloc.first_offset, i2 = this.text(), n2 = this.prev;
      return this.prev = [this.lexer.yylloc.last_line, this.lexer.yylloc.last_column, this.lexer.offset], this.lex(), (t2 = t2(i2)).offset = e2, this.prev = n2, t2;
    } };
    O.read_comment, O.read_doc_comment;
    var R2 = { read_expr: function(t2) {
      var e2 = this.node();
      if ("@" === this.token)
        return t2 || (t2 = this.next().read_expr()), e2("silent", t2);
      if (t2 || (t2 = this.read_expr_item()), "|" === this.token)
        return e2("bin", "|", t2, this.next().read_expr());
      if ("&" === this.token)
        return e2("bin", "&", t2, this.next().read_expr());
      if ("^" === this.token)
        return e2("bin", "^", t2, this.next().read_expr());
      if ("." === this.token)
        return e2("bin", ".", t2, this.next().read_expr());
      if ("+" === this.token)
        return e2("bin", "+", t2, this.next().read_expr());
      if ("-" === this.token)
        return e2("bin", "-", t2, this.next().read_expr());
      if ("*" === this.token)
        return e2("bin", "*", t2, this.next().read_expr());
      if ("/" === this.token)
        return e2("bin", "/", t2, this.next().read_expr());
      if ("%" === this.token)
        return e2("bin", "%", t2, this.next().read_expr());
      if (this.token === this.tok.T_POW)
        return e2("bin", "**", t2, this.next().read_expr());
      if (this.token === this.tok.T_SL)
        return e2("bin", "<<", t2, this.next().read_expr());
      if (this.token === this.tok.T_SR)
        return e2("bin", ">>", t2, this.next().read_expr());
      if (this.token === this.tok.T_BOOLEAN_OR)
        return e2("bin", "||", t2, this.next().read_expr());
      if (this.token === this.tok.T_LOGICAL_OR)
        return e2("bin", "or", t2, this.next().read_expr());
      if (this.token === this.tok.T_BOOLEAN_AND)
        return e2("bin", "&&", t2, this.next().read_expr());
      if (this.token === this.tok.T_LOGICAL_AND)
        return e2("bin", "and", t2, this.next().read_expr());
      if (this.token === this.tok.T_LOGICAL_XOR)
        return e2("bin", "xor", t2, this.next().read_expr());
      if (this.token === this.tok.T_IS_IDENTICAL)
        return e2("bin", "===", t2, this.next().read_expr());
      if (this.token === this.tok.T_IS_NOT_IDENTICAL)
        return e2("bin", "!==", t2, this.next().read_expr());
      if (this.token === this.tok.T_IS_EQUAL)
        return e2("bin", "==", t2, this.next().read_expr());
      if (this.token === this.tok.T_IS_NOT_EQUAL)
        return e2("bin", "!=", t2, this.next().read_expr());
      if ("<" === this.token)
        return e2("bin", "<", t2, this.next().read_expr());
      if (">" === this.token)
        return e2("bin", ">", t2, this.next().read_expr());
      if (this.token === this.tok.T_IS_SMALLER_OR_EQUAL)
        return e2("bin", "<=", t2, this.next().read_expr());
      if (this.token === this.tok.T_IS_GREATER_OR_EQUAL)
        return e2("bin", ">=", t2, this.next().read_expr());
      if (this.token === this.tok.T_SPACESHIP)
        return e2("bin", "<=>", t2, this.next().read_expr());
      if (this.token === this.tok.T_INSTANCEOF && (t2 = e2("bin", "instanceof", t2, this.next().read_class_name_reference()), ";" !== this.token && this.token !== this.tok.T_INLINE_HTML && this.token !== this.EOF && (t2 = this.read_expr(t2))), this.token === this.tok.T_COALESCE)
        return e2("bin", "??", t2, this.next().read_expr());
      if ("?" === this.token) {
        var i2 = null;
        return ":" !== this.next().token && (i2 = this.read_expr()), this.expect(":") && this.next(), e2("retif", t2, i2, this.read_expr());
      }
      return e2.destroy(t2), t2;
    }, read_expr_cast: function(t2) {
      return this.node("cast")(t2, this.text(), this.next().read_expr());
    }, read_isset_variable: function() {
      return this.read_expr();
    }, read_isset_variables: function() {
      return this.read_function_list(this.read_isset_variable, ",");
    }, read_internal_functions_in_yacc: function() {
      var t2 = null;
      switch (this.token) {
        case this.tok.T_ISSET:
          t2 = this.node("isset"), this.next().expect("(") && this.next();
          var e2 = this.read_isset_variables();
          this.expect(")") && this.next(), t2 = t2(e2);
          break;
        case this.tok.T_EMPTY:
          t2 = this.node("empty"), this.next().expect("(") && this.next();
          var i2 = this.read_expr();
          this.expect(")") && this.next(), t2 = t2(i2);
          break;
        case this.tok.T_INCLUDE:
          t2 = this.node("include")(false, false, this.next().read_expr());
          break;
        case this.tok.T_INCLUDE_ONCE:
          t2 = this.node("include")(true, false, this.next().read_expr());
          break;
        case this.tok.T_EVAL:
          t2 = this.node("eval"), this.next().expect("(") && this.next();
          var n2 = this.read_expr();
          this.expect(")") && this.next(), t2 = t2(n2);
          break;
        case this.tok.T_REQUIRE:
          t2 = this.node("include")(false, true, this.next().read_expr());
          break;
        case this.tok.T_REQUIRE_ONCE:
          t2 = this.node("include")(true, true, this.next().read_expr());
      }
      return t2;
    }, read_optional_expr: function(t2) {
      return this.token !== t2 ? this.read_expr() : null;
    }, read_exit_expr: function() {
      var t2 = null;
      return "(" === this.token && (this.next(), t2 = this.read_optional_expr(")"), this.expect(")") && this.next()), t2;
    }, read_expr_item: function() {
      var t2, e2, i2 = [];
      if ("+" === this.token)
        return this.node("unary")("+", this.next().read_expr());
      if ("-" === this.token)
        return this.node("unary")("-", this.next().read_expr());
      if ("!" === this.token)
        return this.node("unary")("!", this.next().read_expr());
      if ("~" === this.token)
        return this.node("unary")("~", this.next().read_expr());
      if ("(" === this.token)
        return (e2 = this.next().read_expr()).parenthesizedExpression = true, this.expect(")") && this.next(), this.handleDereferencable(e2);
      if ("`" === this.token)
        return this.read_encapsed_string("`");
      if (this.token === this.tok.T_LIST) {
        var n2 = null, s2 = this.innerList;
        t2 = this.node("list"), s2 || (n2 = this.node("assign")), this.next().expect("(") && this.next(), this.innerList || (this.innerList = true);
        var r2 = this.read_array_pair_list(false);
        this.expect(")") && this.next();
        for (var o2 = false, a2 = 0; a2 < r2.length; a2++)
          if (null !== r2[a2] && "noop" !== r2[a2].kind) {
            o2 = true;
            break;
          }
        return o2 || this.raiseError("Fatal Error :  Cannot use empty list on line " + this.lexer.yylloc.first_line), s2 ? t2(r2, false) : (this.innerList = false, this.expect("=") ? n2(t2(r2, false), this.next().read_expr(), "=") : t2(r2, false));
      }
      if (this.token === this.tok.T_ATTRIBUTE && (i2 = this.read_attr_list()), this.token === this.tok.T_CLONE)
        return this.node("clone")(this.next().read_expr());
      switch (this.token) {
        case this.tok.T_INC:
          return this.node("pre")("+", this.next().read_variable(false, false));
        case this.tok.T_DEC:
          return this.node("pre")("-", this.next().read_variable(false, false));
        case this.tok.T_NEW:
          return this.read_new_expr();
        case this.tok.T_ISSET:
        case this.tok.T_EMPTY:
        case this.tok.T_INCLUDE:
        case this.tok.T_INCLUDE_ONCE:
        case this.tok.T_EVAL:
        case this.tok.T_REQUIRE:
        case this.tok.T_REQUIRE_ONCE:
          return this.read_internal_functions_in_yacc();
        case this.tok.T_MATCH:
          return this.read_match_expression();
        case this.tok.T_INT_CAST:
          return this.read_expr_cast("int");
        case this.tok.T_DOUBLE_CAST:
          return this.read_expr_cast("float");
        case this.tok.T_STRING_CAST:
          return this.read_expr_cast(-1 !== this.text().indexOf("binary") ? "binary" : "string");
        case this.tok.T_ARRAY_CAST:
          return this.read_expr_cast("array");
        case this.tok.T_OBJECT_CAST:
          return this.read_expr_cast("object");
        case this.tok.T_BOOL_CAST:
          return this.read_expr_cast("bool");
        case this.tok.T_UNSET_CAST:
          return this.read_expr_cast("unset");
        case this.tok.T_THROW:
          return this.version < 800 && this.raiseError("PHP 8+ is required to use throw as an expression"), this.node("throw")(this.next().read_expr());
        case this.tok.T_EXIT:
          var h2 = "die" === this.lexer.yytext.toLowerCase();
          return t2 = this.node("exit"), this.next(), t2(this.read_exit_expr(), h2);
        case this.tok.T_PRINT:
          return this.node("print")(this.next().read_expr());
        case this.tok.T_YIELD:
          var l2 = null, c2 = null;
          return t2 = this.node("yield"), this.next().is("EXPR") && (l2 = this.read_expr(), this.token === this.tok.T_DOUBLE_ARROW && (c2 = l2, l2 = this.next().read_expr())), t2(l2, c2);
        case this.tok.T_YIELD_FROM:
          return (t2 = this.node("yieldfrom"))(e2 = this.next().read_expr());
        case this.tok.T_FN:
        case this.tok.T_FUNCTION:
          return this.read_inline_function(void 0, i2);
        case this.tok.T_STATIC:
          var u2 = [this.token, this.lexer.getState()];
          if (this.next(), this.token === this.tok.T_FUNCTION || this.version >= 704 && this.token === this.tok.T_FN)
            return this.read_inline_function([0, 1, 0], i2);
          this.lexer.tokens.push(u2), this.next();
      }
      if (this.is("VARIABLE")) {
        t2 = this.node();
        var _3 = "identifier" === (e2 = this.read_variable(false, false)).kind || "staticlookup" === e2.kind && "identifier" === e2.offset.kind;
        switch (this.token) {
          case "=":
            return _3 && this.error("VARIABLE"), "&" == this.next().token ? this.read_assignref(t2, e2) : t2("assign", e2, this.read_expr(), "=");
          case this.tok.T_PLUS_EQUAL:
            return _3 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "+=");
          case this.tok.T_MINUS_EQUAL:
            return _3 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "-=");
          case this.tok.T_MUL_EQUAL:
            return _3 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "*=");
          case this.tok.T_POW_EQUAL:
            return _3 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "**=");
          case this.tok.T_DIV_EQUAL:
            return _3 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "/=");
          case this.tok.T_CONCAT_EQUAL:
            return _3 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), ".=");
          case this.tok.T_MOD_EQUAL:
            return _3 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "%=");
          case this.tok.T_AND_EQUAL:
            return _3 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "&=");
          case this.tok.T_OR_EQUAL:
            return _3 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "|=");
          case this.tok.T_XOR_EQUAL:
            return _3 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "^=");
          case this.tok.T_SL_EQUAL:
            return _3 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "<<=");
          case this.tok.T_SR_EQUAL:
            return _3 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), ">>=");
          case this.tok.T_COALESCE_EQUAL:
            return _3 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "??=");
          case this.tok.T_INC:
            return _3 && this.error("VARIABLE"), this.next(), t2("post", "+", e2);
          case this.tok.T_DEC:
            return _3 && this.error("VARIABLE"), this.next(), t2("post", "-", e2);
          default:
            t2.destroy(e2);
        }
      } else {
        if (this.is("SCALAR")) {
          if (t2 = this.node(), "array" === (e2 = this.read_scalar()).kind && e2.shortForm && "=" === this.token) {
            var d3 = this.convertToList(e2);
            return e2.loc && (d3.loc = e2.loc), t2("assign", d3, this.next().read_expr(), "=");
          }
          return t2.destroy(e2), this.handleDereferencable(e2);
        }
        this.error("EXPR"), this.next();
      }
      return e2;
    }, convertToList: function(t2) {
      var e2 = this, i2 = t2.items.map(function(t3) {
        return t3.value && "array" === t3.value.kind && t3.value.shortForm && (t3.value = e2.convertToList(t3.value)), t3;
      }), n2 = this.node("list")(i2, true);
      return t2.loc && (n2.loc = t2.loc), t2.leadingComments && (n2.leadingComments = t2.leadingComments), t2.trailingComments && (n2.trailingComments = t2.trailingComments), n2;
    }, read_assignref: function(t2, e2) {
      var i2;
      return this.next(), this.token === this.tok.T_NEW ? (this.version >= 700 && this.error(), i2 = this.read_new_expr()) : i2 = this.read_variable(false, false), t2("assignref", e2, i2);
    }, read_inline_function: function(t2, e2) {
      if (this.token === this.tok.T_FUNCTION) {
        var i2 = this.read_function(true, t2, e2);
        return i2.attrGroups = e2, i2;
      }
      !this.version >= 704 && this.raiseError("Arrow Functions are not allowed");
      var n2 = this.node("arrowfunc");
      this.expect(this.tok.T_FN) && this.next();
      var s2 = this.is_reference();
      this.expect("(") && this.next();
      var r2 = this.read_parameter_list();
      this.expect(")") && this.next();
      var o2 = false, a2 = null;
      ":" === this.token && ("?" === this.next().token && (o2 = true, this.next()), a2 = this.read_types()), this.expect(this.tok.T_DOUBLE_ARROW) && this.next();
      var h2 = n2(r2, s2, this.read_expr(), a2, o2, !!t2);
      return h2.attrGroups = e2, h2;
    }, read_match_expression: function() {
      var t2 = this.node("match");
      this.expect(this.tok.T_MATCH) && this.next(), this.version < 800 && this.raiseError("Match statements are not allowed before PHP 8");
      var e2, i2;
      return this.expect("(") && this.next(), e2 = this.read_expr(), this.expect(")") && this.next(), this.expect("{") && this.next(), i2 = this.read_match_arms(), this.expect("}") && this.next(), t2(e2, i2);
    }, read_match_arms: function() {
      var t2 = this;
      return this.read_list(function() {
        return t2.read_match_arm();
      }, ",", true);
    }, read_match_arm: function() {
      if ("}" !== this.token)
        return this.node("matcharm")(this.read_match_arm_conds(), this.read_expr());
    }, read_match_arm_conds: function() {
      var t2 = [];
      if (this.token === this.tok.T_DEFAULT)
        t2 = null, this.next();
      else
        for (t2.push(this.read_expr()); "," === this.token; ) {
          if (this.next(), this.token === this.tok.T_DOUBLE_ARROW)
            return this.next(), t2;
          t2.push(this.read_expr());
        }
      return this.expect(this.tok.T_DOUBLE_ARROW) && this.next(), t2;
    }, read_attribute: function() {
      var t2 = this.text(), e2 = [];
      return this.next(), "(" === this.token && (e2 = this.read_argument_list()), this.node("attribute")(t2, e2);
    }, read_attr_list: function() {
      var t2 = [];
      if (this.token === this.tok.T_ATTRIBUTE)
        do {
          var e2 = this.node("attrgroup")([]);
          for (this.next(), e2.attrs.push(this.read_attribute()); "," === this.token; )
            this.next(), "]" !== this.token && e2.attrs.push(this.read_attribute());
          t2.push(e2), this.expect("]"), this.next();
        } while (this.token === this.tok.T_ATTRIBUTE);
      return t2;
    }, read_new_expr: function() {
      var t2 = this.node("new");
      this.expect(this.tok.T_NEW) && this.next();
      var e2 = [], i2 = this.read_attr_list();
      if (this.token === this.tok.T_CLASS) {
        var n2 = this.node("class");
        "(" === this.next().token && (e2 = this.read_argument_list());
        var s2 = this.read_extends_from(), r2 = this.read_implements_list(), o2 = null;
        this.expect("{") && (o2 = this.next().read_class_body(true, false));
        var a2 = n2(null, s2, r2, o2, [0, 0, 0]);
        return a2.attrGroups = i2, t2(a2, e2);
      }
      for (var h2 = this.read_new_class_name(); "[" === this.token; ) {
        var l2 = this.node("offsetlookup"), c2 = this.next().read_encaps_var_offset();
        this.expect("]") && this.next(), h2 = l2(h2, c2);
      }
      return "(" === this.token && (e2 = this.read_argument_list()), t2(h2, e2);
    }, read_new_class_name: function() {
      if (this.token === this.tok.T_NS_SEPARATOR || this.token === this.tok.T_NAME_RELATIVE || this.token === this.tok.T_NAME_QUALIFIED || this.token === this.tok.T_NAME_FULLY_QUALIFIED || this.token === this.tok.T_STRING || this.token === this.tok.T_NAMESPACE) {
        var t2 = this.read_namespace_name(true);
        return this.token === this.tok.T_DOUBLE_COLON && (t2 = this.read_static_getter(t2)), t2;
      }
      if (this.is("VARIABLE"))
        return this.read_variable(true, false);
      this.expect([this.tok.T_STRING, "VARIABLE"]);
    }, handleDereferencable: function(t2) {
      for (; this.token !== this.EOF; )
        if (this.token === this.tok.T_OBJECT_OPERATOR || this.token === this.tok.T_DOUBLE_COLON)
          t2 = this.recursive_variable_chain_scan(t2, false, false, true);
        else if (this.token === this.tok.T_CURLY_OPEN || "[" === this.token)
          t2 = this.read_dereferencable(t2);
        else {
          if ("(" !== this.token)
            return t2;
          t2 = this.node("call")(t2, this.read_argument_list());
        }
      return t2;
    } };
    R2.read_expr, R2.read_expr_cast, R2.read_isset_variable, R2.read_isset_variables, R2.read_internal_functions_in_yacc, R2.read_optional_expr, R2.read_exit_expr, R2.read_expr_item, R2.convertToList, R2.read_assignref, R2.read_inline_function, R2.read_match_expression, R2.read_match_arms, R2.read_match_arm, R2.read_match_arm_conds, R2.read_attribute, R2.read_attr_list, R2.read_new_expr, R2.read_new_class_name, R2.handleDereferencable;
    var w = { read_enum_declaration_statement: function(t2) {
      var e2 = this.node("enum");
      if (!this.expect(this.tok.T_ENUM))
        return null;
      this.next().expect(this.tok.T_STRING);
      var i2 = this.node("identifier"), n2 = this.text();
      this.next(), i2 = i2(n2);
      var s2 = this.read_enum_value_type(), r2 = this.read_implements_list();
      this.expect("{");
      var o2 = e2(i2, s2, r2, this.next().read_class_body(false, true));
      return t2 && (o2.attrGroups = t2), o2;
    }, read_enum_value_type: function() {
      return ":" === this.token ? this.next().read_namespace_name() : null;
    }, read_enum_case: function() {
      this.expect(this.tok.T_CASE);
      var t2 = this.node("enumcase"), e2 = this.node("identifier"), i2 = this.next().text();
      this.next(), e2 = e2(i2);
      var n2 = "=" === this.token ? this.next().read_expr() : null;
      return this.expect(";"), t2(e2, n2);
    } };
    w.read_enum_declaration_statement, w.read_enum_value_type, w.read_enum_case;
    var D = { is_reference: function() {
      return "&" === this.token && (this.next(), true);
    }, is_variadic: function() {
      return this.token === this.tok.T_ELLIPSIS && (this.next(), true);
    }, read_function: function(t2, e2, i2, n2) {
      var s2 = this.read_function_declaration(t2 ? 1 : e2 ? 2 : 0, e2 && 1 === e2[1], i2 || [], n2);
      return e2 && 1 == e2[2] ? (s2.parseFlags(e2), this.expect(";") && this.next()) : (this.expect("{") && (s2.body = this.read_code_block(false), s2.loc && s2.body.loc && (s2.loc.end = s2.body.loc.end)), !t2 && e2 && s2.parseFlags(e2)), s2;
    }, read_function_declaration: function(t2, e2, i2, n2) {
      var s2 = this, r2 = "function";
      1 === t2 ? r2 = "closure" : 2 === t2 && (r2 = "method");
      var o2 = this.node(r2);
      this.expect(this.tok.T_FUNCTION) && this.next();
      var a2 = this.is_reference(), h2 = false, l2 = [], c2 = null, u2 = false;
      if (1 !== t2) {
        var _3 = this.node("identifier");
        2 === t2 ? this.version >= 700 ? this.token === this.tok.T_STRING || this.is("IDENTIFIER") ? (h2 = this.text(), this.next()) : this.version < 704 && this.error("IDENTIFIER") : this.token === this.tok.T_STRING ? (h2 = this.text(), this.next()) : this.error("IDENTIFIER") : this.version >= 700 ? this.token === this.tok.T_STRING ? (h2 = this.text(), this.next()) : this.version >= 704 ? this.expect("(") || this.next() : (this.error(this.tok.T_STRING), this.next()) : (this.expect(this.tok.T_STRING) && (h2 = this.text()), this.next()), h2 = _3(h2);
      }
      this.expect("(") && this.next();
      var d3 = this.read_parameter_list("__construct" === h2.name);
      this.expect(")") && this.next(), 1 === t2 && (l2 = this.read_lexical_vars()), ":" === this.token && ("?" === this.next().token && (u2 = true, this.next()), c2 = this.read_types());
      var p2 = function(t3) {
        return t3.attrGroups = i2 || [], n2 && t3.loc && (t3.loc.start = n2, t3.loc.source && (t3.loc.source = s2.lexer._input.substr(t3.loc.start.offset, t3.loc.end.offset - t3.loc.start.offset))), t3;
      };
      return p2(1 === t2 ? o2(d3, a2, l2, c2, u2, e2) : o2(h2, d3, a2, c2, u2));
    }, read_lexical_vars: function() {
      var t2 = [];
      return this.token === this.tok.T_USE && (this.next(), this.expect("(") && this.next(), t2 = this.read_lexical_var_list(), this.expect(")") && this.next()), t2;
    }, read_list_with_dangling_comma: function(t2) {
      for (var e2 = []; this.token != this.EOF; ) {
        if (e2.push(t2()), "," != this.token) {
          if (")" == this.token)
            break;
          this.error([",", ")"]);
          break;
        }
        if (this.next(), this.version >= 800 && ")" === this.token)
          return e2;
      }
      return e2;
    }, read_lexical_var_list: function() {
      return this.read_list_with_dangling_comma(this.read_lexical_var.bind(this));
    }, read_lexical_var: function() {
      if ("&" === this.token)
        return this.read_byref(this.read_lexical_var.bind(this));
      var t2 = this.node("variable");
      this.expect(this.tok.T_VARIABLE);
      var e2 = this.text().substring(1);
      return this.next(), t2(e2, false);
    }, read_parameter_list: function(t2) {
      if (")" !== this.token) {
        var e2 = false;
        return this.read_list_with_dangling_comma((function() {
          var i2 = this.read_parameter(t2);
          return i2 && (e2 && this.raiseError("Unexpected parameter after a variadic parameter"), i2.variadic && (e2 = true)), i2;
        }).bind(this), ",");
      }
      return [];
    }, read_parameter: function(t2) {
      var e2, i2 = this.node("parameter"), n2 = null, s2 = null, r2 = false, o2 = false, a2 = [];
      this.token === this.tok.T_ATTRIBUTE && (a2 = this.read_attr_list());
      var h2 = this.read_promoted();
      this.version >= 801 && this.token === this.tok.T_READ_ONLY && (t2 ? (this.next(), o2 = true) : this.raiseError("readonly properties can be used only on class constructor")), "?" === this.token && (this.next(), r2 = true), e2 = this.read_types(), r2 && !e2 && this.raiseError("Expecting a type definition combined with nullable operator");
      var l2 = this.is_reference(), c2 = this.is_variadic();
      if (this.expect(this.tok.T_VARIABLE)) {
        n2 = this.node("identifier");
        var u2 = this.text().substring(1);
        this.next(), n2 = n2(u2);
      }
      "=" == this.token && (s2 = this.next().read_expr());
      var _3 = i2(n2, e2, s2, l2, c2, o2, r2, h2);
      return a2 && (_3.attrGroups = a2), _3;
    }, read_types: function() {
      var t2 = "unset", e2 = "union", i2 = "intersection", n2 = [], s2 = t2, r2 = this.read_type();
      if (!r2)
        return null;
      for (n2.push(r2); "|" === this.token || this.version >= 801 && "&" === this.token; ) {
        var o2 = this.peek();
        if (o2 === this.tok.T_ELLIPSIS || o2 === this.tok.T_VARIABLE)
          break;
        s2 === t2 ? s2 = "|" === this.token ? e2 : i2 : (s2 === e2 && "|" !== this.token || s2 === i2 && "&" !== this.token) && this.raiseError('Unexpect token "' + this.token + '", "|" and "&" can not be mixed'), this.next(), n2.push(this.read_type());
      }
      return 1 === n2.length ? n2[0] : s2 === i2 ? this.node("intersectiontype")(n2) : this.node("uniontype")(n2);
    }, read_promoted: function() {
      return this.token === this.tok.T_PUBLIC ? (this.next(), 1) : this.token === this.tok.T_PROTECTED ? (this.next(), 2) : this.token === this.tok.T_PRIVATE ? (this.next(), 4) : 0;
    }, read_argument_list: function() {
      var t2 = [];
      return this.expect("(") && this.next(), this.version >= 801 && this.token === this.tok.T_ELLIPSIS && ")" === this.peek() ? (t2.push(this.node("variadicplaceholder")()), this.next()) : ")" !== this.token && (t2 = this.read_non_empty_argument_list()), this.expect(")") && this.next(), t2;
    }, read_non_empty_argument_list: function() {
      var t2 = false;
      return this.read_function_list((function() {
        var e2 = this.read_argument();
        if (e2) {
          var i2 = "variadic" === e2.kind;
          t2 && !i2 && this.raiseError("Unexpected non-variadic argument after a variadic argument"), i2 && (t2 = true);
        }
        return e2;
      }).bind(this), ",");
    }, read_argument: function() {
      if (this.token === this.tok.T_ELLIPSIS)
        return this.node("variadic")(this.next().read_expr());
      if ((this.token === this.tok.T_STRING || Object.values(this.lexer.keywords).includes(this.token)) && ":" === this.peek())
        return this.version < 800 && this.raiseError("PHP 8+ is required to use named arguments"), this.node("namedargument")(this.text(), this.next().next().read_expr());
      return this.read_expr();
    }, read_type: function() {
      var t2 = this.node();
      if (this.token === this.tok.T_ARRAY || this.token === this.tok.T_CALLABLE) {
        var e2 = this.text();
        return this.next(), t2("typereference", e2.toLowerCase(), e2);
      }
      if (this.token === this.tok.T_NAME_RELATIVE || this.token === this.tok.T_NAME_QUALIFIED || this.token === this.tok.T_NAME_FULLY_QUALIFIED || this.token === this.tok.T_STRING || this.token === this.tok.T_STATIC) {
        var i2 = this.text(), n2 = [this.token, this.lexer.getState()];
        return this.next(), this.token !== this.tok.T_NS_SEPARATOR && this.ast.typereference.types.indexOf(i2.toLowerCase()) > -1 ? t2("typereference", i2.toLowerCase(), i2) : (this.lexer.tokens.push(n2), this.next(), t2.destroy(), this.read_namespace_name());
      }
      return t2.destroy(), null;
    } };
    D.is_reference, D.is_variadic, D.read_function, D.read_function_declaration, D.read_lexical_vars, D.read_list_with_dangling_comma, D.read_lexical_var_list, D.read_lexical_var, D.read_parameter_list, D.read_parameter, D.read_types, D.read_promoted, D.read_argument_list, D.read_non_empty_argument_list, D.read_argument, D.read_type;
    var P = { read_if: function() {
      var t2 = this.node("if"), e2 = this.next().read_if_expr(), i2 = null, n2 = null, s2 = false;
      if (":" === this.token) {
        s2 = true, this.next(), i2 = this.node("block");
        for (var r2 = []; this.token !== this.EOF && this.token !== this.tok.T_ENDIF; ) {
          if (this.token === this.tok.T_ELSEIF) {
            n2 = this.read_elseif_short();
            break;
          }
          if (this.token === this.tok.T_ELSE) {
            n2 = this.read_else_short();
            break;
          }
          r2.push(this.read_inner_statement());
        }
        i2 = i2(null, r2), this.expect(this.tok.T_ENDIF) && this.next(), this.expectEndOfStatement();
      } else
        i2 = this.read_statement(), this.token === this.tok.T_ELSEIF ? n2 = this.read_if() : this.token === this.tok.T_ELSE && (n2 = this.next().read_statement());
      return t2(e2, i2, n2, s2);
    }, read_if_expr: function() {
      this.expect("(") && this.next();
      var t2 = this.read_expr();
      return this.expect(")") && this.next(), t2;
    }, read_elseif_short: function() {
      var t2 = null, e2 = this.node("if"), i2 = this.next().read_if_expr();
      this.expect(":") && this.next();
      for (var n2 = this.node("block"), s2 = []; this.token != this.EOF && this.token !== this.tok.T_ENDIF; ) {
        if (this.token === this.tok.T_ELSEIF) {
          t2 = this.read_elseif_short();
          break;
        }
        if (this.token === this.tok.T_ELSE) {
          t2 = this.read_else_short();
          break;
        }
        s2.push(this.read_inner_statement());
      }
      return e2(i2, n2(null, s2), t2, true);
    }, read_else_short: function() {
      this.next().expect(":") && this.next();
      for (var t2 = this.node("block"), e2 = []; this.token != this.EOF && this.token !== this.tok.T_ENDIF; )
        e2.push(this.read_inner_statement());
      return t2(null, e2);
    } };
    P.read_if, P.read_if_expr, P.read_elseif_short, P.read_else_short;
    var U2 = { read_while: function() {
      var t2 = this.node("while");
      this.expect(this.tok.T_WHILE) && this.next();
      var e2, i2 = null, n2 = false;
      return this.expect("(") && this.next(), e2 = this.read_expr(), this.expect(")") && this.next(), ":" === this.token ? (n2 = true, i2 = this.read_short_form(this.tok.T_ENDWHILE)) : i2 = this.read_statement(), t2(e2, i2, n2);
    }, read_do: function() {
      var t2 = this.node("do");
      this.expect(this.tok.T_DO) && this.next();
      var e2, i2 = null;
      return e2 = this.read_statement(), this.expect(this.tok.T_WHILE) && (this.next().expect("(") && this.next(), i2 = this.read_expr(), this.expect(")") && this.next(), this.expect(";") && this.next()), t2(i2, e2);
    }, read_for: function() {
      var t2 = this.node("for");
      this.expect(this.tok.T_FOR) && this.next();
      var e2 = [], i2 = [], n2 = [], s2 = null, r2 = false;
      return this.expect("(") && this.next(), ";" !== this.token ? (e2 = this.read_list(this.read_expr, ","), this.expect(";") && this.next()) : this.next(), ";" !== this.token ? (i2 = this.read_list(this.read_expr, ","), this.expect(";") && this.next()) : this.next(), ")" !== this.token ? (n2 = this.read_list(this.read_expr, ","), this.expect(")") && this.next()) : this.next(), ":" === this.token ? (r2 = true, s2 = this.read_short_form(this.tok.T_ENDFOR)) : s2 = this.read_statement(), t2(e2, i2, n2, s2, r2);
    }, read_foreach: function() {
      var t2 = this.node("foreach");
      this.expect(this.tok.T_FOREACH) && this.next();
      var e2, i2 = null, n2 = null, s2 = null, r2 = false;
      return this.expect("(") && this.next(), e2 = this.read_expr(), this.expect(this.tok.T_AS) && (this.next(), n2 = this.read_foreach_variable(), this.token === this.tok.T_DOUBLE_ARROW && (i2 = n2, n2 = this.next().read_foreach_variable())), i2 && "list" === i2.kind && this.raiseError("Fatal Error : Cannot use list as key element"), this.expect(")") && this.next(), ":" === this.token ? (r2 = true, s2 = this.read_short_form(this.tok.T_ENDFOREACH)) : s2 = this.read_statement(), t2(e2, i2, n2, s2, r2);
    }, read_foreach_variable: function() {
      if (this.token === this.tok.T_LIST || "[" === this.token) {
        var t2 = "[" === this.token, e2 = this.node("list");
        this.next(), !t2 && this.expect("(") && this.next();
        var i2 = this.read_array_pair_list(t2);
        return this.expect(t2 ? "]" : ")") && this.next(), e2(i2, t2);
      }
      return this.read_variable(false, false);
    } };
    U2.read_while, U2.read_do, U2.read_for, U2.read_foreach, U2.read_foreach_variable;
    var M2 = { read_start: function() {
      return this.token == this.tok.T_NAMESPACE ? this.read_namespace() : this.read_top_statement();
    } };
    M2.read_start;
    var F = { read_namespace: function() {
      var t2, e2, i2 = this.node("namespace");
      return this.expect(this.tok.T_NAMESPACE) && this.next(), e2 = "{" === this.token ? { name: [""] } : this.read_namespace_name(), this.currentNamespace = e2, ";" === this.token ? (this.currentNamespace = e2, t2 = this.next().read_top_statements(), this.expect(this.EOF), i2(e2.name, t2, false)) : "{" === this.token ? (this.currentNamespace = e2, t2 = this.next().read_top_statements(), this.expect("}") && this.next(), 0 === t2.length && this.extractDoc && this._docs.length > this._docIndex && t2.push(this.node("noop")()), i2(e2.name, t2, true)) : (this.error(["{", ";"]), this.currentNamespace = e2, t2 = this.read_top_statements(), this.expect(this.EOF), i2(e2, t2, false));
    }, read_namespace_name: function(t2) {
      var e2, i2 = this.node(), n2 = this.text();
      switch (this.token) {
        case this.tok.T_NAME_RELATIVE:
          e2 = this.ast.name.RELATIVE_NAME, n2 = n2.replace(/^namespace\\/, "");
          break;
        case this.tok.T_NAME_QUALIFIED:
          e2 = this.ast.name.QUALIFIED_NAME;
          break;
        case this.tok.T_NAME_FULLY_QUALIFIED:
          e2 = this.ast.name.FULL_QUALIFIED_NAME;
          break;
        default:
          if (e2 = this.ast.name.UNQUALIFIED_NAME, !this.expect(this.tok.T_STRING))
            return i2("name", "", this.ast.name.FULL_QUALIFIED_NAME);
      }
      if (this.next(), t2 || "(" !== this.token) {
        if ("parent" === n2.toLowerCase())
          return i2("parentreference", n2);
        if ("self" === n2.toLowerCase())
          return i2("selfreference", n2);
      }
      return i2("name", n2, e2);
    }, read_use_statement: function() {
      var t2 = this.node("usegroup"), e2 = [], i2 = null;
      this.expect(this.tok.T_USE) && this.next();
      var n2 = this.read_use_type();
      return e2.push(this.read_use_declaration(false)), "," === this.token ? e2 = e2.concat(this.next().read_use_declarations(false)) : "{" === this.token && (i2 = e2[0].name, e2 = this.next().read_use_declarations(null === n2), this.expect("}") && this.next()), t2 = t2(i2, n2, e2), this.expect(";") && this.next(), t2;
    }, read_class_name_reference: function() {
      return this.read_variable(true, false);
    }, read_use_declaration: function(t2) {
      var e2 = this.node("useitem"), i2 = null;
      t2 && (i2 = this.read_use_type());
      var n2 = this.read_namespace_name(), s2 = this.read_use_alias();
      return e2(n2.name, s2, i2);
    }, read_use_declarations: function(t2) {
      for (var e2 = [this.read_use_declaration(t2)]; "," === this.token; ) {
        if (this.next(), t2) {
          if (this.token !== this.tok.T_NAME_RELATIVE && this.token !== this.tok.T_NAME_QUALIFIED && this.token !== this.tok.T_NAME_FULLY_QUALIFIED && this.token !== this.tok.T_FUNCTION && this.token !== this.tok.T_CONST && this.token !== this.tok.T_STRING)
            break;
        } else if (this.token !== this.tok.T_NAME_RELATIVE && this.token !== this.tok.T_NAME_QUALIFIED && this.token !== this.tok.T_NAME_FULLY_QUALIFIED && this.token !== this.tok.T_STRING && this.token !== this.tok.T_NS_SEPARATOR)
          break;
        e2.push(this.read_use_declaration(t2));
      }
      return e2;
    }, read_use_alias: function() {
      var t2 = null;
      if (this.token === this.tok.T_AS && this.next().expect(this.tok.T_STRING)) {
        var e2 = this.node("identifier"), i2 = this.text();
        this.next(), t2 = e2(i2);
      }
      return t2;
    }, read_use_type: function() {
      return this.token === this.tok.T_FUNCTION ? (this.next(), this.ast.useitem.TYPE_FUNCTION) : this.token === this.tok.T_CONST ? (this.next(), this.ast.useitem.TYPE_CONST) : null;
    } };
    F.read_namespace, F.read_namespace_name, F.read_use_statement, F.read_class_name_reference, F.read_use_declaration, F.read_use_declarations, F.read_use_alias, F.read_use_type;
    var B = { "\\": "\\", $: "$", n: "\n", r: "\r", t: "	", f: String.fromCharCode(12), v: String.fromCharCode(11), e: String.fromCharCode(27) }, H = { resolve_special_chars: function(t2, e2) {
      return e2 ? t2.replace(/\\"/, '"').replace(/\\([\\$nrtfve]|[xX][0-9a-fA-F]{1,2}|[0-7]{1,3}|u{([0-9a-fA-F]+)})/g, function(t3, e3, i2) {
        return B[e3] ? B[e3] : "x" === e3[0] || "X" === e3[0] ? String.fromCodePoint(parseInt(e3.substr(1), 16)) : "u" === e3[0] ? String.fromCodePoint(parseInt(i2, 16)) : String.fromCodePoint(parseInt(e3, 8));
      }) : t2.replace(/\\\\/g, "\\").replace(/\\'/g, "'");
    }, remove_heredoc_leading_whitespace_chars: function(t2, e2, i2, n2) {
      if (0 === e2)
        return t2;
      this.check_heredoc_indentation_level(t2, e2, i2, n2);
      var s2 = i2 ? " " : "	", r2 = new RegExp("\\n".concat(s2, "{").concat(e2, "}"), "g"), o2 = new RegExp("^".concat(s2, "{").concat(e2, "}"));
      return n2 && (t2 = t2.replace(o2, "")), t2.replace(r2, "\n");
    }, check_heredoc_indentation_level: function(t2, e2, i2, n2) {
      var s2 = t2.length, r2 = 0, o2 = 0, a2 = true, h2 = i2 ? " " : "	", l2 = false;
      if (!n2) {
        if (-1 === (r2 = t2.indexOf("\n")))
          return;
        r2++;
      }
      for (; r2 < s2; )
        a2 ? t2[r2] === h2 ? o2++ : l2 = true : a2 = false, "\n" !== t2[r2] && l2 && o2 < e2 ? this.raiseError("Invalid body indentation level (expecting an indentation at least ".concat(e2, ")")) : l2 = false, "\n" === t2[r2] && (a2 = true, o2 = 0), r2++;
    }, read_dereferencable_scalar: function() {
      var t2 = null;
      switch (this.token) {
        case this.tok.T_CONSTANT_ENCAPSED_STRING:
          var e2 = this.node("string"), i2 = this.text(), n2 = 0;
          "b" !== i2[0] && "B" !== i2[0] || (n2 = 1);
          var s2 = '"' === i2[n2];
          this.next(), e2 = e2(s2, this.resolve_special_chars(i2.substring(n2 + 1, i2.length - 1), s2), 1 === n2, i2), t2 = this.token === this.tok.T_DOUBLE_COLON ? this.read_static_getter(e2) : e2;
          break;
        case this.tok.T_ARRAY:
        case "[":
          t2 = this.read_array();
      }
      return t2;
    }, read_scalar: function() {
      if (this.is("T_MAGIC_CONST"))
        return this.get_magic_constant();
      var t2, e2;
      switch (this.token) {
        case this.tok.T_LNUMBER:
        case this.tok.T_DNUMBER:
          var i2 = this.node("number");
          return t2 = this.text(), this.next(), i2(t2, null);
        case this.tok.T_START_HEREDOC:
          if ("ST_NOWDOC" === this.lexer.curCondition) {
            var n2 = this.lexer.yylloc.first_offset;
            e2 = this.node("nowdoc"), t2 = this.next().text(), this.lexer.heredoc_label.indentation > 0 && (t2 = t2.substring(0, t2.length - this.lexer.heredoc_label.indentation));
            var s2 = t2[t2.length - 1];
            "\n" === s2 ? t2 = "\r" === t2[t2.length - 2] ? t2.substring(0, t2.length - 2) : t2.substring(0, t2.length - 1) : "\r" === s2 && (t2 = t2.substring(0, t2.length - 1)), this.expect(this.tok.T_ENCAPSED_AND_WHITESPACE) && this.next(), this.expect(this.tok.T_END_HEREDOC) && this.next();
            var r2 = this.lexer._input.substring(n2, this.lexer.yylloc.first_offset);
            return e2 = e2(this.remove_heredoc_leading_whitespace_chars(t2, this.lexer.heredoc_label.indentation, this.lexer.heredoc_label.indentation_uses_spaces, this.lexer.heredoc_label.first_encaps_node), r2, this.lexer.heredoc_label.label), this.lexer.heredoc_label.finished = true, e2;
          }
          return this.read_encapsed_string(this.tok.T_END_HEREDOC);
        case '"':
          return this.read_encapsed_string('"');
        case 'b"':
        case 'B"':
          return this.read_encapsed_string('"', true);
        case this.tok.T_CONSTANT_ENCAPSED_STRING:
        case this.tok.T_ARRAY:
        case "[":
          return this.read_dereferencable_scalar();
        default:
          var o2 = this.error("SCALAR");
          return this.next(), o2;
      }
    }, read_dereferencable: function(t2) {
      var e2, i2, n2 = this.node("offsetlookup");
      return "[" === this.token ? (i2 = this.next().read_expr(), this.expect("]") && this.next(), e2 = n2(t2, i2)) : this.token === this.tok.T_DOLLAR_OPEN_CURLY_BRACES && (e2 = n2(t2, i2 = this.read_encapsed_string_item(false))), e2;
    }, read_encapsed_string_item: function(t2) {
      var e2, i2, n2, s2 = this.node("encapsedpart"), r2 = null, o2 = false, a2 = this.node();
      if (this.token === this.tok.T_ENCAPSED_AND_WHITESPACE) {
        var h2 = this.text();
        this.next(), a2 = a2("string", false, this.version >= 703 && !this.lexer.heredoc_label.finished ? this.remove_heredoc_leading_whitespace_chars(this.resolve_special_chars(h2, t2), this.lexer.heredoc_label.indentation, this.lexer.heredoc_label.indentation_uses_spaces, this.lexer.heredoc_label.first_encaps_node) : h2, false, h2);
      } else if (this.token === this.tok.T_DOLLAR_OPEN_CURLY_BRACES) {
        if (r2 = "simple", o2 = true, n2 = null, this.next().token === this.tok.T_STRING_VARNAME) {
          n2 = this.node("variable");
          var l2 = this.text();
          this.next(), a2.destroy(), "[" === this.token ? (n2 = n2(l2, false), i2 = this.node("offsetlookup"), e2 = this.next().read_expr(), this.expect("]") && this.next(), a2 = i2(n2, e2)) : a2 = n2(l2, false);
        } else
          a2 = a2("variable", this.read_expr(), false);
        this.expect("}") && this.next();
      } else if (this.token === this.tok.T_CURLY_OPEN)
        r2 = "complex", a2.destroy(), a2 = this.next().read_variable(false, false), this.expect("}") && this.next();
      else if (this.token === this.tok.T_VARIABLE) {
        if (r2 = "simple", a2.destroy(), a2 = this.read_simple_variable(), "[" === this.token && (i2 = this.node("offsetlookup"), e2 = this.next().read_encaps_var_offset(), this.expect("]") && this.next(), a2 = i2(a2, e2)), this.token === this.tok.T_OBJECT_OPERATOR) {
          i2 = this.node("propertylookup"), this.next().expect(this.tok.T_STRING);
          var c2 = this.node("identifier");
          n2 = this.text(), this.next(), a2 = i2(a2, c2(n2));
        }
      } else {
        this.expect(this.tok.T_ENCAPSED_AND_WHITESPACE);
        var u2 = this.text();
        this.next(), a2.destroy(), a2 = a2("string", false, u2, false, u2);
      }
      return this.lexer.heredoc_label.first_encaps_node = false, s2(a2, r2, o2);
    }, read_encapsed_string: function(t2) {
      var e2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i2 = this.lexer.yylloc.first_offset, n2 = this.node("encapsed");
      this.next();
      var s2 = this.lexer.yylloc.prev_offset - (e2 ? 1 : 0), r2 = [], o2 = null;
      for (o2 = "`" === t2 ? this.ast.encapsed.TYPE_SHELL : '"' === t2 ? this.ast.encapsed.TYPE_STRING : this.ast.encapsed.TYPE_HEREDOC; this.token !== t2 && this.token !== this.EOF; )
        r2.push(this.read_encapsed_string_item(true));
      if (r2.length > 0 && "encapsedpart" === r2[r2.length - 1].kind && "string" === r2[r2.length - 1].expression.kind) {
        var a2 = r2[r2.length - 1].expression, h2 = a2.value[a2.value.length - 1];
        "\n" === h2 ? "\r" === a2.value[a2.value.length - 2] ? a2.value = a2.value.substring(0, a2.value.length - 2) : a2.value = a2.value.substring(0, a2.value.length - 1) : "\r" === h2 && (a2.value = a2.value.substring(0, a2.value.length - 1));
      }
      this.expect(t2) && this.next();
      var l2 = this.lexer._input.substring("heredoc" === o2 ? i2 : s2 - 1, this.lexer.yylloc.first_offset);
      return n2 = n2(r2, l2, o2), t2 === this.tok.T_END_HEREDOC && (n2.label = this.lexer.heredoc_label.label, this.lexer.heredoc_label.finished = true), n2;
    }, get_magic_constant: function() {
      var t2 = this.node("magic"), e2 = this.text();
      return this.next(), t2(e2.toUpperCase(), e2);
    } };
    H.resolve_special_chars, H.remove_heredoc_leading_whitespace_chars, H.check_heredoc_indentation_level, H.read_dereferencable_scalar, H.read_scalar, H.read_dereferencable, H.read_encapsed_string_item, H.read_encapsed_string, H.get_magic_constant;
    var G = { read_top_statements: function() {
      for (var t2 = []; this.token !== this.EOF && "}" !== this.token; ) {
        var e2 = this.read_top_statement();
        e2 && (Array.isArray(e2) ? t2 = t2.concat(e2) : t2.push(e2));
      }
      return t2;
    }, read_top_statement: function() {
      var t2 = [];
      switch (this.token === this.tok.T_ATTRIBUTE && (t2 = this.read_attr_list()), this.token) {
        case this.tok.T_FUNCTION:
          return this.read_function(false, false, t2);
        case this.tok.T_ABSTRACT:
        case this.tok.T_FINAL:
        case this.tok.T_CLASS:
          return this.read_class_declaration_statement(t2);
        case this.tok.T_INTERFACE:
          return this.read_interface_declaration_statement(t2);
        case this.tok.T_TRAIT:
          return this.read_trait_declaration_statement();
        case this.tok.T_ENUM:
          return this.read_enum_declaration_statement(t2);
        case this.tok.T_USE:
          return this.read_use_statement();
        case this.tok.T_CONST:
          var e2 = this.node("constantstatement"), i2 = this.next().read_const_list();
          return this.expectEndOfStatement(), e2(null, i2);
        case this.tok.T_NAMESPACE:
          return this.read_namespace();
        case this.tok.T_HALT_COMPILER:
          var n2 = this.node("halt");
          return this.next().expect("(") && this.next(), this.expect(")") && this.next(), this.expect(";"), this.lexer.done = true, n2(this.lexer._input.substring(this.lexer.offset));
        default:
          return this.read_statement();
      }
    }, read_inner_statements: function() {
      for (var t2 = []; this.token != this.EOF && "}" !== this.token; ) {
        var e2 = this.read_inner_statement();
        e2 && (Array.isArray(e2) ? t2 = t2.concat(e2) : t2.push(e2));
      }
      return t2;
    }, read_const_list: function() {
      return this.read_list(function() {
        this.expect(this.tok.T_STRING);
        var t2 = this.node("constant"), e2 = this.node("identifier"), i2 = this.text();
        return this.next(), e2 = e2(i2), this.expect("=") ? t2(e2, this.next().read_expr()) : t2(e2, null);
      }, ",", false);
    }, read_declare_list: function() {
      for (var t2 = []; this.token != this.EOF && ")" !== this.token; ) {
        this.expect(this.tok.T_STRING);
        var e2 = this.node("declaredirective"), i2 = this.node("identifier"), n2 = this.text();
        this.next(), i2 = i2(n2);
        var s2 = null;
        if (this.expect("=") && (s2 = this.next().read_expr()), t2.push(e2(i2, s2)), "," !== this.token)
          break;
        this.next();
      }
      return t2;
    }, read_inner_statement: function() {
      var t2 = [];
      switch (this.token === this.tok.T_ATTRIBUTE && (t2 = this.read_attr_list()), this.token) {
        case this.tok.T_FUNCTION:
          var e2 = this.read_function(false, false);
          return e2.attrGroups = t2, e2;
        case this.tok.T_ABSTRACT:
        case this.tok.T_FINAL:
        case this.tok.T_CLASS:
          return this.read_class_declaration_statement();
        case this.tok.T_INTERFACE:
          return this.read_interface_declaration_statement();
        case this.tok.T_TRAIT:
          return this.read_trait_declaration_statement();
        case this.tok.T_ENUM:
          return this.read_enum_declaration_statement();
        case this.tok.T_HALT_COMPILER:
          this.raiseError("__HALT_COMPILER() can only be used from the outermost scope");
          var i2 = this.node("halt");
          return this.next().expect("(") && this.next(), this.expect(")") && this.next(), i2 = i2(this.lexer._input.substring(this.lexer.offset)), this.expect(";") && this.next(), i2;
        default:
          return this.read_statement();
      }
    }, read_statement: function() {
      switch (this.token) {
        case "{":
          return this.read_code_block(false);
        case this.tok.T_IF:
          return this.read_if();
        case this.tok.T_SWITCH:
          return this.read_switch();
        case this.tok.T_FOR:
          return this.read_for();
        case this.tok.T_FOREACH:
          return this.read_foreach();
        case this.tok.T_WHILE:
          return this.read_while();
        case this.tok.T_DO:
          return this.read_do();
        case this.tok.T_COMMENT:
          return this.read_comment();
        case this.tok.T_DOC_COMMENT:
          return this.read_doc_comment();
        case this.tok.T_RETURN:
          var t2 = this.node("return");
          this.next();
          var e2 = this.read_optional_expr(";");
          return this.expectEndOfStatement(), t2(e2);
        case this.tok.T_BREAK:
        case this.tok.T_CONTINUE:
          var i2 = this.node(this.token === this.tok.T_CONTINUE ? "continue" : "break");
          this.next();
          var n2 = this.read_optional_expr(";");
          return this.expectEndOfStatement(), i2(n2);
        case this.tok.T_GLOBAL:
          var s2 = this.node("global"), r2 = this.next().read_list(this.read_simple_variable, ",");
          return this.expectEndOfStatement(), s2(r2);
        case this.tok.T_STATIC:
          var o2 = [this.token, this.lexer.getState()], a2 = this.node();
          if (this.next().token === this.tok.T_DOUBLE_COLON) {
            this.lexer.tokens.push(o2);
            var h2 = this.next().read_expr();
            return this.expectEndOfStatement(h2), a2("expressionstatement", h2);
          }
          if (this.token === this.tok.T_FUNCTION)
            return this.read_function(true, [0, 1, 0]);
          var l2 = this.read_variable_declarations();
          return this.expectEndOfStatement(), a2("static", l2);
        case this.tok.T_ECHO:
          var c2 = this.node("echo"), u2 = this.text(), _3 = "<?=" === u2 || "<%=" === u2, d3 = this.next().read_function_list(this.read_expr, ",");
          return this.expectEndOfStatement(), c2(d3, _3);
        case this.tok.T_INLINE_HTML:
          var p2 = this.text(), f2 = this.lexer.yylloc.first_offset > 0 ? this.lexer._input[this.lexer.yylloc.first_offset - 1] : null, T2 = "\r" === f2 || "\n" === f2;
          T2 && "\n" === f2 && this.lexer.yylloc.first_offset > 1 && "\r" === this.lexer._input[this.lexer.yylloc.first_offset - 2] && (f2 = "\r\n");
          var k2 = this.node("inline");
          return this.next(), k2(p2, T2 ? f2 + p2 : p2);
        case this.tok.T_UNSET:
          var E2 = this.node("unset");
          this.next().expect("(") && this.next();
          var m2 = this.read_function_list(this.read_variable, ",");
          return this.expect(")") && this.next(), this.expect(";") && this.next(), E2(m2);
        case this.tok.T_DECLARE:
          var x2, y3 = this.node("declare"), v3 = [];
          this.next().expect("(") && this.next();
          var A2 = this.read_declare_list();
          if (this.expect(")") && this.next(), ":" === this.token) {
            for (this.next(); this.token != this.EOF && this.token !== this.tok.T_ENDDECLARE; )
              v3.push(this.read_top_statement());
            0 === v3.length && this.extractDoc && this._docs.length > this._docIndex && v3.push(this.node("noop")()), this.expect(this.tok.T_ENDDECLARE) && this.next(), this.expectEndOfStatement(), x2 = this.ast.declare.MODE_SHORT;
          } else if ("{" === this.token) {
            for (this.next(); this.token != this.EOF && "}" !== this.token; )
              v3.push(this.read_top_statement());
            0 === v3.length && this.extractDoc && this._docs.length > this._docIndex && v3.push(this.node("noop")()), this.expect("}") && this.next(), x2 = this.ast.declare.MODE_BLOCK;
          } else
            this.expect(";") && this.next(), x2 = this.ast.declare.MODE_NONE;
          return y3(A2, v3, x2);
        case this.tok.T_TRY:
          return this.read_try();
        case this.tok.T_THROW:
          var g3 = this.node("throw"), N3 = this.next().read_expr();
          return this.expectEndOfStatement(), g3(N3);
        case ";":
          return this.next(), null;
        case this.tok.T_STRING:
          var L2 = this.node(), C2 = [this.token, this.lexer.getState()], b2 = this.text(), I3 = this.node("identifier");
          if (":" === this.next().token)
            return I3 = I3(b2), this.next(), L2("label", I3);
          I3.destroy(), L2.destroy(), this.lexer.tokens.push(C2);
          var S2 = this.node("expressionstatement"), O2 = this.next().read_expr();
          return this.expectEndOfStatement(O2), S2(O2);
        case this.tok.T_GOTO:
          var R3 = this.node("goto"), w2 = null;
          if (this.next().expect(this.tok.T_STRING)) {
            w2 = this.node("identifier");
            var D2 = this.text();
            this.next(), w2 = w2(D2), this.expectEndOfStatement();
          }
          return R3(w2);
        default:
          var P2 = this.node("expressionstatement"), U3 = this.read_expr();
          return this.expectEndOfStatement(U3), P2(U3);
      }
    }, read_code_block: function(t2) {
      var e2 = this.node("block");
      this.expect("{") && this.next();
      var i2 = t2 ? this.read_top_statements() : this.read_inner_statements();
      return 0 === i2.length && this.extractDoc && this._docs.length > this._docIndex && i2.push(this.node("noop")()), this.expect("}") && this.next(), e2(null, i2);
    } };
    G.read_top_statements, G.read_top_statement, G.read_inner_statements, G.read_const_list, G.read_declare_list, G.read_inner_statement, G.read_statement, G.read_code_block;
    var V = { read_switch: function() {
      var t2 = this.node("switch");
      this.expect(this.tok.T_SWITCH) && this.next(), this.expect("(") && this.next();
      var e2 = this.read_expr();
      this.expect(")") && this.next();
      var i2 = ":" === this.token;
      return t2(e2, this.read_switch_case_list(), i2);
    }, read_switch_case_list: function() {
      var t2 = null, e2 = this.node("block"), i2 = [];
      for ("{" === this.token ? t2 = "}" : ":" === this.token ? t2 = this.tok.T_ENDSWITCH : this.expect(["{", ":"]), this.next(), ";" === this.token && this.next(); this.token !== this.EOF && this.token !== t2; )
        i2.push(this.read_case_list(t2));
      return 0 === i2.length && this.extractDoc && this._docs.length > this._docIndex && i2.push(this.node("noop")()), this.expect(t2) && this.next(), t2 === this.tok.T_ENDSWITCH && this.expectEndOfStatement(), e2(null, i2);
    }, read_case_list: function(t2) {
      var e2 = this.node("case"), i2 = null;
      this.token === this.tok.T_CASE ? i2 = this.next().read_expr() : this.token === this.tok.T_DEFAULT ? this.next() : this.expect([this.tok.T_CASE, this.tok.T_DEFAULT]), this.expect([":", ";"]) && this.next();
      for (var n2 = this.node("block"), s2 = []; this.token !== this.EOF && this.token !== t2 && this.token !== this.tok.T_CASE && this.token !== this.tok.T_DEFAULT; )
        s2.push(this.read_inner_statement());
      return e2(i2, n2(null, s2));
    } };
    V.read_switch, V.read_switch_case_list, V.read_case_list;
    var Q = { read_try: function() {
      this.expect(this.tok.T_TRY);
      for (var t2 = this.node("try"), e2 = null, i2 = [], n2 = this.next().read_statement(); this.token === this.tok.T_CATCH; ) {
        var s2 = this.node("catch");
        this.next().expect("(") && this.next();
        var r2 = this.read_list(this.read_namespace_name, "|", false), o2 = null;
        (this.version < 800 || this.token === this.tok.T_VARIABLE) && (o2 = this.read_variable(true, false)), this.expect(")"), i2.push(s2(this.next().read_statement(), r2, o2));
      }
      return this.token === this.tok.T_FINALLY && (e2 = this.next().read_statement()), t2(n2, i2, e2);
    } };
    Q.read_try;
    var W = { read_short_form: function(t2) {
      var e2 = this.node("block"), i2 = [];
      for (this.expect(":") && this.next(); this.token != this.EOF && this.token !== t2; )
        i2.push(this.read_inner_statement());
      return 0 === i2.length && this.extractDoc && this._docs.length > this._docIndex && i2.push(this.node("noop")()), this.expect(t2) && this.next(), this.expectEndOfStatement(), e2(null, i2);
    }, read_function_list: function(t2, e2) {
      var i2 = [];
      do {
        if (this.token == e2 && this.version >= 703 && i2.length > 0) {
          i2.push(this.node("noop")());
          break;
        }
        if (i2.push(t2.apply(this, [])), this.token != e2)
          break;
        if (")" == this.next().token && this.version >= 703)
          break;
      } while (this.token != this.EOF);
      return i2;
    }, read_list: function(t2, e2, i2) {
      var n2 = [];
      if (this.token == e2 && (i2 && n2.push("function" == typeof t2 ? this.node("noop")() : null), this.next()), "function" == typeof t2)
        do {
          var s2 = t2.apply(this, []);
          if (s2 && n2.push(s2), this.token != e2)
            break;
        } while (this.next().token != this.EOF);
      else {
        if (!this.expect(t2))
          return [];
        for (n2.push(this.text()); this.next().token != this.EOF && this.token == e2 && this.next().token == t2; )
          n2.push(this.text());
      }
      return n2;
    }, read_name_list: function() {
      return this.read_list(this.read_namespace_name, ",", false);
    }, read_byref: function(t2) {
      var e2 = this.node("byref");
      this.next(), e2 = e2(null);
      var i2 = t2();
      return i2 && (this.ast.swapLocations(i2, e2, i2, this), i2.byref = true), i2;
    }, read_variable_declarations: function() {
      return this.read_list(function() {
        var t2 = this.node("staticvariable"), e2 = this.node("variable");
        if (this.expect(this.tok.T_VARIABLE)) {
          var i2 = this.text().substring(1);
          this.next(), e2 = e2(i2, false);
        } else
          e2 = e2("#ERR", false);
        return "=" === this.token ? t2(e2, this.next().read_expr()) : e2;
      }, ",");
    }, read_extends_from: function() {
      return this.token === this.tok.T_EXTENDS ? this.next().read_namespace_name() : null;
    }, read_interface_extends_list: function() {
      return this.token === this.tok.T_EXTENDS ? this.next().read_name_list() : null;
    }, read_implements_list: function() {
      return this.token === this.tok.T_IMPLEMENTS ? this.next().read_name_list() : null;
    } };
    W.read_short_form, W.read_function_list, W.read_list, W.read_name_list, W.read_byref, W.read_variable_declarations, W.read_extends_from, W.read_interface_extends_list, W.read_implements_list;
    var Y = { read_variable: function(t2, e2) {
      var i2;
      if ("&" === this.token)
        return this.read_byref(this.read_variable.bind(this, t2, e2));
      if (this.is([this.tok.T_VARIABLE, "$"]))
        i2 = this.read_reference_variable(e2);
      else if (this.is([this.tok.T_NS_SEPARATOR, this.tok.T_STRING, this.tok.T_NAME_RELATIVE, this.tok.T_NAME_QUALIFIED, this.tok.T_NAME_FULLY_QUALIFIED, this.tok.T_NAMESPACE])) {
        i2 = this.node();
        var n2 = this.read_namespace_name();
        if (this.token != this.tok.T_DOUBLE_COLON && "(" != this.token && -1 === ["parentreference", "selfreference"].indexOf(n2.kind)) {
          var s2 = n2.name.toLowerCase();
          "true" === s2 ? i2 = n2.destroy(i2("boolean", true, n2.name)) : "false" === s2 ? i2 = n2.destroy(i2("boolean", false, n2.name)) : "null" === s2 ? i2 = n2.destroy(i2("nullkeyword", n2.name)) : (i2.destroy(n2), i2 = n2);
        } else
          i2.destroy(n2), i2 = n2;
      } else if (this.token === this.tok.T_STATIC) {
        i2 = this.node("staticreference");
        var r2 = this.text();
        this.next(), i2 = i2(r2);
      } else
        this.expect("VARIABLE");
      return this.token === this.tok.T_DOUBLE_COLON && (i2 = this.read_static_getter(i2, e2)), this.recursive_variable_chain_scan(i2, t2, e2);
    }, read_static_getter: function(t2, e2) {
      var i2, n2, s2 = this.node("staticlookup");
      return this.next().is([this.tok.T_VARIABLE, "$"]) ? i2 = this.read_reference_variable(e2) : this.token === this.tok.T_STRING || this.token === this.tok.T_CLASS || this.version >= 700 && this.is("IDENTIFIER") ? (i2 = this.node("identifier"), n2 = this.text(), this.next(), i2 = i2(n2)) : "{" === this.token ? (i2 = this.node("literal"), n2 = this.next().read_expr(), this.expect("}") && this.next(), i2 = i2("literal", n2, null), this.expect("(")) : (this.error([this.tok.T_VARIABLE, this.tok.T_STRING]), i2 = this.node("identifier"), n2 = this.text(), this.next(), i2 = i2(n2)), s2(t2, i2);
    }, read_what: function() {
      var t2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], e2 = null, i2 = null;
      switch (this.next().token) {
        case this.tok.T_STRING:
          e2 = this.node("identifier"), i2 = this.text(), this.next(), e2 = e2(i2), t2 && this.token === this.tok.T_OBJECT_OPERATOR && this.error();
          break;
        case this.tok.T_VARIABLE:
          e2 = this.node("variable"), i2 = this.text().substring(1), this.next(), e2 = e2(i2, false);
          break;
        case "$":
          e2 = this.node(), this.next().expect(["$", "{", this.tok.T_VARIABLE]), "{" === this.token ? (i2 = this.next().read_expr(), this.expect("}") && this.next(), e2 = e2("variable", i2, true)) : e2 = e2("variable", i2 = this.read_expr(), false);
          break;
        case "{":
          e2 = this.node("encapsedpart"), i2 = this.next().read_expr(), this.expect("}") && this.next(), e2 = e2(i2, "complex", false);
          break;
        default:
          this.error([this.tok.T_STRING, this.tok.T_VARIABLE, "$", "{"]), e2 = this.node("identifier"), i2 = this.text(), this.next(), e2 = e2(i2);
      }
      return e2;
    }, recursive_variable_chain_scan: function(t2, e2, i2) {
      var n2, s2;
      t:
        for (; this.token != this.EOF; )
          switch (this.token) {
            case "(":
              if (e2)
                return t2;
              t2 = this.node("call")(t2, this.read_argument_list());
              break;
            case "[":
            case "{":
              var r2 = "[" === this.token;
              if (n2 = this.node("offsetlookup"), this.next(), s2 = false, i2)
                s2 = this.read_encaps_var_offset(), this.expect(r2 ? "]" : "}") && this.next();
              else
                (r2 ? "]" !== this.token : "}" !== this.token) ? (s2 = this.read_expr(), this.expect(r2 ? "]" : "}") && this.next()) : this.next();
              t2 = n2(t2, s2);
              break;
            case this.tok.T_DOUBLE_COLON:
              "staticlookup" === t2.kind && "identifier" === t2.offset.kind && this.error(), t2 = (n2 = this.node("staticlookup"))(t2, this.read_what(true));
              break;
            case this.tok.T_OBJECT_OPERATOR:
              t2 = (n2 = this.node("propertylookup"))(t2, this.read_what());
              break;
            case this.tok.T_NULLSAFE_OBJECT_OPERATOR:
              t2 = (n2 = this.node("nullsafepropertylookup"))(t2, this.read_what());
              break;
            default:
              break t;
          }
      return t2;
    }, read_encaps_var_offset: function() {
      var t2 = this.node();
      if (this.token === this.tok.T_STRING) {
        var e2 = this.text();
        this.next(), t2 = t2("identifier", e2);
      } else if (this.token === this.tok.T_NUM_STRING) {
        var i2 = this.text();
        this.next(), t2 = t2("number", i2, null);
      } else if ("-" === this.token) {
        this.next();
        var n2 = -1 * this.text();
        this.expect(this.tok.T_NUM_STRING) && this.next(), t2 = t2("number", n2, null);
      } else if (this.token === this.tok.T_VARIABLE) {
        var s2 = this.text().substring(1);
        this.next(), t2 = t2("variable", s2, false);
      } else {
        this.expect([this.tok.T_STRING, this.tok.T_NUM_STRING, "-", this.tok.T_VARIABLE]);
        var r2 = this.text();
        this.next(), t2 = t2("identifier", r2);
      }
      return t2;
    }, read_reference_variable: function(t2) {
      for (var e2, i2 = this.read_simple_variable(); this.token != this.EOF; ) {
        var n2 = this.node();
        if ("{" != this.token || t2) {
          n2.destroy();
          break;
        }
        e2 = this.next().read_expr(), this.expect("}") && this.next(), i2 = n2("offsetlookup", i2, e2);
      }
      return i2;
    }, read_simple_variable: function() {
      var t2, e2 = this.node("variable");
      if (this.expect([this.tok.T_VARIABLE, "$"]) && this.token === this.tok.T_VARIABLE)
        t2 = this.text().substring(1), this.next(), e2 = e2(t2, false);
      else
        switch ("$" === this.token && this.next(), this.token) {
          case "{":
            var i2 = this.next().read_expr();
            this.expect("}") && this.next(), e2 = e2(i2, true);
            break;
          case "$":
            e2 = e2(this.read_simple_variable(), false);
            break;
          case this.tok.T_VARIABLE:
            t2 = this.text().substring(1);
            var n2 = this.node("variable");
            this.next(), e2 = e2(n2(t2, false), false);
            break;
          default:
            this.error(["{", "$", this.tok.T_VARIABLE]), t2 = this.text(), this.next(), e2 = e2(t2, false);
        }
      return e2;
    } };
    function j(t2) {
      return "." != t2 && "," != t2 && !isNaN(parseFloat(t2)) && isFinite(t2);
    }
    Y.read_variable, Y.read_static_getter, Y.read_what, Y.recursive_variable_chain_scan, Y.read_encaps_var_offset, Y.read_reference_variable, Y.read_simple_variable;
    var $2 = function(t2, e2) {
      this.lexer = t2, this.ast = e2, this.tok = t2.tok, this.EOF = t2.EOF, this.token = null, this.prev = null, this.debug = false, this.version = 801, this.extractDoc = false, this.extractTokens = false, this.suppressErrors = false;
      var i2 = function(t3) {
        return [t3, null];
      };
      this.entries = { IDENTIFIER: new Map([this.tok.T_ABSTRACT, this.tok.T_ARRAY, this.tok.T_AS, this.tok.T_BREAK, this.tok.T_CALLABLE, this.tok.T_CASE, this.tok.T_CATCH, this.tok.T_CLASS, this.tok.T_CLASS_C, this.tok.T_CLONE, this.tok.T_CONST, this.tok.T_CONTINUE, this.tok.T_DECLARE, this.tok.T_DEFAULT, this.tok.T_DIR, this.tok.T_DO, this.tok.T_ECHO, this.tok.T_ELSE, this.tok.T_ELSEIF, this.tok.T_EMPTY, this.tok.T_ENDDECLARE, this.tok.T_ENDFOR, this.tok.T_ENDFOREACH, this.tok.T_ENDIF, this.tok.T_ENDSWITCH, this.tok.T_ENDWHILE, this.tok.T_ENUM, this.tok.T_EVAL, this.tok.T_EXIT, this.tok.T_EXTENDS, this.tok.T_FILE, this.tok.T_FINAL, this.tok.T_FINALLY, this.tok.T_FN, this.tok.T_FOR, this.tok.T_FOREACH, this.tok.T_FUNC_C, this.tok.T_FUNCTION, this.tok.T_GLOBAL, this.tok.T_GOTO, this.tok.T_IF, this.tok.T_IMPLEMENTS, this.tok.T_INCLUDE, this.tok.T_INCLUDE_ONCE, this.tok.T_INSTANCEOF, this.tok.T_INSTEADOF, this.tok.T_INTERFACE, this.tok.T_ISSET, this.tok.T_LINE, this.tok.T_LIST, this.tok.T_LOGICAL_AND, this.tok.T_LOGICAL_OR, this.tok.T_LOGICAL_XOR, this.tok.T_MATCH, this.tok.T_METHOD_C, this.tok.T_NAMESPACE, this.tok.T_NEW, this.tok.T_NS_C, this.tok.T_PRINT, this.tok.T_PRIVATE, this.tok.T_PROTECTED, this.tok.T_PUBLIC, this.tok.T_READ_ONLY, this.tok.T_REQUIRE, this.tok.T_REQUIRE_ONCE, this.tok.T_RETURN, this.tok.T_STATIC, this.tok.T_SWITCH, this.tok.T_THROW, this.tok.T_TRAIT, this.tok.T_TRY, this.tok.T_UNSET, this.tok.T_USE, this.tok.T_VAR, this.tok.T_WHILE, this.tok.T_YIELD].map(i2)), VARIABLE: new Map([this.tok.T_VARIABLE, "$", "&", this.tok.T_STRING, this.tok.T_NAME_RELATIVE, this.tok.T_NAME_QUALIFIED, this.tok.T_NAME_FULLY_QUALIFIED, this.tok.T_NAMESPACE, this.tok.T_STATIC].map(i2)), SCALAR: new Map([this.tok.T_CONSTANT_ENCAPSED_STRING, this.tok.T_START_HEREDOC, this.tok.T_LNUMBER, this.tok.T_DNUMBER, this.tok.T_ARRAY, "[", this.tok.T_CLASS_C, this.tok.T_TRAIT_C, this.tok.T_FUNC_C, this.tok.T_METHOD_C, this.tok.T_LINE, this.tok.T_FILE, this.tok.T_DIR, this.tok.T_NS_C, '"', 'b"', 'B"', "-", this.tok.T_NS_SEPARATOR].map(i2)), T_MAGIC_CONST: new Map([this.tok.T_CLASS_C, this.tok.T_TRAIT_C, this.tok.T_FUNC_C, this.tok.T_METHOD_C, this.tok.T_LINE, this.tok.T_FILE, this.tok.T_DIR, this.tok.T_NS_C].map(i2)), T_MEMBER_FLAGS: new Map([this.tok.T_PUBLIC, this.tok.T_PRIVATE, this.tok.T_PROTECTED, this.tok.T_STATIC, this.tok.T_ABSTRACT, this.tok.T_FINAL].map(i2)), EOS: new Map([";", this.EOF, this.tok.T_INLINE_HTML].map(i2)), EXPR: new Map(["@", "-", "+", "!", "~", "(", "`", this.tok.T_LIST, this.tok.T_CLONE, this.tok.T_INC, this.tok.T_DEC, this.tok.T_NEW, this.tok.T_ISSET, this.tok.T_EMPTY, this.tok.T_MATCH, this.tok.T_INCLUDE, this.tok.T_INCLUDE_ONCE, this.tok.T_REQUIRE, this.tok.T_REQUIRE_ONCE, this.tok.T_EVAL, this.tok.T_INT_CAST, this.tok.T_DOUBLE_CAST, this.tok.T_STRING_CAST, this.tok.T_ARRAY_CAST, this.tok.T_OBJECT_CAST, this.tok.T_BOOL_CAST, this.tok.T_UNSET_CAST, this.tok.T_EXIT, this.tok.T_PRINT, this.tok.T_YIELD, this.tok.T_STATIC, this.tok.T_FUNCTION, this.tok.T_FN, this.tok.T_VARIABLE, "$", this.tok.T_NS_SEPARATOR, this.tok.T_STRING, this.tok.T_NAME_RELATIVE, this.tok.T_NAME_QUALIFIED, this.tok.T_NAME_FULLY_QUALIFIED, this.tok.T_STRING, this.tok.T_CONSTANT_ENCAPSED_STRING, this.tok.T_START_HEREDOC, this.tok.T_LNUMBER, this.tok.T_DNUMBER, this.tok.T_ARRAY, "[", this.tok.T_CLASS_C, this.tok.T_TRAIT_C, this.tok.T_FUNC_C, this.tok.T_METHOD_C, this.tok.T_LINE, this.tok.T_FILE, this.tok.T_DIR, this.tok.T_NS_C, '"', 'b"', 'B"', "-", this.tok.T_NS_SEPARATOR].map(i2)) };
    };
    $2.prototype.getTokenName = function(t2) {
      return j(t2) ? t2 == this.EOF ? "the end of file (EOF)" : this.lexer.engine.tokens.values[t2] : "'" + t2 + "'";
    }, $2.prototype.parse = function(t2, e2) {
      this._errors = [], this.filename = e2 || "eval", this.currentNamespace = [""], this.extractDoc ? this._docs = [] : this._docs = null, this.extractTokens ? this._tokens = [] : this._tokens = null, this._docIndex = 0, this._lastNode = null, this.lexer.setInput(t2), this.lexer.all_tokens = this.extractTokens, this.lexer.comment_tokens = this.extractDoc, this.length = this.lexer._input.length, this.innerList = false, this.innerListForm = false;
      var i2 = this.node("program"), n2 = [];
      for (this.next(); this.token != this.EOF; )
        n2.push(this.read_start());
      0 === n2.length && this.extractDoc && this._docs.length > this._docIndex && n2.push(this.node("noop")()), this.prev = [this.lexer.yylloc.last_line, this.lexer.yylloc.last_column, this.lexer.offset];
      var s2 = i2(n2, this._errors, this._docs, this._tokens);
      if (this.debug) {
        var r2 = this.ast.checkNodes();
        if (r2.length > 0)
          throw r2.forEach(function(t3) {
            t3.position && console.log("Node at line " + t3.position.line + ", column " + t3.position.column), console.log(t3.stack.join("\n"));
          }), new Error("Some nodes are not closed");
      }
      return s2;
    }, $2.prototype.raiseError = function(t2, e2, i2, n2) {
      if (t2 += " on line " + this.lexer.yylloc.first_line, !this.suppressErrors) {
        var s2 = new SyntaxError(t2, this.filename, this.lexer.yylloc.first_line);
        throw s2.lineNumber = this.lexer.yylloc.first_line, s2.fileName = this.filename, s2.columnNumber = this.lexer.yylloc.first_column, s2;
      }
      var r2 = this.ast.prepare("error", null, this)(t2, n2, this.lexer.yylloc.first_line, i2);
      return this._errors.push(r2), r2;
    }, $2.prototype.error = function(t2) {
      var e2 = "Parse Error : syntax error", i2 = this.getTokenName(this.token), n2 = "";
      if (this.token !== this.EOF) {
        if (j(this.token)) {
          var s2 = this.text();
          s2.length > 10 && (s2 = s2.substring(0, 7) + "..."), i2 = "'" + s2 + "' (" + i2 + ")";
        }
        e2 += ", unexpected " + i2;
      }
      return t2 && !Array.isArray(t2) && ((j(t2) || 1 === t2.length) && (n2 = ", expecting " + this.getTokenName(t2)), e2 += n2), this.raiseError(e2, n2, t2, i2);
    }, $2.prototype.position = function() {
      return new b(this.lexer.yylloc.first_line, this.lexer.yylloc.first_column, this.lexer.yylloc.first_offset);
    }, $2.prototype.node = function(t2) {
      if (this.extractDoc) {
        var e2 = null;
        this._docIndex < this._docs.length && (e2 = this._docs.slice(this._docIndex), this._docIndex = this._docs.length, this.debug && (console.log(new Error("Append docs on " + t2)), console.log(e2)));
        var i2 = this.ast.prepare(t2, e2, this);
        return i2.postBuild = (function(t3) {
          if (this._docIndex < this._docs.length)
            if (this._lastNode) {
              for (var e3 = this.prev[2], i3 = this._docIndex; i3 < this._docs.length && !(this._docs[i3].offset > e3); i3++)
                ;
              i3 > this._docIndex && (this._lastNode.setTrailingComments(this._docs.slice(this._docIndex, i3)), this._docIndex = i3);
            } else
              this.token === this.EOF && (t3.setTrailingComments(this._docs.slice(this._docIndex)), this._docIndex = this._docs.length);
          this._lastNode = t3;
        }).bind(this), i2;
      }
      return this.ast.prepare(t2, null, this);
    }, $2.prototype.expectEndOfStatement = function(t2) {
      if (";" === this.token)
        t2 && ";" === this.lexer.yytext && t2.includeToken(this);
      else if (this.token !== this.tok.T_INLINE_HTML && this.token !== this.EOF)
        return this.error(";"), false;
      return this.next(), true;
    };
    var z = ["parser.next", "parser.node", "parser.showlog"];
    $2.prototype.showlog = function() {
      for (var t2, e2 = new Error().stack.split("\n"), i2 = 2; i2 < e2.length; i2++) {
        t2 = e2[i2].trim();
        for (var n2 = false, s2 = 0; s2 < z.length; s2++)
          if (t2.substring(3, 3 + z[s2].length) === z[s2]) {
            n2 = true;
            break;
          }
        if (!n2)
          break;
      }
      return console.log("Line " + this.lexer.yylloc.first_line + " : " + this.getTokenName(this.token) + ">" + this.lexer.yytext + "< @-->" + t2), this;
    }, $2.prototype.expect = function(t2) {
      if (Array.isArray(t2)) {
        if (-1 === t2.indexOf(this.token))
          return this.error(t2), false;
      } else if (this.token != t2)
        return this.error(t2), false;
      return true;
    }, $2.prototype.text = function() {
      return this.lexer.yytext;
    }, $2.prototype.next = function() {
      if (";" === this.token && ";" !== this.lexer.yytext || (this.prev = [this.lexer.yylloc.last_line, this.lexer.yylloc.last_column, this.lexer.offset]), this.lex(), this.debug && this.showlog(), this.extractDoc)
        for (; this.token === this.tok.T_COMMENT || this.token === this.tok.T_DOC_COMMENT; )
          this.token === this.tok.T_COMMENT ? this._docs.push(this.read_comment()) : this._docs.push(this.read_doc_comment());
      return this;
    }, $2.prototype.peek = function() {
      var t2 = this.lexer.getState(), e2 = this.lexer.lex();
      return this.lexer.setState(t2), e2;
    }, $2.prototype.lex = function() {
      if (this.extractTokens)
        do {
          if (this.token = this.lexer.lex() || this.EOF, this.token === this.EOF)
            return this;
          var t2 = this.lexer.yytext;
          if (t2 = Object.prototype.hasOwnProperty.call(this.lexer.engine.tokens.values, this.token) ? [this.lexer.engine.tokens.values[this.token], t2, this.lexer.yylloc.first_line, this.lexer.yylloc.first_offset, this.lexer.offset] : [null, t2, this.lexer.yylloc.first_line, this.lexer.yylloc.first_offset, this.lexer.offset], this._tokens.push(t2), this.token === this.tok.T_CLOSE_TAG)
            return this.token = ";", this;
          if (this.token === this.tok.T_OPEN_TAG_WITH_ECHO)
            return this.token = this.tok.T_ECHO, this;
        } while (this.token === this.tok.T_WHITESPACE || !this.extractDoc && (this.token === this.tok.T_COMMENT || this.token === this.tok.T_DOC_COMMENT) || this.token === this.tok.T_OPEN_TAG);
      else
        this.token = this.lexer.lex() || this.EOF;
      return this;
    }, $2.prototype.is = function(t2) {
      return Array.isArray(t2) ? -1 !== t2.indexOf(this.token) : this.entries[t2].has(this.token);
    }, [I2, S, O, R2, w, D, P, U2, M2, F, H, G, V, Q, W, Y].forEach(function(t2) {
      for (var e2 in t2) {
        if (Object.prototype.hasOwnProperty.call($2.prototype, e2))
          throw new Error("Function " + e2 + " is already defined - collision");
        $2.prototype[e2] = t2[e2];
      }
    });
    var K2 = $2, X = Object.freeze({ values: { 101: "T_HALT_COMPILER", 102: "T_USE", 103: "T_ENCAPSED_AND_WHITESPACE", 104: "T_OBJECT_OPERATOR", 105: "T_STRING", 106: "T_DOLLAR_OPEN_CURLY_BRACES", 107: "T_STRING_VARNAME", 108: "T_CURLY_OPEN", 109: "T_NUM_STRING", 110: "T_ISSET", 111: "T_EMPTY", 112: "T_INCLUDE", 113: "T_INCLUDE_ONCE", 114: "T_EVAL", 115: "T_REQUIRE", 116: "T_REQUIRE_ONCE", 117: "T_NAMESPACE", 118: "T_NS_SEPARATOR", 119: "T_AS", 120: "T_IF", 121: "T_ENDIF", 122: "T_WHILE", 123: "T_DO", 124: "T_FOR", 125: "T_SWITCH", 126: "T_BREAK", 127: "T_CONTINUE", 128: "T_RETURN", 129: "T_GLOBAL", 130: "T_STATIC", 131: "T_ECHO", 132: "T_INLINE_HTML", 133: "T_UNSET", 134: "T_FOREACH", 135: "T_DECLARE", 136: "T_TRY", 137: "T_THROW", 138: "T_GOTO", 139: "T_FINALLY", 140: "T_CATCH", 141: "T_ENDDECLARE", 142: "T_LIST", 143: "T_CLONE", 144: "T_PLUS_EQUAL", 145: "T_MINUS_EQUAL", 146: "T_MUL_EQUAL", 147: "T_DIV_EQUAL", 148: "T_CONCAT_EQUAL", 149: "T_MOD_EQUAL", 150: "T_AND_EQUAL", 151: "T_OR_EQUAL", 152: "T_XOR_EQUAL", 153: "T_SL_EQUAL", 154: "T_SR_EQUAL", 155: "T_INC", 156: "T_DEC", 157: "T_BOOLEAN_OR", 158: "T_BOOLEAN_AND", 159: "T_LOGICAL_OR", 160: "T_LOGICAL_AND", 161: "T_LOGICAL_XOR", 162: "T_SL", 163: "T_SR", 164: "T_IS_IDENTICAL", 165: "T_IS_NOT_IDENTICAL", 166: "T_IS_EQUAL", 167: "T_IS_NOT_EQUAL", 168: "T_IS_SMALLER_OR_EQUAL", 169: "T_IS_GREATER_OR_EQUAL", 170: "T_INSTANCEOF", 171: "T_INT_CAST", 172: "T_DOUBLE_CAST", 173: "T_STRING_CAST", 174: "T_ARRAY_CAST", 175: "T_OBJECT_CAST", 176: "T_BOOL_CAST", 177: "T_UNSET_CAST", 178: "T_EXIT", 179: "T_PRINT", 180: "T_YIELD", 181: "T_YIELD_FROM", 182: "T_FUNCTION", 183: "T_DOUBLE_ARROW", 184: "T_DOUBLE_COLON", 185: "T_ARRAY", 186: "T_CALLABLE", 187: "T_CLASS", 188: "T_ABSTRACT", 189: "T_TRAIT", 190: "T_FINAL", 191: "T_EXTENDS", 192: "T_INTERFACE", 193: "T_IMPLEMENTS", 194: "T_VAR", 195: "T_PUBLIC", 196: "T_PROTECTED", 197: "T_PRIVATE", 198: "T_CONST", 199: "T_NEW", 200: "T_INSTEADOF", 201: "T_ELSEIF", 202: "T_ELSE", 203: "T_ENDSWITCH", 204: "T_CASE", 205: "T_DEFAULT", 206: "T_ENDFOR", 207: "T_ENDFOREACH", 208: "T_ENDWHILE", 209: "T_CONSTANT_ENCAPSED_STRING", 210: "T_LNUMBER", 211: "T_DNUMBER", 212: "T_LINE", 213: "T_FILE", 214: "T_DIR", 215: "T_TRAIT_C", 216: "T_METHOD_C", 217: "T_FUNC_C", 218: "T_NS_C", 219: "T_START_HEREDOC", 220: "T_END_HEREDOC", 221: "T_CLASS_C", 222: "T_VARIABLE", 223: "T_OPEN_TAG", 224: "T_OPEN_TAG_WITH_ECHO", 225: "T_CLOSE_TAG", 226: "T_WHITESPACE", 227: "T_COMMENT", 228: "T_DOC_COMMENT", 229: "T_ELLIPSIS", 230: "T_COALESCE", 231: "T_POW", 232: "T_POW_EQUAL", 233: "T_SPACESHIP", 234: "T_COALESCE_EQUAL", 235: "T_FN", 236: "T_NULLSAFE_OBJECT_OPERATOR", 237: "T_MATCH", 238: "T_ATTRIBUTE", 239: "T_ENUM", 240: "T_READ_ONLY", 241: "T_NAME_RELATIVE", 242: "T_NAME_QUALIFIED", 243: "T_NAME_FULLY_QUALIFIED" }, names: { T_HALT_COMPILER: 101, T_USE: 102, T_ENCAPSED_AND_WHITESPACE: 103, T_OBJECT_OPERATOR: 104, T_STRING: 105, T_DOLLAR_OPEN_CURLY_BRACES: 106, T_STRING_VARNAME: 107, T_CURLY_OPEN: 108, T_NUM_STRING: 109, T_ISSET: 110, T_EMPTY: 111, T_INCLUDE: 112, T_INCLUDE_ONCE: 113, T_EVAL: 114, T_REQUIRE: 115, T_REQUIRE_ONCE: 116, T_NAMESPACE: 117, T_NS_SEPARATOR: 118, T_AS: 119, T_IF: 120, T_ENDIF: 121, T_WHILE: 122, T_DO: 123, T_FOR: 124, T_SWITCH: 125, T_BREAK: 126, T_CONTINUE: 127, T_RETURN: 128, T_GLOBAL: 129, T_STATIC: 130, T_ECHO: 131, T_INLINE_HTML: 132, T_UNSET: 133, T_FOREACH: 134, T_DECLARE: 135, T_TRY: 136, T_THROW: 137, T_GOTO: 138, T_FINALLY: 139, T_CATCH: 140, T_ENDDECLARE: 141, T_LIST: 142, T_CLONE: 143, T_PLUS_EQUAL: 144, T_MINUS_EQUAL: 145, T_MUL_EQUAL: 146, T_DIV_EQUAL: 147, T_CONCAT_EQUAL: 148, T_MOD_EQUAL: 149, T_AND_EQUAL: 150, T_OR_EQUAL: 151, T_XOR_EQUAL: 152, T_SL_EQUAL: 153, T_SR_EQUAL: 154, T_INC: 155, T_DEC: 156, T_BOOLEAN_OR: 157, T_BOOLEAN_AND: 158, T_LOGICAL_OR: 159, T_LOGICAL_AND: 160, T_LOGICAL_XOR: 161, T_SL: 162, T_SR: 163, T_IS_IDENTICAL: 164, T_IS_NOT_IDENTICAL: 165, T_IS_EQUAL: 166, T_IS_NOT_EQUAL: 167, T_IS_SMALLER_OR_EQUAL: 168, T_IS_GREATER_OR_EQUAL: 169, T_INSTANCEOF: 170, T_INT_CAST: 171, T_DOUBLE_CAST: 172, T_STRING_CAST: 173, T_ARRAY_CAST: 174, T_OBJECT_CAST: 175, T_BOOL_CAST: 176, T_UNSET_CAST: 177, T_EXIT: 178, T_PRINT: 179, T_YIELD: 180, T_YIELD_FROM: 181, T_FUNCTION: 182, T_DOUBLE_ARROW: 183, T_DOUBLE_COLON: 184, T_ARRAY: 185, T_CALLABLE: 186, T_CLASS: 187, T_ABSTRACT: 188, T_TRAIT: 189, T_FINAL: 190, T_EXTENDS: 191, T_INTERFACE: 192, T_IMPLEMENTS: 193, T_VAR: 194, T_PUBLIC: 195, T_PROTECTED: 196, T_PRIVATE: 197, T_CONST: 198, T_NEW: 199, T_INSTEADOF: 200, T_ELSEIF: 201, T_ELSE: 202, T_ENDSWITCH: 203, T_CASE: 204, T_DEFAULT: 205, T_ENDFOR: 206, T_ENDFOREACH: 207, T_ENDWHILE: 208, T_CONSTANT_ENCAPSED_STRING: 209, T_LNUMBER: 210, T_DNUMBER: 211, T_LINE: 212, T_FILE: 213, T_DIR: 214, T_TRAIT_C: 215, T_METHOD_C: 216, T_FUNC_C: 217, T_NS_C: 218, T_START_HEREDOC: 219, T_END_HEREDOC: 220, T_CLASS_C: 221, T_VARIABLE: 222, T_OPEN_TAG: 223, T_OPEN_TAG_WITH_ECHO: 224, T_CLOSE_TAG: 225, T_WHITESPACE: 226, T_COMMENT: 227, T_DOC_COMMENT: 228, T_ELLIPSIS: 229, T_COALESCE: 230, T_POW: 231, T_POW_EQUAL: 232, T_SPACESHIP: 233, T_COALESCE_EQUAL: 234, T_FN: 235, T_NULLSAFE_OBJECT_OPERATOR: 236, T_MATCH: 237, T_ATTRIBUTE: 238, T_ENUM: 239, T_READ_ONLY: 240, T_NAME_RELATIVE: 241, T_NAME_QUALIFIED: 242, T_NAME_FULLY_QUALIFIED: 243 } }), J = function(t2, e2, i2) {
      this.source = t2, this.start = e2, this.end = i2;
    }, q = function(t2, e2, i2) {
      this.kind = t2, e2 && (this.leadingComments = e2), i2 && (this.loc = i2);
    };
    q.prototype.setTrailingComments = function(t2) {
      this.trailingComments = t2;
    }, q.prototype.destroy = function(t2) {
      if (!t2)
        throw new Error("Node already initialized, you must swap with another node");
      return this.leadingComments && (t2.leadingComments ? t2.leadingComments = Array.concat(this.leadingComments, t2.leadingComments) : t2.leadingComments = this.leadingComments), this.trailingComments && (t2.trailingComments ? t2.trailingComments = Array.concat(this.trailingComments, t2.trailingComments) : t2.trailingComments = this.trailingComments), t2;
    }, q.prototype.includeToken = function(t2) {
      return this.loc && (this.loc.end && (this.loc.end.line = t2.lexer.yylloc.last_line, this.loc.end.column = t2.lexer.yylloc.last_column, this.loc.end.offset = t2.lexer.offset), t2.ast.withSource && (this.loc.source = t2.lexer._input.substring(this.loc.start.offset, t2.lexer.offset))), this;
    }, q.extends = function(t2, e2) {
      return e2.prototype = Object.create(this.prototype), e2.extends = this.extends, e2.prototype.constructor = e2, e2.kind = t2, e2;
    };
    var Z = q, tt = "expression", et2 = Z.extends(tt, function(t2, e2, i2) {
      Z.apply(this, [t2 || tt, e2, i2]);
    }), it2 = "array", nt = et2.extends(it2, function(t2, e2, i2, n2) {
      et2.apply(this, [it2, i2, n2]), this.items = e2, this.shortForm = t2;
    }), st2 = "arrowfunc", rt2 = et2.extends(st2, function(t2, e2, i2, n2, s2, r2, o2, a2) {
      et2.apply(this, [st2, o2, a2]), this.arguments = t2, this.byref = e2, this.body = i2, this.type = n2, this.nullable = s2, this.isStatic = r2 || false;
    }), ot2 = "assign", at2 = et2.extends(ot2, function(t2, e2, i2, n2, s2) {
      et2.apply(this, [ot2, n2, s2]), this.left = t2, this.right = e2, this.operator = i2;
    }), ht2 = "assignref", lt2 = et2.extends(ht2, function(t2, e2, i2, n2) {
      et2.apply(this, [ht2, i2, n2]), this.left = t2, this.right = e2;
    }), ct2 = "attribute", ut2 = Z.extends(ct2, function(t2, e2, i2, n2) {
      Z.apply(this, [ct2, i2, n2]), this.name = t2, this.args = e2;
    }), _t2 = "attrgroup", dt2 = Z.extends(_t2, function(t2, e2, i2) {
      Z.apply(this, [_t2, e2, i2]), this.attrs = t2 || [];
    }), pt2 = "operation", ft2 = et2.extends(pt2, function(t2, e2, i2) {
      et2.apply(this, [t2 || pt2, e2, i2]);
    }), Tt2 = ft2.extends("bin", function(t2, e2, i2, n2, s2) {
      ft2.apply(this, ["bin", n2, s2]), this.type = t2, this.left = e2, this.right = i2;
    }), kt2 = "statement", Et2 = Z.extends(kt2, function(t2, e2, i2) {
      Z.apply(this, [t2 || kt2, e2, i2]);
    }), mt2 = "block", xt2 = Et2.extends(mt2, function(t2, e2, i2, n2) {
      Et2.apply(this, [t2 || mt2, i2, n2]), this.children = e2.filter(Boolean);
    }), yt2 = "literal", vt2 = et2.extends(yt2, function(t2, e2, i2, n2, s2) {
      et2.apply(this, [t2 || yt2, n2, s2]), this.value = e2, i2 && (this.raw = i2);
    }), At2 = "boolean", gt2 = vt2.extends(At2, function(t2, e2, i2, n2) {
      vt2.apply(this, [At2, t2, e2, i2, n2]);
    }), Nt2 = "break", Lt2 = Et2.extends(Nt2, function(t2, e2, i2) {
      Et2.apply(this, [Nt2, e2, i2]), this.level = t2;
    }), Ct2 = "byref", bt2 = et2.extends(Ct2, function(t2, e2, i2) {
      et2.apply(this, [Ct2, e2, i2]), this.what = t2;
    }), It2 = "call", St2 = et2.extends(It2, function(t2, e2, i2, n2) {
      et2.apply(this, [It2, i2, n2]), this.what = t2, this.arguments = e2;
    }), Ot2 = "case", Rt2 = Et2.extends(Ot2, function(t2, e2, i2, n2) {
      Et2.apply(this, [Ot2, i2, n2]), this.test = t2, this.body = e2;
    }), wt2 = "cast", Dt2 = ft2.extends(wt2, function(t2, e2, i2, n2, s2) {
      ft2.apply(this, [wt2, n2, s2]), this.type = t2, this.raw = e2, this.expr = i2;
    }), Pt2 = "catch", Ut = Et2.extends(Pt2, function(t2, e2, i2, n2, s2) {
      Et2.apply(this, [Pt2, n2, s2]), this.body = t2, this.what = e2, this.variable = i2;
    }), Mt2 = "declaration", Ft2 = Et2.extends(Mt2, function(t2, e2, i2, n2) {
      Et2.apply(this, [t2 || Mt2, i2, n2]), this.name = e2;
    });
    Ft2.prototype.parseFlags = function(t2) {
      this.isAbstract = 1 === t2[2], this.isFinal = 2 === t2[2], "class" !== this.kind && (-1 === t2[0] ? this.visibility = "" : null === t2[0] ? this.visibility = null : 0 === t2[0] ? this.visibility = "public" : 1 === t2[0] ? this.visibility = "protected" : 2 === t2[0] && (this.visibility = "private"), this.isStatic = 1 === t2[1]);
    };
    var Bt2 = Ft2, Ht = "class", Gt2 = Bt2.extends(Ht, function(t2, e2, i2, n2, s2, r2, o2) {
      Bt2.apply(this, [Ht, t2, r2, o2]), this.isAnonymous = !t2, this.extends = e2, this.implements = i2, this.body = n2, this.attrGroups = [], this.parseFlags(s2);
    }), Vt2 = "constantstatement", Qt2 = Et2.extends(Vt2, function(t2, e2, i2, n2) {
      Et2.apply(this, [t2 || Vt2, i2, n2]), this.constants = e2;
    }), Wt = "classconstant", Yt2 = Qt2.extends(Wt, function(t2, e2, i2, n2, s2, r2) {
      Qt2.apply(this, [t2 || Wt, e2, s2, r2]), this.parseFlags(i2), this.attrGroups = n2;
    });
    Yt2.prototype.parseFlags = function(t2) {
      -1 === t2[0] ? this.visibility = "" : null === t2[0] ? this.visibility = null : 0 === t2[0] ? this.visibility = "public" : 1 === t2[0] ? this.visibility = "protected" : 2 === t2[0] && (this.visibility = "private");
    };
    var jt2 = Yt2, $t2 = "clone", zt2 = et2.extends($t2, function(t2, e2, i2) {
      et2.apply(this, [$t2, e2, i2]), this.what = t2;
    }), Kt2 = "closure", Xt2 = et2.extends(Kt2, function(t2, e2, i2, n2, s2, r2, o2, a2) {
      et2.apply(this, [Kt2, o2, a2]), this.uses = i2, this.arguments = t2, this.byref = e2, this.type = n2, this.nullable = s2, this.isStatic = r2 || false, this.body = null, this.attrGroups = [];
    }), Jt2 = Z.extends("comment", function(t2, e2, i2, n2) {
      Z.apply(this, [t2, i2, n2]), this.value = e2;
    }), qt2 = "commentblock", Zt2 = Jt2.extends(qt2, function(t2, e2, i2) {
      Jt2.apply(this, [qt2, t2, e2, i2]);
    }), te2 = "commentline", ee2 = Jt2.extends(te2, function(t2, e2, i2) {
      Jt2.apply(this, [te2, t2, e2, i2]);
    }), ie2 = "constant", ne2 = Z.extends(ie2, function(t2, e2, i2, n2) {
      Z.apply(this, [ie2, i2, n2]), this.name = t2, this.value = e2;
    }), se2 = "continue", re = Et2.extends(se2, function(t2, e2, i2) {
      Et2.apply(this, [se2, e2, i2]), this.level = t2;
    }), oe = "declare", ae2 = xt2.extends(oe, function(t2, e2, i2, n2, s2) {
      xt2.apply(this, [oe, e2, n2, s2]), this.directives = t2, this.mode = i2;
    });
    ae2.MODE_SHORT = "short", ae2.MODE_BLOCK = "block", ae2.MODE_NONE = "none";
    var he2 = ae2, le2 = "declaredirective", ce2 = Z.extends(le2, function(t2, e2, i2, n2) {
      Z.apply(this, [le2, i2, n2]), this.key = t2, this.value = e2;
    }), ue2 = Et2.extends("do", function(t2, e2, i2, n2) {
      Et2.apply(this, ["do", i2, n2]), this.test = t2, this.body = e2;
    }), _e2 = "echo", de = Et2.extends(_e2, function(t2, e2, i2, n2) {
      Et2.apply(this, [_e2, i2, n2]), this.shortForm = e2, this.expressions = t2;
    }), pe2 = "empty", fe2 = et2.extends(pe2, function(t2, e2, i2) {
      et2.apply(this, [pe2, e2, i2]), this.expression = t2;
    }), Te2 = "encapsed", ke2 = vt2.extends(Te2, function(t2, e2, i2, n2, s2) {
      vt2.apply(this, [Te2, t2, e2, n2, s2]), this.type = i2;
    });
    ke2.TYPE_STRING = "string", ke2.TYPE_SHELL = "shell", ke2.TYPE_HEREDOC = "heredoc", ke2.TYPE_OFFSET = "offset";
    var Ee = ke2, me2 = "encapsedpart", xe2 = et2.extends(me2, function(t2, e2, i2, n2, s2) {
      et2.apply(this, [me2, n2, s2]), this.expression = t2, this.syntax = e2, this.curly = i2;
    }), ye2 = "entry", ve2 = et2.extends(ye2, function(t2, e2, i2, n2, s2, r2) {
      et2.apply(this, [ye2, s2, r2]), this.key = t2, this.value = e2, this.byRef = i2, this.unpack = n2;
    }), Ae2 = "enum", ge2 = Bt2.extends(Ae2, function(t2, e2, i2, n2, s2, r2) {
      Bt2.apply(this, [Ae2, t2, s2, r2]), this.valueType = e2, this.implements = i2, this.body = n2, this.attrGroups = [];
    }), Ne2 = "enumcase", Le = Z.extends(Ne2, function(t2, e2, i2, n2) {
      Z.apply(this, [Ne2, i2, n2]), this.name = t2, this.value = e2;
    }), Ce2 = "error", be2 = Z.extends(Ce2, function(t2, e2, i2, n2, s2, r2) {
      Z.apply(this, [Ce2, s2, r2]), this.message = t2, this.token = e2, this.line = i2, this.expected = n2;
    }), Ie2 = "eval", Se2 = et2.extends(Ie2, function(t2, e2, i2) {
      et2.apply(this, [Ie2, e2, i2]), this.source = t2;
    }), Oe2 = "exit", Re2 = et2.extends(Oe2, function(t2, e2, i2, n2) {
      et2.apply(this, [Oe2, i2, n2]), this.expression = t2, this.useDie = e2;
    }), we2 = "expressionstatement", De2 = Et2.extends(we2, function(t2, e2, i2) {
      Et2.apply(this, [we2, e2, i2]), this.expression = t2;
    }), Pe2 = Et2.extends("for", function(t2, e2, i2, n2, s2, r2, o2) {
      Et2.apply(this, ["for", r2, o2]), this.init = t2, this.test = e2, this.increment = i2, this.shortForm = s2, this.body = n2;
    }), Ue2 = "foreach", Me2 = Et2.extends(Ue2, function(t2, e2, i2, n2, s2, r2, o2) {
      Et2.apply(this, [Ue2, r2, o2]), this.source = t2, this.key = e2, this.value = i2, this.shortForm = s2, this.body = n2;
    }), Fe2 = "function", Be = Bt2.extends(Fe2, function(t2, e2, i2, n2, s2, r2, o2) {
      Bt2.apply(this, [Fe2, t2, r2, o2]), this.arguments = e2, this.byref = i2, this.type = n2, this.nullable = s2, this.body = null, this.attrGroups = [];
    }), He2 = "global", Ge2 = Et2.extends(He2, function(t2, e2, i2) {
      Et2.apply(this, [He2, e2, i2]), this.items = t2;
    }), Ve2 = "goto", Qe = Et2.extends(Ve2, function(t2, e2, i2) {
      Et2.apply(this, [Ve2, e2, i2]), this.label = t2;
    }), We2 = "halt", Ye2 = Et2.extends(We2, function(t2, e2, i2) {
      Et2.apply(this, [We2, e2, i2]), this.after = t2;
    }), je2 = "identifier", $e2 = Z.extends(je2, function(t2, e2, i2) {
      Z.apply(this, [je2, e2, i2]), this.name = t2;
    }), ze = $e2, Ke2 = Et2.extends("if", function(t2, e2, i2, n2, s2, r2) {
      Et2.apply(this, ["if", s2, r2]), this.test = t2, this.body = e2, this.alternate = i2, this.shortForm = n2;
    }), Xe = "include", Je2 = et2.extends(Xe, function(t2, e2, i2, n2, s2) {
      et2.apply(this, [Xe, n2, s2]), this.once = t2, this.require = e2, this.target = i2;
    }), qe2 = "inline", Ze2 = vt2.extends(qe2, function(t2, e2, i2, n2) {
      vt2.apply(this, [qe2, t2, e2, i2, n2]);
    }), ti2 = "interface", ei = Bt2.extends(ti2, function(t2, e2, i2, n2, s2, r2) {
      Bt2.apply(this, [ti2, t2, s2, r2]), this.extends = e2, this.body = i2, this.attrGroups = n2;
    }), ii = "intersectiontype", ni = Bt2.extends(ii, function(t2, e2, i2) {
      Bt2.apply(this, [ii, null, e2, i2]), this.types = t2;
    }), si = "isset", ri2 = et2.extends(si, function(t2, e2, i2) {
      et2.apply(this, [si, e2, i2]), this.variables = t2;
    }), oi2 = "label", ai = Et2.extends(oi2, function(t2, e2, i2) {
      Et2.apply(this, [oi2, e2, i2]), this.name = t2;
    }), hi = "list", li = et2.extends(hi, function(t2, e2, i2, n2) {
      et2.apply(this, [hi, i2, n2]), this.items = t2, this.shortForm = e2;
    }), ci = "lookup", ui2 = et2.extends(ci, function(t2, e2, i2, n2, s2) {
      et2.apply(this, [t2 || ci, n2, s2]), this.what = e2, this.offset = i2;
    }), _i2 = "magic", di2 = vt2.extends(_i2, function(t2, e2, i2, n2) {
      vt2.apply(this, [_i2, t2, e2, i2, n2]);
    }), pi2 = "match", fi2 = et2.extends(pi2, function(t2, e2, i2, n2) {
      et2.apply(this, [pi2, i2, n2]), this.cond = t2, this.arms = e2;
    }), Ti2 = "matcharm", ki = et2.extends(Ti2, function(t2, e2, i2, n2) {
      et2.apply(this, [Ti2, i2, n2]), this.conds = t2, this.body = e2;
    }), Ei = "method", mi = Be.extends(Ei, function() {
      Be.apply(this, arguments), this.kind = Ei;
    }), xi = "reference", yi2 = Z.extends(xi, function(t2, e2, i2) {
      Z.apply(this, [t2 || xi, e2, i2]);
    }), vi2 = "name", Ai2 = yi2.extends(vi2, function(t2, e2, i2, n2) {
      yi2.apply(this, [vi2, i2, n2]), this.name = t2.replace(/\\$/, ""), this.resolution = e2;
    });
    Ai2.UNQUALIFIED_NAME = "uqn", Ai2.QUALIFIED_NAME = "qn", Ai2.FULL_QUALIFIED_NAME = "fqn", Ai2.RELATIVE_NAME = "rn";
    var gi = Ai2, Ni2 = "namespace", Li2 = xt2.extends(Ni2, function(t2, e2, i2, n2, s2) {
      xt2.apply(this, [Ni2, e2, n2, s2]), this.name = t2, this.withBrackets = i2 || false;
    }), Ci = "namedargument", bi = et2.extends(Ci, function(t2, e2, i2, n2) {
      et2.apply(this, [Ci, i2, n2]), this.name = t2, this.value = e2;
    }), Ii2 = et2.extends("new", function(t2, e2, i2, n2) {
      et2.apply(this, ["new", i2, n2]), this.what = t2, this.arguments = e2;
    }), Si2 = "noop", Oi2 = Z.extends(Si2, function(t2, e2) {
      Z.apply(this, [Si2, t2, e2]);
    }), Ri = "nowdoc", wi2 = vt2.extends(Ri, function(t2, e2, i2, n2, s2) {
      vt2.apply(this, [Ri, t2, e2, n2, s2]), this.label = i2;
    }), Di2 = "nullkeyword", Pi = Z.extends(Di2, function(t2, e2, i2) {
      Z.apply(this, [Di2, e2, i2]), this.raw = t2;
    }), Ui2 = "nullsafepropertylookup", Mi2 = ui2.extends(Ui2, function(t2, e2, i2, n2) {
      ui2.apply(this, [Ui2, t2, e2, i2, n2]);
    }), Fi2 = "number", Bi2 = vt2.extends(Fi2, function(t2, e2, i2, n2) {
      vt2.apply(this, [Fi2, t2, e2, i2, n2]);
    }), Hi2 = "offsetlookup", Gi = ui2.extends(Hi2, function(t2, e2, i2, n2) {
      ui2.apply(this, [Hi2, t2, e2, i2, n2]);
    }), Vi2 = "parameter", Qi2 = Bt2.extends(Vi2, function(t2, e2, i2, n2, s2, r2, o2, a2, h2, l2) {
      Bt2.apply(this, [Vi2, t2, h2, l2]), this.value = i2, this.type = e2, this.byref = n2, this.variadic = s2, this.readonly = r2, this.nullable = o2, this.flags = a2 || 0, this.attrGroups = [];
    }), Wi2 = "parentreference", Yi2 = yi2.extends(Wi2, function(t2, e2, i2) {
      yi2.apply(this, [Wi2, e2, i2]), this.raw = t2;
    }), ji2 = "post", $i2 = ft2.extends(ji2, function(t2, e2, i2, n2) {
      ft2.apply(this, [ji2, i2, n2]), this.type = t2, this.what = e2;
    }), zi2 = ft2.extends("pre", function(t2, e2, i2, n2) {
      ft2.apply(this, ["pre", i2, n2]), this.type = t2, this.what = e2;
    }), Ki = "print", Xi2 = et2.extends(Ki, function(t2, e2, i2) {
      et2.apply(this, [Ki, e2, i2]), this.expression = t2;
    }), Ji2 = "program", qi = xt2.extends(Ji2, function(t2, e2, i2, n2, s2, r2) {
      xt2.apply(this, [Ji2, t2, s2, r2]), this.errors = e2, i2 && (this.comments = i2), n2 && (this.tokens = n2);
    }), Zi2 = "property", tn2 = Et2.extends(Zi2, function(t2, e2, i2, n2, s2, r2, o2, a2) {
      Et2.apply(this, [Zi2, o2, a2]), this.name = t2, this.value = e2, this.readonly = i2, this.nullable = n2, this.type = s2, this.attrGroups = r2;
    }), en2 = "propertylookup", nn2 = ui2.extends(en2, function(t2, e2, i2, n2) {
      ui2.apply(this, [en2, t2, e2, i2, n2]);
    }), sn2 = "propertystatement", rn2 = Et2.extends(sn2, function(t2, e2, i2, n2, s2) {
      Et2.apply(this, [sn2, n2, s2]), this.properties = e2, this.parseFlags(i2);
    });
    rn2.prototype.parseFlags = function(t2) {
      -1 === t2[0] ? this.visibility = "" : null === t2[0] ? this.visibility = null : 0 === t2[0] ? this.visibility = "public" : 1 === t2[0] ? this.visibility = "protected" : 2 === t2[0] && (this.visibility = "private"), this.isStatic = 1 === t2[1];
    };
    var on = rn2, an2 = "retif", hn2 = et2.extends(an2, function(t2, e2, i2, n2, s2) {
      et2.apply(this, [an2, n2, s2]), this.test = t2, this.trueExpr = e2, this.falseExpr = i2;
    }), ln2 = "return", cn2 = Et2.extends(ln2, function(t2, e2, i2) {
      Et2.apply(this, [ln2, e2, i2]), this.expr = t2;
    }), un2 = "selfreference", _n2 = yi2.extends(un2, function(t2, e2, i2) {
      yi2.apply(this, [un2, e2, i2]), this.raw = t2;
    }), dn2 = "silent", pn2 = et2.extends(dn2, function(t2, e2, i2) {
      et2.apply(this, [dn2, e2, i2]), this.expr = t2;
    }), fn2 = "static", Tn2 = Et2.extends(fn2, function(t2, e2, i2) {
      Et2.apply(this, [fn2, e2, i2]), this.variables = t2;
    }), kn2 = "staticvariable", En2 = Z.extends(kn2, function(t2, e2, i2, n2) {
      Z.apply(this, [kn2, i2, n2]), this.variable = t2, this.defaultValue = e2;
    }), mn2 = "staticlookup", xn2 = ui2.extends(mn2, function(t2, e2, i2, n2) {
      ui2.apply(this, [mn2, t2, e2, i2, n2]);
    }), yn = "staticreference", vn2 = yi2.extends(yn, function(t2, e2, i2) {
      yi2.apply(this, [yn, e2, i2]), this.raw = t2;
    }), An = "string", gn2 = vt2.extends(An, function(t2, e2, i2, n2, s2, r2) {
      vt2.apply(this, [An, e2, n2, s2, r2]), this.unicode = i2, this.isDoubleQuote = t2;
    }), Nn2 = "switch", Ln2 = Et2.extends(Nn2, function(t2, e2, i2, n2, s2) {
      Et2.apply(this, [Nn2, n2, s2]), this.test = t2, this.body = e2, this.shortForm = i2;
    }), Cn2 = "throw", bn2 = Et2.extends(Cn2, function(t2, e2, i2) {
      Et2.apply(this, [Cn2, e2, i2]), this.what = t2;
    }), In2 = "trait", Sn2 = Bt2.extends(In2, function(t2, e2, i2, n2) {
      Bt2.apply(this, [In2, t2, i2, n2]), this.body = e2;
    }), On2 = "traitalias", Rn2 = Z.extends(On2, function(t2, e2, i2, n2, s2, r2) {
      Z.apply(this, [On2, s2, r2]), this.trait = t2, this.method = e2, this.as = i2, this.visibility = "", n2 && (0 === n2[0] ? this.visibility = "public" : 1 === n2[0] ? this.visibility = "protected" : 2 === n2[0] && (this.visibility = "private"));
    }), wn2 = "traitprecedence", Dn2 = Z.extends(wn2, function(t2, e2, i2, n2, s2) {
      Z.apply(this, [wn2, n2, s2]), this.trait = t2, this.method = e2, this.instead = i2;
    }), Pn2 = "traituse", Un2 = Z.extends(Pn2, function(t2, e2, i2, n2) {
      Z.apply(this, [Pn2, i2, n2]), this.traits = t2, this.adaptations = e2;
    }), Mn2 = Et2.extends("try", function(t2, e2, i2, n2, s2) {
      Et2.apply(this, ["try", n2, s2]), this.body = t2, this.catches = e2, this.always = i2;
    }), Fn2 = "typereference", Bn2 = yi2.extends(Fn2, function(t2, e2, i2, n2) {
      yi2.apply(this, [Fn2, i2, n2]), this.name = t2, this.raw = e2;
    });
    Bn2.types = ["int", "float", "string", "bool", "object", "array", "callable", "iterable", "void", "static"];
    var Hn2 = Bn2, Gn2 = "unary", Vn2 = ft2.extends(Gn2, function(t2, e2, i2, n2) {
      ft2.apply(this, [Gn2, i2, n2]), this.type = t2, this.what = e2;
    }), Qn2 = "uniontype", Wn2 = Bt2.extends(Qn2, function(t2, e2, i2) {
      Bt2.apply(this, [Qn2, null, e2, i2]), this.types = t2;
    }), Yn2 = "unset", jn2 = Et2.extends(Yn2, function(t2, e2, i2) {
      Et2.apply(this, [Yn2, e2, i2]), this.variables = t2;
    }), $n2 = "usegroup", zn2 = Et2.extends($n2, function(t2, e2, i2, n2, s2) {
      Et2.apply(this, [$n2, n2, s2]), this.name = t2, this.type = e2, this.items = i2;
    }), Kn2 = "useitem", Xn2 = Et2.extends(Kn2, function(t2, e2, i2, n2, s2) {
      Et2.apply(this, [Kn2, n2, s2]), this.name = t2, this.alias = e2, this.type = i2;
    });
    Xn2.TYPE_CONST = "const", Xn2.TYPE_FUNCTION = "function";
    var Jn2 = Xn2, qn2 = "variable", Zn2 = et2.extends(qn2, function(t2, e2, i2, n2) {
      et2.apply(this, [qn2, i2, n2]), this.name = t2, this.curly = e2 || false;
    }), ts2 = "variadic", es = et2.extends(ts2, function(t2, e2, i2) {
      et2.apply(this, [ts2, e2, i2]), this.what = t2;
    }), is2 = "variadicplaceholder", ns2 = Z.extends(is2, function(t2, e2) {
      Z.apply(this, [is2, t2, e2]);
    }), ss2 = "while", rs2 = Et2.extends(ss2, function(t2, e2, i2, n2, s2) {
      Et2.apply(this, [ss2, n2, s2]), this.test = t2, this.body = e2, this.shortForm = i2;
    }), os2 = "yield", as2 = et2.extends(os2, function(t2, e2, i2, n2) {
      et2.apply(this, [os2, i2, n2]), this.value = t2, this.key = e2;
    }), hs2 = "yieldfrom", ls2 = et2.extends(hs2, function(t2, e2, i2) {
      et2.apply(this, [hs2, e2, i2]), this.value = t2;
    }), cs2 = function(t2, e2) {
      this.withPositions = t2, this.withSource = e2;
    };
    cs2.precedence = {}, [["or"], ["xor"], ["and"], ["="], ["?"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "!=", "===", "!==", "<=>"], ["<", "<=", ">", ">="], ["<<", ">>"], ["+", "-", "."], ["*", "/", "%"], ["!"], ["instanceof"], ["cast", "silent"], ["**"]].forEach(function(t2, e2) {
      t2.forEach(function(t3) {
        cs2.precedence[t3] = e2 + 1;
      });
    }), cs2.prototype.isRightAssociative = function(t2) {
      return "**" === t2 || "??" === t2;
    }, cs2.prototype.swapLocations = function(t2, e2, i2, n2) {
      this.withPositions && (t2.loc.start = e2.loc.start, t2.loc.end = i2.loc.end, this.withSource && (t2.loc.source = n2.lexer._input.substring(t2.loc.start.offset, t2.loc.end.offset)));
    }, cs2.prototype.resolveLocations = function(t2, e2, i2, n2) {
      this.withPositions && (t2.loc.start.offset > e2.loc.start.offset && (t2.loc.start = e2.loc.start), t2.loc.end.offset < i2.loc.end.offset && (t2.loc.end = i2.loc.end), this.withSource && (t2.loc.source = n2.lexer._input.substring(t2.loc.start.offset, t2.loc.end.offset)));
    }, cs2.prototype.resolvePrecedence = function(t2, e2) {
      var i2, n2, s2;
      return "call" === t2.kind ? this.resolveLocations(t2, t2.what, t2, e2) : "propertylookup" === t2.kind || "staticlookup" === t2.kind || "offsetlookup" === t2.kind && t2.offset ? this.resolveLocations(t2, t2.what, t2.offset, e2) : "bin" === t2.kind ? t2.right && !t2.right.parenthesizedExpression && ("bin" === t2.right.kind ? (n2 = cs2.precedence[t2.type], s2 = cs2.precedence[t2.right.type], n2 && s2 && s2 <= n2 && (t2.type !== t2.right.type || !this.isRightAssociative(t2.type)) && (i2 = t2.right, t2.right = t2.right.left, this.swapLocations(t2, t2.left, t2.right, e2), i2.left = this.resolvePrecedence(t2, e2), this.swapLocations(i2, i2.left, i2.right, e2), t2 = i2)) : "retif" === t2.right.kind && (n2 = cs2.precedence[t2.type], s2 = cs2.precedence["?"], n2 && s2 && s2 <= n2 && (i2 = t2.right, t2.right = t2.right.test, this.swapLocations(t2, t2.left, t2.right, e2), i2.test = this.resolvePrecedence(t2, e2), this.swapLocations(i2, i2.test, i2.falseExpr, e2), t2 = i2))) : "silent" !== t2.kind && "cast" !== t2.kind || !t2.expr || t2.expr.parenthesizedExpression ? "unary" === t2.kind ? t2.what && !t2.what.parenthesizedExpression && ("bin" === t2.what.kind ? (i2 = t2.what, t2.what = t2.what.left, this.swapLocations(t2, t2, t2.what, e2), i2.left = this.resolvePrecedence(t2, e2), this.swapLocations(i2, i2.left, i2.right, e2), t2 = i2) : "retif" === t2.what.kind && (i2 = t2.what, t2.what = t2.what.test, this.swapLocations(t2, t2, t2.what, e2), i2.test = this.resolvePrecedence(t2, e2), this.swapLocations(i2, i2.test, i2.falseExpr, e2), t2 = i2)) : "retif" === t2.kind ? t2.falseExpr && "retif" === t2.falseExpr.kind && !t2.falseExpr.parenthesizedExpression && (i2 = t2.falseExpr, t2.falseExpr = i2.test, this.swapLocations(t2, t2.test, t2.falseExpr, e2), i2.test = this.resolvePrecedence(t2, e2), this.swapLocations(i2, i2.test, i2.falseExpr, e2), t2 = i2) : "assign" === t2.kind ? t2.right && "bin" === t2.right.kind && !t2.right.parenthesizedExpression && (n2 = cs2.precedence["="], s2 = cs2.precedence[t2.right.type], n2 && s2 && s2 < n2 && (i2 = t2.right, t2.right = t2.right.left, i2.left = t2, this.swapLocations(i2, i2.left, t2.right, e2), t2 = i2)) : "expressionstatement" === t2.kind && this.swapLocations(t2, t2.expression, t2, e2) : "bin" === t2.expr.kind ? (i2 = t2.expr, t2.expr = t2.expr.left, this.swapLocations(t2, t2, t2.expr, e2), i2.left = this.resolvePrecedence(t2, e2), this.swapLocations(i2, i2.left, i2.right, e2), t2 = i2) : "retif" === t2.expr.kind && (i2 = t2.expr, t2.expr = t2.expr.test, this.swapLocations(t2, t2, t2.expr, e2), i2.test = this.resolvePrecedence(t2, e2), this.swapLocations(i2, i2.test, i2.falseExpr, e2), t2 = i2), t2;
    }, cs2.prototype.prepare = function(t2, e2, i2) {
      var n2 = null;
      (this.withPositions || this.withSource) && (n2 = i2.position());
      var s2 = this, r2 = function r3() {
        var o2 = null, a2 = Array.prototype.slice.call(arguments);
        if (a2.push(e2), s2.withPositions || s2.withSource) {
          var h2 = null;
          s2.withSource && (h2 = i2.lexer._input.substring(n2.offset, i2.prev[2])), o2 = new J(h2, n2, new b(i2.prev[0], i2.prev[1], i2.prev[2])), a2.push(o2);
        }
        t2 || (t2 = a2.shift());
        var l2 = s2[t2];
        if ("function" != typeof l2)
          throw new Error('Undefined node "' + t2 + '"');
        var c2 = Object.create(l2.prototype);
        return l2.apply(c2, a2), r3.instance = c2, r3.trailingComments && (c2.trailingComments = r3.trailingComments), "function" == typeof r3.postBuild && r3.postBuild(c2), i2.debug && delete s2.stack[r3.stackUid], s2.resolvePrecedence(c2, i2);
      };
      return i2.debug && (this.stack || (this.stack = {}, this.stackUid = 1), this.stack[++this.stackUid] = { position: n2, stack: new Error().stack.split("\n").slice(3, 5) }, r2.stackUid = this.stackUid), r2.setTrailingComments = function(t3) {
        r2.instance ? r2.instance.setTrailingComments(t3) : r2.trailingComments = t3;
      }, r2.destroy = function(t3) {
        e2 && (t3 ? t3.leadingComments ? t3.leadingComments = e2.concat(t3.leadingComments) : t3.leadingComments = e2 : i2._docIndex = i2._docs.length - e2.length), i2.debug && delete s2.stack[r2.stackUid];
      }, r2;
    }, cs2.prototype.checkNodes = function() {
      var t2 = [];
      for (var e2 in this.stack)
        Object.prototype.hasOwnProperty.call(this.stack, e2) && (this.stack[e2].key = e2, t2.push(this.stack[e2]));
      return this.stack = {}, t2;
    }, [nt, rt2, at2, lt2, ut2, dt2, Tt2, xt2, gt2, Lt2, bt2, St2, Rt2, Dt2, Ut, Gt2, jt2, zt2, Xt2, Jt2, Zt2, ee2, ne2, Qt2, re, Bt2, he2, ce2, ue2, de, fe2, Ee, xe2, ve2, ge2, Le, be2, Se2, Re2, et2, De2, Pe2, Me2, Be, Ge2, Qe, Ye2, ze, Ke2, Je2, Ze2, ei, ni, ri2, ai, li, vt2, ui2, di2, fi2, ki, mi, gi, Li2, bi, Ii2, Z, Oi2, wi2, Pi, Mi2, Bi2, Gi, ft2, Qi2, Yi2, $i2, zi2, Xi2, qi, tn2, nn2, on, yi2, hn2, cn2, _n2, pn2, Et2, Tn2, En2, xn2, vn2, gn2, Ln2, bn2, Sn2, Rn2, Dn2, Un2, Mn2, Hn2, Vn2, Wn2, jn2, zn2, Jn2, Zn2, es, ns2, rs2, as2, ls2].forEach(function(t2) {
      cs2.prototype[t2.kind] = t2;
    });
    var us2 = cs2;
    function _s2(t2, e2) {
      for (var i2 = Object.keys(t2), n2 = i2.length; n2--; ) {
        var s2 = i2[n2], r2 = t2[s2];
        null === r2 ? delete e2[s2] : "function" == typeof r2 ? e2[s2] = r2.bind(e2) : Array.isArray(r2) ? e2[s2] = Array.isArray(e2[s2]) ? e2[s2].concat(r2) : r2 : "object" === a(r2) ? e2[s2] = "object" === a(e2[s2]) ? _s2(r2, e2[s2]) : r2 : e2[s2] = r2;
      }
      return e2;
    }
    var ds2 = function(t2) {
      if ("function" == typeof this)
        return new this(t2);
      if (this.tokens = X, this.lexer = new C(this), this.ast = new us2(), this.parser = new K2(this.lexer, this.ast), t2 && "object" === a(t2)) {
        if (t2.parser && (t2.lexer || (t2.lexer = {}), t2.parser.version)) {
          if ("string" == typeof t2.parser.version) {
            var e2 = t2.parser.version.split(".");
            if (e2 = 100 * parseInt(e2[0]) + parseInt(e2[1]), isNaN(e2))
              throw new Error("Bad version number : " + t2.parser.version);
            t2.parser.version = e2;
          } else if ("number" != typeof t2.parser.version)
            throw new Error("Expecting a number for version");
          if (t2.parser.version < 500 || t2.parser.version > 900)
            throw new Error("Can only handle versions between 5.x to 8.x");
        }
        _s2(t2, this), this.lexer.version = this.parser.version;
      }
    }, ps2 = function(t2) {
      return "function" == typeof t2.write ? t2.toString() : t2;
    };
    ds2.create = function(t2) {
      return new ds2(t2);
    }, ds2.parseEval = function(t2, e2) {
      return new ds2(e2).parseEval(t2);
    }, ds2.prototype.parseEval = function(t2) {
      return this.lexer.mode_eval = true, this.lexer.all_tokens = false, t2 = ps2(t2), this.parser.parse(t2, "eval");
    }, ds2.parseCode = function(t2, e2, i2) {
      return "object" !== a(e2) || i2 || (i2 = e2, e2 = "unknown"), new ds2(i2).parseCode(t2, e2);
    }, ds2.prototype.parseCode = function(t2, e2) {
      return this.lexer.mode_eval = false, this.lexer.all_tokens = false, t2 = ps2(t2), this.parser.parse(t2, e2);
    }, ds2.tokenGetAll = function(t2, e2) {
      return new ds2(e2).tokenGetAll(t2);
    }, ds2.prototype.tokenGetAll = function(t2) {
      this.lexer.mode_eval = false, this.lexer.all_tokens = true, t2 = ps2(t2);
      var e2 = this.lexer.EOF, i2 = this.tokens.values;
      this.lexer.setInput(t2);
      for (var n2 = this.lexer.lex() || e2, s2 = []; n2 != e2; ) {
        var r2 = this.lexer.yytext;
        Object.prototype.hasOwnProperty.call(i2, n2) && (r2 = [i2[n2], r2, this.lexer.yylloc.first_line]), s2.push(r2), n2 = this.lexer.lex() || e2;
      }
      return s2;
    };
    var fs2 = ds2, Ts2 = X, ks2 = C, Es2 = us2, ms2 = K2, xs2 = _s2, ys2 = ds2, vs2 = ds2;
    fs2.tokens = Ts2, fs2.lexer = ks2, fs2.AST = Es2, fs2.parser = ms2, fs2.combine = xs2, fs2.Engine = ys2, fs2.default = vs2;
    var As2 = function(t2, e2, i2) {
      var n2 = i2 && "markdown" === i2.parentParser;
      if (!t2 && n2)
        return "";
      t2 = t2.replace(/\?>\r?\n<\?/g, "?>\n___PSEUDO_INLINE_PLACEHOLDER___<?");
      var s2, r2 = new fs2({ parser: { extractDoc: true }, ast: { withPositions: true, withSource: true } }), o2 = -1 !== t2.indexOf("<?php"), a2 = n2 && !o2;
      try {
        s2 = a2 ? r2.parseEval(t2) : r2.parseCode(t2);
      } catch (t3) {
        throw t3 instanceof SyntaxError && "lineNumber" in t3 && (t3.loc = { start: { line: t3.lineNumber, column: t3.columnNumber } }, delete t3.lineNumber, delete t3.columnNumber), t3;
      }
      return s2.extra = { parseAsEval: a2 }, s2.comments.forEach(function(t3) {
        "\r" === t3.value[t3.value.length - 1] && (t3.value = t3.value.slice(0, -1), t3.loc.end.offset = t3.loc.end.offset - 1), "\n" === t3.value[t3.value.length - 1] && (t3.value = t3.value.slice(0, -1), t3.loc.end.offset = t3.loc.end.offset - 1);
      }), s2;
    }, gs2 = n.default.util, Ns2 = gs2.hasNewline, Ls2 = gs2.skipEverythingButNewLine, Cs2 = gs2.skipNewline, bs2 = gs2.isNextLineEmpty, Is2 = gs2.isPreviousLineEmpty, Ss2 = gs2.getNextNonSpaceNonCommentCharacterIndex, Os2 = n.default.version;
    function Rs2(t2, e2) {
      return parseInt(Os2[0]) > 1 ? t2[e2] : t2;
    }
    var ws2 = {};
    function Ds2(t2) {
      return ws2[t2];
    }
    [["or"], ["xor"], ["and"], ["=", "+=", "-=", "*=", "**=", "/=", ".=", "%=", "&=", "|=", "^=", "<<=", ">>="], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!==", "<>", "<=>"], ["<", ">", "<=", ">="], [">>", "<<"], ["+", "-", "."], ["*", "/", "%"], ["!"], ["instanceof"], ["++", "--", "~"], ["**"]].forEach(function(t2, e2) {
      t2.forEach(function(t3) {
        ws2[t3] = e2;
      });
    });
    var Ps2 = ["==", "!=", "===", "!==", "<>", "<=>"], Us2 = ["*", "/", "%"], Ms2 = [">>", "<<"];
    function Fs2(t2) {
      return ["block", "program", "namespace", "class", "enum", "interface", "trait", "traituse", "declare"].includes(t2.kind);
    }
    function Bs2(t2) {
      var e2 = t2.body;
      return e2 ? ("block" === e2.kind && (e2 = e2.children), e2[0]) : null;
    }
    function Hs2(t2) {
      var e2 = t2.children || t2.body || t2.adaptations;
      return Array.isArray(e2) ? e2 : null;
    }
    function Gs2(t2) {
      var e2 = t2.getParentNode();
      return e2 ? Hs2(e2) : null;
    }
    function Vs2(t2) {
      return t2.length > 0 ? t2[t2.length - 1] : null;
    }
    function Qs2(t2) {
      var e2 = t2.getValue();
      if ("program" === e2.kind) {
        var i2 = Hs2(e2);
        return !(!i2 || 0 === i2.length) && "inline" === i2[0].kind;
      }
      if ("switch" === e2.kind) {
        if (!e2.body)
          return false;
        var n2 = Hs2(e2.body);
        if (0 === n2.length)
          return false;
        var s2 = l(n2, 1)[0];
        if (!s2.body)
          return false;
        var r2 = Hs2(s2.body);
        return 0 !== r2.length && "inline" === r2[0].kind;
      }
      var o2 = Bs2(e2);
      return !!o2 && "inline" === o2.kind;
    }
    var Ws2 = ["__construct", "__destruct", "__call", "__callStatic", "__get", "__set", "__isset", "__unset", "__sleep", "__wakeup", "__toString", "__invoke", "__set_state", "__clone", "__debugInfo"].reduce(function(t2, e2) {
      return t2[e2.toLowerCase()] = e2, t2;
    }, {});
    var Ys2 = { printNumber: function(t2) {
      return t2.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e)/, "");
    }, getPrecedence: Ds2, isBitwiseOperator: function(t2) {
      return !!Ms2[t2] || "|" === t2 || "^" === t2 || "&" === t2;
    }, shouldFlatten: function(t2, e2) {
      return Ds2(e2) === Ds2(t2) && ("**" !== t2 && ((!Ps2.includes(t2) || !Ps2.includes(e2)) && (!("%" === e2 && Us2.includes(t2) || "%" === t2 && Us2.includes(e2)) && ((e2 === t2 || !Us2.includes(e2) || !Us2.includes(t2)) && (!Ms2.includes(t2) || !Ms2.includes(e2))))));
    }, nodeHasStatement: Fs2, getNodeListProperty: Hs2, getParentNodeListProperty: Gs2, getLast: Vs2, getPenultimate: function(t2) {
      return t2.length > 1 ? t2[t2.length - 2] : null;
    }, isLastStatement: function(t2) {
      var e2 = Gs2(t2);
      if (!e2)
        return true;
      var i2 = t2.getValue();
      return e2[e2.length - 1] === i2;
    }, getBodyFirstChild: Bs2, lineShouldEndWithSemicolon: function(t2) {
      var e2 = t2.getValue(), i2 = t2.getParentNode();
      if (!i2)
        return false;
      if (["for", "foreach", "while", "do", "if", "switch"].includes(i2.kind) && "block" !== e2.kind && "if" !== e2.kind && (i2.body === e2 || i2.alternate === e2))
        return true;
      if (!Fs2(i2))
        return false;
      if ("echo" === e2.kind && e2.shortForm)
        return false;
      if ("traituse" === e2.kind)
        return !e2.adaptations;
      if ("method" === e2.kind && e2.isAbstract)
        return true;
      if ("method" === e2.kind) {
        var n2 = t2.getParentNode();
        if (n2 && "interface" === n2.kind)
          return true;
      }
      return ["expressionstatement", "do", "usegroup", "classconstant", "propertystatement", "traitprecedence", "traitalias", "goto", "constantstatement", "enumcase", "global", "static", "echo", "unset", "return", "break", "continue", "throw"].includes(e2.kind);
    }, fileShouldEndWithHardline: function(t2) {
      var e2 = t2.getValue(), i2 = "program" === e2.kind, n2 = e2.children && Vs2(e2.children);
      if (!i2)
        return false;
      if (n2 && ["halt", "inline"].includes(n2.kind))
        return false;
      if (n2 && ("declare" === n2.kind || "namespace" === n2.kind)) {
        var s2 = n2.children.length > 0 && Vs2(n2.children);
        if (s2 && ["halt", "inline"].includes(s2.kind))
          return false;
      }
      return true;
    }, maybeStripLeadingSlashFromUse: function(t2) {
      var e2 = t2.replace(/^\\/, "");
      return -1 !== e2.indexOf("\\") ? e2 : t2;
    }, hasDanglingComments: function(t2) {
      return t2.comments && t2.comments.some(function(t3) {
        return !t3.leading && !t3.trailing;
      });
    }, hasLeadingComment: function(t2) {
      return t2.comments && t2.comments.some(function(t3) {
        return t3.leading;
      });
    }, hasTrailingComment: function(t2) {
      return t2.comments && t2.comments.some(function(t3) {
        return t3.trailing;
      });
    }, docShouldHaveTrailingNewline: function t2(e2) {
      var i2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n2 = e2.getNode(i2), s2 = e2.getNode(i2 + 1), r2 = e2.getNode(i2 + 2);
      if (!s2)
        return false;
      if (r2 && ["call", "new", "echo"].includes(r2.kind) && !["call", "array"].includes(s2.kind) || "parameter" === s2.kind) {
        var o2 = r2.arguments.length - 1, a2 = r2.arguments.indexOf(s2);
        return a2 !== o2;
      }
      if (r2 && "for" === r2.kind) {
        var h2 = r2.init.indexOf(s2);
        if (-1 !== h2)
          return h2 !== r2.init.length - 1;
        var l2 = r2.test.indexOf(s2);
        if (-1 !== l2)
          return l2 !== r2.test.length - 1;
        var c2 = r2.increment.indexOf(s2);
        if (-1 !== c2)
          return c2 !== r2.increment.length - 1;
      }
      if ("bin" === s2.kind)
        return s2.left === n2 || t2(e2, i2 + 1);
      if ("case" === s2.kind && s2.test === n2)
        return true;
      if ("staticvariable" === s2.kind) {
        var u2 = r2.variables.length - 1, _3 = r2.variables.indexOf(s2);
        return _3 !== u2;
      }
      if ("entry" === s2.kind) {
        if (s2.key === n2)
          return true;
        var d3 = r2.items.length - 1, p2 = r2.items.indexOf(s2);
        return p2 !== d3;
      }
      if (["call", "new"].includes(s2.kind)) {
        var f2 = s2.arguments.length - 1, T2 = s2.arguments.indexOf(n2);
        return T2 !== f2;
      }
      if ("echo" === s2.kind) {
        var k2 = s2.expressions.length - 1, E2 = s2.expressions.indexOf(n2);
        return E2 !== k2;
      }
      if ("array" === s2.kind) {
        var m2 = s2.items.length - 1, x2 = s2.items.indexOf(n2);
        return x2 !== m2;
      }
      return "retif" === s2.kind && t2(e2, i2 + 1);
    }, isLookupNode: function(t2) {
      return "propertylookup" === t2.kind || "nullsafepropertylookup" === t2.kind || "staticlookup" === t2.kind || "offsetlookup" === t2.kind;
    }, isFirstChildrenInlineNode: Qs2, shouldPrintHardLineAfterStartInControlStructure: function(t2) {
      var e2 = t2.getValue();
      return !["try", "catch"].includes(e2.kind) && Qs2(t2);
    }, shouldPrintHardLineBeforeEndInControlStructure: function(t2) {
      var e2 = t2.getValue();
      if (["try", "catch"].includes(e2.kind))
        return true;
      if ("switch" === e2.kind) {
        var i2 = Hs2(e2.body);
        if (0 === i2.length)
          return true;
        var n2 = Vs2(i2);
        if (!n2.body)
          return true;
        var s2 = Hs2(n2.body);
        return 0 === s2.length || "inline" !== s2[0].kind;
      }
      return !Qs2(t2);
    }, getAlignment: function(t2) {
      var e2 = t2.split("\n").pop();
      return e2.length - e2.trimLeft().length + 1;
    }, isProgramLikeNode: function(t2) {
      return ["program", "declare", "namespace"].includes(t2.kind);
    }, isReferenceLikeNode: function(t2) {
      return ["name", "parentreference", "selfreference", "staticreference"].includes(t2.kind);
    }, getNodeKindIncludingLogical: function(t2) {
      return "bin" === t2.kind && ["||", "&&"].includes(t2.type) ? "logical" : t2.kind;
    }, useDoubleQuote: function(t2, e2) {
      if (t2.isDoubleQuote === e2.singleQuote) {
        var i2 = t2.raw.slice("b" === t2.raw[0] ? 2 : 1, -1).match(/\\([$nrtfve]|[xX][0-9a-fA-F]{1,2}|[0-7]{1,3}|u{([0-9a-fA-F]+)})|\r?\n|'|"|\$/);
        return t2.isDoubleQuote ? i2 : !i2;
      }
      return t2.isDoubleQuote;
    }, hasEmptyBody: function(t2) {
      var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "body", i2 = t2.getValue();
      return i2[e2] && i2[e2].children && 0 === i2[e2].children.length && (!i2[e2].comments || 0 === i2[e2].comments.length);
    }, isNextLineEmptyAfterNamespace: function(t2, e2, i2) {
      var n2 = i2(e2);
      return n2 = Ls2(t2, n2), n2 = Cs2(t2, n2), Ns2(t2, n2);
    }, shouldPrintHardlineBeforeTrailingComma: function(t2) {
      return "nowdoc" === t2.kind || "encapsed" === t2.kind && "heredoc" === t2.type || "entry" === t2.kind && ("nowdoc" === t2.value.kind || "encapsed" === t2.value.kind && "heredoc" === t2.value.type);
    }, isDocNode: function(t2) {
      return "nowdoc" === t2.kind || "encapsed" === t2.kind && "heredoc" === t2.type;
    }, getAncestorNode: function(t2, e2) {
      var i2 = function(t3, e3) {
        for (var i3, n2 = [].concat(e3), s2 = -1; i3 = t3.getParentNode(++s2); )
          if (-1 !== n2.indexOf(i3.kind))
            return s2;
        return -1;
      }(t2, e2);
      return -1 === i2 ? null : t2.getParentNode(i2);
    }, getNextNode: function(t2, e2) {
      var i2 = t2.getParentNode(), n2 = Hs2(i2);
      if (!n2)
        return null;
      var s2 = n2.indexOf(e2);
      return -1 === s2 ? null : i2.children[s2 + 1];
    }, normalizeMagicMethodName: function(t2) {
      var e2 = t2.toLowerCase();
      return Ws2[e2] ? Ws2[e2] : t2;
    }, isPreviousLineEmpty: function(t2, e2, i2) {
      return Is2(t2, e2, Rs2(i2, "locStart"));
    }, isNextLineEmpty: function(t2, e2, i2) {
      return bs2(t2, e2, Rs2(i2, "locEnd"));
    }, getNextNonSpaceNonCommentCharacterIndex: function(t2, e2, i2) {
      return Ss2(t2, e2, Rs2(i2, "locEnd"));
    } }, js2 = n.default.util, $s2 = js2.addLeadingComment, zs2 = js2.addDanglingComment, Ks2 = js2.addTrailingComment, Xs2 = js2.skipNewline, Js2 = js2.hasNewline, qs2 = js2.hasNewlineInRange, Zs2 = n.default.doc.builders, tr2 = Zs2.concat, er2 = Zs2.join, ir2 = Zs2.indent, nr2 = Zs2.hardline, sr2 = Zs2.cursor, rr2 = Zs2.lineSuffix, or2 = Zs2.breakParent, ar2 = Ys2.getNextNonSpaceNonCommentCharacterIndex, hr2 = Ys2.isNextLineEmpty, lr2 = Ys2.isPreviousLineEmpty, cr2 = Ys2.isLookupNode;
    function ur2(t2, e2) {
      var i2 = t2.children;
      0 === i2.length ? zs2(t2, e2) : $s2(i2[0], e2);
    }
    function _r2(t2, e2) {
      "block" === t2.kind ? ur2(t2, e2) : $s2(t2, e2);
    }
    function dr2(t2, e2, i2, n2, s2, r2) {
      var o2 = ar2(t2, s2, r2), a2 = t2.charAt(o2);
      return e2 && "identifier" === e2.kind && i2 && ("function" === i2.kind || "method" === i2.kind) && ")" === a2 ? (Ks2(i2, s2), true) : !(!i2 || "function" !== i2.kind && "method" !== i2.kind || !n2 || "block" !== n2.kind) && (ur2(n2, s2), true);
    }
    function pr2(t2, e2, i2, n2, s2, r2) {
      if (!i2 || "if" !== i2.kind || !n2)
        return false;
      var o2 = ar2(t2, s2, r2);
      return ")" === t2.charAt(o2) ? (Ks2(e2, s2), true) : e2 === i2.body && n2 === i2.alternate ? (zs2(i2, s2), true) : "if" === n2.kind ? (_r2(n2.body, s2), true) : i2.body === n2 && ($s2(n2, s2), true);
    }
    function fr2(t2, e2, i2) {
      if (t2 && ["class", "interface", "trait"].includes(t2.kind)) {
        if (e2 && t2.extends) {
          if (Array.isArray(t2.extends)) {
            if (t2.extends.some(function(t3) {
              if (e2 && e2 === t3)
                return zs2(e2, i2), true;
            }))
              return true;
          } else if (e2 === t2.extends)
            return zs2(e2, i2), true;
        }
        if (e2 && t2.implements && t2.implements.some(function(t3) {
          if (e2 && e2 === t3)
            return zs2(e2, i2), true;
        }))
          return true;
        if (!(t2.body && t2.body.length > 0))
          return zs2(t2, i2), true;
      }
      return !!(e2 && "class" === e2.kind && e2.isAnonymous && e2.leadingComments && "commentblock" === i2.kind);
    }
    function Tr2(t2, e2, i2, n2, s2) {
      if (e2 && ("function" === e2.kind || "method" === e2.kind)) {
        for (var r2 = 0, o2 = 0; o2 < e2.arguments.length; o2++)
          r2 = s2.locEnd(e2.arguments[o2]) > r2 ? s2.locEnd(e2.arguments[o2]) : r2;
        var a2 = e2.body && s2.locStart(n2) > r2 && s2.locEnd(n2) < s2.locStart(e2.body), h2 = ar2(t2, n2, s2);
        if (e2.type && a2 && ")" !== t2.charAt(h2))
          return s2.locEnd(n2) < s2.locStart(e2.type) ? (zs2(e2.type, n2), true) : (Ks2(e2.type, n2), true);
      }
      return false;
    }
    function kr2(t2, e2, i2, n2, s2) {
      return !(!i2 || !["function", "method", "parameter"].includes(i2.kind)) && ("typereference" === e2.kind && "identifier" === n2.kind && (Ks2(e2, s2), true));
    }
    function Er2(t2, e2) {
      return !(!t2 || !["label", "goto"].includes(t2.kind)) && (Ks2(t2, e2), true);
    }
    function mr2(t2, e2, i2, n2) {
      return i2 && "inline" === i2.kind ? (i2.leadingComments || (i2.leadingComments = []), i2.leadingComments.includes(n2) || i2.leadingComments.push(n2), true) : !(t2 || i2 || !e2 || "inline" !== e2.kind) && (zs2(e2, n2), true);
    }
    function xr2(t2, e2, i2) {
      return !(!t2 || "try" !== t2.kind || !e2) && ("block" === e2.kind ? (ur2(e2, i2), true) : "try" === e2.kind ? (_r2(e2.always, i2), true) : "catch" === e2.kind && (_r2(e2.body, i2), true));
    }
    function yr2(t2, e2, i2, n2) {
      return i2 || e2 || !t2 || "namespace" !== t2.kind || t2.withBrackets ? !(e2 || !t2 || "namespace" !== t2.kind || t2.withBrackets) && (zs2(t2, n2), true) : (Ks2(t2, n2), true);
    }
    function vr2(t2, e2, i2, n2) {
      return !(!t2 || "declare" !== t2.kind) && ((!e2 || "noop" !== e2.kind) && (i2 && t2.directives[0] !== i2 ? !(!i2 || !e2) && ($s2(i2, n2), true) : ("none" === t2.mode ? Ks2(t2, n2) : zs2(t2, n2), true)));
    }
    function Ar2(t2, e2, i2, n2, s2, r2) {
      if (!i2 || "while" !== i2.kind || !n2)
        return false;
      var o2 = ar2(t2, s2, r2);
      return ")" === t2.charAt(o2) ? (Ks2(e2, s2), true) : "block" === n2.kind && (ur2(n2, s2), true);
    }
    function gr2(t2, e2) {
      return t2.getValue().printed = true, e2.printer.printComment(t2, e2);
    }
    function Nr2(t2, e2, i2) {
      return t2.getNode() === e2.cursorNode && t2.getValue() ? tr2([sr2, i2, sr2]) : i2;
    }
    var Lr2 = { handleOwnLineComment: function(t2, e2, i2) {
      var n2 = t2.precedingNode, s2 = t2.enclosingNode, r2 = t2.followingNode;
      return dr2(e2, n2, s2, r2, t2, i2) || function(t3, e3, i3) {
        if (t3 && cr2(t3) && e3 && ["identifier", "variable", "encapsed"].includes(e3.kind))
          return $s2(t3, i3), true;
        return false;
      }(s2, r2, t2) || pr2(e2, n2, s2, r2, t2, i2) || Ar2(e2, n2, s2, r2, t2, i2) || xr2(s2, r2, t2) || fr2(s2, r2, t2) || kr2(e2, n2, s2, r2, t2) || Tr2(e2, s2, r2, t2, i2) || function(t3, e3, i3, n3) {
        if (!i3 && t3 && ("for" === t3.kind || "foreach" === t3.kind))
          return t3.body && "block" !== t3.body.kind ? $s2(i3, n3) : $s2(t3, n3), true;
        return false;
      }(s2, 0, r2, t2) || mr2(s2, n2, r2, t2) || vr2(s2, n2, r2, t2);
    }, handleEndOfLineComment: function(t2, e2, i2) {
      var n2 = t2.precedingNode, s2 = t2.enclosingNode, r2 = t2.followingNode;
      return function(t3, e3, i3, n3, s3) {
        if (!e3 && !n3 && i3 && "array" === i3.kind)
          return Ks2(i3, s3), true;
        return false;
      }(0, n2, s2, r2, t2) || function(t3, e3, i3, n3, s3) {
        if (i3 && "return" === i3.kind && !i3.expr)
          return Ks2(i3, s3), true;
        return false;
      }(0, 0, s2, 0, t2) || dr2(e2, n2, s2, r2, t2, i2) || function(t3, e3, i3, n3, s3, r3) {
        var o2 = e3 && !qs2(s3, r3.locEnd(e3), r3.locStart(n3));
        if ((!e3 || !o2) && t3 && "retif" === t3.kind && i3)
          return $s2(i3, n3), true;
        return false;
      }(s2, n2, r2, t2, e2, i2) || pr2(e2, n2, s2, r2, t2, i2) || Ar2(e2, n2, s2, r2, t2, i2) || xr2(s2, r2, t2) || fr2(s2, r2, t2) || kr2(e2, n2, s2, r2, t2) || Tr2(e2, s2, r2, t2, i2) || function(t3, e3) {
        if (t3 && "entry" === t3.kind)
          return $s2(t3, e3), true;
        return false;
      }(s2, t2) || function(t3, e3, i3) {
        if (e3 && "call" === e3.kind && t3 && e3.what === t3 && e3.arguments.length > 0)
          return $s2(e3.arguments[0], i3), true;
        return false;
      }(n2, s2, t2) || function(t3, e3, i3) {
        if (t3 && "assign" === t3.kind && e3) {
          var n3 = t3.loc.start.offset + t3.loc.source.indexOf("=");
          if (i3.loc.start.offset > n3)
            return $s2(e3, i3), true;
        }
        return false;
      }(s2, r2, t2) || mr2(s2, n2, r2, t2) || yr2(s2, n2, r2, t2) || vr2(s2, n2, r2, t2) || Er2(s2, t2);
    }, handleRemainingComment: function(t2, e2, i2) {
      var n2 = t2.precedingNode, s2 = t2.enclosingNode, r2 = t2.followingNode;
      return pr2(e2, n2, s2, r2, t2, i2) || Ar2(e2, n2, s2, r2, t2, i2) || function(t3, e3, i3, n3) {
        var s3 = ar2(t3, i3, n3);
        if (")" !== t3.charAt(s3))
          return false;
        if (e3 && ("function" === e3.kind || "closure" === e3.kind || "method" === e3.kind || "call" === e3.kind || "new" === e3.kind) && 0 === e3.arguments.length)
          return zs2(e3, i3), true;
        return false;
      }(e2, s2, t2, i2) || fr2(s2, r2, t2) || function(t3, e3, i3) {
        if (t3 && "traituse" === t3.kind && t3.adaptations && !t3.adaptations.length)
          return zs2(t3, i3), true;
        return false;
      }(s2, 0, t2) || kr2(e2, n2, s2, r2, t2) || Tr2(e2, s2, r2, t2, i2) || Er2(s2, t2) || function(t3, e3, i3, n3) {
        if (e3 && "halt" === e3.kind)
          return zs2(e3, n3), true;
        if (t3 && "halt" === t3.kind)
          return zs2(t3, n3), true;
        return false;
      }(n2, s2, 0, t2) || function(t3, e3) {
        if (t3 && ("continue" === t3.kind || "break" === t3.kind) && !t3.label)
          return Ks2(t3, e3), true;
        return false;
      }(s2, t2) || mr2(s2, n2, r2, t2) || yr2(s2, n2, r2, t2);
    }, getCommentChildNodes: function(t2) {
      return "object" !== a(t2) ? [] : function(t3) {
        return Object.keys(t3).filter(function(t4) {
          return "kind" !== t4 && "loc" !== t4 && "errors" !== t4 && "extra" !== t4 && "comments" !== t4 && "leadingComments" !== t4 && "enclosingNode" !== t4 && "precedingNode" !== t4 && "followingNode" !== t4;
        }).map(function(e2) {
          return t3[e2];
        });
      }(t2);
    }, canAttachComment: function(t2) {
      return t2.kind && "commentblock" !== t2.kind && "commentline" !== t2.kind;
    }, isBlockComment: function(t2) {
      return "commentblock" === t2.kind;
    }, printDanglingComments: function(t2, e2, i2, n2) {
      var s2 = [], r2 = t2.getValue();
      return r2 && r2.comments ? (t2.each(function(t3) {
        var i3 = t3.getValue();
        !i3 || i3.leading || i3.trailing || n2 && !n2(i3) || s2.push(gr2(t3, e2));
      }, "comments"), 0 === s2.length ? "" : i2 ? er2(nr2, s2) : ir2(tr2([nr2, er2(nr2, s2)]))) : "";
    }, hasLeadingComment: function(t2) {
      return t2.comments && t2.comments.some(function(t3) {
        return t3.leading;
      });
    }, hasTrailingComment: function(t2) {
      return t2.comments && t2.comments.some(function(t3) {
        return t3.trailing;
      });
    }, hasLeadingOwnLineComment: function(t2, e2, i2) {
      return e2.comments && e2.comments.some(function(e3) {
        return e3.leading && Js2(t2, i2.locEnd(e3));
      });
    }, printComments: function(t2, e2) {
      var i2 = [];
      return t2.forEach(function(t3, n2, s2) {
        t3.printed = true;
        var r2 = s2.length === n2 + 1;
        i2.push(t3.value), r2 || i2.push(nr2), hr2(e2.originalText, t3, e2) && !r2 && i2.push(nr2);
      }), tr2(i2);
    }, printAllComments: function(t2, e2, i2, n2) {
      var s2 = t2.getValue(), r2 = e2(t2), o2 = s2 && s2.comments;
      if (!o2 || 0 === o2.length)
        return Nr2(t2, i2, r2);
      var a2 = [], h2 = [n2 ? ";" : "", r2];
      return t2.each(function(t3) {
        var e3 = t3.getValue(), n3 = e3.leading, s3 = e3.trailing;
        if (n3) {
          var r3 = function(t4, e4, i3) {
            var n4 = t4.getValue(), s4 = gr2(t4, i3);
            if (!s4)
              return "";
            var r4 = i3.printer.isBlockComment && i3.printer.isBlockComment(n4);
            return tr2(r4 ? [s4, Js2(i3.originalText, i3.locEnd(n4)) ? nr2 : " "] : [s4, nr2]);
          }(t3, 0, i2);
          if (!r3)
            return;
          a2.push(r3);
          var o3 = i2.originalText;
          Js2(o3, Xs2(o3, i2.locEnd(e3))) && a2.push(nr2);
        } else
          s3 && h2.push(function(t4, e4, i3) {
            var n4 = t4.getValue(), s4 = gr2(t4, i3);
            if (!s4)
              return "";
            var r4 = i3.printer.isBlockComment && i3.printer.isBlockComment(n4);
            if (Js2(i3.originalText, i3.locStart(n4), { backwards: true })) {
              var o4 = lr2(i3.originalText, n4, i3);
              return rr2(tr2([nr2, o4 ? nr2 : "", s4]));
            }
            return tr2(r4 ? [" ", s4] : [rr2(tr2([" ", s4])), r4 ? "" : or2]);
          }(t3, 0, i2));
      }, "comments"), Nr2(t2, i2, tr2(a2.concat(h2)));
    } };
    function Cr2() {
    }
    Cr2.strictEqual = function() {
    };
    var br2 = Cr2, Ir2 = Ys2.getPrecedence, Sr2 = Ys2.shouldFlatten, Or2 = Ys2.isBitwiseOperator;
    var Rr2 = function(t2) {
      var e2 = t2.getParentNode();
      if (!e2)
        return false;
      var i2 = t2.getName(), n2 = t2.getNode();
      if (["program", "expressionstatement", "namespace", "declare", "block", "include", "print", "return", "echo"].includes(e2.kind))
        return false;
      switch (n2.kind) {
        case "pre":
        case "post":
          if ("unary" === e2.kind)
            return "pre" === n2.kind && ("+" === n2.type && "+" === e2.type || "-" === n2.type && "-" === e2.type);
        case "unary":
          switch (e2.kind) {
            case "unary":
              return n2.type === e2.type && ("+" === n2.type || "-" === n2.type);
            case "propertylookup":
            case "nullsafepropertylookup":
            case "staticlookup":
            case "offsetlookup":
            case "call":
              return "what" === i2 && e2.what === n2;
            case "bin":
              return "**" === e2.type && "left" === i2;
            default:
              return false;
          }
        case "bin":
          switch (e2.kind) {
            case "assign":
            case "retif":
              return ["and", "xor", "or"].includes(n2.type);
            case "silent":
            case "cast":
              return n2.parenthesizedExpression;
            case "pre":
            case "post":
            case "unary":
              return true;
            case "call":
            case "propertylookup":
            case "nullsafepropertylookup":
            case "staticlookup":
            case "offsetlookup":
              return "what" === i2 && e2.what === n2;
            case "bin":
              var s2 = e2.type, r2 = Ir2(s2), o2 = n2.type, a2 = Ir2(o2);
              return r2 > a2 || ("||" === s2 && "&&" === o2 || (r2 === a2 && "right" === i2 ? (br2.strictEqual(e2.right, n2), true) : r2 === a2 && !Sr2(s2, o2) || (r2 < a2 && "%" === o2 ? "+" === s2 || "-" === s2 : !!Or2(s2))));
            default:
              return false;
          }
        case "propertylookup":
        case "nullsafepropertylookup":
        case "staticlookup":
          return "call" === e2.kind && ("what" === i2 && e2.what === n2 && n2.parenthesizedExpression);
        case "clone":
        case "new":
          switch (e2.kind) {
            case "propertylookup":
            case "nullsafepropertylookup":
            case "staticlookup":
            case "offsetlookup":
            case "call":
              return "what" === i2 && e2.what === n2;
            default:
              return false;
          }
        case "yield":
          switch (e2.kind) {
            case "propertylookup":
            case "nullsafepropertylookup":
            case "staticlookup":
            case "offsetlookup":
            case "call":
              return "what" === i2 && e2.what === n2;
            case "retif":
              return e2.test === n2;
            default:
              return !(!n2.key && !n2.value);
          }
        case "assign":
          return ("for" !== e2.kind || !e2.init.includes(n2) && !e2.increment.includes(n2)) && ("assign" !== e2.kind && ("static" !== e2.kind && (!["if", "do", "while", "foreach", "switch"].includes(e2.kind) && ("silent" !== e2.kind && "call" !== e2.kind))));
        case "retif":
          switch (e2.kind) {
            case "cast":
              return true;
            case "unary":
            case "bin":
            case "retif":
              return !("test" === i2 && !e2.trueExpr);
            case "propertylookup":
            case "nullsafepropertylookup":
            case "staticlookup":
            case "offsetlookup":
            case "call":
              return "what" === i2 && e2.what === n2;
            default:
              return false;
          }
        case "closure":
          switch (e2.kind) {
            case "call":
              return "what" === i2 && e2.what === n2;
            case "propertylookup":
            case "nullsafepropertylookup":
              return true;
            default:
              return false;
          }
        case "silence":
        case "cast":
          return n2.parenthesizedExpression;
        case "string":
        case "array":
          switch (e2.kind) {
            case "propertylookup":
            case "nullsafepropertylookup":
            case "staticlookup":
            case "offsetlookup":
            case "call":
              return (!["string", "array"].includes(n2.kind) || "offsetlookup" !== e2.kind) && ("what" === i2 && e2.what === n2);
            default:
              return false;
          }
        case "print":
        case "include":
          return "bin" === e2.kind;
      }
      return false;
    }, wr2 = n.default.doc.builders, Dr2 = wr2.breakParent, Pr2 = wr2.concat, Ur2 = wr2.join, Mr2 = wr2.line, Fr2 = wr2.lineSuffix, Br2 = wr2.group, Hr2 = wr2.conditionalGroup, Gr2 = wr2.indent, Vr2 = wr2.dedent, Qr = wr2.ifBreak, Wr2 = wr2.hardline, Yr2 = wr2.softline, jr2 = wr2.literalline, $r2 = wr2.align, zr2 = wr2.dedentToRoot, Kr2 = n.default.doc.utils.willBreak, Xr2 = n.default.util, Jr2 = Xr2.isNextLineEmptyAfterIndex, qr = Xr2.hasNewline, Zr2 = Xr2.hasNewlineInRange, to2 = Ys2.getLast, eo2 = Ys2.getPenultimate, io2 = Ys2.isLastStatement, no2 = Ys2.lineShouldEndWithSemicolon, so2 = Ys2.printNumber, ro2 = Ys2.shouldFlatten, oo2 = Ys2.maybeStripLeadingSlashFromUse, ao2 = Ys2.fileShouldEndWithHardline, ho2 = Ys2.hasDanglingComments, lo2 = Ys2.hasLeadingComment, co2 = Ys2.hasTrailingComment, uo2 = Ys2.docShouldHaveTrailingNewline, _o2 = Ys2.isLookupNode, po2 = Ys2.isFirstChildrenInlineNode, fo2 = Ys2.shouldPrintHardLineAfterStartInControlStructure, To2 = Ys2.shouldPrintHardLineBeforeEndInControlStructure, ko2 = Ys2.getAlignment, Eo2 = Ys2.isProgramLikeNode, mo2 = Ys2.getNodeKindIncludingLogical, xo2 = Ys2.useDoubleQuote, yo2 = Ys2.hasEmptyBody, vo2 = Ys2.isNextLineEmptyAfterNamespace, Ao2 = Ys2.shouldPrintHardlineBeforeTrailingComma, go2 = Ys2.isDocNode, No2 = Ys2.getAncestorNode, Lo2 = Ys2.isReferenceLikeNode, Co2 = Ys2.getNextNode, bo2 = Ys2.normalizeMagicMethodName, Io2 = Ys2.getNextNonSpaceNonCommentCharacterIndex, So2 = Ys2.isNextLineEmpty;
    function Oo2(t2, e2) {
      return parseFloat(t2) >= parseFloat(e2);
    }
    function Ro2(t2, e2) {
      return !!t2.trailingCommaPHP && Oo2(t2.phpVersion, e2);
    }
    function wo2(t2) {
      return "1tbs" !== t2.braceStyle;
    }
    function Do2(t2, e2, i2) {
      var n2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
      return Pr2([n2 ? "?" : "", "->", t2.call(i2, "offset")]);
    }
    function Po2(t2, e2, i2) {
      return Do2(t2, e2, i2, true);
    }
    function Uo2(t2, e2, i2) {
      var n2 = t2.getValue(), s2 = !["variable", "identifier"].includes(n2.offset.kind);
      return Pr2(["::", s2 ? "{" : "", t2.call(i2, "offset"), s2 ? "}" : ""]);
    }
    function Mo2(t2, e2, i2) {
      var n2 = t2.getValue(), s2 = n2.offset && "number" === n2.offset.kind || No2(t2, "encapsed");
      return Pr2(["[", n2.offset ? Br2(Pr2([Gr2(Pr2([s2 ? "" : Yr2, t2.call(i2, "offset")])), s2 ? "" : Yr2])) : "", "]"]);
    }
    function Fo2(t2) {
      return "array" === t2.kind && (t2.items.length > 0 || t2.comments) || "function" === t2.kind || "method" === t2.kind || "closure" === t2.kind;
    }
    function Bo2(t2) {
      var e2 = to2(t2), i2 = eo2(t2);
      return !lo2(e2) && !co2(e2) && Fo2(e2) && (!i2 || i2.kind !== e2.kind);
    }
    function Ho2(t2) {
      if (2 !== t2.length)
        return false;
      var e2 = l(t2, 2), i2 = e2[0], n2 = e2[1];
      return !(i2.comments && i2.comments.length || "function" !== i2.kind && "method" !== i2.kind && "closure" !== i2.kind || "retif" === n2.kind || Fo2(n2));
    }
    function Go2(t2, e2, i2) {
      var n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "arguments", s2 = t2.getValue()[n2];
      if (0 === s2.length)
        return Pr2(["(", Lr2.printDanglingComments(t2, e2, true), ")"]);
      var r2 = false, o2 = false, a2 = s2.length - 1, h2 = t2.map(function(t3, n3) {
        var s3 = t3.getNode(), h3 = [i2(t3)];
        return n3 === a2 || (So2(e2.originalText, s3, e2) ? (0 === n3 && (o2 = true), r2 = true, h3.push(",", Wr2, Wr2)) : h3.push(",", Mr2)), Pr2(h3);
      }, n2), l2 = t2.getValue(), c2 = to2(s2), u2 = Ro2(e2, "7.3") && ["call", "new", "unset", "isset"].includes(l2.kind) || Ro2(e2, "8.0") && ["function", "closure", "method", "arrowfunc", "attribute"].includes(l2.kind) ? Gr2(Pr2([c2 && Ao2(c2) ? Wr2 : "", ","])) : "";
      function _3() {
        return Br2(Pr2(["(", Gr2(Pr2([Mr2, Pr2(h2)])), u2, Mr2, ")"]), { shouldBreak: true });
      }
      var d3 = Ho2(s2), p2 = Bo2(s2);
      if (d3 || p2) {
        var f2, T2 = (d3 ? h2.slice(1).some(Kr2) : h2.slice(0, -1).some(Kr2)) || r2, k2 = 0;
        t2.each(function(t3) {
          d3 && 0 === k2 && (f2 = [Pr2([t3.call(function(t4) {
            return i2(t4, { expandFirstArg: true });
          }), h2.length > 1 ? "," : "", o2 ? Wr2 : Mr2, o2 ? Wr2 : ""])].concat(h2.slice(1))), p2 && k2 === s2.length - 1 && (f2 = h2.slice(0, -1).concat(t3.call(function(t4) {
            return i2(t4, { expandLastArg: true });
          }))), k2++;
        }, n2);
        var E2 = h2.some(Kr2), m2 = Pr2(["(", Pr2(f2), ")"]);
        return Pr2([E2 ? Dr2 : "", Hr2([E2 ? Qr(_3(), m2) : m2, Pr2(d3 ? ["(", Br2(f2[0], { shouldBreak: true }), Pr2(f2.slice(1)), ")"] : ["(", Pr2(h2.slice(0, -1)), Br2(to2(f2), { shouldBreak: true }), ")"]), Br2(Pr2(["(", Gr2(Pr2([Mr2, Pr2(h2)])), Qr(u2), Mr2, ")"]), { shouldBreak: true })], { shouldBreak: T2 })]);
      }
      return Br2(Pr2(["(", Gr2(Pr2([Yr2, Pr2(h2)])), Qr(u2), Yr2, ")"]), { shouldBreak: h2.some(Kr2) || r2 });
    }
    function Vo2(t2) {
      return "array" === t2.kind && 0 !== t2.items.length;
    }
    function Qo2(t2) {
      return "array" === t2.right.kind && 0 !== t2.right.items.length;
    }
    function Wo2(t2, e2, i2, n2, s2) {
      var r2 = [], o2 = t2.getValue();
      if ("bin" === o2.kind) {
        ro2(o2.type, o2.left.type) ? r2 = r2.concat(t2.call(function(t3) {
          return Wo2(t3, e2, i2, true, s2);
        }, "left")) : r2.push(t2.call(e2, "left"));
        var a2 = Qo2(o2), h2 = Pr2(a2 ? [o2.type, " ", t2.call(e2, "right")] : [o2.type, Mr2, t2.call(e2, "right")]), l2 = t2.getParentNode(), c2 = !(s2 && ["||", "&&"].includes(o2.type)) && mo2(l2) !== mo2(o2) && mo2(o2.left) !== mo2(o2) && mo2(o2.right) !== mo2(o2), u2 = go2(o2.left) || "bin" === o2.left.kind && go2(o2.left.right);
        r2.push(u2 ? "" : " ", c2 ? Br2(h2) : h2), n2 && o2.comments && (r2 = Lr2.printAllComments(t2, function() {
          return Pr2(r2);
        }, i2));
      } else
        r2.push(t2.call(e2));
      return r2;
    }
    function Yo2(t2, e2, i2) {
      var n2 = t2.getValue();
      switch (n2.kind) {
        case "propertylookup":
          return Do2(t2, e2, i2);
        case "nullsafepropertylookup":
          return Po2(t2, e2, i2);
        case "staticlookup":
          return Uo2(t2, 0, i2);
        case "offsetlookup":
          return Mo2(t2, 0, i2);
        default:
          return "Have not implemented lookup kind ".concat(n2.kind, " yet.");
      }
    }
    function jo2(t2) {
      var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i2 = e2.opening, n2 = void 0 === i2 || i2;
      if ("heredoc" === t2.type)
        return n2 ? "<<<".concat(t2.label) : t2.label;
      var s2 = { string: '"', shell: "`" };
      return s2[t2.type] ? s2[t2.type] : "Unimplemented encapsed type ".concat(t2.type);
    }
    function $o2(t2, e2, i2) {
      var n2 = [], s2 = [];
      return t2.each(function(t3) {
        n2.push(Pr2(s2)), n2.push(Br2(i2(t3))), s2 = [",", Mr2], t3.getValue() && So2(e2.originalText, t3.getValue(), e2) && s2.push(Yr2);
      }, "items"), Pr2(n2);
    }
    function zo2(t2, e2) {
      if (0 === e2.length)
        return t2;
      var i2 = 0;
      return e2.reduce(function(e3, n2) {
        var s2 = n2.start, r2 = n2.end, o2 = n2.alignment, a2 = n2.before, h2 = n2.after, l2 = Pr2([a2 || "", Pr2(t2.slice(s2, r2)), h2 || ""]), c2 = e3.concat(t2.slice(i2, s2), o2 ? zr2(Br2(Pr2([$r2(new Array(o2).join(" "), l2)]))) : Br2(l2), r2 === t2.length - 1 ? t2.slice(r2) : "");
        return i2 = r2, c2;
      }, []);
    }
    function Ko2(t2, e2, i2) {
      var n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "children", s2 = t2.getValue(), r2 = t2.getParentNode(), o2 = -1, a2 = [], h2 = [];
      t2.map(function(l2, c3) {
        var u3 = l2.getValue(), _4 = "inline" === u3.kind, d4 = i2(l2), p3 = s2[n2], f3 = p3[c3 + 1], T3 = !io2(l2) && !_4 && (f3 && "case" === f3.kind ? !po2(t2) : f3 && "inline" !== f3.kind), k3 = Pr2([d4, T3 ? Wr2 : "", T3 && So2(e2.originalText, u3, e2) ? Wr2 : ""]), E3 = 0 === c3, m3 = p3.length - 1 === c3, x3 = "block" === s2.kind && r2 && ["function", "closure", "method", "try", "catch"].includes(r2.kind), y3 = x3 && E3 ? "" : " ";
        if (_4 || !_4 && m3 && o2 >= 0) {
          var v3 = o2;
          if (_4 && (o2 = c3), _4 && !E3 || !_4 && m3) {
            var A2 = (_4 ? v3 : o2) + 1, g3 = m3 && !_4 ? c3 + 1 : c3, N3 = p3[_4 ? v3 : o2], L2 = N3 ? ko2(N3.raw) : "", C2 = g3 - A2 > 1, b2 = C2 ? x3 && !N3 || Eo2(s2) && 0 === A2 ? "" : Wr2 : "", I3 = C2 && "halt" !== u3.kind ? x3 && m3 ? "" : Wr2 : "";
            C2 && (y3 = ""), h2.push({ start: A2, end: g3, alignment: L2, before: b2, after: I3 });
          }
        }
        if (_4) {
          var S2 = f3 && "echo" === f3.kind && f3.shortForm ? "<?=" : "<?php", O2 = u3.leadingComments && u3.leadingComments.length ? Pr2([E3 && "namespace" !== s2.kind && !x3 ? "<?php" : "", "namespace" !== s2.kind && x3 ? "" : Wr2, Lr2.printComments(u3.leadingComments, e2), Wr2, "?>"]) : Eo2(s2) && E3 && "namespace" !== s2.kind ? "" : Pr2([y3, "?>"]), R3 = t2.getNode(c3 + 1), w2 = R3 && R3.children && R3.children.length, D2 = u3.comments && u3.comments.length ? Pr2([S2, Wr2, w2 ? Lr2.printComments(u3.comments, e2) : "", Wr2, w2 ? "?>" : ""]) : Eo2(s2) && m3 ? "" : Pr2([S2, " "]);
          k3 = Pr2([O2, k3, D2]);
        }
        a2.push(k3);
      }, n2);
      var c2 = zo2(a2, h2);
      if ("program" === s2.kind && !s2.extra.parseAsEval) {
        var u2 = [], _3 = l(s2.children, 1), d3 = _3[0], p2 = !d3 || "inline" !== d3.kind;
        if (p2) {
          var f2 = e2.originalText.trim().match(/^<\?(php|=)(\s+)?\S/), T2 = Pr2([f2 && f2[2] && f2[2].includes("\n") ? Pr2([Wr2, f2[2].split("\n").length > 2 ? Wr2 : ""]) : " ", s2.comments ? Lr2.printComments(s2.comments, e2) : ""]), k2 = d3 && "echo" === d3.kind && d3.shortForm;
          u2.push(Pr2([k2 ? "<?=" : "<?php", T2]));
        }
        u2.push(Pr2(c2));
        var E2 = e2.originalText.trim().endsWith("?>");
        if (E2) {
          var m2 = to2(s2.children), x2 = m2 ? Pr2([Zr2(e2.originalText.trimEnd(), e2.locEnd(m2), e2.locEnd(s2)) ? Wr2 : " ", So2(e2.originalText, m2, e2) ? Wr2 : ""]) : s2.comments ? Wr2 : "";
          u2.push(Fr2(Pr2([x2, "?>"])));
        }
        return Pr2(u2);
      }
      return Pr2(c2);
    }
    function Xo2(t2, e2, i2, n2) {
      return Pr2(t2.map(function(t3) {
        var n3 = [];
        return n3.push(i2(t3)), io2(t3) || (n3.push(Wr2), So2(e2.originalText, t3.getValue(), e2) && n3.push(Wr2)), Pr2(n3);
      }, n2));
    }
    function Jo2(t2, e2, i2) {
      var n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "extends", s2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : " ", r2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : " ", o2 = t2.getValue(), a2 = ho2(o2[n2]) ? Pr2([Wr2, t2.call(function(t3) {
        return Lr2.printDanglingComments(t3, e2, true);
      }, n2), Wr2]) : s2, h2 = Array.isArray(o2[n2]) ? Br2(Pr2([Ur2(",", t2.map(function(t3) {
        var n3 = i2(t3);
        return ho2(t3.getValue()) ? Pr2([Wr2, Lr2.printDanglingComments(t3, e2, true), Wr2, n3]) : Pr2([r2, n3]);
      }, n2))])) : Pr2([r2, t2.call(i2, n2)]);
      return Gr2(Pr2([a2, n2, Kr2(a2) ? Gr2(h2) : h2]));
    }
    function qo2(t2, e2, i2) {
      var n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, s2 = n2.inline, r2 = void 0 !== s2 && s2, o2 = [];
      return t2.getValue().attrGroups ? (t2.each(function(t3) {
        var n3 = ["#["];
        !r2 && o2.length > 0 && o2.push(Wr2), n3.push(Yr2), t3.each(function(t4) {
          var s3 = t4.getValue();
          n3.length > 2 && n3.push(",", Mr2);
          var r3 = [s3.name];
          s3.args.length > 0 && r3.push(Go2(t4, e2, i2, "args")), n3.push(Br2(Pr2(r3)));
        }, "attrs"), o2.push(Br2(Pr2([Gr2(Pr2(n3)), Qr(Ro2(e2, "8.0") ? "," : ""), Yr2, "]", r2 ? Qr(Yr2, " ") : ""])));
      }, "attrGroups"), 0 === o2.length ? [] : [Pr2([].concat(o2, [r2 ? "" : Wr2]))]) : [];
    }
    function Zo2(t2, e2, i2) {
      var n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "body", s2 = t2.getValue();
      if (!s2[n2])
        return ";";
      var r2 = t2.call(i2, n2);
      return Pr2([s2.shortForm ? ":" : " {", Gr2(Pr2(["block" !== s2[n2].kind || s2[n2].children && s2[n2].children.length > 0 || s2[n2].comments && s2[n2].comments.length > 0 ? Pr2([fo2(t2) ? "switch" === s2.kind ? " " : "" : Wr2, r2]) : ""])), "if" === s2.kind && "body" === n2 ? "" : Pr2([To2(t2) ? Wr2 : "", s2.shortForm ? Pr2(["end", s2.kind, ";"]) : "}"])]);
    }
    function ta2(t2, e2, i2, n2, s2, r2, o2) {
      if (!n2)
        return e2;
      var a2 = ia(t2, n2, s2, r2, o2);
      return Br2(Pr2([e2, i2, a2]));
    }
    function ea2(t2) {
      return !!_o2(t2) && (!("variable" !== t2.what.kind && !Lo2(t2.what)) || ea2(t2.what));
    }
    function ia(t2, e2, i2, n2, s2) {
      var r2 = n2 ? "&" : "";
      if (Lr2.hasLeadingOwnLineComment(s2.originalText, e2, s2))
        return Gr2(Pr2([Wr2, r2, i2]));
      var o2 = "cast" === e2.kind ? e2.expr : e2;
      return "bin" === o2.kind && !Qo2(o2) || "retif" === o2.kind && (!o2.trueExpr && !Vo2(o2.falseExpr) || "bin" === o2.test.kind && !Qo2(o2.test)) || ("variable" === t2.kind || "string" === t2.kind || _o2(t2)) && ("string" === o2.kind && !na2(o2) || ea2(o2)) ? Br2(Gr2(Pr2([Mr2, r2, i2]))) : Pr2([" ", r2, i2]);
    }
    function na2(t2) {
      return t2.raw.includes("\n");
    }
    function sa2(t2, e2, i2) {
      return ("string" === t2.kind || "encapsed" === t2.kind && ("string" === t2.type || "shell" === t2.type)) && na2(t2) && !qr(e2, i2.locStart(t2), { backwards: true });
    }
    function ra2(t2, e2, i2) {
      return Br2(Pr2(t2.map(function(n2, s2) {
        return Pr2(0 === s2 ? [t2.call(e2)] : [i2, t2.call(e2)]);
      }, "types")));
    }
    var oa = function(t2, e2, i2) {
      var n2 = t2.getValue();
      if (!n2)
        return "";
      if ("string" == typeof n2)
        return n2;
      var s2 = function(t3, e3, i3) {
        var n3 = t3.getValue();
        switch (n3.kind) {
          case "program":
            return Br2(Pr2([Ko2(t3, e3, i3), Lr2.printDanglingComments(t3, e3, true, function(t4) {
              return !t4.printed;
            })]));
          case "expressionstatement":
            return t3.call(i3, "expression");
          case "block":
            return Pr2([Ko2(t3, e3, i3), Lr2.printDanglingComments(t3, e3, true)]);
          case "declare":
            var s3 = function(t4) {
              return Ur2(", ", t4.map(function(t5) {
                return Pr2([i3(t5)]);
              }, "directives"));
            };
            if (["block", "short"].includes(n3.mode))
              return Pr2(["declare(", s3(t3), ")", "block" === n3.mode ? " {" : ":", n3.children.length > 0 ? Gr2(Pr2([Wr2, Ko2(t3, e3, i3)])) : "", Lr2.printDanglingComments(t3, e3), Wr2, "block" === n3.mode ? "}" : "enddeclare;"]);
            var r3 = Co2(t3, n3);
            return Pr2(["declare(", s3(t3), ")", r3 && "inline" === r3.kind ? "" : ";"]);
          case "declaredirective":
            return Pr2([t3.call(i3, "key"), "=", t3.call(i3, "value")]);
          case "namespace":
            return Pr2(["namespace ", n3.name && "string" == typeof n3.name ? Pr2([n3.name, n3.withBrackets ? " " : ""]) : "", n3.withBrackets ? "{" : ";", ho2(n3) ? Pr2([" ", Lr2.printDanglingComments(t3, e3, true)]) : "", n3.children.length > 0 ? n3.withBrackets ? Gr2(Pr2([Wr2, Ko2(t3, e3, i3)])) : Pr2(["inline" === n3.children[0].kind ? "" : Pr2([Wr2, vo2(e3.originalText, n3, e3.locStart) ? Wr2 : ""]), Ko2(t3, e3, i3)]) : "", n3.withBrackets ? Pr2([Wr2, "}"]) : ""]);
          case "usegroup":
            return Br2(Pr2(["use ", n3.type ? Pr2([n3.type, " "]) : "", Gr2(Pr2([n3.name ? Pr2([oo2(n3.name), "\\{", Yr2]) : "", Ur2(Pr2([",", Mr2]), t3.map(function(t4) {
              return Pr2([i3(t4)]);
            }, "items"))])), n3.name ? Pr2([Qr(Ro2(e3, "7.2") ? "," : ""), Yr2, "}"]) : ""]));
          case "useitem":
            return Pr2([n3.type ? Pr2([n3.type, " "]) : "", oo2(n3.name), ho2(n3) ? Pr2([" ", Lr2.printDanglingComments(t3, e3, true)]) : "", n3.alias ? Pr2([" as ", t3.call(i3, "alias")]) : ""]);
          case "class":
          case "enum":
          case "interface":
          case "trait":
            return function(t4, e4, i4) {
              var n4 = t4.getValue(), s4 = "class" === n4.kind && n4.isAnonymous, r4 = qo2(t4, e4, i4, { inline: s4 }), o4 = s4 ? [] : c(r4);
              n4.isFinal && o4.push("final ");
              n4.isAbstract && o4.push("abstract ");
              o4.push(s4 ? "" : n4.kind), n4.name && o4.push(" ", t4.call(i4, "name"));
              "enum" === n4.kind && n4.valueType && o4.push(": ", t4.call(i4, "valueType"));
              n4.extends && n4.implements ? o4.push(Hr2([Pr2([Jo2(t4, e4, i4, "extends"), Jo2(t4, e4, i4, "implements")]), Pr2([Jo2(t4, e4, i4, "extends"), Jo2(t4, e4, i4, "implements", " ", Wr2)]), Pr2([Jo2(t4, e4, i4, "extends", Wr2, " "), Jo2(t4, e4, i4, "implements", Wr2, n4.implements.length > 1 ? Wr2 : " ")])], { shouldBreak: ho2(n4.extends) })) : (n4.extends && o4.push(Hr2([Jo2(t4, e4, i4, "extends"), Jo2(t4, e4, i4, "extends", " ", Wr2), Jo2(t4, e4, i4, "extends", Wr2, n4.extends.length > 1 ? Wr2 : " ")])), n4.implements && o4.push(Hr2([Jo2(t4, e4, i4, "implements"), Jo2(t4, e4, i4, "implements", " ", Wr2), Jo2(t4, e4, i4, "implements", Wr2, n4.implements.length > 1 ? Wr2 : " ")])));
              var a3 = Br2(Pr2([Br2(Pr2(o4)), wo2(e4) ? s4 ? Mr2 : Wr2 : " "])), h3 = n4.body && 0 === n4.body.length && !ho2(n4), l2 = Pr2(["{", Gr2(Pr2([h3 ? "" : Wr2, Xo2(t4, e4, i4, "body")])), Lr2.printDanglingComments(t4, e4, true), s4 && h3 ? Yr2 : Wr2, "}"]);
              return Pr2([a3, l2]);
            }(t3, e3, i3);
          case "traitprecedence":
            return Pr2([t3.call(i3, "trait"), "::", t3.call(i3, "method"), " insteadof ", Ur2(", ", t3.map(i3, "instead"))]);
          case "traitalias":
            return Pr2([n3.trait ? Pr2([t3.call(i3, "trait"), "::"]) : "", n3.method ? t3.call(i3, "method") : "", " as ", Ur2(" ", [].concat(c(n3.visibility ? [n3.visibility] : []), c(n3.as ? [t3.call(i3, "as")] : [])))]);
          case "traituse":
            return Br2(Pr2(["use ", Gr2(Br2(Ur2(Pr2([",", Mr2]), t3.map(i3, "traits")))), n3.adaptations ? Pr2([" {", n3.adaptations.length > 0 ? Pr2([Gr2(Pr2([Wr2, Xo2(t3, e3, i3, "adaptations")])), Wr2]) : ho2(n3) ? Pr2([Mr2, Lr2.printDanglingComments(t3, e3, true), Mr2]) : "", "}"]) : ""]));
          case "function":
          case "closure":
          case "method":
            return function(t4, e4, i4) {
              var n4 = t4.getValue(), s4 = c(qo2(t4, e4, i4, { inline: "closure" === n4.kind }));
              n4.isFinal && s4.push("final ");
              n4.isAbstract && s4.push("abstract ");
              n4.visibility && s4.push(n4.visibility, " ");
              n4.isStatic && s4.push("static ");
              s4.push("function "), n4.byref && s4.push("&");
              n4.name && s4.push(t4.call(i4, "name"));
              s4.push(Go2(t4, e4, i4)), n4.uses && n4.uses.length > 0 && s4.push(Br2(Pr2([" use ", Go2(t4, e4, i4, "uses")])));
              n4.type && s4.push(Pr2([": ", ho2(n4.type) ? Pr2([t4.call(function(t5) {
                return Lr2.printDanglingComments(t5, e4, true);
              }, "type"), " "]) : "", n4.nullable ? "?" : "", t4.call(i4, "type")]));
              var r4 = Pr2(s4);
              if (!n4.body)
                return r4;
              var o4 = "closure" === n4.kind, a3 = Pr2(["{", Gr2(Pr2([yo2(t4) ? "" : Wr2, t4.call(i4, "body")])), o4 && yo2(t4) ? "" : Wr2, "}"]);
              if (o4)
                return Pr2([r4, " ", a3]);
              if (0 === n4.arguments.length)
                return Pr2([r4, wo2(e4) ? Wr2 : " ", a3]);
              if (s4.some(Kr2))
                return Pr2([r4, " ", a3]);
              return Hr2([Pr2([r4, wo2(e4) ? Wr2 : " ", a3]), Pr2([r4, " ", a3])]);
            }(t3, e3, i3);
          case "arrowfunc":
            return Pr2([].concat(c(qo2(t3, e3, i3, { inline: true })), [n3.isStatic ? "static " : "", "fn", Go2(t3, e3, i3), n3.type ? Pr2([": ", n3.nullable ? "?" : "", t3.call(i3, "type")]) : "", " => ", t3.call(i3, "body")]));
          case "parameter":
            var o3 = "";
            1 === n3.flags ? o3 = "public " : 2 === n3.flags ? o3 = "protected " : 4 === n3.flags && (o3 = "private ");
            var a2 = Pr2([].concat(c(qo2(t3, e3, i3, { inline: true })), [o3, n3.readonly ? "readonly " : "", n3.nullable ? "?" : "", n3.type ? Pr2([t3.call(i3, "type"), " "]) : "", n3.byref ? "&" : "", n3.variadic ? "..." : "", "$", t3.call(i3, "name")]));
            return n3.value ? Br2(Pr2([a2, ho2(n3) ? " " : "", Lr2.printDanglingComments(t3, e3, true), Pr2([" =", ia(n3.name, n3.value, t3.call(i3, "value"), false, e3)])])) : a2;
          case "variadic":
            return Pr2(["...", t3.call(i3, "what")]);
          case "property":
            return Br2(Pr2([n3.readonly ? "readonly " : "", n3.type ? Pr2([n3.nullable ? "?" : "", t3.call(i3, "type"), " "]) : "", "$", t3.call(i3, "name"), n3.value ? Pr2([" =", ia(n3.name, n3.value, t3.call(i3, "value"), false, e3)]) : ""]));
          case "propertystatement":
            var h2 = [];
            t3.map(function(t4) {
              return h2.push.apply(h2, c(qo2(t4, e3, i3)));
            }, "properties");
            var u2, _3 = t3.map(function(t4) {
              return i3(t4);
            }, "properties"), d3 = n3.properties.some(function(t4) {
              return t4.value;
            });
            if (1 !== _3.length || n3.properties[0].comments)
              _3.length > 0 && (u2 = Gr2(_3[0]));
            else
              u2 = l(_3, 1)[0];
            var p2 = n3.visibility || null === n3.visibility;
            return Br2(Pr2([].concat(h2, [p2 ? Pr2([null === n3.visibility ? "var" : n3.visibility, ""]) : "", n3.isStatic ? Pr2([p2 ? " " : "", "static"]) : "", u2 ? Pr2([" ", u2]) : "", Gr2(Pr2(_3.slice(1).map(function(t4) {
              return Pr2([",", d3 ? Wr2 : Mr2, t4]);
            })))])));
          case "if":
            var f2 = [], T2 = Zo2(t3, e3, i3, "body"), k2 = Br2(Pr2(["if (", Br2(Pr2([Gr2(Pr2([Yr2, t3.call(i3, "test")])), Yr2])), ")", T2]));
            if (f2.push(k2, po2(t3) || !n3.body ? "" : Wr2), n3.alternate) {
              f2.push(n3.shortForm ? "" : "} ");
              var E2 = co2(n3.body) && n3.body.comments.some(function(t4) {
                return t4.trailing && !Lr2.isBlockComment(t4);
              }) || function(t4) {
                if (!t4.comments)
                  return false;
                var e4 = to2(t4.comments.filter(function(t5) {
                  return !t5.leading && !t5.trailing;
                }));
                return e4 && !Lr2.isBlockComment(e4);
              }(n3), m2 = !E2;
              f2.push(m2 ? "" : Wr2), ho2(n3) && f2.push(So2(e3.originalText, n3.body, e3) ? Wr2 : "", Lr2.printDanglingComments(t3, e3, true), E2 ? Wr2 : " "), f2.push("else", Br2("if" === n3.alternate.kind ? t3.call(i3, "alternate") : Zo2(t3, e3, i3, "alternate")));
            } else
              f2.push(n3.body ? n3.shortForm ? "endif;" : "}" : "");
            return Pr2(f2);
          case "do":
            return Pr2(["do", Zo2(t3, e3, i3, "body"), " while (", Br2(Pr2([Gr2(Pr2([Yr2, t3.call(i3, "test")])), Yr2])), ")"]);
          case "while":
          case "switch":
            return Br2(Pr2([n3.kind, " (", Br2(Pr2([Gr2(Pr2([Yr2, t3.call(i3, "test")])), Yr2])), ")", Zo2(t3, e3, i3, "body")]));
          case "for":
            var x2 = Zo2(t3, e3, i3, "body"), y3 = Lr2.printDanglingComments(t3, e3, true), v3 = y3 ? Pr2([y3, Yr2]) : "";
            return n3.init.length || n3.test.length || n3.increment.length ? Pr2([v3, Br2(Pr2(["for (", Br2(Pr2([Gr2(Pr2([Yr2, Br2(Pr2([Ur2(Pr2([",", Mr2]), t3.map(i3, "init"))])), ";", Mr2, Br2(Pr2([Ur2(Pr2([",", Mr2]), t3.map(i3, "test"))])), ";", Mr2, Br2(Ur2(Pr2([",", Mr2]), t3.map(i3, "increment")))])), Yr2])), ")", x2]))]) : Pr2([v3, Br2(Pr2(["for (;;)", x2]))]);
          case "foreach":
            var A2 = Zo2(t3, e3, i3, "body"), g3 = Lr2.printDanglingComments(t3, e3, true), N3 = g3 ? Pr2([g3, Yr2]) : "";
            return Pr2([N3, Br2(Pr2(["foreach (", Br2(Pr2([Gr2(Pr2([Yr2, t3.call(i3, "source"), Mr2, "as ", Br2(n3.key ? Gr2(Ur2(Pr2([" =>", Mr2]), [t3.call(i3, "key"), t3.call(i3, "value")])) : t3.call(i3, "value"))])), Yr2])), ")", A2]))]);
          case "try":
            var L2 = [];
            return L2.push("try", Zo2(t3, e3, i3, "body")), n3.catches && L2.push(Pr2(t3.map(i3, "catches"))), n3.always && L2.push(" finally", Zo2(t3, e3, i3, "always")), Pr2(L2);
          case "catch":
            return Pr2([" catch", n3.what ? Pr2([" (", Ur2(" | ", t3.map(i3, "what")), n3.variable ? Pr2([" ", t3.call(i3, "variable")]) : "", ")"]) : "", Zo2(t3, e3, i3, "body")]);
          case "case":
            return Pr2([n3.test ? Pr2(["case ", n3.test.comments ? Gr2(t3.call(i3, "test")) : t3.call(i3, "test"), ":"]) : "default:", n3.body && n3.body.children && n3.body.children.length ? Gr2(Pr2([po2(t3) ? "" : Wr2, t3.call(i3, "body")])) : ""]);
          case "break":
          case "continue":
            return n3.level && ("number" === n3.level.kind && "1" !== n3.level.value) ? Pr2(["".concat(n3.kind, " "), t3.call(i3, "level")]) : n3.kind;
          case "call":
            return 1 === n3.arguments.length && sa2(n3.arguments[0], e3.originalText, e3) ? Pr2([t3.call(i3, "what"), Pr2(["(", Ur2(", ", t3.map(i3, "arguments")), ")"])]) : _o2(n3.what) ? function(t4, e4, i4) {
              var n4 = [];
              function s4(t5) {
                var i5 = e4.originalText, n5 = Io2(i5, t5, e4);
                return ")" === i5.charAt(n5) ? Jr2(i5, n5 + 1, e4) : So2(i5, t5, e4);
              }
              function r4(t5) {
                var o5 = t5.getValue();
                if ("call" !== o5.kind || !_o2(o5.what) && "call" !== o5.what.kind)
                  if (_o2(o5)) {
                    var a4 = null;
                    a4 = "propertylookup" === o5.kind ? Do2(t5, e4, i4) : "nullsafepropertylookup" === o5.kind ? Po2(t5, e4, i4) : "staticlookup" === o5.kind ? Uo2(t5, e4, i4) : Mo2(t5, e4, i4), n4.unshift({ node: o5, needsParens: Rr2(t5), printed: Lr2.printAllComments(t5, function() {
                      return a4;
                    }, e4) }), t5.call(function(t6) {
                      return r4(t6);
                    }, "what");
                  } else
                    n4.unshift({ node: o5, printed: t5.call(i4) });
                else
                  n4.unshift({ node: o5, printed: Pr2([Lr2.printAllComments(t5, function() {
                    return Pr2([Go2(t5, e4, i4)]);
                  }, e4), s4(o5) ? Wr2 : ""]) }), t5.call(function(t6) {
                    return r4(t6);
                  }, "what");
              }
              var o4 = t4.getValue();
              n4.unshift({ node: o4, printed: Go2(t4, e4, i4) }), t4.call(function(t5) {
                return r4(t5);
              }, "what");
              for (var a3 = 0; a3 < n4.length; ++a3)
                "call" === n4[a3].node.kind && n4[a3 - 1] && ["propertylookup", "nullsafepropertylookup", "staticlookup"].includes(n4[a3 - 1].node.kind) && n4[a3 - 1].needsParens && (n4[0].printed = Pr2(["(", n4[0].printed]), n4[a3 - 1].printed = Pr2([n4[a3 - 1].printed, ")"]));
              for (var h3 = [], l2 = [n4[0]], c2 = 1; c2 < n4.length && ("call" === n4[c2].node.kind || _o2(n4[c2].node) && n4[c2].node.offset && "number" === n4[c2].node.offset.kind); ++c2)
                l2.push(n4[c2]);
              if ("call" !== n4[0].node.kind)
                for (; c2 + 1 < n4.length && (_o2(n4[c2].node) && _o2(n4[c2 + 1].node)); ++c2)
                  l2.push(n4[c2]);
              h3.push(l2), l2 = [];
              for (var u3 = false; c2 < n4.length; ++c2) {
                if (u3 && _o2(n4[c2].node)) {
                  if ("offsetlookup" === n4[c2].node.kind && n4[c2].node.offset && "number" === n4[c2].node.offset.kind) {
                    l2.push(n4[c2]);
                    continue;
                  }
                  h3.push(l2), l2 = [], u3 = false;
                }
                "call" === n4[c2].node.kind && (u3 = true), l2.push(n4[c2]), n4[c2].node.comments && Lr2.hasTrailingComment(n4[c2].node) && (h3.push(l2), l2 = [], u3 = false);
              }
              l2.length > 0 && h3.push(l2);
              function _4(t5) {
                var i5 = t5[1].length && "offsetlookup" === t5[1][0].node.kind;
                if (1 === t5[0].length) {
                  var n5 = t5[0][0].node;
                  return "variable" === n5.kind && ("this" === n5.name || d4 && s5(n5.name)) || Lo2(n5);
                }
                function s5(t6) {
                  return t6.length < e4.tabWidth;
                }
                var r5 = to2(t5[0]).node;
                return _o2(r5) && ("identifier" === r5.offset.kind || "variable" === r5.offset.kind) && i5;
              }
              var d4 = "expressionstatement" === t4.getParentNode().kind, p3 = h3.length >= 2 && !h3[1][0].node.comments && _4(h3);
              function f3(t5) {
                for (var e5 = [], i5 = 0; i5 < t5.length; i5++)
                  t5[i5 + 1] && t5[i5 + 1].needsParens ? (e5.push("(", t5[i5].printed, t5[i5 + 1].printed, ")"), i5++) : e5.push(t5[i5].printed);
                return Pr2(e5);
              }
              function T3(t5) {
                return 0 === t5.length ? "" : Gr2(Br2(Pr2([Wr2, Ur2(Wr2, t5.map(f3))])));
              }
              var k3 = h3.map(f3), E3 = Pr2(k3), m3 = p3 ? 3 : 2, x3 = h3.slice(0, m3).reduce(function(t5, e5) {
                return t5.concat(e5);
              }, []), y4 = x3.slice(1, -1).some(function(t5) {
                return Lr2.hasLeadingComment(t5.node);
              }) || x3.slice(0, -1).some(function(t5) {
                return Lr2.hasTrailingComment(t5.node);
              }) || h3[m3] && Lr2.hasLeadingComment(h3[m3][0].node), v4 = No2(t4, "encapsed");
              if (h3.length <= m3 && !y4 || v4)
                return Br2(E3);
              var A3 = to2(p3 ? h3.slice(1, 2)[0] : h3[0]).node, g4 = "call" !== A3.kind && s4(A3), N4 = Pr2([f3(h3[0]), p3 ? Pr2(h3.slice(1, 2).map(f3)) : "", g4 ? Wr2 : "", T3(h3.slice(p3 ? 2 : 1))]), L3 = n4.filter(function(t5) {
                return "call" === t5.node.kind;
              }).length;
              if (y4 || L3 >= 3 || k3.slice(0, -1).some(Kr2))
                return Br2(N4);
              return Pr2([Kr2(E3) || g4 ? Dr2 : "", Hr2([E3, N4])]);
            }(t3, e3, i3) : Pr2([t3.call(i3, "what"), Go2(t3, e3, i3)]);
          case "new":
            var C2 = n3.what && "class" === n3.what.kind && n3.what.isAnonymous;
            if (!C2 && 1 === n3.arguments.length && sa2(n3.arguments[0], e3.originalText, e3))
              return Pr2(["new "].concat(c(t3.call(qo2, "what")), [t3.call(i3, "what"), "(", Ur2(", ", t3.map(i3, "arguments")), ")"]));
            var b2 = [];
            if (b2.push("new "), C2)
              b2.push.apply(b2, [n3.what.leadingComments && "commentblock" === n3.what.leadingComments[0].kind ? Pr2([Lr2.printComments(n3.what.leadingComments, e3), " "]) : ""].concat(c(t3.call(function(t4) {
                return qo2(t4, e3, i3, { inline: true });
              }, "what")), ["class", n3.arguments.length > 0 ? Pr2([" ", Go2(t3, e3, i3)]) : "", Br2(t3.call(i3, "what"))]));
            else {
              var I3 = Pr2([t3.call(i3, "what"), Go2(t3, e3, i3)]);
              b2.push(lo2(n3.what) ? Gr2(I3) : I3);
            }
            return Pr2(b2);
          case "clone":
            return Pr2(["clone ", n3.what.comments ? Gr2(t3.call(i3, "what")) : t3.call(i3, "what")]);
          case "propertylookup":
          case "nullsafepropertylookup":
          case "staticlookup":
          case "offsetlookup":
            var S2, O2 = t3.getParentNode(), R3 = 0;
            do {
              S2 = t3.getParentNode(R3), R3++;
            } while (S2 && _o2(S2));
            var w2 = No2(t3, "encapsed") || S2 && ("new" === S2.kind || "assign" === S2.kind && "variable" !== S2.left.kind) || "offsetlookup" === n3.kind || (Lo2(n3.what) || "variable" === n3.what.kind) && ["identifier", "variable", "encapsedpart"].includes(n3.offset.kind) && O2 && !_o2(O2);
            return Pr2([t3.call(i3, "what"), w2 ? Yo2(t3, e3, i3) : Br2(Gr2(Pr2([Yr2, Yo2(t3, e3, i3)])))]);
          case "exit":
            return Br2(Pr2([n3.useDie ? "die" : "exit", "(", n3.expression ? sa2(n3.expression, e3.originalText, e3) ? t3.call(i3, "expression") : Pr2([Gr2(Pr2([Yr2, t3.call(i3, "expression")])), Yr2]) : Lr2.printDanglingComments(t3, e3), ")"]));
          case "global":
            return Br2(Pr2(["global ", Gr2(Pr2([Ur2(Pr2([",", Mr2]), t3.map(i3, "items"))]))]));
          case "include":
            return Pr2([n3.require ? "require" : "include", n3.once ? "_once" : "", " ", n3.target.comments ? Gr2(t3.call(i3, "target")) : t3.call(i3, "target")]);
          case "label":
            return Pr2([t3.call(i3, "name"), ":"]);
          case "goto":
            return Pr2(["goto ", t3.call(i3, "label")]);
          case "throw":
            return Pr2(["throw ", n3.what.comments ? Gr2(t3.call(i3, "what")) : t3.call(i3, "what")]);
          case "silent":
            return Pr2(["@", t3.call(i3, "expr")]);
          case "halt":
            return Pr2([ho2(n3) ? Pr2([Lr2.printDanglingComments(t3, e3, true), Wr2]) : "", "__halt_compiler();", n3.after]);
          case "eval":
            return Br2(Pr2(["eval(", sa2(n3.source, e3.originalText, e3) ? t3.call(i3, "source") : Pr2([Gr2(Pr2([Yr2, t3.call(i3, "source")])), Yr2]), ")"]));
          case "echo":
            var D2, P2 = t3.map(function(t4) {
              return i3(t4);
            }, "expressions");
            if (1 !== P2.length || n3.expressions[0].comments)
              P2.length > 0 && (D2 = go2(n3.expressions[0]) || n3.expressions[0].comments ? Gr2(P2[0]) : Vr2(P2[0]));
            else
              D2 = l(P2, 1)[0];
            return Br2(Pr2([n3.shortForm ? "" : "echo ", D2 || "", Gr2(Pr2(P2.slice(1).map(function(t4) {
              return Pr2([",", Mr2, t4]);
            })))]));
          case "print":
            return Pr2(["print ", n3.expression.comments ? Gr2(t3.call(i3, "expression")) : t3.call(i3, "expression")]);
          case "return":
            var U3 = [];
            if (U3.push("return"), n3.expr) {
              var M3 = t3.call(i3, "expr");
              U3.push(" ", n3.expr.comments ? Gr2(M3) : M3);
            }
            return ho2(n3) && U3.push(" ", Lr2.printDanglingComments(t3, e3, true)), Pr2(U3);
          case "isset":
          case "unset":
            return Br2(Pr2([n3.kind, Go2(t3, e3, i3, "variables")]));
          case "empty":
            return Br2(Pr2(["empty(", Gr2(Pr2([Yr2, t3.call(i3, "expression")])), Yr2, ")"]));
          case "variable":
            var F2 = t3.getParentNode(), B2 = t3.getParentNode(1), H2 = "assign" === F2.kind ? "" : n3.byref ? "&" : "", G2 = "encapsedpart" === F2.kind && "simple" === F2.syntax && F2.curly || B2 && "offsetlookup" === F2.kind && "encapsedpart" === B2.kind && "simple" === B2.syntax && B2.curly ? "" : "$", V2 = n3.curly ? "{" : "", Q2 = n3.curly ? "}" : "";
            return Pr2([H2, G2, V2, t3.call(i3, "name"), Q2]);
          case "constantstatement":
          case "classconstant":
            var W2, Y2 = qo2(t3, e3, i3), j2 = t3.map(function(t4) {
              return i3(t4);
            }, "constants");
            if (1 !== j2.length || n3.constants[0].comments)
              j2.length > 0 && (W2 = Gr2(j2[0]));
            else
              W2 = l(j2, 1)[0];
            return Br2(Pr2([].concat(c(Y2), [n3.visibility ? Pr2([n3.visibility, " "]) : "", "const", W2 ? Pr2([" ", W2]) : "", Gr2(Pr2(j2.slice(1).map(function(t4) {
              return Pr2([",", Wr2, t4]);
            })))])));
          case "constant":
            return ta2(n3.name, t3.call(i3, "name"), " =", n3.value, t3.call(i3, "value"), false, e3);
          case "static":
            var $3, z2 = t3.map(function(t4) {
              return i3(t4);
            }, "variables"), K3 = n3.variables.some(function(t4) {
              return t4.defaultValue;
            });
            if (1 !== z2.length || n3.variables[0].comments)
              z2.length > 0 && ($3 = Gr2(z2[0]));
            else
              $3 = l(z2, 1)[0];
            return Br2(Pr2(["static", $3 ? Pr2([" ", $3]) : "", Gr2(Pr2(z2.slice(1).map(function(t4) {
              return Pr2([",", K3 ? Wr2 : Mr2, t4]);
            })))]));
          case "staticvariable":
            return ta2(n3.variable, t3.call(i3, "variable"), " =", n3.defaultValue, t3.call(i3, "defaultValue"), false, e3);
          case "list":
          case "array":
            var X2 = "array" === n3.kind && Oo2(e3.phpVersion, "5.4") || "list" === n3.kind && (n3.shortForm || Oo2(e3.phpVersion, "7.1")), J2 = X2 ? "[" : Pr2([n3.kind, "("]), q2 = X2 ? "]" : ")";
            if (0 === n3.items.length)
              return ho2(n3) ? Br2(Pr2([J2, Lr2.printDanglingComments(t3, e3), Yr2, q2])) : Pr2([J2, q2]);
            var Z2 = to2(n3.items), tt2 = Z2 && "noop" === Z2.kind, et3 = l(n3.items.filter(function(t4) {
              return "noop" !== t4.kind;
            }).sort(function(t4, i4) {
              return e3.locStart(t4) - e3.locStart(i4);
            }), 1)[0], it3 = !(!et3 || !et3.key) && et3 && Zr2(e3.originalText, e3.locStart(n3), e3.locStart(et3));
            return Br2(Pr2([J2, Gr2(Pr2([Yr2, $o2(t3, e3, i3)])), tt2 ? "," : "", Qr(!tt2 && Ro2(e3, "5.0") ? Pr2([Z2 && Ao2(Z2) ? Wr2 : "", ","]) : ""), Lr2.printDanglingComments(t3, e3, true), Yr2, q2]), { shouldBreak: it3 });
          case "entry":
            var nt2 = n3.byRef ? "&" : "", st3 = n3.unpack ? "..." : "";
            return n3.key ? ta2(n3.key, t3.call(i3, "key"), " =>", n3.value, t3.call(i3, "value"), nt2, e3) : Pr2([nt2, st3, t3.call(i3, "value")]);
          case "yield":
            var rt3 = Pr2([n3.key ? Pr2([t3.call(i3, "key"), " => "]) : "", t3.call(i3, "value")]);
            return Pr2(["yield", n3.key || n3.value ? " " : "", n3.value && n3.value.comments ? Gr2(rt3) : rt3]);
          case "yieldfrom":
            return Pr2(["yield from ", n3.value.comments ? Gr2(t3.call(i3, "value")) : t3.call(i3, "value")]);
          case "unary":
            return Pr2([n3.type, t3.call(i3, "what")]);
          case "pre":
            return Pr2([n3.type + n3.type, t3.call(i3, "what")]);
          case "post":
            return Pr2([t3.call(i3, "what"), n3.type + n3.type]);
          case "cast":
            return Pr2(["(", n3.type, ") ", n3.expr.comments ? Gr2(t3.call(i3, "expr")) : t3.call(i3, "expr")]);
          case "assignref":
          case "assign":
            var ot3 = "assignref" === n3.kind;
            return ta2(n3.left, t3.call(i3, "left"), Pr2([" ", ot3 ? "=" : n3.operator]), n3.right, t3.call(i3, "right"), ot3, e3);
          case "bin":
            var at3 = t3.getParentNode(), ht3 = t3.getParentNode(1), lt3 = n3 !== at3.body && ("if" === at3.kind || "while" === at3.kind || "switch" === at3.kind || "do" === at3.kind), ct3 = Wo2(t3, i3, e3, false, lt3);
            if (lt3)
              return Pr2(ct3);
            if ("unary" === at3.kind || _o2(at3) && "offsetlookup" !== at3.kind)
              return Br2(Pr2([Gr2(Pr2([Yr2, Pr2(ct3)])), Yr2]));
            var ut3 = n3 !== at3.body && "for" === at3.kind || "retif" === at3.kind && ht3 && "return" !== ht3.kind, _t3 = ["assign", "property", "constant", "staticvariable", "entry"].includes(at3.kind), dt3 = "bin" === n3.left.kind && ro2(n3.type, n3.left.type);
            if (ut3 || Qo2(n3) && !dt3 || !Qo2(n3) && _t3)
              return Br2(Pr2(ct3));
            var pt3 = Pr2(ct3.slice(1));
            return Br2(Pr2([ct3.length > 0 ? ct3[0] : "", Gr2(pt3)]));
          case "retif":
            var ft3, Tt3 = [], kt3 = t3.getParentNode(), Et3 = 0;
            do {
              ft3 = t3.getParentNode(Et3), Et3++;
            } while (ft3 && "retif" === ft3.kind);
            var mt3 = ft3 || kt3, xt3 = "bin" === n3.falseExpr.kind ? Gr2(t3.call(i3, "falseExpr")) : t3.call(i3, "falseExpr"), yt3 = Pr2([n3.trueExpr ? Mr2 : " ", "?", n3.trueExpr ? Pr2([" ", "bin" === n3.trueExpr.kind ? Gr2(t3.call(i3, "trueExpr")) : t3.call(i3, "trueExpr"), Mr2]) : "", ":", n3.trueExpr ? Pr2([" ", xt3]) : Pr2([Vo2(n3.falseExpr) ? " " : Mr2, xt3])]);
            Tt3.push(yt3);
            var vt3 = function(t4) {
              return kt3 === mt3 ? Br2(t4) : t4;
            }, At3 = t3.getParentNode(1), gt3 = "cast" === kt3.kind && At3 ? At3 : kt3, Nt3 = ["propertylookup", "nullsafepropertylookup", "staticlookup"].includes(gt3.kind), Lt3 = t3.call(i3, "test");
            if (!n3.trueExpr) {
              var Ct3 = Pr2([Lt3, "bin" === gt3.kind || ["print", "echo", "return", "include"].includes(mt3.kind) ? Gr2(Pr2(Tt3)) : Pr2(Tt3)]);
              return "call" === gt3.kind && gt3.what === n3 || "unary" === gt3.kind || _o2(gt3) && "offsetlookup" !== gt3.kind ? Br2(Pr2([Gr2(Pr2([Yr2, Ct3])), Yr2])) : vt3(Ct3);
            }
            return vt3(Pr2(["retif" === n3.test.kind ? Gr2(Lt3) : Lt3, Gr2(Pr2(Tt3)), Nt3 ? Yr2 : ""]));
          case "boolean":
            return n3.value ? "true" : "false";
          case "number":
            return so2(n3.value);
          case "string":
            if ("encapsedpart" === t3.getParentNode().kind) {
              var bt3 = t3.getParentNode(1), It3 = 0, St3 = Oo2(e3.phpVersion, "7.3"), Ot3 = jr2;
              if ("heredoc" === bt3.type) {
                Ot3 = St3 ? Wr2 : jr2;
                var Rt3 = bt3.raw.split(/\r?\n/g);
                -1 === (It3 = Rt3[Rt3.length - 1].search(/\S/)) && (It3 = Rt3[Rt3.length - 2].search(/\S/));
              }
              return Ur2(Ot3, n3.raw.split(/\r?\n/g).map(function(t4, e4) {
                return e4 > 0 || 0 === n3.loc.start.column ? t4.substring(It3) : t4;
              }));
            }
            var wt3 = xo2(n3, e3) ? '"' : "'", Dt3 = n3.raw;
            return "b" === n3.raw[0] && (Dt3 = Dt3.slice(1)), ['"', "'"].includes(Dt3[0]) && (Dt3 = Dt3.substr(1)), ['"', "'"].includes(Dt3[Dt3.length - 1]) && (Dt3 = Dt3.substr(0, Dt3.length - 1)), Pr2(["b" === n3.raw[0] ? "b" : "", wt3, Ur2(jr2, Dt3.split(/\r?\n/g)), wt3]);
          case "intersectiontype":
            return ra2(t3, i3, "&");
          case "uniontype":
            return ra2(t3, i3, "|");
          case "encapsedpart":
            var Pt3 = "simple" === n3.syntax && n3.curly || "complex" === n3.syntax ? Pr2([n3.curly ? "$" : "", "{"]) : "", Ut2 = "simple" === n3.syntax && n3.curly || "complex" === n3.syntax ? "}" : "";
            return Pr2([Pt3, t3.call(i3, "expression"), Ut2]);
          case "encapsed":
            switch (n3.type) {
              case "string":
              case "shell":
              case "heredoc":
                var Mt3 = Oo2(e3.phpVersion, "7.3") ? Wr2 : jr2;
                return Pr2([jo2(n3), "heredoc" === n3.type ? Mt3 : "", Pr2(t3.map(i3, "value")), jo2(n3, { opening: false }), "heredoc" === n3.type && uo2(t3) ? Wr2 : ""]);
              default:
                return "Have not implemented kind ".concat(n3.type, " yet.");
            }
          case "inline":
            return Ur2(jr2, n3.raw.replace("___PSEUDO_INLINE_PLACEHOLDER___", "").split(/\r?\n/g));
          case "magic":
            return n3.value;
          case "nowdoc":
            var Ft3 = Oo2(e3.phpVersion, "7.3") ? Wr2 : jr2;
            return Pr2(["<<<'", n3.label, "'", Ft3, Ur2(Ft3, n3.value.split(/\r?\n/g)), Ft3, n3.label, uo2(t3) ? Wr2 : ""]);
          case "name":
            return Pr2(["rn" === n3.resolution ? "namespace\\" : "", n3.name]);
          case "literal":
            return t3.call(i3, "value");
          case "parentreference":
            return "parent";
          case "selfreference":
            return "self";
          case "staticreference":
            return "static";
          case "typereference":
            return n3.name;
          case "nullkeyword":
            return "null";
          case "identifier":
            return "method" === t3.getParentNode().kind && (n3.name = bo2(n3.name)), t3.call(i3, "name");
          case "match":
            var Bt3 = t3.map(function(t4, e4) {
              var n4 = null === t4.getValue().conds ? "default" : Pr2(t4.map(function(t5, e5) {
                return Br2(Pr2(e5 > 0 ? [",", Mr2, i3(t5)] : [i3(t5)]));
              }, "conds")), s4 = t4.call(i3, "body");
              return Pr2(e4 > 0 ? [", ", Wr2, n4, " => ", s4] : [Wr2, n4, " => ", s4]);
            }, "arms");
            return Br2(Pr2(["match (", Br2(Pr2([Yr2, Gr2(Pr2([t3.call(i3, "cond")])), Yr2])), ") {", Br2(Gr2(Pr2([].concat(c(Bt3), [e3.trailingCommaPHP ? Qr(",") : ""])))), " ", Yr2, "}"]));
          case "noop":
            return n3.comments ? Lr2.printComments(t3.getValue().comments, e3) : "";
          case "namedargument":
            return Pr2([n3.name, ": ", t3.call(i3, "value")]);
          case "enumcase":
            return Br2(Pr2(["case ", t3.call(i3, "name"), n3.value ? Pr2([" =", ia(n3.name, n3.value, t3.call(i3, "value"), false, e3)]) : ""]));
          case "variadicplaceholder":
            return "...";
          default:
            return "Have not implemented kind ".concat(n3.kind, " yet.");
        }
      }(t2, e2, i2), r2 = [], o2 = Rr2(t2);
      return o2 && r2.unshift("("), r2.push(s2), o2 && r2.push(")"), no2(t2) && r2.push(";"), ao2(t2) && r2.push(Wr2), Pr2(r2);
    };
    var aa = function(t2, e2) {
      if (["loc", "range", "raw", "comments", "leadingComments", "trailingComments", "parenthesizedExpression", "parent", "prev", "start", "end", "tokens", "errors", "extra"].forEach(function(t3) {
        delete e2[t3];
      }), "string" === t2.kind && delete e2.isDoubleQuote, ["array", "list"].includes(t2.kind) && delete e2.shortForm, "inline" === t2.kind) {
        if (t2.value.includes("___PSEUDO_INLINE_PLACEHOLDER___"))
          return null;
        e2.value = e2.value.replace(/\r\n?|\n/g, "");
      }
      if (("continue" === t2.kind || "break" === t2.kind) && t2.level) {
        var i2 = e2.level;
        "number" === i2.kind && (e2.level = "1" === i2.value ? null : i2);
      }
      if ("block" === t2.kind && 1 === t2.children.length && "block" === t2.children[0].kind)
        for (; "block" === e2.children[0].kind; )
          e2.children = e2.children[0].children;
      if ("number" === t2.kind && (e2.value = Ys2.printNumber(t2.value)), ["foreach", "for", "if", "while", "do"].includes(t2.kind) && (t2.body && "block" !== t2.body.kind ? e2.body = { kind: "block", children: [e2.body] } : e2.body = e2.body ? e2.body : null, t2.alternate && "block" !== t2.alternate.kind ? e2.alternate = { kind: "block", children: [e2.alternate] } : e2.alternate = e2.alternate ? e2.alternate : null), "usegroup" === t2.kind && "string" == typeof t2.name && (e2.name = e2.name.replace(/^\\/, "")), "useitem" === t2.kind && (e2.name = e2.name.replace(/^\\/, "")), "method" === t2.kind && "identifier" === t2.name.kind && (e2.name.name = Ys2.normalizeMagicMethodName(e2.name.name)), "noop" === t2.kind)
        return null;
    }, ha2 = "PHP", la = { phpVersion: { since: "0.13.0", category: ha2, type: "choice", default: "7.0", description: "Minimum target PHP version.", choices: [{ value: "5.0" }, { value: "5.1" }, { value: "5.2" }, { value: "5.3" }, { value: "5.4" }, { value: "5.5" }, { value: "5.6" }, { value: "7.0" }, { value: "7.1" }, { value: "7.2" }, { value: "7.3" }, { value: "7.4" }, { value: "8.0" }, { value: "8.1" }] }, trailingCommaPHP: { since: "0.0.0", category: ha2, type: "boolean", default: true, description: "Print trailing commas wherever possible when multi-line." }, braceStyle: { since: "0.10.0", category: ha2, type: "choice", default: "psr-2", description: "Print one space or newline for code blocks (classes and functions).", choices: [{ value: "psr-2", description: "Use PSR-2 brace style." }, { value: "1tbs", description: "Use 1tbs brace style." }] } }, ca2 = function(t2, e2, i2, n2) {
      if ("length" !== i2 && "prototype" !== i2 && "arguments" !== i2 && "caller" !== i2) {
        var s2 = Object.getOwnPropertyDescriptor(t2, i2), r2 = Object.getOwnPropertyDescriptor(e2, i2);
        !ua(s2, r2) && n2 || Object.defineProperty(t2, i2, r2);
      }
    }, ua = function(t2, e2) {
      return void 0 === t2 || t2.configurable || t2.writable === e2.writable && t2.enumerable === e2.enumerable && t2.configurable === e2.configurable && (t2.writable || t2.value === e2.value);
    }, _a2 = function(t2, e2) {
      var i2 = Object.getPrototypeOf(e2);
      i2 !== Object.getPrototypeOf(t2) && Object.setPrototypeOf(t2, i2);
    }, da2 = function(t2, e2) {
      return "/* Wrapped ".concat(t2, "*/\n").concat(e2);
    }, pa = Object.getOwnPropertyDescriptor(Function.prototype, "toString"), fa2 = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name"), Ta2 = function(t2, e2, i2) {
      var n2 = "" === i2 ? "" : "with ".concat(i2.trim(), "() "), s2 = da2.bind(null, n2, e2.toString());
      Object.defineProperty(s2, "name", fa2), Object.defineProperty(t2, "toString", r(r({}, pa), {}, { value: s2 }));
    }, ka2 = function(t2, e2) {
      var i2, n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, s2 = n2.ignoreNonConfigurable, r2 = void 0 !== s2 && s2, o2 = t2.name, a2 = d2(Reflect.ownKeys(e2));
      try {
        for (a2.s(); !(i2 = a2.n()).done; ) {
          var h2 = i2.value;
          ca2(t2, e2, h2, r2);
        }
      } catch (t3) {
        a2.e(t3);
      } finally {
        a2.f();
      }
      return _a2(t2, e2), Ta2(t2, e2, o2), t2;
    }, Ea2 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : {};
    function ma(t2) {
      return t2 && t2.default || t2;
    }
    var xa2, ya2 = function() {
      var t2 = {};
      return t2.promise = new Promise(function(e2, i2) {
        t2.resolve = e2, t2.reject = i2;
      }), t2;
    }, va2 = function(t2, e2) {
      return t2(e2 = { exports: {} }, e2.exports), e2.exports;
    }(function(t2, e2) {
      var i2 = Ea2 && Ea2.__awaiter || function(t3, e3, i3, n3) {
        return new (i3 || (i3 = Promise))(function(s3, r3) {
          function o2(t4) {
            try {
              h2(n3.next(t4));
            } catch (t5) {
              r3(t5);
            }
          }
          function a2(t4) {
            try {
              h2(n3.throw(t4));
            } catch (t5) {
              r3(t5);
            }
          }
          function h2(t4) {
            t4.done ? s3(t4.value) : new i3(function(e4) {
              e4(t4.value);
            }).then(o2, a2);
          }
          h2((n3 = n3.apply(t3, e3 || [])).next());
        });
      }, n2 = Ea2 && Ea2.__importDefault || function(t3) {
        return t3 && t3.__esModule ? t3 : { default: t3 };
      };
      Object.defineProperty(e2, "__esModule", { value: true });
      var s2 = n2(ya2);
      function r2(t3) {
        var e3, n3, r3, a2 = this, h2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "maxAge", l2 = function() {
          return i2(a2, void 0, void 0, o().mark(function a3() {
            var l3, c3, u3, _3, p2 = this;
            return o().wrap(function(a4) {
              for (; ; )
                switch (a4.prev = a4.next) {
                  case 0:
                    if (void 0 === e3) {
                      a4.next = 2;
                      break;
                    }
                    return a4.abrupt("return");
                  case 2:
                    l3 = function(a5) {
                      return i2(p2, void 0, void 0, o().mark(function i3() {
                        var l4;
                        return o().wrap(function(i4) {
                          for (; ; )
                            switch (i4.prev = i4.next) {
                              case 0:
                                if (r3 = s2.default(), !((l4 = a5[1][h2] - Date.now()) <= 0)) {
                                  i4.next = 6;
                                  break;
                                }
                                return t3.delete(a5[0]), r3.resolve(), i4.abrupt("return");
                              case 6:
                                return e3 = a5[0], "function" == typeof (n3 = setTimeout(function() {
                                  t3.delete(a5[0]), r3 && r3.resolve();
                                }, l4)).unref && n3.unref(), i4.abrupt("return", r3.promise);
                              case 10:
                              case "end":
                                return i4.stop();
                            }
                        }, i3);
                      }));
                    }, a4.prev = 3, c3 = d2(t3), a4.prev = 5, c3.s();
                  case 7:
                    if ((u3 = c3.n()).done) {
                      a4.next = 13;
                      break;
                    }
                    return _3 = u3.value, a4.next = 11, l3(_3);
                  case 11:
                    a4.next = 7;
                    break;
                  case 13:
                    a4.next = 18;
                    break;
                  case 15:
                    a4.prev = 15, a4.t0 = a4.catch(5), c3.e(a4.t0);
                  case 18:
                    return a4.prev = 18, c3.f(), a4.finish(18);
                  case 21:
                    a4.next = 25;
                    break;
                  case 23:
                    a4.prev = 23, a4.t1 = a4.catch(3);
                  case 25:
                    e3 = void 0;
                  case 26:
                  case "end":
                    return a4.stop();
                }
            }, a3, null, [[3, 23], [5, 15, 18, 21]]);
          }));
        }, c2 = function() {
          e3 = void 0, void 0 !== n3 && (clearTimeout(n3), n3 = void 0), void 0 !== r3 && (r3.reject(void 0), r3 = void 0);
        }, u2 = t3.set.bind(t3);
        return t3.set = function(i3, n4) {
          t3.has(i3) && t3.delete(i3);
          var s3 = u2(i3, n4);
          return e3 && e3 === i3 && c2(), l2(), s3;
        }, l2(), t3;
      }
      e2.default = r2, t2.exports = r2, t2.exports.default = r2;
    });
    (xa2 = va2) && xa2.__esModule && Object.prototype.hasOwnProperty.call(xa2, "default") && xa2.default;
    var Aa2 = va2, ga2 = /* @__PURE__ */ new WeakMap(), Na2 = /* @__PURE__ */ new WeakMap(), La2 = function(t2) {
      var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i2 = e2.cacheKey, n2 = e2.cache, s2 = void 0 === n2 ? /* @__PURE__ */ new Map() : n2, r2 = e2.maxAge;
      "number" == typeof r2 && Aa2(s2);
      var o2 = function() {
        for (var e3 = arguments.length, n3 = new Array(e3), o3 = 0; o3 < e3; o3++)
          n3[o3] = arguments[o3];
        var a2 = i2 ? i2(n3) : n3[0], h2 = s2.get(a2);
        if (h2)
          return h2.data;
        var l2 = t2.apply(this, n3);
        return s2.set(a2, { data: l2, maxAge: r2 ? Date.now() + r2 : Number.POSITIVE_INFINITY }), l2;
      };
      return ka2(o2, t2, { ignoreNonConfigurable: true }), Na2.set(o2, s2), o2;
    };
    La2.decorator = function() {
      var t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      return function(e2, i2, n2) {
        var s2 = e2[i2];
        if ("function" != typeof s2)
          throw new TypeError("The decorated value must be a function");
        delete n2.value, delete n2.writable, n2.get = function() {
          if (!ga2.has(this)) {
            var e3 = La2(s2, t2);
            return ga2.set(this, e3), e3;
          }
          return ga2.get(this);
        };
      };
    }, La2.clear = function(t2) {
      var e2 = Na2.get(t2);
      if (!e2)
        throw new TypeError("Can't clear a function that was not memoized!");
      if ("function" != typeof e2.clear)
        throw new TypeError("The cache Map can't be cleared!");
      e2.clear();
    };
    var Ca2 = /@prettier|@format/, ba2 = La2(function(t2) {
      var e2 = As2(t2), i2 = l(e2.children, 1)[0], n2 = l(e2.comments.filter(function(t3) {
        return "commentblock" === t3.kind;
      }), 1)[0];
      if (i2 && n2 && n2.loc.start.line < i2.loc.start.line)
        return n2;
    });
    var Ia2 = function(t2) {
      if (!Ca2.test(t2))
        return false;
      var e2 = ba2(t2);
      if (e2) {
        var i2 = e2.value;
        return Ca2.test(i2);
      }
      return false;
    }, Sa2 = function(t2) {
      var e2 = ba2(t2);
      if (e2) {
        var i2 = e2.loc, n2 = i2.start.offset, s2 = i2.end.offset, r2 = t2.substring(0, n2), o2 = t2.substring(s2);
        return "".concat(r2).concat(function(t3, e3) {
          var i3 = t3.split(/\r?\n/g);
          if (1 === i3.length) {
            var n3 = l(/\/*\*\*(.*)\*\//.exec(i3[0]), 2)[1];
            i3 = ["/**", " * ".concat(n3.trim()), " */"];
          }
          var s3 = i3.findIndex(function(t4) {
            return /@\S/.test(t4);
          }) || 1;
          return i3.splice(s3, 0, " * @format"), i3.join(function(t4) {
            var e4 = t4.indexOf("\n");
            return e4 >= 0 && "\r" === t4.charAt(e4 - 1) ? "\r\n" : "\n";
          }(e3));
        }(e2.value, t2)).concat(o2);
      }
      var a2 = "<?php";
      if (!t2.startsWith(a2))
        return t2;
      var h2 = a2.length, c2 = t2.substring(0, h2), u2 = t2.substring(h2);
      return "".concat(c2, "\n/** \n * @format \n */\n").concat(u2);
    }, Oa2 = "programming", Ra2 = "text.html.php", wa2 = "application/x-httpd-php", Da = "#4F5D95", Pa2 = [".php", ".aw", ".ctp", ".fcgi", ".inc", ".php3", ".php4", ".php5", ".phps", ".phpt"], Ua2 = [".php", ".php_cs", ".php_cs.dist", "Phakefile"], Ma2 = ["php"], Fa2 = ["inc"], Ba2 = { name: "PHP", type: Oa2, tmScope: Ra2, aceMode: "php", codemirrorMode: "php", codemirrorMimeType: wa2, color: Da, extensions: Pa2, filenames: Ua2, interpreters: Ma2, aliases: Fa2, languageId: 272 }, Ha2 = Object.freeze({ __proto__: null, name: "PHP", type: Oa2, tmScope: Ra2, aceMode: "php", codemirrorMode: "php", codemirrorMimeType: wa2, color: Da, extensions: Pa2, filenames: Ua2, interpreters: Ma2, aliases: Fa2, languageId: 272, default: Ba2 }), Ga2 = "HTML+PHP", Va2 = "markup", Qa2 = "#4f5d95", Wa2 = "text.html.php", Ya2 = "HTML", ja2 = [".phtml"], $a2 = "application/x-httpd-php", za2 = { name: Ga2, type: Va2, color: Qa2, tmScope: Wa2, group: Ya2, extensions: ja2, aceMode: "php", codemirrorMode: "php", codemirrorMimeType: $a2, languageId: 151 }, Ka2 = Object.freeze({ __proto__: null, name: Ga2, type: Va2, color: Qa2, tmScope: Wa2, group: Ya2, extensions: ja2, aceMode: "php", codemirrorMode: "php", codemirrorMimeType: $a2, languageId: 151, default: za2 }), Xa2 = ma(Ha2), Ja2 = ma(Ka2), qa2 = n.default.doc.builders, Za2 = qa2.join, th = qa2.hardline, eh = Ia2, ih = Sa2;
    function nh(t2, e2) {
      var i2 = e2.extend, n2 = e2.override, s2 = {};
      for (var r2 in t2) {
        s2["languageId" === r2 ? "linguistLanguageId" : r2] = t2[r2];
      }
      if (i2)
        for (var o2 in i2)
          s2[o2] = (s2[o2] || []).concat(i2[o2]);
      for (var a2 in n2)
        s2[a2] = n2[a2];
      return s2;
    }
    var sh2 = [nh(Xa2, { override: { parsers: ["php"], vscodeLanguageIds: ["php"] } }), nh(Ja2, { override: { parsers: ["php"], vscodeLanguageIds: ["php"] } })], rh = function(t2) {
      return function(e2) {
        return e2.loc && e2.loc[t2] && e2.loc[t2].offset;
      };
    }, oh = { php: { parse: As2, astFormat: "php", locStart: rh("start"), locEnd: rh("end"), hasPragma: eh } }, ah = { php: { print: oa, insertPragma: ih, massageAstNode: aa, getCommentChildNodes: Lr2.getCommentChildNodes, canAttachComment: Lr2.canAttachComment, isBlockComment: Lr2.isBlockComment, handleComments: { ownLine: Lr2.handleOwnLineComment, endOfLine: Lr2.handleEndOfLineComment, remaining: Lr2.handleRemainingComment }, willPrintOwnComments: function(t2) {
      var e2 = t2.getValue();
      return e2 && "noop" === e2.kind;
    }, printComment: function(t2) {
      var e2 = t2.getValue();
      switch (e2.kind) {
        case "commentblock":
          if (!e2.value.includes("\n"))
            return e2.value;
          var i2 = e2.value.split(/\r?\n/g);
          return i2.slice(1, i2.length - 1).every(function(t3) {
            return "*" === t3.trim()[0];
          }) ? Za2(th, i2.map(function(t3, e3) {
            return (e3 > 0 ? " " : "") + (e3 < i2.length - 1 ? t3.trim() : t3.trimLeft());
          })) : e2.value;
        case "commentline":
          return e2.value.trimRight();
        default:
          throw new Error("Not a comment: ".concat(JSON.stringify(e2)));
      }
    }, hasPrettierIgnore: function(t2) {
      var e2 = function(t3) {
        return t3.value.includes("prettier-ignore") && !t3.value.includes("prettier-ignore-start") && !t3.value.includes("prettier-ignore-end");
      }, i2 = t2.getParentNode(), n2 = t2.getNode();
      return n2 && "classconstant" !== n2.kind && n2.comments && n2.comments.length > 0 && n2.comments.some(e2) || n2 && "constant" === n2.kind && i2 && "classconstant" === i2.kind && i2.comments && i2.comments.length > 0 && i2.comments.some(e2);
    } } }, hh = { languages: sh2, printers: ah, parsers: oh, options: la, defaultOptions: { tabWidth: 4 } }, lh = hh.languages, ch = hh.printers, uh = hh.parsers, _h = hh.options, dh = hh.defaultOptions;
    t.default = hh, t.defaultOptions = dh, t.languages = lh, t.options = _h, t.parsers = uh, t.printers = ch, Object.defineProperty(t, "__esModule", { value: true });
  });
})(standalone$1, standalone$1.exports);
var standaloneExports = standalone$1.exports;
const __prettierPhp = /* @__PURE__ */ getDefaultExportFromCjs(standaloneExports);
var K = (r, n) => () => (n || r((n = { exports: {} }).exports, n), n.exports);
var pe = K((Lf2, Dt2) => {
  var Ye2 = function(r) {
    return r && r.Math == Math && r;
  };
  Dt2.exports = Ye2(typeof globalThis == "object" && globalThis) || Ye2(typeof window == "object" && window) || Ye2(typeof self == "object" && self) || Ye2(typeof global == "object" && global) || function() {
    return this;
  }() || Function("return this")();
});
var be = K((zf, Lt2) => {
  Lt2.exports = function(r) {
    try {
      return !!r();
    } catch {
      return true;
    }
  };
});
var Oe = K((Bf2, zt2) => {
  var ia = be();
  zt2.exports = !ia(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] != 7;
  });
});
var xr = K((Ff2, Bt2) => {
  var sa2 = be();
  Bt2.exports = !sa2(function() {
    var r = (function() {
    }).bind();
    return typeof r != "function" || r.hasOwnProperty("prototype");
  });
});
var Ze = K((Uf2, Ft2) => {
  var oa = xr(), Xe = Function.prototype.call;
  Ft2.exports = oa ? Xe.bind(Xe) : function() {
    return Xe.apply(Xe, arguments);
  };
});
var Vt = K((Wt) => {
  var Ut = {}.propertyIsEnumerable, $t2 = Object.getOwnPropertyDescriptor, aa = $t2 && !Ut.call({ 1: 2 }, 1);
  Wt.f = aa ? function(n) {
    var s = $t2(this, n);
    return !!s && s.enumerable;
  } : Ut;
});
var Sr = K((Wf, Gt2) => {
  Gt2.exports = function(r, n) {
    return { enumerable: !(r & 1), configurable: !(r & 2), writable: !(r & 4), value: n };
  };
});
var xe = K((Vf, Kt2) => {
  var Ht = xr(), Jt2 = Function.prototype, kr2 = Jt2.call, ua = Ht && Jt2.bind.bind(kr2, kr2);
  Kt2.exports = Ht ? ua : function(r) {
    return function() {
      return kr2.apply(r, arguments);
    };
  };
});
var Xt = K((Gf2, Yt2) => {
  var Qt2 = xe(), ca2 = Qt2({}.toString), la = Qt2("".slice);
  Yt2.exports = function(r) {
    return la(ca2(r), 8, -1);
  };
});
var en = K((Hf, Zt2) => {
  var fa2 = xe(), pa = be(), ha2 = Xt(), Or2 = Object, da2 = fa2("".split);
  Zt2.exports = pa(function() {
    return !Or2("z").propertyIsEnumerable(0);
  }) ? function(r) {
    return ha2(r) == "String" ? da2(r, "") : Or2(r);
  } : Or2;
});
var Tr = K((Jf2, rn2) => {
  rn2.exports = function(r) {
    return r == null;
  };
});
var Er = K((Kf2, tn2) => {
  var va2 = Tr(), ma = TypeError;
  tn2.exports = function(r) {
    if (va2(r))
      throw ma("Can't call method on " + r);
    return r;
  };
});
var er = K((Qf2, nn2) => {
  var ga2 = en(), ya2 = Er();
  nn2.exports = function(r) {
    return ga2(ya2(r));
  };
});
var Ar = K((Yf2, sn2) => {
  var qr = typeof document == "object" && document.all, wa2 = typeof qr > "u" && qr !== void 0;
  sn2.exports = { all: qr, IS_HTMLDDA: wa2 };
});
var he = K((Xf, an2) => {
  var on = Ar(), _a2 = on.all;
  an2.exports = on.IS_HTMLDDA ? function(r) {
    return typeof r == "function" || r === _a2;
  } : function(r) {
    return typeof r == "function";
  };
});
var Ne = K((Zf2, ln2) => {
  var un2 = he(), cn2 = Ar(), ba2 = cn2.all;
  ln2.exports = cn2.IS_HTMLDDA ? function(r) {
    return typeof r == "object" ? r !== null : un2(r) || r === ba2;
  } : function(r) {
    return typeof r == "object" ? r !== null : un2(r);
  };
});
var rr = K((ep, fn2) => {
  var Pr2 = pe(), xa2 = he(), Sa2 = function(r) {
    return xa2(r) ? r : void 0;
  };
  fn2.exports = function(r, n) {
    return arguments.length < 2 ? Sa2(Pr2[r]) : Pr2[r] && Pr2[r][n];
  };
});
var hn = K((rp, pn2) => {
  var ka2 = xe();
  pn2.exports = ka2({}.isPrototypeOf);
});
var vn = K((tp, dn2) => {
  var Oa2 = rr();
  dn2.exports = Oa2("navigator", "userAgent") || "";
});
var xn = K((np, bn2) => {
  var _n2 = pe(), Ir2 = vn(), mn2 = _n2.process, gn2 = _n2.Deno, yn = mn2 && mn2.versions || gn2 && gn2.version, wn2 = yn && yn.v8, de, tr2;
  wn2 && (de = wn2.split("."), tr2 = de[0] > 0 && de[0] < 4 ? 1 : +(de[0] + de[1]));
  !tr2 && Ir2 && (de = Ir2.match(/Edge\/(\d+)/), (!de || de[1] >= 74) && (de = Ir2.match(/Chrome\/(\d+)/), de && (tr2 = +de[1])));
  bn2.exports = tr2;
});
var Rr = K((ip, kn2) => {
  var Sn2 = xn(), Ta2 = be();
  kn2.exports = !!Object.getOwnPropertySymbols && !Ta2(function() {
    var r = Symbol();
    return !String(r) || !(Object(r) instanceof Symbol) || !Symbol.sham && Sn2 && Sn2 < 41;
  });
});
var Cr = K((sp, On2) => {
  var Ea2 = Rr();
  On2.exports = Ea2 && !Symbol.sham && typeof Symbol.iterator == "symbol";
});
var Nr = K((op, Tn2) => {
  var qa2 = rr(), Aa2 = he(), Pa2 = hn(), Ia2 = Cr(), Ra2 = Object;
  Tn2.exports = Ia2 ? function(r) {
    return typeof r == "symbol";
  } : function(r) {
    var n = qa2("Symbol");
    return Aa2(n) && Pa2(n.prototype, Ra2(r));
  };
});
var qn = K((ap, En2) => {
  var Ca2 = String;
  En2.exports = function(r) {
    try {
      return Ca2(r);
    } catch {
      return "Object";
    }
  };
});
var Pn = K((up, An) => {
  var Na2 = he(), ja2 = qn(), Ma2 = TypeError;
  An.exports = function(r) {
    if (Na2(r))
      return r;
    throw Ma2(ja2(r) + " is not a function");
  };
});
var Rn = K((cp, In2) => {
  var Da = Pn(), La2 = Tr();
  In2.exports = function(r, n) {
    var s = r[n];
    return La2(s) ? void 0 : Da(s);
  };
});
var Nn = K((lp, Cn2) => {
  var jr2 = Ze(), Mr2 = he(), Dr2 = Ne(), za2 = TypeError;
  Cn2.exports = function(r, n) {
    var s, c;
    if (n === "string" && Mr2(s = r.toString) && !Dr2(c = jr2(s, r)) || Mr2(s = r.valueOf) && !Dr2(c = jr2(s, r)) || n !== "string" && Mr2(s = r.toString) && !Dr2(c = jr2(s, r)))
      return c;
    throw za2("Can't convert object to primitive value");
  };
});
var Mn = K((fp, jn2) => {
  jn2.exports = false;
});
var nr = K((pp, Ln2) => {
  var Dn2 = pe(), Ba2 = Object.defineProperty;
  Ln2.exports = function(r, n) {
    try {
      Ba2(Dn2, r, { value: n, configurable: true, writable: true });
    } catch {
      Dn2[r] = n;
    }
    return n;
  };
});
var ir = K((hp, Bn2) => {
  var Fa2 = pe(), Ua2 = nr(), zn2 = "__core-js_shared__", $a2 = Fa2[zn2] || Ua2(zn2, {});
  Bn2.exports = $a2;
});
var Lr = K((dp, Un2) => {
  var Wa2 = Mn(), Fn2 = ir();
  (Un2.exports = function(r, n) {
    return Fn2[r] || (Fn2[r] = n !== void 0 ? n : {});
  })("versions", []).push({ version: "3.26.1", mode: Wa2 ? "pure" : "global", copyright: "© 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE", source: "https://github.com/zloirock/core-js" });
});
var Wn = K((vp2, $n2) => {
  var Va2 = Er(), Ga2 = Object;
  $n2.exports = function(r) {
    return Ga2(Va2(r));
  };
});
var Te = K((mp, Vn2) => {
  var Ha2 = xe(), Ja2 = Wn(), Ka2 = Ha2({}.hasOwnProperty);
  Vn2.exports = Object.hasOwn || function(n, s) {
    return Ka2(Ja2(n), s);
  };
});
var zr = K((gp, Gn2) => {
  var Qa2 = xe(), Ya2 = 0, Xa2 = Math.random(), Za2 = Qa2(1 .toString);
  Gn2.exports = function(r) {
    return "Symbol(" + (r === void 0 ? "" : r) + ")_" + Za2(++Ya2 + Xa2, 36);
  };
});
var Xn = K((yp, Yn2) => {
  var eu2 = pe(), ru2 = Lr(), Hn2 = Te(), tu2 = zr(), Jn2 = Rr(), Qn2 = Cr(), je2 = ru2("wks"), Ee = eu2.Symbol, Kn2 = Ee && Ee.for, nu2 = Qn2 ? Ee : Ee && Ee.withoutSetter || tu2;
  Yn2.exports = function(r) {
    if (!Hn2(je2, r) || !(Jn2 || typeof je2[r] == "string")) {
      var n = "Symbol." + r;
      Jn2 && Hn2(Ee, r) ? je2[r] = Ee[r] : Qn2 && Kn2 ? je2[r] = Kn2(n) : je2[r] = nu2(n);
    }
    return je2[r];
  };
});
var ti = K((wp, ri2) => {
  var iu = Ze(), Zn2 = Ne(), ei = Nr(), su = Rn(), ou = Nn(), au = Xn(), uu2 = TypeError, cu = au("toPrimitive");
  ri2.exports = function(r, n) {
    if (!Zn2(r) || ei(r))
      return r;
    var s = su(r, cu), c;
    if (s) {
      if (n === void 0 && (n = "default"), c = iu(s, r, n), !Zn2(c) || ei(c))
        return c;
      throw uu2("Can't convert object to primitive value");
    }
    return n === void 0 && (n = "number"), ou(r, n);
  };
});
var Br = K((_p, ni) => {
  var lu2 = ti(), fu = Nr();
  ni.exports = function(r) {
    var n = lu2(r, "string");
    return fu(n) ? n : n + "";
  };
});
var oi = K((bp, si) => {
  var pu = pe(), ii = Ne(), Fr2 = pu.document, hu = ii(Fr2) && ii(Fr2.createElement);
  si.exports = function(r) {
    return hu ? Fr2.createElement(r) : {};
  };
});
var Ur = K((xp, ai) => {
  var du = Oe(), vu = be(), mu = oi();
  ai.exports = !du && !vu(function() {
    return Object.defineProperty(mu("div"), "a", { get: function() {
      return 7;
    } }).a != 7;
  });
});
var $r = K((ci) => {
  var gu2 = Oe(), yu = Ze(), wu = Vt(), _u2 = Sr(), bu = er(), xu = Br(), Su2 = Te(), ku = Ur(), ui2 = Object.getOwnPropertyDescriptor;
  ci.f = gu2 ? ui2 : function(n, s) {
    if (n = bu(n), s = xu(s), ku)
      try {
        return ui2(n, s);
      } catch {
      }
    if (Su2(n, s))
      return _u2(!yu(wu.f, n, s), n[s]);
  };
});
var fi = K((kp, li) => {
  var Ou = Oe(), Tu = be();
  li.exports = Ou && Tu(function() {
    return Object.defineProperty(function() {
    }, "prototype", { value: 42, writable: false }).prototype != 42;
  });
});
var Wr = K((Op, pi2) => {
  var Eu = Ne(), qu = String, Au = TypeError;
  pi2.exports = function(r) {
    if (Eu(r))
      return r;
    throw Au(qu(r) + " is not an object");
  };
});
var or = K((di2) => {
  var Pu = Oe(), Iu = Ur(), Ru = fi(), sr2 = Wr(), hi = Br(), Cu = TypeError, Vr2 = Object.defineProperty, Nu2 = Object.getOwnPropertyDescriptor, Gr2 = "enumerable", Hr2 = "configurable", Jr2 = "writable";
  di2.f = Pu ? Ru ? function(n, s, c) {
    if (sr2(n), s = hi(s), sr2(c), typeof n == "function" && s === "prototype" && "value" in c && Jr2 in c && !c[Jr2]) {
      var o = Nu2(n, s);
      o && o[Jr2] && (n[s] = c.value, c = { configurable: Hr2 in c ? c[Hr2] : o[Hr2], enumerable: Gr2 in c ? c[Gr2] : o[Gr2], writable: false });
    }
    return Vr2(n, s, c);
  } : Vr2 : function(n, s, c) {
    if (sr2(n), s = hi(s), sr2(c), Iu)
      try {
        return Vr2(n, s, c);
      } catch {
      }
    if ("get" in c || "set" in c)
      throw Cu("Accessors not supported");
    return "value" in c && (n[s] = c.value), n;
  };
});
var Kr = K((Ep2, vi2) => {
  var ju2 = Oe(), Mu = or(), Du = Sr();
  vi2.exports = ju2 ? function(r, n, s) {
    return Mu.f(r, n, Du(1, s));
  } : function(r, n, s) {
    return r[n] = s, r;
  };
});
var yi = K((qp, gi) => {
  var Qr = Oe(), Lu = Te(), mi = Function.prototype, zu = Qr && Object.getOwnPropertyDescriptor, Yr2 = Lu(mi, "name"), Bu = Yr2 && (function() {
  }).name === "something", Fu = Yr2 && (!Qr || Qr && zu(mi, "name").configurable);
  gi.exports = { EXISTS: Yr2, PROPER: Bu, CONFIGURABLE: Fu };
});
var _i = K((Ap2, wi2) => {
  var Uu = xe(), $u2 = he(), Xr2 = ir(), Wu = Uu(Function.toString);
  $u2(Xr2.inspectSource) || (Xr2.inspectSource = function(r) {
    return Wu(r);
  });
  wi2.exports = Xr2.inspectSource;
});
var Si = K((Pp2, xi) => {
  var Vu = pe(), Gu = he(), bi = Vu.WeakMap;
  xi.exports = Gu(bi) && /native code/.test(String(bi));
});
var Ti = K((Ip, Oi2) => {
  var Hu2 = Lr(), Ju = zr(), ki = Hu2("keys");
  Oi2.exports = function(r) {
    return ki[r] || (ki[r] = Ju(r));
  };
});
var Zr = K((Rp, Ei) => {
  Ei.exports = {};
});
var Ii = K((Cp2, Pi) => {
  var Ku = Si(), Ai2 = pe(), Qu = Ne(), Yu = Kr(), et2 = Te(), rt2 = ir(), Xu = Ti(), Zu2 = Zr(), qi = "Object already initialized", tt = Ai2.TypeError, ec = Ai2.WeakMap, ar2, ze, ur2, rc = function(r) {
    return ur2(r) ? ze(r) : ar2(r, {});
  }, tc = function(r) {
    return function(n) {
      var s;
      if (!Qu(n) || (s = ze(n)).type !== r)
        throw tt("Incompatible receiver, " + r + " required");
      return s;
    };
  };
  Ku || rt2.state ? (ve2 = rt2.state || (rt2.state = new ec()), ve2.get = ve2.get, ve2.has = ve2.has, ve2.set = ve2.set, ar2 = function(r, n) {
    if (ve2.has(r))
      throw tt(qi);
    return n.facade = r, ve2.set(r, n), n;
  }, ze = function(r) {
    return ve2.get(r) || {};
  }, ur2 = function(r) {
    return ve2.has(r);
  }) : (qe2 = Xu("state"), Zu2[qe2] = true, ar2 = function(r, n) {
    if (et2(r, qe2))
      throw tt(qi);
    return n.facade = r, Yu(r, qe2, n), n;
  }, ze = function(r) {
    return et2(r, qe2) ? r[qe2] : {};
  }, ur2 = function(r) {
    return et2(r, qe2);
  });
  var ve2, qe2;
  Pi.exports = { set: ar2, get: ze, has: ur2, enforce: rc, getterFor: tc };
});
var Ni = K((Np, Ci) => {
  var nc = be(), ic = he(), cr2 = Te(), nt = Oe(), sc = yi().CONFIGURABLE, oc = _i(), Ri = Ii(), ac = Ri.enforce, uc = Ri.get, lr2 = Object.defineProperty, cc = nt && !nc(function() {
    return lr2(function() {
    }, "length", { value: 8 }).length !== 8;
  }), lc = String(String).split("String"), fc = Ci.exports = function(r, n, s) {
    String(n).slice(0, 7) === "Symbol(" && (n = "[" + String(n).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), s && s.getter && (n = "get " + n), s && s.setter && (n = "set " + n), (!cr2(r, "name") || sc && r.name !== n) && (nt ? lr2(r, "name", { value: n, configurable: true }) : r.name = n), cc && s && cr2(s, "arity") && r.length !== s.arity && lr2(r, "length", { value: s.arity });
    try {
      s && cr2(s, "constructor") && s.constructor ? nt && lr2(r, "prototype", { writable: false }) : r.prototype && (r.prototype = void 0);
    } catch {
    }
    var c = ac(r);
    return cr2(c, "source") || (c.source = lc.join(typeof n == "string" ? n : "")), r;
  };
  Function.prototype.toString = fc(function() {
    return ic(this) && uc(this).source || oc(this);
  }, "toString");
});
var Mi = K((jp, ji2) => {
  var pc = he(), hc = or(), dc = Ni(), vc = nr();
  ji2.exports = function(r, n, s, c) {
    c || (c = {});
    var o = c.enumerable, p = c.name !== void 0 ? c.name : n;
    if (pc(s) && dc(s, p, c), c.global)
      o ? r[n] = s : vc(n, s);
    else {
      try {
        c.unsafe ? r[n] && (o = true) : delete r[n];
      } catch {
      }
      o ? r[n] = s : hc.f(r, n, { value: s, enumerable: false, configurable: !c.nonConfigurable, writable: !c.nonWritable });
    }
    return r;
  };
});
var Li = K((Mp, Di2) => {
  var mc = Math.ceil, gc = Math.floor;
  Di2.exports = Math.trunc || function(n) {
    var s = +n;
    return (s > 0 ? gc : mc)(s);
  };
});
var it = K((Dp, zi2) => {
  var yc = Li();
  zi2.exports = function(r) {
    var n = +r;
    return n !== n || n === 0 ? 0 : yc(n);
  };
});
var Fi = K((Lp, Bi2) => {
  var wc = it(), _c2 = Math.max, bc = Math.min;
  Bi2.exports = function(r, n) {
    var s = wc(r);
    return s < 0 ? _c2(s + n, 0) : bc(s, n);
  };
});
var $i = K((zp, Ui2) => {
  var xc = it(), Sc = Math.min;
  Ui2.exports = function(r) {
    return r > 0 ? Sc(xc(r), 9007199254740991) : 0;
  };
});
var Vi = K((Bp, Wi2) => {
  var kc = $i();
  Wi2.exports = function(r) {
    return kc(r.length);
  };
});
var Ji = K((Fp, Hi2) => {
  var Oc = er(), Tc = Fi(), Ec = Vi(), Gi = function(r) {
    return function(n, s, c) {
      var o = Oc(n), p = Ec(o), f = Tc(c, p), h;
      if (r && s != s) {
        for (; p > f; )
          if (h = o[f++], h != h)
            return true;
      } else
        for (; p > f; f++)
          if ((r || f in o) && o[f] === s)
            return r || f || 0;
      return !r && -1;
    };
  };
  Hi2.exports = { includes: Gi(true), indexOf: Gi(false) };
});
var Yi = K((Up, Qi2) => {
  var qc = xe(), st2 = Te(), Ac = er(), Pc = Ji().indexOf, Ic = Zr(), Ki = qc([].push);
  Qi2.exports = function(r, n) {
    var s = Ac(r), c = 0, o = [], p;
    for (p in s)
      !st2(Ic, p) && st2(s, p) && Ki(o, p);
    for (; n.length > c; )
      st2(s, p = n[c++]) && (~Pc(o, p) || Ki(o, p));
    return o;
  };
});
var Zi = K(($p, Xi2) => {
  Xi2.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
});
var rs = K((es) => {
  var Rc = Yi(), Cc = Zi(), Nc = Cc.concat("length", "prototype");
  es.f = Object.getOwnPropertyNames || function(n) {
    return Rc(n, Nc);
  };
});
var ns = K((ts2) => {
  ts2.f = Object.getOwnPropertySymbols;
});
var ss = K((Gp, is2) => {
  var jc = rr(), Mc = xe(), Dc = rs(), Lc = ns(), zc = Wr(), Bc = Mc([].concat);
  is2.exports = jc("Reflect", "ownKeys") || function(n) {
    var s = Dc.f(zc(n)), c = Lc.f;
    return c ? Bc(s, c(n)) : s;
  };
});
var us = K((Hp, as2) => {
  var os2 = Te(), Fc = ss(), Uc = $r(), $c = or();
  as2.exports = function(r, n, s) {
    for (var c = Fc(n), o = $c.f, p = Uc.f, f = 0; f < c.length; f++) {
      var h = c[f];
      !os2(r, h) && !(s && os2(s, h)) && o(r, h, p(n, h));
    }
  };
});
var ls = K((Jp, cs2) => {
  var Wc = be(), Vc = he(), Gc = /#|\.prototype\./, Be = function(r, n) {
    var s = Jc[Hc(r)];
    return s == Qc ? true : s == Kc ? false : Vc(n) ? Wc(n) : !!n;
  }, Hc = Be.normalize = function(r) {
    return String(r).replace(Gc, ".").toLowerCase();
  }, Jc = Be.data = {}, Kc = Be.NATIVE = "N", Qc = Be.POLYFILL = "P";
  cs2.exports = Be;
});
var ps = K((Kp, fs2) => {
  var ot2 = pe(), Yc = $r().f, Xc = Kr(), Zc = Mi(), el2 = nr(), rl2 = us(), tl2 = ls();
  fs2.exports = function(r, n) {
    var s = r.target, c = r.global, o = r.stat, p, f, h, g2, l, t;
    if (c ? f = ot2 : o ? f = ot2[s] || el2(s, {}) : f = (ot2[s] || {}).prototype, f)
      for (h in n) {
        if (l = n[h], r.dontCallGetSet ? (t = Yc(f, h), g2 = t && t.value) : g2 = f[h], p = tl2(c ? h : s + (o ? "." : "#") + h, r.forced), !p && g2 !== void 0) {
          if (typeof l == typeof g2)
            continue;
          rl2(l, g2);
        }
        (r.sham || g2 && g2.sham) && Xc(l, "sham", true), Zc(f, h, l, r);
      }
  };
});
var hs = K(() => {
  var nl2 = ps(), at2 = pe();
  nl2({ global: true, forced: at2.globalThis !== at2 }, { globalThis: at2 });
});
hs();
var yt = Object.defineProperty, il = Object.getOwnPropertyDescriptor, wt = Object.getOwnPropertyNames, sl = Object.prototype.hasOwnProperty, Me = (r, n) => function() {
  return r && (n = (0, r[wt(r)[0]])(r = 0)), n;
}, R = (r, n) => function() {
  return n || (0, r[wt(r)[0]])((n = { exports: {} }).exports, n), n.exports;
}, _t = (r, n) => {
  for (var s in n)
    yt(r, s, { get: n[s], enumerable: true });
}, ol = (r, n, s, c) => {
  if (n && typeof n == "object" || typeof n == "function")
    for (let o of wt(n))
      !sl.call(r, o) && o !== s && yt(r, o, { get: () => n[o], enumerable: !(c = il(n, o)) || c.enumerable });
  return r;
}, bt = (r) => ol(yt({}, "__esModule", { value: true }), r), I = Me({ "<define:process>"() {
} }), al = R({ "src/common/parser-create-error.js"(r, n) {
  I();
  function s(c, o) {
    let p = new SyntaxError(c + " (" + o.start.line + ":" + o.start.column + ")");
    return p.loc = o, p;
  }
  n.exports = s;
} }), Cs = R({ "src/utils/get-last.js"(r, n) {
  I();
  var s = (c) => c[c.length - 1];
  n.exports = s;
} }), Ns = R({ "src/utils/front-matter/parse.js"(r, n) {
  I();
  var s = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
  function c(o) {
    let p = o.match(s);
    if (!p)
      return { content: o };
    let { startDelimiter: f, language: h, value: g2 = "", endDelimiter: l } = p.groups, t = h.trim() || "yaml";
    if (f === "+++" && (t = "toml"), t !== "yaml" && f !== l)
      return { content: o };
    let [e] = p;
    return { frontMatter: { type: "front-matter", lang: t, value: g2, startDelimiter: f, endDelimiter: l, raw: e.replace(/\n$/, "") }, content: e.replace(/[^\n]/g, " ") + o.slice(e.length) };
  }
  n.exports = c;
} }), js = {};
_t(js, { EOL: () => dt, arch: () => ul, cpus: () => Us, default: () => Hs, endianness: () => Ms, freemem: () => Bs, getNetworkInterfaces: () => Gs, hostname: () => Ds, loadavg: () => Ls, networkInterfaces: () => Vs, platform: () => cl, release: () => Ws, tmpDir: () => pt, tmpdir: () => ht, totalmem: () => Fs, type: () => $s, uptime: () => zs });
function Ms() {
  if (typeof fr > "u") {
    var r = new ArrayBuffer(2), n = new Uint8Array(r), s = new Uint16Array(r);
    if (n[0] = 1, n[1] = 2, s[0] === 258)
      fr = "BE";
    else if (s[0] === 513)
      fr = "LE";
    else
      throw new Error("unable to figure out endianess");
  }
  return fr;
}
function Ds() {
  return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
}
function Ls() {
  return [];
}
function zs() {
  return 0;
}
function Bs() {
  return Number.MAX_VALUE;
}
function Fs() {
  return Number.MAX_VALUE;
}
function Us() {
  return [];
}
function $s() {
  return "Browser";
}
function Ws() {
  return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
}
function Vs() {
}
function Gs() {
}
function ul() {
  return "javascript";
}
function cl() {
  return "browser";
}
function pt() {
  return "/tmp";
}
var fr, ht, dt, Hs, ll = Me({ "node-modules-polyfills:os"() {
  I(), ht = pt, dt = `
`, Hs = { EOL: dt, tmpdir: ht, tmpDir: pt, networkInterfaces: Vs, getNetworkInterfaces: Gs, release: Ws, type: $s, cpus: Us, totalmem: Fs, freemem: Bs, uptime: zs, loadavg: Ls, hostname: Ds, endianness: Ms };
} }), fl = R({ "node-modules-polyfills-commonjs:os"(r, n) {
  I();
  var s = (ll(), bt(js));
  if (s && s.default) {
    n.exports = s.default;
    for (let c in s)
      n.exports[c] = s[c];
  } else
    s && (n.exports = s);
} }), pl = R({ "node_modules/detect-newline/index.js"(r, n) {
  I();
  var s = (c) => {
    if (typeof c != "string")
      throw new TypeError("Expected a string");
    let o = c.match(/(?:\r?\n)/g) || [];
    if (o.length === 0)
      return;
    let p = o.filter((h) => h === `\r
`).length, f = o.length - p;
    return p > f ? `\r
` : `
`;
  };
  n.exports = s, n.exports.graceful = (c) => typeof c == "string" && s(c) || `
`;
} }), hl = R({ "node_modules/jest-docblock/build/index.js"(r) {
  I(), Object.defineProperty(r, "__esModule", { value: true }), r.extract = i, r.parse = m, r.parseWithComments = v2, r.print = y2, r.strip = u;
  function n() {
    let d2 = fl();
    return n = function() {
      return d2;
    }, d2;
  }
  function s() {
    let d2 = c(pl());
    return s = function() {
      return d2;
    }, d2;
  }
  function c(d2) {
    return d2 && d2.__esModule ? d2 : { default: d2 };
  }
  var o = /\*\/$/, p = /^\/\*\*?/, f = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, h = /(^|\s+)\/\/([^\r\n]*)/g, g2 = /^(\r?\n)+/, l = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, t = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, e = /(\r?\n|^) *\* ?/g, a = [];
  function i(d2) {
    let _ = d2.match(f);
    return _ ? _[0].trimLeft() : "";
  }
  function u(d2) {
    let _ = d2.match(f);
    return _ && _[0] ? d2.substring(_[0].length) : d2;
  }
  function m(d2) {
    return v2(d2).pragmas;
  }
  function v2(d2) {
    let _ = (0, s().default)(d2) || n().EOL;
    d2 = d2.replace(p, "").replace(o, "").replace(e, "$1");
    let O = "";
    for (; O !== d2; )
      O = d2, d2 = d2.replace(l, `${_}$1 $2${_}`);
    d2 = d2.replace(g2, "").trimRight();
    let k = /* @__PURE__ */ Object.create(null), D = d2.replace(t, "").replace(g2, "").trimRight(), P;
    for (; P = t.exec(d2); ) {
      let $2 = P[2].replace(h, "");
      typeof k[P[1]] == "string" || Array.isArray(k[P[1]]) ? k[P[1]] = a.concat(k[P[1]], $2) : k[P[1]] = $2;
    }
    return { comments: D, pragmas: k };
  }
  function y2(d2) {
    let { comments: _ = "", pragmas: O = {} } = d2, k = (0, s().default)(_) || n().EOL, D = "/**", P = " *", $2 = " */", G = Object.keys(O), Z = G.map((H) => w(H, O[H])).reduce((H, U2) => H.concat(U2), []).map((H) => `${P} ${H}${k}`).join("");
    if (!_) {
      if (G.length === 0)
        return "";
      if (G.length === 1 && !Array.isArray(O[G[0]])) {
        let H = O[G[0]];
        return `${D} ${w(G[0], H)[0]}${$2}`;
      }
    }
    let B = _.split(k).map((H) => `${P} ${H}`).join(k) + k;
    return D + k + (_ ? B : "") + (_ && G.length ? P + k : "") + Z + $2;
  }
  function w(d2, _) {
    return a.concat(_).map((O) => `@${d2} ${O}`.trim());
  }
} }), dl = R({ "src/common/end-of-line.js"(r, n) {
  I();
  function s(f) {
    let h = f.indexOf("\r");
    return h >= 0 ? f.charAt(h + 1) === `
` ? "crlf" : "cr" : "lf";
  }
  function c(f) {
    switch (f) {
      case "cr":
        return "\r";
      case "crlf":
        return `\r
`;
      default:
        return `
`;
    }
  }
  function o(f, h) {
    let g2;
    switch (h) {
      case `
`:
        g2 = /\n/g;
        break;
      case "\r":
        g2 = /\r/g;
        break;
      case `\r
`:
        g2 = /\r\n/g;
        break;
      default:
        throw new Error(`Unexpected "eol" ${JSON.stringify(h)}.`);
    }
    let l = f.match(g2);
    return l ? l.length : 0;
  }
  function p(f) {
    return f.replace(/\r\n?/g, `
`);
  }
  n.exports = { guessEndOfLine: s, convertEndOfLineToChars: c, countEndOfLineChars: o, normalizeEndOfLine: p };
} }), vl = R({ "src/language-js/utils/get-shebang.js"(r, n) {
  I();
  function s(c) {
    if (!c.startsWith("#!"))
      return "";
    let o = c.indexOf(`
`);
    return o === -1 ? c : c.slice(0, o);
  }
  n.exports = s;
} }), ml = R({ "src/language-js/pragma.js"(r, n) {
  I();
  var { parseWithComments: s, strip: c, extract: o, print: p } = hl(), { normalizeEndOfLine: f } = dl(), h = vl();
  function g2(e) {
    let a = h(e);
    a && (e = e.slice(a.length + 1));
    let i = o(e), { pragmas: u, comments: m } = s(i);
    return { shebang: a, text: e, pragmas: u, comments: m };
  }
  function l(e) {
    let a = Object.keys(g2(e).pragmas);
    return a.includes("prettier") || a.includes("format");
  }
  function t(e) {
    let { shebang: a, text: i, pragmas: u, comments: m } = g2(e), v2 = c(i), y2 = p({ pragmas: Object.assign({ format: "" }, u), comments: m.trimStart() });
    return (a ? `${a}
` : "") + f(y2) + (v2.startsWith(`
`) ? `
` : `

`) + v2;
  }
  n.exports = { hasPragma: l, insertPragma: t };
} }), gl = R({ "src/language-css/pragma.js"(r, n) {
  I();
  var s = ml(), c = Ns();
  function o(f) {
    return s.hasPragma(c(f).content);
  }
  function p(f) {
    let { frontMatter: h, content: g2 } = c(f);
    return (h ? h.raw + `

` : "") + s.insertPragma(g2);
  }
  n.exports = { hasPragma: o, insertPragma: p };
} }), yl = R({ "src/utils/text/skip.js"(r, n) {
  I();
  function s(h) {
    return (g2, l, t) => {
      let e = t && t.backwards;
      if (l === false)
        return false;
      let { length: a } = g2, i = l;
      for (; i >= 0 && i < a; ) {
        let u = g2.charAt(i);
        if (h instanceof RegExp) {
          if (!h.test(u))
            return i;
        } else if (!h.includes(u))
          return i;
        e ? i-- : i++;
      }
      return i === -1 || i === a ? i : false;
    };
  }
  var c = s(/\s/), o = s(" 	"), p = s(",; 	"), f = s(/[^\n\r]/);
  n.exports = { skipWhitespace: c, skipSpaces: o, skipToLineEnd: p, skipEverythingButNewLine: f };
} }), wl = R({ "src/utils/line-column-to-index.js"(r, n) {
  I(), n.exports = function(s, c) {
    let o = 0;
    for (let p = 0; p < s.line - 1; ++p)
      o = c.indexOf(`
`, o) + 1;
    return o + s.column;
  };
} }), ds = R({ "src/language-css/loc.js"(r, n) {
  I();
  var { skipEverythingButNewLine: s } = yl(), c = Cs(), o = wl();
  function p(i, u) {
    return typeof i.sourceIndex == "number" ? i.sourceIndex : i.source ? o(i.source.start, u) - 1 : null;
  }
  function f(i, u) {
    if (i.type === "css-comment" && i.inline)
      return s(u, i.source.startOffset);
    let m = i.nodes && c(i.nodes);
    return m && i.source && !i.source.end && (i = m), i.source && i.source.end ? o(i.source.end, u) : null;
  }
  function h(i, u) {
    i.source && (i.source.startOffset = p(i, u), i.source.endOffset = f(i, u));
    for (let m in i) {
      let v2 = i[m];
      m === "source" || !v2 || typeof v2 != "object" || (v2.type === "value-root" || v2.type === "value-unknown" ? g2(v2, l(i), v2.text || v2.value) : h(v2, u));
    }
  }
  function g2(i, u, m) {
    i.source && (i.source.startOffset = p(i, m) + u, i.source.endOffset = f(i, m) + u);
    for (let v2 in i) {
      let y2 = i[v2];
      v2 === "source" || !y2 || typeof y2 != "object" || g2(y2, u, m);
    }
  }
  function l(i) {
    let u = i.source.startOffset;
    return typeof i.prop == "string" && (u += i.prop.length), i.type === "css-atrule" && typeof i.name == "string" && (u += 1 + i.name.length + i.raws.afterName.match(/^\s*:?\s*/)[0].length), i.type !== "css-atrule" && i.raws && typeof i.raws.between == "string" && (u += i.raws.between.length), u;
  }
  function t(i) {
    let u = "initial", m = "initial", v2, y2 = false, w = [];
    for (let d2 = 0; d2 < i.length; d2++) {
      let _ = i[d2];
      switch (u) {
        case "initial":
          if (_ === "'") {
            u = "single-quotes";
            continue;
          }
          if (_ === '"') {
            u = "double-quotes";
            continue;
          }
          if ((_ === "u" || _ === "U") && i.slice(d2, d2 + 4).toLowerCase() === "url(") {
            u = "url", d2 += 3;
            continue;
          }
          if (_ === "*" && i[d2 - 1] === "/") {
            u = "comment-block";
            continue;
          }
          if (_ === "/" && i[d2 - 1] === "/") {
            u = "comment-inline", v2 = d2 - 1;
            continue;
          }
          continue;
        case "single-quotes":
          if (_ === "'" && i[d2 - 1] !== "\\" && (u = m, m = "initial"), _ === `
` || _ === "\r")
            return i;
          continue;
        case "double-quotes":
          if (_ === '"' && i[d2 - 1] !== "\\" && (u = m, m = "initial"), _ === `
` || _ === "\r")
            return i;
          continue;
        case "url":
          if (_ === ")" && (u = "initial"), _ === `
` || _ === "\r")
            return i;
          if (_ === "'") {
            u = "single-quotes", m = "url";
            continue;
          }
          if (_ === '"') {
            u = "double-quotes", m = "url";
            continue;
          }
          continue;
        case "comment-block":
          _ === "/" && i[d2 - 1] === "*" && (u = "initial");
          continue;
        case "comment-inline":
          (_ === '"' || _ === "'" || _ === "*") && (y2 = true), (_ === `
` || _ === "\r") && (y2 && w.push([v2, d2]), u = "initial", y2 = false);
          continue;
      }
    }
    for (let [d2, _] of w)
      i = i.slice(0, d2) + i.slice(d2, _).replace(/["'*]/g, " ") + i.slice(_);
    return i;
  }
  function e(i) {
    return i.source.startOffset;
  }
  function a(i) {
    return i.source.endOffset;
  }
  n.exports = { locStart: e, locEnd: a, calculateLoc: h, replaceQuotesInInlineComments: t };
} }), _l = R({ "src/utils/is-non-empty-array.js"(r, n) {
  I();
  function s(c) {
    return Array.isArray(c) && c.length > 0;
  }
  n.exports = s;
} }), bl = R({ "src/language-css/utils/has-scss-interpolation.js"(r, n) {
  I();
  var s = _l();
  function c(o) {
    if (s(o)) {
      for (let p = o.length - 1; p > 0; p--)
        if (o[p].type === "word" && o[p].value === "{" && o[p - 1].type === "word" && o[p - 1].value.endsWith("#"))
          return true;
    }
    return false;
  }
  n.exports = c;
} }), xl = R({ "src/language-css/utils/has-string-or-function.js"(r, n) {
  I();
  function s(c) {
    return c.some((o) => o.type === "string" || o.type === "func");
  }
  n.exports = s;
} }), Sl = R({ "src/language-css/utils/is-less-parser.js"(r, n) {
  I();
  function s(c) {
    return c.parser === "css" || c.parser === "less";
  }
  n.exports = s;
} }), kl = R({ "src/language-css/utils/is-scss.js"(r, n) {
  I();
  function s(c, o) {
    return c === "less" || c === "scss" ? c === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(o);
  }
  n.exports = s;
} }), Ol = R({ "src/language-css/utils/is-scss-nested-property-node.js"(r, n) {
  I();
  function s(c) {
    return c.selector ? c.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*\n/, "").trim().endsWith(":") : false;
  }
  n.exports = s;
} }), Tl = R({ "src/language-css/utils/is-scss-variable.js"(r, n) {
  I();
  function s(c) {
    return Boolean((c == null ? void 0 : c.type) === "word" && c.value.startsWith("$"));
  }
  n.exports = s;
} }), El = R({ "src/language-css/utils/stringify-node.js"(r, n) {
  I();
  function s(c) {
    var o, p, f;
    if (c.groups) {
      var h, g2, l;
      let y2 = ((h = c.open) === null || h === void 0 ? void 0 : h.value) || "", w = c.groups.map((_) => s(_)).join(((g2 = c.groups[0]) === null || g2 === void 0 ? void 0 : g2.type) === "comma_group" ? "," : ""), d2 = ((l = c.close) === null || l === void 0 ? void 0 : l.value) || "";
      return y2 + w + d2;
    }
    let t = ((o = c.raws) === null || o === void 0 ? void 0 : o.before) || "", e = ((p = c.raws) === null || p === void 0 ? void 0 : p.quote) || "", a = c.type === "atword" ? "@" : "", i = c.value || "", u = c.unit || "", m = c.group ? s(c.group) : "", v2 = ((f = c.raws) === null || f === void 0 ? void 0 : f.after) || "";
    return t + e + a + i + e + u + m + v2;
  }
  n.exports = s;
} }), ql = R({ "src/language-css/utils/is-module-rule-name.js"(r, n) {
  I();
  var s = /* @__PURE__ */ new Set(["import", "use", "forward"]);
  function c(o) {
    return s.has(o);
  }
  n.exports = c;
} }), we = R({ "node_modules/postcss-values-parser/lib/node.js"(r, n) {
  I();
  var s = function(c, o) {
    let p = new c.constructor();
    for (let f in c) {
      if (!c.hasOwnProperty(f))
        continue;
      let h = c[f], g2 = typeof h;
      f === "parent" && g2 === "object" ? o && (p[f] = o) : f === "source" ? p[f] = h : h instanceof Array ? p[f] = h.map((l) => s(l, p)) : f !== "before" && f !== "after" && f !== "between" && f !== "semicolon" && (g2 === "object" && h !== null && (h = s(h)), p[f] = h);
    }
    return p;
  };
  n.exports = class {
    constructor(o) {
      o = o || {}, this.raws = { before: "", after: "" };
      for (let p in o)
        this[p] = o[p];
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }
    toString() {
      return [this.raws.before, String(this.value), this.raws.after].join("");
    }
    clone(o) {
      o = o || {};
      let p = s(this);
      for (let f in o)
        p[f] = o[f];
      return p;
    }
    cloneBefore(o) {
      o = o || {};
      let p = this.clone(o);
      return this.parent.insertBefore(this, p), p;
    }
    cloneAfter(o) {
      o = o || {};
      let p = this.clone(o);
      return this.parent.insertAfter(this, p), p;
    }
    replaceWith() {
      let o = Array.prototype.slice.call(arguments);
      if (this.parent) {
        for (let p of o)
          this.parent.insertBefore(this, p);
        this.remove();
      }
      return this;
    }
    moveTo(o) {
      return this.cleanRaws(this.root() === o.root()), this.remove(), o.append(this), this;
    }
    moveBefore(o) {
      return this.cleanRaws(this.root() === o.root()), this.remove(), o.parent.insertBefore(o, this), this;
    }
    moveAfter(o) {
      return this.cleanRaws(this.root() === o.root()), this.remove(), o.parent.insertAfter(o, this), this;
    }
    next() {
      let o = this.parent.index(this);
      return this.parent.nodes[o + 1];
    }
    prev() {
      let o = this.parent.index(this);
      return this.parent.nodes[o - 1];
    }
    toJSON() {
      let o = {};
      for (let p in this) {
        if (!this.hasOwnProperty(p) || p === "parent")
          continue;
        let f = this[p];
        f instanceof Array ? o[p] = f.map((h) => typeof h == "object" && h.toJSON ? h.toJSON() : h) : typeof f == "object" && f.toJSON ? o[p] = f.toJSON() : o[p] = f;
      }
      return o;
    }
    root() {
      let o = this;
      for (; o.parent; )
        o = o.parent;
      return o;
    }
    cleanRaws(o) {
      delete this.raws.before, delete this.raws.after, o || delete this.raws.between;
    }
    positionInside(o) {
      let p = this.toString(), f = this.source.start.column, h = this.source.start.line;
      for (let g2 = 0; g2 < o; g2++)
        p[g2] === `
` ? (f = 1, h += 1) : f += 1;
      return { line: h, column: f };
    }
    positionBy(o) {
      let p = this.source.start;
      if (Object(o).index)
        p = this.positionInside(o.index);
      else if (Object(o).word) {
        let f = this.toString().indexOf(o.word);
        f !== -1 && (p = this.positionInside(f));
      }
      return p;
    }
  };
} }), ae = R({ "node_modules/postcss-values-parser/lib/container.js"(r, n) {
  I();
  var s = we(), c = class extends s {
    constructor(o) {
      super(o), this.nodes || (this.nodes = []);
    }
    push(o) {
      return o.parent = this, this.nodes.push(o), this;
    }
    each(o) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let p = this.lastEach, f, h;
      if (this.indexes[p] = 0, !!this.nodes) {
        for (; this.indexes[p] < this.nodes.length && (f = this.indexes[p], h = o(this.nodes[f], f), h !== false); )
          this.indexes[p] += 1;
        return delete this.indexes[p], h;
      }
    }
    walk(o) {
      return this.each((p, f) => {
        let h = o(p, f);
        return h !== false && p.walk && (h = p.walk(o)), h;
      });
    }
    walkType(o, p) {
      if (!o || !p)
        throw new Error("Parameters {type} and {callback} are required.");
      let f = typeof o == "function";
      return this.walk((h, g2) => {
        if (f && h instanceof o || !f && h.type === o)
          return p.call(this, h, g2);
      });
    }
    append(o) {
      return o.parent = this, this.nodes.push(o), this;
    }
    prepend(o) {
      return o.parent = this, this.nodes.unshift(o), this;
    }
    cleanRaws(o) {
      if (super.cleanRaws(o), this.nodes)
        for (let p of this.nodes)
          p.cleanRaws(o);
    }
    insertAfter(o, p) {
      let f = this.index(o), h;
      this.nodes.splice(f + 1, 0, p);
      for (let g2 in this.indexes)
        h = this.indexes[g2], f <= h && (this.indexes[g2] = h + this.nodes.length);
      return this;
    }
    insertBefore(o, p) {
      let f = this.index(o), h;
      this.nodes.splice(f, 0, p);
      for (let g2 in this.indexes)
        h = this.indexes[g2], f <= h && (this.indexes[g2] = h + this.nodes.length);
      return this;
    }
    removeChild(o) {
      o = this.index(o), this.nodes[o].parent = void 0, this.nodes.splice(o, 1);
      let p;
      for (let f in this.indexes)
        p = this.indexes[f], p >= o && (this.indexes[f] = p - 1);
      return this;
    }
    removeAll() {
      for (let o of this.nodes)
        o.parent = void 0;
      return this.nodes = [], this;
    }
    every(o) {
      return this.nodes.every(o);
    }
    some(o) {
      return this.nodes.some(o);
    }
    index(o) {
      return typeof o == "number" ? o : this.nodes.indexOf(o);
    }
    get first() {
      if (this.nodes)
        return this.nodes[0];
    }
    get last() {
      if (this.nodes)
        return this.nodes[this.nodes.length - 1];
    }
    toString() {
      let o = this.nodes.map(String).join("");
      return this.value && (o = this.value + o), this.raws.before && (o = this.raws.before + o), this.raws.after && (o += this.raws.after), o;
    }
  };
  c.registerWalker = (o) => {
    let p = "walk" + o.name;
    p.lastIndexOf("s") !== p.length - 1 && (p += "s"), !c.prototype[p] && (c.prototype[p] = function(f) {
      return this.walkType(o, f);
    });
  }, n.exports = c;
} }), Al = R({ "node_modules/postcss-values-parser/lib/root.js"(r, n) {
  I();
  var s = ae();
  n.exports = class extends s {
    constructor(o) {
      super(o), this.type = "root";
    }
  };
} }), Js = R({ "node_modules/postcss-values-parser/lib/value.js"(r, n) {
  I();
  var s = ae();
  n.exports = class extends s {
    constructor(o) {
      super(o), this.type = "value", this.unbalanced = 0;
    }
  };
} }), Ks = R({ "node_modules/postcss-values-parser/lib/atword.js"(r, n) {
  I();
  var s = ae(), c = class extends s {
    constructor(o) {
      super(o), this.type = "atword";
    }
    toString() {
      this.quoted ? this.raws.quote : "";
      return [this.raws.before, "@", String.prototype.toString.call(this.value), this.raws.after].join("");
    }
  };
  s.registerWalker(c), n.exports = c;
} }), Qs = R({ "node_modules/postcss-values-parser/lib/colon.js"(r, n) {
  I();
  var s = ae(), c = we(), o = class extends c {
    constructor(p) {
      super(p), this.type = "colon";
    }
  };
  s.registerWalker(o), n.exports = o;
} }), Ys = R({ "node_modules/postcss-values-parser/lib/comma.js"(r, n) {
  I();
  var s = ae(), c = we(), o = class extends c {
    constructor(p) {
      super(p), this.type = "comma";
    }
  };
  s.registerWalker(o), n.exports = o;
} }), Xs = R({ "node_modules/postcss-values-parser/lib/comment.js"(r, n) {
  I();
  var s = ae(), c = we(), o = class extends c {
    constructor(p) {
      super(p), this.type = "comment", this.inline = Object(p).inline || false;
    }
    toString() {
      return [this.raws.before, this.inline ? "//" : "/*", String(this.value), this.inline ? "" : "*/", this.raws.after].join("");
    }
  };
  s.registerWalker(o), n.exports = o;
} }), Zs = R({ "node_modules/postcss-values-parser/lib/function.js"(r, n) {
  I();
  var s = ae(), c = class extends s {
    constructor(o) {
      super(o), this.type = "func", this.unbalanced = -1;
    }
  };
  s.registerWalker(c), n.exports = c;
} }), eo = R({ "node_modules/postcss-values-parser/lib/number.js"(r, n) {
  I();
  var s = ae(), c = we(), o = class extends c {
    constructor(p) {
      super(p), this.type = "number", this.unit = Object(p).unit || "";
    }
    toString() {
      return [this.raws.before, String(this.value), this.unit, this.raws.after].join("");
    }
  };
  s.registerWalker(o), n.exports = o;
} }), ro = R({ "node_modules/postcss-values-parser/lib/operator.js"(r, n) {
  I();
  var s = ae(), c = we(), o = class extends c {
    constructor(p) {
      super(p), this.type = "operator";
    }
  };
  s.registerWalker(o), n.exports = o;
} }), to = R({ "node_modules/postcss-values-parser/lib/paren.js"(r, n) {
  I();
  var s = ae(), c = we(), o = class extends c {
    constructor(p) {
      super(p), this.type = "paren", this.parenType = "";
    }
  };
  s.registerWalker(o), n.exports = o;
} }), no = R({ "node_modules/postcss-values-parser/lib/string.js"(r, n) {
  I();
  var s = ae(), c = we(), o = class extends c {
    constructor(p) {
      super(p), this.type = "string";
    }
    toString() {
      let p = this.quoted ? this.raws.quote : "";
      return [this.raws.before, p, this.value + "", p, this.raws.after].join("");
    }
  };
  s.registerWalker(o), n.exports = o;
} }), io = R({ "node_modules/postcss-values-parser/lib/word.js"(r, n) {
  I();
  var s = ae(), c = we(), o = class extends c {
    constructor(p) {
      super(p), this.type = "word";
    }
  };
  s.registerWalker(o), n.exports = o;
} }), so = R({ "node_modules/postcss-values-parser/lib/unicode-range.js"(r, n) {
  I();
  var s = ae(), c = we(), o = class extends c {
    constructor(p) {
      super(p), this.type = "unicode-range";
    }
  };
  s.registerWalker(o), n.exports = o;
} });
function oo() {
  throw new Error("setTimeout has not been defined");
}
function ao() {
  throw new Error("clearTimeout has not been defined");
}
function uo(r) {
  if (Se === setTimeout)
    return setTimeout(r, 0);
  if ((Se === oo || !Se) && setTimeout)
    return Se = setTimeout, setTimeout(r, 0);
  try {
    return Se(r, 0);
  } catch {
    try {
      return Se.call(null, r, 0);
    } catch {
      return Se.call(this, r, 0);
    }
  }
}
function Pl(r) {
  if (ke === clearTimeout)
    return clearTimeout(r);
  if ((ke === ao || !ke) && clearTimeout)
    return ke = clearTimeout, clearTimeout(r);
  try {
    return ke(r);
  } catch {
    try {
      return ke.call(null, r);
    } catch {
      return ke.call(this, r);
    }
  }
}
function Il() {
  !Re || !Ie || (Re = false, Ie.length ? me = Ie.concat(me) : Ue = -1, me.length && co());
}
function co() {
  if (!Re) {
    var r = uo(Il);
    Re = true;
    for (var n = me.length; n; ) {
      for (Ie = me, me = []; ++Ue < n; )
        Ie && Ie[Ue].run();
      Ue = -1, n = me.length;
    }
    Ie = null, Re = false, Pl(r);
  }
}
function Rl(r) {
  var n = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var s = 1; s < arguments.length; s++)
      n[s - 1] = arguments[s];
  me.push(new lo(r, n)), me.length === 1 && !Re && uo(co);
}
function lo(r, n) {
  this.fun = r, this.array = n;
}
function Ae() {
}
function Cl(r) {
  throw new Error("process.binding is not supported");
}
function Nl() {
  return "/";
}
function jl(r) {
  throw new Error("process.chdir is not supported");
}
function Ml() {
  return 0;
}
function Dl(r) {
  var n = fo.call(Pe) * 1e-3, s = Math.floor(n), c = Math.floor(n % 1 * 1e9);
  return r && (s = s - r[0], c = c - r[1], c < 0 && (s--, c += 1e9)), [s, c];
}
function Ll() {
  var r = /* @__PURE__ */ new Date(), n = r - po;
  return n / 1e3;
}
var Se, ke, me, Re, Ie, Ue, vs, ms, gs, ys, ws, _s, bs, xs, Ss, ks, Os, Ts, Es, qs$1, As, Ps, Pe, fo, po, Is, $e, zl = Me({ "node-modules-polyfills:process"() {
  I(), Se = oo, ke = ao, typeof globalThis.setTimeout == "function" && (Se = setTimeout), typeof globalThis.clearTimeout == "function" && (ke = clearTimeout), me = [], Re = false, Ue = -1, lo.prototype.run = function() {
    this.fun.apply(null, this.array);
  }, vs = "browser", ms = "browser", gs = true, ys = {}, ws = [], _s = "", bs = {}, xs = {}, Ss = {}, ks = Ae, Os = Ae, Ts = Ae, Es = Ae, qs$1 = Ae, As = Ae, Ps = Ae, Pe = globalThis.performance || {}, fo = Pe.now || Pe.mozNow || Pe.msNow || Pe.oNow || Pe.webkitNow || function() {
    return (/* @__PURE__ */ new Date()).getTime();
  }, po = /* @__PURE__ */ new Date(), Is = { nextTick: Rl, title: vs, browser: gs, env: ys, argv: ws, version: _s, versions: bs, on: ks, addListener: Os, once: Ts, off: Es, removeListener: qs$1, removeAllListeners: As, emit: Ps, binding: Cl, cwd: Nl, chdir: jl, umask: Ml, hrtime: Dl, platform: ms, release: xs, config: Ss, uptime: Ll }, $e = Is;
} }), ut, xt, Bl = Me({ "node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js"() {
  I(), typeof Object.create == "function" ? ut = function(n, s) {
    n.super_ = s, n.prototype = Object.create(s.prototype, { constructor: { value: n, enumerable: false, writable: true, configurable: true } });
  } : ut = function(n, s) {
    n.super_ = s;
    var c = function() {
    };
    c.prototype = s.prototype, n.prototype = new c(), n.prototype.constructor = n;
  }, xt = ut;
} }), ho = {};
_t(ho, { _extend: () => Et, debuglog: () => vo, default: () => ko, deprecate: () => St, format: () => vr, inherits: () => xt, inspect: () => ye, isArray: () => kt, isBoolean: () => mr, isBuffer: () => wo, isDate: () => hr, isError: () => Ve, isFunction: () => Ge, isNull: () => He, isNullOrUndefined: () => mo, isNumber: () => Ot, isObject: () => Ce, isPrimitive: () => yo, isRegExp: () => We, isString: () => Je, isSymbol: () => go, isUndefined: () => ge, log: () => _o });
function vr(r) {
  if (!Je(r)) {
    for (var n = [], s = 0; s < arguments.length; s++)
      n.push(ye(arguments[s]));
    return n.join(" ");
  }
  for (var s = 1, c = arguments, o = c.length, p = String(r).replace(xo, function(h) {
    if (h === "%%")
      return "%";
    if (s >= o)
      return h;
    switch (h) {
      case "%s":
        return String(c[s++]);
      case "%d":
        return Number(c[s++]);
      case "%j":
        try {
          return JSON.stringify(c[s++]);
        } catch {
          return "[Circular]";
        }
      default:
        return h;
    }
  }), f = c[s]; s < o; f = c[++s])
    He(f) || !Ce(f) ? p += " " + f : p += " " + ye(f);
  return p;
}
function St(r, n) {
  if (ge(globalThis.process))
    return function() {
      return St(r, n).apply(this, arguments);
    };
  if ($e.noDeprecation === true)
    return r;
  var s = false;
  function c() {
    if (!s) {
      if ($e.throwDeprecation)
        throw new Error(n);
      $e.traceDeprecation ? console.trace(n) : console.error(n), s = true;
    }
    return r.apply(this, arguments);
  }
  return c;
}
function vo(r) {
  if (ge(ft) && (ft = $e.env.NODE_DEBUG || ""), r = r.toUpperCase(), !Fe[r])
    if (new RegExp("\\b" + r + "\\b", "i").test(ft)) {
      var n = 0;
      Fe[r] = function() {
        var s = vr.apply(null, arguments);
        console.error("%s %d: %s", r, n, s);
      };
    } else
      Fe[r] = function() {
      };
  return Fe[r];
}
function ye(r, n) {
  var s = { seen: [], stylize: Ul };
  return arguments.length >= 3 && (s.depth = arguments[2]), arguments.length >= 4 && (s.colors = arguments[3]), mr(n) ? s.showHidden = n : n && Et(s, n), ge(s.showHidden) && (s.showHidden = false), ge(s.depth) && (s.depth = 2), ge(s.colors) && (s.colors = false), ge(s.customInspect) && (s.customInspect = true), s.colors && (s.stylize = Fl), pr(s, r, s.depth);
}
function Fl(r, n) {
  var s = ye.styles[n];
  return s ? "\x1B[" + ye.colors[s][0] + "m" + r + "\x1B[" + ye.colors[s][1] + "m" : r;
}
function Ul(r, n) {
  return r;
}
function $l(r) {
  var n = {};
  return r.forEach(function(s, c) {
    n[s] = true;
  }), n;
}
function pr(r, n, s) {
  if (r.customInspect && n && Ge(n.inspect) && n.inspect !== ye && !(n.constructor && n.constructor.prototype === n)) {
    var c = n.inspect(s, r);
    return Je(c) || (c = pr(r, c, s)), c;
  }
  var o = Wl(r, n);
  if (o)
    return o;
  var p = Object.keys(n), f = $l(p);
  if (r.showHidden && (p = Object.getOwnPropertyNames(n)), Ve(n) && (p.indexOf("message") >= 0 || p.indexOf("description") >= 0))
    return ct(n);
  if (p.length === 0) {
    if (Ge(n)) {
      var h = n.name ? ": " + n.name : "";
      return r.stylize("[Function" + h + "]", "special");
    }
    if (We(n))
      return r.stylize(RegExp.prototype.toString.call(n), "regexp");
    if (hr(n))
      return r.stylize(Date.prototype.toString.call(n), "date");
    if (Ve(n))
      return ct(n);
  }
  var g2 = "", l = false, t = ["{", "}"];
  if (kt(n) && (l = true, t = ["[", "]"]), Ge(n)) {
    var e = n.name ? ": " + n.name : "";
    g2 = " [Function" + e + "]";
  }
  if (We(n) && (g2 = " " + RegExp.prototype.toString.call(n)), hr(n) && (g2 = " " + Date.prototype.toUTCString.call(n)), Ve(n) && (g2 = " " + ct(n)), p.length === 0 && (!l || n.length == 0))
    return t[0] + g2 + t[1];
  if (s < 0)
    return We(n) ? r.stylize(RegExp.prototype.toString.call(n), "regexp") : r.stylize("[Object]", "special");
  r.seen.push(n);
  var a;
  return l ? a = Vl(r, n, s, f, p) : a = p.map(function(i) {
    return vt(r, n, s, f, i, l);
  }), r.seen.pop(), Gl(a, g2, t);
}
function Wl(r, n) {
  if (ge(n))
    return r.stylize("undefined", "undefined");
  if (Je(n)) {
    var s = "'" + JSON.stringify(n).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return r.stylize(s, "string");
  }
  if (Ot(n))
    return r.stylize("" + n, "number");
  if (mr(n))
    return r.stylize("" + n, "boolean");
  if (He(n))
    return r.stylize("null", "null");
}
function ct(r) {
  return "[" + Error.prototype.toString.call(r) + "]";
}
function Vl(r, n, s, c, o) {
  for (var p = [], f = 0, h = n.length; f < h; ++f)
    bo(n, String(f)) ? p.push(vt(r, n, s, c, String(f), true)) : p.push("");
  return o.forEach(function(g2) {
    g2.match(/^\d+$/) || p.push(vt(r, n, s, c, g2, true));
  }), p;
}
function vt(r, n, s, c, o, p) {
  var f, h, g2;
  if (g2 = Object.getOwnPropertyDescriptor(n, o) || { value: n[o] }, g2.get ? g2.set ? h = r.stylize("[Getter/Setter]", "special") : h = r.stylize("[Getter]", "special") : g2.set && (h = r.stylize("[Setter]", "special")), bo(c, o) || (f = "[" + o + "]"), h || (r.seen.indexOf(g2.value) < 0 ? (He(s) ? h = pr(r, g2.value, null) : h = pr(r, g2.value, s - 1), h.indexOf(`
`) > -1 && (p ? h = h.split(`
`).map(function(l) {
    return "  " + l;
  }).join(`
`).substr(2) : h = `
` + h.split(`
`).map(function(l) {
    return "   " + l;
  }).join(`
`))) : h = r.stylize("[Circular]", "special")), ge(f)) {
    if (p && o.match(/^\d+$/))
      return h;
    f = JSON.stringify("" + o), f.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (f = f.substr(1, f.length - 2), f = r.stylize(f, "name")) : (f = f.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), f = r.stylize(f, "string"));
  }
  return f + ": " + h;
}
function Gl(r, n, s) {
  var c = 0, o = r.reduce(function(p, f) {
    return c++, f.indexOf(`
`) >= 0 && c++, p + f.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  return o > 60 ? s[0] + (n === "" ? "" : n + `
 `) + " " + r.join(`,
  `) + " " + s[1] : s[0] + n + " " + r.join(", ") + " " + s[1];
}
function kt(r) {
  return Array.isArray(r);
}
function mr(r) {
  return typeof r == "boolean";
}
function He(r) {
  return r === null;
}
function mo(r) {
  return r == null;
}
function Ot(r) {
  return typeof r == "number";
}
function Je(r) {
  return typeof r == "string";
}
function go(r) {
  return typeof r == "symbol";
}
function ge(r) {
  return r === void 0;
}
function We(r) {
  return Ce(r) && Tt(r) === "[object RegExp]";
}
function Ce(r) {
  return typeof r == "object" && r !== null;
}
function hr(r) {
  return Ce(r) && Tt(r) === "[object Date]";
}
function Ve(r) {
  return Ce(r) && (Tt(r) === "[object Error]" || r instanceof Error);
}
function Ge(r) {
  return typeof r == "function";
}
function yo(r) {
  return r === null || typeof r == "boolean" || typeof r == "number" || typeof r == "string" || typeof r == "symbol" || typeof r > "u";
}
function wo(r) {
  return Buffer.isBuffer(r);
}
function Tt(r) {
  return Object.prototype.toString.call(r);
}
function lt(r) {
  return r < 10 ? "0" + r.toString(10) : r.toString(10);
}
function Hl() {
  var r = /* @__PURE__ */ new Date(), n = [lt(r.getHours()), lt(r.getMinutes()), lt(r.getSeconds())].join(":");
  return [r.getDate(), So[r.getMonth()], n].join(" ");
}
function _o() {
  console.log("%s - %s", Hl(), vr.apply(null, arguments));
}
function Et(r, n) {
  if (!n || !Ce(n))
    return r;
  for (var s = Object.keys(n), c = s.length; c--; )
    r[s[c]] = n[s[c]];
  return r;
}
function bo(r, n) {
  return Object.prototype.hasOwnProperty.call(r, n);
}
var xo, Fe, ft, So, ko, Jl = Me({ "node-modules-polyfills:util"() {
  I(), zl(), Bl(), xo = /%[sdj%]/g, Fe = {}, ye.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, ye.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, So = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ko = { inherits: xt, _extend: Et, log: _o, isBuffer: wo, isPrimitive: yo, isFunction: Ge, isError: Ve, isDate: hr, isObject: Ce, isRegExp: We, isUndefined: ge, isSymbol: go, isString: Je, isNumber: Ot, isNullOrUndefined: mo, isNull: He, isBoolean: mr, isArray: kt, inspect: ye, deprecate: St, format: vr, debuglog: vo };
} }), Kl = R({ "node-modules-polyfills-commonjs:util"(r, n) {
  I();
  var s = (Jl(), bt(ho));
  if (s && s.default) {
    n.exports = s.default;
    for (let c in s)
      n.exports[c] = s[c];
  } else
    s && (n.exports = s);
} }), Ql = R({ "node_modules/postcss-values-parser/lib/errors/TokenizeError.js"(r, n) {
  I();
  var s = class extends Error {
    constructor(c) {
      super(c), this.name = this.constructor.name, this.message = c || "An error ocurred while tokzenizing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(c).stack;
    }
  };
  n.exports = s;
} }), Yl = R({ "node_modules/postcss-values-parser/lib/tokenize.js"(r, n) {
  I();
  var s = "{".charCodeAt(0), c = "}".charCodeAt(0), o = "(".charCodeAt(0), p = ")".charCodeAt(0), f = "'".charCodeAt(0), h = '"'.charCodeAt(0), g2 = "\\".charCodeAt(0), l = "/".charCodeAt(0), t = ".".charCodeAt(0), e = ",".charCodeAt(0), a = ":".charCodeAt(0), i = "*".charCodeAt(0), u = "-".charCodeAt(0), m = "+".charCodeAt(0), v2 = "#".charCodeAt(0), y2 = `
`.charCodeAt(0), w = " ".charCodeAt(0), d2 = "\f".charCodeAt(0), _ = "	".charCodeAt(0), O = "\r".charCodeAt(0), k = "@".charCodeAt(0), D = "e".charCodeAt(0), P = "E".charCodeAt(0), $2 = "0".charCodeAt(0), G = "9".charCodeAt(0), Z = "u".charCodeAt(0), B = "U".charCodeAt(0), H = /[ \n\t\r\{\(\)'"\\;,/]/g, U2 = /[ \n\t\r\(\)\{\}\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g, T = /[ \n\t\r\(\)\{\}\*:;@!&'"\-\+\|~>,\[\]\\]|\//g, L = /^[a-z0-9]/i, j = /^[a-f0-9?\-]/i, N2 = Kl(), b = Ql();
  n.exports = function(J, W) {
    W = W || {};
    let X = [], C = J.valueOf(), Q = C.length, M2 = -1, E = 1, x = 0, S = 0, z = null, A, q, V, F, ee2, te2, le2, re, ne2, oe, ie2;
    function ce2(Qe) {
      let _e2 = N2.format("Unclosed %s at line: %d, column: %d, token: %d", Qe, E, x - M2, x);
      throw new b(_e2);
    }
    for (; x < Q; ) {
      switch (A = C.charCodeAt(x), A === y2 && (M2 = x, E += 1), A) {
        case y2:
        case w:
        case _:
        case O:
        case d2:
          q = x;
          do
            q += 1, A = C.charCodeAt(q), A === y2 && (M2 = q, E += 1);
          while (A === w || A === y2 || A === _ || A === O || A === d2);
          X.push(["space", C.slice(x, q), E, x - M2, E, q - M2, x]), x = q - 1;
          break;
        case a:
          q = x + 1, X.push(["colon", C.slice(x, q), E, x - M2, E, q - M2, x]), x = q - 1;
          break;
        case e:
          q = x + 1, X.push(["comma", C.slice(x, q), E, x - M2, E, q - M2, x]), x = q - 1;
          break;
        case s:
          X.push(["{", "{", E, x - M2, E, q - M2, x]);
          break;
        case c:
          X.push(["}", "}", E, x - M2, E, q - M2, x]);
          break;
        case o:
          S++, z = !z && S === 1 && X.length > 0 && X[X.length - 1][0] === "word" && X[X.length - 1][1] === "url", X.push(["(", "(", E, x - M2, E, q - M2, x]);
          break;
        case p:
          S--, z = z && S > 0, X.push([")", ")", E, x - M2, E, q - M2, x]);
          break;
        case f:
        case h:
          V = A === f ? "'" : '"', q = x;
          do
            for (ne2 = false, q = C.indexOf(V, q + 1), q === -1 && ce2("quote"), oe = q; C.charCodeAt(oe - 1) === g2; )
              oe -= 1, ne2 = !ne2;
          while (ne2);
          X.push(["string", C.slice(x, q + 1), E, x - M2, E, q - M2, x]), x = q;
          break;
        case k:
          H.lastIndex = x + 1, H.test(C), H.lastIndex === 0 ? q = C.length - 1 : q = H.lastIndex - 2, X.push(["atword", C.slice(x, q + 1), E, x - M2, E, q - M2, x]), x = q;
          break;
        case g2:
          q = x, A = C.charCodeAt(q + 1), X.push(["word", C.slice(x, q + 1), E, x - M2, E, q - M2, x]), x = q;
          break;
        case m:
        case u:
        case i:
          q = x + 1, ie2 = C.slice(x + 1, q + 1);
          C.slice(x - 1, x);
          if (A === u && ie2.charCodeAt(0) === u) {
            q++, X.push(["word", C.slice(x, q), E, x - M2, E, q - M2, x]), x = q - 1;
            break;
          }
          X.push(["operator", C.slice(x, q), E, x - M2, E, q - M2, x]), x = q - 1;
          break;
        default:
          if (A === l && (C.charCodeAt(x + 1) === i || W.loose && !z && C.charCodeAt(x + 1) === l)) {
            if (C.charCodeAt(x + 1) === i)
              q = C.indexOf("*/", x + 2) + 1, q === 0 && ce2("comment");
            else {
              let Le = C.indexOf(`
`, x + 2);
              q = Le !== -1 ? Le - 1 : Q;
            }
            te2 = C.slice(x, q + 1), F = te2.split(`
`), ee2 = F.length - 1, ee2 > 0 ? (le2 = E + ee2, re = q - F[ee2].length) : (le2 = E, re = M2), X.push(["comment", te2, E, x - M2, le2, q - re, x]), M2 = re, E = le2, x = q;
          } else if (A === v2 && !L.test(C.slice(x + 1, x + 2)))
            q = x + 1, X.push(["#", C.slice(x, q), E, x - M2, E, q - M2, x]), x = q - 1;
          else if ((A === Z || A === B) && C.charCodeAt(x + 1) === m) {
            q = x + 2;
            do
              q += 1, A = C.charCodeAt(q);
            while (q < Q && j.test(C.slice(q, q + 1)));
            X.push(["unicoderange", C.slice(x, q), E, x - M2, E, q - M2, x]), x = q - 1;
          } else if (A === l)
            q = x + 1, X.push(["operator", C.slice(x, q), E, x - M2, E, q - M2, x]), x = q - 1;
          else {
            let _e2 = U2;
            if (A >= $2 && A <= G && (_e2 = T), _e2.lastIndex = x + 1, _e2.test(C), _e2.lastIndex === 0 ? q = C.length - 1 : q = _e2.lastIndex - 2, _e2 === T || A === t) {
              let Le = C.charCodeAt(q), jt2 = C.charCodeAt(q + 1), Mt2 = C.charCodeAt(q + 2);
              (Le === D || Le === P) && (jt2 === u || jt2 === m) && Mt2 >= $2 && Mt2 <= G && (T.lastIndex = q + 2, T.test(C), T.lastIndex === 0 ? q = C.length - 1 : q = T.lastIndex - 2);
            }
            X.push(["word", C.slice(x, q + 1), E, x - M2, E, q - M2, x]), x = q;
          }
          break;
      }
      x++;
    }
    return X;
  };
} }), Oo = R({ "node_modules/flatten/index.js"(r, n) {
  I(), n.exports = function(c, o) {
    if (o = typeof o == "number" ? o : 1 / 0, !o)
      return Array.isArray(c) ? c.map(function(f) {
        return f;
      }) : c;
    return p(c, 1);
    function p(f, h) {
      return f.reduce(function(g2, l) {
        return Array.isArray(l) && h < o ? g2.concat(p(l, h + 1)) : g2.concat(l);
      }, []);
    }
  };
} }), To = R({ "node_modules/indexes-of/index.js"(r, n) {
  I(), n.exports = function(s, c) {
    for (var o = -1, p = []; (o = s.indexOf(c, o + 1)) !== -1; )
      p.push(o);
    return p;
  };
} }), Eo = R({ "node_modules/uniq/uniq.js"(r, n) {
  I();
  function s(p, f) {
    for (var h = 1, g2 = p.length, l = p[0], t = p[0], e = 1; e < g2; ++e)
      if (t = l, l = p[e], f(l, t)) {
        if (e === h) {
          h++;
          continue;
        }
        p[h++] = l;
      }
    return p.length = h, p;
  }
  function c(p) {
    for (var f = 1, h = p.length, g2 = p[0], l = p[0], t = 1; t < h; ++t, l = g2)
      if (l = g2, g2 = p[t], g2 !== l) {
        if (t === f) {
          f++;
          continue;
        }
        p[f++] = g2;
      }
    return p.length = f, p;
  }
  function o(p, f, h) {
    return p.length === 0 ? p : f ? (h || p.sort(f), s(p, f)) : (h || p.sort(), c(p));
  }
  n.exports = o;
} }), Xl = R({ "node_modules/postcss-values-parser/lib/errors/ParserError.js"(r, n) {
  I();
  var s = class extends Error {
    constructor(c) {
      super(c), this.name = this.constructor.name, this.message = c || "An error ocurred while parsing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(c).stack;
    }
  };
  n.exports = s;
} }), Zl = R({ "node_modules/postcss-values-parser/lib/parser.js"(r, n) {
  I();
  var s = Al(), c = Js(), o = Ks(), p = Qs(), f = Ys(), h = Xs(), g2 = Zs(), l = eo(), t = ro(), e = to(), a = no(), i = io(), u = so(), m = Yl(), v2 = Oo(), y2 = To(), w = Eo(), d2 = Xl();
  function _(O) {
    return O.sort((k, D) => k - D);
  }
  n.exports = class {
    constructor(k, D) {
      let P = { loose: false };
      this.cache = [], this.input = k, this.options = Object.assign({}, P, D), this.position = 0, this.unbalanced = 0, this.root = new s();
      let $2 = new c();
      this.root.append($2), this.current = $2, this.tokens = m(k, this.options);
    }
    parse() {
      return this.loop();
    }
    colon() {
      let k = this.currToken;
      this.newNode(new p({ value: k[1], source: { start: { line: k[2], column: k[3] }, end: { line: k[4], column: k[5] } }, sourceIndex: k[6] })), this.position++;
    }
    comma() {
      let k = this.currToken;
      this.newNode(new f({ value: k[1], source: { start: { line: k[2], column: k[3] }, end: { line: k[4], column: k[5] } }, sourceIndex: k[6] })), this.position++;
    }
    comment() {
      let k = false, D = this.currToken[1].replace(/\/\*|\*\//g, ""), P;
      this.options.loose && D.startsWith("//") && (D = D.substring(2), k = true), P = new h({ value: D, inline: k, source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] }), this.newNode(P), this.position++;
    }
    error(k, D) {
      throw new d2(k + ` at line: ${D[2]}, column ${D[3]}`);
    }
    loop() {
      for (; this.position < this.tokens.length; )
        this.parseTokens();
      return !this.current.last && this.spaces ? this.current.raws.before += this.spaces : this.spaces && (this.current.last.raws.after += this.spaces), this.spaces = "", this.root;
    }
    operator() {
      let k = this.currToken[1], D;
      if (k === "+" || k === "-") {
        if (this.options.loose || this.position > 0 && (this.current.type === "func" && this.current.value === "calc" ? this.prevToken[0] !== "space" && this.prevToken[0] !== "(" ? this.error("Syntax Error", this.currToken) : this.nextToken[0] !== "space" && this.nextToken[0] !== "word" ? this.error("Syntax Error", this.currToken) : this.nextToken[0] === "word" && this.current.last.type !== "operator" && this.current.last.value !== "(" && this.error("Syntax Error", this.currToken) : (this.nextToken[0] === "space" || this.nextToken[0] === "operator" || this.prevToken[0] === "operator") && this.error("Syntax Error", this.currToken)), this.options.loose) {
          if ((!this.current.nodes.length || this.current.last && this.current.last.type === "operator") && this.nextToken[0] === "word")
            return this.word();
        } else if (this.nextToken[0] === "word")
          return this.word();
      }
      return D = new t({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), this.position++, this.newNode(D);
    }
    parseTokens() {
      switch (this.currToken[0]) {
        case "space":
          this.space();
          break;
        case "colon":
          this.colon();
          break;
        case "comma":
          this.comma();
          break;
        case "comment":
          this.comment();
          break;
        case "(":
          this.parenOpen();
          break;
        case ")":
          this.parenClose();
          break;
        case "atword":
        case "word":
          this.word();
          break;
        case "operator":
          this.operator();
          break;
        case "string":
          this.string();
          break;
        case "unicoderange":
          this.unicodeRange();
          break;
        default:
          this.word();
          break;
      }
    }
    parenOpen() {
      let k = 1, D = this.position + 1, P = this.currToken, $2;
      for (; D < this.tokens.length && k; ) {
        let G = this.tokens[D];
        G[0] === "(" && k++, G[0] === ")" && k--, D++;
      }
      if (k && this.error("Expected closing parenthesis", P), $2 = this.current.last, $2 && $2.type === "func" && $2.unbalanced < 0 && ($2.unbalanced = 0, this.current = $2), this.current.unbalanced++, this.newNode(new e({ value: P[1], source: { start: { line: P[2], column: P[3] }, end: { line: P[4], column: P[5] } }, sourceIndex: P[6] })), this.position++, this.current.type === "func" && this.current.unbalanced && this.current.value === "url" && this.currToken[0] !== "string" && this.currToken[0] !== ")" && !this.options.loose) {
        let G = this.nextToken, Z = this.currToken[1], B = { line: this.currToken[2], column: this.currToken[3] };
        for (; G && G[0] !== ")" && this.current.unbalanced; )
          this.position++, Z += this.currToken[1], G = this.nextToken;
        this.position !== this.tokens.length - 1 && (this.position++, this.newNode(new i({ value: Z, source: { start: B, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] })));
      }
    }
    parenClose() {
      let k = this.currToken;
      this.newNode(new e({ value: k[1], source: { start: { line: k[2], column: k[3] }, end: { line: k[4], column: k[5] } }, sourceIndex: k[6] })), this.position++, !(this.position >= this.tokens.length - 1 && !this.current.unbalanced) && (this.current.unbalanced--, this.current.unbalanced < 0 && this.error("Expected opening parenthesis", k), !this.current.unbalanced && this.cache.length && (this.current = this.cache.pop()));
    }
    space() {
      let k = this.currToken;
      this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.raws.after += k[1], this.position++) : (this.spaces = k[1], this.position++);
    }
    unicodeRange() {
      let k = this.currToken;
      this.newNode(new u({ value: k[1], source: { start: { line: k[2], column: k[3] }, end: { line: k[4], column: k[5] } }, sourceIndex: k[6] })), this.position++;
    }
    splitWord() {
      let k = this.nextToken, D = this.currToken[1], P = /^[\+\-]?((\d+(\.\d*)?)|(\.\d+))([eE][\+\-]?\d+)?/, $2 = /^(?!\#([a-z0-9]+))[\#\{\}]/gi, G, Z;
      if (!$2.test(D))
        for (; k && k[0] === "word"; ) {
          this.position++;
          let B = this.currToken[1];
          D += B, k = this.nextToken;
        }
      G = y2(D, "@"), Z = _(w(v2([[0], G]))), Z.forEach((B, H) => {
        let U2 = Z[H + 1] || D.length, T = D.slice(B, U2), L;
        if (~G.indexOf(B))
          L = new o({ value: T.slice(1), source: { start: { line: this.currToken[2], column: this.currToken[3] + B }, end: { line: this.currToken[4], column: this.currToken[3] + (U2 - 1) } }, sourceIndex: this.currToken[6] + Z[H] });
        else if (P.test(this.currToken[1])) {
          let j = T.replace(P, "");
          L = new l({ value: T.replace(j, ""), source: { start: { line: this.currToken[2], column: this.currToken[3] + B }, end: { line: this.currToken[4], column: this.currToken[3] + (U2 - 1) } }, sourceIndex: this.currToken[6] + Z[H], unit: j });
        } else
          L = new (k && k[0] === "(" ? g2 : i)({ value: T, source: { start: { line: this.currToken[2], column: this.currToken[3] + B }, end: { line: this.currToken[4], column: this.currToken[3] + (U2 - 1) } }, sourceIndex: this.currToken[6] + Z[H] }), L.type === "word" ? (L.isHex = /^#(.+)/.test(T), L.isColor = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(T)) : this.cache.push(this.current);
        this.newNode(L);
      }), this.position++;
    }
    string() {
      let k = this.currToken, D = this.currToken[1], P = /^(\"|\')/, $2 = P.test(D), G = "", Z;
      $2 && (G = D.match(P)[0], D = D.slice(1, D.length - 1)), Z = new a({ value: D, source: { start: { line: k[2], column: k[3] }, end: { line: k[4], column: k[5] } }, sourceIndex: k[6], quoted: $2 }), Z.raws.quote = G, this.newNode(Z), this.position++;
    }
    word() {
      return this.splitWord();
    }
    newNode(k) {
      return this.spaces && (k.raws.before += this.spaces, this.spaces = ""), this.current.append(k);
    }
    get currToken() {
      return this.tokens[this.position];
    }
    get nextToken() {
      return this.tokens[this.position + 1];
    }
    get prevToken() {
      return this.tokens[this.position - 1];
    }
  };
} }), ef = R({ "node_modules/postcss-values-parser/lib/index.js"(r, n) {
  I();
  var s = Zl(), c = Ks(), o = Qs(), p = Ys(), f = Xs(), h = Zs(), g2 = eo(), l = ro(), t = to(), e = no(), a = so(), i = Js(), u = io(), m = function(v2, y2) {
    return new s(v2, y2);
  };
  m.atword = function(v2) {
    return new c(v2);
  }, m.colon = function(v2) {
    return new o(Object.assign({ value: ":" }, v2));
  }, m.comma = function(v2) {
    return new p(Object.assign({ value: "," }, v2));
  }, m.comment = function(v2) {
    return new f(v2);
  }, m.func = function(v2) {
    return new h(v2);
  }, m.number = function(v2) {
    return new g2(v2);
  }, m.operator = function(v2) {
    return new l(v2);
  }, m.paren = function(v2) {
    return new t(Object.assign({ value: "(" }, v2));
  }, m.string = function(v2) {
    return new e(Object.assign({ quote: "'" }, v2));
  }, m.value = function(v2) {
    return new i(v2);
  }, m.word = function(v2) {
    return new u(v2);
  }, m.unicodeRange = function(v2) {
    return new a(v2);
  }, n.exports = m;
} }), De = R({ "node_modules/postcss-selector-parser/dist/selectors/node.js"(r, n) {
  I(), r.__esModule = true;
  var s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(f) {
    return typeof f;
  } : function(f) {
    return f && typeof Symbol == "function" && f.constructor === Symbol && f !== Symbol.prototype ? "symbol" : typeof f;
  };
  function c(f, h) {
    if (!(f instanceof h))
      throw new TypeError("Cannot call a class as a function");
  }
  var o = function f(h, g2) {
    if ((typeof h > "u" ? "undefined" : s(h)) !== "object")
      return h;
    var l = new h.constructor();
    for (var t in h)
      if (h.hasOwnProperty(t)) {
        var e = h[t], a = typeof e > "u" ? "undefined" : s(e);
        t === "parent" && a === "object" ? g2 && (l[t] = g2) : e instanceof Array ? l[t] = e.map(function(i) {
          return f(i, l);
        }) : l[t] = f(e, l);
      }
    return l;
  }, p = function() {
    function f() {
      var h = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      c(this, f);
      for (var g2 in h)
        this[g2] = h[g2];
      var l = h.spaces;
      l = l === void 0 ? {} : l;
      var t = l.before, e = t === void 0 ? "" : t, a = l.after, i = a === void 0 ? "" : a;
      this.spaces = { before: e, after: i };
    }
    return f.prototype.remove = function() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }, f.prototype.replaceWith = function() {
      if (this.parent) {
        for (var g2 in arguments)
          this.parent.insertBefore(this, arguments[g2]);
        this.remove();
      }
      return this;
    }, f.prototype.next = function() {
      return this.parent.at(this.parent.index(this) + 1);
    }, f.prototype.prev = function() {
      return this.parent.at(this.parent.index(this) - 1);
    }, f.prototype.clone = function() {
      var g2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, l = o(this);
      for (var t in g2)
        l[t] = g2[t];
      return l;
    }, f.prototype.toString = function() {
      return [this.spaces.before, String(this.value), this.spaces.after].join("");
    }, f;
  }();
  r.default = p, n.exports = r.default;
} }), se = R({ "node_modules/postcss-selector-parser/dist/selectors/types.js"(r) {
  I(), r.__esModule = true;
  r.TAG = "tag";
  r.STRING = "string";
  r.SELECTOR = "selector";
  r.ROOT = "root";
  r.PSEUDO = "pseudo";
  r.NESTING = "nesting";
  r.ID = "id";
  r.COMMENT = "comment";
  r.COMBINATOR = "combinator";
  r.CLASS = "class";
  r.ATTRIBUTE = "attribute";
  r.UNIVERSAL = "universal";
} }), qt = R({ "node_modules/postcss-selector-parser/dist/selectors/container.js"(r, n) {
  I(), r.__esModule = true;
  var s = function() {
    function i(u, m) {
      for (var v2 = 0; v2 < m.length; v2++) {
        var y2 = m[v2];
        y2.enumerable = y2.enumerable || false, y2.configurable = true, "value" in y2 && (y2.writable = true), Object.defineProperty(u, y2.key, y2);
      }
    }
    return function(u, m, v2) {
      return m && i(u.prototype, m), v2 && i(u, v2), u;
    };
  }(), c = De(), o = g2(c), p = se(), f = h(p);
  function h(i) {
    if (i && i.__esModule)
      return i;
    var u = {};
    if (i != null)
      for (var m in i)
        Object.prototype.hasOwnProperty.call(i, m) && (u[m] = i[m]);
    return u.default = i, u;
  }
  function g2(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function l(i, u) {
    if (!(i instanceof u))
      throw new TypeError("Cannot call a class as a function");
  }
  function t(i, u) {
    if (!i)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return u && (typeof u == "object" || typeof u == "function") ? u : i;
  }
  function e(i, u) {
    if (typeof u != "function" && u !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof u);
    i.prototype = Object.create(u && u.prototype, { constructor: { value: i, enumerable: false, writable: true, configurable: true } }), u && (Object.setPrototypeOf ? Object.setPrototypeOf(i, u) : i.__proto__ = u);
  }
  var a = function(i) {
    e(u, i);
    function u(m) {
      l(this, u);
      var v2 = t(this, i.call(this, m));
      return v2.nodes || (v2.nodes = []), v2;
    }
    return u.prototype.append = function(v2) {
      return v2.parent = this, this.nodes.push(v2), this;
    }, u.prototype.prepend = function(v2) {
      return v2.parent = this, this.nodes.unshift(v2), this;
    }, u.prototype.at = function(v2) {
      return this.nodes[v2];
    }, u.prototype.index = function(v2) {
      return typeof v2 == "number" ? v2 : this.nodes.indexOf(v2);
    }, u.prototype.removeChild = function(v2) {
      v2 = this.index(v2), this.at(v2).parent = void 0, this.nodes.splice(v2, 1);
      var y2 = void 0;
      for (var w in this.indexes)
        y2 = this.indexes[w], y2 >= v2 && (this.indexes[w] = y2 - 1);
      return this;
    }, u.prototype.removeAll = function() {
      for (var w = this.nodes, v2 = Array.isArray(w), y2 = 0, w = v2 ? w : w[Symbol.iterator](); ; ) {
        var d2;
        if (v2) {
          if (y2 >= w.length)
            break;
          d2 = w[y2++];
        } else {
          if (y2 = w.next(), y2.done)
            break;
          d2 = y2.value;
        }
        var _ = d2;
        _.parent = void 0;
      }
      return this.nodes = [], this;
    }, u.prototype.empty = function() {
      return this.removeAll();
    }, u.prototype.insertAfter = function(v2, y2) {
      var w = this.index(v2);
      this.nodes.splice(w + 1, 0, y2);
      var d2 = void 0;
      for (var _ in this.indexes)
        d2 = this.indexes[_], w <= d2 && (this.indexes[_] = d2 + this.nodes.length);
      return this;
    }, u.prototype.insertBefore = function(v2, y2) {
      var w = this.index(v2);
      this.nodes.splice(w, 0, y2);
      var d2 = void 0;
      for (var _ in this.indexes)
        d2 = this.indexes[_], w <= d2 && (this.indexes[_] = d2 + this.nodes.length);
      return this;
    }, u.prototype.each = function(v2) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
      var y2 = this.lastEach;
      if (this.indexes[y2] = 0, !!this.length) {
        for (var w = void 0, d2 = void 0; this.indexes[y2] < this.length && (w = this.indexes[y2], d2 = v2(this.at(w), w), d2 !== false); )
          this.indexes[y2] += 1;
        if (delete this.indexes[y2], d2 === false)
          return false;
      }
    }, u.prototype.walk = function(v2) {
      return this.each(function(y2, w) {
        var d2 = v2(y2, w);
        if (d2 !== false && y2.length && (d2 = y2.walk(v2)), d2 === false)
          return false;
      });
    }, u.prototype.walkAttributes = function(v2) {
      var y2 = this;
      return this.walk(function(w) {
        if (w.type === f.ATTRIBUTE)
          return v2.call(y2, w);
      });
    }, u.prototype.walkClasses = function(v2) {
      var y2 = this;
      return this.walk(function(w) {
        if (w.type === f.CLASS)
          return v2.call(y2, w);
      });
    }, u.prototype.walkCombinators = function(v2) {
      var y2 = this;
      return this.walk(function(w) {
        if (w.type === f.COMBINATOR)
          return v2.call(y2, w);
      });
    }, u.prototype.walkComments = function(v2) {
      var y2 = this;
      return this.walk(function(w) {
        if (w.type === f.COMMENT)
          return v2.call(y2, w);
      });
    }, u.prototype.walkIds = function(v2) {
      var y2 = this;
      return this.walk(function(w) {
        if (w.type === f.ID)
          return v2.call(y2, w);
      });
    }, u.prototype.walkNesting = function(v2) {
      var y2 = this;
      return this.walk(function(w) {
        if (w.type === f.NESTING)
          return v2.call(y2, w);
      });
    }, u.prototype.walkPseudos = function(v2) {
      var y2 = this;
      return this.walk(function(w) {
        if (w.type === f.PSEUDO)
          return v2.call(y2, w);
      });
    }, u.prototype.walkTags = function(v2) {
      var y2 = this;
      return this.walk(function(w) {
        if (w.type === f.TAG)
          return v2.call(y2, w);
      });
    }, u.prototype.walkUniversals = function(v2) {
      var y2 = this;
      return this.walk(function(w) {
        if (w.type === f.UNIVERSAL)
          return v2.call(y2, w);
      });
    }, u.prototype.split = function(v2) {
      var y2 = this, w = [];
      return this.reduce(function(d2, _, O) {
        var k = v2.call(y2, _);
        return w.push(_), k ? (d2.push(w), w = []) : O === y2.length - 1 && d2.push(w), d2;
      }, []);
    }, u.prototype.map = function(v2) {
      return this.nodes.map(v2);
    }, u.prototype.reduce = function(v2, y2) {
      return this.nodes.reduce(v2, y2);
    }, u.prototype.every = function(v2) {
      return this.nodes.every(v2);
    }, u.prototype.some = function(v2) {
      return this.nodes.some(v2);
    }, u.prototype.filter = function(v2) {
      return this.nodes.filter(v2);
    }, u.prototype.sort = function(v2) {
      return this.nodes.sort(v2);
    }, u.prototype.toString = function() {
      return this.map(String).join("");
    }, s(u, [{ key: "first", get: function() {
      return this.at(0);
    } }, { key: "last", get: function() {
      return this.at(this.length - 1);
    } }, { key: "length", get: function() {
      return this.nodes.length;
    } }]), u;
  }(o.default);
  r.default = a, n.exports = r.default;
} }), qo = R({ "node_modules/postcss-selector-parser/dist/selectors/root.js"(r, n) {
  I(), r.__esModule = true;
  var s = qt(), c = p(s), o = se();
  function p(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function f(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function h(t, e) {
    if (!t)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function g2(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var l = function(t) {
    g2(e, t);
    function e(a) {
      f(this, e);
      var i = h(this, t.call(this, a));
      return i.type = o.ROOT, i;
    }
    return e.prototype.toString = function() {
      var i = this.reduce(function(u, m) {
        var v2 = String(m);
        return v2 ? u + v2 + "," : "";
      }, "").slice(0, -1);
      return this.trailingComma ? i + "," : i;
    }, e;
  }(c.default);
  r.default = l, n.exports = r.default;
} }), Ao = R({ "node_modules/postcss-selector-parser/dist/selectors/selector.js"(r, n) {
  I(), r.__esModule = true;
  var s = qt(), c = p(s), o = se();
  function p(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function f(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function h(t, e) {
    if (!t)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function g2(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var l = function(t) {
    g2(e, t);
    function e(a) {
      f(this, e);
      var i = h(this, t.call(this, a));
      return i.type = o.SELECTOR, i;
    }
    return e;
  }(c.default);
  r.default = l, n.exports = r.default;
} }), Ke = R({ "node_modules/postcss-selector-parser/dist/selectors/namespace.js"(r, n) {
  I(), r.__esModule = true;
  var s = function() {
    function t(e, a) {
      for (var i = 0; i < a.length; i++) {
        var u = a[i];
        u.enumerable = u.enumerable || false, u.configurable = true, "value" in u && (u.writable = true), Object.defineProperty(e, u.key, u);
      }
    }
    return function(e, a, i) {
      return a && t(e.prototype, a), i && t(e, i), e;
    };
  }(), c = De(), o = p(c);
  function p(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function f(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function h(t, e) {
    if (!t)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function g2(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var l = function(t) {
    g2(e, t);
    function e() {
      return f(this, e), h(this, t.apply(this, arguments));
    }
    return e.prototype.toString = function() {
      return [this.spaces.before, this.ns, String(this.value), this.spaces.after].join("");
    }, s(e, [{ key: "ns", get: function() {
      var i = this.namespace;
      return i ? (typeof i == "string" ? i : "") + "|" : "";
    } }]), e;
  }(o.default);
  r.default = l, n.exports = r.default;
} }), Po = R({ "node_modules/postcss-selector-parser/dist/selectors/className.js"(r, n) {
  I(), r.__esModule = true;
  var s = Ke(), c = p(s), o = se();
  function p(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function f(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function h(t, e) {
    if (!t)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function g2(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var l = function(t) {
    g2(e, t);
    function e(a) {
      f(this, e);
      var i = h(this, t.call(this, a));
      return i.type = o.CLASS, i;
    }
    return e.prototype.toString = function() {
      return [this.spaces.before, this.ns, String("." + this.value), this.spaces.after].join("");
    }, e;
  }(c.default);
  r.default = l, n.exports = r.default;
} }), Io = R({ "node_modules/postcss-selector-parser/dist/selectors/comment.js"(r, n) {
  I(), r.__esModule = true;
  var s = De(), c = p(s), o = se();
  function p(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function f(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function h(t, e) {
    if (!t)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function g2(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var l = function(t) {
    g2(e, t);
    function e(a) {
      f(this, e);
      var i = h(this, t.call(this, a));
      return i.type = o.COMMENT, i;
    }
    return e;
  }(c.default);
  r.default = l, n.exports = r.default;
} }), Ro = R({ "node_modules/postcss-selector-parser/dist/selectors/id.js"(r, n) {
  I(), r.__esModule = true;
  var s = Ke(), c = p(s), o = se();
  function p(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function f(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function h(t, e) {
    if (!t)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function g2(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var l = function(t) {
    g2(e, t);
    function e(a) {
      f(this, e);
      var i = h(this, t.call(this, a));
      return i.type = o.ID, i;
    }
    return e.prototype.toString = function() {
      return [this.spaces.before, this.ns, String("#" + this.value), this.spaces.after].join("");
    }, e;
  }(c.default);
  r.default = l, n.exports = r.default;
} }), Co = R({ "node_modules/postcss-selector-parser/dist/selectors/tag.js"(r, n) {
  I(), r.__esModule = true;
  var s = Ke(), c = p(s), o = se();
  function p(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function f(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function h(t, e) {
    if (!t)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function g2(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var l = function(t) {
    g2(e, t);
    function e(a) {
      f(this, e);
      var i = h(this, t.call(this, a));
      return i.type = o.TAG, i;
    }
    return e;
  }(c.default);
  r.default = l, n.exports = r.default;
} }), No = R({ "node_modules/postcss-selector-parser/dist/selectors/string.js"(r, n) {
  I(), r.__esModule = true;
  var s = De(), c = p(s), o = se();
  function p(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function f(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function h(t, e) {
    if (!t)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function g2(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var l = function(t) {
    g2(e, t);
    function e(a) {
      f(this, e);
      var i = h(this, t.call(this, a));
      return i.type = o.STRING, i;
    }
    return e;
  }(c.default);
  r.default = l, n.exports = r.default;
} }), jo = R({ "node_modules/postcss-selector-parser/dist/selectors/pseudo.js"(r, n) {
  I(), r.__esModule = true;
  var s = qt(), c = p(s), o = se();
  function p(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function f(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function h(t, e) {
    if (!t)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function g2(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var l = function(t) {
    g2(e, t);
    function e(a) {
      f(this, e);
      var i = h(this, t.call(this, a));
      return i.type = o.PSEUDO, i;
    }
    return e.prototype.toString = function() {
      var i = this.length ? "(" + this.map(String).join(",") + ")" : "";
      return [this.spaces.before, String(this.value), i, this.spaces.after].join("");
    }, e;
  }(c.default);
  r.default = l, n.exports = r.default;
} }), Mo = R({ "node_modules/postcss-selector-parser/dist/selectors/attribute.js"(r, n) {
  I(), r.__esModule = true;
  var s = Ke(), c = p(s), o = se();
  function p(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function f(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function h(t, e) {
    if (!t)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function g2(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var l = function(t) {
    g2(e, t);
    function e(a) {
      f(this, e);
      var i = h(this, t.call(this, a));
      return i.type = o.ATTRIBUTE, i.raws = {}, i;
    }
    return e.prototype.toString = function() {
      var i = [this.spaces.before, "[", this.ns, this.attribute];
      return this.operator && i.push(this.operator), this.value && i.push(this.value), this.raws.insensitive ? i.push(this.raws.insensitive) : this.insensitive && i.push(" i"), i.push("]"), i.concat(this.spaces.after).join("");
    }, e;
  }(c.default);
  r.default = l, n.exports = r.default;
} }), Do = R({ "node_modules/postcss-selector-parser/dist/selectors/universal.js"(r, n) {
  I(), r.__esModule = true;
  var s = Ke(), c = p(s), o = se();
  function p(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function f(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function h(t, e) {
    if (!t)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function g2(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var l = function(t) {
    g2(e, t);
    function e(a) {
      f(this, e);
      var i = h(this, t.call(this, a));
      return i.type = o.UNIVERSAL, i.value = "*", i;
    }
    return e;
  }(c.default);
  r.default = l, n.exports = r.default;
} }), Lo = R({ "node_modules/postcss-selector-parser/dist/selectors/combinator.js"(r, n) {
  I(), r.__esModule = true;
  var s = De(), c = p(s), o = se();
  function p(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function f(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function h(t, e) {
    if (!t)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function g2(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var l = function(t) {
    g2(e, t);
    function e(a) {
      f(this, e);
      var i = h(this, t.call(this, a));
      return i.type = o.COMBINATOR, i;
    }
    return e;
  }(c.default);
  r.default = l, n.exports = r.default;
} }), zo = R({ "node_modules/postcss-selector-parser/dist/selectors/nesting.js"(r, n) {
  I(), r.__esModule = true;
  var s = De(), c = p(s), o = se();
  function p(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function f(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function h(t, e) {
    if (!t)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function g2(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var l = function(t) {
    g2(e, t);
    function e(a) {
      f(this, e);
      var i = h(this, t.call(this, a));
      return i.type = o.NESTING, i.value = "&", i;
    }
    return e;
  }(c.default);
  r.default = l, n.exports = r.default;
} }), rf = R({ "node_modules/postcss-selector-parser/dist/sortAscending.js"(r, n) {
  I(), r.__esModule = true, r.default = s;
  function s(c) {
    return c.sort(function(o, p) {
      return o - p;
    });
  }
  n.exports = r.default;
} }), tf = R({ "node_modules/postcss-selector-parser/dist/tokenize.js"(r, n) {
  I(), r.__esModule = true, r.default = Z;
  var s = 39, c = 34, o = 92, p = 47, f = 10, h = 32, g2 = 12, l = 9, t = 13, e = 43, a = 62, i = 126, u = 124, m = 44, v2 = 40, y2 = 41, w = 91, d2 = 93, _ = 59, O = 42, k = 58, D = 38, P = 64, $2 = /[ \n\t\r\{\(\)'"\\;/]/g, G = /[ \n\t\r\(\)\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g;
  function Z(B) {
    for (var H = [], U2 = B.css.valueOf(), T = void 0, L = void 0, j = void 0, N2 = void 0, b = void 0, Y = void 0, J = void 0, W = void 0, X = void 0, C = void 0, Q = void 0, M2 = U2.length, E = -1, x = 1, S = 0, z = function(q, V) {
      if (B.safe)
        U2 += V, L = U2.length - 1;
      else
        throw B.error("Unclosed " + q, x, S - E, S);
    }; S < M2; ) {
      switch (T = U2.charCodeAt(S), T === f && (E = S, x += 1), T) {
        case f:
        case h:
        case l:
        case t:
        case g2:
          L = S;
          do
            L += 1, T = U2.charCodeAt(L), T === f && (E = L, x += 1);
          while (T === h || T === f || T === l || T === t || T === g2);
          H.push(["space", U2.slice(S, L), x, S - E, S]), S = L - 1;
          break;
        case e:
        case a:
        case i:
        case u:
          L = S;
          do
            L += 1, T = U2.charCodeAt(L);
          while (T === e || T === a || T === i || T === u);
          H.push(["combinator", U2.slice(S, L), x, S - E, S]), S = L - 1;
          break;
        case O:
          H.push(["*", "*", x, S - E, S]);
          break;
        case D:
          H.push(["&", "&", x, S - E, S]);
          break;
        case m:
          H.push([",", ",", x, S - E, S]);
          break;
        case w:
          H.push(["[", "[", x, S - E, S]);
          break;
        case d2:
          H.push(["]", "]", x, S - E, S]);
          break;
        case k:
          H.push([":", ":", x, S - E, S]);
          break;
        case _:
          H.push([";", ";", x, S - E, S]);
          break;
        case v2:
          H.push(["(", "(", x, S - E, S]);
          break;
        case y2:
          H.push([")", ")", x, S - E, S]);
          break;
        case s:
        case c:
          j = T === s ? "'" : '"', L = S;
          do
            for (C = false, L = U2.indexOf(j, L + 1), L === -1 && z("quote", j), Q = L; U2.charCodeAt(Q - 1) === o; )
              Q -= 1, C = !C;
          while (C);
          H.push(["string", U2.slice(S, L + 1), x, S - E, x, L - E, S]), S = L;
          break;
        case P:
          $2.lastIndex = S + 1, $2.test(U2), $2.lastIndex === 0 ? L = U2.length - 1 : L = $2.lastIndex - 2, H.push(["at-word", U2.slice(S, L + 1), x, S - E, x, L - E, S]), S = L;
          break;
        case o:
          for (L = S, J = true; U2.charCodeAt(L + 1) === o; )
            L += 1, J = !J;
          T = U2.charCodeAt(L + 1), J && T !== p && T !== h && T !== f && T !== l && T !== t && T !== g2 && (L += 1), H.push(["word", U2.slice(S, L + 1), x, S - E, x, L - E, S]), S = L;
          break;
        default:
          T === p && U2.charCodeAt(S + 1) === O ? (L = U2.indexOf("*/", S + 2) + 1, L === 0 && z("comment", "*/"), Y = U2.slice(S, L + 1), N2 = Y.split(`
`), b = N2.length - 1, b > 0 ? (W = x + b, X = L - N2[b].length) : (W = x, X = E), H.push(["comment", Y, x, S - E, W, L - X, S]), E = X, x = W, S = L) : (G.lastIndex = S + 1, G.test(U2), G.lastIndex === 0 ? L = U2.length - 1 : L = G.lastIndex - 2, H.push(["word", U2.slice(S, L + 1), x, S - E, x, L - E, S]), S = L);
          break;
      }
      S++;
    }
    return H;
  }
  n.exports = r.default;
} }), nf = R({ "node_modules/postcss-selector-parser/dist/parser.js"(r, n) {
  I(), r.__esModule = true;
  var s = function() {
    function E(x, S) {
      for (var z = 0; z < S.length; z++) {
        var A = S[z];
        A.enumerable = A.enumerable || false, A.configurable = true, "value" in A && (A.writable = true), Object.defineProperty(x, A.key, A);
      }
    }
    return function(x, S, z) {
      return S && E(x.prototype, S), z && E(x, z), x;
    };
  }(), c = Oo(), o = C(c), p = To(), f = C(p), h = Eo(), g2 = C(h), l = qo(), t = C(l), e = Ao(), a = C(e), i = Po(), u = C(i), m = Io(), v2 = C(m), y2 = Ro(), w = C(y2), d2 = Co(), _ = C(d2), O = No(), k = C(O), D = jo(), P = C(D), $2 = Mo(), G = C($2), Z = Do(), B = C(Z), H = Lo(), U2 = C(H), T = zo(), L = C(T), j = rf(), N2 = C(j), b = tf(), Y = C(b), J = se(), W = X(J);
  function X(E) {
    if (E && E.__esModule)
      return E;
    var x = {};
    if (E != null)
      for (var S in E)
        Object.prototype.hasOwnProperty.call(E, S) && (x[S] = E[S]);
    return x.default = E, x;
  }
  function C(E) {
    return E && E.__esModule ? E : { default: E };
  }
  function Q(E, x) {
    if (!(E instanceof x))
      throw new TypeError("Cannot call a class as a function");
  }
  var M2 = function() {
    function E(x) {
      Q(this, E), this.input = x, this.lossy = x.options.lossless === false, this.position = 0, this.root = new t.default();
      var S = new a.default();
      return this.root.append(S), this.current = S, this.lossy ? this.tokens = (0, Y.default)({ safe: x.safe, css: x.css.trim() }) : this.tokens = (0, Y.default)(x), this.loop();
    }
    return E.prototype.attribute = function() {
      var S = "", z = void 0, A = this.currToken;
      for (this.position++; this.position < this.tokens.length && this.currToken[0] !== "]"; )
        S += this.tokens[this.position][1], this.position++;
      this.position === this.tokens.length && !~S.indexOf("]") && this.error("Expected a closing square bracket.");
      var q = S.split(/((?:[*~^$|]?=))([^]*)/), V = q[0].split(/(\|)/g), F = { operator: q[1], value: q[2], source: { start: { line: A[2], column: A[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: A[4] };
      if (V.length > 1 ? (V[0] === "" && (V[0] = true), F.attribute = this.parseValue(V[2]), F.namespace = this.parseNamespace(V[0])) : F.attribute = this.parseValue(q[0]), z = new G.default(F), q[2]) {
        var ee2 = q[2].split(/(\s+i\s*?)$/), te2 = ee2[0].trim();
        z.value = this.lossy ? te2 : ee2[0], ee2[1] && (z.insensitive = true, this.lossy || (z.raws.insensitive = ee2[1])), z.quoted = te2[0] === "'" || te2[0] === '"', z.raws.unquoted = z.quoted ? te2.slice(1, -1) : te2;
      }
      this.newNode(z), this.position++;
    }, E.prototype.combinator = function() {
      if (this.currToken[1] === "|")
        return this.namespace();
      for (var S = new U2.default({ value: "", source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }); this.position < this.tokens.length && this.currToken && (this.currToken[0] === "space" || this.currToken[0] === "combinator"); )
        this.nextToken && this.nextToken[0] === "combinator" ? (S.spaces.before = this.parseSpace(this.currToken[1]), S.source.start.line = this.nextToken[2], S.source.start.column = this.nextToken[3], S.source.end.column = this.nextToken[3], S.source.end.line = this.nextToken[2], S.sourceIndex = this.nextToken[4]) : this.prevToken && this.prevToken[0] === "combinator" ? S.spaces.after = this.parseSpace(this.currToken[1]) : this.currToken[0] === "combinator" ? S.value = this.currToken[1] : this.currToken[0] === "space" && (S.value = this.parseSpace(this.currToken[1], " ")), this.position++;
      return this.newNode(S);
    }, E.prototype.comma = function() {
      if (this.position === this.tokens.length - 1) {
        this.root.trailingComma = true, this.position++;
        return;
      }
      var S = new a.default();
      this.current.parent.append(S), this.current = S, this.position++;
    }, E.prototype.comment = function() {
      var S = new v2.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] });
      this.newNode(S), this.position++;
    }, E.prototype.error = function(S) {
      throw new this.input.error(S);
    }, E.prototype.missingBackslash = function() {
      return this.error("Expected a backslash preceding the semicolon.");
    }, E.prototype.missingParenthesis = function() {
      return this.error("Expected opening parenthesis.");
    }, E.prototype.missingSquareBracket = function() {
      return this.error("Expected opening square bracket.");
    }, E.prototype.namespace = function() {
      var S = this.prevToken && this.prevToken[1] || true;
      if (this.nextToken[0] === "word")
        return this.position++, this.word(S);
      if (this.nextToken[0] === "*")
        return this.position++, this.universal(S);
    }, E.prototype.nesting = function() {
      this.newNode(new L.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] })), this.position++;
    }, E.prototype.parentheses = function() {
      var S = this.current.last;
      if (S && S.type === W.PSEUDO) {
        var z = new a.default(), A = this.current;
        S.append(z), this.current = z;
        var q = 1;
        for (this.position++; this.position < this.tokens.length && q; )
          this.currToken[0] === "(" && q++, this.currToken[0] === ")" && q--, q ? this.parse() : (z.parent.source.end.line = this.currToken[2], z.parent.source.end.column = this.currToken[3], this.position++);
        q && this.error("Expected closing parenthesis."), this.current = A;
      } else {
        var V = 1;
        for (this.position++, S.value += "("; this.position < this.tokens.length && V; )
          this.currToken[0] === "(" && V++, this.currToken[0] === ")" && V--, S.value += this.parseParenthesisToken(this.currToken), this.position++;
        V && this.error("Expected closing parenthesis.");
      }
    }, E.prototype.pseudo = function() {
      for (var S = this, z = "", A = this.currToken; this.currToken && this.currToken[0] === ":"; )
        z += this.currToken[1], this.position++;
      if (!this.currToken)
        return this.error("Expected pseudo-class or pseudo-element");
      if (this.currToken[0] === "word") {
        var q = void 0;
        this.splitWord(false, function(V, F) {
          z += V, q = new P.default({ value: z, source: { start: { line: A[2], column: A[3] }, end: { line: S.currToken[4], column: S.currToken[5] } }, sourceIndex: A[4] }), S.newNode(q), F > 1 && S.nextToken && S.nextToken[0] === "(" && S.error("Misplaced parenthesis.");
        });
      } else
        this.error('Unexpected "' + this.currToken[0] + '" found.');
    }, E.prototype.space = function() {
      var S = this.currToken;
      this.position === 0 || this.prevToken[0] === "," || this.prevToken[0] === "(" ? (this.spaces = this.parseSpace(S[1]), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.spaces.after = this.parseSpace(S[1]), this.position++) : this.combinator();
    }, E.prototype.string = function() {
      var S = this.currToken;
      this.newNode(new k.default({ value: this.currToken[1], source: { start: { line: S[2], column: S[3] }, end: { line: S[4], column: S[5] } }, sourceIndex: S[6] })), this.position++;
    }, E.prototype.universal = function(S) {
      var z = this.nextToken;
      if (z && z[1] === "|")
        return this.position++, this.namespace();
      this.newNode(new B.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), S), this.position++;
    }, E.prototype.splitWord = function(S, z) {
      for (var A = this, q = this.nextToken, V = this.currToken[1]; q && q[0] === "word"; ) {
        this.position++;
        var F = this.currToken[1];
        if (V += F, F.lastIndexOf("\\") === F.length - 1) {
          var ee2 = this.nextToken;
          ee2 && ee2[0] === "space" && (V += this.parseSpace(ee2[1], " "), this.position++);
        }
        q = this.nextToken;
      }
      var te2 = (0, f.default)(V, "."), ue2 = (0, f.default)(V, "#"), le2 = (0, f.default)(V, "#{");
      le2.length && (ue2 = ue2.filter(function(ne2) {
        return !~le2.indexOf(ne2);
      }));
      var re = (0, N2.default)((0, g2.default)((0, o.default)([[0], te2, ue2])));
      re.forEach(function(ne2, oe) {
        var ie2 = re[oe + 1] || V.length, ce2 = V.slice(ne2, ie2);
        if (oe === 0 && z)
          return z.call(A, ce2, re.length);
        var fe2 = void 0;
        ~te2.indexOf(ne2) ? fe2 = new u.default({ value: ce2.slice(1), source: { start: { line: A.currToken[2], column: A.currToken[3] + ne2 }, end: { line: A.currToken[4], column: A.currToken[3] + (ie2 - 1) } }, sourceIndex: A.currToken[6] + re[oe] }) : ~ue2.indexOf(ne2) ? fe2 = new w.default({ value: ce2.slice(1), source: { start: { line: A.currToken[2], column: A.currToken[3] + ne2 }, end: { line: A.currToken[4], column: A.currToken[3] + (ie2 - 1) } }, sourceIndex: A.currToken[6] + re[oe] }) : fe2 = new _.default({ value: ce2, source: { start: { line: A.currToken[2], column: A.currToken[3] + ne2 }, end: { line: A.currToken[4], column: A.currToken[3] + (ie2 - 1) } }, sourceIndex: A.currToken[6] + re[oe] }), A.newNode(fe2, S);
      }), this.position++;
    }, E.prototype.word = function(S) {
      var z = this.nextToken;
      return z && z[1] === "|" ? (this.position++, this.namespace()) : this.splitWord(S);
    }, E.prototype.loop = function() {
      for (; this.position < this.tokens.length; )
        this.parse(true);
      return this.root;
    }, E.prototype.parse = function(S) {
      switch (this.currToken[0]) {
        case "space":
          this.space();
          break;
        case "comment":
          this.comment();
          break;
        case "(":
          this.parentheses();
          break;
        case ")":
          S && this.missingParenthesis();
          break;
        case "[":
          this.attribute();
          break;
        case "]":
          this.missingSquareBracket();
          break;
        case "at-word":
        case "word":
          this.word();
          break;
        case ":":
          this.pseudo();
          break;
        case ";":
          this.missingBackslash();
          break;
        case ",":
          this.comma();
          break;
        case "*":
          this.universal();
          break;
        case "&":
          this.nesting();
          break;
        case "combinator":
          this.combinator();
          break;
        case "string":
          this.string();
          break;
      }
    }, E.prototype.parseNamespace = function(S) {
      if (this.lossy && typeof S == "string") {
        var z = S.trim();
        return z.length ? z : true;
      }
      return S;
    }, E.prototype.parseSpace = function(S, z) {
      return this.lossy ? z || "" : S;
    }, E.prototype.parseValue = function(S) {
      return this.lossy && S && typeof S == "string" ? S.trim() : S;
    }, E.prototype.parseParenthesisToken = function(S) {
      return this.lossy ? S[0] === "space" ? this.parseSpace(S[1], " ") : this.parseValue(S[1]) : S[1];
    }, E.prototype.newNode = function(S, z) {
      return z && (S.namespace = this.parseNamespace(z)), this.spaces && (S.spaces.before = this.spaces, this.spaces = ""), this.current.append(S);
    }, s(E, [{ key: "currToken", get: function() {
      return this.tokens[this.position];
    } }, { key: "nextToken", get: function() {
      return this.tokens[this.position + 1];
    } }, { key: "prevToken", get: function() {
      return this.tokens[this.position - 1];
    } }]), E;
  }();
  r.default = M2, n.exports = r.default;
} }), sf = R({ "node_modules/postcss-selector-parser/dist/processor.js"(r, n) {
  I(), r.__esModule = true;
  var s = function() {
    function g2(l, t) {
      for (var e = 0; e < t.length; e++) {
        var a = t[e];
        a.enumerable = a.enumerable || false, a.configurable = true, "value" in a && (a.writable = true), Object.defineProperty(l, a.key, a);
      }
    }
    return function(l, t, e) {
      return t && g2(l.prototype, t), e && g2(l, e), l;
    };
  }(), c = nf(), o = p(c);
  function p(g2) {
    return g2 && g2.__esModule ? g2 : { default: g2 };
  }
  function f(g2, l) {
    if (!(g2 instanceof l))
      throw new TypeError("Cannot call a class as a function");
  }
  var h = function() {
    function g2(l) {
      return f(this, g2), this.func = l || function() {
      }, this;
    }
    return g2.prototype.process = function(t) {
      var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a = new o.default({ css: t, error: function(u) {
        throw new Error(u);
      }, options: e });
      return this.res = a, this.func(a), this;
    }, s(g2, [{ key: "result", get: function() {
      return String(this.res);
    } }]), g2;
  }();
  r.default = h, n.exports = r.default;
} }), of = R({ "node_modules/postcss-selector-parser/dist/index.js"(r, n) {
  I(), r.__esModule = true;
  var s = sf(), c = T(s), o = Mo(), p = T(o), f = Po(), h = T(f), g2 = Lo(), l = T(g2), t = Io(), e = T(t), a = Ro(), i = T(a), u = zo(), m = T(u), v2 = jo(), y2 = T(v2), w = qo(), d2 = T(w), _ = Ao(), O = T(_), k = No(), D = T(k), P = Co(), $2 = T(P), G = Do(), Z = T(G), B = se(), H = U2(B);
  function U2(j) {
    if (j && j.__esModule)
      return j;
    var N2 = {};
    if (j != null)
      for (var b in j)
        Object.prototype.hasOwnProperty.call(j, b) && (N2[b] = j[b]);
    return N2.default = j, N2;
  }
  function T(j) {
    return j && j.__esModule ? j : { default: j };
  }
  var L = function(N2) {
    return new c.default(N2);
  };
  L.attribute = function(j) {
    return new p.default(j);
  }, L.className = function(j) {
    return new h.default(j);
  }, L.combinator = function(j) {
    return new l.default(j);
  }, L.comment = function(j) {
    return new e.default(j);
  }, L.id = function(j) {
    return new i.default(j);
  }, L.nesting = function(j) {
    return new m.default(j);
  }, L.pseudo = function(j) {
    return new y2.default(j);
  }, L.root = function(j) {
    return new d2.default(j);
  }, L.selector = function(j) {
    return new O.default(j);
  }, L.string = function(j) {
    return new D.default(j);
  }, L.tag = function(j) {
    return new $2.default(j);
  }, L.universal = function(j) {
    return new Z.default(j);
  }, Object.keys(H).forEach(function(j) {
    j !== "__esModule" && (L[j] = H[j]);
  }), r.default = L, n.exports = r.default;
} }), Bo = R({ "node_modules/postcss-media-query-parser/dist/nodes/Node.js"(r) {
  I(), Object.defineProperty(r, "__esModule", { value: true });
  function n(s) {
    this.after = s.after, this.before = s.before, this.type = s.type, this.value = s.value, this.sourceIndex = s.sourceIndex;
  }
  r.default = n;
} }), Fo = R({ "node_modules/postcss-media-query-parser/dist/nodes/Container.js"(r) {
  I(), Object.defineProperty(r, "__esModule", { value: true });
  var n = Bo(), s = c(n);
  function c(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function o(p) {
    var f = this;
    this.constructor(p), this.nodes = p.nodes, this.after === void 0 && (this.after = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : ""), this.before === void 0 && (this.before = this.nodes.length > 0 ? this.nodes[0].before : ""), this.sourceIndex === void 0 && (this.sourceIndex = this.before.length), this.nodes.forEach(function(h) {
      h.parent = f;
    });
  }
  o.prototype = Object.create(s.default.prototype), o.constructor = s.default, o.prototype.walk = function(f, h) {
    for (var g2 = typeof f == "string" || f instanceof RegExp, l = g2 ? h : f, t = typeof f == "string" ? new RegExp(f) : f, e = 0; e < this.nodes.length; e++) {
      var a = this.nodes[e], i = g2 ? t.test(a.type) : true;
      if (i && l && l(a, e, this.nodes) === false || a.nodes && a.walk(f, h) === false)
        return false;
    }
    return true;
  }, o.prototype.each = function() {
    for (var f = arguments.length <= 0 || arguments[0] === void 0 ? function() {
    } : arguments[0], h = 0; h < this.nodes.length; h++) {
      var g2 = this.nodes[h];
      if (f(g2, h, this.nodes) === false)
        return false;
    }
    return true;
  }, r.default = o;
} }), af = R({ "node_modules/postcss-media-query-parser/dist/parsers.js"(r) {
  I(), Object.defineProperty(r, "__esModule", { value: true }), r.parseMediaFeature = f, r.parseMediaQuery = h, r.parseMediaList = g2;
  var n = Bo(), s = p(n), c = Fo(), o = p(c);
  function p(l) {
    return l && l.__esModule ? l : { default: l };
  }
  function f(l) {
    var t = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], e = [{ mode: "normal", character: null }], a = [], i = 0, u = "", m = null, v2 = null, y2 = t, w = l;
    l[0] === "(" && l[l.length - 1] === ")" && (w = l.substring(1, l.length - 1), y2++);
    for (var d2 = 0; d2 < w.length; d2++) {
      var _ = w[d2];
      if ((_ === "'" || _ === '"') && (e[i].isCalculationEnabled === true ? (e.push({ mode: "string", isCalculationEnabled: false, character: _ }), i++) : e[i].mode === "string" && e[i].character === _ && w[d2 - 1] !== "\\" && (e.pop(), i--)), _ === "{" ? (e.push({ mode: "interpolation", isCalculationEnabled: true }), i++) : _ === "}" && (e.pop(), i--), e[i].mode === "normal" && _ === ":") {
        var O = w.substring(d2 + 1);
        v2 = { type: "value", before: /^(\s*)/.exec(O)[1], after: /(\s*)$/.exec(O)[1], value: O.trim() }, v2.sourceIndex = v2.before.length + d2 + 1 + y2, m = { type: "colon", sourceIndex: d2 + y2, after: v2.before, value: ":" };
        break;
      }
      u += _;
    }
    return u = { type: "media-feature", before: /^(\s*)/.exec(u)[1], after: /(\s*)$/.exec(u)[1], value: u.trim() }, u.sourceIndex = u.before.length + y2, a.push(u), m !== null && (m.before = u.after, a.push(m)), v2 !== null && a.push(v2), a;
  }
  function h(l) {
    var t = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], e = [], a = 0, i = false, u = void 0;
    function m() {
      return { before: "", after: "", value: "" };
    }
    u = m();
    for (var v2 = 0; v2 < l.length; v2++) {
      var y2 = l[v2];
      i ? (u.value += y2, (y2 === "{" || y2 === "(") && a++, (y2 === ")" || y2 === "}") && a--) : y2.search(/\s/) !== -1 ? u.before += y2 : (y2 === "(" && (u.type = "media-feature-expression", a++), u.value = y2, u.sourceIndex = t + v2, i = true), i && a === 0 && (y2 === ")" || v2 === l.length - 1 || l[v2 + 1].search(/\s/) !== -1) && (["not", "only", "and"].indexOf(u.value) !== -1 && (u.type = "keyword"), u.type === "media-feature-expression" && (u.nodes = f(u.value, u.sourceIndex)), e.push(Array.isArray(u.nodes) ? new o.default(u) : new s.default(u)), u = m(), i = false);
    }
    for (var w = 0; w < e.length; w++)
      if (u = e[w], w > 0 && (e[w - 1].after = u.before), u.type === void 0) {
        if (w > 0) {
          if (e[w - 1].type === "media-feature-expression") {
            u.type = "keyword";
            continue;
          }
          if (e[w - 1].value === "not" || e[w - 1].value === "only") {
            u.type = "media-type";
            continue;
          }
          if (e[w - 1].value === "and") {
            u.type = "media-feature-expression";
            continue;
          }
          e[w - 1].type === "media-type" && (e[w + 1] ? u.type = e[w + 1].type === "media-feature-expression" ? "keyword" : "media-feature-expression" : u.type = "media-feature-expression");
        }
        if (w === 0) {
          if (!e[w + 1]) {
            u.type = "media-type";
            continue;
          }
          if (e[w + 1] && (e[w + 1].type === "media-feature-expression" || e[w + 1].type === "keyword")) {
            u.type = "media-type";
            continue;
          }
          if (e[w + 2]) {
            if (e[w + 2].type === "media-feature-expression") {
              u.type = "media-type", e[w + 1].type = "keyword";
              continue;
            }
            if (e[w + 2].type === "keyword") {
              u.type = "keyword", e[w + 1].type = "media-type";
              continue;
            }
          }
          if (e[w + 3] && e[w + 3].type === "media-feature-expression") {
            u.type = "keyword", e[w + 1].type = "media-type", e[w + 2].type = "keyword";
            continue;
          }
        }
      }
    return e;
  }
  function g2(l) {
    var t = [], e = 0, a = 0, i = /^(\s*)url\s*\(/.exec(l);
    if (i !== null) {
      for (var u = i[0].length, m = 1; m > 0; ) {
        var v2 = l[u];
        v2 === "(" && m++, v2 === ")" && m--, u++;
      }
      t.unshift(new s.default({ type: "url", value: l.substring(0, u).trim(), sourceIndex: i[1].length, before: i[1], after: /^(\s*)/.exec(l.substring(u))[1] })), e = u;
    }
    for (var y2 = e; y2 < l.length; y2++) {
      var w = l[y2];
      if (w === "(" && a++, w === ")" && a--, a === 0 && w === ",") {
        var d2 = l.substring(e, y2), _ = /^(\s*)/.exec(d2)[1];
        t.push(new o.default({ type: "media-query", value: d2.trim(), sourceIndex: e + _.length, nodes: h(d2, e), before: _, after: /(\s*)$/.exec(d2)[1] })), e = y2 + 1;
      }
    }
    var O = l.substring(e), k = /^(\s*)/.exec(O)[1];
    return t.push(new o.default({ type: "media-query", value: O.trim(), sourceIndex: e + k.length, nodes: h(O, e), before: k, after: /(\s*)$/.exec(O)[1] })), t;
  }
} }), uf = R({ "node_modules/postcss-media-query-parser/dist/index.js"(r) {
  I(), Object.defineProperty(r, "__esModule", { value: true }), r.default = p;
  var n = Fo(), s = o(n), c = af();
  function o(f) {
    return f && f.__esModule ? f : { default: f };
  }
  function p(f) {
    return new s.default({ nodes: (0, c.parseMediaList)(f), type: "media-query-list", value: f.trim() });
  }
} }), Uo = {};
_t(Uo, { basename: () => Ho, default: () => Ko, delimiter: () => gt, dirname: () => Go, extname: () => Jo, isAbsolute: () => Pt, join: () => Wo, normalize: () => At, relative: () => Vo, resolve: () => dr, sep: () => mt });
function $o(r, n) {
  for (var s = 0, c = r.length - 1; c >= 0; c--) {
    var o = r[c];
    o === "." ? r.splice(c, 1) : o === ".." ? (r.splice(c, 1), s++) : s && (r.splice(c, 1), s--);
  }
  if (n)
    for (; s--; s)
      r.unshift("..");
  return r;
}
function dr() {
  for (var r = "", n = false, s = arguments.length - 1; s >= -1 && !n; s--) {
    var c = s >= 0 ? arguments[s] : "/";
    if (typeof c != "string")
      throw new TypeError("Arguments to path.resolve must be strings");
    if (!c)
      continue;
    r = c + "/" + r, n = c.charAt(0) === "/";
  }
  return r = $o(It(r.split("/"), function(o) {
    return !!o;
  }), !n).join("/"), (n ? "/" : "") + r || ".";
}
function At(r) {
  var n = Pt(r), s = Qo(r, -1) === "/";
  return r = $o(It(r.split("/"), function(c) {
    return !!c;
  }), !n).join("/"), !r && !n && (r = "."), r && s && (r += "/"), (n ? "/" : "") + r;
}
function Pt(r) {
  return r.charAt(0) === "/";
}
function Wo() {
  var r = Array.prototype.slice.call(arguments, 0);
  return At(It(r, function(n, s) {
    if (typeof n != "string")
      throw new TypeError("Arguments to path.join must be strings");
    return n;
  }).join("/"));
}
function Vo(r, n) {
  r = dr(r).substr(1), n = dr(n).substr(1);
  function s(l) {
    for (var t = 0; t < l.length && l[t] === ""; t++)
      ;
    for (var e = l.length - 1; e >= 0 && l[e] === ""; e--)
      ;
    return t > e ? [] : l.slice(t, e - t + 1);
  }
  for (var c = s(r.split("/")), o = s(n.split("/")), p = Math.min(c.length, o.length), f = p, h = 0; h < p; h++)
    if (c[h] !== o[h]) {
      f = h;
      break;
    }
  for (var g2 = [], h = f; h < c.length; h++)
    g2.push("..");
  return g2 = g2.concat(o.slice(f)), g2.join("/");
}
function Go(r) {
  var n = gr(r), s = n[0], c = n[1];
  return !s && !c ? "." : (c && (c = c.substr(0, c.length - 1)), s + c);
}
function Ho(r, n) {
  var s = gr(r)[2];
  return n && s.substr(-1 * n.length) === n && (s = s.substr(0, s.length - n.length)), s;
}
function Jo(r) {
  return gr(r)[3];
}
function It(r, n) {
  if (r.filter)
    return r.filter(n);
  for (var s = [], c = 0; c < r.length; c++)
    n(r[c], c, r) && s.push(r[c]);
  return s;
}
var Rs, gr, mt, gt, Ko, Qo, cf = Me({ "node-modules-polyfills:path"() {
  I(), Rs = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, gr = function(r) {
    return Rs.exec(r).slice(1);
  }, mt = "/", gt = ":", Ko = { extname: Jo, basename: Ho, dirname: Go, sep: mt, delimiter: gt, relative: Vo, join: Wo, isAbsolute: Pt, normalize: At, resolve: dr }, Qo = "ab".substr(-1) === "b" ? function(r, n, s) {
    return r.substr(n, s);
  } : function(r, n, s) {
    return n < 0 && (n = r.length + n), r.substr(n, s);
  };
} }), lf = R({ "node-modules-polyfills-commonjs:path"(r, n) {
  I();
  var s = (cf(), bt(Uo));
  if (s && s.default) {
    n.exports = s.default;
    for (let c in s)
      n.exports[c] = s[c];
  } else
    s && (n.exports = s);
} }), ff = R({ "node_modules/picocolors/picocolors.browser.js"(r, n) {
  I();
  var s = String, c = function() {
    return { isColorSupported: false, reset: s, bold: s, dim: s, italic: s, underline: s, inverse: s, hidden: s, strikethrough: s, black: s, red: s, green: s, yellow: s, blue: s, magenta: s, cyan: s, white: s, gray: s, bgBlack: s, bgRed: s, bgGreen: s, bgYellow: s, bgBlue: s, bgMagenta: s, bgCyan: s, bgWhite: s };
  };
  n.exports = c(), n.exports.createColors = c;
} }), pf = R({ "(disabled):node_modules/postcss/lib/terminal-highlight"() {
  I();
} }), Yo = R({ "node_modules/postcss/lib/css-syntax-error.js"(r, n) {
  I(), r.__esModule = true, r.default = void 0;
  var s = o(ff()), c = o(pf());
  function o(m) {
    return m && m.__esModule ? m : { default: m };
  }
  function p(m) {
    if (m === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return m;
  }
  function f(m, v2) {
    m.prototype = Object.create(v2.prototype), m.prototype.constructor = m, m.__proto__ = v2;
  }
  function h(m) {
    var v2 = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
    return h = function(w) {
      if (w === null || !t(w))
        return w;
      if (typeof w != "function")
        throw new TypeError("Super expression must either be null or a function");
      if (typeof v2 < "u") {
        if (v2.has(w))
          return v2.get(w);
        v2.set(w, d2);
      }
      function d2() {
        return g2(w, arguments, a(this).constructor);
      }
      return d2.prototype = Object.create(w.prototype, { constructor: { value: d2, enumerable: false, writable: true, configurable: true } }), e(d2, w);
    }, h(m);
  }
  function g2(m, v2, y2) {
    return l() ? g2 = Reflect.construct : g2 = function(d2, _, O) {
      var k = [null];
      k.push.apply(k, _);
      var D = Function.bind.apply(d2, k), P = new D();
      return O && e(P, O.prototype), P;
    }, g2.apply(null, arguments);
  }
  function l() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return false;
    if (typeof Proxy == "function")
      return true;
    try {
      return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      })), true;
    } catch {
      return false;
    }
  }
  function t(m) {
    return Function.toString.call(m).indexOf("[native code]") !== -1;
  }
  function e(m, v2) {
    return e = Object.setPrototypeOf || function(w, d2) {
      return w.__proto__ = d2, w;
    }, e(m, v2);
  }
  function a(m) {
    return a = Object.setPrototypeOf ? Object.getPrototypeOf : function(y2) {
      return y2.__proto__ || Object.getPrototypeOf(y2);
    }, a(m);
  }
  var i = function(m) {
    f(v2, m);
    function v2(w, d2, _, O, k, D) {
      var P;
      return P = m.call(this, w) || this, P.name = "CssSyntaxError", P.reason = w, k && (P.file = k), O && (P.source = O), D && (P.plugin = D), typeof d2 < "u" && typeof _ < "u" && (P.line = d2, P.column = _), P.setMessage(), Error.captureStackTrace && Error.captureStackTrace(p(P), v2), P;
    }
    var y2 = v2.prototype;
    return y2.setMessage = function() {
      this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
    }, y2.showSourceCode = function(d2) {
      var _ = this;
      if (!this.source)
        return "";
      var O = this.source;
      c.default && (typeof d2 > "u" && (d2 = s.default.isColorSupported), d2 && (O = (0, c.default)(O)));
      var k = O.split(/\r?\n/), D = Math.max(this.line - 3, 0), P = Math.min(this.line + 2, k.length), $2 = String(P).length;
      function G(B) {
        return d2 && s.default.red ? s.default.red(s.default.bold(B)) : B;
      }
      function Z(B) {
        return d2 && s.default.gray ? s.default.gray(B) : B;
      }
      return k.slice(D, P).map(function(B, H) {
        var U2 = D + 1 + H, T = " " + (" " + U2).slice(-$2) + " | ";
        if (U2 === _.line) {
          var L = Z(T.replace(/\d/g, " ")) + B.slice(0, _.column - 1).replace(/[^\t]/g, " ");
          return G(">") + Z(T) + B + `
 ` + L + G("^");
        }
        return " " + Z(T) + B;
      }).join(`
`);
    }, y2.toString = function() {
      var d2 = this.showSourceCode();
      return d2 && (d2 = `

` + d2 + `
`), this.name + ": " + this.message + d2;
    }, v2;
  }(h(Error)), u = i;
  r.default = u, n.exports = r.default;
} }), hf = R({ "node_modules/postcss/lib/previous-map.js"(r, n) {
  I(), n.exports = class {
  };
} }), yr = R({ "node_modules/postcss/lib/input.js"(r, n) {
  I(), r.__esModule = true, r.default = void 0;
  var s = p(lf()), c = p(Yo()), o = p(hf());
  function p(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function f(e, a) {
    for (var i = 0; i < a.length; i++) {
      var u = a[i];
      u.enumerable = u.enumerable || false, u.configurable = true, "value" in u && (u.writable = true), Object.defineProperty(e, u.key, u);
    }
  }
  function h(e, a, i) {
    return a && f(e.prototype, a), i && f(e, i), e;
  }
  var g2 = 0, l = function() {
    function e(i, u) {
      if (u === void 0 && (u = {}), i === null || typeof i > "u" || typeof i == "object" && !i.toString)
        throw new Error("PostCSS received " + i + " instead of CSS string");
      this.css = i.toString(), this.css[0] === "\uFEFF" || this.css[0] === "￾" ? (this.hasBOM = true, this.css = this.css.slice(1)) : this.hasBOM = false, u.from && (/^\w+:\/\//.test(u.from) || s.default.isAbsolute(u.from) ? this.file = u.from : this.file = s.default.resolve(u.from));
      var m = new o.default(this.css, u);
      if (m.text) {
        this.map = m;
        var v2 = m.consumer().file;
        !this.file && v2 && (this.file = this.mapResolve(v2));
      }
      this.file || (g2 += 1, this.id = "<input css " + g2 + ">"), this.map && (this.map.file = this.from);
    }
    var a = e.prototype;
    return a.error = function(u, m, v2, y2) {
      y2 === void 0 && (y2 = {});
      var w, d2 = this.origin(m, v2);
      return d2 ? w = new c.default(u, d2.line, d2.column, d2.source, d2.file, y2.plugin) : w = new c.default(u, m, v2, this.css, this.file, y2.plugin), w.input = { line: m, column: v2, source: this.css }, this.file && (w.input.file = this.file), w;
    }, a.origin = function(u, m) {
      if (!this.map)
        return false;
      var v2 = this.map.consumer(), y2 = v2.originalPositionFor({ line: u, column: m });
      if (!y2.source)
        return false;
      var w = { file: this.mapResolve(y2.source), line: y2.line, column: y2.column }, d2 = v2.sourceContentFor(y2.source);
      return d2 && (w.source = d2), w;
    }, a.mapResolve = function(u) {
      return /^\w+:\/\//.test(u) ? u : s.default.resolve(this.map.consumer().sourceRoot || ".", u);
    }, h(e, [{ key: "from", get: function() {
      return this.file || this.id;
    } }]), e;
  }(), t = l;
  r.default = t, n.exports = r.default;
} }), wr = R({ "node_modules/postcss/lib/stringifier.js"(r, n) {
  I(), r.__esModule = true, r.default = void 0;
  var s = { colon: ": ", indent: "    ", beforeDecl: `
`, beforeRule: `
`, beforeOpen: " ", beforeClose: `
`, beforeComment: `
`, after: `
`, emptyBody: "", commentLeft: " ", commentRight: " ", semicolon: false };
  function c(f) {
    return f[0].toUpperCase() + f.slice(1);
  }
  var o = function() {
    function f(g2) {
      this.builder = g2;
    }
    var h = f.prototype;
    return h.stringify = function(l, t) {
      this[l.type](l, t);
    }, h.root = function(l) {
      this.body(l), l.raws.after && this.builder(l.raws.after);
    }, h.comment = function(l) {
      var t = this.raw(l, "left", "commentLeft"), e = this.raw(l, "right", "commentRight");
      this.builder("/*" + t + l.text + e + "*/", l);
    }, h.decl = function(l, t) {
      var e = this.raw(l, "between", "colon"), a = l.prop + e + this.rawValue(l, "value");
      l.important && (a += l.raws.important || " !important"), t && (a += ";"), this.builder(a, l);
    }, h.rule = function(l) {
      this.block(l, this.rawValue(l, "selector")), l.raws.ownSemicolon && this.builder(l.raws.ownSemicolon, l, "end");
    }, h.atrule = function(l, t) {
      var e = "@" + l.name, a = l.params ? this.rawValue(l, "params") : "";
      if (typeof l.raws.afterName < "u" ? e += l.raws.afterName : a && (e += " "), l.nodes)
        this.block(l, e + a);
      else {
        var i = (l.raws.between || "") + (t ? ";" : "");
        this.builder(e + a + i, l);
      }
    }, h.body = function(l) {
      for (var t = l.nodes.length - 1; t > 0 && l.nodes[t].type === "comment"; )
        t -= 1;
      for (var e = this.raw(l, "semicolon"), a = 0; a < l.nodes.length; a++) {
        var i = l.nodes[a], u = this.raw(i, "before");
        u && this.builder(u), this.stringify(i, t !== a || e);
      }
    }, h.block = function(l, t) {
      var e = this.raw(l, "between", "beforeOpen");
      this.builder(t + e + "{", l, "start");
      var a;
      l.nodes && l.nodes.length ? (this.body(l), a = this.raw(l, "after")) : a = this.raw(l, "after", "emptyBody"), a && this.builder(a), this.builder("}", l, "end");
    }, h.raw = function(l, t, e) {
      var a;
      if (e || (e = t), t && (a = l.raws[t], typeof a < "u"))
        return a;
      var i = l.parent;
      if (e === "before" && (!i || i.type === "root" && i.first === l))
        return "";
      if (!i)
        return s[e];
      var u = l.root();
      if (u.rawCache || (u.rawCache = {}), typeof u.rawCache[e] < "u")
        return u.rawCache[e];
      if (e === "before" || e === "after")
        return this.beforeAfter(l, e);
      var m = "raw" + c(e);
      return this[m] ? a = this[m](u, l) : u.walk(function(v2) {
        if (a = v2.raws[t], typeof a < "u")
          return false;
      }), typeof a > "u" && (a = s[e]), u.rawCache[e] = a, a;
    }, h.rawSemicolon = function(l) {
      var t;
      return l.walk(function(e) {
        if (e.nodes && e.nodes.length && e.last.type === "decl" && (t = e.raws.semicolon, typeof t < "u"))
          return false;
      }), t;
    }, h.rawEmptyBody = function(l) {
      var t;
      return l.walk(function(e) {
        if (e.nodes && e.nodes.length === 0 && (t = e.raws.after, typeof t < "u"))
          return false;
      }), t;
    }, h.rawIndent = function(l) {
      if (l.raws.indent)
        return l.raws.indent;
      var t;
      return l.walk(function(e) {
        var a = e.parent;
        if (a && a !== l && a.parent && a.parent === l && typeof e.raws.before < "u") {
          var i = e.raws.before.split(`
`);
          return t = i[i.length - 1], t = t.replace(/[^\s]/g, ""), false;
        }
      }), t;
    }, h.rawBeforeComment = function(l, t) {
      var e;
      return l.walkComments(function(a) {
        if (typeof a.raws.before < "u")
          return e = a.raws.before, e.indexOf(`
`) !== -1 && (e = e.replace(/[^\n]+$/, "")), false;
      }), typeof e > "u" ? e = this.raw(t, null, "beforeDecl") : e && (e = e.replace(/[^\s]/g, "")), e;
    }, h.rawBeforeDecl = function(l, t) {
      var e;
      return l.walkDecls(function(a) {
        if (typeof a.raws.before < "u")
          return e = a.raws.before, e.indexOf(`
`) !== -1 && (e = e.replace(/[^\n]+$/, "")), false;
      }), typeof e > "u" ? e = this.raw(t, null, "beforeRule") : e && (e = e.replace(/[^\s]/g, "")), e;
    }, h.rawBeforeRule = function(l) {
      var t;
      return l.walk(function(e) {
        if (e.nodes && (e.parent !== l || l.first !== e) && typeof e.raws.before < "u")
          return t = e.raws.before, t.indexOf(`
`) !== -1 && (t = t.replace(/[^\n]+$/, "")), false;
      }), t && (t = t.replace(/[^\s]/g, "")), t;
    }, h.rawBeforeClose = function(l) {
      var t;
      return l.walk(function(e) {
        if (e.nodes && e.nodes.length > 0 && typeof e.raws.after < "u")
          return t = e.raws.after, t.indexOf(`
`) !== -1 && (t = t.replace(/[^\n]+$/, "")), false;
      }), t && (t = t.replace(/[^\s]/g, "")), t;
    }, h.rawBeforeOpen = function(l) {
      var t;
      return l.walk(function(e) {
        if (e.type !== "decl" && (t = e.raws.between, typeof t < "u"))
          return false;
      }), t;
    }, h.rawColon = function(l) {
      var t;
      return l.walkDecls(function(e) {
        if (typeof e.raws.between < "u")
          return t = e.raws.between.replace(/[^\s:]/g, ""), false;
      }), t;
    }, h.beforeAfter = function(l, t) {
      var e;
      l.type === "decl" ? e = this.raw(l, null, "beforeDecl") : l.type === "comment" ? e = this.raw(l, null, "beforeComment") : t === "before" ? e = this.raw(l, null, "beforeRule") : e = this.raw(l, null, "beforeClose");
      for (var a = l.parent, i = 0; a && a.type !== "root"; )
        i += 1, a = a.parent;
      if (e.indexOf(`
`) !== -1) {
        var u = this.raw(l, null, "indent");
        if (u.length)
          for (var m = 0; m < i; m++)
            e += u;
      }
      return e;
    }, h.rawValue = function(l, t) {
      var e = l[t], a = l.raws[t];
      return a && a.value === e ? a.raw : e;
    }, f;
  }(), p = o;
  r.default = p, n.exports = r.default;
} }), Xo = R({ "node_modules/postcss/lib/stringify.js"(r, n) {
  I(), r.__esModule = true, r.default = void 0;
  var s = c(wr());
  function c(f) {
    return f && f.__esModule ? f : { default: f };
  }
  function o(f, h) {
    var g2 = new s.default(h);
    g2.stringify(f);
  }
  var p = o;
  r.default = p, n.exports = r.default;
} }), Rt = R({ "node_modules/postcss/lib/node.js"(r, n) {
  I(), r.__esModule = true, r.default = void 0;
  var s = p(Yo()), c = p(wr()), o = p(Xo());
  function p(l) {
    return l && l.__esModule ? l : { default: l };
  }
  function f(l, t) {
    var e = new l.constructor();
    for (var a in l)
      if (l.hasOwnProperty(a)) {
        var i = l[a], u = typeof i;
        a === "parent" && u === "object" ? t && (e[a] = t) : a === "source" ? e[a] = i : i instanceof Array ? e[a] = i.map(function(m) {
          return f(m, e);
        }) : (u === "object" && i !== null && (i = f(i)), e[a] = i);
      }
    return e;
  }
  var h = function() {
    function l(e) {
      e === void 0 && (e = {}), this.raws = {};
      for (var a in e)
        this[a] = e[a];
    }
    var t = l.prototype;
    return t.error = function(a, i) {
      if (i === void 0 && (i = {}), this.source) {
        var u = this.positionBy(i);
        return this.source.input.error(a, u.line, u.column, i);
      }
      return new s.default(a);
    }, t.warn = function(a, i, u) {
      var m = { node: this };
      for (var v2 in u)
        m[v2] = u[v2];
      return a.warn(i, m);
    }, t.remove = function() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }, t.toString = function(a) {
      a === void 0 && (a = o.default), a.stringify && (a = a.stringify);
      var i = "";
      return a(this, function(u) {
        i += u;
      }), i;
    }, t.clone = function(a) {
      a === void 0 && (a = {});
      var i = f(this);
      for (var u in a)
        i[u] = a[u];
      return i;
    }, t.cloneBefore = function(a) {
      a === void 0 && (a = {});
      var i = this.clone(a);
      return this.parent.insertBefore(this, i), i;
    }, t.cloneAfter = function(a) {
      a === void 0 && (a = {});
      var i = this.clone(a);
      return this.parent.insertAfter(this, i), i;
    }, t.replaceWith = function() {
      if (this.parent) {
        for (var a = arguments.length, i = new Array(a), u = 0; u < a; u++)
          i[u] = arguments[u];
        for (var m = 0, v2 = i; m < v2.length; m++) {
          var y2 = v2[m];
          this.parent.insertBefore(this, y2);
        }
        this.remove();
      }
      return this;
    }, t.next = function() {
      if (this.parent) {
        var a = this.parent.index(this);
        return this.parent.nodes[a + 1];
      }
    }, t.prev = function() {
      if (this.parent) {
        var a = this.parent.index(this);
        return this.parent.nodes[a - 1];
      }
    }, t.before = function(a) {
      return this.parent.insertBefore(this, a), this;
    }, t.after = function(a) {
      return this.parent.insertAfter(this, a), this;
    }, t.toJSON = function() {
      var a = {};
      for (var i in this)
        if (this.hasOwnProperty(i) && i !== "parent") {
          var u = this[i];
          u instanceof Array ? a[i] = u.map(function(m) {
            return typeof m == "object" && m.toJSON ? m.toJSON() : m;
          }) : typeof u == "object" && u.toJSON ? a[i] = u.toJSON() : a[i] = u;
        }
      return a;
    }, t.raw = function(a, i) {
      var u = new c.default();
      return u.raw(this, a, i);
    }, t.root = function() {
      for (var a = this; a.parent; )
        a = a.parent;
      return a;
    }, t.cleanRaws = function(a) {
      delete this.raws.before, delete this.raws.after, a || delete this.raws.between;
    }, t.positionInside = function(a) {
      for (var i = this.toString(), u = this.source.start.column, m = this.source.start.line, v2 = 0; v2 < a; v2++)
        i[v2] === `
` ? (u = 1, m += 1) : u += 1;
      return { line: m, column: u };
    }, t.positionBy = function(a) {
      var i = this.source.start;
      if (a.index)
        i = this.positionInside(a.index);
      else if (a.word) {
        var u = this.toString().indexOf(a.word);
        u !== -1 && (i = this.positionInside(u));
      }
      return i;
    }, l;
  }(), g2 = h;
  r.default = g2, n.exports = r.default;
} }), _r = R({ "node_modules/postcss/lib/comment.js"(r, n) {
  I(), r.__esModule = true, r.default = void 0;
  var s = c(Rt());
  function c(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function o(h, g2) {
    h.prototype = Object.create(g2.prototype), h.prototype.constructor = h, h.__proto__ = g2;
  }
  var p = function(h) {
    o(g2, h);
    function g2(l) {
      var t;
      return t = h.call(this, l) || this, t.type = "comment", t;
    }
    return g2;
  }(s.default), f = p;
  r.default = f, n.exports = r.default;
} }), Zo = R({ "node_modules/postcss/lib/declaration.js"(r, n) {
  I(), r.__esModule = true, r.default = void 0;
  var s = c(Rt());
  function c(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function o(h, g2) {
    h.prototype = Object.create(g2.prototype), h.prototype.constructor = h, h.__proto__ = g2;
  }
  var p = function(h) {
    o(g2, h);
    function g2(l) {
      var t;
      return t = h.call(this, l) || this, t.type = "decl", t;
    }
    return g2;
  }(s.default), f = p;
  r.default = f, n.exports = r.default;
} }), Ct = R({ "node_modules/postcss/lib/tokenize.js"(r, n) {
  I(), r.__esModule = true, r.default = $2;
  var s = "'".charCodeAt(0), c = '"'.charCodeAt(0), o = "\\".charCodeAt(0), p = "/".charCodeAt(0), f = `
`.charCodeAt(0), h = " ".charCodeAt(0), g2 = "\f".charCodeAt(0), l = "	".charCodeAt(0), t = "\r".charCodeAt(0), e = "[".charCodeAt(0), a = "]".charCodeAt(0), i = "(".charCodeAt(0), u = ")".charCodeAt(0), m = "{".charCodeAt(0), v2 = "}".charCodeAt(0), y2 = ";".charCodeAt(0), w = "*".charCodeAt(0), d2 = ":".charCodeAt(0), _ = "@".charCodeAt(0), O = /[ \n\t\r\f{}()'"\\;/[\]#]/g, k = /[ \n\t\r\f(){}:;@!'"\\\][#]|\/(?=\*)/g, D = /.[\\/("'\n]/, P = /[a-f0-9]/i;
  function $2(G, Z) {
    Z === void 0 && (Z = {});
    var B = G.css.valueOf(), H = Z.ignoreErrors, U2, T, L, j, N2, b, Y, J, W, X, C, Q, M2, E, x = B.length, S = -1, z = 1, A = 0, q = [], V = [];
    function F() {
      return A;
    }
    function ee2(re) {
      throw G.error("Unclosed " + re, z, A - S);
    }
    function te2() {
      return V.length === 0 && A >= x;
    }
    function ue2(re) {
      if (V.length)
        return V.pop();
      if (!(A >= x)) {
        var ne2 = re ? re.ignoreUnclosed : false;
        switch (U2 = B.charCodeAt(A), (U2 === f || U2 === g2 || U2 === t && B.charCodeAt(A + 1) !== f) && (S = A, z += 1), U2) {
          case f:
          case h:
          case l:
          case t:
          case g2:
            T = A;
            do
              T += 1, U2 = B.charCodeAt(T), U2 === f && (S = T, z += 1);
            while (U2 === h || U2 === f || U2 === l || U2 === t || U2 === g2);
            E = ["space", B.slice(A, T)], A = T - 1;
            break;
          case e:
          case a:
          case m:
          case v2:
          case d2:
          case y2:
          case u:
            var oe = String.fromCharCode(U2);
            E = [oe, oe, z, A - S];
            break;
          case i:
            if (Q = q.length ? q.pop()[1] : "", M2 = B.charCodeAt(A + 1), Q === "url" && M2 !== s && M2 !== c && M2 !== h && M2 !== f && M2 !== l && M2 !== g2 && M2 !== t) {
              T = A;
              do {
                if (X = false, T = B.indexOf(")", T + 1), T === -1)
                  if (H || ne2) {
                    T = A;
                    break;
                  } else
                    ee2("bracket");
                for (C = T; B.charCodeAt(C - 1) === o; )
                  C -= 1, X = !X;
              } while (X);
              E = ["brackets", B.slice(A, T + 1), z, A - S, z, T - S], A = T;
            } else
              T = B.indexOf(")", A + 1), b = B.slice(A, T + 1), T === -1 || D.test(b) ? E = ["(", "(", z, A - S] : (E = ["brackets", b, z, A - S, z, T - S], A = T);
            break;
          case s:
          case c:
            L = U2 === s ? "'" : '"', T = A;
            do {
              if (X = false, T = B.indexOf(L, T + 1), T === -1)
                if (H || ne2) {
                  T = A + 1;
                  break;
                } else
                  ee2("string");
              for (C = T; B.charCodeAt(C - 1) === o; )
                C -= 1, X = !X;
            } while (X);
            b = B.slice(A, T + 1), j = b.split(`
`), N2 = j.length - 1, N2 > 0 ? (J = z + N2, W = T - j[N2].length) : (J = z, W = S), E = ["string", B.slice(A, T + 1), z, A - S, J, T - W], S = W, z = J, A = T;
            break;
          case _:
            O.lastIndex = A + 1, O.test(B), O.lastIndex === 0 ? T = B.length - 1 : T = O.lastIndex - 2, E = ["at-word", B.slice(A, T + 1), z, A - S, z, T - S], A = T;
            break;
          case o:
            for (T = A, Y = true; B.charCodeAt(T + 1) === o; )
              T += 1, Y = !Y;
            if (U2 = B.charCodeAt(T + 1), Y && U2 !== p && U2 !== h && U2 !== f && U2 !== l && U2 !== t && U2 !== g2 && (T += 1, P.test(B.charAt(T)))) {
              for (; P.test(B.charAt(T + 1)); )
                T += 1;
              B.charCodeAt(T + 1) === h && (T += 1);
            }
            E = ["word", B.slice(A, T + 1), z, A - S, z, T - S], A = T;
            break;
          default:
            U2 === p && B.charCodeAt(A + 1) === w ? (T = B.indexOf("*/", A + 2) + 1, T === 0 && (H || ne2 ? T = B.length : ee2("comment")), b = B.slice(A, T + 1), j = b.split(`
`), N2 = j.length - 1, N2 > 0 ? (J = z + N2, W = T - j[N2].length) : (J = z, W = S), E = ["comment", b, z, A - S, J, T - W], S = W, z = J, A = T) : (k.lastIndex = A + 1, k.test(B), k.lastIndex === 0 ? T = B.length - 1 : T = k.lastIndex - 2, E = ["word", B.slice(A, T + 1), z, A - S, z, T - S], q.push(E), A = T);
            break;
        }
        return A++, E;
      }
    }
    function le2(re) {
      V.push(re);
    }
    return { back: le2, nextToken: ue2, endOfFile: te2, position: F };
  }
  n.exports = r.default;
} }), ea = R({ "node_modules/postcss/lib/parse.js"(r, n) {
  I(), r.__esModule = true, r.default = void 0;
  var s = o(Nt()), c = o(yr());
  function o(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function p(h, g2) {
    var l = new c.default(h, g2), t = new s.default(l);
    try {
      t.parse();
    } catch (e) {
      throw e;
    }
    return t.root;
  }
  var f = p;
  r.default = f, n.exports = r.default;
} }), df = R({ "node_modules/postcss/lib/list.js"(r, n) {
  I(), r.__esModule = true, r.default = void 0;
  var s = { split: function(p, f, h) {
    for (var g2 = [], l = "", t = false, e = 0, a = false, i = false, u = 0; u < p.length; u++) {
      var m = p[u];
      a ? i ? i = false : m === "\\" ? i = true : m === a && (a = false) : m === '"' || m === "'" ? a = m : m === "(" ? e += 1 : m === ")" ? e > 0 && (e -= 1) : e === 0 && f.indexOf(m) !== -1 && (t = true), t ? (l !== "" && g2.push(l.trim()), l = "", t = false) : l += m;
    }
    return (h || l !== "") && g2.push(l.trim()), g2;
  }, space: function(p) {
    var f = [" ", `
`, "	"];
    return s.split(p, f);
  }, comma: function(p) {
    return s.split(p, [","], true);
  } }, c = s;
  r.default = c, n.exports = r.default;
} }), ra = R({ "node_modules/postcss/lib/rule.js"(r, n) {
  I(), r.__esModule = true, r.default = void 0;
  var s = o(br()), c = o(df());
  function o(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function p(t, e) {
    for (var a = 0; a < e.length; a++) {
      var i = e[a];
      i.enumerable = i.enumerable || false, i.configurable = true, "value" in i && (i.writable = true), Object.defineProperty(t, i.key, i);
    }
  }
  function f(t, e, a) {
    return e && p(t.prototype, e), a && p(t, a), t;
  }
  function h(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
  }
  var g2 = function(t) {
    h(e, t);
    function e(a) {
      var i;
      return i = t.call(this, a) || this, i.type = "rule", i.nodes || (i.nodes = []), i;
    }
    return f(e, [{ key: "selectors", get: function() {
      return c.default.comma(this.selector);
    }, set: function(i) {
      var u = this.selector ? this.selector.match(/,\s*/) : null, m = u ? u[0] : "," + this.raw("between", "beforeOpen");
      this.selector = i.join(m);
    } }]), e;
  }(s.default), l = g2;
  r.default = l, n.exports = r.default;
} }), br = R({ "node_modules/postcss/lib/container.js"(r, n) {
  I(), r.__esModule = true, r.default = void 0;
  var s = p(Zo()), c = p(_r()), o = p(Rt());
  function p(m) {
    return m && m.__esModule ? m : { default: m };
  }
  function f(m, v2) {
    var y2;
    if (typeof Symbol > "u" || m[Symbol.iterator] == null) {
      if (Array.isArray(m) || (y2 = h(m)) || v2 && m && typeof m.length == "number") {
        y2 && (m = y2);
        var w = 0;
        return function() {
          return w >= m.length ? { done: true } : { done: false, value: m[w++] };
        };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    return y2 = m[Symbol.iterator](), y2.next.bind(y2);
  }
  function h(m, v2) {
    if (m) {
      if (typeof m == "string")
        return g2(m, v2);
      var y2 = Object.prototype.toString.call(m).slice(8, -1);
      if (y2 === "Object" && m.constructor && (y2 = m.constructor.name), y2 === "Map" || y2 === "Set")
        return Array.from(m);
      if (y2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(y2))
        return g2(m, v2);
    }
  }
  function g2(m, v2) {
    (v2 == null || v2 > m.length) && (v2 = m.length);
    for (var y2 = 0, w = new Array(v2); y2 < v2; y2++)
      w[y2] = m[y2];
    return w;
  }
  function l(m, v2) {
    for (var y2 = 0; y2 < v2.length; y2++) {
      var w = v2[y2];
      w.enumerable = w.enumerable || false, w.configurable = true, "value" in w && (w.writable = true), Object.defineProperty(m, w.key, w);
    }
  }
  function t(m, v2, y2) {
    return v2 && l(m.prototype, v2), y2 && l(m, y2), m;
  }
  function e(m, v2) {
    m.prototype = Object.create(v2.prototype), m.prototype.constructor = m, m.__proto__ = v2;
  }
  function a(m) {
    return m.map(function(v2) {
      return v2.nodes && (v2.nodes = a(v2.nodes)), delete v2.source, v2;
    });
  }
  var i = function(m) {
    e(v2, m);
    function v2() {
      return m.apply(this, arguments) || this;
    }
    var y2 = v2.prototype;
    return y2.push = function(d2) {
      return d2.parent = this, this.nodes.push(d2), this;
    }, y2.each = function(d2) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      var _ = this.lastEach;
      if (this.indexes[_] = 0, !!this.nodes) {
        for (var O, k; this.indexes[_] < this.nodes.length && (O = this.indexes[_], k = d2(this.nodes[O], O), k !== false); )
          this.indexes[_] += 1;
        return delete this.indexes[_], k;
      }
    }, y2.walk = function(d2) {
      return this.each(function(_, O) {
        var k;
        try {
          k = d2(_, O);
        } catch (P) {
          if (P.postcssNode = _, P.stack && _.source && /\n\s{4}at /.test(P.stack)) {
            var D = _.source;
            P.stack = P.stack.replace(/\n\s{4}at /, "$&" + D.input.from + ":" + D.start.line + ":" + D.start.column + "$&");
          }
          throw P;
        }
        return k !== false && _.walk && (k = _.walk(d2)), k;
      });
    }, y2.walkDecls = function(d2, _) {
      return _ ? d2 instanceof RegExp ? this.walk(function(O, k) {
        if (O.type === "decl" && d2.test(O.prop))
          return _(O, k);
      }) : this.walk(function(O, k) {
        if (O.type === "decl" && O.prop === d2)
          return _(O, k);
      }) : (_ = d2, this.walk(function(O, k) {
        if (O.type === "decl")
          return _(O, k);
      }));
    }, y2.walkRules = function(d2, _) {
      return _ ? d2 instanceof RegExp ? this.walk(function(O, k) {
        if (O.type === "rule" && d2.test(O.selector))
          return _(O, k);
      }) : this.walk(function(O, k) {
        if (O.type === "rule" && O.selector === d2)
          return _(O, k);
      }) : (_ = d2, this.walk(function(O, k) {
        if (O.type === "rule")
          return _(O, k);
      }));
    }, y2.walkAtRules = function(d2, _) {
      return _ ? d2 instanceof RegExp ? this.walk(function(O, k) {
        if (O.type === "atrule" && d2.test(O.name))
          return _(O, k);
      }) : this.walk(function(O, k) {
        if (O.type === "atrule" && O.name === d2)
          return _(O, k);
      }) : (_ = d2, this.walk(function(O, k) {
        if (O.type === "atrule")
          return _(O, k);
      }));
    }, y2.walkComments = function(d2) {
      return this.walk(function(_, O) {
        if (_.type === "comment")
          return d2(_, O);
      });
    }, y2.append = function() {
      for (var d2 = arguments.length, _ = new Array(d2), O = 0; O < d2; O++)
        _[O] = arguments[O];
      for (var k = 0, D = _; k < D.length; k++)
        for (var P = D[k], $2 = this.normalize(P, this.last), G = f($2), Z; !(Z = G()).done; ) {
          var B = Z.value;
          this.nodes.push(B);
        }
      return this;
    }, y2.prepend = function() {
      for (var d2 = arguments.length, _ = new Array(d2), O = 0; O < d2; O++)
        _[O] = arguments[O];
      _ = _.reverse();
      for (var k = f(_), D; !(D = k()).done; ) {
        for (var P = D.value, $2 = this.normalize(P, this.first, "prepend").reverse(), G = f($2), Z; !(Z = G()).done; ) {
          var B = Z.value;
          this.nodes.unshift(B);
        }
        for (var H in this.indexes)
          this.indexes[H] = this.indexes[H] + $2.length;
      }
      return this;
    }, y2.cleanRaws = function(d2) {
      if (m.prototype.cleanRaws.call(this, d2), this.nodes)
        for (var _ = f(this.nodes), O; !(O = _()).done; ) {
          var k = O.value;
          k.cleanRaws(d2);
        }
    }, y2.insertBefore = function(d2, _) {
      d2 = this.index(d2);
      for (var O = d2 === 0 ? "prepend" : false, k = this.normalize(_, this.nodes[d2], O).reverse(), D = f(k), P; !(P = D()).done; ) {
        var $2 = P.value;
        this.nodes.splice(d2, 0, $2);
      }
      var G;
      for (var Z in this.indexes)
        G = this.indexes[Z], d2 <= G && (this.indexes[Z] = G + k.length);
      return this;
    }, y2.insertAfter = function(d2, _) {
      d2 = this.index(d2);
      for (var O = this.normalize(_, this.nodes[d2]).reverse(), k = f(O), D; !(D = k()).done; ) {
        var P = D.value;
        this.nodes.splice(d2 + 1, 0, P);
      }
      var $2;
      for (var G in this.indexes)
        $2 = this.indexes[G], d2 < $2 && (this.indexes[G] = $2 + O.length);
      return this;
    }, y2.removeChild = function(d2) {
      d2 = this.index(d2), this.nodes[d2].parent = void 0, this.nodes.splice(d2, 1);
      var _;
      for (var O in this.indexes)
        _ = this.indexes[O], _ >= d2 && (this.indexes[O] = _ - 1);
      return this;
    }, y2.removeAll = function() {
      for (var d2 = f(this.nodes), _; !(_ = d2()).done; ) {
        var O = _.value;
        O.parent = void 0;
      }
      return this.nodes = [], this;
    }, y2.replaceValues = function(d2, _, O) {
      return O || (O = _, _ = {}), this.walkDecls(function(k) {
        _.props && _.props.indexOf(k.prop) === -1 || _.fast && k.value.indexOf(_.fast) === -1 || (k.value = k.value.replace(d2, O));
      }), this;
    }, y2.every = function(d2) {
      return this.nodes.every(d2);
    }, y2.some = function(d2) {
      return this.nodes.some(d2);
    }, y2.index = function(d2) {
      return typeof d2 == "number" ? d2 : this.nodes.indexOf(d2);
    }, y2.normalize = function(d2, _) {
      var O = this;
      if (typeof d2 == "string") {
        var k = ea();
        d2 = a(k(d2).nodes);
      } else if (Array.isArray(d2)) {
        d2 = d2.slice(0);
        for (var D = f(d2), P; !(P = D()).done; ) {
          var $2 = P.value;
          $2.parent && $2.parent.removeChild($2, "ignore");
        }
      } else if (d2.type === "root") {
        d2 = d2.nodes.slice(0);
        for (var G = f(d2), Z; !(Z = G()).done; ) {
          var B = Z.value;
          B.parent && B.parent.removeChild(B, "ignore");
        }
      } else if (d2.type)
        d2 = [d2];
      else if (d2.prop) {
        if (typeof d2.value > "u")
          throw new Error("Value field is missed in node creation");
        typeof d2.value != "string" && (d2.value = String(d2.value)), d2 = [new s.default(d2)];
      } else if (d2.selector) {
        var H = ra();
        d2 = [new H(d2)];
      } else if (d2.name) {
        var U2 = ta();
        d2 = [new U2(d2)];
      } else if (d2.text)
        d2 = [new c.default(d2)];
      else
        throw new Error("Unknown node type in node creation");
      var T = d2.map(function(L) {
        return L.parent && L.parent.removeChild(L), typeof L.raws.before > "u" && _ && typeof _.raws.before < "u" && (L.raws.before = _.raws.before.replace(/[^\s]/g, "")), L.parent = O, L;
      });
      return T;
    }, t(v2, [{ key: "first", get: function() {
      if (this.nodes)
        return this.nodes[0];
    } }, { key: "last", get: function() {
      if (this.nodes)
        return this.nodes[this.nodes.length - 1];
    } }]), v2;
  }(o.default), u = i;
  r.default = u, n.exports = r.default;
} }), ta = R({ "node_modules/postcss/lib/at-rule.js"(r, n) {
  I(), r.__esModule = true, r.default = void 0;
  var s = c(br());
  function c(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function o(h, g2) {
    h.prototype = Object.create(g2.prototype), h.prototype.constructor = h, h.__proto__ = g2;
  }
  var p = function(h) {
    o(g2, h);
    function g2(t) {
      var e;
      return e = h.call(this, t) || this, e.type = "atrule", e;
    }
    var l = g2.prototype;
    return l.append = function() {
      var e;
      this.nodes || (this.nodes = []);
      for (var a = arguments.length, i = new Array(a), u = 0; u < a; u++)
        i[u] = arguments[u];
      return (e = h.prototype.append).call.apply(e, [this].concat(i));
    }, l.prepend = function() {
      var e;
      this.nodes || (this.nodes = []);
      for (var a = arguments.length, i = new Array(a), u = 0; u < a; u++)
        i[u] = arguments[u];
      return (e = h.prototype.prepend).call.apply(e, [this].concat(i));
    }, g2;
  }(s.default), f = p;
  r.default = f, n.exports = r.default;
} }), vf = R({ "node_modules/postcss/lib/map-generator.js"(r, n) {
  I(), n.exports = class {
    generate() {
    }
  };
} }), mf = R({ "node_modules/postcss/lib/warn-once.js"(r, n) {
  I(), r.__esModule = true, r.default = c;
  var s = {};
  function c(o) {
    s[o] || (s[o] = true, typeof console < "u" && console.warn && console.warn(o));
  }
  n.exports = r.default;
} }), gf = R({ "node_modules/postcss/lib/warning.js"(r, n) {
  I(), r.__esModule = true, r.default = void 0;
  var s = function() {
    function o(f, h) {
      if (h === void 0 && (h = {}), this.type = "warning", this.text = f, h.node && h.node.source) {
        var g2 = h.node.positionBy(h);
        this.line = g2.line, this.column = g2.column;
      }
      for (var l in h)
        this[l] = h[l];
    }
    var p = o.prototype;
    return p.toString = function() {
      return this.node ? this.node.error(this.text, { plugin: this.plugin, index: this.index, word: this.word }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
    }, o;
  }(), c = s;
  r.default = c, n.exports = r.default;
} }), yf = R({ "node_modules/postcss/lib/result.js"(r, n) {
  I(), r.__esModule = true, r.default = void 0;
  var s = c(gf());
  function c(g2) {
    return g2 && g2.__esModule ? g2 : { default: g2 };
  }
  function o(g2, l) {
    for (var t = 0; t < l.length; t++) {
      var e = l[t];
      e.enumerable = e.enumerable || false, e.configurable = true, "value" in e && (e.writable = true), Object.defineProperty(g2, e.key, e);
    }
  }
  function p(g2, l, t) {
    return l && o(g2.prototype, l), t && o(g2, t), g2;
  }
  var f = function() {
    function g2(t, e, a) {
      this.processor = t, this.messages = [], this.root = e, this.opts = a, this.css = void 0, this.map = void 0;
    }
    var l = g2.prototype;
    return l.toString = function() {
      return this.css;
    }, l.warn = function(e, a) {
      a === void 0 && (a = {}), a.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (a.plugin = this.lastPlugin.postcssPlugin);
      var i = new s.default(e, a);
      return this.messages.push(i), i;
    }, l.warnings = function() {
      return this.messages.filter(function(e) {
        return e.type === "warning";
      });
    }, p(g2, [{ key: "content", get: function() {
      return this.css;
    } }]), g2;
  }(), h = f;
  r.default = h, n.exports = r.default;
} }), na = R({ "node_modules/postcss/lib/lazy-result.js"(r, n) {
  I(), r.__esModule = true, r.default = void 0;
  var s = h(vf()), c = h(Xo());
  h(mf());
  var p = h(yf()), f = h(ea());
  function h(v2) {
    return v2 && v2.__esModule ? v2 : { default: v2 };
  }
  function g2(v2, y2) {
    var w;
    if (typeof Symbol > "u" || v2[Symbol.iterator] == null) {
      if (Array.isArray(v2) || (w = l(v2)) || y2 && v2 && typeof v2.length == "number") {
        w && (v2 = w);
        var d2 = 0;
        return function() {
          return d2 >= v2.length ? { done: true } : { done: false, value: v2[d2++] };
        };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    return w = v2[Symbol.iterator](), w.next.bind(w);
  }
  function l(v2, y2) {
    if (v2) {
      if (typeof v2 == "string")
        return t(v2, y2);
      var w = Object.prototype.toString.call(v2).slice(8, -1);
      if (w === "Object" && v2.constructor && (w = v2.constructor.name), w === "Map" || w === "Set")
        return Array.from(v2);
      if (w === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(w))
        return t(v2, y2);
    }
  }
  function t(v2, y2) {
    (y2 == null || y2 > v2.length) && (y2 = v2.length);
    for (var w = 0, d2 = new Array(y2); w < y2; w++)
      d2[w] = v2[w];
    return d2;
  }
  function e(v2, y2) {
    for (var w = 0; w < y2.length; w++) {
      var d2 = y2[w];
      d2.enumerable = d2.enumerable || false, d2.configurable = true, "value" in d2 && (d2.writable = true), Object.defineProperty(v2, d2.key, d2);
    }
  }
  function a(v2, y2, w) {
    return y2 && e(v2.prototype, y2), w && e(v2, w), v2;
  }
  function i(v2) {
    return typeof v2 == "object" && typeof v2.then == "function";
  }
  var u = function() {
    function v2(w, d2, _) {
      this.stringified = false, this.processed = false;
      var O;
      if (typeof d2 == "object" && d2 !== null && d2.type === "root")
        O = d2;
      else if (d2 instanceof v2 || d2 instanceof p.default)
        O = d2.root, d2.map && (typeof _.map > "u" && (_.map = {}), _.map.inline || (_.map.inline = false), _.map.prev = d2.map);
      else {
        var k = f.default;
        _.syntax && (k = _.syntax.parse), _.parser && (k = _.parser), k.parse && (k = k.parse);
        try {
          O = k(d2, _);
        } catch (D) {
          this.error = D;
        }
      }
      this.result = new p.default(w, O, _);
    }
    var y2 = v2.prototype;
    return y2.warnings = function() {
      return this.sync().warnings();
    }, y2.toString = function() {
      return this.css;
    }, y2.then = function(d2, _) {
      return this.async().then(d2, _);
    }, y2.catch = function(d2) {
      return this.async().catch(d2);
    }, y2.finally = function(d2) {
      return this.async().then(d2, d2);
    }, y2.handleError = function(d2, _) {
      try {
        if (this.error = d2, d2.name === "CssSyntaxError" && !d2.plugin)
          d2.plugin = _.postcssPlugin, d2.setMessage();
        else if (_.postcssVersion && false)
          var O, k, D, P, $2;
      } catch (G) {
        console && console.error && console.error(G);
      }
    }, y2.asyncTick = function(d2, _) {
      var O = this;
      if (this.plugin >= this.processor.plugins.length)
        return this.processed = true, d2();
      try {
        var k = this.processor.plugins[this.plugin], D = this.run(k);
        this.plugin += 1, i(D) ? D.then(function() {
          O.asyncTick(d2, _);
        }).catch(function(P) {
          O.handleError(P, k), O.processed = true, _(P);
        }) : this.asyncTick(d2, _);
      } catch (P) {
        this.processed = true, _(P);
      }
    }, y2.async = function() {
      var d2 = this;
      return this.processed ? new Promise(function(_, O) {
        d2.error ? O(d2.error) : _(d2.stringify());
      }) : this.processing ? this.processing : (this.processing = new Promise(function(_, O) {
        if (d2.error)
          return O(d2.error);
        d2.plugin = 0, d2.asyncTick(_, O);
      }).then(function() {
        return d2.processed = true, d2.stringify();
      }), this.processing);
    }, y2.sync = function() {
      if (this.processed)
        return this.result;
      if (this.processed = true, this.processing)
        throw new Error("Use process(css).then(cb) to work with async plugins");
      if (this.error)
        throw this.error;
      for (var d2 = g2(this.result.processor.plugins), _; !(_ = d2()).done; ) {
        var O = _.value, k = this.run(O);
        if (i(k))
          throw new Error("Use process(css).then(cb) to work with async plugins");
      }
      return this.result;
    }, y2.run = function(d2) {
      this.result.lastPlugin = d2;
      try {
        return d2(this.result.root, this.result);
      } catch (_) {
        throw this.handleError(_, d2), _;
      }
    }, y2.stringify = function() {
      if (this.stringified)
        return this.result;
      this.stringified = true, this.sync();
      var d2 = this.result.opts, _ = c.default;
      d2.syntax && (_ = d2.syntax.stringify), d2.stringifier && (_ = d2.stringifier), _.stringify && (_ = _.stringify);
      var O = new s.default(_, this.result.root, this.result.opts), k = O.generate();
      return this.result.css = k[0], this.result.map = k[1], this.result;
    }, a(v2, [{ key: "processor", get: function() {
      return this.result.processor;
    } }, { key: "opts", get: function() {
      return this.result.opts;
    } }, { key: "css", get: function() {
      return this.stringify().css;
    } }, { key: "content", get: function() {
      return this.stringify().content;
    } }, { key: "map", get: function() {
      return this.stringify().map;
    } }, { key: "root", get: function() {
      return this.sync().root;
    } }, { key: "messages", get: function() {
      return this.sync().messages;
    } }]), v2;
  }(), m = u;
  r.default = m, n.exports = r.default;
} }), wf = R({ "node_modules/postcss/lib/processor.js"(r, n) {
  I(), r.__esModule = true, r.default = void 0;
  var s = c(na());
  function c(l) {
    return l && l.__esModule ? l : { default: l };
  }
  function o(l, t) {
    var e;
    if (typeof Symbol > "u" || l[Symbol.iterator] == null) {
      if (Array.isArray(l) || (e = p(l)) || t && l && typeof l.length == "number") {
        e && (l = e);
        var a = 0;
        return function() {
          return a >= l.length ? { done: true } : { done: false, value: l[a++] };
        };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    return e = l[Symbol.iterator](), e.next.bind(e);
  }
  function p(l, t) {
    if (l) {
      if (typeof l == "string")
        return f(l, t);
      var e = Object.prototype.toString.call(l).slice(8, -1);
      if (e === "Object" && l.constructor && (e = l.constructor.name), e === "Map" || e === "Set")
        return Array.from(l);
      if (e === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e))
        return f(l, t);
    }
  }
  function f(l, t) {
    (t == null || t > l.length) && (t = l.length);
    for (var e = 0, a = new Array(t); e < t; e++)
      a[e] = l[e];
    return a;
  }
  var h = function() {
    function l(e) {
      e === void 0 && (e = []), this.version = "7.0.39", this.plugins = this.normalize(e);
    }
    var t = l.prototype;
    return t.use = function(a) {
      return this.plugins = this.plugins.concat(this.normalize([a])), this;
    }, t.process = function(e) {
      function a(i) {
        return e.apply(this, arguments);
      }
      return a.toString = function() {
        return e.toString();
      }, a;
    }(function(e, a) {
      return a === void 0 && (a = {}), this.plugins.length === 0 && (a.parser, a.stringifier), new s.default(this, e, a);
    }), t.normalize = function(a) {
      for (var i = [], u = o(a), m; !(m = u()).done; ) {
        var v2 = m.value;
        if (v2.postcss === true) {
          var y2 = v2();
          throw new Error("PostCSS plugin " + y2.postcssPlugin + ` requires PostCSS 8.
Migration guide for end-users:
https://github.com/postcss/postcss/wiki/PostCSS-8-for-end-users`);
        }
        if (v2.postcss && (v2 = v2.postcss), typeof v2 == "object" && Array.isArray(v2.plugins))
          i = i.concat(v2.plugins);
        else if (typeof v2 == "function")
          i.push(v2);
        else if (!(typeof v2 == "object" && (v2.parse || v2.stringify)))
          throw typeof v2 == "object" && v2.postcssPlugin ? new Error("PostCSS plugin " + v2.postcssPlugin + ` requires PostCSS 8.
Migration guide for end-users:
https://github.com/postcss/postcss/wiki/PostCSS-8-for-end-users`) : new Error(v2 + " is not a PostCSS plugin");
      }
      return i;
    }, l;
  }(), g2 = h;
  r.default = g2, n.exports = r.default;
} }), _f = R({ "node_modules/postcss/lib/root.js"(r, n) {
  I(), r.__esModule = true, r.default = void 0;
  var s = c(br());
  function c(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function o(t, e) {
    var a;
    if (typeof Symbol > "u" || t[Symbol.iterator] == null) {
      if (Array.isArray(t) || (a = p(t)) || e && t && typeof t.length == "number") {
        a && (t = a);
        var i = 0;
        return function() {
          return i >= t.length ? { done: true } : { done: false, value: t[i++] };
        };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    return a = t[Symbol.iterator](), a.next.bind(a);
  }
  function p(t, e) {
    if (t) {
      if (typeof t == "string")
        return f(t, e);
      var a = Object.prototype.toString.call(t).slice(8, -1);
      if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set")
        return Array.from(t);
      if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a))
        return f(t, e);
    }
  }
  function f(t, e) {
    (e == null || e > t.length) && (e = t.length);
    for (var a = 0, i = new Array(e); a < e; a++)
      i[a] = t[a];
    return i;
  }
  function h(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
  }
  var g2 = function(t) {
    h(e, t);
    function e(i) {
      var u;
      return u = t.call(this, i) || this, u.type = "root", u.nodes || (u.nodes = []), u;
    }
    var a = e.prototype;
    return a.removeChild = function(u, m) {
      var v2 = this.index(u);
      return !m && v2 === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[v2].raws.before), t.prototype.removeChild.call(this, u);
    }, a.normalize = function(u, m, v2) {
      var y2 = t.prototype.normalize.call(this, u);
      if (m) {
        if (v2 === "prepend")
          this.nodes.length > 1 ? m.raws.before = this.nodes[1].raws.before : delete m.raws.before;
        else if (this.first !== m)
          for (var w = o(y2), d2; !(d2 = w()).done; ) {
            var _ = d2.value;
            _.raws.before = m.raws.before;
          }
      }
      return y2;
    }, a.toResult = function(u) {
      u === void 0 && (u = {});
      var m = na(), v2 = wf(), y2 = new m(new v2(), this, u);
      return y2.stringify();
    }, e;
  }(s.default), l = g2;
  r.default = l, n.exports = r.default;
} }), Nt = R({ "node_modules/postcss/lib/parser.js"(r, n) {
  I(), r.__esModule = true, r.default = void 0;
  var s = g2(Zo()), c = g2(Ct()), o = g2(_r()), p = g2(ta()), f = g2(_f()), h = g2(ra());
  function g2(t) {
    return t && t.__esModule ? t : { default: t };
  }
  var l = function() {
    function t(a) {
      this.input = a, this.root = new f.default(), this.current = this.root, this.spaces = "", this.semicolon = false, this.createTokenizer(), this.root.source = { input: a, start: { line: 1, column: 1 } };
    }
    var e = t.prototype;
    return e.createTokenizer = function() {
      this.tokenizer = (0, c.default)(this.input);
    }, e.parse = function() {
      for (var i; !this.tokenizer.endOfFile(); )
        switch (i = this.tokenizer.nextToken(), i[0]) {
          case "space":
            this.spaces += i[1];
            break;
          case ";":
            this.freeSemicolon(i);
            break;
          case "}":
            this.end(i);
            break;
          case "comment":
            this.comment(i);
            break;
          case "at-word":
            this.atrule(i);
            break;
          case "{":
            this.emptyRule(i);
            break;
          default:
            this.other(i);
            break;
        }
      this.endFile();
    }, e.comment = function(i) {
      var u = new o.default();
      this.init(u, i[2], i[3]), u.source.end = { line: i[4], column: i[5] };
      var m = i[1].slice(2, -2);
      if (/^\s*$/.test(m))
        u.text = "", u.raws.left = m, u.raws.right = "";
      else {
        var v2 = m.match(/^(\s*)([^]*[^\s])(\s*)$/);
        u.text = v2[2], u.raws.left = v2[1], u.raws.right = v2[3];
      }
    }, e.emptyRule = function(i) {
      var u = new h.default();
      this.init(u, i[2], i[3]), u.selector = "", u.raws.between = "", this.current = u;
    }, e.other = function(i) {
      for (var u = false, m = null, v2 = false, y2 = null, w = [], d2 = [], _ = i; _; ) {
        if (m = _[0], d2.push(_), m === "(" || m === "[")
          y2 || (y2 = _), w.push(m === "(" ? ")" : "]");
        else if (w.length === 0)
          if (m === ";")
            if (v2) {
              this.decl(d2);
              return;
            } else
              break;
          else if (m === "{") {
            this.rule(d2);
            return;
          } else if (m === "}") {
            this.tokenizer.back(d2.pop()), u = true;
            break;
          } else
            m === ":" && (v2 = true);
        else
          m === w[w.length - 1] && (w.pop(), w.length === 0 && (y2 = null));
        _ = this.tokenizer.nextToken();
      }
      if (this.tokenizer.endOfFile() && (u = true), w.length > 0 && this.unclosedBracket(y2), u && v2) {
        for (; d2.length && (_ = d2[d2.length - 1][0], !(_ !== "space" && _ !== "comment")); )
          this.tokenizer.back(d2.pop());
        this.decl(d2);
      } else
        this.unknownWord(d2);
    }, e.rule = function(i) {
      i.pop();
      var u = new h.default();
      this.init(u, i[0][2], i[0][3]), u.raws.between = this.spacesAndCommentsFromEnd(i), this.raw(u, "selector", i), this.current = u;
    }, e.decl = function(i) {
      var u = new s.default();
      this.init(u);
      var m = i[i.length - 1];
      for (m[0] === ";" && (this.semicolon = true, i.pop()), m[4] ? u.source.end = { line: m[4], column: m[5] } : u.source.end = { line: m[2], column: m[3] }; i[0][0] !== "word"; )
        i.length === 1 && this.unknownWord(i), u.raws.before += i.shift()[1];
      for (u.source.start = { line: i[0][2], column: i[0][3] }, u.prop = ""; i.length; ) {
        var v2 = i[0][0];
        if (v2 === ":" || v2 === "space" || v2 === "comment")
          break;
        u.prop += i.shift()[1];
      }
      u.raws.between = "";
      for (var y2; i.length; )
        if (y2 = i.shift(), y2[0] === ":") {
          u.raws.between += y2[1];
          break;
        } else
          y2[0] === "word" && /\w/.test(y2[1]) && this.unknownWord([y2]), u.raws.between += y2[1];
      (u.prop[0] === "_" || u.prop[0] === "*") && (u.raws.before += u.prop[0], u.prop = u.prop.slice(1)), u.raws.between += this.spacesAndCommentsFromStart(i), this.precheckMissedSemicolon(i);
      for (var w = i.length - 1; w > 0; w--) {
        if (y2 = i[w], y2[1].toLowerCase() === "!important") {
          u.important = true;
          var d2 = this.stringFrom(i, w);
          d2 = this.spacesFromEnd(i) + d2, d2 !== " !important" && (u.raws.important = d2);
          break;
        } else if (y2[1].toLowerCase() === "important") {
          for (var _ = i.slice(0), O = "", k = w; k > 0; k--) {
            var D = _[k][0];
            if (O.trim().indexOf("!") === 0 && D !== "space")
              break;
            O = _.pop()[1] + O;
          }
          O.trim().indexOf("!") === 0 && (u.important = true, u.raws.important = O, i = _);
        }
        if (y2[0] !== "space" && y2[0] !== "comment")
          break;
      }
      this.raw(u, "value", i), u.value.indexOf(":") !== -1 && this.checkMissedSemicolon(i);
    }, e.atrule = function(i) {
      var u = new p.default();
      u.name = i[1].slice(1), u.name === "" && this.unnamedAtrule(u, i), this.init(u, i[2], i[3]);
      for (var m, v2, y2 = false, w = false, d2 = []; !this.tokenizer.endOfFile(); ) {
        if (i = this.tokenizer.nextToken(), i[0] === ";") {
          u.source.end = { line: i[2], column: i[3] }, this.semicolon = true;
          break;
        } else if (i[0] === "{") {
          w = true;
          break;
        } else if (i[0] === "}") {
          if (d2.length > 0) {
            for (v2 = d2.length - 1, m = d2[v2]; m && m[0] === "space"; )
              m = d2[--v2];
            m && (u.source.end = { line: m[4], column: m[5] });
          }
          this.end(i);
          break;
        } else
          d2.push(i);
        if (this.tokenizer.endOfFile()) {
          y2 = true;
          break;
        }
      }
      u.raws.between = this.spacesAndCommentsFromEnd(d2), d2.length ? (u.raws.afterName = this.spacesAndCommentsFromStart(d2), this.raw(u, "params", d2), y2 && (i = d2[d2.length - 1], u.source.end = { line: i[4], column: i[5] }, this.spaces = u.raws.between, u.raws.between = "")) : (u.raws.afterName = "", u.params = ""), w && (u.nodes = [], this.current = u);
    }, e.end = function(i) {
      this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = false, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = { line: i[2], column: i[3] }, this.current = this.current.parent) : this.unexpectedClose(i);
    }, e.endFile = function() {
      this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces;
    }, e.freeSemicolon = function(i) {
      if (this.spaces += i[1], this.current.nodes) {
        var u = this.current.nodes[this.current.nodes.length - 1];
        u && u.type === "rule" && !u.raws.ownSemicolon && (u.raws.ownSemicolon = this.spaces, this.spaces = "");
      }
    }, e.init = function(i, u, m) {
      this.current.push(i), i.source = { start: { line: u, column: m }, input: this.input }, i.raws.before = this.spaces, this.spaces = "", i.type !== "comment" && (this.semicolon = false);
    }, e.raw = function(i, u, m) {
      for (var v2, y2, w = m.length, d2 = "", _ = true, O, k, D = /^([.|#])?([\w])+/i, P = 0; P < w; P += 1) {
        if (v2 = m[P], y2 = v2[0], y2 === "comment" && i.type === "rule") {
          k = m[P - 1], O = m[P + 1], k[0] !== "space" && O[0] !== "space" && D.test(k[1]) && D.test(O[1]) ? d2 += v2[1] : _ = false;
          continue;
        }
        y2 === "comment" || y2 === "space" && P === w - 1 ? _ = false : d2 += v2[1];
      }
      if (!_) {
        var $2 = m.reduce(function(G, Z) {
          return G + Z[1];
        }, "");
        i.raws[u] = { value: d2, raw: $2 };
      }
      i[u] = d2;
    }, e.spacesAndCommentsFromEnd = function(i) {
      for (var u, m = ""; i.length && (u = i[i.length - 1][0], !(u !== "space" && u !== "comment")); )
        m = i.pop()[1] + m;
      return m;
    }, e.spacesAndCommentsFromStart = function(i) {
      for (var u, m = ""; i.length && (u = i[0][0], !(u !== "space" && u !== "comment")); )
        m += i.shift()[1];
      return m;
    }, e.spacesFromEnd = function(i) {
      for (var u, m = ""; i.length && (u = i[i.length - 1][0], u === "space"); )
        m = i.pop()[1] + m;
      return m;
    }, e.stringFrom = function(i, u) {
      for (var m = "", v2 = u; v2 < i.length; v2++)
        m += i[v2][1];
      return i.splice(u, i.length - u), m;
    }, e.colon = function(i) {
      for (var u = 0, m, v2, y2, w = 0; w < i.length; w++) {
        if (m = i[w], v2 = m[0], v2 === "(" && (u += 1), v2 === ")" && (u -= 1), u === 0 && v2 === ":")
          if (!y2)
            this.doubleColon(m);
          else {
            if (y2[0] === "word" && y2[1] === "progid")
              continue;
            return w;
          }
        y2 = m;
      }
      return false;
    }, e.unclosedBracket = function(i) {
      throw this.input.error("Unclosed bracket", i[2], i[3]);
    }, e.unknownWord = function(i) {
      throw this.input.error("Unknown word", i[0][2], i[0][3]);
    }, e.unexpectedClose = function(i) {
      throw this.input.error("Unexpected }", i[2], i[3]);
    }, e.unclosedBlock = function() {
      var i = this.current.source.start;
      throw this.input.error("Unclosed block", i.line, i.column);
    }, e.doubleColon = function(i) {
      throw this.input.error("Double colon", i[2], i[3]);
    }, e.unnamedAtrule = function(i, u) {
      throw this.input.error("At-rule without name", u[2], u[3]);
    }, e.precheckMissedSemicolon = function() {
    }, e.checkMissedSemicolon = function(i) {
      var u = this.colon(i);
      if (u !== false) {
        for (var m = 0, v2, y2 = u - 1; y2 >= 0 && (v2 = i[y2], !(v2[0] !== "space" && (m += 1, m === 2))); y2--)
          ;
        throw this.input.error("Missed semicolon", v2[2], v2[3]);
      }
    }, t;
  }();
  r.default = l, n.exports = r.default;
} }), bf = R({ "node_modules/postcss-less/lib/nodes/inline-comment.js"(r, n) {
  I();
  var s = Ct(), c = yr();
  n.exports = { isInlineComment(o) {
    if (o[0] === "word" && o[1].slice(0, 2) === "//") {
      let p = o, f = [], h;
      for (; o; ) {
        if (/\r?\n/.test(o[1])) {
          if (/['"].*\r?\n/.test(o[1])) {
            f.push(o[1].substring(0, o[1].indexOf(`
`)));
            let l = o[1].substring(o[1].indexOf(`
`));
            l += this.input.css.valueOf().substring(this.tokenizer.position()), this.input = new c(l), this.tokenizer = s(this.input);
          } else
            this.tokenizer.back(o);
          break;
        }
        f.push(o[1]), h = o, o = this.tokenizer.nextToken({ ignoreUnclosed: true });
      }
      let g2 = ["comment", f.join(""), p[2], p[3], h[2], h[3]];
      return this.inlineComment(g2), true;
    } else if (o[1] === "/") {
      let p = this.tokenizer.nextToken({ ignoreUnclosed: true });
      if (p[0] === "comment" && /^\/\*/.test(p[1]))
        return p[0] = "word", p[1] = p[1].slice(1), o[1] = "//", this.tokenizer.back(p), n.exports.isInlineComment.bind(this)(o);
    }
    return false;
  } };
} }), xf = R({ "node_modules/postcss-less/lib/nodes/interpolation.js"(r, n) {
  I(), n.exports = { interpolation(s) {
    let c = s, o = [s], p = ["word", "{", "}"];
    if (s = this.tokenizer.nextToken(), c[1].length > 1 || s[0] !== "{")
      return this.tokenizer.back(s), false;
    for (; s && p.includes(s[0]); )
      o.push(s), s = this.tokenizer.nextToken();
    let f = o.map((e) => e[1]);
    [c] = o;
    let h = o.pop(), g2 = [c[2], c[3]], l = [h[4] || h[2], h[5] || h[3]], t = ["word", f.join("")].concat(g2, l);
    return this.tokenizer.back(s), this.tokenizer.back(t), true;
  } };
} }), Sf = R({ "node_modules/postcss-less/lib/nodes/mixin.js"(r, n) {
  I();
  var s = /^#[0-9a-fA-F]{6}$|^#[0-9a-fA-F]{3}$/, c = /\.[0-9]/, o = (p) => {
    let [, f] = p, [h] = f;
    return (h === "." || h === "#") && s.test(f) === false && c.test(f) === false;
  };
  n.exports = { isMixinToken: o };
} }), kf = R({ "node_modules/postcss-less/lib/nodes/import.js"(r, n) {
  I();
  var s = Ct(), c = /^url\((.+)\)/;
  n.exports = (o) => {
    let { name: p, params: f = "" } = o;
    if (p === "import" && f.length) {
      o.import = true;
      let h = s({ css: f });
      for (o.filename = f.replace(c, "$1"); !h.endOfFile(); ) {
        let [g2, l] = h.nextToken();
        if (g2 === "word" && l === "url")
          return;
        if (g2 === "brackets") {
          o.options = l, o.filename = f.replace(l, "").trim();
          break;
        }
      }
    }
  };
} }), Of = R({ "node_modules/postcss-less/lib/nodes/variable.js"(r, n) {
  I();
  var s = /:$/, c = /^:(\s+)?/;
  n.exports = (o) => {
    let { name: p, params: f = "" } = o;
    if (o.name.slice(-1) === ":") {
      if (s.test(p)) {
        let [h] = p.match(s);
        o.name = p.replace(h, ""), o.raws.afterName = h + (o.raws.afterName || ""), o.variable = true, o.value = o.params;
      }
      if (c.test(f)) {
        let [h] = f.match(c);
        o.value = f.replace(h, ""), o.raws.afterName = (o.raws.afterName || "") + h, o.variable = true;
      }
    }
  };
} }), Tf = R({ "node_modules/postcss-less/lib/LessParser.js"(r, n) {
  I();
  var s = _r(), c = Nt(), { isInlineComment: o } = bf(), { interpolation: p } = xf(), { isMixinToken: f } = Sf(), h = kf(), g2 = Of(), l = /(!\s*important)$/i;
  n.exports = class extends c {
    constructor() {
      super(...arguments), this.lastNode = null;
    }
    atrule(e) {
      p.bind(this)(e) || (super.atrule(e), h(this.lastNode), g2(this.lastNode));
    }
    decl() {
      super.decl(...arguments), /extend\(.+\)/i.test(this.lastNode.value) && (this.lastNode.extend = true);
    }
    each(e) {
      e[0][1] = ` ${e[0][1]}`;
      let a = e.findIndex((y2) => y2[0] === "("), i = e.reverse().find((y2) => y2[0] === ")"), u = e.reverse().indexOf(i), v2 = e.splice(a, u).map((y2) => y2[1]).join("");
      for (let y2 of e.reverse())
        this.tokenizer.back(y2);
      this.atrule(this.tokenizer.nextToken()), this.lastNode.function = true, this.lastNode.params = v2;
    }
    init(e, a, i) {
      super.init(e, a, i), this.lastNode = e;
    }
    inlineComment(e) {
      let a = new s(), i = e[1].slice(2);
      if (this.init(a, e[2], e[3]), a.source.end = { line: e[4], column: e[5] }, a.inline = true, a.raws.begin = "//", /^\s*$/.test(i))
        a.text = "", a.raws.left = i, a.raws.right = "";
      else {
        let u = i.match(/^(\s*)([^]*[^\s])(\s*)$/);
        [, a.raws.left, a.text, a.raws.right] = u;
      }
    }
    mixin(e) {
      let [a] = e, i = a[1].slice(0, 1), u = e.findIndex((d2) => d2[0] === "brackets"), m = e.findIndex((d2) => d2[0] === "("), v2 = "";
      if ((u < 0 || u > 3) && m > 0) {
        let d2 = e.reduce((H, U2, T) => U2[0] === ")" ? T : H), O = e.slice(m, d2 + m).map((H) => H[1]).join(""), [k] = e.slice(m), D = [k[2], k[3]], [P] = e.slice(d2, d2 + 1), $2 = [P[2], P[3]], G = ["brackets", O].concat(D, $2), Z = e.slice(0, m), B = e.slice(d2 + 1);
        e = Z, e.push(G), e = e.concat(B);
      }
      let y2 = [];
      for (let d2 of e)
        if ((d2[1] === "!" || y2.length) && y2.push(d2), d2[1] === "important")
          break;
      if (y2.length) {
        let [d2] = y2, _ = e.indexOf(d2), O = y2[y2.length - 1], k = [d2[2], d2[3]], D = [O[4], O[5]], $2 = ["word", y2.map((G) => G[1]).join("")].concat(k, D);
        e.splice(_, y2.length, $2);
      }
      let w = e.findIndex((d2) => l.test(d2[1]));
      w > 0 && ([, v2] = e[w], e.splice(w, 1));
      for (let d2 of e.reverse())
        this.tokenizer.back(d2);
      this.atrule(this.tokenizer.nextToken()), this.lastNode.mixin = true, this.lastNode.raws.identifier = i, v2 && (this.lastNode.important = true, this.lastNode.raws.important = v2);
    }
    other(e) {
      o.bind(this)(e) || super.other(e);
    }
    rule(e) {
      let a = e[e.length - 1], i = e[e.length - 2];
      if (i[0] === "at-word" && a[0] === "{" && (this.tokenizer.back(a), p.bind(this)(i))) {
        let m = this.tokenizer.nextToken();
        e = e.slice(0, e.length - 2).concat([m]);
        for (let v2 of e.reverse())
          this.tokenizer.back(v2);
        return;
      }
      super.rule(e), /:extend\(.+\)/i.test(this.lastNode.selector) && (this.lastNode.extend = true);
    }
    unknownWord(e) {
      let [a] = e;
      if (e[0][1] === "each" && e[1][0] === "(") {
        this.each(e);
        return;
      }
      if (f(a)) {
        this.mixin(e);
        return;
      }
      super.unknownWord(e);
    }
  };
} }), Ef = R({ "node_modules/postcss-less/lib/LessStringifier.js"(r, n) {
  I();
  var s = wr();
  n.exports = class extends s {
    atrule(o, p) {
      if (!o.mixin && !o.variable && !o.function) {
        super.atrule(o, p);
        return;
      }
      let h = `${o.function ? "" : o.raws.identifier || "@"}${o.name}`, g2 = o.params ? this.rawValue(o, "params") : "", l = o.raws.important || "";
      if (o.variable && (g2 = o.value), typeof o.raws.afterName < "u" ? h += o.raws.afterName : g2 && (h += " "), o.nodes)
        this.block(o, h + g2 + l);
      else {
        let t = (o.raws.between || "") + l + (p ? ";" : "");
        this.builder(h + g2 + t, o);
      }
    }
    comment(o) {
      if (o.inline) {
        let p = this.raw(o, "left", "commentLeft"), f = this.raw(o, "right", "commentRight");
        this.builder(`//${p}${o.text}${f}`, o);
      } else
        super.comment(o);
    }
  };
} }), qf = R({ "node_modules/postcss-less/lib/index.js"(r, n) {
  I();
  var s = yr(), c = Tf(), o = Ef();
  n.exports = { parse(p, f) {
    let h = new s(p, f), g2 = new c(h);
    return g2.parse(), g2.root;
  }, stringify(p, f) {
    new o(f).stringify(p);
  }, nodeToString(p) {
    let f = "";
    return n.exports.stringify(p, (h) => {
      f += h;
    }), f;
  } };
} }), Af = R({ "node_modules/postcss-scss/lib/scss-stringifier.js"(r, n) {
  I();
  function s(p, f) {
    p.prototype = Object.create(f.prototype), p.prototype.constructor = p, p.__proto__ = f;
  }
  var c = wr(), o = function(p) {
    s(f, p);
    function f() {
      return p.apply(this, arguments) || this;
    }
    var h = f.prototype;
    return h.comment = function(l) {
      var t = this.raw(l, "left", "commentLeft"), e = this.raw(l, "right", "commentRight");
      if (l.raws.inline) {
        var a = l.raws.text || l.text;
        this.builder("//" + t + a + e, l);
      } else
        this.builder("/*" + t + l.text + e + "*/", l);
    }, h.decl = function(l, t) {
      if (!l.isNested)
        p.prototype.decl.call(this, l, t);
      else {
        var e = this.raw(l, "between", "colon"), a = l.prop + e + this.rawValue(l, "value");
        l.important && (a += l.raws.important || " !important"), this.builder(a + "{", l, "start");
        var i;
        l.nodes && l.nodes.length ? (this.body(l), i = this.raw(l, "after")) : i = this.raw(l, "after", "emptyBody"), i && this.builder(i), this.builder("}", l, "end");
      }
    }, h.rawValue = function(l, t) {
      var e = l[t], a = l.raws[t];
      return a && a.value === e ? a.scss ? a.scss : a.raw : e;
    }, f;
  }(c);
  n.exports = o;
} }), Pf = R({ "node_modules/postcss-scss/lib/scss-stringify.js"(r, n) {
  I();
  var s = Af();
  n.exports = function(o, p) {
    var f = new s(p);
    f.stringify(o);
  };
} }), If = R({ "node_modules/postcss-scss/lib/nested-declaration.js"(r, n) {
  I();
  function s(p, f) {
    p.prototype = Object.create(f.prototype), p.prototype.constructor = p, p.__proto__ = f;
  }
  var c = br(), o = function(p) {
    s(f, p);
    function f(h) {
      var g2;
      return g2 = p.call(this, h) || this, g2.type = "decl", g2.isNested = true, g2.nodes || (g2.nodes = []), g2;
    }
    return f;
  }(c);
  n.exports = o;
} }), Rf = R({ "node_modules/postcss-scss/lib/scss-tokenize.js"(r, n) {
  I();
  var s = "'".charCodeAt(0), c = '"'.charCodeAt(0), o = "\\".charCodeAt(0), p = "/".charCodeAt(0), f = `
`.charCodeAt(0), h = " ".charCodeAt(0), g2 = "\f".charCodeAt(0), l = "	".charCodeAt(0), t = "\r".charCodeAt(0), e = "[".charCodeAt(0), a = "]".charCodeAt(0), i = "(".charCodeAt(0), u = ")".charCodeAt(0), m = "{".charCodeAt(0), v2 = "}".charCodeAt(0), y2 = ";".charCodeAt(0), w = "*".charCodeAt(0), d2 = ":".charCodeAt(0), _ = "@".charCodeAt(0), O = ",".charCodeAt(0), k = "#".charCodeAt(0), D = /[ \n\t\r\f{}()'"\\;/[\]#]/g, P = /[ \n\t\r\f(){}:;@!'"\\\][#]|\/(?=\*)/g, $2 = /.[\\/("'\n]/, G = /[a-f0-9]/i, Z = /[\r\f\n]/g;
  n.exports = function(H, U2) {
    U2 === void 0 && (U2 = {});
    var T = H.css.valueOf(), L = U2.ignoreErrors, j, N2, b, Y, J, W, X, C, Q, M2, E, x, S, z, A = T.length, q = -1, V = 1, F = 0, ee2 = [], te2 = [];
    function ue2(ie2) {
      throw H.error("Unclosed " + ie2, V, F - q);
    }
    function le2() {
      return te2.length === 0 && F >= A;
    }
    function re() {
      for (var ie2 = 1, ce2 = false, fe2 = false; ie2 > 0; )
        N2 += 1, T.length <= N2 && ue2("interpolation"), j = T.charCodeAt(N2), x = T.charCodeAt(N2 + 1), ce2 ? !fe2 && j === ce2 ? (ce2 = false, fe2 = false) : j === o ? fe2 = !M2 : fe2 && (fe2 = false) : j === s || j === c ? ce2 = j : j === v2 ? ie2 -= 1 : j === k && x === m && (ie2 += 1);
    }
    function ne2() {
      if (te2.length)
        return te2.pop();
      if (!(F >= A)) {
        switch (j = T.charCodeAt(F), (j === f || j === g2 || j === t && T.charCodeAt(F + 1) !== f) && (q = F, V += 1), j) {
          case f:
          case h:
          case l:
          case t:
          case g2:
            N2 = F;
            do
              N2 += 1, j = T.charCodeAt(N2), j === f && (q = N2, V += 1);
            while (j === h || j === f || j === l || j === t || j === g2);
            S = ["space", T.slice(F, N2)], F = N2 - 1;
            break;
          case e:
            S = ["[", "[", V, F - q];
            break;
          case a:
            S = ["]", "]", V, F - q];
            break;
          case m:
            S = ["{", "{", V, F - q];
            break;
          case v2:
            S = ["}", "}", V, F - q];
            break;
          case O:
            S = ["word", ",", V, F - q, V, F - q + 1];
            break;
          case d2:
            S = [":", ":", V, F - q];
            break;
          case y2:
            S = [";", ";", V, F - q];
            break;
          case i:
            if (E = ee2.length ? ee2.pop()[1] : "", x = T.charCodeAt(F + 1), E === "url" && x !== s && x !== c) {
              for (z = 1, M2 = false, N2 = F + 1; N2 <= T.length - 1; ) {
                if (x = T.charCodeAt(N2), x === o)
                  M2 = !M2;
                else if (x === i)
                  z += 1;
                else if (x === u && (z -= 1, z === 0))
                  break;
                N2 += 1;
              }
              W = T.slice(F, N2 + 1), Y = W.split(`
`), J = Y.length - 1, J > 0 ? (C = V + J, Q = N2 - Y[J].length) : (C = V, Q = q), S = ["brackets", W, V, F - q, C, N2 - Q], q = Q, V = C, F = N2;
            } else
              N2 = T.indexOf(")", F + 1), W = T.slice(F, N2 + 1), N2 === -1 || $2.test(W) ? S = ["(", "(", V, F - q] : (S = ["brackets", W, V, F - q, V, N2 - q], F = N2);
            break;
          case u:
            S = [")", ")", V, F - q];
            break;
          case s:
          case c:
            for (b = j, N2 = F, M2 = false; N2 < A && (N2++, N2 === A && ue2("string"), j = T.charCodeAt(N2), x = T.charCodeAt(N2 + 1), !(!M2 && j === b)); )
              j === o ? M2 = !M2 : M2 ? M2 = false : j === k && x === m && re();
            W = T.slice(F, N2 + 1), Y = W.split(`
`), J = Y.length - 1, J > 0 ? (C = V + J, Q = N2 - Y[J].length) : (C = V, Q = q), S = ["string", T.slice(F, N2 + 1), V, F - q, C, N2 - Q], q = Q, V = C, F = N2;
            break;
          case _:
            D.lastIndex = F + 1, D.test(T), D.lastIndex === 0 ? N2 = T.length - 1 : N2 = D.lastIndex - 2, S = ["at-word", T.slice(F, N2 + 1), V, F - q, V, N2 - q], F = N2;
            break;
          case o:
            for (N2 = F, X = true; T.charCodeAt(N2 + 1) === o; )
              N2 += 1, X = !X;
            if (j = T.charCodeAt(N2 + 1), X && j !== p && j !== h && j !== f && j !== l && j !== t && j !== g2 && (N2 += 1, G.test(T.charAt(N2)))) {
              for (; G.test(T.charAt(N2 + 1)); )
                N2 += 1;
              T.charCodeAt(N2 + 1) === h && (N2 += 1);
            }
            S = ["word", T.slice(F, N2 + 1), V, F - q, V, N2 - q], F = N2;
            break;
          default:
            x = T.charCodeAt(F + 1), j === k && x === m ? (N2 = F, re(), W = T.slice(F, N2 + 1), Y = W.split(`
`), J = Y.length - 1, J > 0 ? (C = V + J, Q = N2 - Y[J].length) : (C = V, Q = q), S = ["word", W, V, F - q, C, N2 - Q], q = Q, V = C, F = N2) : j === p && x === w ? (N2 = T.indexOf("*/", F + 2) + 1, N2 === 0 && (L ? N2 = T.length : ue2("comment")), W = T.slice(F, N2 + 1), Y = W.split(`
`), J = Y.length - 1, J > 0 ? (C = V + J, Q = N2 - Y[J].length) : (C = V, Q = q), S = ["comment", W, V, F - q, C, N2 - Q], q = Q, V = C, F = N2) : j === p && x === p ? (Z.lastIndex = F + 1, Z.test(T), Z.lastIndex === 0 ? N2 = T.length - 1 : N2 = Z.lastIndex - 2, W = T.slice(F, N2 + 1), S = ["comment", W, V, F - q, V, N2 - q, "inline"], F = N2) : (P.lastIndex = F + 1, P.test(T), P.lastIndex === 0 ? N2 = T.length - 1 : N2 = P.lastIndex - 2, S = ["word", T.slice(F, N2 + 1), V, F - q, V, N2 - q], ee2.push(S), F = N2);
            break;
        }
        return F++, S;
      }
    }
    function oe(ie2) {
      te2.push(ie2);
    }
    return { back: oe, nextToken: ne2, endOfFile: le2 };
  };
} }), Cf = R({ "node_modules/postcss-scss/lib/scss-parser.js"(r, n) {
  I();
  function s(g2, l) {
    g2.prototype = Object.create(l.prototype), g2.prototype.constructor = g2, g2.__proto__ = l;
  }
  var c = _r(), o = Nt(), p = If(), f = Rf(), h = function(g2) {
    s(l, g2);
    function l() {
      return g2.apply(this, arguments) || this;
    }
    var t = l.prototype;
    return t.createTokenizer = function() {
      this.tokenizer = f(this.input);
    }, t.rule = function(a) {
      for (var i = false, u = 0, m = "", w = a, v2 = Array.isArray(w), y2 = 0, w = v2 ? w : w[Symbol.iterator](); ; ) {
        var d2;
        if (v2) {
          if (y2 >= w.length)
            break;
          d2 = w[y2++];
        } else {
          if (y2 = w.next(), y2.done)
            break;
          d2 = y2.value;
        }
        var _ = d2;
        if (i)
          _[0] !== "comment" && _[0] !== "{" && (m += _[1]);
        else {
          if (_[0] === "space" && _[1].indexOf(`
`) !== -1)
            break;
          _[0] === "(" ? u += 1 : _[0] === ")" ? u -= 1 : u === 0 && _[0] === ":" && (i = true);
        }
      }
      if (!i || m.trim() === "" || /^[a-zA-Z-:#]/.test(m))
        g2.prototype.rule.call(this, a);
      else {
        a.pop();
        var O = new p();
        this.init(O);
        var k = a[a.length - 1];
        for (k[4] ? O.source.end = { line: k[4], column: k[5] } : O.source.end = { line: k[2], column: k[3] }; a[0][0] !== "word"; )
          O.raws.before += a.shift()[1];
        for (O.source.start = { line: a[0][2], column: a[0][3] }, O.prop = ""; a.length; ) {
          var D = a[0][0];
          if (D === ":" || D === "space" || D === "comment")
            break;
          O.prop += a.shift()[1];
        }
        O.raws.between = "";
        for (var P; a.length; )
          if (P = a.shift(), P[0] === ":") {
            O.raws.between += P[1];
            break;
          } else
            O.raws.between += P[1];
        (O.prop[0] === "_" || O.prop[0] === "*") && (O.raws.before += O.prop[0], O.prop = O.prop.slice(1)), O.raws.between += this.spacesAndCommentsFromStart(a), this.precheckMissedSemicolon(a);
        for (var $2 = a.length - 1; $2 > 0; $2--) {
          if (P = a[$2], P[1] === "!important") {
            O.important = true;
            var G = this.stringFrom(a, $2);
            G = this.spacesFromEnd(a) + G, G !== " !important" && (O.raws.important = G);
            break;
          } else if (P[1] === "important") {
            for (var Z = a.slice(0), B = "", H = $2; H > 0; H--) {
              var U2 = Z[H][0];
              if (B.trim().indexOf("!") === 0 && U2 !== "space")
                break;
              B = Z.pop()[1] + B;
            }
            B.trim().indexOf("!") === 0 && (O.important = true, O.raws.important = B, a = Z);
          }
          if (P[0] !== "space" && P[0] !== "comment")
            break;
        }
        this.raw(O, "value", a), O.value.indexOf(":") !== -1 && this.checkMissedSemicolon(a), this.current = O;
      }
    }, t.comment = function(a) {
      if (a[6] === "inline") {
        var i = new c();
        this.init(i, a[2], a[3]), i.raws.inline = true, i.source.end = { line: a[4], column: a[5] };
        var u = a[1].slice(2);
        if (/^\s*$/.test(u))
          i.text = "", i.raws.left = u, i.raws.right = "";
        else {
          var m = u.match(/^(\s*)([^]*[^\s])(\s*)$/), v2 = m[2].replace(/(\*\/|\/\*)/g, "*//*");
          i.text = v2, i.raws.left = m[1], i.raws.right = m[3], i.raws.text = m[2];
        }
      } else
        g2.prototype.comment.call(this, a);
    }, t.raw = function(a, i, u) {
      if (g2.prototype.raw.call(this, a, i, u), a.raws[i]) {
        var m = a.raws[i].raw;
        a.raws[i].raw = u.reduce(function(v2, y2) {
          if (y2[0] === "comment" && y2[6] === "inline") {
            var w = y2[1].slice(2).replace(/(\*\/|\/\*)/g, "*//*");
            return v2 + "/*" + w + "*/";
          } else
            return v2 + y2[1];
        }, ""), m !== a.raws[i].raw && (a.raws[i].scss = m);
      }
    }, l;
  }(o);
  n.exports = h;
} }), Nf = R({ "node_modules/postcss-scss/lib/scss-parse.js"(r, n) {
  I();
  var s = yr(), c = Cf();
  n.exports = function(p, f) {
    var h = new s(p, f), g2 = new c(h);
    return g2.parse(), g2.root;
  };
} }), jf = R({ "node_modules/postcss-scss/lib/scss-syntax.js"(r, n) {
  I();
  var s = Pf(), c = Nf();
  n.exports = { parse: c, stringify: s };
} }), Mf = R({ "src/language-css/parser-postcss.js"(r, n) {
  I();
  var s = al(), c = Cs(), o = Ns(), { hasPragma: p } = gl(), { locStart: f, locEnd: h } = ds(), { calculateLoc: g2, replaceQuotesInInlineComments: l } = ds(), t = bl(), e = xl(), a = Sl(), i = kl(), u = Ol(), m = Tl(), v2 = El(), y2 = ql(), w = (b) => {
    for (; b.parent; )
      b = b.parent;
    return b;
  };
  function d2(b, Y) {
    let { nodes: J } = b, W = { open: null, close: null, groups: [], type: "paren_group" }, X = [W], C = W, Q = { groups: [], type: "comma_group" }, M2 = [Q];
    for (let E = 0; E < J.length; ++E) {
      let x = J[E];
      if (i(Y.parser, x.value) && x.type === "number" && x.unit === ".." && c(x.value) === "." && (x.value = x.value.slice(0, -1), x.unit = "..."), x.type === "func" && x.value === "selector" && (x.group.groups = [$2(w(b).text.slice(x.group.open.sourceIndex + 1, x.group.close.sourceIndex))]), x.type === "func" && x.value === "url") {
        let S = x.group && x.group.groups || [], z = [];
        for (let A = 0; A < S.length; A++) {
          let q = S[A];
          q.type === "comma_group" ? z = [...z, ...q.groups] : z.push(q);
        }
        if (t(z) || !e(z) && !m(z[0])) {
          let A = v2({ groups: x.group.groups });
          x.group.groups = [A.trim()];
        }
      }
      if (x.type === "paren" && x.value === "(")
        W = { open: x, close: null, groups: [], type: "paren_group" }, X.push(W), Q = { groups: [], type: "comma_group" }, M2.push(Q);
      else if (x.type === "paren" && x.value === ")") {
        if (Q.groups.length > 0 && W.groups.push(Q), W.close = x, M2.length === 1)
          throw new Error("Unbalanced parenthesis");
        M2.pop(), Q = c(M2), Q.groups.push(W), X.pop(), W = c(X);
      } else
        x.type === "comma" ? (W.groups.push(Q), Q = { groups: [], type: "comma_group" }, M2[M2.length - 1] = Q) : Q.groups.push(x);
    }
    return Q.groups.length > 0 && W.groups.push(Q), C;
  }
  function _(b) {
    return b.type === "paren_group" && !b.open && !b.close && b.groups.length === 1 || b.type === "comma_group" && b.groups.length === 1 ? _(b.groups[0]) : b.type === "paren_group" || b.type === "comma_group" ? Object.assign(Object.assign({}, b), {}, { groups: b.groups.map(_) }) : b;
  }
  function O(b, Y, J) {
    if (b && typeof b == "object") {
      delete b.parent;
      for (let W in b)
        O(b[W], Y, J), W === "type" && typeof b[W] == "string" && !b[W].startsWith(Y) && (!J || !J.test(b[W])) && (b[W] = Y + b[W]);
    }
    return b;
  }
  function k(b) {
    if (b && typeof b == "object") {
      delete b.parent;
      for (let Y in b)
        k(b[Y]);
      !Array.isArray(b) && b.value && !b.type && (b.type = "unknown");
    }
    return b;
  }
  function D(b, Y) {
    if (b && typeof b == "object") {
      for (let J in b)
        J !== "parent" && (D(b[J], Y), J === "nodes" && (b.group = _(d2(b, Y)), delete b[J]));
      delete b.parent;
    }
    return b;
  }
  function P(b, Y) {
    let J = ef(), W = null;
    try {
      W = J(b, { loose: true }).parse();
    } catch {
      return { type: "value-unknown", value: b };
    }
    W.text = b;
    let X = D(W, Y);
    return O(X, "value-", /^selector-/);
  }
  function $2(b) {
    if (/\/\/|\/\*/.test(b))
      return { type: "selector-unknown", value: b.trim() };
    let Y = of(), J = null;
    try {
      Y((W) => {
        J = W;
      }).process(b);
    } catch {
      return { type: "selector-unknown", value: b };
    }
    return O(J, "selector-");
  }
  function G(b) {
    let Y = uf().default, J = null;
    try {
      J = Y(b);
    } catch {
      return { type: "selector-unknown", value: b };
    }
    return O(k(J), "media-");
  }
  var Z = /(\s*)(!default).*$/, B = /(\s*)(!global).*$/;
  function H(b, Y) {
    if (b && typeof b == "object") {
      delete b.parent;
      for (let E in b)
        H(b[E], Y);
      if (!b.type)
        return b;
      b.raws || (b.raws = {});
      let C = "";
      if (typeof b.selector == "string") {
        var J;
        C = b.raws.selector ? (J = b.raws.selector.scss) !== null && J !== void 0 ? J : b.raws.selector.raw : b.selector, b.raws.between && b.raws.between.trim().length > 0 && (C += b.raws.between), b.raws.selector = C;
      }
      let Q = "";
      if (typeof b.value == "string") {
        var W;
        Q = b.raws.value ? (W = b.raws.value.scss) !== null && W !== void 0 ? W : b.raws.value.raw : b.value, Q = Q.trim(), b.raws.value = Q;
      }
      let M2 = "";
      if (typeof b.params == "string") {
        var X;
        M2 = b.raws.params ? (X = b.raws.params.scss) !== null && X !== void 0 ? X : b.raws.params.raw : b.params, b.raws.afterName && b.raws.afterName.trim().length > 0 && (M2 = b.raws.afterName + M2), b.raws.between && b.raws.between.trim().length > 0 && (M2 = M2 + b.raws.between), M2 = M2.trim(), b.raws.params = M2;
      }
      if (C.trim().length > 0)
        return C.startsWith("@") && C.endsWith(":") ? b : b.mixin ? (b.selector = P(C, Y), b) : (u(b) && (b.isSCSSNesterProperty = true), b.selector = $2(C), b);
      if (Q.length > 0) {
        let E = Q.match(Z);
        E && (Q = Q.slice(0, E.index), b.scssDefault = true, E[0].trim() !== "!default" && (b.raws.scssDefault = E[0]));
        let x = Q.match(B);
        if (x && (Q = Q.slice(0, x.index), b.scssGlobal = true, x[0].trim() !== "!global" && (b.raws.scssGlobal = x[0])), Q.startsWith("progid:"))
          return { type: "value-unknown", value: Q };
        b.value = P(Q, Y);
      }
      if (a(Y) && b.type === "css-decl" && Q.startsWith("extend(") && (b.extend || (b.extend = b.raws.between === ":"), b.extend && !b.selector && (delete b.value, b.selector = $2(Q.slice(7, -1)))), b.type === "css-atrule") {
        if (a(Y)) {
          if (b.mixin) {
            let E = b.raws.identifier + b.name + b.raws.afterName + b.raws.params;
            return b.selector = $2(E), delete b.params, b;
          }
          if (b.function)
            return b;
        }
        if (Y.parser === "css" && b.name === "custom-selector") {
          let E = b.params.match(/:--\S+\s+/)[0].trim();
          return b.customSelector = E, b.selector = $2(b.params.slice(E.length).trim()), delete b.params, b;
        }
        if (a(Y)) {
          if (b.name.includes(":") && !b.params) {
            b.variable = true;
            let E = b.name.split(":");
            b.name = E[0], b.value = P(E.slice(1).join(":"), Y);
          }
          if (!["page", "nest", "keyframes"].includes(b.name) && b.params && b.params[0] === ":") {
            b.variable = true;
            let E = b.params.slice(1);
            E && (b.value = P(E, Y)), b.raws.afterName += ":";
          }
          if (b.variable)
            return delete b.params, b.value || delete b.value, b;
        }
      }
      if (b.type === "css-atrule" && M2.length > 0) {
        let { name: E } = b, x = b.name.toLowerCase();
        return E === "warn" || E === "error" ? (b.params = { type: "media-unknown", value: M2 }, b) : E === "extend" || E === "nest" ? (b.selector = $2(M2), delete b.params, b) : E === "at-root" ? (/^\(\s*(?:without|with)\s*:.+\)$/s.test(M2) ? b.params = P(M2, Y) : (b.selector = $2(M2), delete b.params), b) : y2(x) ? (b.import = true, delete b.filename, b.params = P(M2, Y), b) : ["namespace", "supports", "if", "else", "for", "each", "while", "debug", "mixin", "include", "function", "return", "define-mixin", "add-mixin"].includes(E) ? (M2 = M2.replace(/(\$\S+?)(\s+)?\.{3}/, "$1...$2"), M2 = M2.replace(/^(?!if)(\S+)(\s+)\(/, "$1($2"), b.value = P(M2, Y), delete b.params, b) : ["media", "custom-media"].includes(x) ? M2.includes("#{") ? { type: "media-unknown", value: M2 } : (b.params = G(M2), b) : (b.params = M2, b);
      }
    }
    return b;
  }
  function U2(b, Y, J) {
    let W = o(Y), { frontMatter: X } = W;
    Y = W.content;
    let C;
    try {
      C = b(Y);
    } catch (Q) {
      let { name: M2, reason: E, line: x, column: S } = Q;
      throw typeof x != "number" ? Q : s(`${M2}: ${E}`, { start: { line: x, column: S } });
    }
    return C = H(O(C, "css-"), J), g2(C, Y), X && (X.source = { startOffset: 0, endOffset: X.raw.length }, C.nodes.unshift(X)), C;
  }
  function T(b, Y) {
    let J = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, X = i(J.parser, b) ? [j, L] : [L, j], C;
    for (let Q of X)
      try {
        return Q(b, Y, J);
      } catch (M2) {
        C = C || M2;
      }
    if (C)
      throw C;
  }
  function L(b, Y) {
    let J = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, W = qf();
    return U2((X) => W.parse(l(X)), b, J);
  }
  function j(b, Y) {
    let J = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, { parse: W } = jf();
    return U2(W, b, J);
  }
  var N2 = { astFormat: "postcss", hasPragma: p, locStart: f, locEnd: h };
  n.exports = { parsers: { css: Object.assign(Object.assign({}, N2), {}, { parse: T }), less: Object.assign(Object.assign({}, N2), {}, { parse: L }), scss: Object.assign(Object.assign({}, N2), {}, { parse: j }) } };
} }), sh = Mf();
const __css$4 = "\n                @import url('https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css');\n            .s-code-example {\n    display: flex;\n    flex-direction: column;\n    text-align: initial;\n}\n            .s-rhythm-vertical > .s-code-example {\n                margin-bottom: calc(var(--s-margin-default, 16) * 5 * 1px);\n            }\n\n.s-code-example_root {\n    display: flex;\n    flex-direction: column;\n    flex-grow: 1;\n}\n\n.s-code-example > * {\n        display: none;\n    }\n\n.s-code-example[mounted] > * {\n            display: flex;\n        }\n\n.hljs {\n    overflow: visible;\n    white-space: pre-wrap;\n}\n\n.s-code-example_slot {\n    display: none;\n}\n\n.s-code-example_nav {\n    position: relative;\n    z-index: 20;\n}\n\n.s-code-example_tabs {\n    list-style: none;\n}\n.s-code-example_tab {\n}\n\n.s-code-example_content {\n    position: relative;\n    display: flex;\n    flex-direction: column;\n    flex-grow: 1;\n    overflow: auto;\n}\n\n/* this variable comes from the @s.codeExample mixin */\n\n.s-code-example[lines] .s-code-example_content {\n        max-height: calc(\n            2em * var(--max-lines) + (var(--paddingBlock, 1em) * 2)\n        );\n    }\n\n.s-code-example--more .s-code-example_content {\n        max-height: 99999px !important;\n    }\n\n.s-code-example_more-bar {\n    position: absolute;\n    bottom: 0;\n    left: 0;\n    height: 50%;\n    width: 100%;\n    opacity: 0;\n    pointer-events: none;\n    display: flex;\n    align-items: flex-end;\n}\n\n.s-code-example[lines] .s-code-example_more-bar {\n        opacity: 1;\n        pointer-events: all;\n    }\n.s-code-example_more-bar {\n    text-align: center;\n    justify-content: center;\n}\n.s-code-example_more-bar:before {\n        content: '';\n        position: absolute;\n        bottom: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n    }\n\n.s-code-example--more .s-code-example_more-bar:before {\n        height: 0;\n    }\n\n.s-code-example_code {\n    display: none;\n    line-height: 0;\n    flex-grow: 1;\n}\n\n.s-code-example_code[active] {\n        display: flex;\n    }\n\n.s-code-example_code > code {\n        flex-grow: 1;\n        line-height: 1;\n    }\n\n.s-code-example_toolbar {\n    position: absolute;\n    right: calc(var(--s-margin-default, 16) * 0.75 * 1px);\n    top: calc(var(--s-margin-default, 16) * 0.75 * 1px);\n}\n\n.s-code-example_toolbar > * {\n        font-size: 20px;\n    }\n\n[toolbar-position='nav'] .s-code-example_toolbar {\n    right: calc(var(--s-margin-default, 16) * 0.75 * 1px);\n    top: calc(var(--s-margin-default, 16) * 0.75 * 1px);\n}\n";
var __decorate = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d2 = decorators[i])
        r = (c < 3 ? d2(r) : c > 3 ? d2(target, key, r) : d2(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter$4 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
define$7();
class SCodeExample extends SLitComponent {
  static get properties() {
    return SLitComponent.propertiesFromInterface({}, SCodeExampleComponentInterface);
  }
  static get styles() {
    return css$1`
            ${unsafeCSS(__css$4)}
        `;
  }
  constructor() {
    super(__deepMerge({
      name: "s-code-example",
      interface: SCodeExampleComponentInterface
    }));
    this._$copy = void 0;
    this.state = {
      activeTabId: void 0,
      more: false
    };
  }
  mount() {
    var _a2, _b2, _c2, _d2, _e2;
    return __awaiter$4(this, void 0, void 0, function* () {
      const languages = Object.assign({ html: xml, twig, javascript, js: javascript, php, bash, shell: bash, css, scss: css }, (_a2 = this.props.languages) !== null && _a2 !== void 0 ? _a2 : {});
      Object.keys(languages).forEach((lang) => {
        HighlightJS.registerLanguage(lang, languages[lang]);
      });
      this.$templates = this.querySelectorAll("template,code");
      for (let [idx, $template] of Object.entries(this.$templates)) {
        if (!$template.getAttribute)
          return;
        let parser = "babel";
        switch ((_b2 = $template.getAttribute("language")) !== null && _b2 !== void 0 ? _b2 : $template.getAttribute("id")) {
          case "html":
          case "xml":
            parser = "html";
            break;
          case "css":
          case "scss":
          case "postcss":
            parser = "css";
            break;
        }
        let rawCode = __decodeHtmlEntities($template.tagName.toLowerCase() === "textarea" && // @ts-ignore
        $template.value ? (
          // @ts-ignore
          $template.value
        ) : $template.innerHTML);
        let formatedCode = rawCode.replace(/\<\!\-\-\?lit\$[a-zA-Z0-9]+\$\-\-\>/gm, "");
        try {
          formatedCode = yield Ty.format(formatedCode, {
            parser,
            plugins: [
              sh,
              _2,
              Tm,
              __prettierPhp
            ]
          });
        } catch (e) {
        }
        this.props.items = [
          ...this.props.items,
          {
            id: (_d2 = (_c2 = $template.getAttribute("id")) !== null && _c2 !== void 0 ? _c2 : $template.getAttribute("language")) !== null && _d2 !== void 0 ? _d2 : "html",
            language: (_e2 = $template.getAttribute("language")) !== null && _e2 !== void 0 ? _e2 : "html",
            code: formatedCode,
            highlightedCode: "",
            lines: formatedCode.trim().split("\n").length
          }
        ];
        $template.remove();
      }
    });
  }
  firstUpdated() {
    return __awaiter$4(this, void 0, void 0, function* () {
      if (this.props.active) {
        this.setActiveTab(this.props.active);
      } else {
        if (this.props.items[0]) {
          this.setActiveTab(this.props.items[0].id);
        }
      }
      this._$pre = this.querySelector(".s-code-example_code");
      this._$root = this.querySelector(".s-code-example_root");
      return true;
    });
  }
  setActiveTabByTab(e) {
    this.setActiveTab(e.target.id);
  }
  get currentItem() {
    if (!this.state.activeTabId)
      return {};
    return this.props.items.find((i) => i.id === this.state.activeTabId);
  }
  setActiveTab(id2) {
    return __awaiter$4(this, void 0, void 0, function* () {
      yield __wait();
      this.state.activeTabId = id2;
      this.highlight(id2);
      this.requestUpdate();
    });
  }
  setMoreClass() {
    return __awaiter$4(this, void 0, void 0, function* () {
      if (this.state.more) {
        this._$root.classList.add("s-code-example--more");
      } else {
        this._$root.classList.remove("s-code-example--more");
      }
    });
  }
  toggleMore() {
    var _a2;
    this.state.more = !this.state.more;
    this.setMoreClass();
    __scrollTo(this, Object.assign({}, (_a2 = this.props.scrollToSettings) !== null && _a2 !== void 0 ? _a2 : {}));
  }
  highlight(id2) {
    var _a2, _b2, _c2, _d2;
    const $content = this.querySelector(`pre#${id2} code`);
    const item = this.props.items.find((i) => i.id === id2);
    if ($content.hasAttribute("inited")) {
      this.setMoreClass();
      return;
    }
    $content.setAttribute("inited", "true");
    let code3;
    try {
      const codeToHighlight = (_b2 = (_a2 = item.code) === null || _a2 === void 0 ? void 0 : _a2.trim()) !== null && _b2 !== void 0 ? _b2 : "";
      code3 = HighlightJS.highlight(codeToHighlight, {
        language: item.language,
        ignoreIllegals: true
      });
    } catch (e) {
      console.log("highlight.js error", e);
    }
    item.highlightedCode = (_d2 = (_c2 = code3 === null || code3 === void 0 ? void 0 : code3.value) !== null && _c2 !== void 0 ? _c2 : code3) !== null && _d2 !== void 0 ? _d2 : "";
    this.setMoreClass();
  }
  copy() {
    const id2 = this.state.activeTabId;
    const item = this.props.items.filter((i) => i.id === id2)[0];
    this.$copy.copy(item.code);
  }
  render() {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
    const currentItem = this.currentItem;
    return html`
            <div
                class="${this.utils.cls("_root")} ${this.props.more ? this.utils.cls("more") : ""}"
                ?lines="${// @ts-ignore
    this.props.lines}"
                ?bare="${// @ts-ignore
    this.props.bare}"
                toolbar-position="${// @ts-ignore
    this.props.toolbarPosition}"
            >
                <div class="templates"></div>

                <header class="${this.utils.cls("_nav")}">
                    <div class="${this.utils.cls("_tabs", "s-tabs")}">
                        ${((_a2 = this.props.items) !== null && _a2 !== void 0 ? _a2 : []).map((item) => {
      var _a3;
      return html`
                                <div
                                    id="${(_a3 = item.id) !== null && _a3 !== void 0 ? _a3 : item.language}"
                                    class="${this.utils.cls("_tab")} ${this.state.activeTabId === item.id ? "active" : ""}"
                                    ?active="${this.state.activeTabId === item.id}"
                                    @click="${this.setActiveTabByTab}"
                                >
                                    ${item.language}
                                </div>
                            `;
    })}
                    </div>
                    ${// @ts-ignore
    this.toolbarPosition === "nav" ? html`
                                  <div class="${this.utils.cls("_toolbar")}">
                                      <s-clipboard-copy
                                          @click="${this.copy}"
                                      ></s-clipboard-copy>
                                  </div>
                              ` : ""}
                </header>
                <div
                    class="${this.utils.cls("_content")}"
                    style="--max-lines: ${(_b2 = this.props.lines) !== null && _b2 !== void 0 ? _b2 : 99999999};"
                >
                    ${// @ts-ignore
    this.toolbarPosition !== "nav" ? html`
                                  <div class="${this.utils.cls("_toolbar")}">
                                      <s-clipboard-copy
                                          @click="${this.copy}"
                                      ></s-clipboard-copy>
                                  </div>
                              ` : ""}
                    ${((_c2 = this.props.items) !== null && _c2 !== void 0 ? _c2 : []).map((item) => {
      var _a3, _b3, _c3, _d3;
      return html`
                            <pre
                                class="${this.utils.cls("_code")}"
                                style="line-height:0;"
                                id="${(_a3 = item.id) !== null && _a3 !== void 0 ? _a3 : item.language}"
                                ?active="${this.state.activeTabId === ((_b3 = item.id) !== null && _b3 !== void 0 ? _b3 : item.language)}"
                            >
                            <code language="${(_c3 = item.language) !== null && _c3 !== void 0 ? _c3 : item.id}" class="language-${item.language} ${item.language} ${this.props.bare ? "" : "hljs"}"
                                .innerHTML=${(_d3 = item.highlightedCode) !== null && _d3 !== void 0 ? _d3 : ""}></code>
                        </pre>
                        `;
    })}
                    ${this.props.more && this.props.lines && currentItem.lines > this.props.lines ? html`
                        <div class="${this.utils.cls("_more-bar")}">
                            ${// @ts-ignore
    this.moreAction === "toggle" ? html`
                                          <button
                                              class="${this.utils.cls("_more-button", "s-btn")}"
                                              aria-label="${this.state.more ? "Show less" : "Show more"}"
                                              @click="${() => this.toggleMore()}"
                                          >
                                              ${// @ts-ignore
    this.state.more ? html`
                                                            ${(_d2 = this.props.lessLabel) !== null && _d2 !== void 0 ? _d2 : "Show less"}
                                                        ` : html`
                                                            ${(_e2 = this.props.moreLabel) !== null && _e2 !== void 0 ? _e2 : "Show more"}
                                                        `}
                                          </button>
                                      ` : html`
                                          <a
                                              class="${this.utils.cls("_more-button", "s-btn s-color--accent")}"
                                              href="${// @ts-ignore
    this.moreAction}"
                                              title="${this.state.more ? "Show less" : "Show more"}"
                                          >
                                              ${// @ts-ignore
    this.state.more ? html`
                                                            ${(_f2 = this.props.lessLabel) !== null && _f2 !== void 0 ? _f2 : "Show less"}
                                                        ` : html`
                                                            ${(_g2 = this.props.moreLabel) !== null && _g2 !== void 0 ? _g2 : "Show more"}
                                                        `}
                                          </a>
                                      `}                        
                            </a>
                        </div>
                    ` : ""}
                </div>
            </div>
        `;
  }
}
__decorate([
  query("s-clipboard-copy")
], SCodeExample.prototype, "$copy", void 0);
__decorate([
  query(".templates")
], SCodeExample.prototype, "$templatesContainer", void 0);
function define$6(props = {}, tagName = "s-code-example", settings) {
  SCodeExample.define(tagName, SCodeExample, props, settings);
}
function base64ToBytes(base64) {
  const binString = atob(base64);
  return Uint8Array.from(binString, (m) => m.codePointAt(0));
}
function bytesToBase64(bytes) {
  const binString = Array.from(bytes, (x) => String.fromCodePoint(x)).join("");
  return btoa(binString);
}
const __base64 = {
  /**
   * @name        encrypt
   * @type        Function
   *
   * Encrypt
   *
   * @param       {String}       message        The message to encrypt
   * @return      {String}                       The encrypted message
   *
   * @since       2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  encrypt: function(message) {
    if (typeof message !== "string")
      message = fn$5(message);
    return bytesToBase64(new TextEncoder().encode(message));
  },
  /**
   * @name        decrypt
   * @type        Function
   *
   * Decrypt
   *
   * @param       {String}      message         The message to decrypt
   * @return      {String}                      The decrypted message
   *
   * @since         2.0.0
   * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)
   */
  decrypt: function(message) {
    if (typeof message !== "string")
      message = fn$5(message);
    return new TextDecoder().decode(base64ToBytes(message)).toString();
  }
};
var md5 = { exports: {} };
(function(module) {
  (function($2) {
    function safeAdd(x, y2) {
      var lsw = (x & 65535) + (y2 & 65535);
      var msw = (x >> 16) + (y2 >> 16) + (lsw >> 16);
      return msw << 16 | lsw & 65535;
    }
    function bitRotateLeft(num, cnt) {
      return num << cnt | num >>> 32 - cnt;
    }
    function md5cmn(q, a, b, x, s, t) {
      return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
    }
    function md5ff(a, b, c, d2, x, s, t) {
      return md5cmn(b & c | ~b & d2, a, b, x, s, t);
    }
    function md5gg(a, b, c, d2, x, s, t) {
      return md5cmn(b & d2 | c & ~d2, a, b, x, s, t);
    }
    function md5hh(a, b, c, d2, x, s, t) {
      return md5cmn(b ^ c ^ d2, a, b, x, s, t);
    }
    function md5ii(a, b, c, d2, x, s, t) {
      return md5cmn(c ^ (b | ~d2), a, b, x, s, t);
    }
    function binlMD5(x, len) {
      x[len >> 5] |= 128 << len % 32;
      x[(len + 64 >>> 9 << 4) + 14] = len;
      var i;
      var olda;
      var oldb;
      var oldc;
      var oldd;
      var a = 1732584193;
      var b = -271733879;
      var c = -1732584194;
      var d2 = 271733878;
      for (i = 0; i < x.length; i += 16) {
        olda = a;
        oldb = b;
        oldc = c;
        oldd = d2;
        a = md5ff(a, b, c, d2, x[i], 7, -680876936);
        d2 = md5ff(d2, a, b, c, x[i + 1], 12, -389564586);
        c = md5ff(c, d2, a, b, x[i + 2], 17, 606105819);
        b = md5ff(b, c, d2, a, x[i + 3], 22, -1044525330);
        a = md5ff(a, b, c, d2, x[i + 4], 7, -176418897);
        d2 = md5ff(d2, a, b, c, x[i + 5], 12, 1200080426);
        c = md5ff(c, d2, a, b, x[i + 6], 17, -1473231341);
        b = md5ff(b, c, d2, a, x[i + 7], 22, -45705983);
        a = md5ff(a, b, c, d2, x[i + 8], 7, 1770035416);
        d2 = md5ff(d2, a, b, c, x[i + 9], 12, -1958414417);
        c = md5ff(c, d2, a, b, x[i + 10], 17, -42063);
        b = md5ff(b, c, d2, a, x[i + 11], 22, -1990404162);
        a = md5ff(a, b, c, d2, x[i + 12], 7, 1804603682);
        d2 = md5ff(d2, a, b, c, x[i + 13], 12, -40341101);
        c = md5ff(c, d2, a, b, x[i + 14], 17, -1502002290);
        b = md5ff(b, c, d2, a, x[i + 15], 22, 1236535329);
        a = md5gg(a, b, c, d2, x[i + 1], 5, -165796510);
        d2 = md5gg(d2, a, b, c, x[i + 6], 9, -1069501632);
        c = md5gg(c, d2, a, b, x[i + 11], 14, 643717713);
        b = md5gg(b, c, d2, a, x[i], 20, -373897302);
        a = md5gg(a, b, c, d2, x[i + 5], 5, -701558691);
        d2 = md5gg(d2, a, b, c, x[i + 10], 9, 38016083);
        c = md5gg(c, d2, a, b, x[i + 15], 14, -660478335);
        b = md5gg(b, c, d2, a, x[i + 4], 20, -405537848);
        a = md5gg(a, b, c, d2, x[i + 9], 5, 568446438);
        d2 = md5gg(d2, a, b, c, x[i + 14], 9, -1019803690);
        c = md5gg(c, d2, a, b, x[i + 3], 14, -187363961);
        b = md5gg(b, c, d2, a, x[i + 8], 20, 1163531501);
        a = md5gg(a, b, c, d2, x[i + 13], 5, -1444681467);
        d2 = md5gg(d2, a, b, c, x[i + 2], 9, -51403784);
        c = md5gg(c, d2, a, b, x[i + 7], 14, 1735328473);
        b = md5gg(b, c, d2, a, x[i + 12], 20, -1926607734);
        a = md5hh(a, b, c, d2, x[i + 5], 4, -378558);
        d2 = md5hh(d2, a, b, c, x[i + 8], 11, -2022574463);
        c = md5hh(c, d2, a, b, x[i + 11], 16, 1839030562);
        b = md5hh(b, c, d2, a, x[i + 14], 23, -35309556);
        a = md5hh(a, b, c, d2, x[i + 1], 4, -1530992060);
        d2 = md5hh(d2, a, b, c, x[i + 4], 11, 1272893353);
        c = md5hh(c, d2, a, b, x[i + 7], 16, -155497632);
        b = md5hh(b, c, d2, a, x[i + 10], 23, -1094730640);
        a = md5hh(a, b, c, d2, x[i + 13], 4, 681279174);
        d2 = md5hh(d2, a, b, c, x[i], 11, -358537222);
        c = md5hh(c, d2, a, b, x[i + 3], 16, -722521979);
        b = md5hh(b, c, d2, a, x[i + 6], 23, 76029189);
        a = md5hh(a, b, c, d2, x[i + 9], 4, -640364487);
        d2 = md5hh(d2, a, b, c, x[i + 12], 11, -421815835);
        c = md5hh(c, d2, a, b, x[i + 15], 16, 530742520);
        b = md5hh(b, c, d2, a, x[i + 2], 23, -995338651);
        a = md5ii(a, b, c, d2, x[i], 6, -198630844);
        d2 = md5ii(d2, a, b, c, x[i + 7], 10, 1126891415);
        c = md5ii(c, d2, a, b, x[i + 14], 15, -1416354905);
        b = md5ii(b, c, d2, a, x[i + 5], 21, -57434055);
        a = md5ii(a, b, c, d2, x[i + 12], 6, 1700485571);
        d2 = md5ii(d2, a, b, c, x[i + 3], 10, -1894986606);
        c = md5ii(c, d2, a, b, x[i + 10], 15, -1051523);
        b = md5ii(b, c, d2, a, x[i + 1], 21, -2054922799);
        a = md5ii(a, b, c, d2, x[i + 8], 6, 1873313359);
        d2 = md5ii(d2, a, b, c, x[i + 15], 10, -30611744);
        c = md5ii(c, d2, a, b, x[i + 6], 15, -1560198380);
        b = md5ii(b, c, d2, a, x[i + 13], 21, 1309151649);
        a = md5ii(a, b, c, d2, x[i + 4], 6, -145523070);
        d2 = md5ii(d2, a, b, c, x[i + 11], 10, -1120210379);
        c = md5ii(c, d2, a, b, x[i + 2], 15, 718787259);
        b = md5ii(b, c, d2, a, x[i + 9], 21, -343485551);
        a = safeAdd(a, olda);
        b = safeAdd(b, oldb);
        c = safeAdd(c, oldc);
        d2 = safeAdd(d2, oldd);
      }
      return [a, b, c, d2];
    }
    function binl2rstr(input) {
      var i;
      var output = "";
      var length32 = input.length * 32;
      for (i = 0; i < length32; i += 8) {
        output += String.fromCharCode(input[i >> 5] >>> i % 32 & 255);
      }
      return output;
    }
    function rstr2binl(input) {
      var i;
      var output = [];
      output[(input.length >> 2) - 1] = void 0;
      for (i = 0; i < output.length; i += 1) {
        output[i] = 0;
      }
      var length8 = input.length * 8;
      for (i = 0; i < length8; i += 8) {
        output[i >> 5] |= (input.charCodeAt(i / 8) & 255) << i % 32;
      }
      return output;
    }
    function rstrMD5(s) {
      return binl2rstr(binlMD5(rstr2binl(s), s.length * 8));
    }
    function rstrHMACMD5(key, data2) {
      var i;
      var bkey = rstr2binl(key);
      var ipad = [];
      var opad = [];
      var hash2;
      ipad[15] = opad[15] = void 0;
      if (bkey.length > 16) {
        bkey = binlMD5(bkey, key.length * 8);
      }
      for (i = 0; i < 16; i += 1) {
        ipad[i] = bkey[i] ^ 909522486;
        opad[i] = bkey[i] ^ 1549556828;
      }
      hash2 = binlMD5(ipad.concat(rstr2binl(data2)), 512 + data2.length * 8);
      return binl2rstr(binlMD5(opad.concat(hash2), 512 + 128));
    }
    function rstr2hex(input) {
      var hexTab = "0123456789abcdef";
      var output = "";
      var x;
      var i;
      for (i = 0; i < input.length; i += 1) {
        x = input.charCodeAt(i);
        output += hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15);
      }
      return output;
    }
    function str2rstrUTF8(input) {
      return unescape(encodeURIComponent(input));
    }
    function rawMD5(s) {
      return rstrMD5(str2rstrUTF8(s));
    }
    function hexMD5(s) {
      return rstr2hex(rawMD5(s));
    }
    function rawHMACMD5(k, d2) {
      return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d2));
    }
    function hexHMACMD5(k, d2) {
      return rstr2hex(rawHMACMD5(k, d2));
    }
    function md52(string, key, raw) {
      if (!key) {
        if (!raw) {
          return hexMD5(string);
        }
        return rawMD5(string);
      }
      if (!raw) {
        return hexHMACMD5(key, string);
      }
      return rawHMACMD5(key, string);
    }
    if (module.exports) {
      module.exports = md52;
    } else {
      $2.md5 = md52;
    }
  })(commonjsGlobal);
})(md5);
function __i18n(str2, settings) {
  var _a2, _b2, _c2;
  const finalSettings = Object.assign({ tokens: {} }, settings !== null && settings !== void 0 ? settings : {});
  const i18n = (_a2 = SEnv2.get("i18n")) !== null && _a2 !== void 0 ? _a2 : {};
  let translation;
  if (finalSettings.id) {
    translation = (_b2 = i18n[finalSettings.id]) !== null && _b2 !== void 0 ? _b2 : get(i18n, finalSettings.id);
  }
  if (!translation) {
    translation = (_c2 = i18n[str2]) !== null && _c2 !== void 0 ? _c2 : str2;
  }
  const tokens = ` ${translation} `.match(/(__\([^__\)]*\)__|(?!\|)%[a-zA-Z0-9])/gm);
  if (!tokens) {
    return translation;
  }
  function getTokenValue(t) {
    var _a3, _b3;
    return (_b3 = (_a3 = finalSettings.tokens[t]) !== null && _a3 !== void 0 ? _a3 : finalSettings.tokens[t.replace(/^%/, "")]) !== null && _b3 !== void 0 ? _b3 : t;
  }
  let currentToken;
  tokens.forEach((token) => {
    var _a3;
    if (token.match(/^%/)) {
      currentToken = token;
      const tokenValue = getTokenValue(token);
      translation = translation.replaceAll(new RegExp(`([^(])?${token}`, "g"), `$1${tokenValue}`);
    } else {
      const tokenMatch = token.match(/\|(%[a-zA-Z0-9]+)\)__/), activeToken = (_a3 = tokenMatch === null || tokenMatch === void 0 ? void 0 : tokenMatch[1]) !== null && _a3 !== void 0 ? _a3 : currentToken, tokenValue = getTokenValue(activeToken);
      if (typeof tokenValue !== "number") {
        translation = translation.replace(token, `**(invalid token "${activeToken}" for pluralization)**`);
        return;
      }
      token = token.replace(/\\\|/gm, "_$_");
      let parts = token.split(/\|/gm);
      parts = parts.map((p) => {
        return p.replace(/_\$_/gm, "|").replace(/^__\(/, "").replace(/\)__$/, "");
      });
      token = token.replace(/_\$_/gm, "\\|");
      if (parts.length === 1) {
        translation = translation.replace(token, tokenValue > 1 ? parts[0] : "");
      } else if (parts.length === 2 && parts[0].match(/^%[a-zA-Z0-9]+/)) {
        translation = translation.replace(token, tokenValue > 1 ? parts[1] : "");
      } else if (parts.length === 2 && !parts[0].match(/^%[a-zA-Z0-9]+/)) {
        translation = translation.replace(token, tokenValue > 1 ? parts[1] : parts[0]);
      } else if (parts.length === 3) {
        translation = translation.replace(token, tokenValue > 1 ? parts[2] : parts[1]);
      }
    }
  });
  return translation;
}
class SDocComponentInterface extends SInterface {
  static get _definition() {
    return {
      endpoints: {
        type: "Object",
        description: "Specify the doc endpoints url",
        default: SSugarConfig.get("doc.endpoints")
      },
      fetchExtension: {
        type: "string",
        description: 'Specify an extension to add at the end of the fetch url like "json"',
        default: ""
      },
      loaderSvg: {
        type: "String",
        description: "Specify an svg to use as the loader",
        default: `<svg class="s-logo s-logo-coffeekraken-picto" viewBox="0 0 299 229" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M102.5 55.3151V202.802H191V229H71V29H142V55.3151H102.5Z" fill="white"/>
                        <path d="M265.5 26.3151V202.802H227.5V229H298.5V0H227.5V26.3151H265.5Z" fill="white"/>
                        <path d="M31.5 109.315V166.802H31V193H0V83H71V109.315H31.5Z" fill="white"/>
                        <path d="M173 144.5C173 159.136 162.703 171 150 171C137.297 171 127 159.136 127 144.5C127 129.864 137.297 118 150 118C167.5 118 173 129.864 173 144.5Z" fill="#FEBD0F"/>
                        <path d="M240 144.5C240 159.136 229.703 171 217 171C204.297 171 194 159.136 194 144.5C194 129.864 200.5 118 217 118C229.703 118 240 129.864 240 144.5Z" fill="#FEBD0F"/>
                        </svg>
                        `
      },
      features: {
        type: "Object",
        description: 'Specify which feature are available like "fullscreen", etc...',
        default: {
          fullscreen: true
        }
      },
      icons: {
        type: "Object",
        description: "Specify some icons for the UI",
        default: {
          file: '<i class="fa-regular fa-file"></i>',
          enterFullscreen: '<i class="fa-solid fa-expand"></i>',
          exitFullscreen: '<i class="fa-solid fa-compress"></i>',
          menu: '<i class="fa-solid fa-list-ul"></i>'
        }
      },
      i18n: {
        type: "Object",
        description: "Specify all the UI translations",
        default: {
          examplesTitle: __i18n("Examples", {
            id: "s-doc.examples.title"
          }),
          installTitle: __i18n("Install", {
            id: "s-doc.install.title"
          }),
          paramsTitle: __i18n("Parameters", {
            id: "s-doc.params.title"
          }),
          cssClassesTitle: __i18n("CSS Classes", {
            id: "s-doc.cssClasses.title"
          }),
          settingsTitle: __i18n("Settings", {
            id: "s-doc.settings.title"
          }),
          search: __i18n("Search documentation", {
            id: "s-doc.search"
          }),
          toggleFullscreen: __i18n("Toggle fullscreen", {
            id: "s-doc.fullscreen.toggle"
          })
        }
      }
    };
  }
}
const __css$3 = `
                @import url('https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css');
            @keyframes s-doc-loading {
    0% {
        opacity: 0.3;
    }
    50% {
        opacity: 1;
    }
    100% {
        opacity: 0.3;
    }
}

body:has(.s-doc-fullscreen) {
    width: 100vw;
    height: calc(100 * var(--vh,1vh)) ;
    overflow: hidden;
}

.s-doc {
    display: flex;
}

.s-doc-fullscreen {
        position: fixed !important;
        top: 50%;
        left: 50%;
        height: calc(100 * var(--vh,1vh)) ;
        width: 100vw;
        max-width: none !important;
        max-height: none !important;
        transform: translate(-50%, -50%);
        z-index: 9999;
    }

.s-doc_explorer {
        flex-grow: 0;
        flex-shrink: 0;
        align-self: stretch;
    }

.s-doc_content {
        position: relative;
        flex-grow: 1;
        width: calc(100% - 400px);
    }

@media (max-width: 639px) {

.s-doc_content {
            width: 100%
    }
}

.s-doc_body {
        height: 100%;
    }

.s-doc_color-preview {
        display: inline-block;
        width: 1em;
        height: 1em;
    }

.s-doc_loading {
        position: absolute;
        display: flex;
        align-items: center;
        justify-content: center;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: hsla(calc(var(--s-color-main-h, 0) + var(--s-color-main-surface-spin ,0)),calc((var(--s-color-main-s, 0) + var(--s-color-main-surface-saturation-offset, 0)) * 1%),calc((var(--s-color-main-l, 0) + var(--s-color-main-surface-lightness-offset, 0)) * 1%),0.6);
        animation: s-doc-loading 1s ease-in-out infinite;
    }

.s-doc_loading svg {
            max-width: 60px;
            max-height: 60px;
        }

.s-doc_example-preview {--s-shape: calc(5px * var(--s-scale, 1) * var(--s-scale-global, 1));
    }

.s-doc_toolbar {
        position: absolute;
        top: calc(var(--s-margin-default, 16) * 0.375 * 1px);
        right: calc(var(--s-margin-default, 16) * 0.375 * 1px);
    }

.s-doc {
    max-height: calc(80 * var(--vh,1vh)) ;
    max-width: 100vw;
    /* width: 90vw; */
    display: flex;
    position: relative;
    /* left: 50%;
    transform: translateX(-50%); */
}

/* @s.depth (100); */

@media (max-width: 1279px) {

.s-doc {
        max-height: none;
        display: block;
}
}

.s-doc-fullscreen {
        background: hsla(calc(var(--s-color-main-h, 0) + var(--s-color-main-background-spin ,0)),calc((var(--s-color-main-s, 0) + var(--s-color-main-background-saturation-offset, 0)) * 1%),calc((var(--s-color-main-l, 0) + var(--s-color-main-background-lightness-offset, 0)) * 1%),var(--s-color-main-background-a, 1));
    }

.s-doc_explorer {
        position: relative;
        width: 400px;
        max-height: calc(80 * var(--vh,1vh)) ;
        overflow-y: scroll;
        padding-inline-end: calc(calc(var(--s-padding-default, 16) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 1.4 * 1px);
    }

.s-doc_explorer::-webkit-scrollbar {
                width: 2px;
                height: 2px;
            }

.s-doc_explorer::-webkit-scrollbar-track {
                    
                        background-color: hsla(calc(var(--s-color-accent-h, 0) + var(--s-color-accent-spin ,0)),calc((var(--s-color-accent-s, 0)) * 1%),calc((var(--s-color-accent-l, 0)) * 1%),0.1);
                    

            }

.s-doc_explorer::-webkit-scrollbar-thumb {
                
                    background-color: hsla(calc(var(--s-color-accent-h, 0) + var(--s-color-accent-spin ,0)),calc((var(--s-color-accent-s, 0)) * 1%),calc((var(--s-color-accent-l, 0)) * 1%),0.3);
                
            }

.s-doc-fullscreen .s-doc_explorer {
            padding-block-start: calc(calc(var(--s-padding-default, 16) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 1.4 * 1px);
            padding-inline-start: calc(calc(var(--s-padding-default, 16) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 1.4 * 1px);
        }

@media (max-width: 1279px) {

.s-doc_explorer {
            background: hsla(calc(var(--s-color-main-h, 0) + var(--s-color-main-background-spin ,0)),calc((var(--s-color-main-s, 0) + var(--s-color-main-background-saturation-offset, 0)) * 1%),calc((var(--s-color-main-l, 0) + var(--s-color-main-background-lightness-offset, 0)) * 1%),var(--s-color-main-background-a, 1));
            padding-inline-start: calc(calc(var(--s-padding-default, 16) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 1.4 * 1px);
            padding-block: calc(calc(var(--s-padding-default, 16) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 1.4 * 1px);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: calc(100 * var(--vh,1vh)) ;
            max-height: calc(100 * var(--vh,1vh)) ;
            z-index: 50;
            transform: translateX(-100%);transition: all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995) !important;
    }

            .s-doc_explorer:focus,
            .s-doc_explorer:focus-within {
                transform: translateX(0);
            }
}

.s-doc-fullscreen .s-doc_explorer {
        max-height: none;
    }

.s-doc_menu-btn {
        display: none;
        position: fixed;
        bottom: calc(var(--s-margin-default, 16) * 1.4 * 1px);
        right: calc(var(--s-margin-default, 16) * 1.4 * 1px);
        /* background: s.color(main, surface); */
        padding: calc(calc(var(--s-padding-default, 16) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 1.4 * 1px);
        z-index: 100;border-radius: calc(5px * var(--s-scale, 1) * var(--s-scale-global, 1));
    }

@media (max-width: 1279px) {

.s-doc_menu-btn {
            display: block
    }
}

.s-doc_category {
        position: relative;
        cursor: pointer;
    }

.s-doc_category > div {
            padding: calc(calc(var(--s-padding-default, 16) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 1.4 * 1px) calc(calc(var(--s-padding-default, 16) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 2 * 1px) !important;transition: all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995) !important;border-radius: var(--s-shape, calc(var(--s-border-radius-default, 5px) * var(--s-scale, 1) * var(--s-scale-global, 1)));
        }

.s-doc_category > div > i {
                margin-inline-end: calc(var(--s-margin-default, 16) * 0.375 * 1px);
                position: relative;
                top: -2px;transition: all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995);
            }

.s-doc_category.active > div > span {
            font-weight: bold;
        }

.s-doc_category:hover > div {
            background: hsla(calc(var(--s-color-main-h, 0) + var(--s-color-main-surface-spin ,0)),calc((var(--s-color-main-s, 0) + var(--s-color-main-surface-saturation-offset, 0)) * 1%),calc((var(--s-color-main-l, 0) + var(--s-color-main-surface-lightness-offset, 0)) * 1%),0.3);
        }

.s-doc_category:active > div,
        .s-doc_category.active > div {
            background: hsla(calc(var(--s-color-main-h, 0) + var(--s-color-main-surface-spin ,0)),calc((var(--s-color-main-s, 0) + var(--s-color-main-surface-saturation-offset, 0)) * 1%),calc((var(--s-color-main-l, 0) + var(--s-color-main-surface-lightness-offset, 0)) * 1%),0.5);
        }

.s-doc_category:active > div > i, .s-doc_category.active > div > i {
                color: hsla(calc(var(--s-color-complementary-h, 0) + var(--s-color-complementary-spin ,0)),calc((var(--s-color-complementary-s, 0)) * 1%),calc((var(--s-color-complementary-l, 0) + 20) * 1%),1);
            }

.s-doc_categories {
    }

/* &_items {
        display: none;
    }
    &_category.active &_items {
        display: block;
    } */

.s-doc_item > div {
            padding: calc(calc(calc(var(--s-padding-default, 16) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 1.4 * 1px) * 0.6) calc(calc(var(--s-padding-default, 16) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 1.4 * 1px)
                calc(calc(calc(var(--s-padding-default, 16) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 1.4 * 1px) * 0.6) calc(calc(var(--s-padding-default, 16) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 3.5 * 1px);
        }

.s-doc_item > div > span {
                /* font-size: 0.9em; */
                opacity: 0.8;transition: all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995) !important;
            }

.s-doc_item:hover > div > span {
            color: hsla(calc(var(--s-color-accent-h, 0) + var(--s-color-accent-spin ,0)),calc((var(--s-color-accent-s, 0)) * 1%),calc((var(--s-color-accent-l, 0)) * 1%),var(--s-color-accent-a, 1));
        }

.s-doc_item.active > div > span {
            color: hsla(calc(var(--s-color-accent-h, 0) + var(--s-color-accent-spin ,0)),calc((var(--s-color-accent-s, 0)) * 1%),calc((var(--s-color-accent-l, 0)) * 1%),var(--s-color-accent-a, 1));
            opacity: 1;
        }

.s-doc_search {
        position: sticky !important;
        z-index: 1;
        top: 0;
        display: block;
        background: hsla(calc(var(--s-color-main-h, 0) + var(--s-color-main-background-spin ,0)),calc((var(--s-color-main-s, 0) + var(--s-color-main-background-saturation-offset, 0)) * 1%),calc((var(--s-color-main-l, 0) + var(--s-color-main-background-lightness-offset, 0)) * 1%),var(--s-color-main-background-a, 1)) !important;
        margin-block-end: calc(var(--s-margin-default, 16) * 0.75 * 1px);
    }

.s-doc_search i {
            opacity: 0.3;
        }

.s-doc_search-input {
        display: block;
        width: 100%;
        padding: calc(calc(var(--s-padding-default, 16) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 1.4 * 1px) calc(calc(var(--s-padding-default, 16) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 2 * 1px);
        background: hsla(calc(var(--s-color-main-h, 0) + var(--s-color-main-surface-spin ,0)),calc((var(--s-color-main-s, 0) + var(--s-color-main-surface-saturation-offset, 0)) * 1%),calc((var(--s-color-main-l, 0) + var(--s-color-main-surface-lightness-offset, 0)) * 1%),var(--s-color-main-surface-a, 1));border-radius: var(--s-shape, calc(var(--s-border-radius-default, 5px) * var(--s-scale, 1) * var(--s-scale-global, 1)));
    }

.s-doc_content {
    }

.s-doc_body {
        display: flex;
        flex-direction: column;
        gap: calc(var(--s-margin-default, 16) * 3.5 * 1px);
        padding: calc(calc(var(--s-padding-default, 16) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 3.5 * 1px);
        overflow-y: auto;border-radius: calc(5px * var(--s-scale, 1) * var(--s-scale-global, 1));
    }

.s-doc_body::-webkit-scrollbar {
                width: 2px;
                height: 2px;
            }

.s-doc_body::-webkit-scrollbar-track {
                    
                        background-color: hsla(calc(var(--s-color-accent-h, 0) + var(--s-color-accent-spin ,0)),calc((var(--s-color-accent-s, 0)) * 1%),calc((var(--s-color-accent-l, 0)) * 1%),0.1);
                    

            }

.s-doc_body::-webkit-scrollbar-thumb {
                
                    background-color: hsla(calc(var(--s-color-accent-h, 0) + var(--s-color-accent-spin ,0)),calc((var(--s-color-accent-s, 0)) * 1%),calc((var(--s-color-accent-l, 0)) * 1%),0.3);
                
            }

@media (max-width: 639px) {

.s-doc_body {
            padding: calc(calc(var(--s-padding-default, 16) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 1.4 * 1px);
    }
}

.s-doc_body > * {
            max-width: 960px;
        }

.s-doc_file {
        display: inline-block;
        padding: calc(calc(var(--s-padding-default, 16) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 1.4 * 1px);
        background: hsla(calc(var(--s-color-main-h, 0) + var(--s-color-main-background-spin ,0)),calc((var(--s-color-main-s, 0) + var(--s-color-main-background-saturation-offset, 0)) * 1%),calc((var(--s-color-main-l, 0) + var(--s-color-main-background-lightness-offset, 0)) * 1%),var(--s-color-main-background-a, 1));border-radius: calc(5px * var(--s-scale, 1) * var(--s-scale-global, 1));
    }

.s-doc_file span {
            color: hsla(calc(var(--s-color-info-h, 0) + var(--s-color-info-text-spin ,0)),calc((var(--s-color-info-s, 0) + var(--s-color-info-text-saturation-offset, 0)) * 1%),calc((var(--s-color-info-l, 0) + var(--s-color-info-text-lightness-offset, 0)) * 1%),var(--s-color-info-text-a, 1));
        }

.s-doc_file i {
            margin-inline-end: calc(var(--s-margin-default, 16) * 0.75 * 1px);
        }

.s-doc .s-code-example {
        max-width: 960px;
    }

@media (max-width: 1279px) {

.s-doc_toolbar {
            display: none
    }
}

.s-doc_toolbar > button {
        padding: calc(calc(var(--s-padding-default, 16) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 1.4 * 1px);
        background: hsla(calc(var(--s-color-main-h, 0) + var(--s-color-main-surface-spin ,0)),calc((var(--s-color-main-s, 0) + var(--s-color-main-surface-saturation-offset, 0)) * 1%),calc((var(--s-color-main-l, 0) + var(--s-color-main-surface-lightness-offset, 0)) * 1%),var(--s-color-main-surface-a, 1));transition: all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995);border-radius: var(--s-shape, calc(var(--s-border-radius-default, 5px) * var(--s-scale, 1) * var(--s-scale-global, 1)));
    }

.s-doc_toolbar > button:hover {
            background: hsla(calc(var(--s-color-main-h, 0) + var(--s-color-main-surface-spin ,0)),calc((var(--s-color-main-s, 0) + var(--s-color-main-surface-saturation-offset, 0)) * 1%),calc((var(--s-color-main-l, 0) + var(--s-color-main-surface-lightness-offset, 0)) * 1%),var(--s-color-main-surface-a, 1));
        }

.s-doc_metas {
    }

.s-doc_title {display: block;font-family: var(--s-font-family-title-font-family, "Roboto"); 
 font-weight: var(--s-font-family-title-font-weight, 500);font-size: calc(var(--s-font-size-default, 16) * calc(var(--s-font-size-60, 2.5) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 1px);
line-height: 1.3;
max-width: 55ch;
    }

@media (max-width: 639px) {

.s-doc_title {font-size: calc(var(--s-font-size-default, 16) * calc(var(--s-font-size-50, 1.8) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 1px);
    }
}

.s-doc_section-title {display: block;font-family: var(--s-font-family-title-font-family, "Roboto"); 
 font-weight: var(--s-font-family-title-font-weight, 500);font-size: calc(var(--s-font-size-default, 16) * calc(var(--s-font-size-50, 1.8) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 1px);
line-height: 1.3;
max-width: 55ch;
    }

@media (max-width: 639px) {

.s-doc_section-title {font-size: calc(var(--s-font-size-default, 16) * calc(var(--s-font-size-40, 1.4) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 1px);
    }
}

.s-doc_classes-title,
    .s-doc_example-title {display: block;font-family: var(--s-font-family-title-font-family, "Roboto"); 
 font-weight: var(--s-font-family-title-font-weight, 500);font-size: calc(var(--s-font-size-default, 16) * calc(var(--s-font-size-40, 1.4) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 1px);
line-height: 1.3;
max-width: 55ch;
    }

@media (max-width: 639px) {

.s-doc_classes-title,
    .s-doc_example-title {font-size: calc(var(--s-font-size-default, 16) * calc(var(--s-font-size-30, 1.1) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 1px);
    }
}

.s-doc_status {
        position: relative;
        top: -0.5em;
        font-size: 0.3em !important;
    }

.s-doc_description {display: block;font-family: var(--s-font-family-default-font-family, "Roboto"); 
 font-weight: var(--s-font-family-default-font-weight, 400);font-size: calc(var(--s-font-size-default, 16) * calc(var(--s-font-size-40, 1.4) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 1px);
line-height: 1.6;
max-width: 55ch;
    }

@media (max-width: 639px) {

.s-doc_description {font-size: calc(var(--s-font-size-default, 16) * calc(var(--s-font-size-40, 1.4) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 1px);
    }
}

.s-doc_section {
        margin-block-start: calc(var(--s-margin-default, 16) * 3.5 * 1px);
    }

.s-doc_color-preview {border-radius: calc(5px * var(--s-scale, 1) * var(--s-scale-global, 1));
    }

.s-doc_configs,
    .s-doc_params {
    }

.s-doc_param {
    }

.s-doc_config-metas,
    .s-doc_classes-metas,
    .s-doc_param-metas {
        display: flex;
        gap: calc(var(--s-margin-default, 16) * 1.4 * 1px);
        background: hsla(calc(var(--s-color-main-h, 0) + var(--s-color-main-surface-spin ,0)),calc((var(--s-color-main-s, 0) + var(--s-color-main-surface-saturation-offset, 0)) * 1%),calc((var(--s-color-main-l, 0) + var(--s-color-main-surface-lightness-offset, 0)) * 1%),var(--s-color-main-surface-a, 1));
        padding: calc(calc(var(--s-padding-default, 16) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 1.4 * 1px);border-radius: calc(5px * var(--s-scale, 1) * var(--s-scale-global, 1));
    }

.s-doc_config-name,
    .s-doc_classes-name,
    .s-doc_param-name {
        color: hsla(calc(var(--s-color-accent-h, 0) + var(--s-color-accent-text-spin ,0)),calc((var(--s-color-accent-s, 0) + var(--s-color-accent-text-saturation-offset, 0)) * 1%),calc((var(--s-color-accent-l, 0) + var(--s-color-accent-text-lightness-offset, 0)) * 1%),var(--s-color-accent-text-a, 1));
        flex-grow: 1;
    }

.s-doc_config-default,
    .s-doc_param-default {
        display: inline-flex;
        gap: calc(var(--s-margin-default, 16) * 0.375 * 1px);
    }

.s-doc_config-default ._value, .s-doc_param-default ._value {
            opacity: 0.6;
        }

.s-doc_config-type,
    .s-doc_param-type {
        color: hsla(calc(var(--s-color-info-h, 0) + var(--s-color-info-spin ,0)),calc((var(--s-color-info-s, 0)) * 1%),calc((var(--s-color-info-l, 0)) * 1%),var(--s-color-info-a, 1));
    }

.s-doc_config-description,
    .s-doc_classes-description,
    .s-doc_param-description {
        padding: calc(calc(var(--s-padding-default, 16) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 1.4 * 1px);display: block;font-family: var(--s-font-family-default-font-family, "Roboto"); 
 font-weight: var(--s-font-family-default-font-weight, 400);font-size: calc(var(--s-font-size-default, 16) * calc(var(--s-font-size-30, 1.1) * var(--s-scale, 1) * var(--s-scale-global, 1)) * 1px);
line-height: 1.8;
max-width: 55ch;
color: hsla(calc(var(--s-color-main-h, 0) + var(--s-color-main-text-spin ,0)),calc((var(--s-color-main-s, 0) + var(--s-color-main-text-saturation-offset, 0)) * 1%),calc((var(--s-color-main-l, 0) + var(--s-color-main-text-lightness-offset, 0)) * 1%),0.7);
    }

@media (max-width: 1279px) {

html:has(.s-doc_explorer:focus, .s-doc_explorer:focus-within),
body:has(.s-doc_explorer:focus, .s-doc_explorer:focus-within) {
        overflow: hidden
}
}
`;
var __awaiter$3 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SDocComponent extends SLitComponent {
  static get properties() {
    return SLitComponent.propertiesFromInterface({}, SDocComponentInterface);
  }
  static get styles() {
    return css$1`
            ${unsafeCSS(__css$3)}
        `;
  }
  static get state() {
    return {};
  }
  constructor() {
    super(__deepMerge({
      name: "s-doc",
      interface: SDocComponentInterface
    }));
    this._status = {
      loading: false,
      fullscreen: false
    };
    this._items = {};
  }
  mount() {
    return __awaiter$3(this, void 0, void 0, function* () {
      this._registerShortcuts();
      const request = yield fetch(`${this.props.endpoints.base}${this.props.fetchExtension ? `.${this.props.fetchExtension}` : ""}`, {}), categories = yield request.json();
      this._categories = categories;
      window.addEventListener("hashchange", (e) => {
        const potentialItem = this._items[document.location.hash.replace(/^#/, "")];
        if (potentialItem) {
          this._goTo(potentialItem);
        }
      });
      this.requestUpdate();
    });
  }
  firstUpdated() {
    return __awaiter$3(this, void 0, void 0, function* () {
      this._$searchInput = this.querySelector(`.${this.utils.cls("_search-input")}`);
      this._$explorer = this.querySelector(`.${this.utils.cls("_explorer")}`);
      this._$menuBtn = this.querySelector(`.${this.utils.cls("_menu-btn")}`);
      document.body.appendChild(this._$menuBtn);
      this._$body = this.querySelector(`.${this.utils.cls("_body")}`);
    });
  }
  /**
   * Register some shortcuts
   */
  _registerShortcuts() {
    __hotkey("ctrl+d", {
      title: "Documentation",
      description: "Access the documentation easily"
    }).on("press", (e) => {
      this._toggleFullscreen();
    });
    __hotkey("ctrl+f", {
      title: "Search",
      description: "Search the documentation"
    }).on("press", (e) => {
      var _a2;
      (_a2 = this._$searchInput) === null || _a2 === void 0 ? void 0 : _a2.focus();
    });
  }
  /**
   * Go to a specific doc item
   */
  _goTo(itemObj) {
    var _a2, _b2;
    return __awaiter$3(this, void 0, void 0, function* () {
      this._loadItem(itemObj);
      yield __wait(100);
      (_b2 = (_a2 = document.activeElement) === null || _a2 === void 0 ? void 0 : _a2.blur) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
      __scrollTo(this._$body, {
        offset: 100
      });
    });
  }
  _loadItem(itemObj) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!itemObj.cache) {
        itemObj.loading = true;
        this._status.loading = true;
        this.requestUpdate();
        const request = yield fetch(`${this.props.endpoints.base}${this.props.endpoints.item.replace(":id", itemObj.id)}${this.props.fetchExtension ? `.${this.props.fetchExtension}` : ""}`), item = yield request.json();
        itemObj.cache = item;
      }
      this._item = null;
      this.requestUpdate();
      setTimeout(() => {
        var _a2, _b2;
        itemObj.loading = false;
        this._status.loading = false;
        this._item = itemObj.cache;
        this.requestUpdate();
        (_b2 = (_a2 = this._$body) === null || _a2 === void 0 ? void 0 : _a2.scrollTo) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, {
          top: 0,
          behavior: "smooth"
        });
      });
    });
  }
  _loadCategoryItems(category, loadFirstItem = false) {
    var _a2, _b2;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (category._loading) {
        return;
      }
      category._loading = true;
      this._status.loading = true;
      const request = yield fetch(`${this.props.endpoints.base}${this.props.endpoints.items}/${__base64.encrypt(JSON.stringify(category.filters))}${this.props.fetchExtension ? `.${this.props.fetchExtension}` : ""}`), items = yield request.json();
      this._items = Object.assign(Object.assign({}, this._items), items);
      const potentialItem = items[(_b2 = (_a2 = document.location.hash) === null || _a2 === void 0 ? void 0 : _a2.replace) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, /^#/, "")];
      if (potentialItem) {
        this._goTo(potentialItem);
      }
      category.items = items;
      if (!potentialItem && loadFirstItem) {
        const firstItemId = Object.keys(items)[0];
        this._loadItem(items[firstItemId]);
      } else {
        this._status.loading = false;
        this.requestUpdate();
      }
    });
  }
  _search(value) {
    this._searchValue = value;
    this.requestUpdate();
  }
  _exitFullscreen() {
    this._$placeholder.after(this);
    this._$placeholder.remove();
    this.classList.remove(this.utils.cls("-fullscreen"));
    this._status.fullscreen = false;
    this.requestUpdate();
    window.scrollTo({
      top: this.getBoundingClientRect().top - 200
    });
  }
  _enterFullscreen() {
    escapeQueue(() => {
      this._exitFullscreen();
    }, {
      id: "s-doc"
    });
    this._$placeholder = document.createElement("div");
    this.before(this._$placeholder);
    document.body.appendChild(this);
    this.classList.add(this.utils.cls("-fullscreen"));
    this._status.fullscreen = true;
    this.requestUpdate();
  }
  _toggleFullscreen() {
    if (this._status.fullscreen) {
      this._exitFullscreen();
    } else {
      this._enterFullscreen();
    }
  }
  _renderItems(items) {
    let searchReg;
    if (this._searchValue) {
      searchReg = new RegExp(this._searchValue.replace(/\s/gm, "|"), "gi");
    }
    return html`
            <ul role="group" class="${this.utils.cls("_items")}">
                ${__unique(Object.keys(items)).sort((a, b) => {
      const aObj = items[a], bObj = items[b];
      if (aObj.name < bObj.name) {
        return -1;
      }
      if (aObj.name > bObj.name) {
        return 1;
      }
      return 0;
    }).map((namespace) => {
      var _a2, _b2, _c2;
      const itemObj = items[namespace];
      if (this._searchValue && !searchReg.test(itemObj.id)) {
        return;
      }
      return html`
                            <li
                                role="treeitem"
                                class="${this.utils.cls("_item")} ${((_a2 = this._item) === null || _a2 === void 0 ? void 0 : _a2.id) === itemObj.id ? "active" : ""}"
                                tabindex="0"
                                @pointerup=${(e) => __awaiter$3(this, void 0, void 0, function* () {
        e.stopPropagation();
        document.location.hash = itemObj.id;
        this._goTo(itemObj);
      })}
                            >
                                <div>
                                    ${itemObj.loading ? html`
                                              <div
                                                  class="s-loader:square-dots ${this.utils.cls(null, "s-color:accent s-mie:10")}"
                                              ></div>
                                          ` : ""}
                                    <span>
                                        ${this._searchValue ? html`
                                                  ${unsafeHTML(__replaceChunks((_b2 = itemObj.as) !== null && _b2 !== void 0 ? _b2 : itemObj.name, this._searchValue.split(" "), (chunk) => {
        return `<span class="s-tc-accent">${chunk}</span>`;
      }))}
                                              ` : (_c2 = itemObj.as) !== null && _c2 !== void 0 ? _c2 : itemObj.name}
                                    </span>
                                </div>
                            </li>
                        `;
    })}
            </ul>
        `;
  }
  _renderItemDefault(itemObj) {
    var _a2;
    let addon = "";
    if (__isColor((_a2 = itemObj.default) !== null && _a2 !== void 0 ? _a2 : "")) {
      addon = unsafeHTML(`<span class="${this.utils.cls("_color-preview")}" style="background: ${itemObj.default}"></span>`);
    }
    return html`
            ${itemObj.default !== void 0 && itemObj.default !== "undefined" ? html`
                      <div class="${this.utils.cls("_config-default")}">
                          <span class="_value">${itemObj.default}</span>
                          ${addon ? html` <span class="_addon">${addon}</span> ` : ""}
                      </div>
                  ` : ""}
        `;
  }
  _renderItemMetas(itemObj) {
    var _a2, _b2, _c2, _d2;
    return html`
            <header class="${this.utils.cls("_metas")}">
                ${itemObj.name ? html`
                          <h1 class="${this.utils.cls("_title", "s-mbe-30")}">
                              ${(_a2 = itemObj.as) !== null && _a2 !== void 0 ? _a2 : itemObj.name}
                              ${itemObj.status ? html` <span
                                        class="${this.utils.cls("_status", `s-badge s-color:${itemObj.status === "stable" ? "success" : itemObj.status === "beta" ? "accent" : "error"}`)}"
                                        >${itemObj.status}</span
                                    >` : ""}
                          </h1>
                      ` : ""}
                ${((_d2 = (_c2 = (_b2 = itemObj.type) === null || _b2 === void 0 ? void 0 : _b2.raw) === null || _c2 === void 0 ? void 0 : _c2.toLowerCase) === null || _d2 === void 0 ? void 0 : _d2.call(_c2)) === "config" ? html`
                          <div class="${this.utils.cls("_file", "s-mbe-30")}">
                              ${unsafeHTML(this.props.icons.file)}
                              <span>.sugar/${itemObj.name}.config.ts</span>
                          </div>
                      ` : ""}
                ${itemObj.description ? html`
                <p class="${this.utils.cls("_description", "s-mbe-30")}">${itemObj.description}</h1>
            ` : ""}
            </header>
        `;
  }
  _renderItemConfig(configObj) {
    var _a2, _b2;
    return html`
            <div class="${this.utils.cls("_section _config")}">
                <div class="${this.utils.cls("_config-metas")}">
                    <div class="${this.utils.cls("_config-name")}">
                        ${configObj.id.replace(/^.*\.config\./, "")}
                    </div>
                    ${this._renderItemDefault(configObj)}
                    <div class="${this.utils.cls("_config-type")}">
                        ${(_b2 = (_a2 = configObj.type) === null || _a2 === void 0 ? void 0 : _a2.raw) !== null && _b2 !== void 0 ? _b2 : configObj.type}
                    </div>
                </div>
                <p class="${this.utils.cls("_param-description")}">
                    ${configObj.description}
                </p>
            </div>
        `;
  }
  _renderItemCssClasses(itemObj) {
    return html`
            <div class="${this.utils.cls("_section _css-classes")}">
                <h2
                    class="${this.utils.cls("_section-title _classes-title", "s-mbe-30")}"
                >
                    ${this.props.i18n.cssClassesTitle}
                </h2>
            </div>
            ${Object.keys(itemObj.cssClasses).map((cls) => {
      const clsObj = itemObj.cssClasses[cls];
      return html`
                    <div class="${this.utils.cls("_classes")}">
                        <div class="${this.utils.cls("_classes-metas")}">
                            <div class="${this.utils.cls("_classes-name")}">
                                ${clsObj.name}
                            </div>
                        </div>
                        <p class="${this.utils.cls("_classes-description")}">
                            ${clsObj.description}
                        </p>
                    </div>
                `;
    })}
        `;
  }
  _renderItemParams(itemObj) {
    return html`
            <div class="${this.utils.cls("_section _params")}">
                <h2 class="${this.utils.cls("_section-title", "s-mbe-30")}">
                    ${this.props.i18n.paramsTitle}
                </h2>
                ${Object.keys(itemObj.param).map((param) => {
      var _a2, _b2;
      const paramObj = itemObj.param[param];
      return html`
                        <div class="${this.utils.cls("_param")}">
                            <div class="${this.utils.cls("_param-metas")}">
                                <div class="${this.utils.cls("_param-name")}">
                                    ${paramObj.name}
                                    ${paramObj.required ? html`<span
                                              class="${this.utils.cls("_required", "s-required")}"
                                          ></span>` : ""}
                                </div>
                                ${this._renderItemDefault(paramObj)}
                                <div class="${this.utils.cls("_param-type")}">
                                    ${(_b2 = (_a2 = paramObj.type) === null || _a2 === void 0 ? void 0 : _a2.raw) !== null && _b2 !== void 0 ? _b2 : paramObj.type}
                                </div>
                            </div>
                            <p class="${this.utils.cls("_param-description")}">
                                ${paramObj.description}
                            </p>
                        </div>
                    `;
    })}
            </div>
        `;
  }
  _renderItemInstall(itemObj) {
    var _a2;
    if (!((_a2 = itemObj.install) === null || _a2 === void 0 ? void 0 : _a2.length)) {
      return "";
    }
    return html`
            <div class="${this.utils.cls("_section _install")}">
                <h2 class="${this.utils.cls("_section-title", "s-mbe-30")}">
                    ${this.props.i18n.installTitle}
                </h2>

                <s-code-example bare=${this.props.bare}>
                    <code language="${itemObj.install[0].language}">
                        ${itemObj.install[0].code}
                    </code>
                </s-code-example>
            </div>
        `;
  }
  _renderItemExamples(itemObj) {
    return html`
            ${itemObj.example ? html`
                      <div class="${this.utils.cls("_section _examples")}">
                          <h2
                              class="${this.utils.cls("_section-title", "s-mbe-30")}"
                          >
                              ${this.props.i18n.examplesTitle}
                          </h2>
                          ${itemObj.example.map((example) => {
      var _a2, _b2;
      return html`
                                  <div
                                      class="${this.utils.cls("_example", "s-mbe-50")}"
                                  >
                                      <h3
                                          class="${this.utils.cls("_example-title", "s-mbe-50")}"
                                      >
                                          ${__upperFirst((_a2 = example.title) !== null && _a2 !== void 0 ? _a2 : "")}
                                      </h3>
                                      ${((_b2 = itemObj.type.raw) === null || _b2 === void 0 ? void 0 : _b2.toLowerCase()) === "styleguide" ? html`<div
                                                class="${this.utils.cls("_example-preview", "s-mbe-50")}"
                                            >
                                                ${unsafeHTML(example.code)}
                                            </div>` : ""}
                                      <s-code-example bare=${this.props.bare}>
                                          <code language="${example.language}">
                                              ${example.code}
                                          </code>
                                      </s-code-example>
                                  </div>
                              `;
    })}
                      </div>
                  ` : ""}
        `;
  }
  _renderItem(itemObj) {
    var _a2, _b2, _c2;
    if (itemObj.docHtml) {
      return html`
                <div class="s-format:text s-rhythm:vertical">
                    ${unsafeHTML(itemObj.docHtml)}
                </div>
            `;
    }
    if (itemObj.type.raw.toLowerCase() === "config") {
      return html`
                ${this._renderItemMetas(itemObj)}

                <div class="${this.utils.cls("_configs")}">
                    ${itemObj.docblocks.slice(1).map((configObj) => html`
                                ${this._renderItemConfig(configObj)}
                            `)}
                </div>
            `;
    }
    itemObj.cssClasses = (_a2 = itemObj.docblocks[0]) === null || _a2 === void 0 ? void 0 : _a2.cssClass;
    return html`
            <div
                s-deps
                css="${__camelCase((_c2 = (_b2 = itemObj.namespace) === null || _b2 === void 0 ? void 0 : _b2.split) === null || _c2 === void 0 ? void 0 : _c2.call(_b2, ".").pop())}"
            >
                ${this._renderItemMetas(itemObj)}
                ${this._renderItemInstall(itemObj)}
                ${this._renderItemExamples(itemObj)}
                ${itemObj.param ? this._renderItemParams(itemObj) : ""}
                ${itemObj.cssClasses ? this._renderItemCssClasses(itemObj) : ""}
            </div>
        `;
  }
  _renderCategories(categories, role = "tree") {
    return html`
            <ul role="${role}" class="${this.utils.cls("_categories")}">
                ${Object.keys(categories).map((categoryId, i) => {
      const categoryObj = categories[categoryId];
      if (!categoryObj.items && !categoryObj.children) {
        if (!this._firstCategory) {
          this._loadCategoryItems(categoryObj, true);
        } else {
          this._loadCategoryItems(categoryObj);
        }
      }
      if (!this._firstCategory) {
        categoryObj.selected = true;
        this._firstCategory = categoryObj;
      }
      return html`
                        <li
                            role="treeitem"
                            class="${this.utils.cls("_category")} ${categoryObj.selected || this._searchValue ? "active" : ""}"
                            tabindex="0"
                            @pointerup=${(e) => {
        e.stopPropagation();
        categoryObj.selected = !categoryObj.selected;
        this.requestUpdate();
      }}
                        >
                            <div>
                                ${categoryObj.selected ? html`
                                          <i class="s-icon:folder-opened"></i>
                                      ` : html` <i class="s-icon:folder"></i> `}
                                <span> ${categoryObj.title} </span>
                            </div>
                            ${categoryObj.selected && categoryObj.children ? html`
                                      ${this._renderCategories(categoryObj.children, "group")}
                                  ` : (categoryObj.selected || this._searchValue) && categoryObj.items ? html`
                                      ${this._renderItems(categoryObj.items)}
                                  ` : ""}
                        </li>
                    `;
    })}
            </ul>
        `;
  }
  render() {
    return html`
            <button
                class="${this.utils.cls("_menu-btn")}"
                @pointerup=${(e) => __awaiter$3(this, void 0, void 0, function* () {
      e.preventDefault();
      yield __wait(100);
      this._$explorer.focus();
    })}
            >
                ${unsafeHTML(this.props.icons.menu)}
            </button>
            <div class="${this.utils.cls("_explorer")}" tabindex="0">
                <label
                    class="${this.utils.cls("_search", "s-input-container-addon")}"
                >
                    <input
                        type="text"
                        name="search"
                        placeholder="${this.props.i18n.search} (CTRL+f)"
                        class="${this.utils.cls("_search-input")}"
                        @keyup=${(e) => {
      this._search(e.target.value);
    }}
                    />
                    <div>
                        <i class="s-icon:search"></i>
                    </div>
                </label>
                ${this._renderCategories(this._categories)}
            </div>

            <div class="${this.utils.cls("_content")}">
                <div class="${this.utils.cls("_body")}" tabindex="0">
                    ${this._item ? html` ${this._renderItem(this._item)} ` : ""}
                </div>
                <div class="${this.utils.cls("_toolbar")}">
                    ${this.props.features.fullscreen ? html`
                              <button
                                  class="${this.utils.cls("_fullscreen-btn")}"
                                  aria-label="Toggle documentation fullscreen mode"
                                  title="${this.props.i18n.toggleFullscreen} (CTRL+D"
                                  @pointerup=${(e) => {
      e.stopPropagation();
      this._toggleFullscreen();
    }}
                              >
                                  ${this._status.fullscreen ? html`
                                            ${unsafeHTML(this.props.icons.exitFullscreen)}
                                        ` : html`
                                            ${unsafeHTML(this.props.icons.enterFullscreen)}
                                        `}
                              </button>
                          ` : ""}
                </div>
                ${this._status.loading ? html`
                          <div class="${this.utils.cls("_loading")}">
                              ${unsafeHTML(this.props.loaderSvg)}
                          </div>
                      ` : ""}
            </div>
        `;
  }
}
function define$5(props = {}, tagName = "s-doc", settings) {
  SDocComponent.define(tagName, SDocComponent, props, settings);
}
class SGaugeComponentInterface extends SInterface {
  static get _definition() {
    return {
      min: {
        type: "Number",
        title: "Min",
        description: "Min value",
        default: 0
      },
      start: {
        type: "Number",
        title: "Start",
        description: "Start degree",
        default: 0
      },
      end: {
        type: "Number",
        title: "End",
        description: "End degree",
        default: 360
      },
      max: {
        type: "Number",
        title: "Max",
        description: "Max value",
        default: 100
      },
      value: {
        type: "String|Number",
        title: "Value",
        description: "Actual value between the min and the max one",
        required: true
      },
      classes: {
        type: "Object",
        title: "Classes",
        description: "Specify a class to be added if the actual gauge value is above it. The check number has to be a percentage",
        default: {
          low: 0,
          medium: 33,
          high: 66
        }
      },
      linecap: {
        type: "String",
        title: "Linecap",
        description: "Specify the shape you want a the end of the geuge line",
        values: ["butt", "square", "round"],
        default: "round"
      }
    };
  }
}
const __css$2 = "\n                @import url('https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css');\n            .s-gauge {\n    --stroke-width: 0.33em;\n\n    display: block;\n    position: relative;\n    width: 1em;\n    height: 1em;\n    font-size: 150px;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n            user-select: none;\n    stroke-width: calc(\n        var(--stroke-width) * 0.5\n    );\n} /* only for js to get the computed stroke width */ .s-gauge svg {\n        --dash-circle: calc(2 * 3.14 * 0.5em);\n        --dash-length: calc(\n            var(--dash-circle) / 360 * (var(--end-degree) - var(--start-degree))\n        );\n        transform: rotateZ(calc(90deg + var(--start-degree) * 1deg));\n        color: red;\n    } .s-gauge path {\n        stroke-width: calc(var(--stroke-width) * 0.5);\n        stroke-dasharray: calc(2 * 3.14 * 0.5em);\n        transform-origin: 50% 50%;\n    } .s-gauge ._track {\n        stroke: rgba(0, 0, 0, 0.1);\n        stroke-dashoffset: calc((var(--dash-circle) - var(--dash-length)));\n    } .s-gauge ._gauge {\n        stroke: currentColor;\n        stroke-dashoffset: calc(\n            (\n                var(--dash-circle) -\n                    (var(--dash-length) / 100 * var(--value-percent))\n            )\n        );\n    } .s-gauge ._value {\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        font-size: 0.25em;\n        transform: translate(-50%, -50%);\n    }\n";
class SGaugeComponent extends SLitComponent {
  static get properties() {
    return SLitComponent.propertiesFromInterface({}, SGaugeComponentInterface);
  }
  static get styles() {
    return css$1`
            ${unsafeCSS(__css$2)}
        `;
  }
  static get state() {
    return {};
  }
  constructor() {
    super(__deepMerge({
      name: "s-gauge",
      interface: SGaugeComponentInterface
    }));
  }
  render() {
    const value = parseFloat(this.props.value);
    const boundings = this.getBoundingClientRect(), strokeWidth = parseFloat(window.getComputedStyle(this).strokeWidth), scale = 1 / (boundings.width + strokeWidth) * boundings.width, valuePercent = 100 / this.props.max * parseFloat(this.props.value);
    for (let [cls, percentage] of Object.entries(this.props.classes)) {
      if (100 / this.props.max * value >= percentage) {
        this.classList.add(cls);
      } else {
        this.classList.remove(cls);
      }
    }
    return html`
            <svg
                style="--start-degree: ${this.props.start}; --end-degree: ${this.props.end}; --value-percent: ${valuePercent};"
                viewBox="0 0 ${boundings.width} ${boundings.height}"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
            >
                <path
                    class="_track"
                    style="transform: rotateZ(-180deg) scale(${scale});"
                    stroke-linecap="${this.props.linecap}"
                    d="
    M 0, ${boundings.width * 0.5}
    a ${boundings.width * 0.5},${boundings.width * 0.5} 0 1,1 ${boundings.width},0
    a ${boundings.width * 0.5},${boundings.width * 0.5} 0 1,1 -${boundings.width},0
  "
                />
                <path
                    class="_gauge"
                    style="transform: rotateZ(-180deg) scale(${scale});"
                    stroke-linecap="${this.props.linecap}"
                    d="
    M 0, ${boundings.width * 0.5}
    a ${boundings.width * 0.5},${boundings.width * 0.5} 0 1,1 ${boundings.width},0
    a ${boundings.width * 0.5},${boundings.width * 0.5} 0 1,1 -${boundings.width},0
  "
                />
            </svg>
            <div class="_value">${this.props.value}</div>
        `;
  }
}
function define$4(props = {}, tagName = "s-gauge", settings) {
  SGaugeComponent.define(tagName, SGaugeComponent, props, settings);
}
class SHighlightFeatureInterface extends SInterface {
  static get _definition() {
    return {
      type: {
        type: "String",
        description: "Specify the type of highlight you want",
        default: "light",
        physical: true
      },
      size: {
        type: "Number",
        description: "Specify the size of the highlight in px"
      },
      intensity: {
        type: "Number",
        description: "Specify the intensity of the highlight beetween 0 and 1"
      }
    };
  }
}
const __css$1 = "\n                @import url('https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css');\n            [s-highlight][type='light'] {\n    position: relative;\n}\n\n[s-highlight][type='light']::before,\n[s-highlight][type='light']::after {\n    border-radius: inherit;\n    content: '';\n    display: block;\n    height: 100%;\n    left: 0px;\n    opacity: 0;\n    position: absolute;\n    top: 0px;\n    transition: opacity 500ms;\n    width: 100%;\n    mix-blend-mode: overlay;\n    pointer-events: none;\n}\n\n[s-highlight][type='light']::before {\n    background: radial-gradient(\n        var(--s-highlight-size, 1000px) circle at var(--s-highlight-mouse-x)\n            var(--s-highlight-mouse-y),\n        rgba(255, 255, 255, 0.06),\n        transparent 40%\n    );\n    z-index: 3;\n}\n\n[s-highlight][type='light']::after {\n    background: radial-gradient(\n        var(--s-highlight-size, 1000px) circle at var(--s-highlight-mouse-x)\n            var(--s-highlight-mouse-y),\n        rgba(255, 255, 255, 0.4),\n        transparent 40%\n    );\n    z-index: 1;\n}\n\n[s-highlight][type='light'].highlight:before,\n    [s-highlight][type='light'].highlight:after {\n        opacity: var(--s-highlight-intensity, 0.6);\n    }\n";
var __awaiter$2 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class SHighlightFeature extends SFeature {
  // @ts-ignore
  constructor(name2, node, settings) {
    super(name2, node, __deepMerge({
      name: "s-highlight",
      interface: SHighlightFeatureInterface,
      style: __css$1
    }, settings !== null && settings !== void 0 ? settings : {}));
  }
  mount() {
    return __awaiter$2(this, void 0, void 0, function* () {
      if (this.props.size) {
        this.node.style.setProperty("--s-highlight-size", `${this.props.size}px`);
      }
      if (this.props.intensity) {
        this.node.style.setProperty("--s-highlight-intensity", this.props.intensity);
      }
      ["mouseover", "pointerover"].forEach((eventName) => {
        this.node.addEventListener(eventName, (e) => {
          if (!this.utils.isActive()) {
            return;
          }
          this.node.classList.add("highlight");
        });
      });
      ["mouseout", "pointerout"].forEach((eventName) => {
        this.node.addEventListener(eventName, (e) => {
          if (!this.utils.isActive()) {
            return;
          }
          this.node.classList.remove("highlight");
        });
      });
      ["mousemove", "touchmove"].forEach((eventName) => {
        this.node.addEventListener(eventName, (e) => {
          if (!this.utils.isActive()) {
            return;
          }
          const rect = this.node.getBoundingClientRect(), x = e.clientX - rect.left, y2 = e.clientY - rect.top;
          this.node.style.setProperty("--s-highlight-mouse-x", `${x}px`);
          this.node.style.setProperty("--s-highlight-mouse-y", `${y2}px`);
        });
      });
    });
  }
}
function define$3(props = {}, name2 = "s-highlight") {
  SHighlightFeature.define(name2, SHighlightFeature, Object.assign({}, props));
}
class SHotkeysListComponentInterface extends SInterface {
  static get _definition() {
    return {
      hotkeys: {
        type: "Object",
        description: 'Specify the hotkeys you want to list. The key is the hotkey itself and it stores an object with "title", "description" and "hotkey" property.'
      }
    };
  }
}
const __css = "\n                @import url('https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css');\n            .s-hotkeys-list {\n    display: block;\n}\n";
class SHotkeysListComponent extends SLitComponent {
  static get properties() {
    return SLitComponent.propertiesFromInterface({}, SHotkeysListComponentInterface);
  }
  static get styles() {
    return css$1`
            ${unsafeCSS(__css)}
        `;
  }
  get _hotkeys() {
    var _a2, _b2;
    return (_a2 = this.props.hotkeys) !== null && _a2 !== void 0 ? _a2 : (_b2 = document.env) === null || _b2 === void 0 ? void 0 : _b2.HOTKEYS;
  }
  constructor() {
    super({
      name: "s-hotkeys-list",
      interface: SHotkeysListComponentInterface
    });
    document.addEventListener("hotkeys.update", (e) => {
      this.requestUpdate();
    });
  }
  render() {
    var _a2;
    return html`
            <ol class="${this.utils.cls("_list")}">
                ${Object.keys((_a2 = this._hotkeys) !== null && _a2 !== void 0 ? _a2 : {}).map((hotkey) => {
      var _a3;
      const hotkeyObj = this._hotkeys[hotkey];
      return html`
                        <li class="${this.utils.cls("_list-item")}">
                            <div class="${this.utils.cls("_hotkey")}">
                                ${unsafeHTML(`
                                    ${((_a3 = hotkeyObj.hotkey) !== null && _a3 !== void 0 ? _a3 : hotkey).split("+").map((key) => `<span
                                                    class="${this.utils.cls("_key")}"
                                                    >${key}</span
                                                >`).join("+")}
                                    `)}
                            </div>
                            <div class="${this.utils.cls("_metas")}">
                                ${hotkeyObj.title ? html`
                                          <h1
                                              class="${this.utils.cls("_title")}"
                                          >
                                              ${hotkeyObj.title}
                                          </h1>
                                      ` : ""}
                                ${hotkeyObj.description ? html`
                                          <p
                                              class="${this.utils.cls("_description")}"
                                          >
                                              ${hotkeyObj.description}
                                          </p>
                                      ` : ""}
                            </div>
                        </li>
                    `;
    })}
            </ol>
        `;
  }
}
function define$2(props = {}, tagName = "s-hotkeys-list", settings) {
  SHotkeysListComponent.define(tagName, SHotkeysListComponent, props, settings);
}
class SParallaxFeatureInterface extends SInterface {
  static get _definition() {
    return {
      amount: {
        description: "Specify the amount of parallax you want to apply",
        type: "Number",
        default: 1
      },
      amountX: {
        description: "Specify the amount of parallax you want for the x axis. This will be applied on top of the global amount",
        type: "Number",
        default: 1
      },
      amountY: {
        description: "Specify the amount of parallax you want for the y axis. This will be applied on top of the global amount",
        type: "Number",
        default: 1
      },
      amountT: {
        description: "Specify the amount of parallax you want for the translate x and y axis. This will be applied on top of the global amount",
        type: "Number",
        default: 1
      },
      amountTx: {
        description: "Specify the amount of parallax you want for the translate x axis. This will be applied on top of the global amount",
        type: "Number",
        default: 1
      },
      amountTy: {
        description: "Specify the amount of parallax you want for the translate y axis. This will be applied on top of the global amount",
        type: "Number",
        default: 1
      },
      amountR: {
        description: "Specify the amount of parallax you want for the rotate x and y axis. This will be applied on top of the global amount",
        type: "Number",
        default: 1
      },
      amountRx: {
        description: "Specify the amount of parallax you want for the rotate x axis. This will be applied on top of the global amount",
        type: "Number",
        default: 1
      },
      amountRy: {
        description: "Specify the amount of parallax you want for the rotate y axis. This will be applied on top of the global amount",
        type: "Number",
        default: 1
      },
      amountRz: {
        description: "Specify the amount of parallax you want for the rotate z axis. This will be applied on top of the global amount",
        type: "Number",
        default: 1
      }
    };
  }
}
class SParallaxFeature extends SFeature {
  constructor(name2, node, settings) {
    super(name2, node, __deepMerge({
      name: "s-parallax",
      interface: SParallaxFeatureInterface
    }, settings !== null && settings !== void 0 ? settings : {}));
  }
  mount() {
    const style = window.getComputedStyle(this.node);
    const transformStr = style.transform;
    this._originalTransform = transformStr;
    document.addEventListener("mousemove", (e) => {
      if (!this.utils.isActive()) {
        return;
      }
      const percentage = this._getPositionPercentages(e);
      this._setLayerTransform(percentage);
    });
  }
  _setLayerTransform(percentage) {
    var _a2;
    const rotateY$1 = 90 / 100 * percentage.x;
    const rotateX$1 = 90 / 100 * percentage.y;
    const offsetX = 200 / 100 * percentage.x;
    const offsetY = 200 / 100 * percentage.y;
    const amount = (_a2 = this.props.amount) !== null && _a2 !== void 0 ? _a2 : "1";
    const matrix = fromString(this._originalTransform);
    const finalRotateX = rotateX$1 * parseFloat(amount) * parseFloat(this.props.amountX) * parseFloat(this.props.amountR) * parseFloat(this.props.amountRx);
    const finalRotateY = rotateY$1 * parseFloat(amount) * parseFloat(this.props.amountY) * parseFloat(this.props.amountR) * parseFloat(this.props.amountRy);
    const finalRotateZ = rotateY$1 * parseFloat(amount) * parseFloat(this.props.amountZ) * parseFloat(this.props.amountR) * parseFloat(this.props.amountRz);
    const finalOffsetX = offsetX * parseFloat(amount) * parseFloat(this.props.amountX) * parseFloat(this.props.amountT) * parseFloat(this.props.amountTx);
    const finalOffsetY = offsetY * parseFloat(amount) * parseFloat(this.props.amountY) * parseFloat(this.props.amountT) * parseFloat(this.props.amountTy);
    const tx = translateX(finalOffsetX), ty = translateY(finalOffsetY), rx = rotateX(finalRotateX), ry = rotateY(finalRotateY);
    rotateZ(finalRotateZ);
    let newMatrix = [matrix, tx, ty, rx, ry].reduce(multiply);
    this.node.style.transform = toString$1(newMatrix);
  }
  _getPositionPercentages(e) {
    var _a2, _b2, _c2, _d2;
    const viewportWidth = document.documentElement.clientWidth, viewportHeight = document.documentElement.clientHeight, halfViewportWidth = viewportWidth * 0.5, halfViewportHeight = viewportHeight * 0.5, positionX = (_b2 = (_a2 = e.touches) === null || _a2 === void 0 ? void 0 : _a2[0].clientX) !== null && _b2 !== void 0 ? _b2 : e.pageX, positionY = ((_d2 = (_c2 = e.touches) === null || _c2 === void 0 ? void 0 : _c2[0].clientY) !== null && _d2 !== void 0 ? _d2 : e.pageY) - document.documentElement.scrollTop, percentageX = 100 / halfViewportWidth * (positionX - halfViewportWidth), percentageY = 100 / halfViewportHeight * (positionY - halfViewportHeight);
    return {
      x: percentageX,
      y: percentageY
    };
  }
}
function define$1(props = {}, name2 = "s-parallax") {
  SParallaxFeature.define(name2, SParallaxFeature, Object.assign({}, props));
}
var __awaiter$1 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function autoResizeFeature() {
  __querySelectorLive("[auto-resize]", ($elm) => __awaiter$1(this, void 0, void 0, function* () {
    autoResize($elm);
  }));
}
var __awaiter = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve2(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function confirmButtonFeature() {
  __querySelectorLive("[confirm]", ($btn) => __awaiter(this, void 0, void 0, function* () {
    if ($btn.needConfirmation !== void 0) {
      return;
    }
    $btn._isConfirmedStatus = void 0;
    $btn.needConfirmation = true;
    yield __wait(100);
    const buttonElmStyle = window.getComputedStyle($btn), buttonWidth = buttonElmStyle.width, confirmElmStyle = window.getComputedStyle($btn, ":after"), confirmWidth = `${parseInt(confirmElmStyle.width) + 10}px`;
    $btn.style.setProperty("--s-btn-confirm-width", buttonWidth);
    $btn.addEventListener("pointerdown", (e) => {
      if ($btn._isConfirmedStatus === void 0) {
        $btn._isConfirmedStatus = false;
        $btn.style.setProperty("--s-btn-confirm-width", confirmWidth);
      } else if ($btn._isConfirmedStatus === false) {
        setTimeout(() => {
          $btn.style.setProperty("--s-btn-confirm-width", buttonWidth);
        }, 100);
        $btn._isConfirmedStatus = true;
        $btn.needConfirmation = false;
      }
    });
    $btn.addEventListener("blur", (e) => {
      setTimeout(() => {
        $btn.style.setProperty("--s-btn-confirm-width", buttonWidth);
      }, 100);
      $btn._isConfirmedStatus = void 0;
    });
    $btn.addEventListener("pointerup", (e) => {
      setTimeout(() => {
        if ($btn._isConfirmedStatus === true) {
          $btn.blur();
          $btn._isConfirmedStatus = void 0;
          $btn.needConfirmation = true;
        }
      });
    });
  }));
}
var requiresPort = function required(port2, protocol) {
  protocol = protocol.split(":")[0];
  port2 = +port2;
  if (!port2)
    return false;
  switch (protocol) {
    case "http":
    case "ws":
      return port2 !== 80;
    case "https":
    case "wss":
      return port2 !== 443;
    case "ftp":
      return port2 !== 21;
    case "gopher":
      return port2 !== 70;
    case "file":
      return false;
  }
  return port2 !== 0;
};
var querystringify$1 = {};
var has = Object.prototype.hasOwnProperty, undef;
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, " "));
  } catch (e) {
    return null;
  }
}
function encode(input) {
  try {
    return encodeURIComponent(input);
  } catch (e) {
    return null;
  }
}
function querystring(query2) {
  var parser = /([^=?#&]+)=?([^&]*)/g, result2 = {}, part;
  while (part = parser.exec(query2)) {
    var key = decode(part[1]), value = decode(part[2]);
    if (key === null || value === null || key in result2)
      continue;
    result2[key] = value;
  }
  return result2;
}
function querystringify(obj, prefix) {
  prefix = prefix || "";
  var pairs = [], value, key;
  if ("string" !== typeof prefix)
    prefix = "?";
  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = "";
      }
      key = encode(key);
      value = encode(value);
      if (key === null || value === null)
        continue;
      pairs.push(key + "=" + value);
    }
  }
  return pairs.length ? prefix + pairs.join("&") : "";
}
querystringify$1.stringify = querystringify;
querystringify$1.parse = querystring;
var required2 = requiresPort, qs = querystringify$1, controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/, CRHTLF = /[\n\r\t]/g, slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//, port = /:\d+$/, protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i, windowsDriveLetter = /^[a-zA-Z]:/;
function trimLeft(str2) {
  return (str2 ? str2 : "").toString().replace(controlOrWhitespace, "");
}
var rules = [
  ["#", "hash"],
  // Extract from the back.
  ["?", "query"],
  // Extract from the back.
  function sanitize(address, url) {
    return isSpecial(url.protocol) ? address.replace(/\\/g, "/") : address;
  },
  ["/", "pathname"],
  // Extract from the back.
  ["@", "auth", 1],
  // Extract from the front.
  [NaN, "host", void 0, 1, 1],
  // Set left over value.
  [/:(\d*)$/, "port", void 0, 1],
  // RegExp the back.
  [NaN, "hostname", void 0, 1, 1]
  // Set left over.
];
var ignore = { hash: 1, query: 1 };
function lolcation(loc) {
  var globalVar;
  if (typeof window !== "undefined")
    globalVar = window;
  else if (typeof commonjsGlobal !== "undefined")
    globalVar = commonjsGlobal;
  else if (typeof self !== "undefined")
    globalVar = self;
  else
    globalVar = {};
  var location = globalVar.location || {};
  loc = loc || location;
  var finaldestination = {}, type = typeof loc, key;
  if ("blob:" === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ("string" === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore)
      delete finaldestination[key];
  } else if ("object" === type) {
    for (key in loc) {
      if (key in ignore)
        continue;
      finaldestination[key] = loc[key];
    }
    if (finaldestination.slashes === void 0) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }
  return finaldestination;
}
function isSpecial(scheme) {
  return scheme === "file:" || scheme === "ftp:" || scheme === "http:" || scheme === "https:" || scheme === "ws:" || scheme === "wss:";
}
function extractProtocol(address, location) {
  address = trimLeft(address);
  address = address.replace(CRHTLF, "");
  location = location || {};
  var match2 = protocolre.exec(address);
  var protocol = match2[1] ? match2[1].toLowerCase() : "";
  var forwardSlashes = !!match2[2];
  var otherSlashes = !!match2[3];
  var slashesCount = 0;
  var rest;
  if (forwardSlashes) {
    if (otherSlashes) {
      rest = match2[2] + match2[3] + match2[4];
      slashesCount = match2[2].length + match2[3].length;
    } else {
      rest = match2[2] + match2[4];
      slashesCount = match2[2].length;
    }
  } else {
    if (otherSlashes) {
      rest = match2[3] + match2[4];
      slashesCount = match2[3].length;
    } else {
      rest = match2[4];
    }
  }
  if (protocol === "file:") {
    if (slashesCount >= 2) {
      rest = rest.slice(2);
    }
  } else if (isSpecial(protocol)) {
    rest = match2[4];
  } else if (protocol) {
    if (forwardSlashes) {
      rest = rest.slice(2);
    }
  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
    rest = match2[4];
  }
  return {
    protocol,
    slashes: forwardSlashes || isSpecial(protocol),
    slashesCount,
    rest
  };
}
function resolve(relative, base) {
  if (relative === "")
    return base;
  var path2 = (base || "/").split("/").slice(0, -1).concat(relative.split("/")), i = path2.length, last = path2[i - 1], unshift = false, up = 0;
  while (i--) {
    if (path2[i] === ".") {
      path2.splice(i, 1);
    } else if (path2[i] === "..") {
      path2.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0)
        unshift = true;
      path2.splice(i, 1);
      up--;
    }
  }
  if (unshift)
    path2.unshift("");
  if (last === "." || last === "..")
    path2.push("");
  return path2.join("/");
}
function Url(address, location, parser) {
  address = trimLeft(address);
  address = address.replace(CRHTLF, "");
  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }
  var relative, extracted, parse2, instruction, index, key, instructions = rules.slice(), type = typeof location, url = this, i = 0;
  if ("object" !== type && "string" !== type) {
    parser = location;
    location = null;
  }
  if (parser && "function" !== typeof parser)
    parser = qs.parse;
  location = lolcation(location);
  extracted = extractProtocol(address || "", location);
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || "";
  address = extracted.rest;
  if (extracted.protocol === "file:" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {
    instructions[3] = [/(.*)/, "pathname"];
  }
  for (; i < instructions.length; i++) {
    instruction = instructions[i];
    if (typeof instruction === "function") {
      address = instruction(address, url);
      continue;
    }
    parse2 = instruction[0];
    key = instruction[1];
    if (parse2 !== parse2) {
      url[key] = address;
    } else if ("string" === typeof parse2) {
      index = parse2 === "@" ? address.lastIndexOf(parse2) : address.indexOf(parse2);
      if (~index) {
        if ("number" === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if (index = parse2.exec(address)) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }
    url[key] = url[key] || (relative && instruction[3] ? location[key] || "" : "");
    if (instruction[4])
      url[key] = url[key].toLowerCase();
  }
  if (parser)
    url.query = parser(url.query);
  if (relative && location.slashes && url.pathname.charAt(0) !== "/" && (url.pathname !== "" || location.pathname !== "")) {
    url.pathname = resolve(url.pathname, location.pathname);
  }
  if (url.pathname.charAt(0) !== "/" && isSpecial(url.protocol)) {
    url.pathname = "/" + url.pathname;
  }
  if (!required2(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = "";
  }
  url.username = url.password = "";
  if (url.auth) {
    index = url.auth.indexOf(":");
    if (~index) {
      url.username = url.auth.slice(0, index);
      url.username = encodeURIComponent(decodeURIComponent(url.username));
      url.password = url.auth.slice(index + 1);
      url.password = encodeURIComponent(decodeURIComponent(url.password));
    } else {
      url.username = encodeURIComponent(decodeURIComponent(url.auth));
    }
    url.auth = url.password ? url.username + ":" + url.password : url.username;
  }
  url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
  url.href = url.toString();
}
function set(part, value, fn2) {
  var url = this;
  switch (part) {
    case "query":
      if ("string" === typeof value && value.length) {
        value = (fn2 || qs.parse)(value);
      }
      url[part] = value;
      break;
    case "port":
      url[part] = value;
      if (!required2(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = "";
      } else if (value) {
        url.host = url.hostname + ":" + value;
      }
      break;
    case "hostname":
      url[part] = value;
      if (url.port)
        value += ":" + url.port;
      url.host = value;
      break;
    case "host":
      url[part] = value;
      if (port.test(value)) {
        value = value.split(":");
        url.port = value.pop();
        url.hostname = value.join(":");
      } else {
        url.hostname = value;
        url.port = "";
      }
      break;
    case "protocol":
      url.protocol = value.toLowerCase();
      url.slashes = !fn2;
      break;
    case "pathname":
    case "hash":
      if (value) {
        var char = part === "pathname" ? "/" : "#";
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;
    case "username":
    case "password":
      url[part] = encodeURIComponent(value);
      break;
    case "auth":
      var index = value.indexOf(":");
      if (~index) {
        url.username = value.slice(0, index);
        url.username = encodeURIComponent(decodeURIComponent(url.username));
        url.password = value.slice(index + 1);
        url.password = encodeURIComponent(decodeURIComponent(url.password));
      } else {
        url.username = encodeURIComponent(decodeURIComponent(value));
      }
  }
  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];
    if (ins[4])
      url[ins[1]] = url[ins[1]].toLowerCase();
  }
  url.auth = url.password ? url.username + ":" + url.password : url.username;
  url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
  url.href = url.toString();
  return url;
}
function toString(stringify) {
  if (!stringify || "function" !== typeof stringify)
    stringify = qs.stringify;
  var query2, url = this, host = url.host, protocol = url.protocol;
  if (protocol && protocol.charAt(protocol.length - 1) !== ":")
    protocol += ":";
  var result2 = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? "//" : "");
  if (url.username) {
    result2 += url.username;
    if (url.password)
      result2 += ":" + url.password;
    result2 += "@";
  } else if (url.password) {
    result2 += ":" + url.password;
    result2 += "@";
  } else if (url.protocol !== "file:" && isSpecial(url.protocol) && !host && url.pathname !== "/") {
    result2 += "@";
  }
  if (host[host.length - 1] === ":" || port.test(url.hostname) && !url.port) {
    host += ":";
  }
  result2 += host + url.pathname;
  query2 = "object" === typeof url.query ? stringify(url.query) : url.query;
  if (query2)
    result2 += "?" !== query2.charAt(0) ? "?" + query2 : query2;
  if (url.hash)
    result2 += url.hash;
  return result2;
}
Url.prototype = { set, toString };
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;
var urlParse = Url;
const urlParse$1 = /* @__PURE__ */ getDefaultExportFromCjs(urlParse);
function __smoothScrollOnAnchorLinks(settings = {}) {
  var _a2, _b2, _c2, _d2, _e2, _f2;
  settings = __deepMerge({
    scroll: {
      delay: (_f2 = (_e2 = (_d2 = (_c2 = (_b2 = (_a2 = document === null || document === void 0 ? void 0 : document.env) === null || _a2 === void 0 ? void 0 : _a2.SUGAR) === null || _b2 === void 0 ? void 0 : _b2.theme) === null || _c2 === void 0 ? void 0 : _c2.get) === null || _d2 === void 0 ? void 0 : _d2.call(_c2, "scroll")) === null || _e2 === void 0 ? void 0 : _e2.delay) !== null && _f2 !== void 0 ? _f2 : 0
    },
    checkPathNames: true
  }, settings);
  __querySelectorLive('a:not([is])[href*="#"]', ($link) => {
    $link.addEventListener("click", (e) => {
      var _a3;
      const linkUrl = urlParse$1($link.getAttribute("href"));
      const currentUrl = urlParse$1();
      if (!linkUrl.hash || linkUrl.hash === "#")
        return;
      if (settings.checkPathNames && currentUrl.pathname !== linkUrl.pathname)
        return;
      const $target = document.querySelector(linkUrl.hash);
      if (!$target)
        return;
      e.preventDefault();
      history.pushState({}, null, linkUrl.hash);
      setTimeout(() => {
        __scrollTo($target, settings.scroll);
      }, (_a3 = settings.scroll.delay) !== null && _a3 !== void 0 ? _a3 : 0);
    });
  });
}
function __smoothScrollOnPageLoad(settings = {}) {
  var _a2, _b2, _c2, _d2, _e2, _f2;
  settings = __deepMerge({
    scroll: {
      delay: (_f2 = (_e2 = (_d2 = (_c2 = (_b2 = (_a2 = document === null || document === void 0 ? void 0 : document.env) === null || _a2 === void 0 ? void 0 : _a2.SUGAR) === null || _b2 === void 0 ? void 0 : _b2.theme) === null || _c2 === void 0 ? void 0 : _c2.get) === null || _d2 === void 0 ? void 0 : _d2.call(_c2, "scroll")) === null || _e2 === void 0 ? void 0 : _e2.delay) !== null && _f2 !== void 0 ? _f2 : 0
    }
  }, settings);
  __scrollToLocationHash(settings);
}
function __smoothScroll(settings = {}) {
  settings = __deepMerge({
    scroll: {}
  }, settings);
  __smoothScrollOnPageLoad(settings);
  __smoothScrollOnAnchorLinks(settings);
}
if (!window.___isObject) {
  window.___isObject = function(item) {
    return item && typeof item === "object" && !Array.isArray(item);
  };
}
if (!window.___deepMerge) {
  window.___deepMerge = function(target, ...sources) {
    if (!sources.length)
      return target;
    var source2 = sources.shift();
    if (window.___isObject(target) && window.___isObject(source2)) {
      for (const key in source2) {
        if (window.___isObject(source2[key])) {
          if (!target[key])
            Object.assign(target, { [key]: {} });
          window.___deepMerge(target[key], source2[key]);
        } else {
          Object.assign(target, { [key]: source2[key] });
        }
      }
    }
    return window.___deepMerge(target, ...sources);
  };
}
document.env = window.___deepMerge(
  JSON.parse(`{"PLATFORM":"browser","ENV":"development","SUGAR":{"config":{"datetime":{"dateFormat":"YYYY-MM-DD","timeFormat":"h:mm:ss","i18n":{"previousMonth":"Previous Month","nextMonth":"Next Month","months":["January","February","March","April","May","June","July","August","September","October","November","December"],"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"]}},"doc":{"categories":{"getStarted":{"title":"Get Started","description":"All the documentations like install, get started, etc...","filters":{"type":"Markdown","id":"@website.sugarcss-coffeekraken-io.doc.**"}},"styleguideComponents":{"title":"Components","description":"All the available components, etc...","filters":{"type":"Styleguide","id":"/.*.sugar.style.ui.*/"}},"styleguideHelpers":{"title":"Helpers","description":"All the available helpers, etc...","filters":{"type":"Styleguide","id":"/.*.sugar.style.helpers.*/"}},"mixins":{"title":"Mixins","description":"All the available mixins","filters":{"type":"PostcssMixin","id":"@coffeekraken.s-postcss-sugar-plugin.**"}},"functions":{"title":"Functions","description":"All the available functions","filters":{"type":"PostcssFunction","id":"@coffeekraken.s-postcss-sugar-plugin.**"}},"theming":{"title":"Theming","description":"All the available theming configs","filters":{"type":"Config","id":"@coffeekraken.s-theme.**"}},"configs":{"title":"Configs","description":"All the available configs","filters":{"type":"Config","id":"@coffeekraken.s-postcss-sugar-plugin.**"}}},"server":{"port":9191},"endpoints":{"base":"/api/doc","items":"/items","item":"/item/:id"}},"google":{"gtm":"GTM-K4LMN8Q","map":{"apiKey":"AIzaSyDzFfEzhmYXRTlONUCtMWQ88uHJhsbtXY4"}},"project":{"environments":{"dev":{"branch":"develop","urls":{"website":{"label":"Template","url":"http://localhost:3000"},"admin":{"label":"Admin","url":"http://localhost:3000/admin"}}},"staging":{"branch":"staging","urls":{"website":{"label":"Template","url":"http://staging.localhost:3000"},"admin":{"label":"Admin","url":"http://staging.localhost:3000/admin"}}},"preprod":{"branch":"preprod","urls":{"website":{"label":"Template","url":"http://preprod.localhost:3000"},"admin":{"label":"Admin","url":"http://preprod.localhost:3000/admin"}}},"prod":{"branch":"prod","urls":{"website":{"label":"Template","url":"http://prod.localhost:3000"},"admin":{"label":"Admin","url":"http://prod.localhost:3000/admin"}}}}},"serve":{"img":{"imgPath":"/dist/img"},"js":{"path":"/dist/js"},"css":{"path":"/dist/css"},"icons":{"path":"/dist/icons"},"fonts":{"path":"/dist/fonts"},"cache":{"path":"/cache"}},"dashboard":{"layout":[["s-dashboard-pages"],["s-dashboard-browserstack","s-dashboard-google","s-dashboard-web-vitals","s-dashboard-responsive"],["s-dashboard-project","s-dashboard-frontend-checker"]]},"vite":{"server":{"proxy":{"/sugar/dashboard/init.js":{"target":"http://0.0.0.0:5173/@fs/Users/olivierbossel/data/web/coffeekraken/coffeekraken/packages/app/s-dashboard/src/js/init.ts","changeOrigin":true}}}},"env":{"envFromLocation":{"development":"https?://(localhost|127.0.0.1|0.0.0.0|192.168.[0-9]{1,3}.[0-9]{1,3})","staging":"https?://([a-zA-Z0-9.-]+)?staging([a-zA-Z0-9.-]+)?","production":"https?://.*"},"git":{"template":{"name":"Template","commit":{}}}},"frontendServer":{"corsProxy":{"port":9999,"url":"http://127.0.0.1:9999","targetUrlHeaderName":"TargetUrl","limit":"12mb"}},"package":{"json":{"name":"@coffeekraken/s-sugarcss-plugin","version":"2.0.0-beta.1","description":"Postcss Coffeekraken plugin that gives you access to a ton of sugar like \\"@sugar.when.dark\\", \\"@sugar.classes\\", etc... mixins as well as functions like \\"sugar.padding\\", \\"sugar.color\\", etc... All of these makes uses of your theme configuration defined using the @coffeekraken/s-sugar-config system.","keywords":["coffeekraken","coffee","kraken","sugar","postcss","styleguide","color","margin","padding","ui"],"type":"module","author":"Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)","license":"MIT","repository":{"type":"git","url":"https://github.com/Coffeekraken/coffeekraken/tree/master/packages/postcss/s-sugarcss-plugin"},"dependencies":{"@coffeekraken/s-classmap":"^2.0.0-beta.1","@coffeekraken/s-duration":"^2.0.0-beta.1","@coffeekraken/s-env":"^2.0.0-beta.1","@coffeekraken/s-event-emitter":"^2.0.0-beta.1","@coffeekraken/s-file":"^2.0.0-beta.1","@coffeekraken/s-glob":"^2.0.0-beta.1","@coffeekraken/s-interface":"^2.0.0-beta.1","@coffeekraken/s-media":"^2.0.0-beta.1","@coffeekraken/s-request":"^2.0.0-beta.1","@coffeekraken/s-sugar-config":"^2.0.0-beta.1","@coffeekraken/s-sugar-json":"^2.0.0-beta.1","@coffeekraken/s-theme":"^2.0.0-beta.1","@coffeekraken/sugar":"^2.0.0-beta.1","chokidar":"^3.5.3","csso":"^5.0.5","faker":"^5.5.3","fantasticon":"1.2.3","filehound":"^1.17.6","glob":"^7.2.3","known-css-properties":"^0.28.0","oslllo-svg-fixer":"^3.0.0","postcss":"^8.4.14","svg-path-bounds":"^1.0.2","svg-path-commander":"^2.0.8"},"main":"dist/pkg/cjs/node/exports.js","module":"dist/pkg/esm/node/exports.js","exports":{".":{"require":"./dist/pkg/cjs/node/exports.js","import":"./dist/pkg/esm/node/exports.js"},"./shared/*":{"require":"./dist/pkg/cjs/shared/*.js","import":"./dist/pkg/esm/shared/*.js"},"./node/*":{"require":"./dist/pkg/cjs/node/*.js","import":"./dist/pkg/esm/node/*.js"},"./js/*":{"require":"./dist/pkg/cjs/js/*.js","import":"./dist/pkg/esm/js/*.js"}},"homepage":"https://coffeekraken.io"}},"theme":{"theme":"coffeekraken","variant":"dark","themes":{"coffeekraken-dark":{"color":{"current":"#808080","main":"#818898","accent":"#F7C33F","complementary":"#F9656E","success":"#91ff00","warning":"#ffd500","error":"#ff003b","info":"#00ffff"},"classmap":{"enabled":false,"url":"/classmap.json"},"lod":{"enabled":false,"defaultLevel":3,"botLevel":1,"levels":{"0":{"name":"bare","speedIndex":0},"1":{"name":"lnf","speedIndex":30},"2":{"name":"theme","speedIndex":40},"3":{"name":"high","speedIndex":50},"4":{"name":"ultra","speedIndex":60}},"method":"class","defaultAction":">=","cssProperties":{}},"easing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"scroll":{"duration":300,"delay":500,"offset":0,"offsetX":0,"offsetY":200},"partytown":{"enabled":true,"forward":["dataLayer.push","fbq","freshpaint.addPageviewProperties","freshpaint.identify","freshpaint.track","_hsq.push","Intercom","_learnq.push","ttq.track","ttq.page","ttq.load","mixpanel.track"]},"timing":{"slow":".6s","default":".3s","fast":".1s"},"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"gradient":{"defaultModifierStart":{},"defaultModifierEnd":{"lighten":20},"defaultX":"50%","defaultY":"50%","defaultAngle":"90deg","defaultTextModifierStart":{"darken":5},"defaultTextModifierEnd":{"lighten":5},"defaultTextAngle":"90deg"},"helpers":{"states":["mounted","active","loading"],"clearfix":{"default":"overflow"},"disabled":{"opacity":0.4},"truncate":{"count":10},"order":{"count":20}},"layout":{"offset":{"top":100,"right":0,"bottom":0,"left":0},"container":{"default":"1280px","wide":"1440px","full":"none"},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","21":"2 1","112":"1 1 2","122":"1 2 2","123":"1 2 3","211":"2 1 1","221":"2 2 1","321":"3 2 1","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","2221":"2 2 2 1","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","22221":"2 2 2 2 1","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6","1_2":"1 _ 2","2_1":"2 _ 1","12_33":"1 2 _ 3 3","1_23":"1 _ 2 3","1_2_3":"1 _ 2 _ 3","32_1":"3 2 _ 1","3_21":"3 _ 2 1","12_34":"1 2 _ 3 4","123_4":"1 2 3 _ 4","1_234":"1 _ 2 3 4","1_2_3_4":"1 _ 2 _ 3 _ 4","123_45":"1 2 3 _ 4 5","12_345":"1 2 _ 3 4 5","1_2345":"1 _ 2 3 4 5","1234_5":"1 2 3 4 _ 5","1_2_3_4_5":"1 _ 2 _ 3 _ 4 _ 5"}},"ratio":{"1":1,"16-9":1.7777777777777777,"16-10":1.6,"21-9":2.3333333333333335,"1-2":0.5,"2-1":2,"2-3":0.6666666666666666,"3-2":1.5,"4-3":1.3333333333333333,"3-4":0.75},"scalable":{"margin":false,"padding":true,"offsize":false,"font":true},"scale":{"10":1,"11":1.1,"12":1.2,"13":1.3,"14":1.4,"15":1.5,"16":1.6,"17":1.7,"18":1.8,"19":1.9,"20":2,"21":2.1,"22":2.2,"23":2.3,"24":2.4,"25":25,"26":2.6,"27":2.7,"28":2.8,"29":2.9,"30":3,"default":1,"01":0.1,"02":0.2,"03":0.3,"04":0.4,"05":0.5,"06":0.6,"07":0.7,"08":0.8,"09":0.9},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"height":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","5":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.006),\\n  0px 2.5px 1.5px rgba(0, 0, 0, 0.005),\\n  0px 3.5px 3.4px rgba(0, 0, 0, 0.006),\\n  0px 4.4px 4.3px rgba(0, 0, 0, 0.007),\\n  0px 10px 10px rgba(0, 0, 0, 0.01)","10":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","20":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","30":"0px 0.6px 0.4px rgba(0, 0, 0, 0.008),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.012),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.015),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.018),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.022),\\n  0px 20px 15px rgba(0, 0, 0, 0.03)","40":"0px 0.8px 0.6px rgba(0, 0, 0, 0.008),\\n  0px 2px 1.3px rgba(0, 0, 0, 0.012),\\n  0px 3.8px 2.5px rgba(0, 0, 0, 0.015),\\n  0px 6.7px 4.5px rgba(0, 0, 0, 0.018),\\n  0px 12.5px 8.4px rgba(0, 0, 0, 0.022),\\n  0px 30px 20px rgba(0, 0, 0, 0.03)","50":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","60":"0px 1px 0.7px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 1.7px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.1px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 5.6px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 10.4px rgba(0, 0, 0, 0.029),\\n  0px 35px 25px rgba(0, 0, 0, 0.04)","70":"0px 1.1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2px rgba(0, 0, 0, 0.016),\\n  0px 5px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 40px 30px rgba(0, 0, 0, 0.04)","80":"0px 1.1px 1px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2.3px rgba(0, 0, 0, 0.016),\\n  0px 5px 4.4px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 7.8px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 14.6px rgba(0, 0, 0, 0.029),\\n  0px 40px 35px rgba(0, 0, 0, 0.04)","90":"0px 1.4px 1.1px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 2.7px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 8.9px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 16.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 40px rgba(0, 0, 0, 0.04)","100":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)","default":"0"},"size":{"0":0.25,"5":"0.5","10":0.65,"15":0.7,"20":0.75,"25":0.95,"30":1.1,"40":1.4,"50":1.8,"60":2.5,"70":3.5,"80":4.5,"90":5.5,"100":7,"default":16},"font":{"family":{"default":{"fontFamily":"\\"Roboto\\"","fontWeight":400,"import":"https://fonts.googleapis.com/css2?family=Roboto&display=swap"},"title":{"fontFamily":"\\"Roboto\\"","fontWeight":500,"import":"https://fonts.googleapis.com/css2?family=Roboto:wght@500&display=swap"},"quote":{"fontFamily":"\\"Palatino, Times, Georgia, serif\\"","fontWeight":"normal","fontStyle":"normal","fontDisplay":"auto","capHeight":0.65},"code":{"fontFamily":"Menlo, Monaco, Consolas, Courier New, monospace","fontWeight":"normal","fontStyle":"normal","fontDisplay":"auto","capHeight":0.65}},"size":{"0":0,"5":"0.5","10":0.65,"15":0.7,"20":0.75,"25":0.95,"30":1.1,"40":1.4,"50":1.8,"60":2.5,"70":3.5,"80":4.5,"90":5.5,"100":7,"default":16}},"border":{"width":{"0":0,"10":1,"20":2,"30":4,"40":6,"50":8,"60":12,"70":16,"80":20,"90":24,"100":30,"default":"1px"},"radius":{"0":0,"10":0.8,"20":1.6,"30":2.4,"40":3.2,"50":4,"60":5.2,"70":6.4,"80":8,"90":10,"100":12,"default":"5px"}},"space":{"0":0,"10":0.375,"20":0.75,"30":1.4,"40":2,"50":3.5,"60":5,"70":7.5,"80":10,"90":15,"100":20,"default":16},"margin":{"0":0,"10":0.375,"20":0.75,"30":1.4,"40":2,"50":3.5,"60":5,"70":7.5,"80":10,"90":15,"100":20,"default":16},"padding":{"0":0,"10":0.375,"20":0.75,"30":1.4,"40":2,"50":3.5,"60":5,"70":7.5,"80":10,"90":15,"100":20,"default":16},"offsize":{"0":0,"10":0.375,"20":0.75,"30":1.4,"40":2,"50":3.5,"60":5,"70":7.5,"80":10,"90":15,"100":20,"default":16},"media":{"defaultAction":"<=","defaultMedia":"desktop","queries":{"mobile":{"minWidth":0,"maxWidth":639},"tablet":{"minWidth":640,"maxWidth":1279},"desktop":{"minWidth":1280,"maxWidth":2047},"wide":{"minWidth":2048,"maxWidth":null}}},"ui":{"default":{"paddingInline":1.25,"paddingBlock":0.75,"borderRadius":1,"borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultLnf":"solid","depth":"0","outline":true,"spacing":1.4,"rhythmVertical":{"margin-bottom":60}},"menu":{"paddingInline":2,"paddingBlock":1.4,"borderRadius":1,"borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultLnf":"solid","defaultType":"primary","depth":"0","rhythmVertical":{"margin-bottom":60}},"card":{"paddingInline":3.5,"paddingBlock":3.5},"form":{"paddingInline":1,"paddingBlock":0.75,"borderRadius":1,"transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","outline":true,"rhythmVertical":{"margin-bottom":40}},"outline":{"active":true,"borderWidth":"10px","borderRadius":1,"transition":"all .2s ease-out"},"scrollbar":{"size":"2px","color":"accent"},"label":{"defaultLnf":"inline"},"dropdown":{"paddingInline":0.75,"paddingBlock":0.75,"itemPaddingInline":1.25,"itemPaddingBlock":0.75},"list":{"defaultLnf":"dl","bulletChar":"-"},"fsTree":{"bulletChar":"●"},"tooltip":{"defaultPosition":"top","arrowSize":"15px"},"loader":{"duration":"1s","easing":"linear"}},"typo":{"h1":{"label":"H1","group":"style","style":{"display":"block","fontFamily":"title","fontSize":80,"lineHeight":1.3,"maxWidth":"55ch","mobile":{"fontSize":70}},"rhythmVertical":{"marginBottom":50}},"h2":{"label":"H2","group":"style","style":{"display":"block","fontFamily":"title","fontSize":70,"lineHeight":1.3,"maxWidth":"55ch","mobile":{"fontSize":60}},"rhythmVertical":{"marginBottom":50}},"h3":{"label":"H3","group":"style","style":{"display":"block","fontFamily":"title","fontSize":60,"lineHeight":1.3,"maxWidth":"55ch","mobile":{"fontSize":50}},"rhythmVertical":{"marginBottom":50}},"h4":{"label":"H4","group":"style","style":{"display":"block","fontFamily":"title","fontSize":50,"lineHeight":1.3,"maxWidth":"55ch","mobile":{"fontSize":40}},"rhythmVertical":{"marginBottom":50}},"h5":{"label":"H5","group":"style","style":{"display":"block","fontFamily":"title","fontSize":40,"lineHeight":1.3,"maxWidth":"55ch","mobile":{"fontSize":30}},"rhythmVertical":{"marginBottom":40}},"h6":{"label":"H6","group":"style","style":{"display":"block","fontFamily":"title","fontSize":30,"lineHeight":1.3,"maxWidth":"55ch","mobile":{"fontSize":30}},"hythmVertical":{"marginBottom":40}},"p":{"label":"Paragraph","group":"style","default":true,"style":{"display":"block","fontFamily":"default","fontSize":30,"lineHeight":1.8,"maxWidth":"55ch","color":["main","text","--alpha 0.7"]},"rhythmVertical":{"marginBottom":40}},"lead":{"label":"Lead paragraph","group":"style","style":{"display":"block","fontFamily":"default","fontSize":40,"lineHeight":1.6,"maxWidth":"55ch","mobile":{"fontSize":40}},"rhythmVertical":{"marginBottom":40}},"hr":{"label":"--","group":"block","button":{"label":"--"},"style":{"display":"block","color":"#818898","opacity":0.2},"rhythmVertical":{"marginBottom":50}},"pre:not([class])":{"label":"Pre","group":"text","style":{"display":"block","fontFamily":"code","color":["main","text"],"backgroundColor":["main","surface"],"lineHeight":1.5,"paddingInline":1.25,"paddingBlock":0.75,"borderRadius":1,"depth":"0"},"rhythmVertical":{"marginBottom":50}},"code:not(pre > code)":{"label":"Code","group":"text","button":{"label":"</>"},"style":{"display":"inline-block","fontFamily":"code","color":["main","text"],"lineHeight":1.1,"backgroundColor":["accent","surface"],"borderRadius":10,"paddingInline":10,"paddingBlock":0}},"blockquote":{"label":"Blockquote","group":"block","button":{"label":"<svg viewBox=\\"0 0 20 20\\"><path d=\\"M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z\\"></path></svg>"},"style":{"display":"block","fontFamily":"quote"},"editor":{"style":{"paddingInlineStart":1.25,"borderLeft":"1px solid #000"}},"rhythmVertical":{"marginBottom":50}},"a":{"label":"Link","group":"text","button":{"label":"<svg viewBox=\\"0 0 20 20\\"><path d=\\"m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z\\"></path></svg>"},"style":{"color":"accent","textDecoration":"underline"}},"quote":{"label":"Quote","group":"text","button":{"label":"<svg viewBox=\\"0 0 20 20\\"><path d=\\"M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z\\"></path></svg>"},"style":{"fontFamily":"quote"},"rhythmVertical":{"marginBottom":50}},"bold":{"label":"Bold","group":"text","style":{"fontWeight":"bold"},"button":{"label":"B","style":{"fontWeight":"bolder"}}},"italic":{"label":"Italic","group":"text","style":{"fontStyle":"italic"},"button":{"label":"I","style":{"fontStyle":"italic"}}},"large":{"label":"Large","group":"text","style":{"fontSize":"1.1em"},"button":{"label":"A","style":{"fontSize":"1.01em"}}},"larger":{"label":"Larger","group":"text","style":{"fontSize":"1.2em"},"button":{"label":"A","style":{"fontSize":"1.02em"}}},"largest":{"label":"Largest","group":"text","style":{"fontSize":"1.3em"},"button":{"label":"A","style":{"fontSize":"1.03em"}}},"small":{"label":"Small","group":"text","style":{"fontSize":"0.9em"},"button":{"label":"A","style":{"fontSize":"0.99em"}}},"smaller":{"label":"Smaller","group":"text","style":{"fontSize":"0.8em"},"button":{"label":"A","style":{"fontSize":"0.98em"}}},"smallest":{"label":"Smallest","group":"text","style":{"fontSize":"0.7em"},"button":{"label":"A","style":{"fontSize":"0.97em"}}},"mark":{"label":"Mark","group":"text","button":{"label":"M"},"style":{"backgroundColor":"#F7C33F"}},"del":{"label":"Deleted","group":"text","style":{"textDecoration":"line-through"},"button":{"label":"D","style":{"textDecoration":"line-through"}}},"ins":{"label":"Inserted","group":"text","style":{"textDecoration":"underline"},"button":{"label":"U","style":{"textDecoration":"underline"}}},"sub":{"label":"Subscript","group":"text","style":{"verticalAlign":"sub","fontSize":"0.6em"},"button":{"label":"Sub","style":{"verticalAlign":"sub","fontSize":"0.6em"}}},"sup":{"label":"Superscript","group":"text","style":{"verticalAlign":"sup","fontSize":"0.6em"},"button":{"label":"Sup","style":{"verticalAlign":"sup","fontSize":"0.6em"}}},"main":{"label":"Main","group":"color","type":"color","style":{"color":"#818898"}},"mainGradient":{"label":"Main gradient","group":"color","type":"color","style":{"backgroundSize":"100%","-webkitBackgroundClip":"text","-mozBackgroundClip":"text","-webkitTextFillColor":"transparent","-mozTextFillColor":"transparent","backgroundImage":"linear-gradient(90deg, #818898 0%, #8f95a3 100%)"}},"accent":{"label":"Accent","group":"color","type":"color","style":{"color":"#F7C33F"}},"accentGradient":{"label":"Accent gradient","group":"color","type":"color","style":{"backgroundSize":"100%","-webkitBackgroundClip":"text","-mozBackgroundClip":"text","-webkitTextFillColor":"transparent","-mozTextFillColor":"transparent","backgroundImage":"linear-gradient(90deg, #F7C33F 0%, #f8c954 100%)"}},"complementary":{"label":"Complementary","group":"color","type":"color","style":{"color":"#F9656E"}},"complementaryGradient":{"label":"Complementary gradient","group":"color","type":"color","style":{"backgroundSize":"100%","-webkitBackgroundClip":"text","-mozBackgroundClip":"text","-webkitTextFillColor":"transparent","-mozTextFillColor":"transparent","backgroundImage":"linear-gradient(90deg, #F9656E 0%, #f97b83 100%)"}},"success":{"label":"Success","group":"color","type":"color","style":{"color":"#91ff00"}},"successGradient":{"label":"Success gradient","group":"color","type":"color","style":{"backgroundSize":"100%","-webkitBackgroundClip":"text","-mozBackgroundClip":"text","-webkitTextFillColor":"transparent","-mozTextFillColor":"transparent","backgroundImage":"linear-gradient(90deg, #91ff00 0%, #9cff1a 100%)"}},"warning":{"label":"Warning","group":"color","type":"color","style":{"color":"#ffd500"}},"warningGradient":{"label":"Warning gradient","group":"color","type":"color","style":{"backgroundSize":"100%","-webkitBackgroundClip":"text","-mozBackgroundClip":"text","-webkitTextFillColor":"transparent","-mozTextFillColor":"transparent","backgroundImage":"linear-gradient(90deg, #ffd500 0%, #ffd91a 100%)"}},"error":{"label":"Error","group":"color","type":"color","style":{"color":"#ff003b"}},"errorGradient":{"label":"Error gradient","group":"color","type":"color","style":{"backgroundSize":"100%","-webkitBackgroundClip":"text","-mozBackgroundClip":"text","-webkitTextFillColor":"transparent","-mozTextFillColor":"transparent","backgroundImage":"linear-gradient(90deg, #ff003b 0%, #ff1a4f 100%)"}},"info":{"label":"Info","group":"color","type":"color","style":{"color":"#00ffff"}},"infoGradient":{"label":"Info gradient","group":"color","type":"color","style":{"backgroundSize":"100%","-webkitBackgroundClip":"text","-mozBackgroundClip":"text","-webkitTextFillColor":"transparent","-mozTextFillColor":"transparent","backgroundImage":"linear-gradient(90deg, #00ffff 0%, #1affff 100%)"}}},"wireframe":{"light":{"border":"1px solid rgba(0,0,0,0.1)","borderColor":"rgba(0,0,0,0.1)","background":"#ffffff","surface":"#fafafa"},"dark":{"border":"1px solid rgba(255,255,255,0.2)","borderColor":"rgba(255,255,255,0.2)","background":"#2D323A","surface":"#3B424C"}},"metas":{"title":"Coffeekraken dark","description":"Nice and elegant coffeekraken dark theme"},"shades":{"text":{"lighten":10,"color":{"main":{"lighten":50}}},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"surface":{"darken":25},"ui":{"lighten":10},"uiBackground":{"darken":27},"border":{"alpha":0.4},"hover":{"lighten":40},"active":{"darken":10},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}},"default-light":{"color":{"current":"#808080","main":"#808080","accent":"#ffbb00","complementary":"#8054F9","success":"#91ff00","warning":"#ffd500","error":"#ff003b","info":"#00ffff"},"classmap":{"enabled":false,"url":"/classmap.json"},"lod":{"enabled":false,"defaultLevel":3,"botLevel":1,"levels":{"0":{"name":"bare","speedIndex":0},"1":{"name":"lnf","speedIndex":30},"2":{"name":"theme","speedIndex":40},"3":{"name":"high","speedIndex":50},"4":{"name":"ultra","speedIndex":60}},"method":"class","defaultAction":">=","cssProperties":{}},"easing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"scroll":{"duration":300,"delay":500,"offset":0,"offsetX":0,"offsetY":200},"partytown":{"enabled":true,"forward":["dataLayer.push","fbq","freshpaint.addPageviewProperties","freshpaint.identify","freshpaint.track","_hsq.push","Intercom","_learnq.push","ttq.track","ttq.page","ttq.load","mixpanel.track"]},"timing":{"slow":".6s","default":".3s","fast":".1s"},"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"gradient":{"defaultModifierStart":{},"defaultModifierEnd":{"lighten":20},"defaultX":"50%","defaultY":"50%","defaultAngle":"90deg","defaultTextModifierStart":{"darken":5},"defaultTextModifierEnd":{"lighten":5},"defaultTextAngle":"90deg"},"helpers":{"states":["mounted","active","loading"],"clearfix":{"default":"overflow"},"disabled":{"opacity":0.4},"truncate":{"count":10},"order":{"count":20}},"layout":{"offset":{"top":100,"right":0,"bottom":0,"left":0},"container":{"default":"1280px","wide":"1440px","full":"none"},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","21":"2 1","112":"1 1 2","122":"1 2 2","123":"1 2 3","211":"2 1 1","221":"2 2 1","321":"3 2 1","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","2221":"2 2 2 1","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","22221":"2 2 2 2 1","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6","1_2":"1 _ 2","2_1":"2 _ 1","12_33":"1 2 _ 3 3","1_23":"1 _ 2 3","1_2_3":"1 _ 2 _ 3","32_1":"3 2 _ 1","3_21":"3 _ 2 1","12_34":"1 2 _ 3 4","123_4":"1 2 3 _ 4","1_234":"1 _ 2 3 4","1_2_3_4":"1 _ 2 _ 3 _ 4","123_45":"1 2 3 _ 4 5","12_345":"1 2 _ 3 4 5","1_2345":"1 _ 2 3 4 5","1234_5":"1 2 3 4 _ 5","1_2_3_4_5":"1 _ 2 _ 3 _ 4 _ 5"}},"ratio":{"1":1,"16-9":1.7777777777777777,"16-10":1.6,"21-9":2.3333333333333335,"1-2":0.5,"2-1":2,"2-3":0.6666666666666666,"3-2":1.5,"4-3":1.3333333333333333,"3-4":0.75},"scalable":{"margin":false,"padding":true,"offsize":false,"font":true},"scale":{"10":1,"11":1.1,"12":1.2,"13":1.3,"14":1.4,"15":1.5,"16":1.6,"17":1.7,"18":1.8,"19":1.9,"20":2,"21":2.1,"22":2.2,"23":2.3,"24":2.4,"25":25,"26":2.6,"27":2.7,"28":2.8,"29":2.9,"30":3,"default":1,"01":0.1,"02":0.2,"03":0.3,"04":0.4,"05":0.5,"06":0.6,"07":0.7,"08":0.8,"09":0.9},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"height":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","5":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.006),\\n  0px 2.5px 1.5px rgba(0, 0, 0, 0.005),\\n  0px 3.5px 3.4px rgba(0, 0, 0, 0.006),\\n  0px 4.4px 4.3px rgba(0, 0, 0, 0.007),\\n  0px 10px 10px rgba(0, 0, 0, 0.01)","10":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","20":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","30":"0px 0.6px 0.4px rgba(0, 0, 0, 0.008),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.012),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.015),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.018),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.022),\\n  0px 20px 15px rgba(0, 0, 0, 0.03)","40":"0px 0.8px 0.6px rgba(0, 0, 0, 0.008),\\n  0px 2px 1.3px rgba(0, 0, 0, 0.012),\\n  0px 3.8px 2.5px rgba(0, 0, 0, 0.015),\\n  0px 6.7px 4.5px rgba(0, 0, 0, 0.018),\\n  0px 12.5px 8.4px rgba(0, 0, 0, 0.022),\\n  0px 30px 20px rgba(0, 0, 0, 0.03)","50":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","60":"0px 1px 0.7px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 1.7px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.1px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 5.6px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 10.4px rgba(0, 0, 0, 0.029),\\n  0px 35px 25px rgba(0, 0, 0, 0.04)","70":"0px 1.1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2px rgba(0, 0, 0, 0.016),\\n  0px 5px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 40px 30px rgba(0, 0, 0, 0.04)","80":"0px 1.1px 1px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2.3px rgba(0, 0, 0, 0.016),\\n  0px 5px 4.4px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 7.8px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 14.6px rgba(0, 0, 0, 0.029),\\n  0px 40px 35px rgba(0, 0, 0, 0.04)","90":"0px 1.4px 1.1px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 2.7px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 8.9px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 16.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 40px rgba(0, 0, 0, 0.04)","100":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)","default":"0"},"size":{"0":0.25,"5":"0.5","10":0.65,"15":0.7,"20":0.75,"25":0.95,"30":1.1,"40":1.4,"50":1.8,"60":2.5,"70":3.5,"80":4.5,"90":5.5,"100":7,"default":16},"font":{"family":{"default":{"fontFamily":"\\"Roboto\\"","fontWeight":400,"import":"https://fonts.googleapis.com/css2?family=Roboto&display=swap"},"title":{"fontFamily":"\\"Roboto\\"","fontWeight":500,"import":"https://fonts.googleapis.com/css2?family=Roboto:wght@500&display=swap"},"quote":{"fontFamily":"\\"Palatino, Times, Georgia, serif\\"","fontWeight":"normal","fontStyle":"normal","fontDisplay":"auto","capHeight":0.65},"code":{"fontFamily":"Menlo, Monaco, Consolas, Courier New, monospace","fontWeight":"normal","fontStyle":"normal","fontDisplay":"auto","capHeight":0.65}},"size":{"0":0,"5":"0.5","10":0.65,"15":0.7,"20":0.75,"25":0.95,"30":1.1,"40":1.4,"50":1.8,"60":2.5,"70":3.5,"80":4.5,"90":5.5,"100":7,"default":16}},"border":{"width":{"0":0,"10":1,"20":2,"30":4,"40":6,"50":8,"60":12,"70":16,"80":20,"90":24,"100":30,"default":"1px"},"radius":{"0":0,"10":0.8,"20":1.6,"30":2.4,"40":3.2,"50":4,"60":5.2,"70":6.4,"80":8,"90":10,"100":12,"default":"5px"}},"space":{"0":0,"10":0.375,"20":0.75,"30":1.4,"40":2,"50":3.5,"60":5,"70":7.5,"80":10,"90":15,"100":20,"default":16},"margin":{"0":0,"10":0.375,"20":0.75,"30":1.4,"40":2,"50":3.5,"60":5,"70":7.5,"80":10,"90":15,"100":20,"default":16},"padding":{"0":0,"10":0.375,"20":0.75,"30":1.4,"40":2,"50":3.5,"60":5,"70":7.5,"80":10,"90":15,"100":20,"default":16},"offsize":{"0":0,"10":0.375,"20":0.75,"30":1.4,"40":2,"50":3.5,"60":5,"70":7.5,"80":10,"90":15,"100":20,"default":16},"media":{"defaultAction":"<=","defaultMedia":"desktop","queries":{"mobile":{"minWidth":0,"maxWidth":639},"tablet":{"minWidth":640,"maxWidth":1279},"desktop":{"minWidth":1280,"maxWidth":2047},"wide":{"minWidth":2048,"maxWidth":null}}},"ui":{"default":{"paddingInline":1.25,"paddingBlock":0.75,"borderRadius":1,"borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultLnf":"solid","depth":"0","outline":true,"spacing":1.4,"rhythmVertical":{"margin-bottom":60}},"menu":{"paddingInline":2,"paddingBlock":1.4,"borderRadius":1,"borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultLnf":"solid","defaultType":"primary","depth":"0","rhythmVertical":{"margin-bottom":60}},"card":{"paddingInline":3.5,"paddingBlock":3.5},"form":{"paddingInline":1,"paddingBlock":0.75,"borderRadius":1,"transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","outline":true,"rhythmVertical":{"margin-bottom":40}},"outline":{"active":true,"borderWidth":"10px","borderRadius":1,"transition":"all .2s ease-out"},"scrollbar":{"size":"2px","color":"accent"},"label":{"defaultLnf":"inline"},"dropdown":{"paddingInline":0.75,"paddingBlock":0.75,"itemPaddingInline":1.25,"itemPaddingBlock":0.75},"list":{"defaultLnf":"dl","bulletChar":"-"},"fsTree":{"bulletChar":"●"},"tooltip":{"defaultPosition":"top","arrowSize":"15px"},"loader":{"duration":"1s","easing":"linear"}},"typo":{"h1":{"label":"H1","group":"style","style":{"display":"block","fontFamily":"title","fontSize":80,"lineHeight":1.3,"maxWidth":"55ch","mobile":{"fontSize":70}},"rhythmVertical":{"marginBottom":50}},"h2":{"label":"H2","group":"style","style":{"display":"block","fontFamily":"title","fontSize":70,"lineHeight":1.3,"maxWidth":"55ch","mobile":{"fontSize":60}},"rhythmVertical":{"marginBottom":50}},"h3":{"label":"H3","group":"style","style":{"display":"block","fontFamily":"title","fontSize":60,"lineHeight":1.3,"maxWidth":"55ch","mobile":{"fontSize":50}},"rhythmVertical":{"marginBottom":50}},"h4":{"label":"H4","group":"style","style":{"display":"block","fontFamily":"title","fontSize":50,"lineHeight":1.3,"maxWidth":"55ch","mobile":{"fontSize":40}},"rhythmVertical":{"marginBottom":50}},"h5":{"label":"H5","group":"style","style":{"display":"block","fontFamily":"title","fontSize":40,"lineHeight":1.3,"maxWidth":"55ch","mobile":{"fontSize":30}},"rhythmVertical":{"marginBottom":40}},"h6":{"label":"H6","group":"style","style":{"display":"block","fontFamily":"title","fontSize":30,"lineHeight":1.3,"maxWidth":"55ch","mobile":{"fontSize":30}},"hythmVertical":{"marginBottom":40}},"p":{"label":"Paragraph","group":"style","default":true,"style":{"display":"block","fontFamily":"default","fontSize":30,"lineHeight":1.8,"maxWidth":"55ch","color":["main","text","--alpha 0.7"]},"rhythmVertical":{"marginBottom":40}},"lead":{"label":"Lead paragraph","group":"style","style":{"display":"block","fontFamily":"default","fontSize":40,"lineHeight":1.6,"maxWidth":"55ch","mobile":{"fontSize":40}},"rhythmVertical":{"marginBottom":40}},"hr":{"label":"--","group":"block","button":{"label":"--"},"style":{"display":"block","color":"#818898","opacity":0.2},"rhythmVertical":{"marginBottom":50}},"pre:not([class])":{"label":"Pre","group":"text","style":{"display":"block","fontFamily":"code","color":["main","text"],"backgroundColor":["main","surface"],"lineHeight":1.5,"paddingInline":1.25,"paddingBlock":0.75,"borderRadius":1,"depth":"0"},"rhythmVertical":{"marginBottom":50}},"code:not(pre > code)":{"label":"Code","group":"text","button":{"label":"</>"},"style":{"display":"inline-block","fontFamily":"code","color":["main","text"],"lineHeight":1.1,"backgroundColor":["accent","surface"],"borderRadius":10,"paddingInline":10,"paddingBlock":0}},"blockquote":{"label":"Blockquote","group":"block","button":{"label":"<svg viewBox=\\"0 0 20 20\\"><path d=\\"M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z\\"></path></svg>"},"style":{"display":"block","fontFamily":"quote"},"editor":{"style":{"paddingInlineStart":1.25,"borderLeft":"1px solid #000"}},"rhythmVertical":{"marginBottom":50}},"a":{"label":"Link","group":"text","button":{"label":"<svg viewBox=\\"0 0 20 20\\"><path d=\\"m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z\\"></path></svg>"},"style":{"color":"accent","textDecoration":"underline"}},"quote":{"label":"Quote","group":"text","button":{"label":"<svg viewBox=\\"0 0 20 20\\"><path d=\\"M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z\\"></path></svg>"},"style":{"fontFamily":"quote"},"rhythmVertical":{"marginBottom":50}},"bold":{"label":"Bold","group":"text","style":{"fontWeight":"bold"},"button":{"label":"B","style":{"fontWeight":"bolder"}}},"italic":{"label":"Italic","group":"text","style":{"fontStyle":"italic"},"button":{"label":"I","style":{"fontStyle":"italic"}}},"large":{"label":"Large","group":"text","style":{"fontSize":"1.1em"},"button":{"label":"A","style":{"fontSize":"1.01em"}}},"larger":{"label":"Larger","group":"text","style":{"fontSize":"1.2em"},"button":{"label":"A","style":{"fontSize":"1.02em"}}},"largest":{"label":"Largest","group":"text","style":{"fontSize":"1.3em"},"button":{"label":"A","style":{"fontSize":"1.03em"}}},"small":{"label":"Small","group":"text","style":{"fontSize":"0.9em"},"button":{"label":"A","style":{"fontSize":"0.99em"}}},"smaller":{"label":"Smaller","group":"text","style":{"fontSize":"0.8em"},"button":{"label":"A","style":{"fontSize":"0.98em"}}},"smallest":{"label":"Smallest","group":"text","style":{"fontSize":"0.7em"},"button":{"label":"A","style":{"fontSize":"0.97em"}}},"mark":{"label":"Mark","group":"text","button":{"label":"M"},"style":{"backgroundColor":"#F7C33F"}},"del":{"label":"Deleted","group":"text","style":{"textDecoration":"line-through"},"button":{"label":"D","style":{"textDecoration":"line-through"}}},"ins":{"label":"Inserted","group":"text","style":{"textDecoration":"underline"},"button":{"label":"U","style":{"textDecoration":"underline"}}},"sub":{"label":"Subscript","group":"text","style":{"verticalAlign":"sub","fontSize":"0.6em"},"button":{"label":"Sub","style":{"verticalAlign":"sub","fontSize":"0.6em"}}},"sup":{"label":"Superscript","group":"text","style":{"verticalAlign":"sup","fontSize":"0.6em"},"button":{"label":"Sup","style":{"verticalAlign":"sup","fontSize":"0.6em"}}},"main":{"label":"Main","group":"color","type":"color","style":{"color":"#818898"}},"mainGradient":{"label":"Main gradient","group":"color","type":"color","style":{"backgroundSize":"100%","-webkitBackgroundClip":"text","-mozBackgroundClip":"text","-webkitTextFillColor":"transparent","-mozTextFillColor":"transparent","backgroundImage":"linear-gradient(90deg, #818898 0%, #8f95a3 100%)"}},"accent":{"label":"Accent","group":"color","type":"color","style":{"color":"#F7C33F"}},"accentGradient":{"label":"Accent gradient","group":"color","type":"color","style":{"backgroundSize":"100%","-webkitBackgroundClip":"text","-mozBackgroundClip":"text","-webkitTextFillColor":"transparent","-mozTextFillColor":"transparent","backgroundImage":"linear-gradient(90deg, #F7C33F 0%, #f8c954 100%)"}},"complementary":{"label":"Complementary","group":"color","type":"color","style":{"color":"#F9656E"}},"complementaryGradient":{"label":"Complementary gradient","group":"color","type":"color","style":{"backgroundSize":"100%","-webkitBackgroundClip":"text","-mozBackgroundClip":"text","-webkitTextFillColor":"transparent","-mozTextFillColor":"transparent","backgroundImage":"linear-gradient(90deg, #F9656E 0%, #f97b83 100%)"}},"success":{"label":"Success","group":"color","type":"color","style":{"color":"#91ff00"}},"successGradient":{"label":"Success gradient","group":"color","type":"color","style":{"backgroundSize":"100%","-webkitBackgroundClip":"text","-mozBackgroundClip":"text","-webkitTextFillColor":"transparent","-mozTextFillColor":"transparent","backgroundImage":"linear-gradient(90deg, #91ff00 0%, #9cff1a 100%)"}},"warning":{"label":"Warning","group":"color","type":"color","style":{"color":"#ffd500"}},"warningGradient":{"label":"Warning gradient","group":"color","type":"color","style":{"backgroundSize":"100%","-webkitBackgroundClip":"text","-mozBackgroundClip":"text","-webkitTextFillColor":"transparent","-mozTextFillColor":"transparent","backgroundImage":"linear-gradient(90deg, #ffd500 0%, #ffd91a 100%)"}},"error":{"label":"Error","group":"color","type":"color","style":{"color":"#ff003b"}},"errorGradient":{"label":"Error gradient","group":"color","type":"color","style":{"backgroundSize":"100%","-webkitBackgroundClip":"text","-mozBackgroundClip":"text","-webkitTextFillColor":"transparent","-mozTextFillColor":"transparent","backgroundImage":"linear-gradient(90deg, #ff003b 0%, #ff1a4f 100%)"}},"info":{"label":"Info","group":"color","type":"color","style":{"color":"#00ffff"}},"infoGradient":{"label":"Info gradient","group":"color","type":"color","style":{"backgroundSize":"100%","-webkitBackgroundClip":"text","-mozBackgroundClip":"text","-webkitTextFillColor":"transparent","-mozTextFillColor":"transparent","backgroundImage":"linear-gradient(90deg, #00ffff 0%, #1affff 100%)"}}},"wireframe":{"light":{"border":"1px solid rgba(0,0,0,0.1)","borderColor":"rgba(0,0,0,0.1)","background":"#ffffff","surface":"#fafafa"},"dark":{"border":"1px solid rgba(255,255,255,0.2)","borderColor":"rgba(255,255,255,0.2)","background":"#2D323A","surface":"#3B424C"}},"metas":{"title":"Default light","description":"Nice and elegant light theme"},"shades":{"text":{"darken":0,"color":{"main":{"darken":15},"complementary":{"lighten":15},"info":{"darken":10}}},"placeholder":{"darken":0,"alpha":0.4},"foreground":{"lighten":50},"background":{"lighten":50},"surface":{"lighten":40,"color":{"main":{"lighten":49}}},"ui":{"lighten":49},"uiBackground":{"lighten":48},"border":{"alpha":0.2},"hover":{"lighten":40},"active":{"darken":10},"gradientStart":{"lighten":0},"gradientEnd":{"lighten":20}}},"default-dark":{"color":{"current":"#808080","main":"#808080","accent":"#ffbb00","complementary":"#8054F9","success":"#91ff00","warning":"#ffd500","error":"#ff003b","info":"#00ffff"},"classmap":{"enabled":false,"url":"/classmap.json"},"lod":{"enabled":false,"defaultLevel":3,"botLevel":1,"levels":{"0":{"name":"bare","speedIndex":0},"1":{"name":"lnf","speedIndex":30},"2":{"name":"theme","speedIndex":40},"3":{"name":"high","speedIndex":50},"4":{"name":"ultra","speedIndex":60}},"method":"class","defaultAction":">=","cssProperties":{}},"easing":{"default":"cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"scroll":{"duration":300,"delay":500,"offset":0,"offsetX":0,"offsetY":200},"partytown":{"enabled":true,"forward":["dataLayer.push","fbq","freshpaint.addPageviewProperties","freshpaint.identify","freshpaint.track","_hsq.push","Intercom","_learnq.push","ttq.track","ttq.page","ttq.load","mixpanel.track"]},"timing":{"slow":".6s","default":".3s","fast":".1s"},"transition":{"slow":"all .6s cubic-bezier(0.700, 0.000, 0.305, 0.995)","default":"all .3s cubic-bezier(0.700, 0.000, 0.305, 0.995)","fast":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)"},"gradient":{"defaultModifierStart":{},"defaultModifierEnd":{"lighten":20},"defaultX":"50%","defaultY":"50%","defaultAngle":"90deg","defaultTextModifierStart":{"darken":5},"defaultTextModifierEnd":{"lighten":5},"defaultTextAngle":"90deg"},"helpers":{"states":["mounted","active","loading"],"clearfix":{"default":"overflow"},"disabled":{"opacity":0.4},"truncate":{"count":10},"order":{"count":20}},"layout":{"offset":{"top":100,"right":0,"bottom":0,"left":0},"container":{"default":"1280px","wide":"1440px","full":"none"},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","21":"2 1","112":"1 1 2","122":"1 2 2","123":"1 2 3","211":"2 1 1","221":"2 2 1","321":"3 2 1","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","2221":"2 2 2 1","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","22221":"2 2 2 2 1","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6","1_2":"1 _ 2","2_1":"2 _ 1","12_33":"1 2 _ 3 3","1_23":"1 _ 2 3","1_2_3":"1 _ 2 _ 3","32_1":"3 2 _ 1","3_21":"3 _ 2 1","12_34":"1 2 _ 3 4","123_4":"1 2 3 _ 4","1_234":"1 _ 2 3 4","1_2_3_4":"1 _ 2 _ 3 _ 4","123_45":"1 2 3 _ 4 5","12_345":"1 2 _ 3 4 5","1_2345":"1 _ 2 3 4 5","1234_5":"1 2 3 4 _ 5","1_2_3_4_5":"1 _ 2 _ 3 _ 4 _ 5"}},"ratio":{"1":1,"16-9":1.7777777777777777,"16-10":1.6,"21-9":2.3333333333333335,"1-2":0.5,"2-1":2,"2-3":0.6666666666666666,"3-2":1.5,"4-3":1.3333333333333333,"3-4":0.75},"scalable":{"margin":false,"padding":true,"offsize":false,"font":true},"scale":{"10":1,"11":1.1,"12":1.2,"13":1.3,"14":1.4,"15":1.5,"16":1.6,"17":1.7,"18":1.8,"19":1.9,"20":2,"21":2.1,"22":2.2,"23":2.3,"24":2.4,"25":25,"26":2.6,"27":2.7,"28":2.8,"29":2.9,"30":3,"default":1,"01":0.1,"02":0.2,"03":0.3,"04":0.4,"05":0.5,"06":0.6,"07":0.7,"08":0.8,"09":0.9},"opacity":{"0":0,"10":0.1,"20":0.2,"30":0.3,"40":0.4,"50":0.5,"60":0.6,"70":0.7,"80":0.8,"90":0.9,"100":1},"width":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"height":{"0":"0","10":"10%","20":"20%","30":"30%","40":"40%","50":"50%","60":"60%","70":"70%","80":"80%","90":"90%","100":"100%"},"depth":{"0":"0","5":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.006),\\n  0px 2.5px 1.5px rgba(0, 0, 0, 0.005),\\n  0px 3.5px 3.4px rgba(0, 0, 0, 0.006),\\n  0px 4.4px 4.3px rgba(0, 0, 0, 0.007),\\n  0px 10px 10px rgba(0, 0, 0, 0.01)","10":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","20":"0px 0.6px 0.4px rgba(0, 0, 0, 0.006),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.008),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.01),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.012),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.014),\\n  0px 20px 15px rgba(0, 0, 0, 0.02)","30":"0px 0.6px 0.4px rgba(0, 0, 0, 0.008),\\n  0px 1.3px 1px rgba(0, 0, 0, 0.012),\\n  0px 2.5px 1.9px rgba(0, 0, 0, 0.015),\\n  0px 4.5px 3.4px rgba(0, 0, 0, 0.018),\\n  0px 8.4px 6.3px rgba(0, 0, 0, 0.022),\\n  0px 20px 15px rgba(0, 0, 0, 0.03)","40":"0px 0.8px 0.6px rgba(0, 0, 0, 0.008),\\n  0px 2px 1.3px rgba(0, 0, 0, 0.012),\\n  0px 3.8px 2.5px rgba(0, 0, 0, 0.015),\\n  0px 6.7px 4.5px rgba(0, 0, 0, 0.018),\\n  0px 12.5px 8.4px rgba(0, 0, 0, 0.022),\\n  0px 30px 20px rgba(0, 0, 0, 0.03)","50":"0px 1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 2px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 35px 30px rgba(0, 0, 0, 0.04)","60":"0px 1px 0.7px rgba(0, 0, 0, 0.011),\\n  0px 2.3px 1.7px rgba(0, 0, 0, 0.016),\\n  0px 4.4px 3.1px rgba(0, 0, 0, 0.02),\\n  0px 7.8px 5.6px rgba(0, 0, 0, 0.024),\\n  0px 14.6px 10.4px rgba(0, 0, 0, 0.029),\\n  0px 35px 25px rgba(0, 0, 0, 0.04)","70":"0px 1.1px 0.8px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2px rgba(0, 0, 0, 0.016),\\n  0px 5px 3.8px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 6.7px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 12.5px rgba(0, 0, 0, 0.029),\\n  0px 40px 30px rgba(0, 0, 0, 0.04)","80":"0px 1.1px 1px rgba(0, 0, 0, 0.011),\\n  0px 2.7px 2.3px rgba(0, 0, 0, 0.016),\\n  0px 5px 4.4px rgba(0, 0, 0, 0.02),\\n  0px 8.9px 7.8px rgba(0, 0, 0, 0.024),\\n  0px 16.7px 14.6px rgba(0, 0, 0, 0.029),\\n  0px 40px 35px rgba(0, 0, 0, 0.04)","90":"0px 1.4px 1.1px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 2.7px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 8.9px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 16.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 40px rgba(0, 0, 0, 0.04)","100":"0px 1.4px 1.4px rgba(0, 0, 0, 0.011),\\n  0px 3.3px 3.5px rgba(0, 0, 0, 0.016),\\n  0px 6.1px 6.5px rgba(0, 0, 0, 0.02),\\n  0px 10.9px 11.6px rgba(0, 0, 0, 0.024),\\n  0px 20.5px 21.7px rgba(0, 0, 0, 0.029),\\n  0px 49px 52px rgba(0, 0, 0, 0.04)","default":"0"},"size":{"0":0.25,"5":"0.5","10":0.65,"15":0.7,"20":0.75,"25":0.95,"30":1.1,"40":1.4,"50":1.8,"60":2.5,"70":3.5,"80":4.5,"90":5.5,"100":7,"default":16},"font":{"family":{"default":{"fontFamily":"\\"Roboto\\"","fontWeight":400,"import":"https://fonts.googleapis.com/css2?family=Roboto&display=swap"},"title":{"fontFamily":"\\"Roboto\\"","fontWeight":500,"import":"https://fonts.googleapis.com/css2?family=Roboto:wght@500&display=swap"},"quote":{"fontFamily":"\\"Palatino, Times, Georgia, serif\\"","fontWeight":"normal","fontStyle":"normal","fontDisplay":"auto","capHeight":0.65},"code":{"fontFamily":"Menlo, Monaco, Consolas, Courier New, monospace","fontWeight":"normal","fontStyle":"normal","fontDisplay":"auto","capHeight":0.65}},"size":{"0":0,"5":"0.5","10":0.65,"15":0.7,"20":0.75,"25":0.95,"30":1.1,"40":1.4,"50":1.8,"60":2.5,"70":3.5,"80":4.5,"90":5.5,"100":7,"default":16}},"border":{"width":{"0":0,"10":1,"20":2,"30":4,"40":6,"50":8,"60":12,"70":16,"80":20,"90":24,"100":30,"default":"1px"},"radius":{"0":0,"10":0.8,"20":1.6,"30":2.4,"40":3.2,"50":4,"60":5.2,"70":6.4,"80":8,"90":10,"100":12,"default":"5px"}},"space":{"0":0,"10":0.375,"20":0.75,"30":1.4,"40":2,"50":3.5,"60":5,"70":7.5,"80":10,"90":15,"100":20,"default":16},"margin":{"0":0,"10":0.375,"20":0.75,"30":1.4,"40":2,"50":3.5,"60":5,"70":7.5,"80":10,"90":15,"100":20,"default":16},"padding":{"0":0,"10":0.375,"20":0.75,"30":1.4,"40":2,"50":3.5,"60":5,"70":7.5,"80":10,"90":15,"100":20,"default":16},"offsize":{"0":0,"10":0.375,"20":0.75,"30":1.4,"40":2,"50":3.5,"60":5,"70":7.5,"80":10,"90":15,"100":20,"default":16},"media":{"defaultAction":"<=","defaultMedia":"desktop","queries":{"mobile":{"minWidth":0,"maxWidth":639},"tablet":{"minWidth":640,"maxWidth":1279},"desktop":{"minWidth":1280,"maxWidth":2047},"wide":{"minWidth":2048,"maxWidth":null}}},"ui":{"default":{"paddingInline":1.25,"paddingBlock":0.75,"borderRadius":1,"borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultLnf":"solid","depth":"0","outline":true,"spacing":1.4,"rhythmVertical":{"margin-bottom":60}},"menu":{"paddingInline":2,"paddingBlock":1.4,"borderRadius":1,"borderWidth":"1px","transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","defaultLnf":"solid","defaultType":"primary","depth":"0","rhythmVertical":{"margin-bottom":60}},"card":{"paddingInline":3.5,"paddingBlock":3.5},"form":{"paddingInline":1,"paddingBlock":0.75,"borderRadius":1,"transition":"all .1s cubic-bezier(0.700, 0.000, 0.305, 0.995)","outline":true,"rhythmVertical":{"margin-bottom":40}},"outline":{"active":true,"borderWidth":"10px","borderRadius":1,"transition":"all .2s ease-out"},"scrollbar":{"size":"2px","color":"accent"},"label":{"defaultLnf":"inline"},"dropdown":{"paddingInline":0.75,"paddingBlock":0.75,"itemPaddingInline":1.25,"itemPaddingBlock":0.75},"list":{"defaultLnf":"dl","bulletChar":"-"},"fsTree":{"bulletChar":"●"},"tooltip":{"defaultPosition":"top","arrowSize":"15px"},"loader":{"duration":"1s","easing":"linear"}},"typo":{"h1":{"label":"H1","group":"style","style":{"display":"block","fontFamily":"title","fontSize":80,"lineHeight":1.3,"maxWidth":"55ch","mobile":{"fontSize":70}},"rhythmVertical":{"marginBottom":50}},"h2":{"label":"H2","group":"style","style":{"display":"block","fontFamily":"title","fontSize":70,"lineHeight":1.3,"maxWidth":"55ch","mobile":{"fontSize":60}},"rhythmVertical":{"marginBottom":50}},"h3":{"label":"H3","group":"style","style":{"display":"block","fontFamily":"title","fontSize":60,"lineHeight":1.3,"maxWidth":"55ch","mobile":{"fontSize":50}},"rhythmVertical":{"marginBottom":50}},"h4":{"label":"H4","group":"style","style":{"display":"block","fontFamily":"title","fontSize":50,"lineHeight":1.3,"maxWidth":"55ch","mobile":{"fontSize":40}},"rhythmVertical":{"marginBottom":50}},"h5":{"label":"H5","group":"style","style":{"display":"block","fontFamily":"title","fontSize":40,"lineHeight":1.3,"maxWidth":"55ch","mobile":{"fontSize":30}},"rhythmVertical":{"marginBottom":40}},"h6":{"label":"H6","group":"style","style":{"display":"block","fontFamily":"title","fontSize":30,"lineHeight":1.3,"maxWidth":"55ch","mobile":{"fontSize":30}},"hythmVertical":{"marginBottom":40}},"p":{"label":"Paragraph","group":"style","default":true,"style":{"display":"block","fontFamily":"default","fontSize":30,"lineHeight":1.8,"maxWidth":"55ch","color":["main","text","--alpha 0.7"]},"rhythmVertical":{"marginBottom":40}},"lead":{"label":"Lead paragraph","group":"style","style":{"display":"block","fontFamily":"default","fontSize":40,"lineHeight":1.6,"maxWidth":"55ch","mobile":{"fontSize":40}},"rhythmVertical":{"marginBottom":40}},"hr":{"label":"--","group":"block","button":{"label":"--"},"style":{"display":"block","color":"#818898","opacity":0.2},"rhythmVertical":{"marginBottom":50}},"pre:not([class])":{"label":"Pre","group":"text","style":{"display":"block","fontFamily":"code","color":["main","text"],"backgroundColor":["main","surface"],"lineHeight":1.5,"paddingInline":1.25,"paddingBlock":0.75,"borderRadius":1,"depth":"0"},"rhythmVertical":{"marginBottom":50}},"code:not(pre > code)":{"label":"Code","group":"text","button":{"label":"</>"},"style":{"display":"inline-block","fontFamily":"code","color":["main","text"],"lineHeight":1.1,"backgroundColor":["accent","surface"],"borderRadius":10,"paddingInline":10,"paddingBlock":0}},"blockquote":{"label":"Blockquote","group":"block","button":{"label":"<svg viewBox=\\"0 0 20 20\\"><path d=\\"M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z\\"></path></svg>"},"style":{"display":"block","fontFamily":"quote"},"editor":{"style":{"paddingInlineStart":1.25,"borderLeft":"1px solid #000"}},"rhythmVertical":{"marginBottom":50}},"a":{"label":"Link","group":"text","button":{"label":"<svg viewBox=\\"0 0 20 20\\"><path d=\\"m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z\\"></path></svg>"},"style":{"color":"accent","textDecoration":"underline"}},"quote":{"label":"Quote","group":"text","button":{"label":"<svg viewBox=\\"0 0 20 20\\"><path d=\\"M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z\\"></path></svg>"},"style":{"fontFamily":"quote"},"rhythmVertical":{"marginBottom":50}},"bold":{"label":"Bold","group":"text","style":{"fontWeight":"bold"},"button":{"label":"B","style":{"fontWeight":"bolder"}}},"italic":{"label":"Italic","group":"text","style":{"fontStyle":"italic"},"button":{"label":"I","style":{"fontStyle":"italic"}}},"large":{"label":"Large","group":"text","style":{"fontSize":"1.1em"},"button":{"label":"A","style":{"fontSize":"1.01em"}}},"larger":{"label":"Larger","group":"text","style":{"fontSize":"1.2em"},"button":{"label":"A","style":{"fontSize":"1.02em"}}},"largest":{"label":"Largest","group":"text","style":{"fontSize":"1.3em"},"button":{"label":"A","style":{"fontSize":"1.03em"}}},"small":{"label":"Small","group":"text","style":{"fontSize":"0.9em"},"button":{"label":"A","style":{"fontSize":"0.99em"}}},"smaller":{"label":"Smaller","group":"text","style":{"fontSize":"0.8em"},"button":{"label":"A","style":{"fontSize":"0.98em"}}},"smallest":{"label":"Smallest","group":"text","style":{"fontSize":"0.7em"},"button":{"label":"A","style":{"fontSize":"0.97em"}}},"mark":{"label":"Mark","group":"text","button":{"label":"M"},"style":{"backgroundColor":"#F7C33F"}},"del":{"label":"Deleted","group":"text","style":{"textDecoration":"line-through"},"button":{"label":"D","style":{"textDecoration":"line-through"}}},"ins":{"label":"Inserted","group":"text","style":{"textDecoration":"underline"},"button":{"label":"U","style":{"textDecoration":"underline"}}},"sub":{"label":"Subscript","group":"text","style":{"verticalAlign":"sub","fontSize":"0.6em"},"button":{"label":"Sub","style":{"verticalAlign":"sub","fontSize":"0.6em"}}},"sup":{"label":"Superscript","group":"text","style":{"verticalAlign":"sup","fontSize":"0.6em"},"button":{"label":"Sup","style":{"verticalAlign":"sup","fontSize":"0.6em"}}},"main":{"label":"Main","group":"color","type":"color","style":{"color":"#818898"}},"mainGradient":{"label":"Main gradient","group":"color","type":"color","style":{"backgroundSize":"100%","-webkitBackgroundClip":"text","-mozBackgroundClip":"text","-webkitTextFillColor":"transparent","-mozTextFillColor":"transparent","backgroundImage":"linear-gradient(90deg, #818898 0%, #8f95a3 100%)"}},"accent":{"label":"Accent","group":"color","type":"color","style":{"color":"#F7C33F"}},"accentGradient":{"label":"Accent gradient","group":"color","type":"color","style":{"backgroundSize":"100%","-webkitBackgroundClip":"text","-mozBackgroundClip":"text","-webkitTextFillColor":"transparent","-mozTextFillColor":"transparent","backgroundImage":"linear-gradient(90deg, #F7C33F 0%, #f8c954 100%)"}},"complementary":{"label":"Complementary","group":"color","type":"color","style":{"color":"#F9656E"}},"complementaryGradient":{"label":"Complementary gradient","group":"color","type":"color","style":{"backgroundSize":"100%","-webkitBackgroundClip":"text","-mozBackgroundClip":"text","-webkitTextFillColor":"transparent","-mozTextFillColor":"transparent","backgroundImage":"linear-gradient(90deg, #F9656E 0%, #f97b83 100%)"}},"success":{"label":"Success","group":"color","type":"color","style":{"color":"#91ff00"}},"successGradient":{"label":"Success gradient","group":"color","type":"color","style":{"backgroundSize":"100%","-webkitBackgroundClip":"text","-mozBackgroundClip":"text","-webkitTextFillColor":"transparent","-mozTextFillColor":"transparent","backgroundImage":"linear-gradient(90deg, #91ff00 0%, #9cff1a 100%)"}},"warning":{"label":"Warning","group":"color","type":"color","style":{"color":"#ffd500"}},"warningGradient":{"label":"Warning gradient","group":"color","type":"color","style":{"backgroundSize":"100%","-webkitBackgroundClip":"text","-mozBackgroundClip":"text","-webkitTextFillColor":"transparent","-mozTextFillColor":"transparent","backgroundImage":"linear-gradient(90deg, #ffd500 0%, #ffd91a 100%)"}},"error":{"label":"Error","group":"color","type":"color","style":{"color":"#ff003b"}},"errorGradient":{"label":"Error gradient","group":"color","type":"color","style":{"backgroundSize":"100%","-webkitBackgroundClip":"text","-mozBackgroundClip":"text","-webkitTextFillColor":"transparent","-mozTextFillColor":"transparent","backgroundImage":"linear-gradient(90deg, #ff003b 0%, #ff1a4f 100%)"}},"info":{"label":"Info","group":"color","type":"color","style":{"color":"#00ffff"}},"infoGradient":{"label":"Info gradient","group":"color","type":"color","style":{"backgroundSize":"100%","-webkitBackgroundClip":"text","-mozBackgroundClip":"text","-webkitTextFillColor":"transparent","-mozTextFillColor":"transparent","backgroundImage":"linear-gradient(90deg, #00ffff 0%, #1affff 100%)"}}},"wireframe":{"light":{"border":"1px solid rgba(0,0,0,0.1)","borderColor":"rgba(0,0,0,0.1)","background":"#ffffff","surface":"#fafafa"},"dark":{"border":"1px solid rgba(255,255,255,0.2)","borderColor":"rgba(255,255,255,0.2)","background":"#2D323A","surface":"#3B424C"}},"metas":{"title":"Default dark","description":"Nice and elegant dark theme"},"shades":{"text":{"lighten":10,"color":{"main":{"lighten":50}}},"placeholder":{"lighten":50,"alpha":0.4},"foreground":{"lighten":50},"background":{"darken":30},"surface":{"darken":25},"ui":{"lighten":10},"uiBackground":{"darken":27},"border":{"alpha":0.4},"hover":{"lighten":40},"active":{"darken":10},"gradientStart":{"lighten":0},"gradientEnd":{"darken":20}}}}}}},"FRONTSPEC":{"metas":{"lang":"en","title":"@coffeekraken/s-postcss-sugar-plugin","homepage":"https://coffeekraken.io","description":"Postcss Coffeekraken plugin that gives you access to a ton of sugar like \\"@sugar.when.dark\\", \\"@sugar.classes\\", etc... mixins as well as functions like \\"sugar.padding\\", \\"sugar.color\\", etc... All of these makes uses of your theme configuration defined using the @coffeekraken/s-sugar-config system.","keywords":["coffeekraken","coffee","kraken","sugar","postcss","styleguide","color","margin","padding","ui"],"themeColor":"#F7C33F","author":{"name":"Olivier Bossel","email":"olivier.bossel@gmail.com","url":"https://coffeekraken.io"},"og":{"title":"@coffeekraken/s-postcss-sugar-plugin","description":"Postcss Coffeekraken plugin that gives you access to a ton of sugar like \\"@sugar.when.dark\\", \\"@sugar.classes\\", etc... mixins as well as functions like \\"sugar.padding\\", \\"sugar.color\\", etc... All of these makes uses of your theme configuration defined using the @coffeekraken/s-sugar-config system.","type":"website","url":"https://coffeekraken.io","image":"https://cdnv2.coffeekraken.io/global/coffeekraken-og.png"}},"package":{"name":"@coffeekraken/s-postcss-sugar-plugin","description":"Postcss Coffeekraken plugin that gives you access to a ton of sugar like \\"@sugar.when.dark\\", \\"@sugar.classes\\", etc... mixins as well as functions like \\"sugar.padding\\", \\"sugar.color\\", etc... All of these makes uses of your theme configuration defined using the @coffeekraken/s-sugar-config system.","version":"2.0.0-beta.1","author":"Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)","license":"MIT"},"favicon":{"rootDir":"./dist/favicon","fileName":"favicon.html","filePath":"./dist/favicon/favicon.html"},"theme":{"theme":"coffeekraken","variant":"dark","themes":{"coffeekraken-dark":{"title":"Coffeekraken dark","description":"Nice and elegant coffeekraken dark theme"},"default-light":{"title":"Default light","description":"Nice and elegant light theme"},"default-dark":{"title":"Default dark","description":"Nice and elegant dark theme"}},"lnf":{"margin":{"0":0,"10":0.375,"20":0.75,"30":1.4,"40":2,"50":3.5,"60":5,"70":7.5,"80":10,"90":15,"100":20,"default":16},"padding":{"0":0,"10":0.375,"20":0.75,"30":1.4,"40":2,"50":3.5,"60":5,"70":7.5,"80":10,"90":15,"100":20,"default":16},"font":{"family":{"default":{"fontFamily":"\\"Roboto\\"","fontWeight":400,"import":"https://fonts.googleapis.com/css2?family=Roboto&display=swap"},"title":{"fontFamily":"\\"Roboto\\"","fontWeight":500,"import":"https://fonts.googleapis.com/css2?family=Roboto:wght@500&display=swap"},"quote":{"fontFamily":"\\"Palatino, Times, Georgia, serif\\"","fontWeight":"normal","fontStyle":"normal","fontDisplay":"auto","capHeight":0.65},"code":{"fontFamily":"Menlo, Monaco, Consolas, Courier New, monospace","fontWeight":"normal","fontStyle":"normal","fontDisplay":"auto","capHeight":0.65}},"size":{"0":0,"5":"0.5","10":0.65,"15":0.7,"20":0.75,"25":0.95,"30":1.1,"40":1.4,"50":1.8,"60":2.5,"70":3.5,"80":4.5,"90":5.5,"100":7,"default":16}},"layout":{"offset":{"top":100,"right":0,"bottom":0,"left":0},"container":{"default":"1280px","wide":"1440px","full":"none"},"grid":{"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"11":11,"12":12},"layout":{"1":"1","12":"1 2","21":"2 1","112":"1 1 2","122":"1 2 2","123":"1 2 3","211":"2 1 1","221":"2 2 1","321":"3 2 1","1112":"1 1 1 2","1222":"1 2 2 2","1234":"1 2 3 4","2221":"2 2 2 1","11112":"1 1 1 1 2","12222":"1 2 2 2 2","12345":"1 2 3 4 5","22221":"2 2 2 2 1","111112":"1 1 1 1 1 2","122222":"1 2 2 2 2 2","123456":"1 2 3 4 5 6","1_2":"1 _ 2","2_1":"2 _ 1","12_33":"1 2 _ 3 3","1_23":"1 _ 2 3","1_2_3":"1 _ 2 _ 3","32_1":"3 2 _ 1","3_21":"3 _ 2 1","12_34":"1 2 _ 3 4","123_4":"1 2 3 _ 4","1_234":"1 _ 2 3 4","1_2_3_4":"1 _ 2 _ 3 _ 4","123_45":"1 2 3 _ 4 5","12_345":"1 2 _ 3 4 5","1_2345":"1 _ 2 3 4 5","1234_5":"1 2 3 4 _ 5","1_2_3_4_5":"1 _ 2 _ 3 _ 4 _ 5"}},"typo":{"h1":{"label":"H1","group":"style","button":{},"editor":{},"style":{"display":"block","fontFamily":"\\"Roboto\\"","fontSize":"72px","lineHeight":1.3,"maxWidth":"55ch","marginBottom":"56px"}},"h2":{"label":"H2","group":"style","button":{},"editor":{},"style":{"display":"block","fontFamily":"\\"Roboto\\"","fontSize":"56px","lineHeight":1.3,"maxWidth":"55ch","marginBottom":"56px"}},"h3":{"label":"H3","group":"style","button":{},"editor":{},"style":{"display":"block","fontFamily":"\\"Roboto\\"","fontSize":"40px","lineHeight":1.3,"maxWidth":"55ch","marginBottom":"56px"}},"h4":{"label":"H4","group":"style","button":{},"editor":{},"style":{"display":"block","fontFamily":"\\"Roboto\\"","fontSize":"28.8px","lineHeight":1.3,"maxWidth":"55ch","marginBottom":"56px"}},"h5":{"label":"H5","group":"style","button":{},"editor":{},"style":{"display":"block","fontFamily":"\\"Roboto\\"","fontSize":"22.4px","lineHeight":1.3,"maxWidth":"55ch","marginBottom":"32px"}},"h6":{"label":"H6","group":"style","button":{},"editor":{},"style":{"display":"block","fontFamily":"\\"Roboto\\"","fontSize":"17.6px","lineHeight":1.3,"maxWidth":"55ch"}},"p":{"label":"Paragraph","group":"style","button":{},"editor":{},"style":{"display":"block","fontFamily":"\\"Roboto\\"","fontSize":"17.6px","lineHeight":1.8,"maxWidth":"55ch","color":"#ffffff","marginBottom":"32px"},"default":true},"lead":{"label":"Lead paragraph","group":"style","button":{},"editor":{},"style":{"display":"block","fontFamily":"\\"Roboto\\"","fontSize":"22.4px","lineHeight":1.6,"maxWidth":"55ch","marginBottom":"32px"}},"hr":{"label":"--","group":"block","button":{"label":"--"},"editor":{},"style":{"display":"block","color":"#818898","opacity":0.2,"marginBottom":"56px"}},"pre":{"label":"Pre","group":"text","button":{},"editor":{},"style":{"display":"block","fontFamily":"Menlo, Monaco, Consolas, Courier New, monospace","color":"#ffffff","backgroundColor":"#454954","lineHeight":1.5,"paddingInline":"20px","paddingBlock":"12px","borderRadius":"NaNpx","depth":"0","marginBottom":"56px"}},"code":{"label":"Code","group":"text","button":{"label":"</>"},"editor":{},"style":{"display":"inline-block","fontFamily":"Menlo, Monaco, Consolas, Courier New, monospace","color":"#ffffff","lineHeight":1.1,"backgroundColor":"#ab7d07","borderRadius":"NaNpx","paddingInline":"6px","paddingBlock":"0px"}},"blockquote":{"label":"Blockquote","group":"block","button":{"label":"<svg viewBox=\\"0 0 20 20\\"><path d=\\"M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z\\"></path></svg>"},"editor":{"style":{"paddingInlineStart":1.25,"borderLeft":"1px solid #000"}},"style":{"display":"block","fontFamily":"\\"Palatino, Times, Georgia, serif\\"","marginBottom":"56px"}},"a":{"label":"Link","group":"text","button":{"label":"<svg viewBox=\\"0 0 20 20\\"><path d=\\"m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z\\"></path></svg>"},"editor":{},"style":{"color":"#f7c23b","textDecoration":"underline"}},"quote":{"label":"Quote","group":"text","button":{"label":"<svg viewBox=\\"0 0 20 20\\"><path d=\\"M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z\\"></path></svg>"},"editor":{},"style":{"fontFamily":"\\"Palatino, Times, Georgia, serif\\"","marginBottom":"56px"}},"bold":{"label":"Bold","group":"text","button":{"label":"B","style":{"fontWeight":"bolder"}},"editor":{},"style":{"fontWeight":"bold"}},"italic":{"label":"Italic","group":"text","button":{"label":"I","style":{"fontStyle":"italic"}},"editor":{},"style":{"fontStyle":"italic"}},"large":{"label":"Large","group":"text","button":{"label":"A","style":{"fontSize":"1.01em"}},"editor":{},"style":{"fontSize":"1.1em"}},"larger":{"label":"Larger","group":"text","button":{"label":"A","style":{"fontSize":"1.02em"}},"editor":{},"style":{"fontSize":"1.2em"}},"largest":{"label":"Largest","group":"text","button":{"label":"A","style":{"fontSize":"1.03em"}},"editor":{},"style":{"fontSize":"1.3em"}},"small":{"label":"Small","group":"text","button":{"label":"A","style":{"fontSize":"0.99em"}},"editor":{},"style":{"fontSize":"0.9em"}},"smaller":{"label":"Smaller","group":"text","button":{"label":"A","style":{"fontSize":"0.98em"}},"editor":{},"style":{"fontSize":"0.8em"}},"smallest":{"label":"Smallest","group":"text","button":{"label":"A","style":{"fontSize":"0.97em"}},"editor":{},"style":{"fontSize":"0.7em"}},"mark":{"label":"Mark","group":"text","button":{"label":"M"},"editor":{},"style":{"backgroundColor":"#f7c23b"}},"del":{"label":"Deleted","group":"text","button":{"label":"D","style":{"textDecoration":"line-through"}},"editor":{},"style":{"textDecoration":"line-through"}},"ins":{"label":"Inserted","group":"text","button":{"label":"U","style":{"textDecoration":"underline"}},"editor":{},"style":{"textDecoration":"underline"}},"sub":{"label":"Subscript","group":"text","button":{"label":"Sub","style":{"verticalAlign":"sub","fontSize":"0.6em"}},"editor":{},"style":{"verticalAlign":"sub","fontSize":"0.6em"}},"sup":{"label":"Superscript","group":"text","button":{"label":"Sup","style":{"verticalAlign":"sup","fontSize":"0.6em"}},"editor":{},"style":{"verticalAlign":"sup","fontSize":"0.6em"}},"main":{"label":"Main","group":"color","type":"color","button":{},"editor":{},"style":{"color":"#818898"}},"accent":{"label":"Accent","group":"color","type":"color","button":{},"editor":{},"style":{"color":"#f7c23b"}},"complementary":{"label":"Complementary","group":"color","type":"color","button":{},"editor":{},"style":{"color":"#f8626c"}},"success":{"label":"Success","group":"color","type":"color","button":{},"editor":{},"style":{"color":"#91ff00"}},"warning":{"label":"Warning","group":"color","type":"color","button":{},"editor":{},"style":{"color":"#ffd500"}},"error":{"label":"Error","group":"color","type":"color","button":{},"editor":{},"style":{"color":"#ff003c"}},"info":{"label":"Info","group":"color","type":"color","button":{},"editor":{},"style":{"color":"#00ffff"}}}}},"media":{"defaultAction":"<=","defaultMedia":"desktop","queries":{"wide":{"minWidth":2048,"maxWidth":null},"desktop":{"minWidth":1280,"maxWidth":2047},"tablet":{"minWidth":640,"maxWidth":1279},"mobile":{"minWidth":0,"maxWidth":639}}},"google":{"gtm":"GTM-K4LMN8Q","map":{"apiKey":"AIzaSyDzFfEzhmYXRTlONUCtMWQ88uHJhsbtXY4"}}},"CLASSMAP":null,"PACKAGE":{"name":"@website/sugarcss-coffeekraken-io","title":"Coffeekraken SugarCSS","version":"2.0.0-beta.1","description":"The frontend toolkit that works for everyone. Experts, professionals and new-comers","keywords":["coffeekraken","coffee","kraken","sugar","postcss","styleguide","color","margin","padding","ui"],"type":"module","private":true,"scripts":{"dev":"sugar kitchen.run dev & npm run doc.serve","build":"sugar kitchen.run build --target production","preview":"sugar kitchen.run preview & npm run doc.serve","static":"npm run preview & sleep 5 && npm run static.build && npm run static.serve","static.serve":"sugar staticServer.start","static.build":"sugar static.build --clean --env production --target production","doc.serve":"sugar doc.serve","deploy":"rsync -avzh --delete --progress --stats ./static fe0mt_coffeekraken@fe0mt.ftp.infomaniak.com:~/sites/sugarcss.coffeekraken.io","server.ssh":"ssh root@194.233.173.214"},"repository":{"type":"git","url":"https://olivierbossel.com"},"author":"Olivier Bossel <olivier.bossel@gmail.com> (https://coffeekraken.io)","license":"MIT","dependencies":{"@coffeekraken/s-code-example-component":"^2.0.0-beta.1","@coffeekraken/s-dashboard":"^2.0.0-beta.1","@coffeekraken/s-doc":"^2.0.0-beta.1","@coffeekraken/s-docmap":"^2.0.0-beta.1","@coffeekraken/s-filtrable-input-component":"^2.0.0-beta.1","@coffeekraken/s-front":"^2.0.0-beta.1","@coffeekraken/s-highlight-feature":"^2.0.0-beta.1","@coffeekraken/s-lit-component":"^2.0.0-beta.1","@coffeekraken/s-pack-essentials":"^2.0.0-beta.1","@coffeekraken/s-parallax-feature":"^2.0.0-beta.1","@coffeekraken/s-static-builder":"^2.0.0-beta.1","@coffeekraken/s-sugarcss-plugin":"^2.0.0-beta.1","@coffeekraken/s-theme":"^2.0.0-beta.1","@coffeekraken/sugar":"^2.0.0-beta.1"},"exports":{"./shared/*":{"require":"./dist/pkg/cjs/shared/*.js","import":"./dist/pkg/esm/shared/*.js"},"./node/*":{"require":"./dist/pkg/cjs/node/*.js","import":"./dist/pkg/esm/node/*.js"},"./js/*":{"require":"./dist/pkg/cjs/js/*.js","import":"./dist/pkg/esm/js/*.js"}},"homepage":"https://coffeekraken.io"}}`),
  document.env || {}
);
(async () => {
  SFeature.setDefaultProps("*", {
    mountWhen: "nearViewport"
  });
  SLitComponent.setDefaultProps("*", {
    mountWhen: "nearViewport"
  });
  SLitComponent.setDefaultProps(["s-code-example"], {
    responsive: {
      mobile: {
        lines: 5
      }
    }
  });
  SFront.init();
  SPackEssentials();
  __smoothScroll();
  define$3();
  define$1();
  define$9();
  define$2();
  define$6();
  define$4();
  define$5({
    mountWhen: "direct",
    endpoints: {
      base: document.location.origin.includes(":5173") ? "http://localhost:9191/api/doc" : "/api/doc"
    },
    icons: {
      file: '<i class="s-icon:file"></i>',
      search: '<i class="s-icon:search"></i>',
      enterFullscreen: '<i class="s-icon:enter-fullscreen"></i>',
      exitFullscreen: '<i class="s-icon:exit-fullscreen"></i>',
      menu: '<i class="s-icon:documentation"></i>'
    }
  });
  const $slider = document.querySelector("[welcome-slider]");
  $slider && new WelcomeSlider($slider);
  new SDashboard();
})();
export {
  format$1 as A,
  SComponentUtils as B,
  __querySelectorUp as C,
  __camelCase as D,
  __parse as E,
  SLitComponent as F,
  css$1 as G,
  unsafeCSS as H,
  __scrollTo as I,
  html as J,
  __fastdom as K,
  __clearTransmations as L,
  autoResizeFeature as M,
  confirmButtonFeature as N,
  SSugarConfig as O,
  getAugmentedNamespace as P,
  getDefaultExportFromCjs as Q,
  require$$0$4 as R,
  SStdio as S,
  objectHash as T,
  commonjsGlobal as U,
  __isNode$2 as _,
  SInterface as a,
  SFeature as b,
  __deepMerge as c,
  __querySelectorLive as d,
  __unique as e,
  __getCookie as f,
  get as g,
  __scrollSpy as h,
  __wait as i,
  SPromise as j,
  fromString as k,
  rotateY as l,
  rotateZ as m,
  multiply as n,
  toString$1 as o,
  __uniqid as p,
  STheme as q,
  rotateX as r,
  __injectStyle as s,
  translate3d as t,
  __makeFloat as u,
  __i18n as v,
  __isPlainObject as w,
  __isInteger as x,
  __isColor as y,
  SClass as z
};
